// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

// ReplaceContentsBytesAsync: same as g_file_replace_contents_async() but takes
// a #GBytes input instead. This function will keep a ref on contents until the
// operation is done. Unlike g_file_replace_contents_async() this allows
// forgetting about the content without waiting for the callback.
//
// When this operation has completed, callback will be called with user_user
// data, and the operation can be finalized with
// g_file_replace_contents_finish().
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - contents: #GBytes.
//    - etag (optional): new [entity tag][gfile-etag] for the file, or NULL.
//    - makeBackup: TRUE if a backup should be created.
//    - flags: set of CreateFlags.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) ReplaceContentsBytesAsync(ctx context.Context, contents *glib.Bytes, etag string, makeBackup bool, flags FileCreateFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.GBytes             // out
	var _arg2 *C.char               // out
	var _arg3 C.gboolean            // out
	var _arg4 C.GFileCreateFlags    // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(contents)))
	if etag != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if makeBackup {
		_arg3 = C.TRUE
	}
	_arg4 = C.GFileCreateFlags(flags)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_replace_contents_bytes_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

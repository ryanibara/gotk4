// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// char* _gotk4_gio2_AppInfo_virtual_get_commandline(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_can_delete(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_do_delete(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
import "C"

// CanDelete obtains the information whether the Info can be deleted. See
// g_app_info_delete().
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo can be deleted.
//
func (appinfo *AppInfo) CanDelete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_can_delete(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Delete tries to delete a Info.
//
// On some platforms, there may be a difference between user-defined Infos which
// can be deleted, and system-wide ones which cannot. See
// g_app_info_can_delete().
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo has been deleted.
//
func (appinfo *AppInfo) Delete() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_delete(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Commandline gets the commandline with which the application will be started.
//
// The function returns the following values:
//
//    - filename (optional): string containing the appinfo's commandline, or NULL
//      if this information is not available.
//
func (appinfo *AppInfo) Commandline() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_commandline(_arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// canDelete obtains the information whether the Info can be deleted. See
// g_app_info_delete().
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo can be deleted.
//
func (appinfo *AppInfo) canDelete() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.can_delete

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_can_delete(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// doDelete tries to delete a Info.
//
// On some platforms, there may be a difference between user-defined Infos which
// can be deleted, and system-wide ones which cannot. See
// g_app_info_can_delete().
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo has been deleted.
//
func (appinfo *AppInfo) doDelete() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.do_delete

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_do_delete(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Commandline gets the commandline with which the application will be started.
//
// The function returns the following values:
//
//    - filename (optional): string containing the appinfo's commandline, or NULL
//      if this information is not available.
//
func (appinfo *AppInfo) commandline() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_commandline

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_commandline(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// AppInfoResetTypeAssociations removes all changes to the type associations
// done by g_app_info_set_as_default_for_type(),
// g_app_info_set_as_default_for_extension(), g_app_info_add_supports_type() or
// g_app_info_remove_supports_type().
//
// The function takes the following parameters:
//
//    - contentType: content type.
//
func AppInfoResetTypeAssociations(contentType string) {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_reset_type_associations(_arg1)
	runtime.KeepAlive(contentType)
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// PropagateValue gets the result of task as a #GValue, and transfers ownership
// of that value to the caller. As with g_task_return_value(), this is a generic
// low-level method; g_task_propagate_pointer() and the like will usually be
// more useful for C code.
//
// If the task resulted in an error, or was cancelled, then this will instead
// set error and return FALSE.
//
// Since this method transfers ownership of the return value (or error) to the
// caller, you may only call it once.
//
// The function returns the following values:
//
//    - value: return location for the #GValue.
//
func (task *Task) PropagateValue() (coreglib.Value, error) {
	var _arg0 *C.GTask  // out
	var _arg1 C.GValue  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))

	C.g_task_propagate_value(_arg0, &_arg1, &_cerr)
	runtime.KeepAlive(task)

	var _value coreglib.Value // out
	var _goerr error          // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// ReturnValue sets task's result to result (by copying it) and completes the
// task.
//
// If result is NULL then a #GValue of type TYPE_POINTER with a value of NULL
// will be used for the result.
//
// This is a very generic low-level method intended primarily for use by
// language bindings; for C code, g_task_return_pointer() and the like will
// normally be much easier to use.
//
// The function takes the following parameters:
//
//    - result (optional) result of a task function.
//
func (task *Task) ReturnValue(result *coreglib.Value) {
	var _arg0 *C.GTask  // out
	var _arg1 *C.GValue // out

	_arg0 = (*C.GTask)(unsafe.Pointer(coreglib.InternObject(task).Native()))
	if result != nil {
		_arg1 = (*C.GValue)(unsafe.Pointer(result.Native()))
	}

	C.g_task_return_value(_arg0, _arg1)
	runtime.KeepAlive(task)
	runtime.KeepAlive(result)
}

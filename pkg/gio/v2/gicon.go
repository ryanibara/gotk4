// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// gboolean _gotk4_gio2_Icon_virtual_equal(void* fnptr, GIcon* arg0, GIcon* arg1) {
//   return ((gboolean (*)(GIcon*, GIcon*))(fnptr))(arg0, arg1);
// };
// guint _gotk4_gio2_Icon_virtual_hash(void* fnptr, GIcon* arg0) {
//   return ((guint (*)(GIcon*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeIcon = coreglib.Type(C.g_icon_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIcon, F: marshalIcon},
	})
}

// Icon is a very minimal interface for icons. It provides functions for
// checking the equality of two icons, hashing of icons and serializing an icon
// to and from strings.
//
// #GIcon does not provide the actual pixmap for the icon as this is out of
// GIO's scope, however implementations of #GIcon may contain the name of an
// icon (see Icon), or the path to an icon (see Icon).
//
// To obtain a hash of a #GIcon, see g_icon_hash().
//
// To check if two #GIcons are equal, see g_icon_equal().
//
// For serializing a #GIcon, use g_icon_serialize() and g_icon_deserialize().
//
// If you want to consume #GIcon (for example, in a toolkit) you must be
// prepared to handle at least the three following cases: Icon, Icon and Icon.
// It may also make sense to have fast-paths for other cases (like handling
// Pixbuf directly, for example) but all compliant #GIcon implementations
// outside of GIO must implement Icon.
//
// If your application or library provides one or more #GIcon implementations
// you need to ensure that your new implementation also implements Icon.
// Additionally, you must provide an implementation of g_icon_serialize() that
// gives a result that is understood by g_icon_deserialize(), yielding one of
// the built-in icon types.
//
// Icon wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Icon struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Icon)(nil)
)

// Iconner describes Icon's interface methods.
type Iconner interface {
	coreglib.Objector

	// Equal checks if two icons are equal.
	Equal(icon2 Iconner) bool
	// Serialize serializes a #GIcon into a #GVariant.
	Serialize() *glib.Variant
	// String generates a textual representation of icon that can be used for
	// serialization such as when passing icon to a different process or saving
	// it to persistent storage.
	String() string
}

var _ Iconner = (*Icon)(nil)

func wrapIcon(obj *coreglib.Object) *Icon {
	return &Icon{
		Object: obj,
	}
}

func marshalIcon(p uintptr) (interface{}, error) {
	return wrapIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Equal checks if two icons are equal.
//
// The function takes the following parameters:
//
//    - icon2 (optional): pointer to the second #GIcon.
//
// The function returns the following values:
//
//    - ok: TRUE if icon1 is equal to icon2. FALSE otherwise.
//
func (icon1 *Icon) Equal(icon2 Iconner) bool {
	var _arg0 *C.GIcon   // out
	var _arg1 *C.GIcon   // out
	var _cret C.gboolean // in

	if icon1 != nil {
		_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon1).Native()))
	}
	if icon2 != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon2).Native()))
	}

	_cret = C.g_icon_equal(_arg0, _arg1)
	runtime.KeepAlive(icon1)
	runtime.KeepAlive(icon2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal checks if two icons are equal.
//
// The function takes the following parameters:
//
//    - icon2 (optional): pointer to the second #GIcon.
//
// The function returns the following values:
//
//    - ok: TRUE if icon1 is equal to icon2. FALSE otherwise.
//
func (icon1 *Icon) equal(icon2 Iconner) bool {
	gclass := (*C.GIconIface)(coreglib.PeekParentClass(icon1))
	fnarg := gclass.equal

	var _arg0 *C.GIcon   // out
	var _arg1 *C.GIcon   // out
	var _cret C.gboolean // in

	if icon1 != nil {
		_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon1).Native()))
	}
	if icon2 != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon2).Native()))
	}

	_cret = C._gotk4_gio2_Icon_virtual_equal(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(icon1)
	runtime.KeepAlive(icon2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hash gets a hash for an icon.
//
// The function returns the following values:
//
//    - guint containing a hash for the icon, suitable for use in a Table or
//      similar data structure.
//
func (icon *Icon) hash() uint {
	gclass := (*C.GIconIface)(coreglib.PeekParentClass(icon))
	fnarg := gclass.hash

	var _arg0 *C.GIcon // out
	var _cret C.guint  // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C._gotk4_gio2_Icon_virtual_hash(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(icon)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IconHash gets a hash for an icon.
//
// The function takes the following parameters:
//
//    - icon to an icon object.
//
// The function returns the following values:
//
//    - guint containing a hash for the icon, suitable for use in a Table or
//      similar data structure.
//
func IconHash(icon unsafe.Pointer) uint {
	var _arg1 C.gconstpointer // out
	var _cret C.guint         // in

	_arg1 = (C.gconstpointer)(unsafe.Pointer(icon))

	_cret = C.g_icon_hash(_arg1)
	runtime.KeepAlive(icon)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IconIface is used to implement GIcon types for various different systems. See
// Icon and Icon for examples of how to implement this interface.
//
// An instance of this type is always passed by reference.
type IconIface struct {
	*iconIface
}

// iconIface is the struct that's finalized.
type iconIface struct {
	native *C.GIconIface
}

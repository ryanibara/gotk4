// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeResource = coreglib.Type(C.g_resource_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeResource, F: marshalResource},
	})
}

// Resource applications and libraries often contain binary or textual data that
// is really part of the application, rather than user data. For instance
// Builder .ui files, splashscreen images, GMenu markup XML, CSS files, icons,
// etc. These are often shipped as files in $datadir/appname, or manually
// included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources]
// program provide a convenient and efficient alternative to this which has some
// nice properties. You maintain the files as normal files, so its easy to edit
// them, but during the build the files are combined into a binary bundle that
// is linked into the executable. This means that loading the resource files are
// efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in
// the filesystem). It also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of
// the preprocess attribute to a comma-separated list of preprocessing options.
// The only options currently supported are:
//
// xml-stripblanks which will use the xmllint command to strip ignorable
// whitespace from the XML file. For this to work, the XMLLINT environment
// variable must be set to the full path to the xmllint executable, or xmllint
// must be in the PATH; otherwise the preprocessing step is skipped.
//
// to-pixdata (deprecated since gdk-pixbuf 2.32) which will use the
// gdk-pixbuf-pixdata command to convert images to the Pixdata format, which
// allows you to create pixbufs directly using the data inside the resource
// file, rather than an (uncompressed) copy of it. For this, the
// gdk-pixbuf-pixdata program must be in the PATH, or the GDK_PIXBUF_PIXDATA
// environment variable must be set to the full path to the gdk-pixbuf-pixdata
// executable; otherwise the resource compiler will abort. to-pixdata has been
// deprecated since gdk-pixbuf 2.32, as #GResource supports embedding modern
// image formats just as well. Instead of using it, embed a PNG or SVG file in
// your #GResource.
//
// json-stripblanks which will use the json-glib-format command to strip
// ignorable whitespace from the JSON file. For this to work, the
// JSON_GLIB_FORMAT environment variable must be set to the full path to the
// json-glib-format executable, or it must be in the PATH; otherwise the
// preprocessing step is skipped. In addition, at least version 1.6 of
// json-glib-format is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given prefix and the filename from the file element. The
// alias attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the
// [glib-compile-resources][glib-compile-resources] program which takes an XML
// file that describes the bundle, and a set of files that the XML references.
// These are combined into a binary resource bundle.
//
// An example resource description:
//
//    <?xml version="1.0" encoding="UTF-8"?>
//    <gresources>
//      <gresource prefix="/org/gtk/Example">
//        <file>data/splashscreen.png</file>
//        <file compressed="true">dialog.ui</file>
//        <file preprocess="xml-stripblanks">menumarkup.xml</file>
//        <file alias="example.css">data/example.css</file>
//      </gresource>
//    </gresources>
//
// This will create a resource bundle with the following files:
//
//    /org/gtk/Example/data/splashscreen.png
//    /org/gtk/Example/dialog.ui
//    /org/gtk/Example/menumarkup.xml
//    /org/gtk/Example/example.css
//
// Note that all resources in the process share the same namespace, so use
// Java-style path prefixes (like in the above example) to avoid conflicts.
//
// You can then use [glib-compile-resources][glib-compile-resources] to compile
// the XML to a binary bundle that you can load with g_resource_load(). However,
// its more common to use the --generate-source and --generate-header arguments
// to create a source file and header to link directly into your application.
// This will generate get_resource(), register_resource() and
// unregister_resource() functions, prefixed by the --c-name argument passed to
// [glib-compile-resources][glib-compile-resources]. get_resource() returns the
// generated #GResource object. The register and unregister functions register
// the resource so its files can be accessed using g_resources_lookup_data().
//
// Once a #GResource has been created and registered all the data in it can be
// accessed globally in the process by using API calls like
// g_resources_open_stream() to stream the data or g_resources_lookup_data() to
// get a direct pointer to the data. You can also use URIs like
// "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access the
// resource data.
//
// Some higher-level APIs, such as Application, will automatically load
// resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
//
// There are two forms of the generated source, the default version uses the
// compiler support for constructor and destructor functions (where available)
// to automatically create and register the #GResource on startup or library
// load time. If you pass --manual-register, two functions to
// register/unregister the resource are created instead. This requires an
// explicit initialization call in your application/library, but it works on all
// platforms, even on the minor ones where constructors are not supported.
// (Constructor support is available for at least Win32, Mac OS and Linux.)
//
// Note that resource data can point directly into the data segment of e.g. a
// library, so if you are unloading libraries during runtime you need to be very
// careful with keeping around pointers to data from a resource, as this goes
// away when the library is unloaded. However, in practice this is not generally
// a problem, since most resource accesses are for your own resources, and
// resource data is often used once, during parsing, and then released.
//
// When debugging a program or testing a change to an installed version, it is
// often useful to be able to replace resources in the program or library,
// without recompiling, for debugging or quick hacking and testing purposes.
// Since GLib 2.50, it is possible to use the G_RESOURCE_OVERLAYS environment
// variable to selectively overlay resources with replacements from the
// filesystem. It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions to
// perform during resource lookups. It is ignored when running in a setuid
// process.
//
// A substitution has the form
//
//    /org/gtk/libgtk=/home/desrt/gtk-overlay
//
// The part before the = is the resource subpath for which the overlay applies.
// The part after is a filesystem path which contains files and subdirectories
// as you would like to be loaded as resources with the equivalent names.
//
// In the example above, if an application tried to load a resource with the
// resource path /org/gtk/libgtk/ui/gtkdialog.ui then GResource would check the
// filesystem path /home/desrt/gtk-overlay/ui/gtkdialog.ui. If a file was found
// there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash
// before the '='. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
//
// An instance of this type is always passed by reference.
type Resource struct {
	*resource
}

// resource is the struct that's finalized.
type resource struct {
	native *C.GResource
}

func marshalResource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Resource{&resource{(*C.GResource)(b)}}, nil
}

// NewResourceFromData constructs a struct Resource.
func NewResourceFromData(data *glib.Bytes) (*Resource, error) {
	var _arg1 *C.GBytes    // out
	var _cret *C.GResource // in
	var _cerr *C.GError    // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))

	_cret = C.g_resource_new_from_data(_arg1, &_cerr)
	runtime.KeepAlive(data)

	var _resource *Resource // out
	var _goerr error        // out

	_resource = (*Resource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_resource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_resource_unref((*C.GResource)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _resource, _goerr
}

// EnumerateChildren returns all the names of children at the specified path in
// the resource. The return result is a NULL terminated list of strings which
// should be released with g_strfreev().
//
// If path is invalid or does not exist in the #GResource,
// G_RESOURCE_ERROR_NOT_FOUND will be returned.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//    - path: pathname inside the resource.
//    - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//    - utf8s: array of constant strings.
//
func (resource *Resource) EnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret **C.char               // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resource_enumerate_children(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// Info looks for a file at the specified path in the resource and if found
// returns information about it.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//    - path: pathname inside the resource.
//    - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//    - size (optional): location to place the length of the contents of the
//      file, or NULL if the length is not needed.
//    - flags (optional): location to place the flags about the file, or NULL if
//      the length is not needed.
//
func (resource *Resource) Info(path string, lookupFlags ResourceLookupFlags) (uint, uint32, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _arg3 C.gsize                // in
	var _arg4 C.guint32              // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	C.g_resource_get_info(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _size uint    // out
	var _flags uint32 // out
	var _goerr error  // out

	_size = uint(_arg3)
	_flags = uint32(_arg4)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _size, _flags, _goerr
}

// LookupData looks for a file at the specified path in the resource and returns
// a #GBytes that lets you directly access the data in memory.
//
// The data is always followed by a zero byte, so you can safely use the data as
// a C string. However, that byte is not included in the size of the GBytes.
//
// For uncompressed resource files this is a pointer directly into the resource
// bundle, which is typically in some readonly data section in the program
// binary. For compressed files we allocate memory on the heap and automatically
// uncompress the data.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//    - path: pathname inside the resource.
//    - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//    - bytes or NULL on error. Free the returned object with g_bytes_unref().
//
func (resource *Resource) LookupData(path string, lookupFlags ResourceLookupFlags) (*glib.Bytes, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret *C.GBytes              // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resource_lookup_data(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// OpenStream looks for a file at the specified path in the resource and returns
// a Stream that lets you read the data.
//
// lookup_flags controls the behaviour of the lookup.
//
// The function takes the following parameters:
//
//    - path: pathname inside the resource.
//    - lookupFlags: LookupFlags.
//
// The function returns the following values:
//
//    - inputStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (resource *Resource) OpenStream(path string, lookupFlags ResourceLookupFlags) (InputStreamer, error) {
	var _arg0 *C.GResource           // out
	var _arg1 *C.char                // out
	var _arg2 C.GResourceLookupFlags // out
	var _cret *C.GInputStream        // in
	var _cerr *C.GError              // in

	_arg0 = (*C.GResource)(gextras.StructNative(unsafe.Pointer(resource)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResourceLookupFlags(lookupFlags)

	_cret = C.g_resource_open_stream(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resource)
	runtime.KeepAlive(path)
	runtime.KeepAlive(lookupFlags)

	var _inputStream InputStreamer // out
	var _goerr error               // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.InputStreamer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(InputStreamer)
			return ok
		})
		rv, ok := casted.(InputStreamer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
		}
		_inputStream = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _inputStream, _goerr
}

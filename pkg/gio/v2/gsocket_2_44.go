// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// SendMessages: send multiple data messages from socket in one go. This is the
// most complicated and fully-featured version of this call. For easier use, see
// g_socket_send(), g_socket_send_to(), and g_socket_send_message().
//
// messages must point to an array of Message structs and num_messages must be
// the length of this array. Each Message contains an address to send the data
// to, and a pointer to an array of Vector structs to describe the buffers that
// the data to be sent for each message will be gathered from. Using multiple
// Vectors is more memory-efficient than manually copying data from multiple
// sources into a single buffer, and more network-efficient than making multiple
// calls to g_socket_send(). Sending multiple messages in one go avoids the
// overhead of making a lot of syscalls in scenarios where a lot of data packets
// need to be sent (e.g. high-bandwidth video streaming over RTP/UDP), or where
// the same data needs to be sent to multiple recipients.
//
// flags modify how the message is sent. The commonly available arguments for
// this are available in the MsgFlags enum, but the values there are the same as
// the system values, and the flags are passed in as-is, so you can pass in
// system-specific flags too.
//
// If the socket is in blocking mode the call will block until there is space
// for all the data in the socket queue. If there is no space available and the
// socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error will be
// returned if no data was written at all, otherwise the number of messages sent
// will be returned. To be notified when space is available, wait for the
// G_IO_OUT condition. Note though that you may still receive
// G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously
// notified of a G_IO_OUT condition. (On Windows in particular, this is very
// common due to the way the underlying APIs work.)
//
// On error -1 is returned and error is set accordingly. An error will only be
// returned if zero messages could be sent; otherwise the number of messages
// successfully sent before the error will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - messages: array of Message structs.
//    - flags: int containing MsgFlags flags, which may additionally contain
//      other platform specific flags
//      (http://man7.org/linux/man-pages/man2/recv.2.html).
//
// The function returns the following values:
//
//    - gint: number of messages sent, or -1 on error. Note that the number of
//      messages sent may be smaller than num_messages if the socket is
//      non-blocking or if num_messages was larger than UIO_MAXIOV (1024), in
//      which case the caller may re-try to send the remaining messages.
//
func (socket *Socket) SendMessages(ctx context.Context, messages []OutputMessage, flags int) (int, error) {
	var _arg0 *C.GSocket        // out
	var _arg4 *C.GCancellable   // out
	var _arg1 *C.GOutputMessage // out
	var _arg2 C.guint
	var _arg3 C.gint    // out
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.guint)(len(messages))
	_arg1 = (*C.GOutputMessage)(C.calloc(C.size_t(len(messages)), C.size_t(C.sizeof_GOutputMessage)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputMessage)(_arg1), len(messages))
		for i := range messages {
			out[i] = *(*C.GOutputMessage)(gextras.StructNative(unsafe.Pointer((&messages[i]))))
		}
	}
	_arg3 = C.gint(flags)

	_cret = C.g_socket_send_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

// ConnectToURI: this is a helper function for g_socket_client_connect().
//
// Attempts to create a TCP connection with a network URI.
//
// uri may be any valid URI containing an "authority" (hostname/port) component.
// If a port is not specified in the URI, default_port will be used. TLS will be
// negotiated if Client:tls is TRUE. (Client does not know to automatically
// assume TLS for certain URI schemes.)
//
// Using this rather than g_socket_client_connect() or
// g_socket_client_connect_to_host() allows Client to determine when to use
// application-specific proxy protocols.
//
// Upon a successful connection, a new Connection is constructed and returned.
// The caller owns this new object and must drop their reference to it when
// finished with it.
//
// In the event of any failure (DNS error, service not found, no hosts
// connectable) NULL is returned and error (if non-NULL) is set accordingly.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - uri: network URI.
//    - defaultPort: default port to connect to.
//
// The function returns the following values:
//
//    - socketConnection on success, NULL on error.
//
func (client *SocketClient) ConnectToURI(ctx context.Context, uri string, defaultPort uint16) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg3 *C.GCancellable      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.guint16            // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(defaultPort)

	_cret = C.g_socket_client_connect_to_uri(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// ConnectToURIAsync: this is the asynchronous version of
// g_socket_client_connect_to_uri().
//
// When the operation is finished callback will be called. You can then call
// g_socket_client_connect_to_uri_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - uri: network uri.
//    - defaultPort: default port to connect to.
//    - callback (optional): ReadyCallback.
//
func (client *SocketClient) ConnectToURIAsync(ctx context.Context, uri string, defaultPort uint16, callback AsyncReadyCallback) {
	var _arg0 *C.GSocketClient      // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.guint16             // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(defaultPort)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_socket_client_connect_to_uri_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(client)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(defaultPort)
	runtime.KeepAlive(callback)
}

// ConnectToURIFinish finishes an async connect operation. See
// g_socket_client_connect_to_uri_async().
//
// The function takes the following parameters:
//
//    - result: Result.
//
// The function returns the following values:
//
//    - socketConnection on success, NULL on error.
//
func (client *SocketClient) ConnectToURIFinish(result AsyncResulter) (*SocketConnection, error) {
	var _arg0 *C.GSocketClient     // out
	var _arg1 *C.GAsyncResult      // out
	var _cret *C.GSocketConnection // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_socket_client_connect_to_uri_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(client)
	runtime.KeepAlive(result)

	var _socketConnection *SocketConnection // out
	var _goerr error                        // out

	_socketConnection = wrapSocketConnection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _socketConnection, _goerr
}

// EnableProxy gets the proxy enable state; see
// g_socket_client_set_enable_proxy().
//
// The function returns the following values:
//
//    - ok: whether proxying is enabled.
//
func (client *SocketClient) EnableProxy() bool {
	var _arg0 *C.GSocketClient // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_enable_proxy(_arg0)
	runtime.KeepAlive(client)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Timeout gets the I/O timeout time for sockets created by client.
//
// See g_socket_client_set_timeout() for details.
//
// The function returns the following values:
//
//    - guint: timeout in seconds.
//
func (client *SocketClient) Timeout() uint {
	var _arg0 *C.GSocketClient // out
	var _cret C.guint          // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_timeout(_arg0)
	runtime.KeepAlive(client)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetEnableProxy sets whether or not client attempts to make connections via a
// proxy server. When enabled (the default), Client will use a Resolver to
// determine if a proxy protocol such as SOCKS is needed, and automatically do
// the necessary proxy negotiation.
//
// See also g_socket_client_set_proxy_resolver().
//
// The function takes the following parameters:
//
//    - enable: whether to enable proxies.
//
func (client *SocketClient) SetEnableProxy(enable bool) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.g_socket_client_set_enable_proxy(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(enable)
}

// SetTimeout sets the I/O timeout for sockets created by client. timeout is a
// time in seconds, or 0 for no timeout (the default).
//
// The timeout value affects the initial connection attempt as well, so setting
// this may cause calls to g_socket_client_connect(), etc, to fail with
// G_IO_ERROR_TIMED_OUT.
//
// The function takes the following parameters:
//
//    - timeout: timeout.
//
func (client *SocketClient) SetTimeout(timeout uint) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = C.guint(timeout)

	C.g_socket_client_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(timeout)
}

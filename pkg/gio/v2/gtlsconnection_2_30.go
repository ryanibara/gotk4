// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// Database gets the certificate database that conn uses to verify peer
// certificates. See g_tls_connection_set_database().
//
// The function returns the following values:
//
//    - tlsDatabase (optional): certificate database that conn uses or NULL.
//
func (conn *TLSConnection) Database() TLSDatabaser {
	var _arg0 *C.GTlsConnection // out
	var _cret *C.GTlsDatabase   // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_database(_arg0)
	runtime.KeepAlive(conn)

	var _tlsDatabase TLSDatabaser // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(TLSDatabaser)
				return ok
			})
			rv, ok := casted.(TLSDatabaser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.TLSDatabaser")
			}
			_tlsDatabase = rv
		}
	}

	return _tlsDatabase
}

// Interaction: get the object that will be used to interact with the user. It
// will be used for things like prompting the user for passwords. If NULL is
// returned, then no user interaction will occur for this connection.
//
// The function returns the following values:
//
//    - tlsInteraction (optional): interaction object.
//
func (conn *TLSConnection) Interaction() *TLSInteraction {
	var _arg0 *C.GTlsConnection  // out
	var _cret *C.GTlsInteraction // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))

	_cret = C.g_tls_connection_get_interaction(_arg0)
	runtime.KeepAlive(conn)

	var _tlsInteraction *TLSInteraction // out

	if _cret != nil {
		_tlsInteraction = wrapTLSInteraction(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _tlsInteraction
}

// SetDatabase sets the certificate database that is used to verify peer
// certificates. This is set to the default database by default. See
// g_tls_backend_get_default_database(). If set to NULL, then peer certificate
// validation will always set the G_TLS_CERTIFICATE_UNKNOWN_CA error (meaning
// Connection::accept-certificate will always be emitted on client-side
// connections, unless that bit is not set in
// ClientConnection:validation-flags).
//
// The function takes the following parameters:
//
//    - database (optional): Database.
//
func (conn *TLSConnection) SetDatabase(database TLSDatabaser) {
	var _arg0 *C.GTlsConnection // out
	var _arg1 *C.GTlsDatabase   // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if database != nil {
		_arg1 = (*C.GTlsDatabase)(unsafe.Pointer(coreglib.InternObject(database).Native()))
	}

	C.g_tls_connection_set_database(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(database)
}

// SetInteraction: set the object that will be used to interact with the user.
// It will be used for things like prompting the user for passwords.
//
// The interaction argument will normally be a derived subclass of Interaction.
// NULL can also be provided if no user interaction should occur for this
// connection.
//
// The function takes the following parameters:
//
//    - interaction (optional) object, or NULL.
//
func (conn *TLSConnection) SetInteraction(interaction *TLSInteraction) {
	var _arg0 *C.GTlsConnection  // out
	var _arg1 *C.GTlsInteraction // out

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	if interaction != nil {
		_arg1 = (*C.GTlsInteraction)(unsafe.Pointer(coreglib.InternObject(interaction).Native()))
	}

	C.g_tls_connection_set_interaction(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(interaction)
}

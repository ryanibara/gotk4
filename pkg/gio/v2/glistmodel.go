// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_ListModel_ConnectItemsChanged(gpointer, guint, guint, guint, guintptr);
import "C"

// GType values.
var (
	GTypeListModel = coreglib.Type(C.g_list_model_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeListModel, F: marshalListModel},
	})
}

// ListModel is an interface that represents a mutable list of #GObjects. Its
// main intention is as a model for various widgets in user interfaces, such as
// list views, but it can also be used as a convenient method of returning lists
// of data, with support for updates.
//
// Each object in the list may also report changes in itself via some mechanism
// (normally the #GObject::notify signal). Taken together with the
// Model::items-changed signal, this provides for a list that can change its
// membership, and in which the members can change their individual properties.
//
// A good example would be the list of visible wireless network access points,
// where each access point can report dynamic properties such as signal
// strength.
//
// It is important to note that the Model itself does not report changes to the
// individual items. It only reports changes to the list membership. If you want
// to observe changes to the objects themselves then you need to connect signals
// to the objects that you are interested in.
//
// All items in a Model are of (or derived from) the same type.
// g_list_model_get_item_type() returns that type. The type may be an interface,
// in which case all objects in the list must implement it.
//
// The semantics are close to that of an array: g_list_model_get_n_items()
// returns the number of items in the list and g_list_model_get_item() returns
// an item at a (0-based) position. In order to allow implementations to
// calculate the list length lazily, you can also iterate over items: starting
// from 0, repeatedly call g_list_model_get_item() until it returns NULL.
//
// An implementation may create objects lazily, but must take care to return the
// same object for a given position until all references to it are gone.
//
// On the other side, a consumer is expected only to hold references on objects
// that are currently "user visible", in order to facilitate the maximum level
// of laziness in the implementation of the list and to reduce the required
// number of signal connections at a given time.
//
// This interface is intended only to be used from a single thread. The thread
// in which it is appropriate to use it depends on the particular
// implementation, but typically it will be from the thread that owns the
// [thread-default main context][g-main-context-push-thread-default] in effect
// at the time that the model was created.
//
// ListModel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ListModel)(nil)
)

// ListModeller describes ListModel's interface methods.
type ListModeller interface {
	coreglib.Objector

	// ItemType gets the type of the items in list.
	ItemType() coreglib.Type
	// NItems gets the number of items in list.
	NItems() uint
	// Item: get the item at position.
	Item(position uint) *coreglib.Object
	// ItemsChanged emits the Model::items-changed signal on list.
	ItemsChanged(position, removed, added uint)

	// Items-changed: this signal is emitted whenever items were added to or
	// removed from list.
	ConnectItemsChanged(func(position, removed, added uint)) coreglib.SignalHandle
}

var _ ListModeller = (*ListModel)(nil)

func wrapListModel(obj *coreglib.Object) *ListModel {
	return &ListModel{
		Object: obj,
	}
}

func marshalListModel(p uintptr) (interface{}, error) {
	return wrapListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectItemsChanged: this signal is emitted whenever items were added to or
// removed from list. At position, removed items were removed and added items
// were added in their place.
//
// Note: If removed != added, the positions of all later items in the model
// change.
func (list *ListModel) ConnectItemsChanged(f func(position, removed, added uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(list, "items-changed", false, unsafe.Pointer(C._gotk4_gio2_ListModel_ConnectItemsChanged), f)
}

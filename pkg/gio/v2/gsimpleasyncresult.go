// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gsimpleasyncresult.go.
var GTypeSimpleAsyncResult = coreglib.Type(C.g_simple_async_result_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeSimpleAsyncResult, F: marshalSimpleAsyncResult},
	})
}

// SimpleAsyncResultOverrider contains methods that are overridable.
type SimpleAsyncResultOverrider interface {
}

// SimpleAsyncResult as of GLib 2.46, AsyncResult is deprecated in favor of
// #GTask, which provides a simpler API.
//
// AsyncResult implements Result.
//
// GSimpleAsyncResult handles ReadyCallbacks, error reporting, operation
// cancellation and the final state of an operation, completely transparent to
// the application. Results can be returned as a pointer e.g. for functions that
// return data that is collected asynchronously, a boolean value for checking
// the success or failure of an operation, or a #gssize for operations which
// return the number of bytes modified by the operation; all of the simple
// return cases are covered.
//
// Most of the time, an application will not need to know of the details of this
// API; it is handled transparently, and any necessary operations are handled by
// Result's interface. However, if implementing a new GIO module, for writing
// language bindings, or for complex applications that need better control of
// how asynchronous operations are completed, it is important to understand this
// functionality.
//
// GSimpleAsyncResults are tagged with the calling function to ensure that
// asynchronous functions and their finishing functions are used together
// correctly.
//
// To create a new AsyncResult, call g_simple_async_result_new(). If the result
// needs to be created for a #GError, use g_simple_async_result_new_from_error()
// or g_simple_async_result_new_take_error(). If a #GError is not available
// (e.g. the asynchronous operation's doesn't take a #GError argument), but the
// result still needs to be created for an error condition, use
// g_simple_async_result_new_error() (or g_simple_async_result_set_error_va() if
// your application or binding requires passing a variable argument list
// directly), and the error can then be propagated through the use of
// g_simple_async_result_propagate_error().
//
// An asynchronous operation can be made to ignore a cancellation event by
// calling g_simple_async_result_set_handle_cancellation() with a AsyncResult
// for the operation and FALSE. This is useful for operations that are dangerous
// to cancel, such as close (which would cause a leak if cancelled before being
// run).
//
// GSimpleAsyncResult can integrate into GLib's event loop, Loop, or it can use
// #GThreads. g_simple_async_result_complete() will finish an I/O task directly
// from the point where it is called. g_simple_async_result_complete_in_idle()
// will finish it from an idle handler in the [thread-default main
// context][g-main-context-push-thread-default] where the AsyncResult was
// created. g_simple_async_result_run_in_thread() will run the job in a separate
// thread and then use g_simple_async_result_complete_in_idle() to deliver the
// result.
//
// To set the results of an asynchronous function,
// g_simple_async_result_set_op_res_gpointer(),
// g_simple_async_result_set_op_res_gboolean(), and
// g_simple_async_result_set_op_res_gssize() are provided, setting the
// operation's result to a gpointer, gboolean, or gssize, respectively.
//
// Likewise, to get the result of an asynchronous function,
// g_simple_async_result_get_op_res_gpointer(),
// g_simple_async_result_get_op_res_gboolean(), and
// g_simple_async_result_get_op_res_gssize() are provided, getting the
// operation's result as a gpointer, gboolean, and gssize, respectively.
//
// For the details of the requirements implementations must respect, see Result.
// A typical implementation of an asynchronous operation using
// GSimpleAsyncResult looks something like this:
//
//    static void
//    baked_cb (Cake    *cake,
//              gpointer user_data)
//    {
//      // In this example, this callback is not given a reference to the cake,
//      // so the GSimpleAsyncResult has to take a reference to it.
//      GSimpleAsyncResult *result = user_data;
//
//      if (cake == NULL)
//        g_simple_async_result_set_error (result,
//                                         BAKER_ERRORS,
//                                         BAKER_ERROR_NO_FLOUR,
//                                         "Go to the supermarket");
//      else
//        g_simple_async_result_set_op_res_gpointer (result,
//                                                   g_object_ref (cake),
//                                                   g_object_unref);
//
//
//      // In this example, we assume that baked_cb is called as a callback from
//      // the mainloop, so it's safe to complete the operation synchronously here.
//      // If, however, _baker_prepare_cake () might call its callback without
//      // first returning to the mainloop — inadvisable, but some APIs do so —
//      // we would need to use g_simple_async_result_complete_in_idle().
//      g_simple_async_result_complete (result);
//      g_object_unref (result);
//    }
//
//    void
//    baker_bake_cake_async (Baker              *self,
//                           guint               radius,
//                           GAsyncReadyCallback callback,
//                           gpointer            user_data)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      if (radius < 3)
//        {
//          g_simple_async_report_error_in_idle (G_OBJECT (self),
//                                               callback,
//                                               user_data,
//                                               BAKER_ERRORS,
//                                               BAKER_ERROR_TOO_SMALL,
//                                               "ucm radius cakes are silly",
//                                               radius);
//          return;
//        }
//
//      simple = g_simple_async_result_new (G_OBJECT (self),
//                                          callback,
//                                          user_data,
//                                          baker_bake_cake_async);
//      cake = _baker_get_cached_cake (self, radius);
//
//      if (cake != NULL)
//        {
//          g_simple_async_result_set_op_res_gpointer (simple,
//                                                     g_object_ref (cake),
//                                                     g_object_unref);
//          g_simple_async_result_complete_in_idle (simple);
//          g_object_unref (simple);
//          // Drop the reference returned by _baker_get_cached_cake();
//          // the GSimpleAsyncResult has taken its own reference.
//          g_object_unref (cake);
//          return;
//        }
//
//      _baker_prepare_cake (self, radius, baked_cb, simple);
//    }
//
//    Cake *
//    baker_bake_cake_finish (Baker        *self,
//                            GAsyncResult *result,
//                            GError      **error)
//    {
//      GSimpleAsyncResult *simple;
//      Cake               *cake;
//
//      g_return_val_if_fail (g_simple_async_result_is_valid (result,
//                                                            G_OBJECT (self),
//                                                            baker_bake_cake_async),
//                            NULL);
//
//      simple = (GSimpleAsyncResult *) result;
//
//      if (g_simple_async_result_propagate_error (simple, error))
//        return NULL;
//
//      cake = CAKE (g_simple_async_result_get_op_res_gpointer (simple));
//      return g_object_ref (cake);
//    }.
type SimpleAsyncResult struct {
	_ [0]func() // equal guard
	*coreglib.Object

	AsyncResult
}

var (
	_ coreglib.Objector = (*SimpleAsyncResult)(nil)
)

func classInitSimpleAsyncResulter(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapSimpleAsyncResult(obj *coreglib.Object) *SimpleAsyncResult {
	return &SimpleAsyncResult{
		Object: obj,
		AsyncResult: AsyncResult{
			Object: obj,
		},
	}
}

func marshalSimpleAsyncResult(p uintptr) (interface{}, error) {
	return wrapSimpleAsyncResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Complete completes an asynchronous I/O job immediately. Must be called in the
// thread where the asynchronous result was to be delivered, as it invokes the
// callback directly. If you are in a different thread use
// g_simple_async_result_complete_in_idle().
//
// Calling this function takes a reference to simple for as long as is needed to
// complete the call.
//
// Deprecated: Use #GTask instead.
func (simple *SimpleAsyncResult) Complete() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("complete", args[:], nil)

	runtime.KeepAlive(simple)
}

// CompleteInIdle completes an asynchronous function in an idle handler in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that simple was initially created in (and re-pushes that context
// around the invocation of the callback).
//
// Calling this function takes a reference to simple for as long as is needed to
// complete the call.
//
// Deprecated: Use #GTask instead.
func (simple *SimpleAsyncResult) CompleteInIdle() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("complete_in_idle", args[:], nil)

	runtime.KeepAlive(simple)
}

// OpResGboolean gets the operation result boolean from within the asynchronous
// result.
//
// Deprecated: Use #GTask and g_task_propagate_boolean() instead.
//
// The function returns the following values:
//
//    - ok: TRUE if the operation's result was TRUE, FALSE if the operation's
//      result was FALSE.
//
func (simple *SimpleAsyncResult) OpResGboolean() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("get_op_res_gboolean", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(simple)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OpResGssize gets a gssize from the asynchronous result.
//
// Deprecated: Use #GTask and g_task_propagate_int() instead.
//
// The function returns the following values:
//
//    - gssize returned from the asynchronous function.
//
func (simple *SimpleAsyncResult) OpResGssize() int {
	var args [1]girepository.Argument
	var _arg0 *C.void  // out
	var _cret C.gssize // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("get_op_res_gssize", args[:], nil)
	_cret = *(*C.gssize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(simple)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// PropagateError propagates an error from within the simple asynchronous result
// to a given destination.
//
// If the #GCancellable given to a prior call to
// g_simple_async_result_set_check_cancellable() is cancelled then this function
// will return TRUE with dest set appropriately.
//
// Deprecated: Use #GTask instead.
func (simple *SimpleAsyncResult) PropagateError() error {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cerr *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("propagate_error", args[:], nil)

	runtime.KeepAlive(simple)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetCheckCancellable sets a #GCancellable to check before dispatching results.
//
// This function has one very specific purpose: the provided cancellable is
// checked at the time of g_simple_async_result_propagate_error() If it is
// cancelled, these functions will return an "Operation was cancelled" error
// (G_IO_ERROR_CANCELLED).
//
// Implementors of cancellable asynchronous functions should use this in order
// to provide a guarantee to their callers that cancelling an async operation
// will reliably result in an error being returned for that operation (even if a
// positive result for the operation has already been sent as an idle to the
// main context to be dispatched).
//
// The checking described above is done regardless of any call to the unrelated
// g_simple_async_result_set_handle_cancellation() function.
//
// Deprecated: Use #GTask instead.
//
// The function takes the following parameters:
//
//    - ctx (optional) to check, or NULL to unset.
//
func (simple *SimpleAsyncResult) SetCheckCancellable(ctx context.Context) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.void)(unsafe.Pointer(cancellable.Native()))
	}
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("set_check_cancellable", args[:], nil)

	runtime.KeepAlive(simple)
	runtime.KeepAlive(ctx)
}

// SetFromError sets the result from a #GError.
//
// Deprecated: Use #GTask and g_task_return_error() instead.
//
// The function takes the following parameters:
//
//    - err: #GError.
//
func (simple *SimpleAsyncResult) SetFromError(err error) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	if err != nil {
		_arg1 = (*C.void)(gerror.New(err))
	}
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("set_from_error", args[:], nil)

	runtime.KeepAlive(simple)
	runtime.KeepAlive(err)
}

// SetHandleCancellation sets whether to handle cancellation within the
// asynchronous operation.
//
// This function has nothing to do with
// g_simple_async_result_set_check_cancellable(). It only refers to the
// #GCancellable passed to g_simple_async_result_run_in_thread().
//
// Deprecated: since version 2.46.
//
// The function takes the following parameters:
//
//    - handleCancellation: #gboolean.
//
func (simple *SimpleAsyncResult) SetHandleCancellation(handleCancellation bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	if handleCancellation {
		_arg1 = C.TRUE
	}
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("set_handle_cancellation", args[:], nil)

	runtime.KeepAlive(simple)
	runtime.KeepAlive(handleCancellation)
}

// SetOpResGboolean sets the operation result to a boolean within the
// asynchronous result.
//
// Deprecated: Use #GTask and g_task_return_boolean() instead.
//
// The function takes the following parameters:
//
//    - opRes: #gboolean.
//
func (simple *SimpleAsyncResult) SetOpResGboolean(opRes bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	if opRes {
		_arg1 = C.TRUE
	}
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("set_op_res_gboolean", args[:], nil)

	runtime.KeepAlive(simple)
	runtime.KeepAlive(opRes)
}

// SetOpResGssize sets the operation result within the asynchronous result to
// the given op_res.
//
// Deprecated: Use #GTask and g_task_return_int() instead.
//
// The function takes the following parameters:
//
//    - opRes: #gssize.
//
func (simple *SimpleAsyncResult) SetOpResGssize(opRes int) {
	var args [2]girepository.Argument
	var _arg0 *C.void  // out
	var _arg1 C.gssize // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(simple).Native()))
	_arg1 = C.gssize(opRes)
	*(**SimpleAsyncResult)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gio", "SimpleAsyncResult").InvokeMethod("set_op_res_gssize", args[:], nil)

	runtime.KeepAlive(simple)
	runtime.KeepAlive(opRes)
}

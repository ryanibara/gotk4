// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// GFileIOStream* _gotk4_gio2_File_virtual_create_readwrite(void* fnptr, GFile* arg0, GFileCreateFlags arg1, GCancellable* arg2, GError** arg3) {
//   return ((GFileIOStream* (*)(GFile*, GFileCreateFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_create_readwrite_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileIOStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_open_readwrite(void* fnptr, GFile* arg0, GCancellable* arg1, GError** arg2) {
//   return ((GFileIOStream* (*)(GFile*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_open_readwrite_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileIOStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_replace_readwrite(void* fnptr, GFile* arg0, char* arg1, gboolean arg2, GFileCreateFlags arg3, GCancellable* arg4, GError** arg5) {
//   return ((GFileIOStream* (*)(GFile*, char*, gboolean, GFileCreateFlags, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// GFileIOStream* _gotk4_gio2_File_virtual_replace_readwrite_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GFileIOStream* (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_eject_mountable_with_operation_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_poll_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_start_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_stop_mountable_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_File_virtual_unmount_mountable_with_operation_finish(void* fnptr, GFile* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gboolean (*)(GFile*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_File_virtual_create_readwrite_async(void* fnptr, GFile* arg0, GFileCreateFlags arg1, int arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GFileCreateFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_eject_mountable_with_operation(void* fnptr, GFile* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_open_readwrite_async(void* fnptr, GFile* arg0, int arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GFile*, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_File_virtual_poll_mountable(void* fnptr, GFile* arg0, GCancellable* arg1, GAsyncReadyCallback arg2, gpointer arg3) {
//   ((void (*)(GFile*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gio2_File_virtual_replace_readwrite_async(void* fnptr, GFile* arg0, char* arg1, gboolean arg2, GFileCreateFlags arg3, int arg4, GCancellable* arg5, GAsyncReadyCallback arg6, gpointer arg7) {
//   ((void (*)(GFile*, char*, gboolean, GFileCreateFlags, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
// };
// void _gotk4_gio2_File_virtual_start_mountable(void* fnptr, GFile* arg0, GDriveStartFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GDriveStartFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_stop_mountable(void* fnptr, GFile* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_File_virtual_unmount_mountable_with_operation(void* fnptr, GFile* arg0, GMountUnmountFlags arg1, GMountOperation* arg2, GCancellable* arg3, GAsyncReadyCallback arg4, gpointer arg5) {
//   ((void (*)(GFile*, GMountUnmountFlags, GMountOperation*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
import "C"

// CreateReadwrite creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
//
// By default files created are generally readable by everyone, but if you pass
// FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If a file or directory with this name already exists, the G_IO_ERROR_EXISTS
// error will be returned. Some file systems don't allow all file names, and may
// return an G_IO_ERROR_INVALID_FILENAME error, and if the name is too long,
// G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible too,
// and depend on what kind of filesystem the file is on.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags: set of CreateFlags.
//
// The function returns the following values:
//
//    - fileIOStream for the newly created file, or NULL on error. Free the
//      returned object with g_object_unref().
//
func (file *File) CreateReadwrite(ctx context.Context, flags FileCreateFlags) (*FileIOStream, error) {
	var _arg0 *C.GFile           // out
	var _arg2 *C.GCancellable    // out
	var _arg1 C.GFileCreateFlags // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)

	_cret = C.g_file_create_readwrite(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// CreateReadwriteAsync: asynchronously creates a new file and returns a stream
// for reading and writing to it. The file must not already exist.
//
// For more details, see g_file_create_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_create_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags: set of CreateFlags.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) CreateReadwriteAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GFileCreateFlags    // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_create_readwrite_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// CreateReadwriteFinish finishes an asynchronous file create operation started
// with g_file_create_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) CreateReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_create_readwrite_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// EjectMountableWithOperation starts an asynchronous eject on a mountable. When
// this operation has completed, callback will be called with user_user data,
// and the operation can be finalized with
// g_file_eject_mountable_with_operation_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags affecting the operation.
//    - mountOperation (optional): Operation, or NULL to avoid user interaction.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) EjectMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_eject_mountable_with_operation(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// EjectMountableWithOperationFinish finishes an asynchronous eject operation
// started by g_file_eject_mountable_with_operation().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) EjectMountableWithOperationFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_eject_mountable_with_operation_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// OpenReadwrite opens an existing file for reading and writing. The result is a
// IOStream that can be used to read and write the contents of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on. Note that in many non-local file cases read and
// write streams are not supported, so make sure you really need to do read and
// write streaming, rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) OpenReadwrite(ctx context.Context) (*FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GCancellable  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_open_readwrite(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// OpenReadwriteAsync: asynchronously opens file for reading and writing.
//
// For more details, see g_file_open_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_open_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) OpenReadwriteAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_open_readwrite_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// OpenReadwriteFinish finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) OpenReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_open_readwrite_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// PollMountable polls a file of type FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) PollMountable(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_poll_mountable(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// PollMountableFinish finishes a poll operation. See g_file_poll_mountable()
// for details.
//
// Finish an asynchronous poll operation that was polled with
// g_file_poll_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) PollMountableFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_poll_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ReplaceReadwrite returns an output stream for overwriting the file in
// readwrite mode, possibly creating a backup copy of the file first. If the
// file doesn't exist, it will be created.
//
// For details about the behaviour, see g_file_replace() which does the same
// thing but returns an output stream only.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - etag (optional): optional [entity tag][gfile-etag] for the current
//      #GFile, or LL to ignore.
//    - makeBackup: TRUE if a backup should be created.
//    - flags: set of CreateFlags.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) ReplaceReadwrite(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags) (*FileIOStream, error) {
	var _arg0 *C.GFile           // out
	var _arg4 *C.GCancellable    // out
	var _arg1 *C.char            // out
	var _arg2 C.gboolean         // out
	var _arg3 C.GFileCreateFlags // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)

	_cret = C.g_file_replace_readwrite(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// ReplaceReadwriteAsync: asynchronously overwrites the file in read-write mode,
// replacing the contents, possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_replace_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - etag (optional): [entity tag][gfile-etag] for the current #GFile, or NULL
//      to ignore.
//    - makeBackup: TRUE if a backup should be created.
//    - flags: set of CreateFlags.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) ReplaceReadwriteAsync(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gboolean            // out
	var _arg3 C.GFileCreateFlags    // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_replace_readwrite_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReplaceReadwriteFinish finishes an asynchronous file replace operation
// started with g_file_replace_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) ReplaceReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C.g_file_replace_readwrite_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// StartMountable starts a file of type FILE_TYPE_MOUNTABLE. Using
// start_operation, you can request callbacks when, for instance, passwords are
// needed during authentication.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags affecting the operation.
//    - startOperation (optional) or NULL to avoid user interaction.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) StartMountable(ctx context.Context, flags DriveStartFlags, startOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GDriveStartFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GDriveStartFlags(flags)
	if startOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(startOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_start_mountable(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startOperation)
	runtime.KeepAlive(callback)
}

// StartMountableFinish finishes a start operation. See g_file_start_mountable()
// for details.
//
// Finish an asynchronous start operation that was started with
// g_file_start_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) StartMountableFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_start_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// StopMountable stops a file of type FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_stop_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags affecting the operation.
//    - mountOperation (optional): Operation, or NULL to avoid user interaction.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) StopMountable(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_stop_mountable(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// StopMountableFinish finishes a stop operation, see g_file_stop_mountable()
// for details.
//
// Finish an asynchronous stop operation that was started with
// g_file_stop_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) StopMountableFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_stop_mountable_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SupportsThreadContexts checks if file supports [thread-default
// contexts][g-main-context-push-thread-default-context]. If this returns FALSE,
// you cannot perform asynchronous operations on file in a thread that has a
// thread-default context.
//
// The function returns the following values:
//
//    - ok: whether or not file supports thread-default contexts.
//
func (file *File) SupportsThreadContexts() bool {
	var _arg0 *C.GFile   // out
	var _cret C.gboolean // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_supports_thread_contexts(_arg0)
	runtime.KeepAlive(file)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnmountMountableWithOperation unmounts a file of type FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_unmount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags affecting the operation.
//    - mountOperation (optional): Operation, or NULL to avoid user interaction.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) UnmountMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_unmount_mountable_with_operation(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// UnmountMountableWithOperationFinish finishes an unmount operation, see
// g_file_unmount_mountable_with_operation() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable_with_operation().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) UnmountMountableWithOperationFinish(result AsyncResulter) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_file_unmount_mountable_with_operation_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// createReadwrite creates a new file and returns a stream for reading and
// writing to it. The file must not already exist.
//
// By default files created are generally readable by everyone, but if you pass
// FILE_CREATE_PRIVATE in flags the file will be made readable only to the
// current user, to the level that is supported on the target filesystem.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If a file or directory with this name already exists, the G_IO_ERROR_EXISTS
// error will be returned. Some file systems don't allow all file names, and may
// return an G_IO_ERROR_INVALID_FILENAME error, and if the name is too long,
// G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are possible too,
// and depend on what kind of filesystem the file is on.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags: set of CreateFlags.
//
// The function returns the following values:
//
//    - fileIOStream for the newly created file, or NULL on error. Free the
//      returned object with g_object_unref().
//
func (file *File) createReadwrite(ctx context.Context, flags FileCreateFlags) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create_readwrite

	var _arg0 *C.GFile           // out
	var _arg2 *C.GCancellable    // out
	var _arg1 C.GFileCreateFlags // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_create_readwrite(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// createReadwriteAsync: asynchronously creates a new file and returns a stream
// for reading and writing to it. The file must not already exist.
//
// For more details, see g_file_create_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_create_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags: set of CreateFlags.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) createReadwriteAsync(ctx context.Context, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create_readwrite_async

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GFileCreateFlags    // out
	var _arg2 C.int                 // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileCreateFlags(flags)
	_arg2 = C.int(ioPriority)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_create_readwrite_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// createReadwriteFinish finishes an asynchronous file create operation started
// with g_file_create_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) createReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.create_readwrite_finish

	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_create_readwrite_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// ejectMountableWithOperation starts an asynchronous eject on a mountable. When
// this operation has completed, callback will be called with user_user data,
// and the operation can be finalized with
// g_file_eject_mountable_with_operation_finish().
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags affecting the operation.
//    - mountOperation (optional): Operation, or NULL to avoid user interaction.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) ejectMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.eject_mountable_with_operation

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_eject_mountable_with_operation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// ejectMountableWithOperationFinish finishes an asynchronous eject operation
// started by g_file_eject_mountable_with_operation().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) ejectMountableWithOperationFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.eject_mountable_with_operation_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_eject_mountable_with_operation_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// openReadwrite opens an existing file for reading and writing. The result is a
// IOStream that can be used to read and write the contents of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on. Note that in many non-local file cases read and
// write streams are not supported, so make sure you really need to do read and
// write streaming, rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) openReadwrite(ctx context.Context) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.open_readwrite

	var _arg0 *C.GFile         // out
	var _arg1 *C.GCancellable  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C._gotk4_gio2_File_virtual_open_readwrite(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// openReadwriteAsync: asynchronously opens file for reading and writing.
//
// For more details, see g_file_open_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_open_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) openReadwriteAsync(ctx context.Context, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.open_readwrite_async

	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.int                 // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(ioPriority)
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_open_readwrite_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// openReadwriteFinish finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) openReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.open_readwrite_finish

	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_open_readwrite_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// pollMountable polls a file of type FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) pollMountable(ctx context.Context, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.poll_mountable

	var _arg0 *C.GFile              // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_poll_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// pollMountableFinish finishes a poll operation. See g_file_poll_mountable()
// for details.
//
// Finish an asynchronous poll operation that was polled with
// g_file_poll_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) pollMountableFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.poll_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_poll_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// replaceReadwrite returns an output stream for overwriting the file in
// readwrite mode, possibly creating a backup copy of the file first. If the
// file doesn't exist, it will be created.
//
// For details about the behaviour, see g_file_replace() which does the same
// thing but returns an output stream only.
//
// Note that in many non-local file cases read and write streams are not
// supported, so make sure you really need to do read and write streaming,
// rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - etag (optional): optional [entity tag][gfile-etag] for the current
//      #GFile, or LL to ignore.
//    - makeBackup: TRUE if a backup should be created.
//    - flags: set of CreateFlags.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) replaceReadwrite(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace_readwrite

	var _arg0 *C.GFile           // out
	var _arg4 *C.GCancellable    // out
	var _arg1 *C.char            // out
	var _arg2 C.gboolean         // out
	var _arg3 C.GFileCreateFlags // out
	var _cret *C.GFileIOStream   // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)

	_cret = C._gotk4_gio2_File_virtual_replace_readwrite(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// replaceReadwriteAsync: asynchronously overwrites the file in read-write mode,
// replacing the contents, possibly creating a backup copy of the file first.
//
// For more details, see g_file_replace_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_replace_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - etag (optional): [entity tag][gfile-etag] for the current #GFile, or NULL
//      to ignore.
//    - makeBackup: TRUE if a backup should be created.
//    - flags: set of CreateFlags.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) replaceReadwriteAsync(ctx context.Context, etag string, makeBackup bool, flags FileCreateFlags, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace_readwrite_async

	var _arg0 *C.GFile              // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.char               // out
	var _arg2 C.gboolean            // out
	var _arg3 C.GFileCreateFlags    // out
	var _arg4 C.int                 // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if etag != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(etag)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if makeBackup {
		_arg2 = C.TRUE
	}
	_arg3 = C.GFileCreateFlags(flags)
	_arg4 = C.int(ioPriority)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_replace_readwrite_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(etag)
	runtime.KeepAlive(makeBackup)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// replaceReadwriteFinish finishes an asynchronous file replace operation
// started with g_file_replace_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) replaceReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.replace_readwrite_finish

	var _arg0 *C.GFile         // out
	var _arg1 *C.GAsyncResult  // out
	var _cret *C.GFileIOStream // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_cret = C._gotk4_gio2_File_virtual_replace_readwrite_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileIOStream, _goerr
}

// startMountable starts a file of type FILE_TYPE_MOUNTABLE. Using
// start_operation, you can request callbacks when, for instance, passwords are
// needed during authentication.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags affecting the operation.
//    - startOperation (optional) or NULL to avoid user interaction.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) startMountable(ctx context.Context, flags DriveStartFlags, startOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.start_mountable

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GDriveStartFlags    // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GDriveStartFlags(flags)
	if startOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(startOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_start_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(startOperation)
	runtime.KeepAlive(callback)
}

// startMountableFinish finishes a start operation. See g_file_start_mountable()
// for details.
//
// Finish an asynchronous start operation that was started with
// g_file_start_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) startMountableFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.start_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_start_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// stopMountable stops a file of type FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_stop_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags affecting the operation.
//    - mountOperation (optional): Operation, or NULL to avoid user interaction.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) stopMountable(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.stop_mountable

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_stop_mountable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// stopMountableFinish finishes a stop operation, see g_file_stop_mountable()
// for details.
//
// Finish an asynchronous stop operation that was started with
// g_file_stop_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) stopMountableFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.stop_mountable_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_stop_mountable_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// unmountMountableWithOperation unmounts a file of type FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_unmount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags affecting the operation.
//    - mountOperation (optional): Operation, or NULL to avoid user interaction.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) unmountMountableWithOperation(ctx context.Context, flags MountUnmountFlags, mountOperation *MountOperation, callback AsyncReadyCallback) {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.unmount_mountable_with_operation

	var _arg0 *C.GFile              // out
	var _arg3 *C.GCancellable       // out
	var _arg1 C.GMountUnmountFlags  // out
	var _arg2 *C.GMountOperation    // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GMountUnmountFlags(flags)
	if mountOperation != nil {
		_arg2 = (*C.GMountOperation)(unsafe.Pointer(coreglib.InternObject(mountOperation).Native()))
	}
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_File_virtual_unmount_mountable_with_operation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mountOperation)
	runtime.KeepAlive(callback)
}

// unmountMountableWithOperationFinish finishes an unmount operation, see
// g_file_unmount_mountable_with_operation() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable_with_operation().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) unmountMountableWithOperationFinish(result AsyncResulter) error {
	gclass := (*C.GFileIface)(coreglib.PeekParentClass(file))
	fnarg := gclass.unmount_mountable_with_operation_finish

	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_File_virtual_unmount_mountable_with_operation_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// NewTLSCertificateFromPKCS11URIs creates a Certificate from a PKCS \#11 URI.
//
// An example pkcs11_uri would be
// pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01
//
// Where the tokenâ€™s layout is:
//
//    Object 0:
//      URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=private20key;type=private
//      Type: Private key (RSA-2048)
//      ID: 01
//
//    Object 1:
//      URL: pkcs11:model=Model;manufacturer=Manufacture;serial=1;token=My20Client20Certificate;id=01;object=Certificate20for20Authentication;type=cert
//      Type: X.509 Certificate (RSA-2048)
//      ID: 01
//
//
// In this case the certificate and private key would both be detected and used
// as expected. pkcs_uri may also just reference an X.509 certificate object and
// then optionally private_key_pkcs11_uri allows using a private key exposed
// under a different URI.
//
// Note that the private key is not accessed until usage and may fail or require
// a PIN later.
//
// The function takes the following parameters:
//
//    - pkcs11Uri: PKCS \#11 URI.
//    - privateKeyPkcs11Uri (optional): PKCS \#11 URI.
//
// The function returns the following values:
//
//    - tlsCertificate: new certificate, or NULL on error.
//
func NewTLSCertificateFromPKCS11URIs(pkcs11Uri, privateKeyPkcs11Uri string) (*TLSCertificate, error) {
	var _arg1 *C.gchar           // out
	var _arg2 *C.gchar           // out
	var _cret *C.GTlsCertificate // in
	var _cerr *C.GError          // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pkcs11Uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if privateKeyPkcs11Uri != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(privateKeyPkcs11Uri)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_tls_certificate_new_from_pkcs11_uris(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(pkcs11Uri)
	runtime.KeepAlive(privateKeyPkcs11Uri)

	var _tlsCertificate *TLSCertificate // out
	var _goerr error                    // out

	_tlsCertificate = wrapTLSCertificate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _tlsCertificate, _goerr
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// GVariant* _gotk4_gio2_Icon_virtual_serialize(void* fnptr, GIcon* arg0) {
//   return ((GVariant* (*)(GIcon*))(fnptr))(arg0);
// };
import "C"

// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can be
// retrieved back by calling g_icon_deserialize() on the returned value. As
// serialization will avoid using raw icon data when possible, it only makes
// sense to transfer the #GVariant between processes on the same machine, (as
// opposed to over the network), and within the same file system namespace.
//
// The function returns the following values:
//
//    - variant (optional) or NULL when serialization fails. The #GVariant will
//      not be floating.
//
func (icon *Icon) Serialize() *glib.Variant {
	var _arg0 *C.GIcon    // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.g_icon_serialize(_arg0)
	runtime.KeepAlive(icon)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Serialize serializes a #GIcon into a #GVariant. An equivalent #GIcon can be
// retrieved back by calling g_icon_deserialize() on the returned value. As
// serialization will avoid using raw icon data when possible, it only makes
// sense to transfer the #GVariant between processes on the same machine, (as
// opposed to over the network), and within the same file system namespace.
//
// The function returns the following values:
//
//    - variant (optional) or NULL when serialization fails. The #GVariant will
//      not be floating.
//
func (icon *Icon) serialize() *glib.Variant {
	gclass := (*C.GIconIface)(coreglib.PeekParentClass(icon))
	fnarg := gclass.serialize

	var _arg0 *C.GIcon    // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C._gotk4_gio2_Icon_virtual_serialize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(icon)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// IconDeserialize deserializes a #GIcon previously serialized using
// g_icon_serialize().
//
// The function takes the following parameters:
//
//    - value created with g_icon_serialize().
//
// The function returns the following values:
//
//    - icon (optional) or NULL when deserialization fails.
//
func IconDeserialize(value *glib.Variant) *Icon {
	var _arg1 *C.GVariant // out
	var _cret *C.GIcon    // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))

	_cret = C.g_icon_deserialize(_arg1)
	runtime.KeepAlive(value)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _icon
}

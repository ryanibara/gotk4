// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeFileAttributeMatcher = coreglib.Type(C.g_file_attribute_matcher_get_type())
	GTypeSrvTarget            = coreglib.Type(C.g_srv_target_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFileAttributeMatcher, F: marshalFileAttributeMatcher},
		coreglib.TypeMarshaler{T: GTypeSrvTarget, F: marshalSrvTarget},
	})
}

// AsyncReadyCallback: type definition for a function that will be called back
// when an asynchronous operation within GIO has been completed. ReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later iteration of
// the [thread-default main context][g-main-context-push-thread-default] where
// the #GTask was created. All other users of ReadyCallback must likewise call
// it asynchronously in a later iteration of the main context.
type AsyncReadyCallback func(res AsyncResulter)

// FileProgressCallback: when doing file operations that may take a while,
// such as moving a file or copying a file, a progress callback is used to pass
// how far along that operation is to the application.
type FileProgressCallback func(currentNumBytes, totalNumBytes int64)

// FileReadMoreCallback: when loading the partial contents of a file with
// g_file_load_partial_contents_async(), it may become necessary to determine
// if any more data from the file should be loaded. A ReadMoreCallback function
// facilitates this by returning TRUE if more data should be read, or FALSE
// otherwise.
type FileReadMoreCallback func(fileContents string, fileSize int64) (ok bool)

// FileAttributeMatcher determines if a string matches a file attribute.
//
// An instance of this type is always passed by reference.
type FileAttributeMatcher struct {
	*fileAttributeMatcher
}

// fileAttributeMatcher is the struct that's finalized.
type fileAttributeMatcher struct {
	native *C.GFileAttributeMatcher
}

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FileAttributeMatcher{&fileAttributeMatcher{(*C.GFileAttributeMatcher)(b)}}, nil
}

// NewFileAttributeMatcher constructs a struct FileAttributeMatcher.
func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher {
	var _arg1 *C.char                  // out
	var _cret *C.GFileAttributeMatcher // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_new(_arg1)
	runtime.KeepAlive(attributes)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	_fileAttributeMatcher = (*FileAttributeMatcher)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeMatcher)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_file_attribute_matcher_unref((*C.GFileAttributeMatcher)(intern.C))
		},
	)

	return _fileAttributeMatcher
}

// EnumerateNamespace checks if the matcher will match all of the keys in a
// given namespace. This will always return TRUE if a wildcard character is in
// use (e.g. if matcher was created with "standard::*" and ns is "standard",
// or if matcher was created using "*" and namespace is anything.)
//
// TODO: this is awkwardly worded.
//
// The function takes the following parameters:
//
//   - ns: string containing a file attribute namespace.
//
// The function returns the following values:
//
//   - ok: TRUE if the matcher matches all of the entries in the given ns,
//     FALSE otherwise.
//
func (matcher *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(ns)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_enumerate_namespace(_arg0, _arg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(ns)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnumerateNext gets the next matched attribute from a AttributeMatcher.
//
// The function returns the following values:
//
//   - utf8 (optional): string containing the next attribute or, NULL if no more
//     attribute exist.
//
func (matcher *FileAttributeMatcher) EnumerateNext() string {
	var _arg0 *C.GFileAttributeMatcher // out
	var _cret *C.char                  // in

	_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))

	_cret = C.g_file_attribute_matcher_enumerate_next(_arg0)
	runtime.KeepAlive(matcher)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Matches checks if an attribute will be matched by an attribute matcher.
// If the matcher was created with the "*" matching string, this function will
// always return TRUE.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - ok: TRUE if attribute matches matcher. FALSE otherwise.
//
func (matcher *FileAttributeMatcher) Matches(attribute string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_matches(_arg0, _arg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchesOnly checks if a attribute matcher only matches a given attribute.
// Always returns FALSE if "*" was used when creating the matcher.
//
// The function takes the following parameters:
//
//   - attribute: file attribute key.
//
// The function returns the following values:
//
//   - ok: TRUE if the matcher only matches attribute. FALSE otherwise.
//
func (matcher *FileAttributeMatcher) MatchesOnly(attribute string) bool {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.char                  // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_attribute_matcher_matches_only(_arg0, _arg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Subtract subtracts all attributes of subtract from matcher and returns a
// matcher that supports those attributes.
//
// Note that currently it is not possible to remove a single attribute when the
// matcher matches the whole namespace - or remove a namespace or attribute
// when the matcher matches everything. This is a limitation of the current
// implementation, but may be fixed in the future.
//
// The function takes the following parameters:
//
//   - subtract (optional): matcher to subtract.
//
// The function returns the following values:
//
//   - fileAttributeMatcher (optional): file attribute matcher matching all
//     attributes of matcher that are not matched by subtract.
//
func (matcher *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
	var _arg0 *C.GFileAttributeMatcher // out
	var _arg1 *C.GFileAttributeMatcher // out
	var _cret *C.GFileAttributeMatcher // in

	if matcher != nil {
		_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	}
	if subtract != nil {
		_arg1 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(subtract)))
	}

	_cret = C.g_file_attribute_matcher_subtract(_arg0, _arg1)
	runtime.KeepAlive(matcher)
	runtime.KeepAlive(subtract)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	if _cret != nil {
		_fileAttributeMatcher = (*FileAttributeMatcher)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_fileAttributeMatcher)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_file_attribute_matcher_unref((*C.GFileAttributeMatcher)(intern.C))
			},
		)
	}

	return _fileAttributeMatcher
}

// String prints what the matcher is matching against. The format will be equal
// to the format passed to g_file_attribute_matcher_new(). The output however,
// might not be identical, as the matcher may decide to use a different order or
// omit needless parts.
//
// The function returns the following values:
//
//   - utf8: string describing the attributes the matcher matches against or
//     NULL if matcher was NULL.
//
func (matcher *FileAttributeMatcher) String() string {
	var _arg0 *C.GFileAttributeMatcher // out
	var _cret *C.char                  // in

	if matcher != nil {
		_arg0 = (*C.GFileAttributeMatcher)(gextras.StructNative(unsafe.Pointer(matcher)))
	}

	_cret = C.g_file_attribute_matcher_to_string(_arg0)
	runtime.KeepAlive(matcher)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
//
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
//
// An instance of this type is always passed by reference.
type SrvTarget struct {
	*srvTarget
}

// srvTarget is the struct that's finalized.
type srvTarget struct {
	native *C.GSrvTarget
}

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SrvTarget{&srvTarget{(*C.GSrvTarget)(b)}}, nil
}

// NewSrvTarget constructs a struct SrvTarget.
func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
	var _arg1 *C.gchar      // out
	var _arg2 C.guint16     // out
	var _arg3 C.guint16     // out
	var _arg4 C.guint16     // out
	var _cret *C.GSrvTarget // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint16(port)
	_arg3 = C.guint16(priority)
	_arg4 = C.guint16(weight)

	_cret = C.g_srv_target_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(port)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(weight)

	var _srvTarget *SrvTarget // out

	_srvTarget = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_srvTarget)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_srv_target_free((*C.GSrvTarget)(intern.C))
		},
	)

	return _srvTarget
}

// Copy copies target.
//
// The function returns the following values:
//
//   - srvTarget: copy of target.
//
func (target *SrvTarget) Copy() *SrvTarget {
	var _arg0 *C.GSrvTarget // out
	var _cret *C.GSrvTarget // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_copy(_arg0)
	runtime.KeepAlive(target)

	var _srvTarget *SrvTarget // out

	_srvTarget = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_srvTarget)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_srv_target_free((*C.GSrvTarget)(intern.C))
		},
	)

	return _srvTarget
}

// Hostname gets target's hostname (in ASCII form; if you are going to present
// this to the user, you should use g_hostname_is_ascii_encoded() to check if it
// contains encoded Unicode segments, and use g_hostname_to_unicode() to convert
// it if it does.).
//
// The function returns the following values:
//
//   - utf8 target's hostname.
//
func (target *SrvTarget) Hostname() string {
	var _arg0 *C.GSrvTarget // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_get_hostname(_arg0)
	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Port gets target's port.
//
// The function returns the following values:
//
//   - guint16 target's port.
//
func (target *SrvTarget) Port() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_get_port(_arg0)
	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Priority gets target's priority. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in RFC 2782.
//
// The function returns the following values:
//
//   - guint16 target's priority.
//
func (target *SrvTarget) Priority() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_get_priority(_arg0)
	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Weight gets target's weight. You should not need to look at this; #GResolver
// already sorts the targets according to the algorithm in RFC 2782.
//
// The function returns the following values:
//
//   - guint16 target's weight.
//
func (target *SrvTarget) Weight() uint16 {
	var _arg0 *C.GSrvTarget // out
	var _cret C.guint16     // in

	_arg0 = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(target)))

	_cret = C.g_srv_target_get_weight(_arg0)
	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

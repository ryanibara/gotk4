// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeFileAttributeMatcher returns the GType for the type FileAttributeMatcher.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFileAttributeMatcher() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "FileAttributeMatcher").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFileAttributeMatcher)
	return gtype
}

// GTypeResource returns the GType for the type Resource.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeResource() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "Resource").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalResource)
	return gtype
}

// GTypeSrvTarget returns the GType for the type SrvTarget.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeSrvTarget() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "SrvTarget").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalSrvTarget)
	return gtype
}

// AsyncReadyCallback: type definition for a function that will be called back
// when an asynchronous operation within GIO has been completed. ReadyCallback
// callbacks from #GTask are guaranteed to be invoked in a later iteration of
// the [thread-default main context][g-main-context-push-thread-default] where
// the #GTask was created. All other users of ReadyCallback must likewise call
// it asynchronously in a later iteration of the main context.
type AsyncReadyCallback func(res AsyncResulter)

//export _gotk4_gio2_AsyncReadyCallback
func _gotk4_gio2_AsyncReadyCallback(arg1 *C.GObject, arg2 *C.void, arg3 C.gpointer) {
	var fn AsyncReadyCallback
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(AsyncReadyCallback)
	}

	var _res AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_res = rv
	}

	fn(_res)
}

// CancellableSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_cancellable_source_new().
type CancellableSourceFunc func(cancellable context.Context) (ok bool)

//export _gotk4_gio2_CancellableSourceFunc
func _gotk4_gio2_CancellableSourceFunc(arg1 *C.void, arg2 C.gpointer) (cret C.gboolean) {
	var fn CancellableSourceFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CancellableSourceFunc)
	}

	var _cancellable context.Context // out

	if arg1 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg1))
	}

	ok := fn(_cancellable)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// DBusProxyTypeFunc: function signature for a function used to determine the
// #GType to use for an interface proxy (if interface_name is not NULL) or
// object proxy (if interface_name is NULL).
//
// This function is called in the [thread-default main
// loop][g-main-context-push-thread-default] that manager was constructed in.
type DBusProxyTypeFunc func(manager *DBusObjectManagerClient, objectPath, interfaceName string) (gType coreglib.Type)

//export _gotk4_gio2_DBusProxyTypeFunc
func _gotk4_gio2_DBusProxyTypeFunc(arg1 *C.void, arg2 *C.gchar, arg3 *C.gchar, arg4 C.gpointer) (cret C.GType) {
	var fn DBusProxyTypeFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(DBusProxyTypeFunc)
	}

	var _manager *DBusObjectManagerClient // out
	var _objectPath string                // out
	var _interfaceName string             // out

	_manager = wrapDBusObjectManagerClient(coreglib.Take(unsafe.Pointer(arg1)))
	_objectPath = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	if arg3 != nil {
		_interfaceName = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	}

	gType := fn(_manager, _objectPath, _interfaceName)

	cret = C.GType(gType)

	return cret
}

// DatagramBasedSourceFunc: this is the function type of the callback used for
// the #GSource returned by g_datagram_based_create_source().
type DatagramBasedSourceFunc func(datagramBased DatagramBasedder, condition glib.IOCondition) (ok bool)

//export _gotk4_gio2_DatagramBasedSourceFunc
func _gotk4_gio2_DatagramBasedSourceFunc(arg1 *C.void, arg2 C.GIOCondition, arg3 C.gpointer) (cret C.gboolean) {
	var fn DatagramBasedSourceFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(DatagramBasedSourceFunc)
	}

	var _datagramBased DatagramBasedder // out
	var _condition glib.IOCondition     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.DatagramBasedder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(DatagramBasedder)
			return ok
		})
		rv, ok := casted.(DatagramBasedder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.DatagramBasedder")
		}
		_datagramBased = rv
	}
	_condition = glib.IOCondition(arg2)

	ok := fn(_datagramBased, _condition)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// FileMeasureProgressCallback: this callback type is used by
// g_file_measure_disk_usage() to make periodic progress reports when measuring
// the amount of disk spaced used by a directory.
//
// These calls are made on a best-effort basis and not all types of #GFile will
// support them. At the minimum, however, one call will always be made
// immediately.
//
// In the case that there is no support, reporting will be set to FALSE (and the
// other values undefined) and no further calls will be made. Otherwise, the
// reporting will be TRUE and the other values all-zeros during the first
// (immediate) call. In this way, you can know which type of progress UI to show
// without a delay.
//
// For g_file_measure_disk_usage() the callback is made directly. For
// g_file_measure_disk_usage_async() the callback is made via the default main
// context of the calling thread (ie: the same way that the final async result
// would be reported).
//
// current_size is in the same units as requested by the operation (see
// G_FILE_MEASURE_APPARENT_SIZE).
//
// The frequency of the updates is implementation defined, but is ideally about
// once every 200ms.
//
// The last progress callback may or may not be equal to the final result.
// Always check the async result to get the final value.
type FileMeasureProgressCallback func(reporting bool, currentSize, numDirs, numFiles uint64)

//export _gotk4_gio2_FileMeasureProgressCallback
func _gotk4_gio2_FileMeasureProgressCallback(arg1 C.gboolean, arg2 C.guint64, arg3 C.guint64, arg4 C.guint64, arg5 C.gpointer) {
	var fn FileMeasureProgressCallback
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FileMeasureProgressCallback)
	}

	var _reporting bool     // out
	var _currentSize uint64 // out
	var _numDirs uint64     // out
	var _numFiles uint64    // out

	if arg1 != 0 {
		_reporting = true
	}
	_currentSize = uint64(arg2)
	_numDirs = uint64(arg3)
	_numFiles = uint64(arg4)

	fn(_reporting, _currentSize, _numDirs, _numFiles)
}

// FileProgressCallback: when doing file operations that may take a while, such
// as moving a file or copying a file, a progress callback is used to pass how
// far along that operation is to the application.
type FileProgressCallback func(currentNumBytes, totalNumBytes int64)

//export _gotk4_gio2_FileProgressCallback
func _gotk4_gio2_FileProgressCallback(arg1 C.goffset, arg2 C.goffset, arg3 C.gpointer) {
	var fn FileProgressCallback
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FileProgressCallback)
	}

	var _currentNumBytes int64 // out
	var _totalNumBytes int64   // out

	_currentNumBytes = int64(arg1)
	_totalNumBytes = int64(arg2)

	fn(_currentNumBytes, _totalNumBytes)
}

// FileReadMoreCallback: when loading the partial contents of a file with
// g_file_load_partial_contents_async(), it may become necessary to determine if
// any more data from the file should be loaded. A ReadMoreCallback function
// facilitates this by returning TRUE if more data should be read, or FALSE
// otherwise.
type FileReadMoreCallback func(fileContents string, fileSize int64) (ok bool)

//export _gotk4_gio2_FileReadMoreCallback
func _gotk4_gio2_FileReadMoreCallback(arg1 *C.char, arg2 C.goffset, arg3 C.gpointer) (cret C.gboolean) {
	var fn FileReadMoreCallback
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(FileReadMoreCallback)
	}

	var _fileContents string // out
	var _fileSize int64      // out

	_fileContents = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_fileSize = int64(arg2)

	ok := fn(_fileContents, _fileSize)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// PollableSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_pollable_input_stream_create_source() and
// g_pollable_output_stream_create_source().
type PollableSourceFunc func(pollableStream *coreglib.Object) (ok bool)

//export _gotk4_gio2_PollableSourceFunc
func _gotk4_gio2_PollableSourceFunc(arg1 *C.GObject, arg2 C.gpointer) (cret C.gboolean) {
	var fn PollableSourceFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PollableSourceFunc)
	}

	var _pollableStream *coreglib.Object // out

	_pollableStream = coreglib.Take(unsafe.Pointer(arg1))

	ok := fn(_pollableStream)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// SocketSourceFunc: this is the function type of the callback used for the
// #GSource returned by g_socket_create_source().
type SocketSourceFunc func(socket *Socket, condition glib.IOCondition) (ok bool)

//export _gotk4_gio2_SocketSourceFunc
func _gotk4_gio2_SocketSourceFunc(arg1 *C.void, arg2 C.GIOCondition, arg3 C.gpointer) (cret C.gboolean) {
	var fn SocketSourceFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(SocketSourceFunc)
	}

	var _socket *Socket             // out
	var _condition glib.IOCondition // out

	_socket = wrapSocket(coreglib.Take(unsafe.Pointer(arg1)))
	_condition = glib.IOCondition(arg2)

	ok := fn(_socket, _condition)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// FileAttributeMatcher determines if a string matches a file attribute.
//
// An instance of this type is always passed by reference.
type FileAttributeMatcher struct {
	*fileAttributeMatcher
}

// fileAttributeMatcher is the struct that's finalized.
type fileAttributeMatcher struct {
	native unsafe.Pointer
}

func marshalFileAttributeMatcher(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FileAttributeMatcher{&fileAttributeMatcher{(unsafe.Pointer)(b)}}, nil
}

// NewFileAttributeMatcher constructs a struct FileAttributeMatcher.
func NewFileAttributeMatcher(attributes string) *FileAttributeMatcher {
	var _args [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gio", "FileAttributeMatcher")
	_gret := _info.InvokeRecordMethod("new", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(attributes)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	_fileAttributeMatcher = (*FileAttributeMatcher)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeMatcher)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _fileAttributeMatcher
}

// EnumerateNamespace checks if the matcher will match all of the keys in a
// given namespace. This will always return TRUE if a wildcard character is in
// use (e.g. if matcher was created with "standard::*" and ns is "standard", or
// if matcher was created using "*" and namespace is anything.)
//
// TODO: this is awkwardly worded.
//
// The function takes the following parameters:
//
//    - ns: string containing a file attribute namespace.
//
// The function returns the following values:
//
//    - ok: TRUE if the matcher matches all of the entries in the given ns, FALSE
//      otherwise.
//
func (matcher *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matcher)))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(ns)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "FileAttributeMatcher")
	_gret := _info.InvokeRecordMethod("enumerate_namespace", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(matcher)
	runtime.KeepAlive(ns)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// EnumerateNext gets the next matched attribute from a AttributeMatcher.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the next attribute or, NULL if no more
//      attribute exist.
//
func (matcher *FileAttributeMatcher) EnumerateNext() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matcher)))

	_info := girepository.MustFind("Gio", "FileAttributeMatcher")
	_gret := _info.InvokeRecordMethod("enumerate_next", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(matcher)

	var _utf8 string // out

	if *(**C.char)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
	}

	return _utf8
}

// Matches checks if an attribute will be matched by an attribute matcher. If
// the matcher was created with the "*" matching string, this function will
// always return TRUE.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - ok: TRUE if attribute matches matcher. FALSE otherwise.
//
func (matcher *FileAttributeMatcher) Matches(attribute string) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matcher)))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "FileAttributeMatcher")
	_gret := _info.InvokeRecordMethod("matches", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// MatchesOnly checks if a attribute matcher only matches a given attribute.
// Always returns FALSE if "*" was used when creating the matcher.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - ok: TRUE if the matcher only matches attribute. FALSE otherwise.
//
func (matcher *FileAttributeMatcher) MatchesOnly(attribute string) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matcher)))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "FileAttributeMatcher")
	_gret := _info.InvokeRecordMethod("matches_only", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(matcher)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Subtract subtracts all attributes of subtract from matcher and returns a
// matcher that supports those attributes.
//
// Note that currently it is not possible to remove a single attribute when the
// matcher matches the whole namespace - or remove a namespace or attribute when
// the matcher matches everything. This is a limitation of the current
// implementation, but may be fixed in the future.
//
// The function takes the following parameters:
//
//    - subtract (optional): matcher to subtract.
//
// The function returns the following values:
//
//    - fileAttributeMatcher (optional): file attribute matcher matching all
//      attributes of matcher that are not matched by subtract.
//
func (matcher *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
	var _args [2]girepository.Argument

	if matcher != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matcher)))
	}
	if subtract != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(subtract)))
	}

	_info := girepository.MustFind("Gio", "FileAttributeMatcher")
	_gret := _info.InvokeRecordMethod("subtract", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(matcher)
	runtime.KeepAlive(subtract)

	var _fileAttributeMatcher *FileAttributeMatcher // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_fileAttributeMatcher = (*FileAttributeMatcher)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_fileAttributeMatcher)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _fileAttributeMatcher
}

// String prints what the matcher is matching against. The format will be equal
// to the format passed to g_file_attribute_matcher_new(). The output however,
// might not be identical, as the matcher may decide to use a different order or
// omit needless parts.
//
// The function returns the following values:
//
//    - utf8: string describing the attributes the matcher matches against or
//      NULL if matcher was NULL.
//
func (matcher *FileAttributeMatcher) String() string {
	var _args [1]girepository.Argument

	if matcher != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matcher)))
	}

	_info := girepository.MustFind("Gio", "FileAttributeMatcher")
	_gret := _info.InvokeRecordMethod("to_string", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(matcher)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))

	return _utf8
}

// InputMessage: structure used for scatter/gather data input when receiving
// multiple messages or packets in one go. You generally pass in an array of
// empty Vectors and the operation will use all the buffers as if they were one
// buffer, and will set bytes_received to the total number of bytes received
// across all Vectors.
//
// This structure closely mirrors struct mmsghdr and struct msghdr from the
// POSIX sockets API (see man 2 recvmmsg).
//
// If address is non-NULL then it is set to the source address the message was
// received from, and the caller must free it afterwards.
//
// If control_messages is non-NULL then it is set to an array of control
// messages received with the message (if any), and the caller must free it
// afterwards. num_control_messages is set to the number of elements in this
// array, which may be zero.
//
// Flags relevant to this message will be returned in flags. For example,
// MSG_EOR or MSG_TRUNC.
//
// An instance of this type is always passed by reference.
type InputMessage struct {
	*inputMessage
}

// inputMessage is the struct that's finalized.
type inputMessage struct {
	native unsafe.Pointer
}

// InputVector: structure used for scatter/gather data input. You generally pass
// in an array of Vectors and the operation will store the read data starting in
// the first buffer, switching to the next as needed.
//
// An instance of this type is always passed by reference.
type InputVector struct {
	*inputVector
}

// inputVector is the struct that's finalized.
type inputVector struct {
	native unsafe.Pointer
}

// Buffer: pointer to a buffer where data will be written.
func (i *InputVector) Buffer() unsafe.Pointer {
	offset := girepository.MustFind("Gio", "InputVector").StructFieldOffset("buffer")
	valptr := (*uintptr)(unsafe.Add(i.native, offset))
	var v unsafe.Pointer // out
	v = (unsafe.Pointer)(unsafe.Pointer(*(*C.gpointer)(unsafe.Pointer(&*valptr))))
	return v
}

// Size: available size in buffer.
func (i *InputVector) Size() uint {
	offset := girepository.MustFind("Gio", "InputVector").StructFieldOffset("size")
	valptr := (*uintptr)(unsafe.Add(i.native, offset))
	var v uint // out
	v = uint(*(*C.gsize)(unsafe.Pointer(&*valptr)))
	return v
}

// Size: available size in buffer.
func (i *InputVector) SetSize(size uint) {
	offset := girepository.MustFind("Gio", "InputVector").StructFieldOffset("size")
	valptr := (*uintptr)(unsafe.Add(i.native, offset))
	*(*C.gsize)(unsafe.Pointer(&*valptr)) = C.gsize(size)
}

// OutputMessage: structure used for scatter/gather data output when sending
// multiple messages or packets in one go. You generally pass in an array of
// Vectors and the operation will use all the buffers as if they were one
// buffer.
//
// If address is NULL then the message is sent to the default receiver (as
// previously set by g_socket_connect()).
//
// An instance of this type is always passed by reference.
type OutputMessage struct {
	*outputMessage
}

// outputMessage is the struct that's finalized.
type outputMessage struct {
	native unsafe.Pointer
}

// OutputVector: structure used for scatter/gather data output. You generally
// pass in an array of Vectors and the operation will use all the buffers as if
// they were one buffer.
//
// An instance of this type is always passed by reference.
type OutputVector struct {
	*outputVector
}

// outputVector is the struct that's finalized.
type outputVector struct {
	native unsafe.Pointer
}

// Buffer: pointer to a buffer of data to read.
func (o *OutputVector) Buffer() unsafe.Pointer {
	offset := girepository.MustFind("Gio", "OutputVector").StructFieldOffset("buffer")
	valptr := (*uintptr)(unsafe.Add(o.native, offset))
	var v unsafe.Pointer // out
	v = (unsafe.Pointer)(unsafe.Pointer(*(*C.gconstpointer)(unsafe.Pointer(&*valptr))))
	return v
}

// Size: size of buffer.
func (o *OutputVector) Size() uint {
	offset := girepository.MustFind("Gio", "OutputVector").StructFieldOffset("size")
	valptr := (*uintptr)(unsafe.Add(o.native, offset))
	var v uint // out
	v = uint(*(*C.gsize)(unsafe.Pointer(&*valptr)))
	return v
}

// Size: size of buffer.
func (o *OutputVector) SetSize(size uint) {
	offset := girepository.MustFind("Gio", "OutputVector").StructFieldOffset("size")
	valptr := (*uintptr)(unsafe.Add(o.native, offset))
	*(*C.gsize)(unsafe.Pointer(&*valptr)) = C.gsize(size)
}

// Resource applications and libraries often contain binary or textual data that
// is really part of the application, rather than user data. For instance
// Builder .ui files, splashscreen images, GMenu markup XML, CSS files, icons,
// etc. These are often shipped as files in $datadir/appname, or manually
// included as literal strings in the code.
//
// The #GResource API and the [glib-compile-resources][glib-compile-resources]
// program provide a convenient and efficient alternative to this which has some
// nice properties. You maintain the files as normal files, so its easy to edit
// them, but during the build the files are combined into a binary bundle that
// is linked into the executable. This means that loading the resource files are
// efficient (as they are already in memory, shared with other instances) and
// simple (no need to check for things like I/O errors or locate the files in
// the filesystem). It also makes it easier to create relocatable applications.
//
// Resource files can also be marked as compressed. Such files will be included
// in the resource bundle in a compressed form, but will be automatically
// uncompressed when the resource is used. This is very useful e.g. for larger
// text files that are parsed once (or rarely) and then thrown away.
//
// Resource files can also be marked to be preprocessed, by setting the value of
// the preprocess attribute to a comma-separated list of preprocessing options.
// The only options currently supported are:
//
// xml-stripblanks which will use the xmllint command to strip ignorable
// whitespace from the XML file. For this to work, the XMLLINT environment
// variable must be set to the full path to the xmllint executable, or xmllint
// must be in the PATH; otherwise the preprocessing step is skipped.
//
// to-pixdata (deprecated since gdk-pixbuf 2.32) which will use the
// gdk-pixbuf-pixdata command to convert images to the Pixdata format, which
// allows you to create pixbufs directly using the data inside the resource
// file, rather than an (uncompressed) copy of it. For this, the
// gdk-pixbuf-pixdata program must be in the PATH, or the GDK_PIXBUF_PIXDATA
// environment variable must be set to the full path to the gdk-pixbuf-pixdata
// executable; otherwise the resource compiler will abort. to-pixdata has been
// deprecated since gdk-pixbuf 2.32, as #GResource supports embedding modern
// image formats just as well. Instead of using it, embed a PNG or SVG file in
// your #GResource.
//
// json-stripblanks which will use the json-glib-format command to strip
// ignorable whitespace from the JSON file. For this to work, the
// JSON_GLIB_FORMAT environment variable must be set to the full path to the
// json-glib-format executable, or it must be in the PATH; otherwise the
// preprocessing step is skipped. In addition, at least version 1.6 of
// json-glib-format is required.
//
// Resource files will be exported in the GResource namespace using the
// combination of the given prefix and the filename from the file element. The
// alias attribute can be used to alter the filename to expose them at a
// different location in the resource namespace. Typically, this is used to
// include files from a different source directory without exposing the source
// directory in the resource namespace, as in the example below.
//
// Resource bundles are created by the
// [glib-compile-resources][glib-compile-resources] program which takes an XML
// file that describes the bundle, and a set of files that the XML references.
// These are combined into a binary resource bundle.
//
// An example resource description:
//
//    <?xml version="1.0" encoding="UTF-8"?>
//    <gresources>
//      <gresource prefix="/org/gtk/Example">
//        <file>data/splashscreen.png</file>
//        <file compressed="true">dialog.ui</file>
//        <file preprocess="xml-stripblanks">menumarkup.xml</file>
//        <file alias="example.css">data/example.css</file>
//      </gresource>
//    </gresources>
//
// This will create a resource bundle with the following files:
//
//    /org/gtk/Example/data/splashscreen.png
//    /org/gtk/Example/dialog.ui
//    /org/gtk/Example/menumarkup.xml
//    /org/gtk/Example/example.css
//
// Note that all resources in the process share the same namespace, so use
// Java-style path prefixes (like in the above example) to avoid conflicts.
//
// You can then use [glib-compile-resources][glib-compile-resources] to compile
// the XML to a binary bundle that you can load with g_resource_load(). However,
// its more common to use the --generate-source and --generate-header arguments
// to create a source file and header to link directly into your application.
// This will generate get_resource(), register_resource() and
// unregister_resource() functions, prefixed by the --c-name argument passed to
// [glib-compile-resources][glib-compile-resources]. get_resource() returns the
// generated #GResource object. The register and unregister functions register
// the resource so its files can be accessed using g_resources_lookup_data().
//
// Once a #GResource has been created and registered all the data in it can be
// accessed globally in the process by using API calls like
// g_resources_open_stream() to stream the data or g_resources_lookup_data() to
// get a direct pointer to the data. You can also use URIs like
// "resource:///org/gtk/Example/data/splashscreen.png" with #GFile to access the
// resource data.
//
// Some higher-level APIs, such as Application, will automatically load
// resources from certain well-known paths in the resource namespace as a
// convenience. See the documentation for those APIs for details.
//
// There are two forms of the generated source, the default version uses the
// compiler support for constructor and destructor functions (where available)
// to automatically create and register the #GResource on startup or library
// load time. If you pass --manual-register, two functions to
// register/unregister the resource are created instead. This requires an
// explicit initialization call in your application/library, but it works on all
// platforms, even on the minor ones where constructors are not supported.
// (Constructor support is available for at least Win32, Mac OS and Linux.)
//
// Note that resource data can point directly into the data segment of e.g. a
// library, so if you are unloading libraries during runtime you need to be very
// careful with keeping around pointers to data from a resource, as this goes
// away when the library is unloaded. However, in practice this is not generally
// a problem, since most resource accesses are for your own resources, and
// resource data is often used once, during parsing, and then released.
//
// When debugging a program or testing a change to an installed version, it is
// often useful to be able to replace resources in the program or library,
// without recompiling, for debugging or quick hacking and testing purposes.
// Since GLib 2.50, it is possible to use the G_RESOURCE_OVERLAYS environment
// variable to selectively overlay resources with replacements from the
// filesystem. It is a G_SEARCHPATH_SEPARATOR-separated list of substitutions to
// perform during resource lookups. It is ignored when running in a setuid
// process.
//
// A substitution has the form
//
//    /org/gtk/libgtk=/home/desrt/gtk-overlay
//
// The part before the = is the resource subpath for which the overlay applies.
// The part after is a filesystem path which contains files and subdirectories
// as you would like to be loaded as resources with the equivalent names.
//
// In the example above, if an application tried to load a resource with the
// resource path /org/gtk/libgtk/ui/gtkdialog.ui then GResource would check the
// filesystem path /home/desrt/gtk-overlay/ui/gtkdialog.ui. If a file was found
// there, it would be used instead. This is an overlay, not an outright
// replacement, which means that if a file is not found at that path, the
// built-in version will be used instead. Whiteouts are not currently supported.
//
// Substitutions must start with a slash, and must not contain a trailing slash
// before the '='. The path after the slash should ideally be absolute, but this
// is not strictly required. It is possible to overlay the location of a single
// resource with an individual file.
//
// An instance of this type is always passed by reference.
type Resource struct {
	*resource
}

// resource is the struct that's finalized.
type resource struct {
	native unsafe.Pointer
}

func marshalResource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Resource{&resource{(unsafe.Pointer)(b)}}, nil
}

// NewResourceFromData constructs a struct Resource.
func NewResourceFromData(data *glib.Bytes) (*Resource, error) {
	var _args [1]girepository.Argument

	*(**C.GBytes)(unsafe.Pointer(&_args[0])) = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))

	_info := girepository.MustFind("Gio", "Resource")
	_gret := _info.InvokeRecordMethod("new_from_data", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(data)

	var _resource *Resource // out
	var _goerr error        // out

	_resource = (*Resource)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_resource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _resource, _goerr
}

// SrvTarget: SRV (service) records are used by some network protocols to
// provide service-specific aliasing and load-balancing. For example, XMPP
// (Jabber) uses SRV records to locate the XMPP server for a domain; rather than
// connecting directly to "example.com" or assuming a specific server hostname
// like "xmpp.example.com", an XMPP client would look up the "xmpp-client" SRV
// record for "example.com", and then connect to whatever host was pointed to by
// that record.
//
// You can use g_resolver_lookup_service() or g_resolver_lookup_service_async()
// to find the Targets for a given service. However, if you are simply planning
// to connect to the remote service, you can use Service's Connectable interface
// and not need to worry about Target at all.
//
// An instance of this type is always passed by reference.
type SrvTarget struct {
	*srvTarget
}

// srvTarget is the struct that's finalized.
type srvTarget struct {
	native unsafe.Pointer
}

func marshalSrvTarget(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SrvTarget{&srvTarget{(unsafe.Pointer)(b)}}, nil
}

// NewSrvTarget constructs a struct SrvTarget.
func NewSrvTarget(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
	var _args [4]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))
	*(*C.guint16)(unsafe.Pointer(&_args[1])) = C.guint16(port)
	*(*C.guint16)(unsafe.Pointer(&_args[2])) = C.guint16(priority)
	*(*C.guint16)(unsafe.Pointer(&_args[3])) = C.guint16(weight)

	_info := girepository.MustFind("Gio", "SrvTarget")
	_gret := _info.InvokeRecordMethod("new", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(hostname)
	runtime.KeepAlive(port)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(weight)

	var _srvTarget *SrvTarget // out

	_srvTarget = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_srvTarget)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				var args [1]girepository.Argument
				*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
				girepository.MustFind("Gio", "SrvTarget").InvokeRecordMethod("free", args[:], nil)
			}
		},
	)

	return _srvTarget
}

// Copy copies target.
//
// The function returns the following values:
//
//    - srvTarget: copy of target.
//
func (target *SrvTarget) Copy() *SrvTarget {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(target)))

	_info := girepository.MustFind("Gio", "SrvTarget")
	_gret := _info.InvokeRecordMethod("copy", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(target)

	var _srvTarget *SrvTarget // out

	_srvTarget = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_srvTarget)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				var args [1]girepository.Argument
				*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
				girepository.MustFind("Gio", "SrvTarget").InvokeRecordMethod("free", args[:], nil)
			}
		},
	)

	return _srvTarget
}

// Hostname gets target's hostname (in ASCII form; if you are going to present
// this to the user, you should use g_hostname_is_ascii_encoded() to check if it
// contains encoded Unicode segments, and use g_hostname_to_unicode() to convert
// it if it does.).
//
// The function returns the following values:
//
//    - utf8 target's hostname.
//
func (target *SrvTarget) Hostname() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(target)))

	_info := girepository.MustFind("Gio", "SrvTarget")
	_gret := _info.InvokeRecordMethod("get_hostname", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(target)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// Port gets target's port.
//
// The function returns the following values:
//
//    - guint16 target's port.
//
func (target *SrvTarget) Port() uint16 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(target)))

	_info := girepository.MustFind("Gio", "SrvTarget")
	_gret := _info.InvokeRecordMethod("get_port", _args[:], nil)
	_cret := *(*C.guint16)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(*(*C.guint16)(unsafe.Pointer(&_cret)))

	return _guint16
}

// Priority gets target's priority. You should not need to look at this;
// #GResolver already sorts the targets according to the algorithm in RFC 2782.
//
// The function returns the following values:
//
//    - guint16 target's priority.
//
func (target *SrvTarget) Priority() uint16 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(target)))

	_info := girepository.MustFind("Gio", "SrvTarget")
	_gret := _info.InvokeRecordMethod("get_priority", _args[:], nil)
	_cret := *(*C.guint16)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(*(*C.guint16)(unsafe.Pointer(&_cret)))

	return _guint16
}

// Weight gets target's weight. You should not need to look at this; #GResolver
// already sorts the targets according to the algorithm in RFC 2782.
//
// The function returns the following values:
//
//    - guint16 target's weight.
//
func (target *SrvTarget) Weight() uint16 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(target)))

	_info := girepository.MustFind("Gio", "SrvTarget")
	_gret := _info.InvokeRecordMethod("get_weight", _args[:], nil)
	_cret := *(*C.guint16)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(target)

	var _guint16 uint16 // out

	_guint16 = uint16(*(*C.guint16)(unsafe.Pointer(&_cret)))

	return _guint16
}

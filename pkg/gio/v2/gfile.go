// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern char* _gotk4_gio2_FileIface_get_basename(void*);
// extern char* _gotk4_gio2_FileIface_get_parse_name(void*);
// extern char* _gotk4_gio2_FileIface_get_path(void*);
// extern char* _gotk4_gio2_FileIface_get_relative_path(void*, void*);
// extern char* _gotk4_gio2_FileIface_get_uri(void*);
// extern char* _gotk4_gio2_FileIface_get_uri_scheme(void*);
// extern gboolean _gotk4_gio2_FileIface_copy_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_eject_mountable_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_eject_mountable_with_operation_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_equal(void*, void*);
// extern gboolean _gotk4_gio2_FileIface_has_uri_scheme(void*, char*);
// extern gboolean _gotk4_gio2_FileIface_is_native(void*);
// extern gboolean _gotk4_gio2_FileIface_make_directory(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_make_directory_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_make_symbolic_link(void*, char*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_measure_disk_usage_finish(void*, void*, guint64*, guint64*, guint64*, GError**);
// extern gboolean _gotk4_gio2_FileIface_mount_enclosing_volume_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_poll_mountable_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_set_attributes_finish(void*, void*, void**, GError**);
// extern gboolean _gotk4_gio2_FileIface_start_mountable_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_stop_mountable_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_trash(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_trash_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_unmount_mountable_finish(void*, void*, GError**);
// extern gboolean _gotk4_gio2_FileIface_unmount_mountable_with_operation_finish(void*, void*, GError**);
// extern guint _gotk4_gio2_FileIface_hash(void*);
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, void*, gpointer);
// extern void* _gotk4_gio2_FileIface_append_to_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_create_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_create_readwrite_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_dup(void*);
// extern void* _gotk4_gio2_FileIface_enumerate_children_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_find_enclosing_mount(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_find_enclosing_mount_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_get_child_for_display_name(void*, char*, GError**);
// extern void* _gotk4_gio2_FileIface_get_parent(void*);
// extern void* _gotk4_gio2_FileIface_mount_mountable_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_open_readwrite(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_open_readwrite_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_query_filesystem_info(void*, char*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_query_filesystem_info_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_query_info_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_query_settable_attributes(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_query_writable_namespaces(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_read_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_replace_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_replace_readwrite_finish(void*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_resolve_relative_path(void*, char*);
// extern void* _gotk4_gio2_FileIface_set_display_name(void*, char*, void*, GError**);
// extern void* _gotk4_gio2_FileIface_set_display_name_finish(void*, void*, GError**);
import "C"

// GTypeFile returns the GType for the type File.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFile() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "File").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFile)
	return gtype
}

// File is a high level abstraction for manipulating files on a virtual file
// system. #GFiles are lightweight, immutable objects that do no I/O upon
// creation. It is necessary to understand that #GFile objects do not represent
// files, merely an identifier for a file. All file content I/O is implemented
// as streaming operations (see Stream and Stream).
//
// To construct a #GFile, you can use:
//
// - g_file_new_for_path() if you have a path.
//
// - g_file_new_for_uri() if you have a URI.
//
// - g_file_new_for_commandline_arg() for a command line argument.
//
// - g_file_new_tmp() to create a temporary file from a template.
//
// - g_file_parse_name() from a UTF-8 string gotten from
// g_file_get_parse_name().
//
// - g_file_new_build_filename() to create a file from path elements.
//
// One way to think of a #GFile is as an abstraction of a pathname. For normal
// files the system pathname is what is stored internally, but as #GFiles are
// extensible it could also be something else that corresponds to a pathname in
// a userspace implementation of a filesystem.
//
// #GFiles make up hierarchies of directories and files that correspond to the
// files on a filesystem. You can move through the file system with #GFile using
// g_file_get_parent() to get an identifier for the parent directory,
// g_file_get_child() to get a child within a directory,
// g_file_resolve_relative_path() to resolve a relative path between two
// #GFiles. There can be multiple hierarchies, so you may not end up at the same
// root if you repeatedly call g_file_get_parent() on two different files.
//
// All #GFiles have a basename (get with g_file_get_basename()). These names are
// byte strings that are used to identify the file on the filesystem (relative
// to its parent directory) and there is no guarantees that they have any
// particular charset encoding or even make any sense at all. If you want to use
// filenames in a user interface you should use the display name that you can
// get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info(). This is guaranteed to be in UTF-8 and can be used in a
// user interface. But always store the real basename or the #GFile to use to
// actually access the file, because there is no way to go from a display name
// to the actual name.
//
// Using #GFile as an identifier has the same weaknesses as using a path in that
// there may be multiple aliases for the same file. For instance, hard or soft
// links may cause two different #GFiles to refer to the same file. Other
// possible causes for aliases are: case insensitive filesystems, short and long
// names on FAT/NTFS, or bind mounts in Linux. If you want to check if two
// #GFiles point to the same file you can query for the G_FILE_ATTRIBUTE_ID_FILE
// attribute. Note that #GFile does some trivial canonicalization of pathnames
// passed in, so that trivial differences in the path string used at creation
// (duplicated slashes, slash at end of path, "." or ".." path segments, etc)
// does not create different #GFiles.
//
// Many #GFile operations have both synchronous and asynchronous versions to
// suit your application. Asynchronous versions of synchronous functions simply
// have _async() appended to their function names. The asynchronous I/O
// functions call a ReadyCallback which is then used to finalize the operation,
// producing a GAsyncResult which is then passed to the function's matching
// _finish() operation.
//
// It is highly recommended to use asynchronous calls when running within a
// shared main loop, such as in the main thread of an application. This avoids
// I/O operations blocking other sources on the main loop from being dispatched.
// Synchronous I/O operations should be performed from worker threads. See the
// [introduction to asynchronous programming section][async-programming] for
// more.
//
// Some #GFile operations almost always take a noticeable amount of time, and so
// do not have synchronous analogs. Notable cases include:
//
// - g_file_mount_mountable() to mount a mountable file.
//
// - g_file_unmount_mountable_with_operation() to unmount a mountable file.
//
// - g_file_eject_mountable_with_operation() to eject a mountable file.
//
//
// Entity Tags
//
// One notable feature of #GFiles are entity tags, or "etags" for short. Entity
// tags are somewhat like a more abstract version of the traditional mtime, and
// can be used to quickly determine if the file has been modified from the
// version on the file system. See the HTTP 1.1 specification
// (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) for HTTP Etag
// headers, which are a very similar concept.
//
// File wraps an interface. This means the user can get the
// underlying type by calling Cast().
type File struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*File)(nil)
)

// Filer describes File's interface methods.
type Filer interface {
	coreglib.Objector

	// AppendToFinish finishes an asynchronous file append operation started
	// with g_file_append_to_async().
	AppendToFinish(res AsyncResulter) (*FileOutputStream, error)
	// CopyFinish finishes copying the file started with g_file_copy_async().
	CopyFinish(res AsyncResulter) error
	// CreateFinish finishes an asynchronous file create operation started with
	// g_file_create_async().
	CreateFinish(res AsyncResulter) (*FileOutputStream, error)
	// CreateReadwriteFinish finishes an asynchronous file create operation
	// started with g_file_create_readwrite_async().
	CreateReadwriteFinish(res AsyncResulter) (*FileIOStream, error)
	// Delete deletes a file.
	Delete(ctx context.Context) error
	// DeleteAsync: asynchronously delete a file.
	DeleteAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback)
	// DeleteFinish finishes deleting a file started with g_file_delete_async().
	DeleteFinish(result AsyncResulter) error
	// Dup duplicates a #GFile handle.
	Dup() *File
	// EjectMountableFinish finishes an asynchronous eject operation started by
	// g_file_eject_mountable().
	EjectMountableFinish(result AsyncResulter) error
	// EjectMountableWithOperationFinish finishes an asynchronous eject
	// operation started by g_file_eject_mountable_with_operation().
	EjectMountableWithOperationFinish(result AsyncResulter) error
	// EnumerateChildrenFinish finishes an async enumerate children operation.
	EnumerateChildrenFinish(res AsyncResulter) (*FileEnumerator, error)
	// Equal checks if the two given #GFiles refer to the same file.
	Equal(file2 Filer) bool
	// FindEnclosingMount gets a #GMount for the #GFile.
	FindEnclosingMount(ctx context.Context) (*Mount, error)
	// FindEnclosingMountAsync: asynchronously gets the mount for the file.
	FindEnclosingMountAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback)
	// FindEnclosingMountFinish finishes an asynchronous find mount request.
	FindEnclosingMountFinish(res AsyncResulter) (*Mount, error)
	// Basename gets the base name (the last component of the path) for a given
	// #GFile.
	Basename() string
	// Child gets a child of file with basename equal to name.
	Child(name string) *File
	// ChildForDisplayName gets the child of file for a given display_name (i.e.
	ChildForDisplayName(displayName string) (*File, error)
	// Parent gets the parent directory for the file.
	Parent() *File
	// ParseName gets the parse name of the file.
	ParseName() string
	// Path gets the local pathname for #GFile, if one exists.
	Path() string
	// RelativePath gets the path for descendant relative to parent.
	RelativePath(descendant Filer) string
	// URI gets the URI for the file.
	URI() string
	// URIScheme gets the URI scheme for a #GFile.
	URIScheme() string
	// HasParent checks if file has a parent, and optionally, if it is parent.
	HasParent(parent Filer) bool
	// HasPrefix checks whether file has the prefix specified by prefix.
	HasPrefix(prefix Filer) bool
	// HasURIScheme checks to see if a #GFile has a given URI scheme.
	HasURIScheme(uriScheme string) bool
	// Hash creates a hash value for a #GFile.
	Hash() uint32
	// IsNative checks to see if a file is native to the platform.
	IsNative() bool
	// LoadBytes loads the contents of file and returns it as #GBytes.
	LoadBytes(ctx context.Context) (string, *glib.Bytes, error)
	// LoadBytesAsync: asynchronously loads the contents of file as #GBytes.
	LoadBytesAsync(ctx context.Context, callback AsyncReadyCallback)
	// LoadBytesFinish completes an asynchronous request to
	// g_file_load_bytes_async().
	LoadBytesFinish(result AsyncResulter) (string, *glib.Bytes, error)
	// LoadContents loads the content of the file into memory.
	LoadContents(ctx context.Context) ([]byte, string, error)
	// LoadContentsAsync starts an asynchronous load of the file's contents.
	LoadContentsAsync(ctx context.Context, callback AsyncReadyCallback)
	// LoadContentsFinish finishes an asynchronous load of the file's contents.
	LoadContentsFinish(res AsyncResulter) ([]byte, string, error)
	// LoadPartialContentsFinish finishes an asynchronous partial load operation
	// that was started with g_file_load_partial_contents_async().
	LoadPartialContentsFinish(res AsyncResulter) ([]byte, string, error)
	// MakeDirectory creates a directory.
	MakeDirectory(ctx context.Context) error
	// MakeDirectoryAsync: asynchronously creates a directory.
	MakeDirectoryAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback)
	// MakeDirectoryFinish finishes an asynchronous directory creation, started
	// with g_file_make_directory_async().
	MakeDirectoryFinish(result AsyncResulter) error
	// MakeDirectoryWithParents creates a directory and any parent directories
	// that may not exist similar to 'mkdir -p'.
	MakeDirectoryWithParents(ctx context.Context) error
	// MakeSymbolicLink creates a symbolic link named file which contains the
	// string symlink_value.
	MakeSymbolicLink(ctx context.Context, symlinkValue string) error
	// MeasureDiskUsageFinish collects the results from an earlier call to
	// g_file_measure_disk_usage_async().
	MeasureDiskUsageFinish(result AsyncResulter) (diskUsage, numDirs, numFiles uint64, goerr error)
	// MountEnclosingVolumeFinish finishes a mount operation started by
	// g_file_mount_enclosing_volume().
	MountEnclosingVolumeFinish(result AsyncResulter) error
	// MountMountableFinish finishes a mount operation.
	MountMountableFinish(result AsyncResulter) (*File, error)
	// OpenReadwrite opens an existing file for reading and writing.
	OpenReadwrite(ctx context.Context) (*FileIOStream, error)
	// OpenReadwriteAsync: asynchronously opens file for reading and writing.
	OpenReadwriteAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback)
	// OpenReadwriteFinish finishes an asynchronous file read operation started
	// with g_file_open_readwrite_async().
	OpenReadwriteFinish(res AsyncResulter) (*FileIOStream, error)
	// PeekPath: exactly like g_file_get_path(), but caches the result via
	// g_object_set_qdata_full().
	PeekPath() string
	// PollMountable polls a file of type FILE_TYPE_MOUNTABLE.
	PollMountable(ctx context.Context, callback AsyncReadyCallback)
	// PollMountableFinish finishes a poll operation.
	PollMountableFinish(result AsyncResulter) error
	// QueryDefaultHandler returns the Info that is registered as the default
	// application to handle the file specified by file.
	QueryDefaultHandler(ctx context.Context) (*AppInfo, error)
	// QueryDefaultHandlerAsync: async version of
	// g_file_query_default_handler().
	QueryDefaultHandlerAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback)
	// QueryDefaultHandlerFinish finishes a g_file_query_default_handler_async()
	// operation.
	QueryDefaultHandlerFinish(result AsyncResulter) (*AppInfo, error)
	// QueryExists: utility function to check if a particular file exists.
	QueryExists(ctx context.Context) bool
	// QueryFilesystemInfo: similar to g_file_query_info(), but obtains
	// information about the filesystem the file is on, rather than the file
	// itself.
	QueryFilesystemInfo(ctx context.Context, attributes string) (*FileInfo, error)
	// QueryFilesystemInfoAsync: asynchronously gets the requested information
	// about the filesystem that the specified file is on.
	QueryFilesystemInfoAsync(ctx context.Context, attributes string, ioPriority int32, callback AsyncReadyCallback)
	// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query.
	QueryFilesystemInfoFinish(res AsyncResulter) (*FileInfo, error)
	// QueryInfoFinish finishes an asynchronous file info query.
	QueryInfoFinish(res AsyncResulter) (*FileInfo, error)
	// QuerySettableAttributes: obtain the list of settable attributes for the
	// file.
	QuerySettableAttributes(ctx context.Context) (*FileAttributeInfoList, error)
	// QueryWritableNamespaces: obtain the list of attribute namespaces where
	// new attributes can be created by a user.
	QueryWritableNamespaces(ctx context.Context) (*FileAttributeInfoList, error)
	// Read opens a file for reading.
	Read(ctx context.Context) (*FileInputStream, error)
	// ReadAsync: asynchronously opens file for reading.
	ReadAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback)
	// ReadFinish finishes an asynchronous file read operation started with
	// g_file_read_async().
	ReadFinish(res AsyncResulter) (*FileInputStream, error)
	// ReplaceContentsFinish finishes an asynchronous replace of the given file.
	ReplaceContentsFinish(res AsyncResulter) (string, error)
	// ReplaceFinish finishes an asynchronous file replace operation started
	// with g_file_replace_async().
	ReplaceFinish(res AsyncResulter) (*FileOutputStream, error)
	// ReplaceReadwriteFinish finishes an asynchronous file replace operation
	// started with g_file_replace_readwrite_async().
	ReplaceReadwriteFinish(res AsyncResulter) (*FileIOStream, error)
	// ResolveRelativePath resolves a relative path for file to an absolute
	// path.
	ResolveRelativePath(relativePath string) *File
	// SetAttributesFinish finishes setting an attribute started in
	// g_file_set_attributes_async().
	SetAttributesFinish(result AsyncResulter) (*FileInfo, error)
	// SetDisplayName renames file to the specified display name.
	SetDisplayName(ctx context.Context, displayName string) (*File, error)
	// SetDisplayNameAsync: asynchronously sets the display name for a given
	// #GFile.
	SetDisplayNameAsync(ctx context.Context, displayName string, ioPriority int32, callback AsyncReadyCallback)
	// SetDisplayNameFinish finishes setting a display name started with
	// g_file_set_display_name_async().
	SetDisplayNameFinish(res AsyncResulter) (*File, error)
	// StartMountableFinish finishes a start operation.
	StartMountableFinish(result AsyncResulter) error
	// StopMountableFinish finishes a stop operation, see
	// g_file_stop_mountable() for details.
	StopMountableFinish(result AsyncResulter) error
	// SupportsThreadContexts checks if file supports [thread-default
	// contexts][g-main-context-push-thread-default-context].
	SupportsThreadContexts() bool
	// Trash sends file to the "Trashcan", if possible.
	Trash(ctx context.Context) error
	// TrashAsync: asynchronously sends file to the Trash location, if possible.
	TrashAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback)
	// TrashFinish finishes an asynchronous file trashing operation, started
	// with g_file_trash_async().
	TrashFinish(result AsyncResulter) error
	// UnmountMountableFinish finishes an unmount operation, see
	// g_file_unmount_mountable() for details.
	UnmountMountableFinish(result AsyncResulter) error
	// UnmountMountableWithOperationFinish finishes an unmount operation, see
	// g_file_unmount_mountable_with_operation() for details.
	UnmountMountableWithOperationFinish(result AsyncResulter) error
}

var _ Filer = (*File)(nil)

func wrapFile(obj *coreglib.Object) *File {
	return &File{
		Object: obj,
	}
}

func marshalFile(p uintptr) (interface{}, error) {
	return wrapFile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AppendToFinish finishes an asynchronous file append operation started with
// g_file_append_to_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileOutputStream: valid OutputStream or NULL on error. Free the returned
//      object with g_object_unref().
//
func (file *File) AppendToFinish(res AsyncResulter) (*FileOutputStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("append_to_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileOutputStream, _goerr
}

// CopyFinish finishes copying the file started with g_file_copy_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
func (file *File) CopyFinish(res AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("copy_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// CreateFinish finishes an asynchronous file create operation started with
// g_file_create_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileOutputStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) CreateFinish(res AsyncResulter) (*FileOutputStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("create_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileOutputStream, _goerr
}

// CreateReadwriteFinish finishes an asynchronous file create operation started
// with g_file_create_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) CreateReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("create_readwrite_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileIOStream, _goerr
}

// Delete deletes a file. If the file is a directory, it will only be deleted if
// it is empty. This has the same semantics as g_unlink().
//
// If file doesn’t exist, G_IO_ERROR_NOT_FOUND will be returned. This allows for
// deletion to be implemented avoiding time-of-check to time-of-use races
// (https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
//
//    g_autoptr(GError) local_error = NULL;
//    if (!g_file_delete (my_file, my_cancellable, &local_error) &&
//        !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
//      {
//        // deletion failed for some reason other than the file not existing:
//        // so report the error
//        g_warning ("Failed to delete s: s",
//                   g_file_peek_path (my_file), local_error->message);
//      }
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
func (file *File) Delete(ctx context.Context) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("delete", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// DeleteAsync: asynchronously delete a file. If the file is a directory, it
// will only be deleted if it is empty. This has the same semantics as
// g_unlink().
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) DeleteAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("delete_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// DeleteFinish finishes deleting a file started with g_file_delete_async().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) DeleteFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("delete_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// Dup duplicates a #GFile handle. This operation does not duplicate the actual
// file or directory represented by the #GFile; see g_file_copy() if attempting
// to copy a file.
//
// g_file_dup() is useful when a second handle is needed to the same underlying
// file, for use in a separate thread (#GFile is not thread-safe). For use
// within the same thread, use g_object_ref() to increment the existing object’s
// reference count.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - ret: new #GFile that is a duplicate of the given #GFile.
//
func (file *File) Dup() *File {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("dup", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _ret *File // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _ret
}

// EjectMountableFinish finishes an asynchronous eject operation started by
// g_file_eject_mountable().
//
// Deprecated: Use g_file_eject_mountable_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) EjectMountableFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("eject_mountable_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// EjectMountableWithOperationFinish finishes an asynchronous eject operation
// started by g_file_eject_mountable_with_operation().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) EjectMountableWithOperationFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("eject_mountable_with_operation_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// EnumerateChildrenFinish finishes an async enumerate children operation. See
// g_file_enumerate_children_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileEnumerator or NULL if an error occurred. Free the returned object
//      with g_object_unref().
//
func (file *File) EnumerateChildrenFinish(res AsyncResulter) (*FileEnumerator, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("enumerate_children_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileEnumerator *FileEnumerator // out
	var _goerr error                    // out

	_fileEnumerator = wrapFileEnumerator(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileEnumerator, _goerr
}

// Equal checks if the two given #GFiles refer to the same file.
//
// Note that two #GFiles that differ can still refer to the same file on the
// filesystem due to various forms of filename aliasing.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//    - file2: second #GFile.
//
// The function returns the following values:
//
//    - ok: TRUE if file1 and file2 are equal.
//
func (file1 *File) Equal(file2 Filer) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file1).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file2).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("equal", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file1)
	runtime.KeepAlive(file2)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// FindEnclosingMount gets a #GMount for the #GFile.
//
// #GMount is returned only for user interesting locations, see Monitor. If the
// Iface for file does not have a #mount, error will be set to
// G_IO_ERROR_NOT_FOUND and NULL #will be returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//    - mount where the file is located or NULL on error. Free the returned
//      object with g_object_unref().
//
func (file *File) FindEnclosingMount(ctx context.Context) (*Mount, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("find_enclosing_mount", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _mount *Mount // out
	var _goerr error  // out

	_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _mount, _goerr
}

// FindEnclosingMountAsync: asynchronously gets the mount for the file.
//
// For more details, see g_file_find_enclosing_mount() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_find_enclosing_mount_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) FindEnclosingMountAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("find_enclosing_mount_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// FindEnclosingMountFinish finishes an asynchronous find mount request. See
// g_file_find_enclosing_mount_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - mount for given file or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) FindEnclosingMountFinish(res AsyncResulter) (*Mount, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("find_enclosing_mount_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _mount *Mount // out
	var _goerr error  // out

	_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _mount, _goerr
}

// Basename gets the base name (the last component of the path) for a given
// #GFile.
//
// If called for the top level of a system (such as the filesystem root or a uri
// like sftp://host/) it will return a single directory separator (and on
// Windows, possibly a drive letter).
//
// The base name is a byte string (not UTF-8). It has no defined encoding or
// rules other than it may not contain zero bytes. If you want to use filenames
// in a user interface you should use the display name that you can get by
// requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with
// g_file_query_info().
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - filename (optional): string containing the #GFile's base name, or NULL if
//      given #GFile is invalid. The returned string should be freed with
//      g_free() when no longer needed.
//
func (file *File) Basename() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_basename", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _filename string // out

	if *(**C.char)(unsafe.Pointer(&_cret)) != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))
	}

	return _filename
}

// Child gets a child of file with basename equal to name.
//
// Note that the file with that specific name might not exist, but you can still
// have a #GFile that points to it. You can use this for instance to create that
// file.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//    - name: string containing the child's basename.
//
// The function returns the following values:
//
//    - ret to a child specified by name. Free the returned object with
//      g_object_unref().
//
func (file *File) Child(name string) *File {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(name)

	var _ret *File // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _ret
}

// ChildForDisplayName gets the child of file for a given display_name (i.e. a
// UTF-8 version of the name). If this function fails, it returns NULL and error
// will be set. This is very useful when constructing a #GFile for a new file
// and the user entered the filename in the user interface, for instance when
// you select a directory and type a filename in the file selector.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//    - displayName: string to a possible child.
//
// The function returns the following values:
//
//    - ret to the specified child, or NULL if the display name couldn't be
//      converted. Free the returned object with g_object_unref().
//
func (file *File) ChildForDisplayName(displayName string) (*File, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_child_for_display_name", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(displayName)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _ret, _goerr
}

// Parent gets the parent directory for the file. If the file represents the
// root directory of the file system, then NULL will be returned.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - ret (optional) structure to the parent of the given #GFile or NULL if
//      there is no parent. Free the returned object with g_object_unref().
//
func (file *File) Parent() *File {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_parent", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _ret *File // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	}

	return _ret
}

// ParseName gets the parse name of the file. A parse name is a UTF-8 string
// that describes the file such that one can get the #GFile back using
// g_file_parse_name().
//
// This is generally used to show the #GFile as a nice full-pathname kind of
// string in a user interface, like in a location entry.
//
// For local files with names that can safely be converted to UTF-8 the pathname
// is used, otherwise the IRI is used (a form of URI that allows UTF-8
// characters unescaped).
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - utf8: string containing the #GFile's parse name. The returned string
//      should be freed with g_free() when no longer needed.
//
func (file *File) ParseName() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_parse_name", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))

	return _utf8
}

// Path gets the local pathname for #GFile, if one exists. If non-NULL, this is
// guaranteed to be an absolute, canonical path. It might contain symlinks.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - filename (optional): string containing the #GFile's path, or NULL if no
//      such path exists. The returned string should be freed with g_free() when
//      no longer needed.
//
func (file *File) Path() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_path", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _filename string // out

	if *(**C.char)(unsafe.Pointer(&_cret)) != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))
	}

	return _filename
}

// RelativePath gets the path for descendant relative to parent.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//    - descendant: input #GFile.
//
// The function returns the following values:
//
//    - filename (optional): string with the relative path from descendant to
//      parent, or NULL if descendant doesn't have parent as prefix. The returned
//      string should be freed with g_free() when no longer needed.
//
func (parent *File) RelativePath(descendant Filer) string {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(descendant).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_relative_path", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(parent)
	runtime.KeepAlive(descendant)

	var _filename string // out

	if *(**C.char)(unsafe.Pointer(&_cret)) != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))
	}

	return _filename
}

// URI gets the URI for the file.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - utf8: string containing the #GFile's URI. If the #GFile was constructed
//      with an invalid URI, an invalid URI is returned. The returned string
//      should be freed with g_free() when no longer needed.
//
func (file *File) URI() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_uri", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))

	return _utf8
}

// URIScheme gets the URI scheme for a #GFile. RFC 3986 decodes the scheme as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include "file", "http", "ftp", etc.
//
// The scheme can be different from the one used to construct the #GFile, in
// that it might be replaced with one that is logically equivalent to the
// #GFile.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the URI scheme for the given #GFile or
//      NULL if the #GFile was constructed with an invalid URI. The returned
//      string should be freed with g_free() when no longer needed.
//
func (file *File) URIScheme() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("get_uri_scheme", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _utf8 string // out

	if *(**C.char)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))
	}

	return _utf8
}

// HasParent checks if file has a parent, and optionally, if it is parent.
//
// If parent is NULL then this function returns TRUE if file has any parent at
// all. If parent is non-NULL then TRUE is only returned if file is an immediate
// child of parent.
//
// The function takes the following parameters:
//
//    - parent (optional) to check for, or NULL.
//
// The function returns the following values:
//
//    - ok: TRUE if file is an immediate child of parent (or any parent in the
//      case that parent is NULL).
//
func (file *File) HasParent(parent Filer) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	if parent != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("has_parent", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(parent)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// HasPrefix checks whether file has the prefix specified by prefix.
//
// In other words, if the names of initial elements of file's pathname match
// prefix. Only full pathname elements are matched, so a path like /foo is not
// considered a prefix of /foobar, only of /foo/bar.
//
// A #GFile is not a prefix of itself. If you want to check for equality, use
// g_file_equal().
//
// This call does no I/O, as it works purely on names. As such it can sometimes
// return FALSE even if file is inside a prefix (from a filesystem point of
// view), because the prefix of file is an alias of prefix.
//
// The function takes the following parameters:
//
//    - prefix: input #GFile.
//
// The function returns the following values:
//
//    - ok: TRUE if the file's parent, grandparent, etc is prefix, FALSE
//      otherwise.
//
func (file *File) HasPrefix(prefix Filer) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(prefix).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("has_prefix", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(prefix)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// HasURIScheme checks to see if a #GFile has a given URI scheme.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//    - uriScheme: string containing a URI scheme.
//
// The function returns the following values:
//
//    - ok: TRUE if #GFile's backend supports the given URI scheme, FALSE if URI
//      scheme is NULL, not supported, or #GFile is invalid.
//
func (file *File) HasURIScheme(uriScheme string) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("has_uri_scheme", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(uriScheme)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Hash creates a hash value for a #GFile.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - guint: 0 if file is not a valid #GFile, otherwise an integer that can be
//      used as hash value for the #GFile. This function is intended for easily
//      hashing a #GFile to add to a Table or similar data structure.
//
func (file *File) Hash() uint32 {
	var _args [1]girepository.Argument

	*(*C.gpointer)(unsafe.Pointer(&_args[0])) = *(*C.gpointer)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("hash", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// IsNative checks to see if a file is native to the platform.
//
// A native file is one expressed in the platform-native filename format, e.g.
// "C:\Windows" or "/usr/bin/". This does not mean the file is local, as it
// might be on a locally mounted remote filesystem.
//
// On some systems non-native files may be available using the native filesystem
// via a userspace filesystem (FUSE), in these cases this call will return
// FALSE, but g_file_get_path() will still return a native path.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - ok: TRUE if file is native.
//
func (file *File) IsNative() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("is_native", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// LoadBytes loads the contents of file and returns it as #GBytes.
//
// If file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents() and g_bytes_new_take().
//
// For resources, etag_out will be set to NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//
// The function returns the following values:
//
//    - etagOut (optional): location to place the current entity tag for the
//      file, or NULL if the entity tag is not needed.
//    - bytes or NULL and error is set.
//
func (file *File) LoadBytes(ctx context.Context) (string, *glib.Bytes, error) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("load_bytes", _args[:], _outs[:])
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _etagOut string    // out
	var _bytes *glib.Bytes // out
	var _goerr error       // out

	if *(**C.gchar)(unsafe.Pointer(&_outs[0])) != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_outs[0])))))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_outs[0]))))
	}
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(*(**C.GBytes)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _etagOut, _bytes, _goerr
}

// LoadBytesAsync: asynchronously loads the contents of file as #GBytes.
//
// If file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents_async() and g_bytes_new_take().
//
// callback should call g_file_load_bytes_finish() to get the result of this
// asynchronous operation.
//
// See g_file_load_bytes() for more information.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) LoadBytesAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[2])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[3] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("load_bytes_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// LoadBytesFinish completes an asynchronous request to
// g_file_load_bytes_async().
//
// For resources, etag_out will be set to NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
//
// See g_file_load_bytes() for more information.
//
// The function takes the following parameters:
//
//    - result provided to the callback.
//
// The function returns the following values:
//
//    - etagOut (optional): location to place the current entity tag for the
//      file, or NULL if the entity tag is not needed.
//    - bytes or NULL and error is set.
//
func (file *File) LoadBytesFinish(result AsyncResulter) (string, *glib.Bytes, error) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("load_bytes_finish", _args[:], _outs[:])
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _etagOut string    // out
	var _bytes *glib.Bytes // out
	var _goerr error       // out

	if *(**C.gchar)(unsafe.Pointer(&_outs[0])) != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_outs[0])))))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_outs[0]))))
	}
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(*(**C.GBytes)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _etagOut, _bytes, _goerr
}

// LoadContents loads the content of the file into memory. The data is always
// zero-terminated, but this is not included in the resultant length. The
// returned contents should be freed with g_free() when no longer needed.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//    - contents: location to place the contents of the file.
//    - etagOut (optional): location to place the current entity tag for the
//      file, or NULL if the entity tag is not needed.
//
func (file *File) LoadContents(ctx context.Context) ([]byte, string, error) {
	var _args [2]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("load_contents", _args[:], _outs[:])

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _contents []byte // out
	var _etagOut string  // out
	var _goerr error     // out

	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[0]))))
	_contents = make([]byte, *(*C.gsize)(unsafe.Pointer(&_outs[1])))
	copy(_contents, unsafe.Slice((*byte)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[0])))), *(*C.gsize)(unsafe.Pointer(&_outs[1]))))
	if *(**C.char)(unsafe.Pointer(&_outs[2])) != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[2])))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[2]))))
	}
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _contents, _etagOut, _goerr
}

// LoadContentsAsync starts an asynchronous load of the file's contents.
//
// For more details, see g_file_load_contents() which is the synchronous version
// of this call.
//
// When the load operation has completed, callback will be called with user
// data. To finish the operation, call g_file_load_contents_finish() with the
// Result returned by the callback.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) LoadContentsAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[2])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[3] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("load_contents_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// LoadContentsFinish finishes an asynchronous load of the file's contents. The
// contents are placed in contents, and length is set to the size of the
// contents string. The contents should be freed with g_free() when no longer
// needed. If etag_out is present, it will be set to the new entity tag for the
// file.
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - contents: location to place the contents of the file.
//    - etagOut (optional): location to place the current entity tag for the
//      file, or NULL if the entity tag is not needed.
//
func (file *File) LoadContentsFinish(res AsyncResulter) ([]byte, string, error) {
	var _args [2]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("load_contents_finish", _args[:], _outs[:])

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _contents []byte // out
	var _etagOut string  // out
	var _goerr error     // out

	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[0]))))
	_contents = make([]byte, *(*C.gsize)(unsafe.Pointer(&_outs[1])))
	copy(_contents, unsafe.Slice((*byte)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[0])))), *(*C.gsize)(unsafe.Pointer(&_outs[1]))))
	if *(**C.char)(unsafe.Pointer(&_outs[2])) != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[2])))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[2]))))
	}
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _contents, _etagOut, _goerr
}

// LoadPartialContentsFinish finishes an asynchronous partial load operation
// that was started with g_file_load_partial_contents_async(). The data is
// always zero-terminated, but this is not included in the resultant length. The
// returned contents should be freed with g_free() when no longer needed.
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - contents: location to place the contents of the file.
//    - etagOut (optional): location to place the current entity tag for the
//      file, or NULL if the entity tag is not needed.
//
func (file *File) LoadPartialContentsFinish(res AsyncResulter) ([]byte, string, error) {
	var _args [2]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("load_partial_contents_finish", _args[:], _outs[:])

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _contents []byte // out
	var _etagOut string  // out
	var _goerr error     // out

	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[0]))))
	_contents = make([]byte, *(*C.gsize)(unsafe.Pointer(&_outs[1])))
	copy(_contents, unsafe.Slice((*byte)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[0])))), *(*C.gsize)(unsafe.Pointer(&_outs[1]))))
	if *(**C.char)(unsafe.Pointer(&_outs[2])) != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[2])))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[2]))))
	}
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _contents, _etagOut, _goerr
}

// MakeDirectory creates a directory. Note that this will only create a child
// directory of the immediate parent directory of the path or URI given by the
// #GFile. To recursively create directories, see
// g_file_make_directory_with_parents(). This function will fail if the parent
// directory does not exist, setting error to G_IO_ERROR_NOT_FOUND. If the file
// system doesn't support creating directories, this function will fail, setting
// error to G_IO_ERROR_NOT_SUPPORTED.
//
// For a local #GFile the newly created directory will have the default
// (current) ownership and permissions of the current process.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
func (file *File) MakeDirectory(ctx context.Context) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("make_directory", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// MakeDirectoryAsync: asynchronously creates a directory.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) MakeDirectoryAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("make_directory_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// MakeDirectoryFinish finishes an asynchronous directory creation, started with
// g_file_make_directory_async().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) MakeDirectoryFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("make_directory_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// MakeDirectoryWithParents creates a directory and any parent directories that
// may not exist similar to 'mkdir -p'. If the file system does not support
// creating directories, this function will fail, setting error to
// G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this
// function will fail setting error to G_IO_ERROR_EXISTS, unlike the similar
// g_mkdir_with_parents().
//
// For a local #GFile the newly created directories will have the default
// (current) ownership and permissions of the current process.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
func (file *File) MakeDirectoryWithParents(ctx context.Context) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("make_directory_with_parents", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// MakeSymbolicLink creates a symbolic link named file which contains the string
// symlink_value.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - symlinkValue: string with the path for the target of the new symlink.
//
func (file *File) MakeSymbolicLink(ctx context.Context, symlinkValue string) error {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(symlinkValue)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("make_symbolic_link", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(symlinkValue)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// MeasureDiskUsageFinish collects the results from an earlier call to
// g_file_measure_disk_usage_async(). See g_file_measure_disk_usage() for more
// information.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - diskUsage (optional): number of bytes of disk space used.
//    - numDirs (optional): number of directories encountered.
//    - numFiles (optional): number of non-directories encountered.
//
func (file *File) MeasureDiskUsageFinish(result AsyncResulter) (diskUsage, numDirs, numFiles uint64, goerr error) {
	var _args [2]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("measure_disk_usage_finish", _args[:], _outs[:])

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _diskUsage uint64 // out
	var _numDirs uint64   // out
	var _numFiles uint64  // out
	var _goerr error      // out

	_diskUsage = uint64(*(*C.guint64)(unsafe.Pointer(&_outs[0])))
	_numDirs = uint64(*(*C.guint64)(unsafe.Pointer(&_outs[1])))
	_numFiles = uint64(*(*C.guint64)(unsafe.Pointer(&_outs[2])))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _diskUsage, _numDirs, _numFiles, _goerr
}

// MountEnclosingVolumeFinish finishes a mount operation started by
// g_file_mount_enclosing_volume().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (location *File) MountEnclosingVolumeFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(location).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("mount_enclosing_volume_finish", _args[:], nil)

	runtime.KeepAlive(location)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// MountMountableFinish finishes a mount operation. See g_file_mount_mountable()
// for details.
//
// Finish an asynchronous mount operation that was started with
// g_file_mount_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
// The function returns the following values:
//
//    - ret or NULL on error. Free the returned object with g_object_unref().
//
func (file *File) MountMountableFinish(result AsyncResulter) (*File, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("mount_mountable_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _ret, _goerr
}

// OpenReadwrite opens an existing file for reading and writing. The result is a
// IOStream that can be used to read and write the contents of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on. Note that in many non-local file cases read and
// write streams are not supported, so make sure you really need to do read and
// write streaming, rather than just opening for reading or writing.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) OpenReadwrite(ctx context.Context) (*FileIOStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("open_readwrite", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileIOStream, _goerr
}

// OpenReadwriteAsync: asynchronously opens file for reading and writing.
//
// For more details, see g_file_open_readwrite() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_open_readwrite_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) OpenReadwriteAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("open_readwrite_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// OpenReadwriteFinish finishes an asynchronous file read operation started with
// g_file_open_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) OpenReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("open_readwrite_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileIOStream, _goerr
}

// PeekPath: exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full(). This is useful for example in C applications which
// mix g_file_* APIs with native ones. It also avoids an extra duplicated string
// when possible, so will be generally more efficient.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - filename (optional): string containing the #GFile's path, or NULL if no
//      such path exists. The returned string is owned by file.
//
func (file *File) PeekPath() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("peek_path", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _filename string // out

	if *(**C.char)(unsafe.Pointer(&_cret)) != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
	}

	return _filename
}

// PollMountable polls a file of type FILE_TYPE_MOUNTABLE.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// When the operation is finished, callback will be called. You can then call
// g_file_mount_mountable_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - callback (optional) to call when the request is satisfied, or NULL.
//
func (file *File) PollMountable(ctx context.Context, callback AsyncReadyCallback) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[2])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[3] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("poll_mountable", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// PollMountableFinish finishes a poll operation. See g_file_poll_mountable()
// for details.
//
// Finish an asynchronous poll operation that was polled with
// g_file_poll_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) PollMountableFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("poll_mountable_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// QueryDefaultHandler returns the Info that is registered as the default
// application to handle the file specified by file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//    - appInfo if the handle was found, NULL if there were errors. When you are
//      done with it, release it with g_object_unref().
//
func (file *File) QueryDefaultHandler(ctx context.Context) (*AppInfo, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("query_default_handler", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _appInfo *AppInfo // out
	var _goerr error      // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _appInfo, _goerr
}

// QueryDefaultHandlerAsync: async version of g_file_query_default_handler().
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is done.
//
func (file *File) QueryDefaultHandlerAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("query_default_handler_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// QueryDefaultHandlerFinish finishes a g_file_query_default_handler_async()
// operation.
//
// The function takes the following parameters:
//
//    - result: Result.
//
// The function returns the following values:
//
//    - appInfo if the handle was found, NULL if there were errors. When you are
//      done with it, release it with g_object_unref().
//
func (file *File) QueryDefaultHandlerFinish(result AsyncResulter) (*AppInfo, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("query_default_handler_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _appInfo *AppInfo // out
	var _goerr error      // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _appInfo, _goerr
}

// QueryExists: utility function to check if a particular file exists. This is
// implemented using g_file_query_info() and as such does blocking I/O.
//
// Note that in many cases it is racy to first check for file existence
// (https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and then execute
// something based on the outcome of that, because the file might have been
// created or removed in between the operations. The general approach to
// handling that is to not check, but just do the operation and handle the
// errors as they come.
//
// As an example of race-free checking, take the case of reading a file, and if
// it doesn't exist, creating it. There are two racy versions: read it, and on
// error create it; and: check if it exists, if not create it. These can both
// result in two processes creating the file (with perhaps a partially written
// file as the result). The correct approach is to always try to create the file
// with g_file_create() which will either atomically create the file or fail
// with a G_IO_ERROR_EXISTS error.
//
// However, in many cases an existence check is useful in a user interface, for
// instance to make a menu item sensitive/insensitive, so that you don't have to
// fool users that something is possible and then just show an error dialog. If
// you do this, you should make sure to also handle the errors that can happen
// due to races when you execute the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//    - ok: TRUE if the file exists (and can be detected without error), FALSE
//      otherwise (or if cancelled).
//
func (file *File) QueryExists(ctx context.Context) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("query_exists", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// QueryFilesystemInfo: similar to g_file_query_info(), but obtains information
// about the filesystem the file is on, rather than the file itself. For
// instance the amount of space available and the type of the filesystem.
//
// The attributes value is a string that specifies the attributes that should be
// gathered. It is not an error if it's not possible to read a particular
// requested attribute from a file - it just won't be set. attributes should be
// a comma-separated list of attributes or attribute wildcards. The wildcard "*"
// means all attributes, and a wildcard like "filesystem::*" means all
// attributes in the filesystem namespace. The standard namespace for filesystem
// attributes is "filesystem". Common attributes of interest are
// FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes),
// FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available), and
// FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// Other errors are possible too, and depend on what kind of filesystem the file
// is on.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - attributes: attribute query string.
//
// The function returns the following values:
//
//    - fileInfo or NULL if there was an error. Free the returned object with
//      g_object_unref().
//
func (file *File) QueryFilesystemInfo(ctx context.Context, attributes string) (*FileInfo, error) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("query_filesystem_info", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileInfo, _goerr
}

// QueryFilesystemInfoAsync: asynchronously gets the requested information about
// the filesystem that the specified file is on. The result is a Info object
// that contains key-value attributes (such as type or size for the file).
//
// For more details, see g_file_query_filesystem_info() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_query_info_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - attributes: attribute query string.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) QueryFilesystemInfoAsync(ctx context.Context, attributes string, ioPriority int32, callback AsyncReadyCallback) {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[3] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(attributes)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[4])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[5] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("query_filesystem_info_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// QueryFilesystemInfoFinish finishes an asynchronous filesystem info query. See
// g_file_query_filesystem_info_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileInfo for given file or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) QueryFilesystemInfoFinish(res AsyncResulter) (*FileInfo, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("query_filesystem_info_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileInfo, _goerr
}

// QueryInfoFinish finishes an asynchronous file info query. See
// g_file_query_info_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileInfo for given file or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) QueryInfoFinish(res AsyncResulter) (*FileInfo, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("query_info_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInfo *FileInfo // out
	var _goerr error        // out

	_fileInfo = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileInfo, _goerr
}

// QuerySettableAttributes: obtain the list of settable attributes for the file.
//
// Returns the type and full attribute name of all the attributes that can be
// set on this file. This doesn't mean setting it will always succeed though,
// you might get an access failure, or some specific file may not support a
// specific attribute.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//    - fileAttributeInfoList describing the settable attributes. When you are
//      done with it, release it with g_file_attribute_info_list_unref().
//
func (file *File) QuerySettableAttributes(ctx context.Context) (*FileAttributeInfoList, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("query_settable_attributes", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileAttributeInfoList *FileAttributeInfoList // out
	var _goerr error                                  // out

	_fileAttributeInfoList = (*FileAttributeInfoList)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeInfoList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileAttributeInfoList, _goerr
}

// QueryWritableNamespaces: obtain the list of attribute namespaces where new
// attributes can be created by a user. An example of this is extended
// attributes (in the "xattr" namespace).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
// The function returns the following values:
//
//    - fileAttributeInfoList describing the writable namespaces. When you are
//      done with it, release it with g_file_attribute_info_list_unref().
//
func (file *File) QueryWritableNamespaces(ctx context.Context) (*FileAttributeInfoList, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("query_writable_namespaces", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileAttributeInfoList *FileAttributeInfoList // out
	var _goerr error                                  // out

	_fileAttributeInfoList = (*FileAttributeInfoList)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fileAttributeInfoList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileAttributeInfoList, _goerr
}

// Read opens a file for reading. The result is a InputStream that can be used
// to read the contents of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.
// If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be
// returned. Other errors are possible too, and depend on what kind of
// filesystem the file is on.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//    - fileInputStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) Read(ctx context.Context) (*FileInputStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("read", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _fileInputStream *FileInputStream // out
	var _goerr error                      // out

	_fileInputStream = wrapFileInputStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileInputStream, _goerr
}

// ReadAsync: asynchronously opens file for reading.
//
// For more details, see g_file_read() which is the synchronous version of this
// call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_read_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) ReadAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("read_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// ReadFinish finishes an asynchronous file read operation started with
// g_file_read_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileInputStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) ReadFinish(res AsyncResulter) (*FileInputStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("read_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileInputStream *FileInputStream // out
	var _goerr error                      // out

	_fileInputStream = wrapFileInputStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileInputStream, _goerr
}

// ReplaceContentsFinish finishes an asynchronous replace of the given file. See
// g_file_replace_contents_async(). Sets new_etag to the new entity tag for the
// document, if present.
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - newEtag (optional): location of a new [entity tag][gfile-etag] for the
//      document. This should be freed with g_free() when it is no longer needed,
//      or NULL.
//
func (file *File) ReplaceContentsFinish(res AsyncResulter) (string, error) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("replace_contents_finish", _args[:], _outs[:])

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _newEtag string // out
	var _goerr error    // out

	if *(**C.char)(unsafe.Pointer(&_outs[0])) != nil {
		_newEtag = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[0])))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[0]))))
	}
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _newEtag, _goerr
}

// ReplaceFinish finishes an asynchronous file replace operation started with
// g_file_replace_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileOutputStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) ReplaceFinish(res AsyncResulter) (*FileOutputStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("replace_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileOutputStream *FileOutputStream // out
	var _goerr error                        // out

	_fileOutputStream = wrapFileOutputStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileOutputStream, _goerr
}

// ReplaceReadwriteFinish finishes an asynchronous file replace operation
// started with g_file_replace_readwrite_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - fileIOStream or NULL on error. Free the returned object with
//      g_object_unref().
//
func (file *File) ReplaceReadwriteFinish(res AsyncResulter) (*FileIOStream, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("replace_readwrite_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _fileIOStream *FileIOStream // out
	var _goerr error                // out

	_fileIOStream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _fileIOStream, _goerr
}

// ResolveRelativePath resolves a relative path for file to an absolute path.
//
// This call does no blocking I/O.
//
// The function takes the following parameters:
//
//    - relativePath: given relative path string.
//
// The function returns the following values:
//
//    - ret to the resolved path. NULL if relative_path is NULL or if file is
//      invalid. Free the returned object with g_object_unref().
//
func (file *File) ResolveRelativePath(relativePath string) *File {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(relativePath)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("resolve_relative_path", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(relativePath)

	var _ret *File // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _ret
}

// SetAttributesFinish finishes setting an attribute started in
// g_file_set_attributes_async().
//
// The function takes the following parameters:
//
//    - result: Result.
//
// The function returns the following values:
//
//    - info: Info.
//
func (file *File) SetAttributesFinish(result AsyncResulter) (*FileInfo, error) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("set_attributes_finish", _args[:], _outs[:])

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _info *FileInfo // out
	var _goerr error    // out

	_info = wrapFileInfo(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0])))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _info, _goerr
}

// SetDisplayName renames file to the specified display name.
//
// The display name is converted from UTF-8 to the correct encoding for the
// target filesystem if possible and the file is renamed to this.
//
// If you want to implement a rename operation in the user interface the edit
// name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value
// in the rename widget, and then the result after editing should be passed to
// g_file_set_display_name().
//
// On success the resulting converted filename is returned.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - displayName: string.
//
// The function returns the following values:
//
//    - ret specifying what file was renamed to, or NULL if there was an error.
//      Free the returned object with g_object_unref().
//
func (file *File) SetDisplayName(ctx context.Context, displayName string) (*File, error) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("set_display_name", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(displayName)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _ret, _goerr
}

// SetDisplayNameAsync: asynchronously sets the display name for a given #GFile.
//
// For more details, see g_file_set_display_name() which is the synchronous
// version of this call.
//
// When the operation is finished, callback will be called. You can then call
// g_file_set_display_name_finish() to get the result of the operation.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - displayName: string.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) SetDisplayNameAsync(ctx context.Context, displayName string, ioPriority int32, callback AsyncReadyCallback) {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[3] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[4])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[5] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("set_display_name_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(displayName)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// SetDisplayNameFinish finishes setting a display name started with
// g_file_set_display_name_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - ret or NULL on error. Free the returned object with g_object_unref().
//
func (file *File) SetDisplayNameFinish(res AsyncResulter) (*File, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("set_display_name_finish", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)
	runtime.KeepAlive(res)

	var _ret *File   // out
	var _goerr error // out

	_ret = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _ret, _goerr
}

// StartMountableFinish finishes a start operation. See g_file_start_mountable()
// for details.
//
// Finish an asynchronous start operation that was started with
// g_file_start_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) StartMountableFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("start_mountable_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// StopMountableFinish finishes a stop operation, see g_file_stop_mountable()
// for details.
//
// Finish an asynchronous stop operation that was started with
// g_file_stop_mountable().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) StopMountableFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("stop_mountable_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// SupportsThreadContexts checks if file supports [thread-default
// contexts][g-main-context-push-thread-default-context]. If this returns FALSE,
// you cannot perform asynchronous operations on file in a thread that has a
// thread-default context.
//
// The function returns the following values:
//
//    - ok: whether or not file supports thread-default contexts.
//
func (file *File) SupportsThreadContexts() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_info := girepository.MustFind("Gio", "File")
	_gret := _info.InvokeIfaceMethod("supports_thread_contexts", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(file)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Trash sends file to the "Trashcan", if possible. This is similar to deleting
// it, but the user can recover it before emptying the trashcan. Not all file
// systems support trashing, so this call can return the
// G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the x-gvfs-notrash unix
// mount option can be used to disable g_file_trash() support for certain
// mounts, the G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
func (file *File) Trash(ctx context.Context) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("trash", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// TrashAsync: asynchronously sends file to the Trash location, if possible.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - ioPriority: [I/O priority][io-priority] of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) TrashAsync(ctx context.Context, ioPriority int32, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(ioPriority)
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("trash_async", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// TrashFinish finishes an asynchronous file trashing operation, started with
// g_file_trash_async().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) TrashFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("trash_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// UnmountMountableFinish finishes an unmount operation, see
// g_file_unmount_mountable() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable().
//
// Deprecated: Use g_file_unmount_mountable_with_operation_finish() instead.
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) UnmountMountableFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("unmount_mountable_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// UnmountMountableWithOperationFinish finishes an unmount operation, see
// g_file_unmount_mountable_with_operation() for details.
//
// Finish an asynchronous unmount operation that was started with
// g_file_unmount_mountable_with_operation().
//
// The function takes the following parameters:
//
//    - result: Result.
//
func (file *File) UnmountMountableWithOperationFinish(result AsyncResulter) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_info := girepository.MustFind("Gio", "File")
	_info.InvokeIfaceMethod("unmount_mountable_with_operation_finish", _args[:], nil)

	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// NewFileForCommandlineArg creates a #GFile with the given argument from the
// command line. The value of arg can be either a URI, an absolute path or a
// relative path resolved relative to the current working directory. This
// operation never fails, but the returned object might not support any I/O
// operation if arg points to a malformed path.
//
// Note that on Windows, this function expects its argument to be in UTF-8 --
// not the system code page. This means that you should not use this function
// with string from argv as it is passed to main(). g_win32_get_command_line()
// will return a UTF-8 version of the commandline. #GApplication also uses UTF-8
// but g_application_command_line_create_file_for_arg() may be more useful for
// you there. It is also always possible to use this function with Context
// arguments of type G_OPTION_ARG_FILENAME.
//
// The function takes the following parameters:
//
//    - arg: command line string.
//
// The function returns the following values:
//
//    - file: new #GFile. Free the returned object with g_object_unref().
//
func NewFileForCommandlineArg(arg string) *File {
	var _args [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gio", "new_for_commandline_arg")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(arg)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _file
}

// NewFileForCommandlineArgAndCwd creates a #GFile with the given argument from
// the command line.
//
// This function is similar to g_file_new_for_commandline_arg() except that it
// allows for passing the current working directory as an argument instead of
// using the current working directory of the process.
//
// This is useful if the commandline argument was given in a context other than
// the invocation of the current process.
//
// See also g_application_command_line_create_file_for_arg().
//
// The function takes the following parameters:
//
//    - arg: command line string.
//    - cwd: current working directory of the commandline.
//
// The function returns the following values:
//
//    - file: new #GFile.
//
func NewFileForCommandlineArgAndCwd(arg, cwd string) *File {
	var _args [2]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(arg)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(cwd)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "new_for_commandline_arg_and_cwd")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(arg)
	runtime.KeepAlive(cwd)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _file
}

// NewFileForPath constructs a #GFile for a given path. This operation never
// fails, but the returned object might not support any I/O operation if path is
// malformed.
//
// The function takes the following parameters:
//
//    - path: string containing a relative or absolute path. The string must be
//      encoded in the glib filename encoding.
//
// The function returns the following values:
//
//    - file: new #GFile for the given path. Free the returned object with
//      g_object_unref().
//
func NewFileForPath(path string) *File {
	var _args [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gio", "new_for_path")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _file
}

// NewFileForURI constructs a #GFile for a given URI. This operation never
// fails, but the returned object might not support any I/O operation if uri is
// malformed or if the uri type is not supported.
//
// The function takes the following parameters:
//
//    - uri: UTF-8 string containing a URI.
//
// The function returns the following values:
//
//    - file: new #GFile for the given uri. Free the returned object with
//      g_object_unref().
//
func NewFileForURI(uri string) *File {
	var _args [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gio", "new_for_uri")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(uri)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _file
}

// NewFileTmp opens a file in the preferred directory for temporary files (as
// returned by g_get_tmp_dir()) and returns a #GFile and IOStream pointing to
// it.
//
// tmpl should be a string in the GLib file name encoding containing a sequence
// of six 'X' characters, and containing no directory components. If it is NULL,
// a default template is used.
//
// Unlike the other #GFile constructors, this will return NULL if a temporary
// file could not be created.
//
// The function takes the following parameters:
//
//    - tmpl (optional): template for the file name, as in g_file_open_tmp(), or
//      NULL for a default template.
//
// The function returns the following values:
//
//    - iostream: on return, a IOStream for the created file.
//    - file: new #GFile. Free the returned object with g_object_unref().
//
func NewFileTmp(tmpl string) (*FileIOStream, *File, error) {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	if tmpl != "" {
		*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(tmpl)))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))
	}

	_info := girepository.MustFind("Gio", "new_tmp")
	_gret := _info.InvokeFunction(_args[:], _outs[:])
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(tmpl)

	var _iostream *FileIOStream // out
	var _file *File             // out
	var _goerr error            // out

	_iostream = wrapFileIOStream(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0])))))
	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _iostream, _file, _goerr
}

// FileParseName constructs a #GFile with the given parse_name (i.e. something
// given by g_file_get_parse_name()). This operation never fails, but the
// returned object might not support any I/O operation if the parse_name cannot
// be parsed.
//
// The function takes the following parameters:
//
//    - parseName: file name or path to be parsed.
//
// The function returns the following values:
//
//    - file: new #GFile.
//
func FileParseName(parseName string) *File {
	var _args [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(parseName)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gio", "parse_name")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(parseName)

	var _file *File // out

	_file = wrapFile(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _file
}

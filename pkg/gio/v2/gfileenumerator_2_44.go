// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// Iterate: this is a version of g_file_enumerator_next_file() that's easier to
// use correctly from C programs. With g_file_enumerator_next_file(), the
// gboolean return value signifies "end of iteration or error", which requires
// allocation of a temporary #GError.
//
// In contrast, with this function, a FALSE return from
// g_file_enumerator_iterate() *always* means "error". End of iteration is
// signaled by out_info or out_child being NULL.
//
// Another crucial difference is that the references for out_info and out_child
// are owned by direnum (they are cached as hidden properties). You must not
// unref them in your own code. This makes memory management significantly
// easier for C code in combination with loops.
//
// Finally, this function optionally allows retrieving a #GFile as well.
//
// You must specify at least one of out_info or out_child.
//
// The code pattern for correctly using g_file_enumerator_iterate() from C is:
//
//    direnum = g_file_enumerate_children (file, ...);
//    while (TRUE)
//      {
//        GFileInfo *info;
//        if (!g_file_enumerator_iterate (direnum, &info, NULL, cancellable, error))
//          goto out;
//        if (!info)
//          break;
//        ... do stuff with "info"; do not unref it! ...
//      }
//
//    out:
//      g_object_unref (direnum); // Note: frees the last info.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//    - outInfo (optional): output location for the next Info, or NULL.
//    - outChild (optional): output location for the next #GFile, or NULL.
//
func (direnum *FileEnumerator) Iterate(ctx context.Context) (*FileInfo, *File, error) {
	var _arg0 *C.GFileEnumerator // out
	var _arg3 *C.GCancellable    // out
	var _arg1 *C.GFileInfo       // in
	var _arg2 *C.GFile           // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GFileEnumerator)(unsafe.Pointer(coreglib.InternObject(direnum).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_enumerator_iterate(_arg0, &_arg1, &_arg2, _arg3, &_cerr)
	runtime.KeepAlive(direnum)
	runtime.KeepAlive(ctx)

	var _outInfo *FileInfo // out
	var _outChild *File    // out
	var _goerr error       // out

	if _arg1 != nil {
		_outInfo = wrapFileInfo(coreglib.Take(unsafe.Pointer(_arg1)))
	}
	if _arg2 != nil {
		_outChild = wrapFile(coreglib.Take(unsafe.Pointer(_arg2)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outInfo, _outChild, _goerr
}

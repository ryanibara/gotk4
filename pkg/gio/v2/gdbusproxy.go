// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern void _gotk4_gio2_DBusProxyClass_g_signal(GDBusProxy*, gchar*, gchar*, GVariant*);
// extern void _gotk4_gio2_DBusProxy_ConnectGSignal(gpointer, gchar*, gchar*, GVariant*, guintptr);
import "C"

// glib.Type values for gdbusproxy.go.
var GTypeDBusProxy = externglib.Type(C.g_dbus_proxy_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeDBusProxy, F: marshalDBusProxy},
	})
}

// DBusProxyOverrider contains methods that are overridable.
type DBusProxyOverrider interface {
	externglib.Objector
	// The function takes the following parameters:
	//
	//    - senderName
	//    - signalName
	//    - parameters
	//
	GSignal(senderName, signalName string, parameters *glib.Variant)
}

// WrapDBusProxyOverrider wraps the DBusProxyOverrider
// interface implementation to access the instance methods.
func WrapDBusProxyOverrider(obj DBusProxyOverrider) *DBusProxy {
	return wrapDBusProxy(externglib.BaseObject(obj))
}

// DBusProxy is a base class used for proxies to access a D-Bus interface on a
// remote object. A BusProxy can be constructed for both well-known and unique
// names.
//
// By default, BusProxy will cache all properties (and listen to changes) of the
// remote object, and proxy all signals that get emitted. This behaviour can be
// changed by passing suitable BusProxyFlags when the proxy is created. If the
// proxy is for a well-known name, the property cache is flushed when the name
// owner vanishes and reloaded when a name owner appears.
//
// The unique name owner of the proxy's name is tracked and can be read from
// BusProxy:g-name-owner. Connect to the #GObject::notify signal to get notified
// of changes. Additionally, only signals and property changes emitted from the
// current name owner are considered and calls are always sent to the current
// name owner. This avoids a number of race conditions when the name is lost by
// one owner and claimed by another. However, if no name owner currently exists,
// then calls will be sent to the well-known name which may result in the
// message bus launching an owner (unless G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START
// is set).
//
// The generic BusProxy::g-properties-changed and BusProxy::g-signal signals are
// not very convenient to work with. Therefore, the recommended way of working
// with proxies is to subclass BusProxy, and have more natural properties and
// signals in your derived class. This [example][gdbus-example-gdbus-codegen]
// shows how this can easily be done using the [gdbus-codegen][gdbus-codegen]
// tool.
//
// A BusProxy instance can be used from multiple threads but note that all
// signals (e.g. BusProxy::g-signal, BusProxy::g-properties-changed and
// #GObject::notify) are emitted in the [thread-default main
// context][g-main-context-push-thread-default] of the thread where the instance
// was constructed.
//
// An example using a proxy for a well-known name can be found in
// gdbus-example-watch-proxy.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-proxy.c).
type DBusProxy struct {
	_ [0]func() // equal guard
	*externglib.Object

	AsyncInitable
	DBusInterface
	Initable
}

var (
	_ externglib.Objector = (*DBusProxy)(nil)
)

func classInitDBusProxier(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GDBusProxyClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GDBusProxyClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface {
		GSignal(senderName, signalName string, parameters *glib.Variant)
	}); ok {
		pclass.g_signal = (*[0]byte)(C._gotk4_gio2_DBusProxyClass_g_signal)
	}
}

//export _gotk4_gio2_DBusProxyClass_g_signal
func _gotk4_gio2_DBusProxyClass_g_signal(arg0 *C.GDBusProxy, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.GVariant) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		GSignal(senderName, signalName string, parameters *glib.Variant)
	})

	var _senderName string        // out
	var _signalName string        // out
	var _parameters *glib.Variant // out

	_senderName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_signalName = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_parameters = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.g_variant_ref(arg3)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_parameters)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	iface.GSignal(_senderName, _signalName, _parameters)
}

func wrapDBusProxy(obj *externglib.Object) *DBusProxy {
	return &DBusProxy{
		Object: obj,
		AsyncInitable: AsyncInitable{
			Object: obj,
		},
		DBusInterface: DBusInterface{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalDBusProxy(p uintptr) (interface{}, error) {
	return wrapDBusProxy(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gio2_DBusProxy_ConnectGSignal
func _gotk4_gio2_DBusProxy_ConnectGSignal(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.GVariant, arg4 C.guintptr) {
	var f func(senderName, signalName string, parameters *glib.Variant)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(senderName, signalName string, parameters *glib.Variant))
	}

	var _senderName string        // out
	var _signalName string        // out
	var _parameters *glib.Variant // out

	if arg1 != nil {
		_senderName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}
	_signalName = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_parameters = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.g_variant_ref(arg3)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_parameters)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	f(_senderName, _signalName, _parameters)
}

// ConnectGSignal is emitted when a signal from the remote object and interface
// that proxy is for, has been received.
func (proxy *DBusProxy) ConnectGSignal(f func(senderName, signalName string, parameters *glib.Variant)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(proxy, "g-signal", false, unsafe.Pointer(C._gotk4_gio2_DBusProxy_ConnectGSignal), f)
}

// NewDBusProxyFinish finishes creating a BusProxy.
//
// The function takes the following parameters:
//
//    - res obtained from the ReadyCallback function passed to
//      g_dbus_proxy_new().
//
// The function returns the following values:
//
//    - dBusProxy or NULL if error is set. Free with g_object_unref().
//
func NewDBusProxyFinish(res AsyncResultOverrider) (*DBusProxy, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GDBusProxy   // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(externglib.InternObject(res).Native()))

	_cret = C.g_dbus_proxy_new_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusProxy *DBusProxy // out
	var _goerr error          // out

	_dBusProxy = wrapDBusProxy(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusProxy, _goerr
}

// NewDBusProxyForBusFinish finishes creating a BusProxy.
//
// The function takes the following parameters:
//
//    - res obtained from the ReadyCallback function passed to
//      g_dbus_proxy_new_for_bus().
//
// The function returns the following values:
//
//    - dBusProxy or NULL if error is set. Free with g_object_unref().
//
func NewDBusProxyForBusFinish(res AsyncResultOverrider) (*DBusProxy, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GDBusProxy   // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(externglib.InternObject(res).Native()))

	_cret = C.g_dbus_proxy_new_for_bus_finish(_arg1, &_cerr)
	runtime.KeepAlive(res)

	var _dBusProxy *DBusProxy // out
	var _goerr error          // out

	_dBusProxy = wrapDBusProxy(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusProxy, _goerr
}

// NewDBusProxyForBusSync: like g_dbus_proxy_new_sync() but takes a Type instead
// of a BusConnection.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - busType: Type.
//    - flags flags used when constructing the proxy.
//    - info (optional) specifying the minimal interface that proxy conforms to
//      or NULL.
//    - name bus name (well-known or unique).
//    - objectPath: object path.
//    - interfaceName d-Bus interface name.
//
// The function returns the following values:
//
//    - dBusProxy or NULL if error is set. Free with g_object_unref().
//
func NewDBusProxyForBusSync(ctx context.Context, busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name, objectPath, interfaceName string) (*DBusProxy, error) {
	var _arg7 *C.GCancellable       // out
	var _arg1 C.GBusType            // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _cret *C.GDBusProxy         // in
	var _cerr *C.GError             // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GBusType(busType)
	_arg2 = C.GDBusProxyFlags(flags)
	if info != nil {
		_arg3 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg6))

	_cret = C.g_dbus_proxy_new_for_bus_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)

	var _dBusProxy *DBusProxy // out
	var _goerr error          // out

	_dBusProxy = wrapDBusProxy(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusProxy, _goerr
}

// NewDBusProxySync creates a proxy for accessing interface_name on the remote
// object at object_path owned by name at connection and synchronously loads
// D-Bus properties unless the G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is
// used.
//
// If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets
// up match rules for signals. Connect to the BusProxy::g-signal signal to
// handle signals from the remote object.
//
// If both G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
// G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
// guaranteed to return immediately without blocking.
//
// If name is a well-known name and the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and
// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION flags aren't set and no
// name owner currently exists, the message bus will be requested to launch a
// name owner for the name.
//
// This is a synchronous failable constructor. See g_dbus_proxy_new() and
// g_dbus_proxy_new_finish() for the asynchronous version.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - connection: BusConnection.
//    - flags flags used when constructing the proxy.
//    - info (optional) specifying the minimal interface that proxy conforms to
//      or NULL.
//    - name (optional) bus name (well-known or unique) or NULL if connection is
//      not a message bus connection.
//    - objectPath: object path.
//    - interfaceName d-Bus interface name.
//
// The function returns the following values:
//
//    - dBusProxy or NULL if error is set. Free with g_object_unref().
//
func NewDBusProxySync(ctx context.Context, connection *DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name, objectPath, interfaceName string) (*DBusProxy, error) {
	var _arg7 *C.GCancellable       // out
	var _arg1 *C.GDBusConnection    // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _cret *C.GDBusProxy         // in
	var _cerr *C.GError             // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(externglib.InternObject(connection).Native()))
	_arg2 = C.GDBusProxyFlags(flags)
	if info != nil {
		_arg3 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}
	if name != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg6))

	_cret = C.g_dbus_proxy_new_sync(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)

	var _dBusProxy *DBusProxy // out
	var _goerr error          // out

	_dBusProxy = wrapDBusProxy(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusProxy, _goerr
}

// Call: asynchronously invokes the method_name method on proxy.
//
// If method_name contains any dots, then name is split into interface and
// method name parts. This allows using proxy for invoking methods on other
// interfaces.
//
// If the BusConnection associated with proxy is closed then the operation will
// fail with G_IO_ERROR_CLOSED. If cancellable is canceled, the operation will
// fail with G_IO_ERROR_CANCELLED. If parameters contains a value not compatible
// with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If the parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_proxy_call (proxy,
//                       "TwoStrings",
//                       g_variant_new ("(ss)",
//                                      "Thing One",
//                                      "Thing Two"),
//                       G_DBUS_CALL_FLAGS_NONE,
//                       -1,
//                       NULL,
//                       (GAsyncReadyCallback) two_strings_done,
//                       &data);
//
// If proxy has an expected interface (see BusProxy:g-interface-info) and
// method_name is referenced by it, then the return value is checked against the
// return type.
//
// This is an asynchronous method. When the operation is finished, callback will
// be invoked in the [thread-default main
// context][g-main-context-push-thread-default] of the thread you are calling
// this method from. You can then call g_dbus_proxy_call_finish() to get the
// result of the operation. See g_dbus_proxy_call_sync() for the synchronous
// version of this method.
//
// If callback is NULL then the D-Bus method call message will be sent with the
// G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED flag set.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - methodName: name of method to invoke.
//    - parameters (optional) tuple with parameters for the signal or NULL if not
//      passing parameters.
//    - flags flags from the BusCallFlags enumeration.
//    - timeoutMsec: timeout in milliseconds (with G_MAXINT meaning "infinite")
//      or -1 to use the proxy default timeout.
//    - callback (optional) to call when the request is satisfied or NULL if you
//      don't care about the result of the method invocation.
//
func (proxy *DBusProxy) Call(ctx context.Context, methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int, callback AsyncReadyCallback) {
	var _arg0 *C.GDBusProxy         // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.GVariant           // out
	var _arg3 C.GDBusCallFlags      // out
	var _arg4 C.gint                // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameters != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	}
	_arg3 = C.GDBusCallFlags(flags)
	_arg4 = C.gint(timeoutMsec)
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_proxy_call(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(methodName)
	runtime.KeepAlive(parameters)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutMsec)
	runtime.KeepAlive(callback)
}

// CallFinish finishes an operation started with g_dbus_proxy_call().
//
// The function takes the following parameters:
//
//    - res obtained from the ReadyCallback passed to g_dbus_proxy_call().
//
// The function returns the following values:
//
//    - variant: NULL if error is set. Otherwise a #GVariant tuple with return
//      values. Free with g_variant_unref().
//
func (proxy *DBusProxy) CallFinish(res AsyncResultOverrider) (*glib.Variant, error) {
	var _arg0 *C.GDBusProxy   // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GVariant     // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(externglib.InternObject(res).Native()))

	_cret = C.g_dbus_proxy_call_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(res)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// CallSync: synchronously invokes the method_name method on proxy.
//
// If method_name contains any dots, then name is split into interface and
// method name parts. This allows using proxy for invoking methods on other
// interfaces.
//
// If the BusConnection associated with proxy is disconnected then the operation
// will fail with G_IO_ERROR_CLOSED. If cancellable is canceled, the operation
// will fail with G_IO_ERROR_CANCELLED. If parameters contains a value not
// compatible with the D-Bus protocol, the operation fails with
// G_IO_ERROR_INVALID_ARGUMENT.
//
// If the parameters #GVariant is floating, it is consumed. This allows
// convenient 'inline' use of g_variant_new(), e.g.:
//
//    g_dbus_proxy_call_sync (proxy,
//                            "TwoStrings",
//                            g_variant_new ("(ss)",
//                                           "Thing One",
//                                           "Thing Two"),
//                            G_DBUS_CALL_FLAGS_NONE,
//                            -1,
//                            NULL,
//                            &error);
//
// The calling thread is blocked until a reply is received. See
// g_dbus_proxy_call() for the asynchronous version of this method.
//
// If proxy has an expected interface (see BusProxy:g-interface-info) and
// method_name is referenced by it, then the return value is checked against the
// return type.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - methodName: name of method to invoke.
//    - parameters (optional) tuple with parameters for the signal or NULL if not
//      passing parameters.
//    - flags flags from the BusCallFlags enumeration.
//    - timeoutMsec: timeout in milliseconds (with G_MAXINT meaning "infinite")
//      or -1 to use the proxy default timeout.
//
// The function returns the following values:
//
//    - variant: NULL if error is set. Otherwise a #GVariant tuple with return
//      values. Free with g_variant_unref().
//
func (proxy *DBusProxy) CallSync(ctx context.Context, methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int) (*glib.Variant, error) {
	var _arg0 *C.GDBusProxy    // out
	var _arg5 *C.GCancellable  // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GVariant      // out
	var _arg3 C.GDBusCallFlags // out
	var _arg4 C.gint           // out
	var _cret *C.GVariant      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(methodName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameters != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameters)))
	}
	_arg3 = C.GDBusCallFlags(flags)
	_arg4 = C.gint(timeoutMsec)

	_cret = C.g_dbus_proxy_call_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(methodName)
	runtime.KeepAlive(parameters)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(timeoutMsec)

	var _variant *glib.Variant // out
	var _goerr error           // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _variant, _goerr
}

// CachedProperty looks up the value for a property from the cache. This call
// does no blocking IO.
//
// If proxy has an expected interface (see BusProxy:g-interface-info) and
// property_name is referenced by it, then value is checked against the type of
// the property.
//
// The function takes the following parameters:
//
//    - propertyName: property name.
//
// The function returns the following values:
//
//    - variant (optional): reference to the #GVariant instance that holds the
//      value for property_name or NULL if the value is not in the cache. The
//      returned reference must be freed with g_variant_unref().
//
func (proxy *DBusProxy) CachedProperty(propertyName string) *glib.Variant {
	var _arg0 *C.GDBusProxy // out
	var _arg1 *C.gchar      // out
	var _cret *C.GVariant   // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_dbus_proxy_get_cached_property(_arg0, _arg1)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(propertyName)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// CachedPropertyNames gets the names of all cached properties on proxy.
//
// The function returns the following values:
//
//    - utf8s (optional): a NULL-terminated array of strings or NULL if proxy has
//      no cached properties. Free the returned array with g_strfreev().
//
func (proxy *DBusProxy) CachedPropertyNames() []string {
	var _arg0 *C.GDBusProxy // out
	var _cret **C.gchar     // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_cached_property_names(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.gchar
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// Connection gets the connection proxy is for.
//
// The function returns the following values:
//
//    - dBusConnection owned by proxy. Do not free.
//
func (proxy *DBusProxy) Connection() *DBusConnection {
	var _arg0 *C.GDBusProxy      // out
	var _cret *C.GDBusConnection // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_connection(_arg0)
	runtime.KeepAlive(proxy)

	var _dBusConnection *DBusConnection // out

	_dBusConnection = wrapDBusConnection(externglib.Take(unsafe.Pointer(_cret)))

	return _dBusConnection
}

// DefaultTimeout gets the timeout to use if -1 (specifying default timeout) is
// passed as timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
//
// See the BusProxy:g-default-timeout property for more details.
//
// The function returns the following values:
//
//    - gint: timeout to use for proxy.
//
func (proxy *DBusProxy) DefaultTimeout() int {
	var _arg0 *C.GDBusProxy // out
	var _cret C.gint        // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_default_timeout(_arg0)
	runtime.KeepAlive(proxy)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Flags gets the flags that proxy was constructed with.
//
// The function returns the following values:
//
//    - dBusProxyFlags flags from the BusProxyFlags enumeration.
//
func (proxy *DBusProxy) Flags() DBusProxyFlags {
	var _arg0 *C.GDBusProxy     // out
	var _cret C.GDBusProxyFlags // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_flags(_arg0)
	runtime.KeepAlive(proxy)

	var _dBusProxyFlags DBusProxyFlags // out

	_dBusProxyFlags = DBusProxyFlags(_cret)

	return _dBusProxyFlags
}

// InterfaceInfo returns the BusInterfaceInfo, if any, specifying the interface
// that proxy conforms to. See the BusProxy:g-interface-info property for more
// details.
//
// The function returns the following values:
//
//    - dBusInterfaceInfo (optional) or NULL. Do not unref the returned object,
//      it is owned by proxy.
//
func (proxy *DBusProxy) InterfaceInfo() *DBusInterfaceInfo {
	var _arg0 *C.GDBusProxy         // out
	var _cret *C.GDBusInterfaceInfo // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_interface_info(_arg0)
	runtime.KeepAlive(proxy)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	if _cret != nil {
		_dBusInterfaceInfo = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_interface_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusInterfaceInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
			},
		)
	}

	return _dBusInterfaceInfo
}

// InterfaceName gets the D-Bus interface name proxy is for.
//
// The function returns the following values:
//
//    - utf8: string owned by proxy. Do not free.
//
func (proxy *DBusProxy) InterfaceName() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_interface_name(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name gets the name that proxy was constructed for.
//
// The function returns the following values:
//
//    - utf8: string owned by proxy. Do not free.
//
func (proxy *DBusProxy) Name() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_name(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NameOwner: unique name that owns the name that proxy is for or NULL if no-one
// currently owns that name. You may connect to the #GObject::notify signal to
// track changes to the BusProxy:g-name-owner property.
//
// The function returns the following values:
//
//    - utf8 (optional): name owner or NULL if no name owner exists. Free with
//      g_free().
//
func (proxy *DBusProxy) NameOwner() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_name_owner(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ObjectPath gets the object path proxy is for.
//
// The function returns the following values:
//
//    - utf8: string owned by proxy. Do not free.
//
func (proxy *DBusProxy) ObjectPath() string {
	var _arg0 *C.GDBusProxy // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))

	_cret = C.g_dbus_proxy_get_object_path(_arg0)
	runtime.KeepAlive(proxy)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetCachedProperty: if value is not NULL, sets the cached value for the
// property with name property_name to the value in value.
//
// If value is NULL, then the cached value is removed from the property cache.
//
// If proxy has an expected interface (see BusProxy:g-interface-info) and
// property_name is referenced by it, then value is checked against the type of
// the property.
//
// If the value #GVariant is floating, it is consumed. This allows convenient
// 'inline' use of g_variant_new(), e.g.
//
//    g_dbus_proxy_set_cached_property (proxy,
//                                      "SomeProperty",
//                                      g_variant_new ("(si)",
//                                                    "A String",
//                                                    42));
//
// Normally you will not need to use this method since proxy is tracking changes
// using the org.freedesktop.DBus.Properties.PropertiesChanged D-Bus signal.
// However, for performance reasons an object may decide to not use this signal
// for some properties and instead use a proprietary out-of-band mechanism to
// transmit changes.
//
// As a concrete example, consider an object with a property
// ChatroomParticipants which is an array of strings. Instead of transmitting
// the same (long) array every time the property changes, it is more efficient
// to only transmit the delta using e.g. signals
// ChatroomParticipantJoined(String name) and ChatroomParticipantParted(String
// name).
//
// The function takes the following parameters:
//
//    - propertyName: property name.
//    - value (optional): value for the property or NULL to remove it from the
//      cache.
//
func (proxy *DBusProxy) SetCachedProperty(propertyName string, value *glib.Variant) {
	var _arg0 *C.GDBusProxy // out
	var _arg1 *C.gchar      // out
	var _arg2 *C.GVariant   // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	if value != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(value)))
	}

	C.g_dbus_proxy_set_cached_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// SetDefaultTimeout sets the timeout to use if -1 (specifying default timeout)
// is passed as timeout_msec in the g_dbus_proxy_call() and
// g_dbus_proxy_call_sync() functions.
//
// See the BusProxy:g-default-timeout property for more details.
//
// The function takes the following parameters:
//
//    - timeoutMsec: timeout in milliseconds.
//
func (proxy *DBusProxy) SetDefaultTimeout(timeoutMsec int) {
	var _arg0 *C.GDBusProxy // out
	var _arg1 C.gint        // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))
	_arg1 = C.gint(timeoutMsec)

	C.g_dbus_proxy_set_default_timeout(_arg0, _arg1)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(timeoutMsec)
}

// SetInterfaceInfo: ensure that interactions with proxy conform to the given
// interface. See the BusProxy:g-interface-info property for more details.
//
// The function takes the following parameters:
//
//    - info (optional): minimum interface this proxy conforms to or NULL to
//      unset.
//
func (proxy *DBusProxy) SetInterfaceInfo(info *DBusInterfaceInfo) {
	var _arg0 *C.GDBusProxy         // out
	var _arg1 *C.GDBusInterfaceInfo // out

	_arg0 = (*C.GDBusProxy)(unsafe.Pointer(externglib.InternObject(proxy).Native()))
	if info != nil {
		_arg1 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}

	C.g_dbus_proxy_set_interface_info(_arg0, _arg1)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(info)
}

// NewDBusProxy creates a proxy for accessing interface_name on the remote
// object at object_path owned by name at connection and asynchronously loads
// D-Bus properties unless the G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is
// used. Connect to the BusProxy::g-properties-changed signal to get notified
// about property changes.
//
// If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets
// up match rules for signals. Connect to the BusProxy::g-signal signal to
// handle signals from the remote object.
//
// If both G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES and
// G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS are set, this constructor is
// guaranteed to complete immediately without blocking.
//
// If name is a well-known name and the G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START and
// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION flags aren't set and no
// name owner currently exists, the message bus will be requested to launch a
// name owner for the name.
//
// This is a failable asynchronous constructor - when the proxy is ready,
// callback will be invoked and you can use g_dbus_proxy_new_finish() to get the
// result.
//
// See g_dbus_proxy_new_sync() and for a synchronous version of this
// constructor.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - connection: BusConnection.
//    - flags flags used when constructing the proxy.
//    - info (optional) specifying the minimal interface that proxy conforms to
//      or NULL.
//    - name (optional) bus name (well-known or unique) or NULL if connection is
//      not a message bus connection.
//    - objectPath: object path.
//    - interfaceName d-Bus interface name.
//    - callback (optional): callback function to invoke when the proxy is ready.
//
func NewDBusProxy(ctx context.Context, connection *DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name, objectPath, interfaceName string, callback AsyncReadyCallback) {
	var _arg7 *C.GCancellable       // out
	var _arg1 *C.GDBusConnection    // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _arg8 C.GAsyncReadyCallback // out
	var _arg9 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(externglib.InternObject(connection).Native()))
	_arg2 = C.GDBusProxyFlags(flags)
	if info != nil {
		_arg3 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}
	if name != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg6))
	if callback != nil {
		_arg8 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg9 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_proxy_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)
	runtime.KeepAlive(callback)
}

// NewDBusProxyForBus: like g_dbus_proxy_new() but takes a Type instead of a
// BusConnection.
//
// BusProxy is used in this [example][gdbus-wellknown-proxy].
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - busType: Type.
//    - flags flags used when constructing the proxy.
//    - info (optional) specifying the minimal interface that proxy conforms to
//      or NULL.
//    - name bus name (well-known or unique).
//    - objectPath: object path.
//    - interfaceName d-Bus interface name.
//    - callback (optional): callback function to invoke when the proxy is ready.
//
func NewDBusProxyForBus(ctx context.Context, busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name, objectPath, interfaceName string, callback AsyncReadyCallback) {
	var _arg7 *C.GCancellable       // out
	var _arg1 C.GBusType            // out
	var _arg2 C.GDBusProxyFlags     // out
	var _arg3 *C.GDBusInterfaceInfo // out
	var _arg4 *C.gchar              // out
	var _arg5 *C.gchar              // out
	var _arg6 *C.gchar              // out
	var _arg8 C.GAsyncReadyCallback // out
	var _arg9 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GBusType(busType)
	_arg2 = C.GDBusProxyFlags(flags)
	if info != nil {
		_arg3 = (*C.GDBusInterfaceInfo)(gextras.StructNative(unsafe.Pointer(info)))
	}
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(interfaceName)))
	defer C.free(unsafe.Pointer(_arg6))
	if callback != nil {
		_arg8 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg9 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_dbus_proxy_new_for_bus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(busType)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(info)
	runtime.KeepAlive(name)
	runtime.KeepAlive(objectPath)
	runtime.KeepAlive(interfaceName)
	runtime.KeepAlive(callback)
}

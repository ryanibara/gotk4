// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"strings"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gio-2.0 gio-unix-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_bus_type_get_type()), F: marshalBusType},
		{T: externglib.Type(C.g_converter_result_get_type()), F: marshalConverterResult},
		{T: externglib.Type(C.g_credentials_type_get_type()), F: marshalCredentialsType},
		{T: externglib.Type(C.g_dbus_error_get_type()), F: marshalDBusError},
		{T: externglib.Type(C.g_dbus_message_byte_order_get_type()), F: marshalDBusMessageByteOrder},
		{T: externglib.Type(C.g_dbus_message_header_field_get_type()), F: marshalDBusMessageHeaderField},
		{T: externglib.Type(C.g_dbus_message_type_get_type()), F: marshalDBusMessageType},
		{T: externglib.Type(C.g_data_stream_byte_order_get_type()), F: marshalDataStreamByteOrder},
		{T: externglib.Type(C.g_data_stream_newline_type_get_type()), F: marshalDataStreamNewlineType},
		{T: externglib.Type(C.g_drive_start_stop_type_get_type()), F: marshalDriveStartStopType},
		{T: externglib.Type(C.g_emblem_origin_get_type()), F: marshalEmblemOrigin},
		{T: externglib.Type(C.g_file_attribute_status_get_type()), F: marshalFileAttributeStatus},
		{T: externglib.Type(C.g_file_attribute_type_get_type()), F: marshalFileAttributeType},
		{T: externglib.Type(C.g_file_monitor_event_get_type()), F: marshalFileMonitorEvent},
		{T: externglib.Type(C.g_file_type_get_type()), F: marshalFileType},
		{T: externglib.Type(C.g_filesystem_preview_type_get_type()), F: marshalFilesystemPreviewType},
		{T: externglib.Type(C.g_io_error_enum_get_type()), F: marshalIOErrorEnum},
		{T: externglib.Type(C.g_io_module_scope_flags_get_type()), F: marshalIOModuleScopeFlags},
		{T: externglib.Type(C.g_memory_monitor_warning_level_get_type()), F: marshalMemoryMonitorWarningLevel},
		{T: externglib.Type(C.g_mount_operation_result_get_type()), F: marshalMountOperationResult},
		{T: externglib.Type(C.g_network_connectivity_get_type()), F: marshalNetworkConnectivity},
		{T: externglib.Type(C.g_notification_priority_get_type()), F: marshalNotificationPriority},
		{T: externglib.Type(C.g_password_save_get_type()), F: marshalPasswordSave},
		{T: externglib.Type(C.g_pollable_return_get_type()), F: marshalPollableReturn},
		{T: externglib.Type(C.g_resolver_error_get_type()), F: marshalResolverError},
		{T: externglib.Type(C.g_resolver_record_type_get_type()), F: marshalResolverRecordType},
		{T: externglib.Type(C.g_resource_error_get_type()), F: marshalResourceError},
		{T: externglib.Type(C.g_socket_client_event_get_type()), F: marshalSocketClientEvent},
		{T: externglib.Type(C.g_socket_family_get_type()), F: marshalSocketFamily},
		{T: externglib.Type(C.g_socket_listener_event_get_type()), F: marshalSocketListenerEvent},
		{T: externglib.Type(C.g_socket_protocol_get_type()), F: marshalSocketProtocol},
		{T: externglib.Type(C.g_socket_type_get_type()), F: marshalSocketType},
		{T: externglib.Type(C.g_tls_authentication_mode_get_type()), F: marshalTLSAuthenticationMode},
		{T: externglib.Type(C.g_tls_certificate_request_flags_get_type()), F: marshalTLSCertificateRequestFlags},
		{T: externglib.Type(C.g_tls_channel_binding_error_get_type()), F: marshalTLSChannelBindingError},
		{T: externglib.Type(C.g_tls_channel_binding_type_get_type()), F: marshalTLSChannelBindingType},
		{T: externglib.Type(C.g_tls_database_lookup_flags_get_type()), F: marshalTLSDatabaseLookupFlags},
		{T: externglib.Type(C.g_tls_error_get_type()), F: marshalTLSError},
		{T: externglib.Type(C.g_tls_interaction_result_get_type()), F: marshalTLSInteractionResult},
		{T: externglib.Type(C.g_tls_rehandshake_mode_get_type()), F: marshalTLSRehandshakeMode},
		{T: externglib.Type(C.g_unix_socket_address_type_get_type()), F: marshalUnixSocketAddressType},
		{T: externglib.Type(C.g_zlib_compressor_format_get_type()), F: marshalZlibCompressorFormat},
		{T: externglib.Type(C.g_app_info_create_flags_get_type()), F: marshalAppInfoCreateFlags},
		{T: externglib.Type(C.g_application_flags_get_type()), F: marshalApplicationFlags},
		{T: externglib.Type(C.g_ask_password_flags_get_type()), F: marshalAskPasswordFlags},
		{T: externglib.Type(C.g_bus_name_owner_flags_get_type()), F: marshalBusNameOwnerFlags},
		{T: externglib.Type(C.g_bus_name_watcher_flags_get_type()), F: marshalBusNameWatcherFlags},
		{T: externglib.Type(C.g_converter_flags_get_type()), F: marshalConverterFlags},
		{T: externglib.Type(C.g_dbus_call_flags_get_type()), F: marshalDBusCallFlags},
		{T: externglib.Type(C.g_dbus_capability_flags_get_type()), F: marshalDBusCapabilityFlags},
		{T: externglib.Type(C.g_dbus_connection_flags_get_type()), F: marshalDBusConnectionFlags},
		{T: externglib.Type(C.g_dbus_interface_skeleton_flags_get_type()), F: marshalDBusInterfaceSkeletonFlags},
		{T: externglib.Type(C.g_dbus_message_flags_get_type()), F: marshalDBusMessageFlags},
		{T: externglib.Type(C.g_dbus_object_manager_client_flags_get_type()), F: marshalDBusObjectManagerClientFlags},
		{T: externglib.Type(C.g_dbus_property_info_flags_get_type()), F: marshalDBusPropertyInfoFlags},
		{T: externglib.Type(C.g_dbus_proxy_flags_get_type()), F: marshalDBusProxyFlags},
		{T: externglib.Type(C.g_dbus_send_message_flags_get_type()), F: marshalDBusSendMessageFlags},
		{T: externglib.Type(C.g_dbus_server_flags_get_type()), F: marshalDBusServerFlags},
		{T: externglib.Type(C.g_dbus_signal_flags_get_type()), F: marshalDBusSignalFlags},
		{T: externglib.Type(C.g_dbus_subtree_flags_get_type()), F: marshalDBusSubtreeFlags},
		{T: externglib.Type(C.g_drive_start_flags_get_type()), F: marshalDriveStartFlags},
		{T: externglib.Type(C.g_file_attribute_info_flags_get_type()), F: marshalFileAttributeInfoFlags},
		{T: externglib.Type(C.g_file_copy_flags_get_type()), F: marshalFileCopyFlags},
		{T: externglib.Type(C.g_file_create_flags_get_type()), F: marshalFileCreateFlags},
		{T: externglib.Type(C.g_file_measure_flags_get_type()), F: marshalFileMeasureFlags},
		{T: externglib.Type(C.g_file_monitor_flags_get_type()), F: marshalFileMonitorFlags},
		{T: externglib.Type(C.g_file_query_info_flags_get_type()), F: marshalFileQueryInfoFlags},
		{T: externglib.Type(C.g_io_stream_splice_flags_get_type()), F: marshalIOStreamSpliceFlags},
		{T: externglib.Type(C.g_mount_mount_flags_get_type()), F: marshalMountMountFlags},
		{T: externglib.Type(C.g_mount_unmount_flags_get_type()), F: marshalMountUnmountFlags},
		{T: externglib.Type(C.g_output_stream_splice_flags_get_type()), F: marshalOutputStreamSpliceFlags},
		{T: externglib.Type(C.g_resource_flags_get_type()), F: marshalResourceFlags},
		{T: externglib.Type(C.g_resource_lookup_flags_get_type()), F: marshalResourceLookupFlags},
		{T: externglib.Type(C.g_socket_msg_flags_get_type()), F: marshalSocketMsgFlags},
		{T: externglib.Type(C.g_subprocess_flags_get_type()), F: marshalSubprocessFlags},
		{T: externglib.Type(C.g_test_dbus_flags_get_type()), F: marshalTestDBusFlags},
		{T: externglib.Type(C.g_tls_certificate_flags_get_type()), F: marshalTLSCertificateFlags},
		{T: externglib.Type(C.g_tls_database_verify_flags_get_type()), F: marshalTLSDatabaseVerifyFlags},
		{T: externglib.Type(C.g_tls_password_flags_get_type()), F: marshalTLSPasswordFlags},
	})
}

// BusType: enumeration for well-known message buses.
type BusType C.gint

const (
	// BusTypeStarter alias for the message bus that activated the process, if
	// any.
	BusTypeStarter BusType = -1
	// BusTypeNone: not a message bus.
	BusTypeNone BusType = 0
	// BusTypeSystem: system-wide message bus.
	BusTypeSystem BusType = 1
	// BusTypeSession: login session message bus.
	BusTypeSession BusType = 2
)

func marshalBusType(p uintptr) (interface{}, error) {
	return BusType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BusType.
func (b BusType) String() string {
	switch b {
	case BusTypeStarter:
		return "Starter"
	case BusTypeNone:
		return "None"
	case BusTypeSystem:
		return "System"
	case BusTypeSession:
		return "Session"
	default:
		return fmt.Sprintf("BusType(%d)", b)
	}
}

// ConverterResult results returned from g_converter_convert().
type ConverterResult C.gint

const (
	// ConverterError: there was an error during conversion.
	ConverterError ConverterResult = iota
	// ConverterConverted: some data was consumed or produced.
	ConverterConverted
	// ConverterFinished: conversion is finished.
	ConverterFinished
	// ConverterFlushed: flushing is finished.
	ConverterFlushed
)

func marshalConverterResult(p uintptr) (interface{}, error) {
	return ConverterResult(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConverterResult.
func (c ConverterResult) String() string {
	switch c {
	case ConverterError:
		return "Error"
	case ConverterConverted:
		return "Converted"
	case ConverterFinished:
		return "Finished"
	case ConverterFlushed:
		return "Flushed"
	default:
		return fmt.Sprintf("ConverterResult(%d)", c)
	}
}

// CredentialsType: enumeration describing different kinds of native credential
// types.
type CredentialsType C.gint

const (
	// CredentialsTypeInvalid indicates an invalid native credential type.
	CredentialsTypeInvalid CredentialsType = iota
	// CredentialsTypeLinuxUcred: native credentials type is a struct ucred.
	CredentialsTypeLinuxUcred
	// CredentialsTypeFreebsdCmsgcred: native credentials type is a struct
	// cmsgcred.
	CredentialsTypeFreebsdCmsgcred
	// CredentialsTypeOpenbsdSockpeercred: native credentials type is a struct
	// sockpeercred. Added in 2.30.
	CredentialsTypeOpenbsdSockpeercred
	// CredentialsTypeSolarisUcred: native credentials type is a ucred_t. Added
	// in 2.40.
	CredentialsTypeSolarisUcred
	// CredentialsTypeNetbsdUnpcbid: native credentials type is a struct
	// unpcbid. Added in 2.42.
	CredentialsTypeNetbsdUnpcbid
	// CredentialsTypeAppleXucred: native credentials type is a struct xucred.
	// Added in 2.66.
	CredentialsTypeAppleXucred
)

func marshalCredentialsType(p uintptr) (interface{}, error) {
	return CredentialsType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CredentialsType.
func (c CredentialsType) String() string {
	switch c {
	case CredentialsTypeInvalid:
		return "Invalid"
	case CredentialsTypeLinuxUcred:
		return "LinuxUcred"
	case CredentialsTypeFreebsdCmsgcred:
		return "FreebsdCmsgcred"
	case CredentialsTypeOpenbsdSockpeercred:
		return "OpenbsdSockpeercred"
	case CredentialsTypeSolarisUcred:
		return "SolarisUcred"
	case CredentialsTypeNetbsdUnpcbid:
		return "NetbsdUnpcbid"
	case CredentialsTypeAppleXucred:
		return "AppleXucred"
	default:
		return fmt.Sprintf("CredentialsType(%d)", c)
	}
}

// DBusError: error codes for the G_DBUS_ERROR error domain.
type DBusError C.gint

const (
	// DBusErrorFailed: generic error; "something went wrong" - see the error
	// message for more.
	DBusErrorFailed DBusError = iota
	// DBusErrorNoMemory: there was not enough memory to complete an operation.
	DBusErrorNoMemory
	// DBusErrorServiceUnknown bus doesn't know how to launch a service to
	// supply the bus name you wanted.
	DBusErrorServiceUnknown
	// DBusErrorNameHasNoOwner bus name you referenced doesn't exist (i.e. no
	// application owns it).
	DBusErrorNameHasNoOwner
	// DBusErrorNoReply: no reply to a message expecting one, usually means a
	// timeout occurred.
	DBusErrorNoReply
	// DBusErrorIOError: something went wrong reading or writing to a socket,
	// for example.
	DBusErrorIOError
	// DBusErrorBadAddress d-Bus bus address was malformed.
	DBusErrorBadAddress
	// DBusErrorNotSupported: requested operation isn't supported (like ENOSYS
	// on UNIX).
	DBusErrorNotSupported
	// DBusErrorLimitsExceeded: some limited resource is exhausted.
	DBusErrorLimitsExceeded
	// DBusErrorAccessDenied: security restrictions don't allow doing what
	// you're trying to do.
	DBusErrorAccessDenied
	// DBusErrorAuthFailed: authentication didn't work.
	DBusErrorAuthFailed
	// DBusErrorNoServer: unable to connect to server (probably caused by
	// ECONNREFUSED on a socket).
	DBusErrorNoServer
	// DBusErrorTimeout: certain timeout errors, possibly ETIMEDOUT on a socket.
	// Note that G_DBUS_ERROR_NO_REPLY is used for message reply timeouts.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMED_OUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimeout
	// DBusErrorNoNetwork: no network access (probably ENETUNREACH on a socket).
	DBusErrorNoNetwork
	// DBusErrorAddressInUse: can't bind a socket since its address is in use
	// (i.e. EADDRINUSE).
	DBusErrorAddressInUse
	// DBusErrorDisconnected: connection is disconnected and you're trying to
	// use it.
	DBusErrorDisconnected
	// DBusErrorInvalidArgs: invalid arguments passed to a method call.
	DBusErrorInvalidArgs
	// DBusErrorFileNotFound: missing file.
	DBusErrorFileNotFound
	// DBusErrorFileExists: existing file and the operation you're using does
	// not silently overwrite.
	DBusErrorFileExists
	// DBusErrorUnknownMethod: method name you invoked isn't known by the object
	// you invoked it on.
	DBusErrorUnknownMethod
	// DBusErrorTimedOut: certain timeout errors, e.g. while starting a service.
	// Warning: this is confusingly-named given that G_DBUS_ERROR_TIMEOUT also
	// exists. We can't fix it for compatibility reasons so just be careful.
	DBusErrorTimedOut
	// DBusErrorMatchRuleNotFound: tried to remove or modify a match rule that
	// didn't exist.
	DBusErrorMatchRuleNotFound
	// DBusErrorMatchRuleInvalid: match rule isn't syntactically valid.
	DBusErrorMatchRuleInvalid
	// DBusErrorSpawnExecFailed: while starting a new process, the exec() call
	// failed.
	DBusErrorSpawnExecFailed
	// DBusErrorSpawnForkFailed: while starting a new process, the fork() call
	// failed.
	DBusErrorSpawnForkFailed
	// DBusErrorSpawnChildExited: while starting a new process, the child exited
	// with a status code.
	DBusErrorSpawnChildExited
	// DBusErrorSpawnChildSignaled: while starting a new process, the child
	// exited on a signal.
	DBusErrorSpawnChildSignaled
	// DBusErrorSpawnFailed: while starting a new process, something went wrong.
	DBusErrorSpawnFailed
	// DBusErrorSpawnSetupFailed: we failed to setup the environment correctly.
	DBusErrorSpawnSetupFailed
	// DBusErrorSpawnConfigInvalid: we failed to setup the config parser
	// correctly.
	DBusErrorSpawnConfigInvalid
	// DBusErrorSpawnServiceInvalid bus name was not valid.
	DBusErrorSpawnServiceInvalid
	// DBusErrorSpawnServiceNotFound: service file not found in system-services
	// directory.
	DBusErrorSpawnServiceNotFound
	// DBusErrorSpawnPermissionsInvalid permissions are incorrect on the setuid
	// helper.
	DBusErrorSpawnPermissionsInvalid
	// DBusErrorSpawnFileInvalid: service file invalid (Name, User or Exec
	// missing).
	DBusErrorSpawnFileInvalid
	// DBusErrorSpawnNoMemory: tried to get a UNIX process ID and it wasn't
	// available.
	DBusErrorSpawnNoMemory
	// DBusErrorUnixProcessIDUnknown: tried to get a UNIX process ID and it
	// wasn't available.
	DBusErrorUnixProcessIDUnknown
	// DBusErrorInvalidSignature: type signature is not valid.
	DBusErrorInvalidSignature
	// DBusErrorInvalidFileContent: file contains invalid syntax or is otherwise
	// broken.
	DBusErrorInvalidFileContent
	// DBusErrorSelinuxSecurityContextUnknown: asked for SELinux security
	// context and it wasn't available.
	DBusErrorSelinuxSecurityContextUnknown
	// DBusErrorAdtAuditDataUnknown: asked for ADT audit data and it wasn't
	// available.
	DBusErrorAdtAuditDataUnknown
	// DBusErrorObjectPathInUse there's already an object with the requested
	// object path.
	DBusErrorObjectPathInUse
	// DBusErrorUnknownObject: object you invoked a method on isn't known. Since
	// 2.42.
	DBusErrorUnknownObject
	// DBusErrorUnknownInterface: interface you invoked a method on isn't known
	// by the object. Since 2.42.
	DBusErrorUnknownInterface
	// DBusErrorUnknownProperty: property you tried to access isn't known by the
	// object. Since 2.42.
	DBusErrorUnknownProperty
	// DBusErrorPropertyReadOnly: property you tried to set is read-only. Since
	// 2.42.
	DBusErrorPropertyReadOnly
)

func marshalDBusError(p uintptr) (interface{}, error) {
	return DBusError(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusError.
func (d DBusError) String() string {
	switch d {
	case DBusErrorFailed:
		return "Failed"
	case DBusErrorNoMemory:
		return "NoMemory"
	case DBusErrorServiceUnknown:
		return "ServiceUnknown"
	case DBusErrorNameHasNoOwner:
		return "NameHasNoOwner"
	case DBusErrorNoReply:
		return "NoReply"
	case DBusErrorIOError:
		return "IOError"
	case DBusErrorBadAddress:
		return "BadAddress"
	case DBusErrorNotSupported:
		return "NotSupported"
	case DBusErrorLimitsExceeded:
		return "LimitsExceeded"
	case DBusErrorAccessDenied:
		return "AccessDenied"
	case DBusErrorAuthFailed:
		return "AuthFailed"
	case DBusErrorNoServer:
		return "NoServer"
	case DBusErrorTimeout:
		return "Timeout"
	case DBusErrorNoNetwork:
		return "NoNetwork"
	case DBusErrorAddressInUse:
		return "AddressInUse"
	case DBusErrorDisconnected:
		return "Disconnected"
	case DBusErrorInvalidArgs:
		return "InvalidArgs"
	case DBusErrorFileNotFound:
		return "FileNotFound"
	case DBusErrorFileExists:
		return "FileExists"
	case DBusErrorUnknownMethod:
		return "UnknownMethod"
	case DBusErrorTimedOut:
		return "TimedOut"
	case DBusErrorMatchRuleNotFound:
		return "MatchRuleNotFound"
	case DBusErrorMatchRuleInvalid:
		return "MatchRuleInvalid"
	case DBusErrorSpawnExecFailed:
		return "SpawnExecFailed"
	case DBusErrorSpawnForkFailed:
		return "SpawnForkFailed"
	case DBusErrorSpawnChildExited:
		return "SpawnChildExited"
	case DBusErrorSpawnChildSignaled:
		return "SpawnChildSignaled"
	case DBusErrorSpawnFailed:
		return "SpawnFailed"
	case DBusErrorSpawnSetupFailed:
		return "SpawnSetupFailed"
	case DBusErrorSpawnConfigInvalid:
		return "SpawnConfigInvalid"
	case DBusErrorSpawnServiceInvalid:
		return "SpawnServiceInvalid"
	case DBusErrorSpawnServiceNotFound:
		return "SpawnServiceNotFound"
	case DBusErrorSpawnPermissionsInvalid:
		return "SpawnPermissionsInvalid"
	case DBusErrorSpawnFileInvalid:
		return "SpawnFileInvalid"
	case DBusErrorSpawnNoMemory:
		return "SpawnNoMemory"
	case DBusErrorUnixProcessIDUnknown:
		return "UnixProcessIDUnknown"
	case DBusErrorInvalidSignature:
		return "InvalidSignature"
	case DBusErrorInvalidFileContent:
		return "InvalidFileContent"
	case DBusErrorSelinuxSecurityContextUnknown:
		return "SelinuxSecurityContextUnknown"
	case DBusErrorAdtAuditDataUnknown:
		return "AdtAuditDataUnknown"
	case DBusErrorObjectPathInUse:
		return "ObjectPathInUse"
	case DBusErrorUnknownObject:
		return "UnknownObject"
	case DBusErrorUnknownInterface:
		return "UnknownInterface"
	case DBusErrorUnknownProperty:
		return "UnknownProperty"
	case DBusErrorPropertyReadOnly:
		return "PropertyReadOnly"
	default:
		return fmt.Sprintf("DBusError(%d)", d)
	}
}

// DBusMessageByteOrder: enumeration used to describe the byte order of a D-Bus
// message.
type DBusMessageByteOrder C.gint

const (
	// DBusMessageByteOrderBigEndian: byte order is big endian.
	DBusMessageByteOrderBigEndian DBusMessageByteOrder = 66
	// DBusMessageByteOrderLittleEndian: byte order is little endian.
	DBusMessageByteOrderLittleEndian DBusMessageByteOrder = 108
)

func marshalDBusMessageByteOrder(p uintptr) (interface{}, error) {
	return DBusMessageByteOrder(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageByteOrder.
func (d DBusMessageByteOrder) String() string {
	switch d {
	case DBusMessageByteOrderBigEndian:
		return "BigEndian"
	case DBusMessageByteOrderLittleEndian:
		return "LittleEndian"
	default:
		return fmt.Sprintf("DBusMessageByteOrder(%d)", d)
	}
}

// DBusMessageHeaderField: header fields used in BusMessage.
type DBusMessageHeaderField C.gint

const (
	// DBusMessageHeaderFieldInvalid: not a valid header field.
	DBusMessageHeaderFieldInvalid DBusMessageHeaderField = iota
	// DBusMessageHeaderFieldPath: object path.
	DBusMessageHeaderFieldPath
	// DBusMessageHeaderFieldInterface: interface name.
	DBusMessageHeaderFieldInterface
	// DBusMessageHeaderFieldMember: method or signal name.
	DBusMessageHeaderFieldMember
	// DBusMessageHeaderFieldErrorName: name of the error that occurred.
	DBusMessageHeaderFieldErrorName
	// DBusMessageHeaderFieldReplySerial: serial number the message is a reply
	// to.
	DBusMessageHeaderFieldReplySerial
	// DBusMessageHeaderFieldDestination: name the message is intended for.
	DBusMessageHeaderFieldDestination
	// DBusMessageHeaderFieldSender: unique name of the sender of the message
	// (filled in by the bus).
	DBusMessageHeaderFieldSender
	// DBusMessageHeaderFieldSignature: signature of the message body.
	DBusMessageHeaderFieldSignature
	// DBusMessageHeaderFieldNumUnixFds: number of UNIX file descriptors that
	// accompany the message.
	DBusMessageHeaderFieldNumUnixFds
)

func marshalDBusMessageHeaderField(p uintptr) (interface{}, error) {
	return DBusMessageHeaderField(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageHeaderField.
func (d DBusMessageHeaderField) String() string {
	switch d {
	case DBusMessageHeaderFieldInvalid:
		return "Invalid"
	case DBusMessageHeaderFieldPath:
		return "Path"
	case DBusMessageHeaderFieldInterface:
		return "Interface"
	case DBusMessageHeaderFieldMember:
		return "Member"
	case DBusMessageHeaderFieldErrorName:
		return "ErrorName"
	case DBusMessageHeaderFieldReplySerial:
		return "ReplySerial"
	case DBusMessageHeaderFieldDestination:
		return "Destination"
	case DBusMessageHeaderFieldSender:
		return "Sender"
	case DBusMessageHeaderFieldSignature:
		return "Signature"
	case DBusMessageHeaderFieldNumUnixFds:
		return "NumUnixFds"
	default:
		return fmt.Sprintf("DBusMessageHeaderField(%d)", d)
	}
}

// DBusMessageType: message types used in BusMessage.
type DBusMessageType C.gint

const (
	// DBusMessageTypeInvalid: message is of invalid type.
	DBusMessageTypeInvalid DBusMessageType = iota
	// DBusMessageTypeMethodCall: method call.
	DBusMessageTypeMethodCall
	// DBusMessageTypeMethodReturn: method reply.
	DBusMessageTypeMethodReturn
	// DBusMessageTypeError: error reply.
	DBusMessageTypeError
	// DBusMessageTypeSignal: signal emission.
	DBusMessageTypeSignal
)

func marshalDBusMessageType(p uintptr) (interface{}, error) {
	return DBusMessageType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DBusMessageType.
func (d DBusMessageType) String() string {
	switch d {
	case DBusMessageTypeInvalid:
		return "Invalid"
	case DBusMessageTypeMethodCall:
		return "MethodCall"
	case DBusMessageTypeMethodReturn:
		return "MethodReturn"
	case DBusMessageTypeError:
		return "Error"
	case DBusMessageTypeSignal:
		return "Signal"
	default:
		return fmt.Sprintf("DBusMessageType(%d)", d)
	}
}

// DataStreamByteOrder is used to ensure proper endianness of streaming data
// sources across various machine architectures.
type DataStreamByteOrder C.gint

const (
	// DataStreamByteOrderBigEndian selects Big Endian byte order.
	DataStreamByteOrderBigEndian DataStreamByteOrder = iota
	// DataStreamByteOrderLittleEndian selects Little Endian byte order.
	DataStreamByteOrderLittleEndian
	// DataStreamByteOrderHostEndian selects endianness based on host machine's
	// architecture.
	DataStreamByteOrderHostEndian
)

func marshalDataStreamByteOrder(p uintptr) (interface{}, error) {
	return DataStreamByteOrder(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DataStreamByteOrder.
func (d DataStreamByteOrder) String() string {
	switch d {
	case DataStreamByteOrderBigEndian:
		return "BigEndian"
	case DataStreamByteOrderLittleEndian:
		return "LittleEndian"
	case DataStreamByteOrderHostEndian:
		return "HostEndian"
	default:
		return fmt.Sprintf("DataStreamByteOrder(%d)", d)
	}
}

// DataStreamNewlineType is used when checking for or setting the line endings
// for a given file.
type DataStreamNewlineType C.gint

const (
	// DataStreamNewlineTypeLf selects "LF" line endings, common on most modern
	// UNIX platforms.
	DataStreamNewlineTypeLf DataStreamNewlineType = iota
	// DataStreamNewlineTypeCr selects "CR" line endings.
	DataStreamNewlineTypeCr
	// DataStreamNewlineTypeCrLf selects "CR, LF" line ending, common on
	// Microsoft Windows.
	DataStreamNewlineTypeCrLf
	// DataStreamNewlineTypeAny: automatically try to handle any line ending
	// type.
	DataStreamNewlineTypeAny
)

func marshalDataStreamNewlineType(p uintptr) (interface{}, error) {
	return DataStreamNewlineType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DataStreamNewlineType.
func (d DataStreamNewlineType) String() string {
	switch d {
	case DataStreamNewlineTypeLf:
		return "Lf"
	case DataStreamNewlineTypeCr:
		return "Cr"
	case DataStreamNewlineTypeCrLf:
		return "CrLf"
	case DataStreamNewlineTypeAny:
		return "Any"
	default:
		return fmt.Sprintf("DataStreamNewlineType(%d)", d)
	}
}

// DriveStartStopType: enumeration describing how a drive can be
// started/stopped.
type DriveStartStopType C.gint

const (
	// DriveStartStopTypeUnknown: unknown or drive doesn't support start/stop.
	DriveStartStopTypeUnknown DriveStartStopType = iota
	// DriveStartStopTypeShutdown: stop method will physically shut down the
	// drive and e.g. power down the port the drive is attached to.
	DriveStartStopTypeShutdown
	// DriveStartStopTypeNetwork: start/stop methods are used for
	// connecting/disconnect to the drive over the network.
	DriveStartStopTypeNetwork
	// DriveStartStopTypeMultidisk: start/stop methods will assemble/disassemble
	// a virtual drive from several physical drives.
	DriveStartStopTypeMultidisk
	// DriveStartStopTypePassword: start/stop methods will unlock/lock the disk
	// (for example using the ATA <quote>SECURITY UNLOCK DEVICE</quote>
	// command).
	DriveStartStopTypePassword
)

func marshalDriveStartStopType(p uintptr) (interface{}, error) {
	return DriveStartStopType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DriveStartStopType.
func (d DriveStartStopType) String() string {
	switch d {
	case DriveStartStopTypeUnknown:
		return "Unknown"
	case DriveStartStopTypeShutdown:
		return "Shutdown"
	case DriveStartStopTypeNetwork:
		return "Network"
	case DriveStartStopTypeMultidisk:
		return "Multidisk"
	case DriveStartStopTypePassword:
		return "Password"
	default:
		return fmt.Sprintf("DriveStartStopType(%d)", d)
	}
}

// EmblemOrigin is used to add information about the origin of the emblem to
// #GEmblem.
type EmblemOrigin C.gint

const (
	// EmblemOriginUnknown: emblem of unknown origin.
	EmblemOriginUnknown EmblemOrigin = iota
	// EmblemOriginDevice: emblem adds device-specific information.
	EmblemOriginDevice
	// EmblemOriginLivemetadata: emblem depicts live metadata, such as
	// "readonly".
	EmblemOriginLivemetadata
	// EmblemOriginTag: emblem comes from a user-defined tag, e.g. set by
	// nautilus (in the future).
	EmblemOriginTag
)

func marshalEmblemOrigin(p uintptr) (interface{}, error) {
	return EmblemOrigin(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EmblemOrigin.
func (e EmblemOrigin) String() string {
	switch e {
	case EmblemOriginUnknown:
		return "Unknown"
	case EmblemOriginDevice:
		return "Device"
	case EmblemOriginLivemetadata:
		return "Livemetadata"
	case EmblemOriginTag:
		return "Tag"
	default:
		return fmt.Sprintf("EmblemOrigin(%d)", e)
	}
}

// FileAttributeStatus: used by g_file_set_attributes_from_info() when setting
// file attributes.
type FileAttributeStatus C.gint

const (
	// FileAttributeStatusUnset: attribute value is unset (empty).
	FileAttributeStatusUnset FileAttributeStatus = iota
	// FileAttributeStatusSet: attribute value is set.
	FileAttributeStatusSet
	// FileAttributeStatusErrorSetting indicates an error in setting the value.
	FileAttributeStatusErrorSetting
)

func marshalFileAttributeStatus(p uintptr) (interface{}, error) {
	return FileAttributeStatus(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileAttributeStatus.
func (f FileAttributeStatus) String() string {
	switch f {
	case FileAttributeStatusUnset:
		return "Unset"
	case FileAttributeStatusSet:
		return "Set"
	case FileAttributeStatusErrorSetting:
		return "ErrorSetting"
	default:
		return fmt.Sprintf("FileAttributeStatus(%d)", f)
	}
}

// FileAttributeType: data types for file attributes.
type FileAttributeType C.gint

const (
	// FileAttributeTypeInvalid indicates an invalid or uninitialized type.
	FileAttributeTypeInvalid FileAttributeType = iota
	// FileAttributeTypeString: null terminated UTF8 string.
	FileAttributeTypeString
	// FileAttributeTypeByteString: zero terminated string of non-zero bytes.
	FileAttributeTypeByteString
	// FileAttributeTypeBoolean: boolean value.
	FileAttributeTypeBoolean
	// FileAttributeTypeUint32: unsigned 4-byte/32-bit integer.
	FileAttributeTypeUint32
	// FileAttributeTypeInt32: signed 4-byte/32-bit integer.
	FileAttributeTypeInt32
	// FileAttributeTypeUint64: unsigned 8-byte/64-bit integer.
	FileAttributeTypeUint64
	// FileAttributeTypeInt64: signed 8-byte/64-bit integer.
	FileAttributeTypeInt64
	// FileAttributeTypeObject: #GObject.
	FileAttributeTypeObject
	// FileAttributeTypeStringv: NULL terminated char **. Since 2.22.
	FileAttributeTypeStringv
)

func marshalFileAttributeType(p uintptr) (interface{}, error) {
	return FileAttributeType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileAttributeType.
func (f FileAttributeType) String() string {
	switch f {
	case FileAttributeTypeInvalid:
		return "Invalid"
	case FileAttributeTypeString:
		return "String"
	case FileAttributeTypeByteString:
		return "ByteString"
	case FileAttributeTypeBoolean:
		return "Boolean"
	case FileAttributeTypeUint32:
		return "Uint32"
	case FileAttributeTypeInt32:
		return "Int32"
	case FileAttributeTypeUint64:
		return "Uint64"
	case FileAttributeTypeInt64:
		return "Int64"
	case FileAttributeTypeObject:
		return "Object"
	case FileAttributeTypeStringv:
		return "Stringv"
	default:
		return fmt.Sprintf("FileAttributeType(%d)", f)
	}
}

// FileMonitorEvent specifies what type of event a monitor event is.
type FileMonitorEvent C.gint

const (
	// FileMonitorEventChanged: file changed.
	FileMonitorEventChanged FileMonitorEvent = iota
	// FileMonitorEventChangesDoneHint: hint that this was probably the last
	// change in a set of changes.
	FileMonitorEventChangesDoneHint
	// FileMonitorEventDeleted: file was deleted.
	FileMonitorEventDeleted
	// FileMonitorEventCreated: file was created.
	FileMonitorEventCreated
	// FileMonitorEventAttributeChanged: file attribute was changed.
	FileMonitorEventAttributeChanged
	// FileMonitorEventPreUnmount: file location will soon be unmounted.
	FileMonitorEventPreUnmount
	// FileMonitorEventUnmounted: file location was unmounted.
	FileMonitorEventUnmounted
	// FileMonitorEventMoved: file was moved -- only sent if the (deprecated)
	// G_FILE_MONITOR_SEND_MOVED flag is set.
	FileMonitorEventMoved
	// FileMonitorEventRenamed: file was renamed within the current directory --
	// only sent if the G_FILE_MONITOR_WATCH_MOVES flag is set. Since: 2.46.
	FileMonitorEventRenamed
	// FileMonitorEventMovedIn: file was moved into the monitored directory from
	// another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag is
	// set. Since: 2.46.
	FileMonitorEventMovedIn
	// FileMonitorEventMovedOut: file was moved out of the monitored directory
	// to another location -- only sent if the G_FILE_MONITOR_WATCH_MOVES flag
	// is set. Since: 2.46.
	FileMonitorEventMovedOut
)

func marshalFileMonitorEvent(p uintptr) (interface{}, error) {
	return FileMonitorEvent(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileMonitorEvent.
func (f FileMonitorEvent) String() string {
	switch f {
	case FileMonitorEventChanged:
		return "Changed"
	case FileMonitorEventChangesDoneHint:
		return "ChangesDoneHint"
	case FileMonitorEventDeleted:
		return "Deleted"
	case FileMonitorEventCreated:
		return "Created"
	case FileMonitorEventAttributeChanged:
		return "AttributeChanged"
	case FileMonitorEventPreUnmount:
		return "PreUnmount"
	case FileMonitorEventUnmounted:
		return "Unmounted"
	case FileMonitorEventMoved:
		return "Moved"
	case FileMonitorEventRenamed:
		return "Renamed"
	case FileMonitorEventMovedIn:
		return "MovedIn"
	case FileMonitorEventMovedOut:
		return "MovedOut"
	default:
		return fmt.Sprintf("FileMonitorEvent(%d)", f)
	}
}

// FileType indicates the file's on-disk type.
//
// On Windows systems a file will never have G_FILE_TYPE_SYMBOLIC_LINK type; use
// Info and G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine whether a file is
// a symlink or not. This is due to the fact that NTFS does not have a single
// filesystem object type for symbolic links - it has files that symlink to
// files, and directories that symlink to directories. Type enumeration cannot
// precisely represent this important distinction, which is why all Windows
// symlinks will continue to be reported as G_FILE_TYPE_REGULAR or
// G_FILE_TYPE_DIRECTORY.
type FileType C.gint

const (
	// FileTypeUnknown file's type is unknown.
	FileTypeUnknown FileType = iota
	// FileTypeRegular: file handle represents a regular file.
	FileTypeRegular
	// FileTypeDirectory: file handle represents a directory.
	FileTypeDirectory
	// FileTypeSymbolicLink: file handle represents a symbolic link (Unix
	// systems).
	FileTypeSymbolicLink
	// FileTypeSpecial: file is a "special" file, such as a socket, fifo, block
	// device, or character device.
	FileTypeSpecial
	// FileTypeShortcut: file is a shortcut (Windows systems).
	FileTypeShortcut
	// FileTypeMountable: file is a mountable location.
	FileTypeMountable
)

func marshalFileType(p uintptr) (interface{}, error) {
	return FileType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileType.
func (f FileType) String() string {
	switch f {
	case FileTypeUnknown:
		return "Unknown"
	case FileTypeRegular:
		return "Regular"
	case FileTypeDirectory:
		return "Directory"
	case FileTypeSymbolicLink:
		return "SymbolicLink"
	case FileTypeSpecial:
		return "Special"
	case FileTypeShortcut:
		return "Shortcut"
	case FileTypeMountable:
		return "Mountable"
	default:
		return fmt.Sprintf("FileType(%d)", f)
	}
}

// FilesystemPreviewType indicates a hint from the file system whether files
// should be previewed in a file manager. Returned as the value of the key
// FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
type FilesystemPreviewType C.gint

const (
	// FilesystemPreviewTypeIfAlways: only preview files if user has explicitly
	// requested it.
	FilesystemPreviewTypeIfAlways FilesystemPreviewType = iota
	// FilesystemPreviewTypeIfLocal: preview files if user has requested preview
	// of "local" files.
	FilesystemPreviewTypeIfLocal
	// FilesystemPreviewTypeNever: never preview files.
	FilesystemPreviewTypeNever
)

func marshalFilesystemPreviewType(p uintptr) (interface{}, error) {
	return FilesystemPreviewType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FilesystemPreviewType.
func (f FilesystemPreviewType) String() string {
	switch f {
	case FilesystemPreviewTypeIfAlways:
		return "IfAlways"
	case FilesystemPreviewTypeIfLocal:
		return "IfLocal"
	case FilesystemPreviewTypeNever:
		return "Never"
	default:
		return fmt.Sprintf("FilesystemPreviewType(%d)", f)
	}
}

// IOErrorEnum: error codes returned by GIO functions.
//
// Note that this domain may be extended in future GLib releases. In general,
// new error codes either only apply to new APIs, or else replace
// G_IO_ERROR_FAILED in cases that were not explicitly distinguished before. You
// should therefore avoid writing code like
//
//    if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
//      {
//        // Assume that this is EPRINTERONFIRE
//        ...
//      }
//
// but should instead treat all unrecognized error codes the same as
// IO_ERROR_FAILED.
//
// See also Return for a cheaper way of returning G_IO_ERROR_WOULD_BLOCK to
// callers without allocating a #GError.
type IOErrorEnum C.gint

const (
	// IOErrorFailed: generic error condition for when an operation fails and no
	// more specific OErrorEnum value is defined.
	IOErrorFailed IOErrorEnum = 0
	// IOErrorNotFound: file not found.
	IOErrorNotFound IOErrorEnum = 1
	// IOErrorExists: file already exists.
	IOErrorExists IOErrorEnum = 2
	// IOErrorIsDirectory: file is a directory.
	IOErrorIsDirectory IOErrorEnum = 3
	// IOErrorNotDirectory: file is not a directory.
	IOErrorNotDirectory IOErrorEnum = 4
	// IOErrorNotEmpty: file is a directory that isn't empty.
	IOErrorNotEmpty IOErrorEnum = 5
	// IOErrorNotRegularFile: file is not a regular file.
	IOErrorNotRegularFile IOErrorEnum = 6
	// IOErrorNotSymbolicLink: file is not a symbolic link.
	IOErrorNotSymbolicLink IOErrorEnum = 7
	// IOErrorNotMountableFile: file cannot be mounted.
	IOErrorNotMountableFile IOErrorEnum = 8
	// IOErrorFilenameTooLong: filename is too many characters.
	IOErrorFilenameTooLong IOErrorEnum = 9
	// IOErrorInvalidFilename: filename is invalid or contains invalid
	// characters.
	IOErrorInvalidFilename IOErrorEnum = 10
	// IOErrorTooManyLinks: file contains too many symbolic links.
	IOErrorTooManyLinks IOErrorEnum = 11
	// IOErrorNoSpace: no space left on drive.
	IOErrorNoSpace IOErrorEnum = 12
	// IOErrorInvalidArgument: invalid argument.
	IOErrorInvalidArgument IOErrorEnum = 13
	// IOErrorPermissionDenied: permission denied.
	IOErrorPermissionDenied IOErrorEnum = 14
	// IOErrorNotSupported: operation (or one of its parameters) not supported.
	IOErrorNotSupported IOErrorEnum = 15
	// IOErrorNotMounted: file isn't mounted.
	IOErrorNotMounted IOErrorEnum = 16
	// IOErrorAlreadyMounted: file is already mounted.
	IOErrorAlreadyMounted IOErrorEnum = 17
	// IOErrorClosed: file was closed.
	IOErrorClosed IOErrorEnum = 18
	// IOErrorCancelled: operation was cancelled. See #GCancellable.
	IOErrorCancelled IOErrorEnum = 19
	// IOErrorPending operations are still pending.
	IOErrorPending IOErrorEnum = 20
	// IOErrorReadOnly: file is read only.
	IOErrorReadOnly IOErrorEnum = 21
	// IOErrorCantCreateBackup: backup couldn't be created.
	IOErrorCantCreateBackup IOErrorEnum = 22
	// IOErrorWrongETag file's Entity Tag was incorrect.
	IOErrorWrongETag IOErrorEnum = 23
	// IOErrorTimedOut: operation timed out.
	IOErrorTimedOut IOErrorEnum = 24
	// IOErrorWouldRecurse: operation would be recursive.
	IOErrorWouldRecurse IOErrorEnum = 25
	// IOErrorBusy: file is busy.
	IOErrorBusy IOErrorEnum = 26
	// IOErrorWouldBlock: operation would block.
	IOErrorWouldBlock IOErrorEnum = 27
	// IOErrorHostNotFound: host couldn't be found (remote operations).
	IOErrorHostNotFound IOErrorEnum = 28
	// IOErrorWouldMerge: operation would merge files.
	IOErrorWouldMerge IOErrorEnum = 29
	// IOErrorFailedHandled: operation failed and a helper program has already
	// interacted with the user. Do not display any error dialog.
	IOErrorFailedHandled IOErrorEnum = 30
	// IOErrorTooManyOpenFiles: current process has too many files open and
	// can't open any more. Duplicate descriptors do count toward this limit.
	// Since 2.20.
	IOErrorTooManyOpenFiles IOErrorEnum = 31
	// IOErrorNotInitialized: object has not been initialized. Since 2.22.
	IOErrorNotInitialized IOErrorEnum = 32
	// IOErrorAddressInUse: requested address is already in use. Since 2.22.
	IOErrorAddressInUse IOErrorEnum = 33
	// IOErrorPartialInput: need more input to finish operation. Since 2.24.
	IOErrorPartialInput IOErrorEnum = 34
	// IOErrorInvalidData: input data was invalid. Since 2.24.
	IOErrorInvalidData IOErrorEnum = 35
	// IOErrorDBusError: remote object generated an error that doesn't
	// correspond to a locally registered #GError error domain. Use
	// g_dbus_error_get_remote_error() to extract the D-Bus error name and
	// g_dbus_error_strip_remote_error() to fix up the message so it matches
	// what was received on the wire. Since 2.26.
	IOErrorDBusError IOErrorEnum = 36
	// IOErrorHostUnreachable: host unreachable. Since 2.26.
	IOErrorHostUnreachable IOErrorEnum = 37
	// IOErrorNetworkUnreachable: network unreachable. Since 2.26.
	IOErrorNetworkUnreachable IOErrorEnum = 38
	// IOErrorConnectionRefused: connection refused. Since 2.26.
	IOErrorConnectionRefused IOErrorEnum = 39
	// IOErrorProxyFailed: connection to proxy server failed. Since 2.26.
	IOErrorProxyFailed IOErrorEnum = 40
	// IOErrorProxyAuthFailed: proxy authentication failed. Since 2.26.
	IOErrorProxyAuthFailed IOErrorEnum = 41
	// IOErrorProxyNeedAuth: proxy server needs authentication. Since 2.26.
	IOErrorProxyNeedAuth IOErrorEnum = 42
	// IOErrorProxyNotAllowed: proxy connection is not allowed by ruleset. Since
	// 2.26.
	IOErrorProxyNotAllowed IOErrorEnum = 43
	// IOErrorBrokenPipe: broken pipe. Since 2.36.
	IOErrorBrokenPipe IOErrorEnum = 44
	// IOErrorConnectionClosed: connection closed by peer. Note that this is the
	// same code as G_IO_ERROR_BROKEN_PIPE; before 2.44 some "connection closed"
	// errors returned G_IO_ERROR_BROKEN_PIPE, but others returned
	// G_IO_ERROR_FAILED. Now they should all return the same value, which has
	// this more logical name. Since 2.44.
	IOErrorConnectionClosed IOErrorEnum = 44
	// IOErrorNotConnected: transport endpoint is not connected. Since 2.44.
	IOErrorNotConnected IOErrorEnum = 45
	// IOErrorMessageTooLarge: message too large. Since 2.48.
	IOErrorMessageTooLarge IOErrorEnum = 46
)

func marshalIOErrorEnum(p uintptr) (interface{}, error) {
	return IOErrorEnum(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IOErrorEnum.
func (i IOErrorEnum) String() string {
	switch i {
	case IOErrorFailed:
		return "Failed"
	case IOErrorNotFound:
		return "NotFound"
	case IOErrorExists:
		return "Exists"
	case IOErrorIsDirectory:
		return "IsDirectory"
	case IOErrorNotDirectory:
		return "NotDirectory"
	case IOErrorNotEmpty:
		return "NotEmpty"
	case IOErrorNotRegularFile:
		return "NotRegularFile"
	case IOErrorNotSymbolicLink:
		return "NotSymbolicLink"
	case IOErrorNotMountableFile:
		return "NotMountableFile"
	case IOErrorFilenameTooLong:
		return "FilenameTooLong"
	case IOErrorInvalidFilename:
		return "InvalidFilename"
	case IOErrorTooManyLinks:
		return "TooManyLinks"
	case IOErrorNoSpace:
		return "NoSpace"
	case IOErrorInvalidArgument:
		return "InvalidArgument"
	case IOErrorPermissionDenied:
		return "PermissionDenied"
	case IOErrorNotSupported:
		return "NotSupported"
	case IOErrorNotMounted:
		return "NotMounted"
	case IOErrorAlreadyMounted:
		return "AlreadyMounted"
	case IOErrorClosed:
		return "Closed"
	case IOErrorCancelled:
		return "Cancelled"
	case IOErrorPending:
		return "Pending"
	case IOErrorReadOnly:
		return "ReadOnly"
	case IOErrorCantCreateBackup:
		return "CantCreateBackup"
	case IOErrorWrongETag:
		return "WrongETag"
	case IOErrorTimedOut:
		return "TimedOut"
	case IOErrorWouldRecurse:
		return "WouldRecurse"
	case IOErrorBusy:
		return "Busy"
	case IOErrorWouldBlock:
		return "WouldBlock"
	case IOErrorHostNotFound:
		return "HostNotFound"
	case IOErrorWouldMerge:
		return "WouldMerge"
	case IOErrorFailedHandled:
		return "FailedHandled"
	case IOErrorTooManyOpenFiles:
		return "TooManyOpenFiles"
	case IOErrorNotInitialized:
		return "NotInitialized"
	case IOErrorAddressInUse:
		return "AddressInUse"
	case IOErrorPartialInput:
		return "PartialInput"
	case IOErrorInvalidData:
		return "InvalidData"
	case IOErrorDBusError:
		return "DBusError"
	case IOErrorHostUnreachable:
		return "HostUnreachable"
	case IOErrorNetworkUnreachable:
		return "NetworkUnreachable"
	case IOErrorConnectionRefused:
		return "ConnectionRefused"
	case IOErrorProxyFailed:
		return "ProxyFailed"
	case IOErrorProxyAuthFailed:
		return "ProxyAuthFailed"
	case IOErrorProxyNeedAuth:
		return "ProxyNeedAuth"
	case IOErrorProxyNotAllowed:
		return "ProxyNotAllowed"
	case IOErrorBrokenPipe:
		return "BrokenPipe"
	case IOErrorNotConnected:
		return "NotConnected"
	case IOErrorMessageTooLarge:
		return "MessageTooLarge"
	default:
		return fmt.Sprintf("IOErrorEnum(%d)", i)
	}
}

// IOModuleScopeFlags flags for use with g_io_module_scope_new().
type IOModuleScopeFlags C.gint

const (
	// IOModuleScopeNone: no module scan flags.
	IOModuleScopeNone IOModuleScopeFlags = iota
	// IOModuleScopeBlockDuplicates: when using this scope to load or scan
	// modules, automatically block a modules which has the same base basename
	// as previously loaded module.
	IOModuleScopeBlockDuplicates
)

func marshalIOModuleScopeFlags(p uintptr) (interface{}, error) {
	return IOModuleScopeFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IOModuleScopeFlags.
func (i IOModuleScopeFlags) String() string {
	switch i {
	case IOModuleScopeNone:
		return "None"
	case IOModuleScopeBlockDuplicates:
		return "BlockDuplicates"
	default:
		return fmt.Sprintf("IOModuleScopeFlags(%d)", i)
	}
}

// MemoryMonitorWarningLevel: memory availability warning levels.
//
// Note that because new values might be added, it is recommended that
// applications check MonitorWarningLevel as ranges, for example:
//
//    if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)
//      drop_caches ();.
type MemoryMonitorWarningLevel C.gint

const (
	// MemoryMonitorWarningLevelLow: memory on the device is low, processes
	// should free up unneeded resources (for example, in-memory caches) so they
	// can be used elsewhere.
	MemoryMonitorWarningLevelLow MemoryMonitorWarningLevel = 50
	// MemoryMonitorWarningLevelMedium: same as
	// G_MEMORY_MONITOR_WARNING_LEVEL_LOW but the device has even less free
	// memory, so processes should try harder to free up unneeded resources. If
	// your process does not need to stay running, it is a good time for it to
	// quit.
	MemoryMonitorWarningLevelMedium MemoryMonitorWarningLevel = 100
	// MemoryMonitorWarningLevelCritical: system will soon start terminating
	// processes to reclaim memory, including background processes.
	MemoryMonitorWarningLevelCritical MemoryMonitorWarningLevel = 255
)

func marshalMemoryMonitorWarningLevel(p uintptr) (interface{}, error) {
	return MemoryMonitorWarningLevel(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MemoryMonitorWarningLevel.
func (m MemoryMonitorWarningLevel) String() string {
	switch m {
	case MemoryMonitorWarningLevelLow:
		return "Low"
	case MemoryMonitorWarningLevelMedium:
		return "Medium"
	case MemoryMonitorWarningLevelCritical:
		return "Critical"
	default:
		return fmt.Sprintf("MemoryMonitorWarningLevel(%d)", m)
	}
}

// MountOperationResult is returned as a result when a request for information
// is send by the mounting operation.
type MountOperationResult C.gint

const (
	// MountOperationHandled: request was fulfilled and the user specified data
	// is now available.
	MountOperationHandled MountOperationResult = iota
	// MountOperationAborted: user requested the mount operation to be aborted.
	MountOperationAborted
	// MountOperationUnhandled: request was unhandled (i.e. not implemented).
	MountOperationUnhandled
)

func marshalMountOperationResult(p uintptr) (interface{}, error) {
	return MountOperationResult(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MountOperationResult.
func (m MountOperationResult) String() string {
	switch m {
	case MountOperationHandled:
		return "Handled"
	case MountOperationAborted:
		return "Aborted"
	case MountOperationUnhandled:
		return "Unhandled"
	default:
		return fmt.Sprintf("MountOperationResult(%d)", m)
	}
}

// NetworkConnectivity host's network connectivity state, as reported by
// Monitor.
type NetworkConnectivity C.gint

const (
	// NetworkConnectivityLocal: host is not configured with a route to the
	// Internet; it may or may not be connected to a local network.
	NetworkConnectivityLocal NetworkConnectivity = 1
	// NetworkConnectivityLimited: host is connected to a network, but does not
	// appear to be able to reach the full Internet, perhaps due to upstream
	// network problems.
	NetworkConnectivityLimited NetworkConnectivity = 2
	// NetworkConnectivityPortal: host is behind a captive portal and cannot
	// reach the full Internet.
	NetworkConnectivityPortal NetworkConnectivity = 3
	// NetworkConnectivityFull: host is connected to a network, and appears to
	// be able to reach the full Internet.
	NetworkConnectivityFull NetworkConnectivity = 4
)

func marshalNetworkConnectivity(p uintptr) (interface{}, error) {
	return NetworkConnectivity(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NetworkConnectivity.
func (n NetworkConnectivity) String() string {
	switch n {
	case NetworkConnectivityLocal:
		return "Local"
	case NetworkConnectivityLimited:
		return "Limited"
	case NetworkConnectivityPortal:
		return "Portal"
	case NetworkConnectivityFull:
		return "Full"
	default:
		return fmt.Sprintf("NetworkConnectivity(%d)", n)
	}
}

// NotificationPriority: priority levels for #GNotifications.
type NotificationPriority C.gint

const (
	// NotificationPriorityNormal: default priority, to be used for the majority
	// of notifications (for example email messages, software updates, completed
	// download/sync operations).
	NotificationPriorityNormal NotificationPriority = iota
	// NotificationPriorityLow: for notifications that do not require immediate
	// attention - typically used for contextual background information, such as
	// contact birthdays or local weather.
	NotificationPriorityLow
	// NotificationPriorityHigh: for events that require more attention, usually
	// because responses are time-sensitive (for example chat and SMS messages
	// or alarms).
	NotificationPriorityHigh
	// NotificationPriorityUrgent: for urgent notifications, or notifications
	// that require a response in a short space of time (for example phone calls
	// or emergency warnings).
	NotificationPriorityUrgent
)

func marshalNotificationPriority(p uintptr) (interface{}, error) {
	return NotificationPriority(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NotificationPriority.
func (n NotificationPriority) String() string {
	switch n {
	case NotificationPriorityNormal:
		return "Normal"
	case NotificationPriorityLow:
		return "Low"
	case NotificationPriorityHigh:
		return "High"
	case NotificationPriorityUrgent:
		return "Urgent"
	default:
		return fmt.Sprintf("NotificationPriority(%d)", n)
	}
}

// PasswordSave is used to indicate the lifespan of a saved password.
//
// #Gvfs stores passwords in the Gnome keyring when this flag allows it to, and
// later retrieves it again from there.
type PasswordSave C.gint

const (
	// PasswordSaveNever: never save a password.
	PasswordSaveNever PasswordSave = iota
	// PasswordSaveForSession: save a password for the session.
	PasswordSaveForSession
	// PasswordSavePermanently: save a password permanently.
	PasswordSavePermanently
)

func marshalPasswordSave(p uintptr) (interface{}, error) {
	return PasswordSave(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PasswordSave.
func (p PasswordSave) String() string {
	switch p {
	case PasswordSaveNever:
		return "Never"
	case PasswordSaveForSession:
		return "ForSession"
	case PasswordSavePermanently:
		return "Permanently"
	default:
		return fmt.Sprintf("PasswordSave(%d)", p)
	}
}

// PollableReturn: return value for various IO operations that signal errors via
// the return value and not necessarily via a #GError.
//
// This enum exists to be able to return errors to callers without having to
// allocate a #GError. Allocating #GErrors can be quite expensive for regularly
// happening errors like G_IO_ERROR_WOULD_BLOCK.
//
// In case of G_POLLABLE_RETURN_FAILED a #GError should be set for the operation
// to give details about the error that happened.
type PollableReturn C.gint

const (
	// PollableReturnFailed: generic error condition for when an operation
	// fails.
	PollableReturnFailed PollableReturn = 0
	// PollableReturnOK: operation was successfully finished.
	PollableReturnOK PollableReturn = 1
	// PollableReturnWouldBlock: operation would block.
	PollableReturnWouldBlock PollableReturn = -27
)

func marshalPollableReturn(p uintptr) (interface{}, error) {
	return PollableReturn(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PollableReturn.
func (p PollableReturn) String() string {
	switch p {
	case PollableReturnFailed:
		return "Failed"
	case PollableReturnOK:
		return "OK"
	case PollableReturnWouldBlock:
		return "WouldBlock"
	default:
		return fmt.Sprintf("PollableReturn(%d)", p)
	}
}

// ResolverError: error code used with G_RESOLVER_ERROR in a #GError returned
// from a #GResolver routine.
type ResolverError C.gint

const (
	// ResolverErrorNotFound: requested name/address/service was not found.
	ResolverErrorNotFound ResolverError = iota
	// ResolverErrorTemporaryFailure: requested information could not be looked
	// up due to a network error or similar problem.
	ResolverErrorTemporaryFailure
	// ResolverErrorInternal: unknown error.
	ResolverErrorInternal
)

func marshalResolverError(p uintptr) (interface{}, error) {
	return ResolverError(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResolverError.
func (r ResolverError) String() string {
	switch r {
	case ResolverErrorNotFound:
		return "NotFound"
	case ResolverErrorTemporaryFailure:
		return "TemporaryFailure"
	case ResolverErrorInternal:
		return "Internal"
	default:
		return fmt.Sprintf("ResolverError(%d)", r)
	}
}

// ResolverRecordType: type of record that g_resolver_lookup_records() or
// g_resolver_lookup_records_async() should retrieve. The records are returned
// as lists of #GVariant tuples. Each record type has different values in the
// variant tuples returned.
//
// G_RESOLVER_RECORD_SRV records are returned as variants with the signature
// (qqqs), containing a guint16 with the priority, a guint16 with the weight, a
// guint16 with the port, and a string of the hostname.
//
// G_RESOLVER_RECORD_MX records are returned as variants with the signature
// (qs), representing a guint16 with the preference, and a string containing the
// mail exchanger hostname.
//
// G_RESOLVER_RECORD_TXT records are returned as variants with the signature
// (as), representing an array of the strings in the text record. Note: Most TXT
// records only contain a single string, but RFC 1035
// (https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a record to
// contain multiple strings. The RFC which defines the interpretation of a
// specific TXT record will likely require concatenation of multiple strings if
// they are present, as with RFC 7208
// (https://tools.ietf.org/html/rfc7208#section-3.3).
//
// G_RESOLVER_RECORD_SOA records are returned as variants with the signature
// (ssuuuuu), representing a string containing the primary name server, a string
// containing the administrator, the serial as a guint32, the refresh interval
// as a guint32, the retry interval as a guint32, the expire timeout as a
// guint32, and the TTL as a guint32.
//
// G_RESOLVER_RECORD_NS records are returned as variants with the signature (s),
// representing a string of the hostname of the name server.
type ResolverRecordType C.gint

const (
	// ResolverRecordSrv: look up DNS SRV records for a domain.
	ResolverRecordSrv ResolverRecordType = 1
	// ResolverRecordMx: look up DNS MX records for a domain.
	ResolverRecordMx ResolverRecordType = 2
	// ResolverRecordTxt: look up DNS TXT records for a name.
	ResolverRecordTxt ResolverRecordType = 3
	// ResolverRecordSoa: look up DNS SOA records for a zone.
	ResolverRecordSoa ResolverRecordType = 4
	// ResolverRecordNs: look up DNS NS records for a domain.
	ResolverRecordNs ResolverRecordType = 5
)

func marshalResolverRecordType(p uintptr) (interface{}, error) {
	return ResolverRecordType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResolverRecordType.
func (r ResolverRecordType) String() string {
	switch r {
	case ResolverRecordSrv:
		return "Srv"
	case ResolverRecordMx:
		return "Mx"
	case ResolverRecordTxt:
		return "Txt"
	case ResolverRecordSoa:
		return "Soa"
	case ResolverRecordNs:
		return "Ns"
	default:
		return fmt.Sprintf("ResolverRecordType(%d)", r)
	}
}

// ResourceError: error code used with G_RESOURCE_ERROR in a #GError returned
// from a #GResource routine.
type ResourceError C.gint

const (
	// ResourceErrorNotFound: no file was found at the requested path.
	ResourceErrorNotFound ResourceError = iota
	// ResourceErrorInternal: unknown error.
	ResourceErrorInternal
)

func marshalResourceError(p uintptr) (interface{}, error) {
	return ResourceError(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResourceError.
func (r ResourceError) String() string {
	switch r {
	case ResourceErrorNotFound:
		return "NotFound"
	case ResourceErrorInternal:
		return "Internal"
	default:
		return fmt.Sprintf("ResourceError(%d)", r)
	}
}

// SocketClientEvent describes an event occurring on a Client. See the
// Client::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketClientEvent C.gint

const (
	// SocketClientResolving: client is doing a DNS lookup.
	SocketClientResolving SocketClientEvent = iota
	// SocketClientResolved: client has completed a DNS lookup.
	SocketClientResolved
	// SocketClientConnecting: client is connecting to a remote host (either a
	// proxy or the destination server).
	SocketClientConnecting
	// SocketClientConnected: client has connected to a remote host.
	SocketClientConnected
	// SocketClientProxyNegotiating: client is negotiating with a proxy to
	// connect to the destination server.
	SocketClientProxyNegotiating
	// SocketClientProxyNegotiated: client has negotiated with the proxy server.
	SocketClientProxyNegotiated
	// SocketClientTLSHandshaking: client is performing a TLS handshake.
	SocketClientTLSHandshaking
	// SocketClientTLSHandshaked: client has performed a TLS handshake.
	SocketClientTLSHandshaked
	// SocketClientComplete: client is done with a particular Connectable.
	SocketClientComplete
)

func marshalSocketClientEvent(p uintptr) (interface{}, error) {
	return SocketClientEvent(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketClientEvent.
func (s SocketClientEvent) String() string {
	switch s {
	case SocketClientResolving:
		return "Resolving"
	case SocketClientResolved:
		return "Resolved"
	case SocketClientConnecting:
		return "Connecting"
	case SocketClientConnected:
		return "Connected"
	case SocketClientProxyNegotiating:
		return "ProxyNegotiating"
	case SocketClientProxyNegotiated:
		return "ProxyNegotiated"
	case SocketClientTLSHandshaking:
		return "TLSHandshaking"
	case SocketClientTLSHandshaked:
		return "TLSHandshaked"
	case SocketClientComplete:
		return "Complete"
	default:
		return fmt.Sprintf("SocketClientEvent(%d)", s)
	}
}

// SocketFamily: protocol family of a Address. (These values are identical to
// the system defines AF_INET, AF_INET6 and AF_UNIX, if available.).
type SocketFamily C.gint

const (
	// SocketFamilyInvalid: no address family.
	SocketFamilyInvalid SocketFamily = 0
	// SocketFamilyUnix: UNIX domain family.
	SocketFamilyUnix SocketFamily = 1
	// SocketFamilyIPv4: IPv4 family.
	SocketFamilyIPv4 SocketFamily = 2
	// SocketFamilyIPv6: IPv6 family.
	SocketFamilyIPv6 SocketFamily = 10
)

func marshalSocketFamily(p uintptr) (interface{}, error) {
	return SocketFamily(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketFamily.
func (s SocketFamily) String() string {
	switch s {
	case SocketFamilyInvalid:
		return "Invalid"
	case SocketFamilyUnix:
		return "Unix"
	case SocketFamilyIPv4:
		return "IPv4"
	case SocketFamilyIPv6:
		return "IPv6"
	default:
		return fmt.Sprintf("SocketFamily(%d)", s)
	}
}

// SocketListenerEvent describes an event occurring on a Listener. See the
// Listener::event signal for more details.
//
// Additional values may be added to this type in the future.
type SocketListenerEvent C.gint

const (
	// SocketListenerBinding: listener is about to bind a socket.
	SocketListenerBinding SocketListenerEvent = iota
	// SocketListenerBound: listener has bound a socket.
	SocketListenerBound
	// SocketListenerListening: listener is about to start listening on this
	// socket.
	SocketListenerListening
	// SocketListenerListened: listener is now listening on this socket.
	SocketListenerListened
)

func marshalSocketListenerEvent(p uintptr) (interface{}, error) {
	return SocketListenerEvent(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketListenerEvent.
func (s SocketListenerEvent) String() string {
	switch s {
	case SocketListenerBinding:
		return "Binding"
	case SocketListenerBound:
		return "Bound"
	case SocketListenerListening:
		return "Listening"
	case SocketListenerListened:
		return "Listened"
	default:
		return fmt.Sprintf("SocketListenerEvent(%d)", s)
	}
}

// SocketProtocol: protocol identifier is specified when creating a #GSocket,
// which is a family/type specific identifier, where 0 means the default
// protocol for the particular family/type.
//
// This enum contains a set of commonly available and used protocols. You can
// also pass any other identifiers handled by the platform in order to use
// protocols not listed here.
type SocketProtocol C.gint

const (
	// SocketProtocolUnknown: protocol type is unknown.
	SocketProtocolUnknown SocketProtocol = -1
	// SocketProtocolDefault: default protocol for the family/type.
	SocketProtocolDefault SocketProtocol = 0
	// SocketProtocolTCP: TCP over IP.
	SocketProtocolTCP SocketProtocol = 6
	// SocketProtocolUDP: UDP over IP.
	SocketProtocolUDP SocketProtocol = 17
	// SocketProtocolSCTP: SCTP over IP.
	SocketProtocolSCTP SocketProtocol = 132
)

func marshalSocketProtocol(p uintptr) (interface{}, error) {
	return SocketProtocol(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketProtocol.
func (s SocketProtocol) String() string {
	switch s {
	case SocketProtocolUnknown:
		return "Unknown"
	case SocketProtocolDefault:
		return "Default"
	case SocketProtocolTCP:
		return "TCP"
	case SocketProtocolUDP:
		return "UDP"
	case SocketProtocolSCTP:
		return "SCTP"
	default:
		return fmt.Sprintf("SocketProtocol(%d)", s)
	}
}

// SocketType flags used when creating a #GSocket. Some protocols may not
// implement all the socket types.
type SocketType C.gint

const (
	// SocketTypeInvalid: type unknown or wrong.
	SocketTypeInvalid SocketType = iota
	// SocketTypeStream: reliable connection-based byte streams (e.g. TCP).
	SocketTypeStream
	// SocketTypeDatagram: connectionless, unreliable datagram passing. (e.g.
	// UDP).
	SocketTypeDatagram
	// SocketTypeSeqpacket: reliable connection-based passing of datagrams of
	// fixed maximum length (e.g. SCTP).
	SocketTypeSeqpacket
)

func marshalSocketType(p uintptr) (interface{}, error) {
	return SocketType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SocketType.
func (s SocketType) String() string {
	switch s {
	case SocketTypeInvalid:
		return "Invalid"
	case SocketTypeStream:
		return "Stream"
	case SocketTypeDatagram:
		return "Datagram"
	case SocketTypeSeqpacket:
		return "Seqpacket"
	default:
		return fmt.Sprintf("SocketType(%d)", s)
	}
}

// TLSAuthenticationMode: client authentication mode for a ServerConnection.
type TLSAuthenticationMode C.gint

const (
	// TLSAuthenticationNone: client authentication not required.
	TLSAuthenticationNone TLSAuthenticationMode = iota
	// TLSAuthenticationRequested: client authentication is requested.
	TLSAuthenticationRequested
	// TLSAuthenticationRequired: client authentication is required.
	TLSAuthenticationRequired
)

func marshalTLSAuthenticationMode(p uintptr) (interface{}, error) {
	return TLSAuthenticationMode(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSAuthenticationMode.
func (t TLSAuthenticationMode) String() string {
	switch t {
	case TLSAuthenticationNone:
		return "None"
	case TLSAuthenticationRequested:
		return "Requested"
	case TLSAuthenticationRequired:
		return "Required"
	default:
		return fmt.Sprintf("TLSAuthenticationMode(%d)", t)
	}
}

// TLSCertificateRequestFlags flags for g_tls_interaction_request_certificate(),
// g_tls_interaction_request_certificate_async(), and
// g_tls_interaction_invoke_request_certificate().
type TLSCertificateRequestFlags C.gint

const (
	// TLSCertificateRequestNone: no flags.
	TLSCertificateRequestNone TLSCertificateRequestFlags = iota
)

func marshalTLSCertificateRequestFlags(p uintptr) (interface{}, error) {
	return TLSCertificateRequestFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSCertificateRequestFlags.
func (t TLSCertificateRequestFlags) String() string {
	switch t {
	case TLSCertificateRequestNone:
		return "None"
	default:
		return fmt.Sprintf("TLSCertificateRequestFlags(%d)", t)
	}
}

// TLSChannelBindingError: error code used with G_TLS_CHANNEL_BINDING_ERROR in a
// #GError to indicate a TLS channel binding retrieval error.
type TLSChannelBindingError C.gint

const (
	// TLSChannelBindingErrorNotImplemented: either entire binding retrieval
	// facility or specific binding type is not implemented in the TLS backend.
	TLSChannelBindingErrorNotImplemented TLSChannelBindingError = iota
	// TLSChannelBindingErrorInvalidState: handshake is not yet complete on the
	// connection which is a strong requirement for any existing binding type.
	TLSChannelBindingErrorInvalidState
	// TLSChannelBindingErrorNotAvailable: handshake is complete but binding
	// data is not available. That normally indicates the TLS implementation
	// failed to provide the binding data. For example, some implementations do
	// not provide a peer certificate for resumed connections.
	TLSChannelBindingErrorNotAvailable
	// TLSChannelBindingErrorNotSupported: binding type is not supported on the
	// current connection. This error could be triggered when requesting
	// tls-server-end-point binding data for a certificate which has no hash
	// function or uses multiple hash functions.
	TLSChannelBindingErrorNotSupported
	// TLSChannelBindingErrorGeneralError: any other backend error preventing
	// binding data retrieval.
	TLSChannelBindingErrorGeneralError
)

func marshalTLSChannelBindingError(p uintptr) (interface{}, error) {
	return TLSChannelBindingError(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSChannelBindingError.
func (t TLSChannelBindingError) String() string {
	switch t {
	case TLSChannelBindingErrorNotImplemented:
		return "NotImplemented"
	case TLSChannelBindingErrorInvalidState:
		return "InvalidState"
	case TLSChannelBindingErrorNotAvailable:
		return "NotAvailable"
	case TLSChannelBindingErrorNotSupported:
		return "NotSupported"
	case TLSChannelBindingErrorGeneralError:
		return "GeneralError"
	default:
		return fmt.Sprintf("TLSChannelBindingError(%d)", t)
	}
}

// TLSChannelBindingType: type of TLS channel binding data to retrieve from
// Connection or Connection, as documented by RFC 5929. The
// tls-unique-for-telnet (https://tools.ietf.org/html/rfc5929#section-5) binding
// type is not currently implemented.
type TLSChannelBindingType C.gint

const (
	// TLSChannelBindingTLSUnique: tls-unique
	// (https://tools.ietf.org/html/rfc5929#section-3) binding type.
	TLSChannelBindingTLSUnique TLSChannelBindingType = iota
	// TLSChannelBindingTLSServerEndPoint: tls-server-end-point
	// (https://tools.ietf.org/html/rfc5929#section-4) binding type.
	TLSChannelBindingTLSServerEndPoint
)

func marshalTLSChannelBindingType(p uintptr) (interface{}, error) {
	return TLSChannelBindingType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSChannelBindingType.
func (t TLSChannelBindingType) String() string {
	switch t {
	case TLSChannelBindingTLSUnique:
		return "Unique"
	case TLSChannelBindingTLSServerEndPoint:
		return "ServerEndPoint"
	default:
		return fmt.Sprintf("TLSChannelBindingType(%d)", t)
	}
}

// TLSDatabaseLookupFlags flags for
// g_tls_database_lookup_certificate_for_handle(),
// g_tls_database_lookup_certificate_issuer(), and
// g_tls_database_lookup_certificates_issued_by().
type TLSDatabaseLookupFlags C.gint

const (
	// TLSDatabaseLookupNone: no lookup flags.
	TLSDatabaseLookupNone TLSDatabaseLookupFlags = iota
	// TLSDatabaseLookupKeypair: restrict lookup to certificates that have a
	// private key.
	TLSDatabaseLookupKeypair
)

func marshalTLSDatabaseLookupFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseLookupFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSDatabaseLookupFlags.
func (t TLSDatabaseLookupFlags) String() string {
	switch t {
	case TLSDatabaseLookupNone:
		return "None"
	case TLSDatabaseLookupKeypair:
		return "Keypair"
	default:
		return fmt.Sprintf("TLSDatabaseLookupFlags(%d)", t)
	}
}

// TLSError: error code used with G_TLS_ERROR in a #GError returned from a
// TLS-related routine.
type TLSError C.gint

const (
	// TLSErrorUnavailable: no TLS provider is available.
	TLSErrorUnavailable TLSError = iota
	// TLSErrorMisc miscellaneous TLS error.
	TLSErrorMisc
	// TLSErrorBadCertificate: certificate presented could not be parsed or
	// failed validation.
	TLSErrorBadCertificate
	// TLSErrorNotTLS: TLS handshake failed because the peer does not seem to be
	// a TLS server.
	TLSErrorNotTLS
	// TLSErrorHandshake: TLS handshake failed because the peer's certificate
	// was not acceptable.
	TLSErrorHandshake
	// TLSErrorCertificateRequired: TLS handshake failed because the server
	// requested a client-side certificate, but none was provided. See
	// g_tls_connection_set_certificate().
	TLSErrorCertificateRequired
	// TLSErrorEOF: TLS connection was closed without proper notice, which may
	// indicate an attack. See g_tls_connection_set_require_close_notify().
	TLSErrorEOF
	// TLSErrorInappropriateFallback: TLS handshake failed because the client
	// sent the fallback SCSV, indicating a protocol downgrade attack. Since:
	// 2.60.
	TLSErrorInappropriateFallback
)

func marshalTLSError(p uintptr) (interface{}, error) {
	return TLSError(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSError.
func (t TLSError) String() string {
	switch t {
	case TLSErrorUnavailable:
		return "Unavailable"
	case TLSErrorMisc:
		return "Misc"
	case TLSErrorBadCertificate:
		return "BadCertificate"
	case TLSErrorNotTLS:
		return "NotTLS"
	case TLSErrorHandshake:
		return "Handshake"
	case TLSErrorCertificateRequired:
		return "CertificateRequired"
	case TLSErrorEOF:
		return "EOF"
	case TLSErrorInappropriateFallback:
		return "InappropriateFallback"
	default:
		return fmt.Sprintf("TLSError(%d)", t)
	}
}

// TLSInteractionResult is returned by various functions in Interaction when
// finishing an interaction request.
type TLSInteractionResult C.gint

const (
	// TLSInteractionUnhandled: interaction was unhandled (i.e. not
	// implemented).
	TLSInteractionUnhandled TLSInteractionResult = iota
	// TLSInteractionHandled: interaction completed, and resulting data is
	// available.
	TLSInteractionHandled
	// TLSInteractionFailed: interaction has failed, or was cancelled. and the
	// operation should be aborted.
	TLSInteractionFailed
)

func marshalTLSInteractionResult(p uintptr) (interface{}, error) {
	return TLSInteractionResult(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSInteractionResult.
func (t TLSInteractionResult) String() string {
	switch t {
	case TLSInteractionUnhandled:
		return "Unhandled"
	case TLSInteractionHandled:
		return "Handled"
	case TLSInteractionFailed:
		return "Failed"
	default:
		return fmt.Sprintf("TLSInteractionResult(%d)", t)
	}
}

// TLSRehandshakeMode: when to allow rehandshaking. See
// g_tls_connection_set_rehandshake_mode().
//
// Deprecated: Changing the rehandshake mode is no longer required for
// compatibility. Also, rehandshaking has been removed from the TLS protocol in
// TLS 1.3.
type TLSRehandshakeMode C.gint

const (
	// TLSRehandshakeNever: never allow rehandshaking.
	TLSRehandshakeNever TLSRehandshakeMode = iota
	// TLSRehandshakeSafely: allow safe rehandshaking only.
	TLSRehandshakeSafely
	// TLSRehandshakeUnsafely: allow unsafe rehandshaking.
	TLSRehandshakeUnsafely
)

func marshalTLSRehandshakeMode(p uintptr) (interface{}, error) {
	return TLSRehandshakeMode(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TLSRehandshakeMode.
func (t TLSRehandshakeMode) String() string {
	switch t {
	case TLSRehandshakeNever:
		return "Never"
	case TLSRehandshakeSafely:
		return "Safely"
	case TLSRehandshakeUnsafely:
		return "Unsafely"
	default:
		return fmt.Sprintf("TLSRehandshakeMode(%d)", t)
	}
}

// UnixSocketAddressType: type of name used by a SocketAddress.
// G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain socket bound
// to a filesystem path. G_UNIX_SOCKET_ADDRESS_ANONYMOUS indicates a socket not
// bound to any name (eg, a client-side socket, or a socket created with
// socketpair()).
//
// For abstract sockets, there are two incompatible ways of naming them; the man
// pages suggest using the entire struct sockaddr_un as the name, padding the
// unused parts of the sun_path field with zeroes; this corresponds to
// G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED. However, many programs instead just
// use a portion of sun_path, and pass an appropriate smaller length to bind()
// or connect(). This is G_UNIX_SOCKET_ADDRESS_ABSTRACT.
type UnixSocketAddressType C.gint

const (
	// UnixSocketAddressInvalid: invalid.
	UnixSocketAddressInvalid UnixSocketAddressType = iota
	// UnixSocketAddressAnonymous: anonymous.
	UnixSocketAddressAnonymous
	// UnixSocketAddressPath: filesystem path.
	UnixSocketAddressPath
	// UnixSocketAddressAbstract: abstract name.
	UnixSocketAddressAbstract
	// UnixSocketAddressAbstractPadded: abstract name, 0-padded to the full
	// length of a unix socket name.
	UnixSocketAddressAbstractPadded
)

func marshalUnixSocketAddressType(p uintptr) (interface{}, error) {
	return UnixSocketAddressType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for UnixSocketAddressType.
func (u UnixSocketAddressType) String() string {
	switch u {
	case UnixSocketAddressInvalid:
		return "Invalid"
	case UnixSocketAddressAnonymous:
		return "Anonymous"
	case UnixSocketAddressPath:
		return "Path"
	case UnixSocketAddressAbstract:
		return "Abstract"
	case UnixSocketAddressAbstractPadded:
		return "AbstractPadded"
	default:
		return fmt.Sprintf("UnixSocketAddressType(%d)", u)
	}
}

// ZlibCompressorFormat: used to select the type of data format to use for
// Decompressor and Compressor.
type ZlibCompressorFormat C.gint

const (
	// ZlibCompressorFormatZlib: deflate compression with zlib header.
	ZlibCompressorFormatZlib ZlibCompressorFormat = iota
	// ZlibCompressorFormatGzip: gzip file format.
	ZlibCompressorFormatGzip
	// ZlibCompressorFormatRaw: deflate compression with no header.
	ZlibCompressorFormatRaw
)

func marshalZlibCompressorFormat(p uintptr) (interface{}, error) {
	return ZlibCompressorFormat(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ZlibCompressorFormat.
func (z ZlibCompressorFormat) String() string {
	switch z {
	case ZlibCompressorFormatZlib:
		return "Zlib"
	case ZlibCompressorFormatGzip:
		return "Gzip"
	case ZlibCompressorFormatRaw:
		return "Raw"
	default:
		return fmt.Sprintf("ZlibCompressorFormat(%d)", z)
	}
}

// AppInfoCreateFlags flags used when creating a Info.
type AppInfoCreateFlags C.guint

const (
	// AppInfoCreateNone: no flags.
	AppInfoCreateNone AppInfoCreateFlags = 0b0
	// AppInfoCreateNeedsTerminal: application opens in a terminal window.
	AppInfoCreateNeedsTerminal AppInfoCreateFlags = 0b1
	// AppInfoCreateSupportsURIs: application supports URI arguments.
	AppInfoCreateSupportsURIs AppInfoCreateFlags = 0b10
	// AppInfoCreateSupportsStartupNotification: application supports startup
	// notification. Since 2.26.
	AppInfoCreateSupportsStartupNotification AppInfoCreateFlags = 0b100
)

func marshalAppInfoCreateFlags(p uintptr) (interface{}, error) {
	return AppInfoCreateFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AppInfoCreateFlags.
func (a AppInfoCreateFlags) String() string {
	if a == 0 {
		return "AppInfoCreateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(111)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AppInfoCreateNone:
			builder.WriteString("None|")
		case AppInfoCreateNeedsTerminal:
			builder.WriteString("NeedsTerminal|")
		case AppInfoCreateSupportsURIs:
			builder.WriteString("SupportsURIs|")
		case AppInfoCreateSupportsStartupNotification:
			builder.WriteString("SupportsStartupNotification|")
		default:
			builder.WriteString(fmt.Sprintf("AppInfoCreateFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AppInfoCreateFlags) Has(other AppInfoCreateFlags) bool {
	return (a & other) == other
}

// ApplicationFlags flags used to define the behaviour of a #GApplication.
type ApplicationFlags C.guint

const (
	// ApplicationFlagsNone: default.
	ApplicationFlagsNone ApplicationFlags = 0b0
	// ApplicationIsService: run as a service. In this mode, registration fails
	// if the service is already running, and the application will initially
	// wait up to 10 seconds for an initial activation message to arrive.
	ApplicationIsService ApplicationFlags = 0b1
	// ApplicationIsLauncher: don't try to become the primary instance.
	ApplicationIsLauncher ApplicationFlags = 0b10
	// ApplicationHandlesOpen: this application handles opening files (in the
	// primary instance). Note that this flag only affects the default
	// implementation of local_command_line(), and has no effect if
	// G_APPLICATION_HANDLES_COMMAND_LINE is given. See g_application_run() for
	// details.
	ApplicationHandlesOpen ApplicationFlags = 0b100
	// ApplicationHandlesCommandLine: this application handles command line
	// arguments (in the primary instance). Note that this flag only affect the
	// default implementation of local_command_line(). See g_application_run()
	// for details.
	ApplicationHandlesCommandLine ApplicationFlags = 0b1000
	// ApplicationSendEnvironment: send the environment of the launching process
	// to the primary instance. Set this flag if your application is expected to
	// behave differently depending on certain environment variables. For
	// instance, an editor might be expected to use the GIT_COMMITTER_NAME
	// environment variable when editing a git commit message. The environment
	// is available to the #GApplication::command-line signal handler, via
	// g_application_command_line_getenv().
	ApplicationSendEnvironment ApplicationFlags = 0b10000
	// ApplicationNonUnique: make no attempts to do any of the typical
	// single-instance application negotiation, even if the application ID is
	// given. The application neither attempts to become the owner of the
	// application ID nor does it check if an existing owner already exists.
	// Everything occurs in the local process. Since: 2.30.
	ApplicationNonUnique ApplicationFlags = 0b100000
	// ApplicationCanOverrideAppID: allow users to override the application ID
	// from the command line with --gapplication-app-id. Since: 2.48.
	ApplicationCanOverrideAppID ApplicationFlags = 0b1000000
	// ApplicationAllowReplacement: allow another instance to take over the bus
	// name. Since: 2.60.
	ApplicationAllowReplacement ApplicationFlags = 0b10000000
	// ApplicationReplace: take over from another instance. This flag is usually
	// set by passing --gapplication-replace on the commandline. Since: 2.60.
	ApplicationReplace ApplicationFlags = 0b100000000
)

func marshalApplicationFlags(p uintptr) (interface{}, error) {
	return ApplicationFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ApplicationFlags.
func (a ApplicationFlags) String() string {
	if a == 0 {
		return "ApplicationFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(239)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case ApplicationFlagsNone:
			builder.WriteString("FlagsNone|")
		case ApplicationIsService:
			builder.WriteString("IsService|")
		case ApplicationIsLauncher:
			builder.WriteString("IsLauncher|")
		case ApplicationHandlesOpen:
			builder.WriteString("HandlesOpen|")
		case ApplicationHandlesCommandLine:
			builder.WriteString("HandlesCommandLine|")
		case ApplicationSendEnvironment:
			builder.WriteString("SendEnvironment|")
		case ApplicationNonUnique:
			builder.WriteString("NonUnique|")
		case ApplicationCanOverrideAppID:
			builder.WriteString("CanOverrideAppID|")
		case ApplicationAllowReplacement:
			builder.WriteString("AllowReplacement|")
		case ApplicationReplace:
			builder.WriteString("Replace|")
		default:
			builder.WriteString(fmt.Sprintf("ApplicationFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a ApplicationFlags) Has(other ApplicationFlags) bool {
	return (a & other) == other
}

// AskPasswordFlags are used to request specific information from the user, or
// to notify the user of their choices in an authentication situation.
type AskPasswordFlags C.guint

const (
	// AskPasswordNeedPassword: operation requires a password.
	AskPasswordNeedPassword AskPasswordFlags = 0b1
	// AskPasswordNeedUsername: operation requires a username.
	AskPasswordNeedUsername AskPasswordFlags = 0b10
	// AskPasswordNeedDomain: operation requires a domain.
	AskPasswordNeedDomain AskPasswordFlags = 0b100
	// AskPasswordSavingSupported: operation supports saving settings.
	AskPasswordSavingSupported AskPasswordFlags = 0b1000
	// AskPasswordAnonymousSupported: operation supports anonymous users.
	AskPasswordAnonymousSupported AskPasswordFlags = 0b10000
	// AskPasswordTcrypt: operation takes TCRYPT parameters (Since: 2.58).
	AskPasswordTcrypt AskPasswordFlags = 0b100000
)

func marshalAskPasswordFlags(p uintptr) (interface{}, error) {
	return AskPasswordFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AskPasswordFlags.
func (a AskPasswordFlags) String() string {
	if a == 0 {
		return "AskPasswordFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(144)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AskPasswordNeedPassword:
			builder.WriteString("NeedPassword|")
		case AskPasswordNeedUsername:
			builder.WriteString("NeedUsername|")
		case AskPasswordNeedDomain:
			builder.WriteString("NeedDomain|")
		case AskPasswordSavingSupported:
			builder.WriteString("SavingSupported|")
		case AskPasswordAnonymousSupported:
			builder.WriteString("AnonymousSupported|")
		case AskPasswordTcrypt:
			builder.WriteString("Tcrypt|")
		default:
			builder.WriteString(fmt.Sprintf("AskPasswordFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AskPasswordFlags) Has(other AskPasswordFlags) bool {
	return (a & other) == other
}

// BusNameOwnerFlags flags used in g_bus_own_name().
type BusNameOwnerFlags C.guint

const (
	// BusNameOwnerFlagsNone: no flags set.
	BusNameOwnerFlagsNone BusNameOwnerFlags = 0b0
	// BusNameOwnerFlagsAllowReplacement: allow another message bus connection
	// to claim the name.
	BusNameOwnerFlagsAllowReplacement BusNameOwnerFlags = 0b1
	// BusNameOwnerFlagsReplace: if another message bus connection owns the name
	// and have specified BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the
	// name from the other connection.
	BusNameOwnerFlagsReplace BusNameOwnerFlags = 0b10
	// BusNameOwnerFlagsDoNotQueue: if another message bus connection owns the
	// name, immediately return an error from g_bus_own_name() rather than
	// entering the waiting queue for that name. (Since 2.54).
	BusNameOwnerFlagsDoNotQueue BusNameOwnerFlags = 0b100
)

func marshalBusNameOwnerFlags(p uintptr) (interface{}, error) {
	return BusNameOwnerFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BusNameOwnerFlags.
func (b BusNameOwnerFlags) String() string {
	if b == 0 {
		return "BusNameOwnerFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(108)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BusNameOwnerFlagsNone:
			builder.WriteString("None|")
		case BusNameOwnerFlagsAllowReplacement:
			builder.WriteString("AllowReplacement|")
		case BusNameOwnerFlagsReplace:
			builder.WriteString("Replace|")
		case BusNameOwnerFlagsDoNotQueue:
			builder.WriteString("DoNotQueue|")
		default:
			builder.WriteString(fmt.Sprintf("BusNameOwnerFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BusNameOwnerFlags) Has(other BusNameOwnerFlags) bool {
	return (b & other) == other
}

// BusNameWatcherFlags flags used in g_bus_watch_name().
type BusNameWatcherFlags C.guint

const (
	// BusNameWatcherFlagsNone: no flags set.
	BusNameWatcherFlagsNone BusNameWatcherFlags = 0b0
	// BusNameWatcherFlagsAutoStart: if no-one owns the name when beginning to
	// watch the name, ask the bus to launch an owner for the name.
	BusNameWatcherFlagsAutoStart BusNameWatcherFlags = 0b1
)

func marshalBusNameWatcherFlags(p uintptr) (interface{}, error) {
	return BusNameWatcherFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BusNameWatcherFlags.
func (b BusNameWatcherFlags) String() string {
	if b == 0 {
		return "BusNameWatcherFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(52)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BusNameWatcherFlagsNone:
			builder.WriteString("None|")
		case BusNameWatcherFlagsAutoStart:
			builder.WriteString("AutoStart|")
		default:
			builder.WriteString(fmt.Sprintf("BusNameWatcherFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BusNameWatcherFlags) Has(other BusNameWatcherFlags) bool {
	return (b & other) == other
}

// ConverterFlags flags used when calling a g_converter_convert().
type ConverterFlags C.guint

const (
	// ConverterNoFlags: no flags.
	ConverterNoFlags ConverterFlags = 0b0
	// ConverterInputAtEnd: at end of input data.
	ConverterInputAtEnd ConverterFlags = 0b1
	// ConverterFlush: flush data.
	ConverterFlush ConverterFlags = 0b10
)

func marshalConverterFlags(p uintptr) (interface{}, error) {
	return ConverterFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ConverterFlags.
func (c ConverterFlags) String() string {
	if c == 0 {
		return "ConverterFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(51)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case ConverterNoFlags:
			builder.WriteString("None|")
		case ConverterInputAtEnd:
			builder.WriteString("InputAtEnd|")
		case ConverterFlush:
			builder.WriteString("Flush|")
		default:
			builder.WriteString(fmt.Sprintf("ConverterFlags(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c ConverterFlags) Has(other ConverterFlags) bool {
	return (c & other) == other
}

// DBusCallFlags flags used in g_dbus_connection_call() and similar APIs.
type DBusCallFlags C.guint

const (
	// DBusCallFlagsNone: no flags set.
	DBusCallFlagsNone DBusCallFlags = 0b0
	// DBusCallFlagsNoAutoStart bus must not launch an owner for the destination
	// name in response to this method invocation.
	DBusCallFlagsNoAutoStart DBusCallFlags = 0b1
	// DBusCallFlagsAllowInteractiveAuthorization: caller is prepared to wait
	// for interactive authorization. Since 2.46.
	DBusCallFlagsAllowInteractiveAuthorization DBusCallFlags = 0b10
)

func marshalDBusCallFlags(p uintptr) (interface{}, error) {
	return DBusCallFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusCallFlags.
func (d DBusCallFlags) String() string {
	if d == 0 {
		return "DBusCallFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(85)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusCallFlagsNone:
			builder.WriteString("None|")
		case DBusCallFlagsNoAutoStart:
			builder.WriteString("NoAutoStart|")
		case DBusCallFlagsAllowInteractiveAuthorization:
			builder.WriteString("AllowInteractiveAuthorization|")
		default:
			builder.WriteString(fmt.Sprintf("DBusCallFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusCallFlags) Has(other DBusCallFlags) bool {
	return (d & other) == other
}

// DBusCapabilityFlags capabilities negotiated with the remote peer.
type DBusCapabilityFlags C.guint

const (
	// DBusCapabilityFlagsNone: no flags set.
	DBusCapabilityFlagsNone DBusCapabilityFlags = 0b0
	// DBusCapabilityFlagsUnixFdPassing connection supports exchanging UNIX file
	// descriptors with the remote peer.
	DBusCapabilityFlagsUnixFdPassing DBusCapabilityFlags = 0b1
)

func marshalDBusCapabilityFlags(p uintptr) (interface{}, error) {
	return DBusCapabilityFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusCapabilityFlags.
func (d DBusCapabilityFlags) String() string {
	if d == 0 {
		return "DBusCapabilityFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(56)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusCapabilityFlagsNone:
			builder.WriteString("None|")
		case DBusCapabilityFlagsUnixFdPassing:
			builder.WriteString("UnixFdPassing|")
		default:
			builder.WriteString(fmt.Sprintf("DBusCapabilityFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusCapabilityFlags) Has(other DBusCapabilityFlags) bool {
	return (d & other) == other
}

// DBusConnectionFlags flags used when creating a new BusConnection.
type DBusConnectionFlags C.guint

const (
	// DBusConnectionFlagsNone: no flags set.
	DBusConnectionFlagsNone DBusConnectionFlags = 0b0
	// DBusConnectionFlagsAuthenticationClient: perform authentication against
	// server.
	DBusConnectionFlagsAuthenticationClient DBusConnectionFlags = 0b1
	// DBusConnectionFlagsAuthenticationServer: perform authentication against
	// client.
	DBusConnectionFlagsAuthenticationServer DBusConnectionFlags = 0b10
	// DBusConnectionFlagsAuthenticationAllowAnonymous: when authenticating as a
	// server, allow the anonymous authentication method.
	DBusConnectionFlagsAuthenticationAllowAnonymous DBusConnectionFlags = 0b100
	// DBusConnectionFlagsMessageBusConnection pass this flag if connecting to a
	// peer that is a message bus. This means that the Hello() method will be
	// invoked as part of the connection setup.
	DBusConnectionFlagsMessageBusConnection DBusConnectionFlags = 0b1000
	// DBusConnectionFlagsDelayMessageProcessing: if set, processing of D-Bus
	// messages is delayed until g_dbus_connection_start_message_processing() is
	// called.
	DBusConnectionFlagsDelayMessageProcessing DBusConnectionFlags = 0b10000
	// DBusConnectionFlagsAuthenticationRequireSameUser: when authenticating as
	// a server, require the UID of the peer to be the same as the UID of the
	// server. (Since: 2.68).
	DBusConnectionFlagsAuthenticationRequireSameUser DBusConnectionFlags = 0b100000
)

func marshalDBusConnectionFlags(p uintptr) (interface{}, error) {
	return DBusConnectionFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusConnectionFlags.
func (d DBusConnectionFlags) String() string {
	if d == 0 {
		return "DBusConnectionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusConnectionFlagsNone:
			builder.WriteString("None|")
		case DBusConnectionFlagsAuthenticationClient:
			builder.WriteString("AuthenticationClient|")
		case DBusConnectionFlagsAuthenticationServer:
			builder.WriteString("AuthenticationServer|")
		case DBusConnectionFlagsAuthenticationAllowAnonymous:
			builder.WriteString("AuthenticationAllowAnonymous|")
		case DBusConnectionFlagsMessageBusConnection:
			builder.WriteString("MessageBusConnection|")
		case DBusConnectionFlagsDelayMessageProcessing:
			builder.WriteString("DelayMessageProcessing|")
		case DBusConnectionFlagsAuthenticationRequireSameUser:
			builder.WriteString("AuthenticationRequireSameUser|")
		default:
			builder.WriteString(fmt.Sprintf("DBusConnectionFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusConnectionFlags) Has(other DBusConnectionFlags) bool {
	return (d & other) == other
}

// DBusInterfaceSkeletonFlags flags describing the behavior of a
// BusInterfaceSkeleton instance.
type DBusInterfaceSkeletonFlags C.guint

const (
	// DBusInterfaceSkeletonFlagsNone: no flags set.
	DBusInterfaceSkeletonFlagsNone DBusInterfaceSkeletonFlags = 0b0
	// DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread: each method
	// invocation is handled in a thread dedicated to the invocation. This means
	// that the method implementation can use blocking IO without blocking any
	// other part of the process. It also means that the method implementation
	// must use locking to access data structures used by other threads.
	DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread DBusInterfaceSkeletonFlags = 0b1
)

func marshalDBusInterfaceSkeletonFlags(p uintptr) (interface{}, error) {
	return DBusInterfaceSkeletonFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusInterfaceSkeletonFlags.
func (d DBusInterfaceSkeletonFlags) String() string {
	if d == 0 {
		return "DBusInterfaceSkeletonFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(88)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusInterfaceSkeletonFlagsNone:
			builder.WriteString("None|")
		case DBusInterfaceSkeletonFlagsHandleMethodInvocationsInThread:
			builder.WriteString("HandleMethodInvocationsInThread|")
		default:
			builder.WriteString(fmt.Sprintf("DBusInterfaceSkeletonFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusInterfaceSkeletonFlags) Has(other DBusInterfaceSkeletonFlags) bool {
	return (d & other) == other
}

// DBusMessageFlags: message flags used in BusMessage.
type DBusMessageFlags C.guint

const (
	// DBusMessageFlagsNone: no flags set.
	DBusMessageFlagsNone DBusMessageFlags = 0b0
	// DBusMessageFlagsNoReplyExpected: reply is not expected.
	DBusMessageFlagsNoReplyExpected DBusMessageFlags = 0b1
	// DBusMessageFlagsNoAutoStart bus must not launch an owner for the
	// destination name in response to this message.
	DBusMessageFlagsNoAutoStart DBusMessageFlags = 0b10
	// DBusMessageFlagsAllowInteractiveAuthorization: if set on a method call,
	// this flag means that the caller is prepared to wait for interactive
	// authorization. Since 2.46.
	DBusMessageFlagsAllowInteractiveAuthorization DBusMessageFlags = 0b100
)

func marshalDBusMessageFlags(p uintptr) (interface{}, error) {
	return DBusMessageFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusMessageFlags.
func (d DBusMessageFlags) String() string {
	if d == 0 {
		return "DBusMessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(126)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusMessageFlagsNone:
			builder.WriteString("None|")
		case DBusMessageFlagsNoReplyExpected:
			builder.WriteString("NoReplyExpected|")
		case DBusMessageFlagsNoAutoStart:
			builder.WriteString("NoAutoStart|")
		case DBusMessageFlagsAllowInteractiveAuthorization:
			builder.WriteString("AllowInteractiveAuthorization|")
		default:
			builder.WriteString(fmt.Sprintf("DBusMessageFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusMessageFlags) Has(other DBusMessageFlags) bool {
	return (d & other) == other
}

// DBusObjectManagerClientFlags flags used when constructing a
// BusObjectManagerClient.
type DBusObjectManagerClientFlags C.guint

const (
	// DBusObjectManagerClientFlagsNone: no flags set.
	DBusObjectManagerClientFlagsNone DBusObjectManagerClientFlags = 0b0
	// DBusObjectManagerClientFlagsDoNotAutoStart: if not set and the manager is
	// for a well-known name, then request the bus to launch an owner for the
	// name if no-one owns the name. This flag can only be used in managers for
	// well-known names.
	DBusObjectManagerClientFlagsDoNotAutoStart DBusObjectManagerClientFlags = 0b1
)

func marshalDBusObjectManagerClientFlags(p uintptr) (interface{}, error) {
	return DBusObjectManagerClientFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusObjectManagerClientFlags.
func (d DBusObjectManagerClientFlags) String() string {
	if d == 0 {
		return "DBusObjectManagerClientFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(75)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusObjectManagerClientFlagsNone:
			builder.WriteString("None|")
		case DBusObjectManagerClientFlagsDoNotAutoStart:
			builder.WriteString("DoNotAutoStart|")
		default:
			builder.WriteString(fmt.Sprintf("DBusObjectManagerClientFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusObjectManagerClientFlags) Has(other DBusObjectManagerClientFlags) bool {
	return (d & other) == other
}

// DBusPropertyInfoFlags flags describing the access control of a D-Bus
// property.
type DBusPropertyInfoFlags C.guint

const (
	// DBusPropertyInfoFlagsNone: no flags set.
	DBusPropertyInfoFlagsNone DBusPropertyInfoFlags = 0b0
	// DBusPropertyInfoFlagsReadable: property is readable.
	DBusPropertyInfoFlagsReadable DBusPropertyInfoFlags = 0b1
	// DBusPropertyInfoFlagsWritable: property is writable.
	DBusPropertyInfoFlagsWritable DBusPropertyInfoFlags = 0b10
)

func marshalDBusPropertyInfoFlags(p uintptr) (interface{}, error) {
	return DBusPropertyInfoFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusPropertyInfoFlags.
func (d DBusPropertyInfoFlags) String() string {
	if d == 0 {
		return "DBusPropertyInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(85)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusPropertyInfoFlagsNone:
			builder.WriteString("None|")
		case DBusPropertyInfoFlagsReadable:
			builder.WriteString("Readable|")
		case DBusPropertyInfoFlagsWritable:
			builder.WriteString("Writable|")
		default:
			builder.WriteString(fmt.Sprintf("DBusPropertyInfoFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusPropertyInfoFlags) Has(other DBusPropertyInfoFlags) bool {
	return (d & other) == other
}

// DBusProxyFlags flags used when constructing an instance of a BusProxy derived
// class.
type DBusProxyFlags C.guint

const (
	// DBusProxyFlagsNone: no flags set.
	DBusProxyFlagsNone DBusProxyFlags = 0b0
	// DBusProxyFlagsDoNotLoadProperties: don't load properties.
	DBusProxyFlagsDoNotLoadProperties DBusProxyFlags = 0b1
	// DBusProxyFlagsDoNotConnectSignals: don't connect to signals on the remote
	// object.
	DBusProxyFlagsDoNotConnectSignals DBusProxyFlags = 0b10
	// DBusProxyFlagsDoNotAutoStart: if the proxy is for a well-known name, do
	// not ask the bus to launch an owner during proxy initialization or a
	// method call. This flag is only meaningful in proxies for well-known
	// names.
	DBusProxyFlagsDoNotAutoStart DBusProxyFlags = 0b100
	// DBusProxyFlagsGetInvalidatedProperties: if set, the property value for
	// any __invalidated property__ will be (asynchronously) retrieved upon
	// receiving the PropertiesChanged
	// (http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
	// D-Bus signal and the property will not cause emission of the
	// BusProxy::g-properties-changed signal. When the value is received the
	// BusProxy::g-properties-changed signal is emitted for the property along
	// with the retrieved value. Since 2.32.
	DBusProxyFlagsGetInvalidatedProperties DBusProxyFlags = 0b1000
	// DBusProxyFlagsDoNotAutoStartAtConstruction: if the proxy is for a
	// well-known name, do not ask the bus to launch an owner during proxy
	// initialization, but allow it to be autostarted by a method call. This
	// flag is only meaningful in proxies for well-known names, and only if
	// G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
	DBusProxyFlagsDoNotAutoStartAtConstruction DBusProxyFlags = 0b10000
)

func marshalDBusProxyFlags(p uintptr) (interface{}, error) {
	return DBusProxyFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusProxyFlags.
func (d DBusProxyFlags) String() string {
	if d == 0 {
		return "DBusProxyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(197)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusProxyFlagsNone:
			builder.WriteString("None|")
		case DBusProxyFlagsDoNotLoadProperties:
			builder.WriteString("DoNotLoadProperties|")
		case DBusProxyFlagsDoNotConnectSignals:
			builder.WriteString("DoNotConnectSignals|")
		case DBusProxyFlagsDoNotAutoStart:
			builder.WriteString("DoNotAutoStart|")
		case DBusProxyFlagsGetInvalidatedProperties:
			builder.WriteString("GetInvalidatedProperties|")
		case DBusProxyFlagsDoNotAutoStartAtConstruction:
			builder.WriteString("DoNotAutoStartAtConstruction|")
		default:
			builder.WriteString(fmt.Sprintf("DBusProxyFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusProxyFlags) Has(other DBusProxyFlags) bool {
	return (d & other) == other
}

// DBusSendMessageFlags flags used when sending BusMessages on a BusConnection.
type DBusSendMessageFlags C.guint

const (
	// DBusSendMessageFlagsNone: no flags set.
	DBusSendMessageFlagsNone DBusSendMessageFlags = 0b0
	// DBusSendMessageFlagsPreserveSerial: do not automatically assign a serial
	// number from the BusConnection object when sending a message.
	DBusSendMessageFlagsPreserveSerial DBusSendMessageFlags = 0b1
)

func marshalDBusSendMessageFlags(p uintptr) (interface{}, error) {
	return DBusSendMessageFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSendMessageFlags.
func (d DBusSendMessageFlags) String() string {
	if d == 0 {
		return "DBusSendMessageFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSendMessageFlagsNone:
			builder.WriteString("None|")
		case DBusSendMessageFlagsPreserveSerial:
			builder.WriteString("PreserveSerial|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSendMessageFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSendMessageFlags) Has(other DBusSendMessageFlags) bool {
	return (d & other) == other
}

// DBusServerFlags flags used when creating a BusServer.
type DBusServerFlags C.guint

const (
	// DBusServerFlagsNone: no flags set.
	DBusServerFlagsNone DBusServerFlags = 0b0
	// DBusServerFlagsRunInThread: all BusServer::new-connection signals will
	// run in separated dedicated threads (see signal for details).
	DBusServerFlagsRunInThread DBusServerFlags = 0b1
	// DBusServerFlagsAuthenticationAllowAnonymous: allow the anonymous
	// authentication method.
	DBusServerFlagsAuthenticationAllowAnonymous DBusServerFlags = 0b10
	// DBusServerFlagsAuthenticationRequireSameUser: require the UID of the peer
	// to be the same as the UID of the server when authenticating. (Since:
	// 2.68).
	DBusServerFlagsAuthenticationRequireSameUser DBusServerFlags = 0b100
)

func marshalDBusServerFlags(p uintptr) (interface{}, error) {
	return DBusServerFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusServerFlags.
func (d DBusServerFlags) String() string {
	if d == 0 {
		return "DBusServerFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(135)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusServerFlagsNone:
			builder.WriteString("None|")
		case DBusServerFlagsRunInThread:
			builder.WriteString("RunInThread|")
		case DBusServerFlagsAuthenticationAllowAnonymous:
			builder.WriteString("AuthenticationAllowAnonymous|")
		case DBusServerFlagsAuthenticationRequireSameUser:
			builder.WriteString("AuthenticationRequireSameUser|")
		default:
			builder.WriteString(fmt.Sprintf("DBusServerFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusServerFlags) Has(other DBusServerFlags) bool {
	return (d & other) == other
}

// DBusSignalFlags flags used when subscribing to signals via
// g_dbus_connection_signal_subscribe().
type DBusSignalFlags C.guint

const (
	// DBusSignalFlagsNone: no flags set.
	DBusSignalFlagsNone DBusSignalFlags = 0b0
	// DBusSignalFlagsNoMatchRule: don't actually send the AddMatch D-Bus call
	// for this signal subscription. This gives you more control over which
	// match rules you add (but you must add them manually).
	DBusSignalFlagsNoMatchRule DBusSignalFlags = 0b1
	// DBusSignalFlagsMatchArg0Namespace: match first arguments that contain a
	// bus or interface name with the given namespace.
	DBusSignalFlagsMatchArg0Namespace DBusSignalFlags = 0b10
	// DBusSignalFlagsMatchArg0Path: match first arguments that contain an
	// object path that is either equivalent to the given path, or one of the
	// paths is a subpath of the other.
	DBusSignalFlagsMatchArg0Path DBusSignalFlags = 0b100
)

func marshalDBusSignalFlags(p uintptr) (interface{}, error) {
	return DBusSignalFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSignalFlags.
func (d DBusSignalFlags) String() string {
	if d == 0 {
		return "DBusSignalFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(109)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSignalFlagsNone:
			builder.WriteString("None|")
		case DBusSignalFlagsNoMatchRule:
			builder.WriteString("NoMatchRule|")
		case DBusSignalFlagsMatchArg0Namespace:
			builder.WriteString("MatchArg0Namespace|")
		case DBusSignalFlagsMatchArg0Path:
			builder.WriteString("MatchArg0Path|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSignalFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSignalFlags) Has(other DBusSignalFlags) bool {
	return (d & other) == other
}

// DBusSubtreeFlags flags passed to g_dbus_connection_register_subtree().
type DBusSubtreeFlags C.guint

const (
	// DBusSubtreeFlagsNone: no flags set.
	DBusSubtreeFlagsNone DBusSubtreeFlags = 0b0
	// DBusSubtreeFlagsDispatchToUnenumeratedNodes: method calls to objects not
	// in the enumerated range will still be dispatched. This is useful if you
	// want to dynamically spawn objects in the subtree.
	DBusSubtreeFlagsDispatchToUnenumeratedNodes DBusSubtreeFlags = 0b1
)

func marshalDBusSubtreeFlags(p uintptr) (interface{}, error) {
	return DBusSubtreeFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DBusSubtreeFlags.
func (d DBusSubtreeFlags) String() string {
	if d == 0 {
		return "DBusSubtreeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(64)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DBusSubtreeFlagsNone:
			builder.WriteString("None|")
		case DBusSubtreeFlagsDispatchToUnenumeratedNodes:
			builder.WriteString("DispatchToUnenumeratedNodes|")
		default:
			builder.WriteString(fmt.Sprintf("DBusSubtreeFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DBusSubtreeFlags) Has(other DBusSubtreeFlags) bool {
	return (d & other) == other
}

// DriveStartFlags flags used when starting a drive.
type DriveStartFlags C.guint

const (
	// DriveStartNone: no flags set.
	DriveStartNone DriveStartFlags = 0b0
)

func marshalDriveStartFlags(p uintptr) (interface{}, error) {
	return DriveStartFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DriveStartFlags.
func (d DriveStartFlags) String() string {
	if d == 0 {
		return "DriveStartFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(14)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DriveStartNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("DriveStartFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DriveStartFlags) Has(other DriveStartFlags) bool {
	return (d & other) == other
}

// FileAttributeInfoFlags flags specifying the behaviour of an attribute.
type FileAttributeInfoFlags C.guint

const (
	// FileAttributeInfoNone: no flags set.
	FileAttributeInfoNone FileAttributeInfoFlags = 0b0
	// FileAttributeInfoCopyWithFile: copy the attribute values when the file is
	// copied.
	FileAttributeInfoCopyWithFile FileAttributeInfoFlags = 0b1
	// FileAttributeInfoCopyWhenMoved: copy the attribute values when the file
	// is moved.
	FileAttributeInfoCopyWhenMoved FileAttributeInfoFlags = 0b10
)

func marshalFileAttributeInfoFlags(p uintptr) (interface{}, error) {
	return FileAttributeInfoFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileAttributeInfoFlags.
func (f FileAttributeInfoFlags) String() string {
	if f == 0 {
		return "FileAttributeInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileAttributeInfoNone:
			builder.WriteString("None|")
		case FileAttributeInfoCopyWithFile:
			builder.WriteString("CopyWithFile|")
		case FileAttributeInfoCopyWhenMoved:
			builder.WriteString("CopyWhenMoved|")
		default:
			builder.WriteString(fmt.Sprintf("FileAttributeInfoFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileAttributeInfoFlags) Has(other FileAttributeInfoFlags) bool {
	return (f & other) == other
}

// FileCopyFlags flags used when copying or moving files.
type FileCopyFlags C.guint

const (
	// FileCopyNone: no flags set.
	FileCopyNone FileCopyFlags = 0b0
	// FileCopyOverwrite: overwrite any existing files.
	FileCopyOverwrite FileCopyFlags = 0b1
	// FileCopyBackup: make a backup of any existing files.
	FileCopyBackup FileCopyFlags = 0b10
	// FileCopyNofollowSymlinks: don't follow symlinks.
	FileCopyNofollowSymlinks FileCopyFlags = 0b100
	// FileCopyAllMetadata: copy all file metadata instead of just default set
	// used for copy (see Info).
	FileCopyAllMetadata FileCopyFlags = 0b1000
	// FileCopyNoFallbackForMove: don't use copy and delete fallback if native
	// move not supported.
	FileCopyNoFallbackForMove FileCopyFlags = 0b10000
	// FileCopyTargetDefaultPerms leaves target file with default perms, instead
	// of setting the source file perms.
	FileCopyTargetDefaultPerms FileCopyFlags = 0b100000
)

func marshalFileCopyFlags(p uintptr) (interface{}, error) {
	return FileCopyFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileCopyFlags.
func (f FileCopyFlags) String() string {
	if f == 0 {
		return "FileCopyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(143)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileCopyNone:
			builder.WriteString("None|")
		case FileCopyOverwrite:
			builder.WriteString("Overwrite|")
		case FileCopyBackup:
			builder.WriteString("Backup|")
		case FileCopyNofollowSymlinks:
			builder.WriteString("NofollowSymlinks|")
		case FileCopyAllMetadata:
			builder.WriteString("AllMetadata|")
		case FileCopyNoFallbackForMove:
			builder.WriteString("NoFallbackForMove|")
		case FileCopyTargetDefaultPerms:
			builder.WriteString("TargetDefaultPerms|")
		default:
			builder.WriteString(fmt.Sprintf("FileCopyFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileCopyFlags) Has(other FileCopyFlags) bool {
	return (f & other) == other
}

// FileCreateFlags flags used when an operation may create a file.
type FileCreateFlags C.guint

const (
	// FileCreateNone: no flags set.
	FileCreateNone FileCreateFlags = 0b0
	// FileCreatePrivate: create a file that can only be accessed by the current
	// user.
	FileCreatePrivate FileCreateFlags = 0b1
	// FileCreateReplaceDestination: replace the destination as if it didn't
	// exist before. Don't try to keep any old permissions, replace instead of
	// following links. This is generally useful if you're doing a "copy over"
	// rather than a "save new version of" replace operation. You can think of
	// it as "unlink destination" before writing to it, although the
	// implementation may not be exactly like that. This flag can only be used
	// with g_file_replace() and its variants, including
	// g_file_replace_contents(). Since 2.20.
	FileCreateReplaceDestination FileCreateFlags = 0b10
)

func marshalFileCreateFlags(p uintptr) (interface{}, error) {
	return FileCreateFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileCreateFlags.
func (f FileCreateFlags) String() string {
	if f == 0 {
		return "FileCreateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(61)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileCreateNone:
			builder.WriteString("None|")
		case FileCreatePrivate:
			builder.WriteString("Private|")
		case FileCreateReplaceDestination:
			builder.WriteString("ReplaceDestination|")
		default:
			builder.WriteString(fmt.Sprintf("FileCreateFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileCreateFlags) Has(other FileCreateFlags) bool {
	return (f & other) == other
}

// FileMeasureFlags flags that can be used with g_file_measure_disk_usage().
type FileMeasureFlags C.guint

const (
	// FileMeasureNone: no flags set.
	FileMeasureNone FileMeasureFlags = 0b0
	// FileMeasureReportAnyError: report any error encountered while traversing
	// the directory tree. Normally errors are only reported for the toplevel
	// file.
	FileMeasureReportAnyError FileMeasureFlags = 0b10
	// FileMeasureApparentSize: tally usage based on apparent file sizes.
	// Normally, the block-size is used, if available, as this is a more
	// accurate representation of disk space used. Compare with du
	// --apparent-size.
	FileMeasureApparentSize FileMeasureFlags = 0b100
	// FileMeasureNoXdev: do not cross mount point boundaries. Compare with du
	// -x.
	FileMeasureNoXdev FileMeasureFlags = 0b1000
)

func marshalFileMeasureFlags(p uintptr) (interface{}, error) {
	return FileMeasureFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileMeasureFlags.
func (f FileMeasureFlags) String() string {
	if f == 0 {
		return "FileMeasureFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(83)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileMeasureNone:
			builder.WriteString("None|")
		case FileMeasureReportAnyError:
			builder.WriteString("ReportAnyError|")
		case FileMeasureApparentSize:
			builder.WriteString("ApparentSize|")
		case FileMeasureNoXdev:
			builder.WriteString("NoXdev|")
		default:
			builder.WriteString(fmt.Sprintf("FileMeasureFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileMeasureFlags) Has(other FileMeasureFlags) bool {
	return (f & other) == other
}

// FileMonitorFlags flags used to set what a Monitor will watch for.
type FileMonitorFlags C.guint

const (
	// FileMonitorNone: no flags set.
	FileMonitorNone FileMonitorFlags = 0b0
	// FileMonitorWatchMounts: watch for mount events.
	FileMonitorWatchMounts FileMonitorFlags = 0b1
	// FileMonitorSendMoved: pair DELETED and CREATED events caused by file
	// renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED event
	// instead (NB: not supported on all backends; the default behaviour
	// -without specifying this flag- is to send single DELETED and CREATED
	// events). Deprecated since 2.46: use G_FILE_MONITOR_WATCH_MOVES instead.
	FileMonitorSendMoved FileMonitorFlags = 0b10
	// FileMonitorWatchHardLinks: watch for changes to the file made via another
	// hard link. Since 2.36.
	FileMonitorWatchHardLinks FileMonitorFlags = 0b100
	// FileMonitorWatchMoves: watch for rename operations on a monitored
	// directory. This causes G_FILE_MONITOR_EVENT_RENAMED,
	// G_FILE_MONITOR_EVENT_MOVED_IN and G_FILE_MONITOR_EVENT_MOVED_OUT events
	// to be emitted when possible. Since: 2.46.
	FileMonitorWatchMoves FileMonitorFlags = 0b1000
)

func marshalFileMonitorFlags(p uintptr) (interface{}, error) {
	return FileMonitorFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileMonitorFlags.
func (f FileMonitorFlags) String() string {
	if f == 0 {
		return "FileMonitorFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(107)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileMonitorNone:
			builder.WriteString("None|")
		case FileMonitorWatchMounts:
			builder.WriteString("WatchMounts|")
		case FileMonitorSendMoved:
			builder.WriteString("SendMoved|")
		case FileMonitorWatchHardLinks:
			builder.WriteString("WatchHardLinks|")
		case FileMonitorWatchMoves:
			builder.WriteString("WatchMoves|")
		default:
			builder.WriteString(fmt.Sprintf("FileMonitorFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileMonitorFlags) Has(other FileMonitorFlags) bool {
	return (f & other) == other
}

// FileQueryInfoFlags flags used when querying a Info.
type FileQueryInfoFlags C.guint

const (
	// FileQueryInfoNone: no flags set.
	FileQueryInfoNone FileQueryInfoFlags = 0b0
	// FileQueryInfoNofollowSymlinks: don't follow symlinks.
	FileQueryInfoNofollowSymlinks FileQueryInfoFlags = 0b1
)

func marshalFileQueryInfoFlags(p uintptr) (interface{}, error) {
	return FileQueryInfoFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FileQueryInfoFlags.
func (f FileQueryInfoFlags) String() string {
	if f == 0 {
		return "FileQueryInfoFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(47)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileQueryInfoNone:
			builder.WriteString("None|")
		case FileQueryInfoNofollowSymlinks:
			builder.WriteString("NofollowSymlinks|")
		default:
			builder.WriteString(fmt.Sprintf("FileQueryInfoFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileQueryInfoFlags) Has(other FileQueryInfoFlags) bool {
	return (f & other) == other
}

// IOStreamSpliceFlags determine how streams should be spliced.
type IOStreamSpliceFlags C.guint

const (
	// IOStreamSpliceNone: do not close either stream.
	IOStreamSpliceNone IOStreamSpliceFlags = 0b0
	// IOStreamSpliceCloseStream1: close the first stream after the splice.
	IOStreamSpliceCloseStream1 IOStreamSpliceFlags = 0b1
	// IOStreamSpliceCloseStream2: close the second stream after the splice.
	IOStreamSpliceCloseStream2 IOStreamSpliceFlags = 0b10
	// IOStreamSpliceWaitForBoth: wait for both splice operations to finish
	// before calling the callback.
	IOStreamSpliceWaitForBoth IOStreamSpliceFlags = 0b100
)

func marshalIOStreamSpliceFlags(p uintptr) (interface{}, error) {
	return IOStreamSpliceFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for IOStreamSpliceFlags.
func (i IOStreamSpliceFlags) String() string {
	if i == 0 {
		return "IOStreamSpliceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(98)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case IOStreamSpliceNone:
			builder.WriteString("None|")
		case IOStreamSpliceCloseStream1:
			builder.WriteString("CloseStream1|")
		case IOStreamSpliceCloseStream2:
			builder.WriteString("CloseStream2|")
		case IOStreamSpliceWaitForBoth:
			builder.WriteString("WaitForBoth|")
		default:
			builder.WriteString(fmt.Sprintf("IOStreamSpliceFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i IOStreamSpliceFlags) Has(other IOStreamSpliceFlags) bool {
	return (i & other) == other
}

// MountMountFlags flags used when mounting a mount.
type MountMountFlags C.guint

const (
	// MountMountNone: no flags set.
	MountMountNone MountMountFlags = 0b0
)

func marshalMountMountFlags(p uintptr) (interface{}, error) {
	return MountMountFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MountMountFlags.
func (m MountMountFlags) String() string {
	if m == 0 {
		return "MountMountFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(14)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MountMountNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("MountMountFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MountMountFlags) Has(other MountMountFlags) bool {
	return (m & other) == other
}

// MountUnmountFlags flags used when an unmounting a mount.
type MountUnmountFlags C.guint

const (
	// MountUnmountNone: no flags set.
	MountUnmountNone MountUnmountFlags = 0b0
	// MountUnmountForce: unmount even if there are outstanding file operations
	// on the mount.
	MountUnmountForce MountUnmountFlags = 0b1
)

func marshalMountUnmountFlags(p uintptr) (interface{}, error) {
	return MountUnmountFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for MountUnmountFlags.
func (m MountUnmountFlags) String() string {
	if m == 0 {
		return "MountUnmountFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(34)

	for m != 0 {
		next := m & (m - 1)
		bit := m - next

		switch bit {
		case MountUnmountNone:
			builder.WriteString("None|")
		case MountUnmountForce:
			builder.WriteString("Force|")
		default:
			builder.WriteString(fmt.Sprintf("MountUnmountFlags(0b%b)|", bit))
		}

		m = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if m contains other.
func (m MountUnmountFlags) Has(other MountUnmountFlags) bool {
	return (m & other) == other
}

// OutputStreamSpliceFlags determine how streams should be spliced.
type OutputStreamSpliceFlags C.guint

const (
	// OutputStreamSpliceNone: do not close either stream.
	OutputStreamSpliceNone OutputStreamSpliceFlags = 0b0
	// OutputStreamSpliceCloseSource: close the source stream after the splice.
	OutputStreamSpliceCloseSource OutputStreamSpliceFlags = 0b1
	// OutputStreamSpliceCloseTarget: close the target stream after the splice.
	OutputStreamSpliceCloseTarget OutputStreamSpliceFlags = 0b10
)

func marshalOutputStreamSpliceFlags(p uintptr) (interface{}, error) {
	return OutputStreamSpliceFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for OutputStreamSpliceFlags.
func (o OutputStreamSpliceFlags) String() string {
	if o == 0 {
		return "OutputStreamSpliceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for o != 0 {
		next := o & (o - 1)
		bit := o - next

		switch bit {
		case OutputStreamSpliceNone:
			builder.WriteString("None|")
		case OutputStreamSpliceCloseSource:
			builder.WriteString("CloseSource|")
		case OutputStreamSpliceCloseTarget:
			builder.WriteString("CloseTarget|")
		default:
			builder.WriteString(fmt.Sprintf("OutputStreamSpliceFlags(0b%b)|", bit))
		}

		o = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if o contains other.
func (o OutputStreamSpliceFlags) Has(other OutputStreamSpliceFlags) bool {
	return (o & other) == other
}

// ResourceFlags give information about a particular file inside a resource
// bundle.
type ResourceFlags C.guint

const (
	// ResourceFlagsNone: no flags set.
	ResourceFlagsNone ResourceFlags = 0b0
	// ResourceFlagsCompressed: file is compressed.
	ResourceFlagsCompressed ResourceFlags = 0b1
)

func marshalResourceFlags(p uintptr) (interface{}, error) {
	return ResourceFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResourceFlags.
func (r ResourceFlags) String() string {
	if r == 0 {
		return "ResourceFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(41)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResourceFlagsNone:
			builder.WriteString("None|")
		case ResourceFlagsCompressed:
			builder.WriteString("Compressed|")
		default:
			builder.WriteString(fmt.Sprintf("ResourceFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResourceFlags) Has(other ResourceFlags) bool {
	return (r & other) == other
}

// ResourceLookupFlags determine how resource path lookups are handled.
type ResourceLookupFlags C.guint

const (
	// ResourceLookupFlagsNone: no flags set.
	ResourceLookupFlagsNone ResourceLookupFlags = 0b0
)

func marshalResourceLookupFlags(p uintptr) (interface{}, error) {
	return ResourceLookupFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResourceLookupFlags.
func (r ResourceLookupFlags) String() string {
	if r == 0 {
		return "ResourceLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(23)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResourceLookupFlagsNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("ResourceLookupFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResourceLookupFlags) Has(other ResourceLookupFlags) bool {
	return (r & other) == other
}

// SocketMsgFlags flags used in g_socket_receive_message() and
// g_socket_send_message(). The flags listed in the enum are some commonly
// available flags, but the values used for them are the same as on the
// platform, and any other flags are passed in/out as is. So to use a platform
// specific flag, just include the right system header and pass in the flag.
type SocketMsgFlags C.guint

const (
	// SocketMsgNone: no flags.
	SocketMsgNone SocketMsgFlags = 0b0
	// SocketMsgOob: request to send/receive out of band data.
	SocketMsgOob SocketMsgFlags = 0b1
	// SocketMsgPeek: read data from the socket without removing it from the
	// queue.
	SocketMsgPeek SocketMsgFlags = 0b10
	// SocketMsgDontroute: don't use a gateway to send out the packet, only send
	// to hosts on directly connected networks.
	SocketMsgDontroute SocketMsgFlags = 0b100
)

func marshalSocketMsgFlags(p uintptr) (interface{}, error) {
	return SocketMsgFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SocketMsgFlags.
func (s SocketMsgFlags) String() string {
	if s == 0 {
		return "SocketMsgFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(59)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SocketMsgNone:
			builder.WriteString("None|")
		case SocketMsgOob:
			builder.WriteString("Oob|")
		case SocketMsgPeek:
			builder.WriteString("Peek|")
		case SocketMsgDontroute:
			builder.WriteString("Dontroute|")
		default:
			builder.WriteString(fmt.Sprintf("SocketMsgFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SocketMsgFlags) Has(other SocketMsgFlags) bool {
	return (s & other) == other
}

// SubprocessFlags flags to define the behaviour of a #GSubprocess.
//
// Note that the default for stdin is to redirect from /dev/null. For stdout and
// stderr the default are for them to inherit the corresponding descriptor from
// the calling process.
//
// Note that it is a programmer error to mix 'incompatible' flags. For example,
// you may not request both G_SUBPROCESS_FLAGS_STDOUT_PIPE and
// G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
type SubprocessFlags C.guint

const (
	// SubprocessFlagsNone: no flags.
	SubprocessFlagsNone SubprocessFlags = 0b0
	// SubprocessFlagsStdinPipe: create a pipe for the stdin of the spawned
	// process that can be accessed with g_subprocess_get_stdin_pipe().
	SubprocessFlagsStdinPipe SubprocessFlags = 0b1
	// SubprocessFlagsStdinInherit: stdin is inherited from the calling process.
	SubprocessFlagsStdinInherit SubprocessFlags = 0b10
	// SubprocessFlagsStdoutPipe: create a pipe for the stdout of the spawned
	// process that can be accessed with g_subprocess_get_stdout_pipe().
	SubprocessFlagsStdoutPipe SubprocessFlags = 0b100
	// SubprocessFlagsStdoutSilence: silence the stdout of the spawned process
	// (ie: redirect to /dev/null).
	SubprocessFlagsStdoutSilence SubprocessFlags = 0b1000
	// SubprocessFlagsStderrPipe: create a pipe for the stderr of the spawned
	// process that can be accessed with g_subprocess_get_stderr_pipe().
	SubprocessFlagsStderrPipe SubprocessFlags = 0b10000
	// SubprocessFlagsStderrSilence: silence the stderr of the spawned process
	// (ie: redirect to /dev/null).
	SubprocessFlagsStderrSilence SubprocessFlags = 0b100000
	// SubprocessFlagsStderrMerge: merge the stderr of the spawned process with
	// whatever the stdout happens to be. This is a good way of directing both
	// streams to a common log file, for example.
	SubprocessFlagsStderrMerge SubprocessFlags = 0b1000000
	// SubprocessFlagsInheritFds: spawned processes will inherit the file
	// descriptors of their parent, unless those descriptors have been
	// explicitly marked as close-on-exec. This flag has no effect over the
	// "standard" file descriptors (stdin, stdout, stderr).
	SubprocessFlagsInheritFds SubprocessFlags = 0b10000000
)

func marshalSubprocessFlags(p uintptr) (interface{}, error) {
	return SubprocessFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SubprocessFlags.
func (s SubprocessFlags) String() string {
	if s == 0 {
		return "SubprocessFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(235)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SubprocessFlagsNone:
			builder.WriteString("None|")
		case SubprocessFlagsStdinPipe:
			builder.WriteString("StdinPipe|")
		case SubprocessFlagsStdinInherit:
			builder.WriteString("StdinInherit|")
		case SubprocessFlagsStdoutPipe:
			builder.WriteString("StdoutPipe|")
		case SubprocessFlagsStdoutSilence:
			builder.WriteString("StdoutSilence|")
		case SubprocessFlagsStderrPipe:
			builder.WriteString("StderrPipe|")
		case SubprocessFlagsStderrSilence:
			builder.WriteString("StderrSilence|")
		case SubprocessFlagsStderrMerge:
			builder.WriteString("StderrMerge|")
		case SubprocessFlagsInheritFds:
			builder.WriteString("InheritFds|")
		default:
			builder.WriteString(fmt.Sprintf("SubprocessFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SubprocessFlags) Has(other SubprocessFlags) bool {
	return (s & other) == other
}

// TestDBusFlags flags to define future DBus behaviour.
type TestDBusFlags C.guint

const (
	// TestDBusNone: no flags.
	TestDBusNone TestDBusFlags = 0b0
)

func marshalTestDBusFlags(p uintptr) (interface{}, error) {
	return TestDBusFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TestDBusFlags.
func (t TestDBusFlags) String() string {
	if t == 0 {
		return "TestDBusFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(12)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TestDBusNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("TestDBusFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TestDBusFlags) Has(other TestDBusFlags) bool {
	return (t & other) == other
}

// TLSCertificateFlags: set of flags describing TLS certification validation.
// This can be used to set which validation steps to perform (eg, with
// g_tls_client_connection_set_validation_flags()), or to describe why a
// particular certificate was rejected (eg, in Connection::accept-certificate).
type TLSCertificateFlags C.guint

const (
	// TLSCertificateUnknownCa: signing certificate authority is not known.
	TLSCertificateUnknownCa TLSCertificateFlags = 0b1
	// TLSCertificateBadIdentity: certificate does not match the expected
	// identity of the site that it was retrieved from.
	TLSCertificateBadIdentity TLSCertificateFlags = 0b10
	// TLSCertificateNotActivated certificate's activation time is still in the
	// future.
	TLSCertificateNotActivated TLSCertificateFlags = 0b100
	// TLSCertificateExpired: certificate has expired.
	TLSCertificateExpired TLSCertificateFlags = 0b1000
	// TLSCertificateRevoked: certificate has been revoked according to the
	// Connection's certificate revocation list.
	TLSCertificateRevoked TLSCertificateFlags = 0b10000
	// TLSCertificateInsecure certificate's algorithm is considered insecure.
	TLSCertificateInsecure TLSCertificateFlags = 0b100000
	// TLSCertificateGenericError: some other error occurred validating the
	// certificate.
	TLSCertificateGenericError TLSCertificateFlags = 0b1000000
	// TLSCertificateValidateAll: combination of all of the above flags.
	TLSCertificateValidateAll TLSCertificateFlags = 0b1111111
)

func marshalTLSCertificateFlags(p uintptr) (interface{}, error) {
	return TLSCertificateFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSCertificateFlags.
func (t TLSCertificateFlags) String() string {
	if t == 0 {
		return "TLSCertificateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(196)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSCertificateUnknownCa:
			builder.WriteString("UnknownCa|")
		case TLSCertificateBadIdentity:
			builder.WriteString("BadIdentity|")
		case TLSCertificateNotActivated:
			builder.WriteString("NotActivated|")
		case TLSCertificateExpired:
			builder.WriteString("Expired|")
		case TLSCertificateRevoked:
			builder.WriteString("Revoked|")
		case TLSCertificateInsecure:
			builder.WriteString("Insecure|")
		case TLSCertificateGenericError:
			builder.WriteString("GenericError|")
		case TLSCertificateValidateAll:
			builder.WriteString("ValidateAll|")
		default:
			builder.WriteString(fmt.Sprintf("TLSCertificateFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSCertificateFlags) Has(other TLSCertificateFlags) bool {
	return (t & other) == other
}

// TLSDatabaseVerifyFlags flags for g_tls_database_verify_chain().
type TLSDatabaseVerifyFlags C.guint

const (
	// TLSDatabaseVerifyNone: no verification flags.
	TLSDatabaseVerifyNone TLSDatabaseVerifyFlags = 0b0
)

func marshalTLSDatabaseVerifyFlags(p uintptr) (interface{}, error) {
	return TLSDatabaseVerifyFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSDatabaseVerifyFlags.
func (t TLSDatabaseVerifyFlags) String() string {
	if t == 0 {
		return "TLSDatabaseVerifyFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(21)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSDatabaseVerifyNone:
			builder.WriteString("None|")
		default:
			builder.WriteString(fmt.Sprintf("TLSDatabaseVerifyFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSDatabaseVerifyFlags) Has(other TLSDatabaseVerifyFlags) bool {
	return (t & other) == other
}

// TLSPasswordFlags various flags for the password.
type TLSPasswordFlags C.guint

const (
	// TLSPasswordNone: no flags.
	TLSPasswordNone TLSPasswordFlags = 0b0
	// TLSPasswordRetry: password was wrong, and the user should retry.
	TLSPasswordRetry TLSPasswordFlags = 0b10
	// TLSPasswordManyTries: hint to the user that the password has been wrong
	// many times, and the user may not have many chances left.
	TLSPasswordManyTries TLSPasswordFlags = 0b100
	// TLSPasswordFinalTry: hint to the user that this is the last try to get
	// this password right.
	TLSPasswordFinalTry TLSPasswordFlags = 0b1000
)

func marshalTLSPasswordFlags(p uintptr) (interface{}, error) {
	return TLSPasswordFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TLSPasswordFlags.
func (t TLSPasswordFlags) String() string {
	if t == 0 {
		return "TLSPasswordFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(73)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TLSPasswordNone:
			builder.WriteString("None|")
		case TLSPasswordRetry:
			builder.WriteString("Retry|")
		case TLSPasswordManyTries:
			builder.WriteString("ManyTries|")
		case TLSPasswordFinalTry:
			builder.WriteString("FinalTry|")
		default:
			builder.WriteString(fmt.Sprintf("TLSPasswordFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TLSPasswordFlags) Has(other TLSPasswordFlags) bool {
	return (t & other) == other
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// ChannelBindingData: query the TLS backend for TLS channel binding data of
// type for conn.
//
// This call retrieves TLS channel binding data as specified in RFC 5056
// (https://tools.ietf.org/html/rfc5056), RFC 5929
// (https://tools.ietf.org/html/rfc5929), and related RFCs. The binding data is
// returned in data. The data is resized by the callee using Array buffer
// management and will be freed when the data is destroyed by
// g_byte_array_unref(). If data is NULL, it will only check whether TLS backend
// is able to fetch the data (e.g. whether type is supported by the TLS
// backend). It does not guarantee that the data will be available though. That
// could happen if TLS connection does not support type or the binding data is
// not available yet due to additional negotiation or input required.
//
// The function takes the following parameters:
//
//    - typ type of data to fetch.
//
// The function returns the following values:
//
//    - data (optional) is filled with the binding data, or NULL.
//
func (conn *TLSConnection) ChannelBindingData(typ TLSChannelBindingType) ([]byte, error) {
	var _arg0 *C.GTlsConnection        // out
	var _arg1 C.GTlsChannelBindingType // out
	var _arg2 C.GByteArray             // in
	var _cerr *C.GError                // in

	_arg0 = (*C.GTlsConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = C.GTlsChannelBindingType(typ)

	C.g_tls_connection_get_channel_binding_data(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(typ)

	var _data []byte // out
	var _goerr error // out

	_data = make([]byte, _arg2.len)
	copy(_data, unsafe.Slice((*byte)(_arg2.data), _arg2.len))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _data, _goerr
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"fmt"
	"reflect"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_Settings_ConnectWritableChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_Settings_ConnectChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_SettingsClass_writable_changed(GSettings*, gchar*);
// extern void _gotk4_gio2_SettingsClass_changed(GSettings*, gchar*);
// extern gboolean _gotk4_gio2_Settings_ConnectWritableChangeEvent(gpointer, guint, guintptr);
// extern gboolean _gotk4_gio2_Settings_ConnectChangeEvent(gpointer, gpointer, gint, guintptr);
// extern gboolean _gotk4_gio2_SettingsGetMapping(GVariant*, gpointer*, gpointer);
// extern gboolean _gotk4_gio2_SettingsClass_writable_change_event(GSettings*, GQuark);
// extern gboolean _gotk4_gio2_SettingsClass_change_event(GSettings*, GQuark*, gint);
// gboolean _gotk4_gio2_Settings_virtual_change_event(void* fnptr, GSettings* arg0, GQuark* arg1, gint arg2) {
//   return ((gboolean (*)(GSettings*, GQuark*, gint))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_Settings_virtual_writable_change_event(void* fnptr, GSettings* arg0, GQuark arg1) {
//   return ((gboolean (*)(GSettings*, GQuark))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Settings_virtual_changed(void* fnptr, GSettings* arg0, gchar* arg1) {
//   ((void (*)(GSettings*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Settings_virtual_writable_changed(void* fnptr, GSettings* arg0, gchar* arg1) {
//   ((void (*)(GSettings*, gchar*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeSettingsBindFlags = coreglib.Type(C.g_settings_bind_flags_get_type())
	GTypeSettings          = coreglib.Type(C.g_settings_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSettingsBindFlags, F: marshalSettingsBindFlags},
		coreglib.TypeMarshaler{T: GTypeSettings, F: marshalSettings},
	})
}

// SettingsBindFlags flags used when creating a binding. These flags determine
// in which direction the binding works. The default is to synchronize in both
// directions.
type SettingsBindFlags C.guint

const (
	// SettingsBindDefault: equivalent to
	// G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET.
	SettingsBindDefault SettingsBindFlags = 0b0
	// SettingsBindGet: update the #GObject property when the setting changes.
	// It is an error to use this flag if the property is not writable.
	SettingsBindGet SettingsBindFlags = 0b1
	// SettingsBindSet: update the setting when the #GObject property changes.
	// It is an error to use this flag if the property is not readable.
	SettingsBindSet SettingsBindFlags = 0b10
	// SettingsBindNoSensitivity: do not try to bind a "sensitivity" property to
	// the writability of the setting.
	SettingsBindNoSensitivity SettingsBindFlags = 0b100
	// SettingsBindGetNoChanges: when set in addition to SETTINGS_BIND_GET, set
	// the #GObject property value initially from the setting, but do not listen
	// for changes of the setting.
	SettingsBindGetNoChanges SettingsBindFlags = 0b1000
	// SettingsBindInvertBoolean: when passed to g_settings_bind(), uses a pair
	// of mapping functions that invert the boolean value when mapping between
	// the setting and the property. The setting and property must both be
	// booleans. You cannot pass this flag to g_settings_bind_with_mapping().
	SettingsBindInvertBoolean SettingsBindFlags = 0b10000
)

func marshalSettingsBindFlags(p uintptr) (interface{}, error) {
	return SettingsBindFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for SettingsBindFlags.
func (s SettingsBindFlags) String() string {
	if s == 0 {
		return "SettingsBindFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(128)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case SettingsBindDefault:
			builder.WriteString("Default|")
		case SettingsBindGet:
			builder.WriteString("Get|")
		case SettingsBindSet:
			builder.WriteString("Set|")
		case SettingsBindNoSensitivity:
			builder.WriteString("NoSensitivity|")
		case SettingsBindGetNoChanges:
			builder.WriteString("GetNoChanges|")
		case SettingsBindInvertBoolean:
			builder.WriteString("InvertBoolean|")
		default:
			builder.WriteString(fmt.Sprintf("SettingsBindFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s SettingsBindFlags) Has(other SettingsBindFlags) bool {
	return (s & other) == other
}

// SettingsBindGetMapping: type for the function that is used to convert from
// #GSettings to an object property. The value is already initialized to hold
// values of the appropriate type.
type SettingsBindGetMapping func(value *coreglib.Value, variant *glib.Variant) (ok bool)

// SettingsBindSetMapping: type for the function that is used to convert an
// object property value to a #GVariant for storing it in #GSettings.
type SettingsBindSetMapping func(value *coreglib.Value, expectedType *glib.VariantType) (variant *glib.Variant)

// SettingsGetMapping: type of the function that is used to convert from a value
// stored in a #GSettings to a value that is useful to the application.
//
// If the value is successfully mapped, the result should be stored at result
// and TRUE returned. If mapping fails (for example, if value is not in the
// right format) then FALSE should be returned.
//
// If value is NULL then it means that the mapping function is being given a
// "last chance" to successfully return a valid value. TRUE must be returned in
// this case.
type SettingsGetMapping func(value *glib.Variant) (result unsafe.Pointer, ok bool)

// SettingsOverrides contains methods that are overridable.
type SettingsOverrides struct {
	// The function takes the following parameters:
	//
	//    - keys
	//    - nKeys
	//
	// The function returns the following values:
	//
	ChangeEvent func(keys *glib.Quark, nKeys int) bool
	// The function takes the following parameters:
	//
	Changed func(key string)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	WritableChangeEvent func(key glib.Quark) bool
	// The function takes the following parameters:
	//
	WritableChanged func(key string)
}

func defaultSettingsOverrides(v *Settings) SettingsOverrides {
	return SettingsOverrides{
		ChangeEvent:         v.changeEvent,
		Changed:             v.changed,
		WritableChangeEvent: v.writableChangeEvent,
		WritableChanged:     v.writableChanged,
	}
}

// Settings class provides a convenient API for storing and retrieving
// application settings.
//
// Reads and writes can be considered to be non-blocking. Reading settings with
// #GSettings is typically extremely fast: on approximately the same order of
// magnitude (but slower than) a Table lookup. Writing settings is also
// extremely fast in terms of time to return to your application, but can be
// extremely expensive for other threads and other processes. Many settings
// backends (including dconf) have lazy initialisation which means in the common
// case of the user using their computer without modifying any settings a lot of
// work can be avoided. For dconf, the D-Bus service doesn't even need to be
// started in this case. For this reason, you should only ever modify #GSettings
// keys in response to explicit user action. Particular care should be paid to
// ensure that modifications are not made during startup -- for example, when
// setting the initial value of preferences widgets. The built-in
// g_settings_bind() functionality is careful not to write settings in response
// to notify signals as a result of modifications that it makes to widgets.
//
// When creating a GSettings instance, you have to specify a schema that
// describes the keys in your settings and their types and default values, as
// well as some other information.
//
// Normally, a schema has a fixed path that determines where the settings are
// stored in the conceptual global tree of settings. However, schemas can also
// be '[relocatable][gsettings-relocatable]', i.e. not equipped with a fixed
// path. This is useful e.g. when the schema describes an 'account', and you
// want to be able to store a arbitrary number of accounts.
//
// Paths must start with and end with a forward slash character ('/') and must
// not contain two sequential slash characters. Paths should be chosen based on
// a domain name associated with the program or library to which the settings
// belong. Examples of paths are "/org/gtk/settings/file-chooser/" and
// "/ca/desrt/dconf-editor/". Paths should not start with "/apps/", "/desktop/"
// or "/system/" as they often did in GConf.
//
// Unlike other configuration systems (like GConf), GSettings does not restrict
// keys to basic types like strings and numbers. GSettings stores values as
// #GVariant, and allows any Type for keys. Key names are restricted to
// lowercase characters, numbers and '-'. Furthermore, the names must begin with
// a lowercase character, must not end with a '-', and must not contain
// consecutive dashes.
//
// Similar to GConf, the default values in GSettings schemas can be localized,
// but the localized values are stored in gettext catalogs and looked up with
// the domain that is specified in the gettext-domain attribute of the
// <schemalist> or <schema> elements and the category that is specified in the
// l10n attribute of the <default> element. The string which is translated
// includes all text in the <default> element, including any surrounding
// quotation marks.
//
// The l10n attribute must be set to messages or time, and sets the [locale
// category for
// translation](https://www.gnu.org/software/gettext/manual/html_node/Aspects.html#index-locale-categories-1).
// The messages category should be used by default; use time for translatable
// date or time formats. A translation comment can be added as an XML comment
// immediately above the <default> element — it is recommended to add these
// comments to aid translators understand the meaning and implications of the
// default value. An optional translation context attribute can be set on the
// <default> element to disambiguate multiple defaults which use the same
// string.
//
// For example:
//
//    <!-- Translators: A list of words which are not allowed to be typed, in
//         GVariant serialization syntax.
//         See: https://developer.gnome.org/glib/stable/gvariant-text.html -->
//    <default l10n='messages' context='Banned words'>['bad', 'words']</default>
//
// Translations of default values must remain syntactically valid serialized
// #GVariants (e.g. retaining any surrounding quotation marks) or runtime errors
// will occur.
//
// GSettings uses schemas in a compact binary form that is created by the
// [glib-compile-schemas][glib-compile-schemas] utility. The input is a schema
// description in an XML format.
//
// A DTD for the gschema XML format can be found here: gschema.dtd
// (https://git.gnome.org/browse/glib/tree/gio/gschema.dtd)
//
// The [glib-compile-schemas][glib-compile-schemas] tool expects schema files to
// have the extension .gschema.xml.
//
// At runtime, schemas are identified by their id (as specified in the id
// attribute of the <schema> element). The convention for schema ids is to use a
// dotted name, similar in style to a D-Bus bus name, e.g.
// "org.gnome.SessionManager". In particular, if the settings are for a specific
// service that owns a D-Bus bus name, the D-Bus bus name and schema id should
// match. For schemas which deal with settings not associated with one named
// application, the id should not use StudlyCaps, e.g.
// "org.gnome.font-rendering".
//
// In addition to #GVariant types, keys can have types that have enumerated
// types. These can be described by a <choice>, <enum> or <flags> element, as
// seen in the [example][schema-enumerated]. The underlying type of such a key
// is string, but you can use g_settings_get_enum(), g_settings_set_enum(),
// g_settings_get_flags(), g_settings_set_flags() access the numeric values
// corresponding to the string value of enum and flags keys.
//
// An example for default value:
//
//    <schemalist>
//      <schema id="org.gtk.Test" path="/org/gtk/Test/" gettext-domain="test">
//
//        <key name="greeting" type="s">
//          <default l10n="messages">"Hello, earthlings"</default>
//          <summary>A greeting</summary>
//          <description>
//            Greeting of the invading martians
//          </description>
//        </key>
//
//        <key name="box" type="(ii)">
//          <default>(20,30)</default>
//        </key>
//
//        <key name="empty-string" type="s">
//          <default>""</default>
//          <summary>Empty strings have to be provided in GVariant form</summary>
//        </key>
//
//      </schema>
//    </schemalist>
//
// An example for ranges, choices and enumerated types:
//
//    <schemalist>
//
//      <enum id="org.gtk.Test.myenum">
//        <value nick="first" value="1"/>
//        <value nick="second" value="2"/>
//      </enum>
//
//      <flags id="org.gtk.Test.myflags">
//        <value nick="flag1" value="1"/>
//        <value nick="flag2" value="2"/>
//        <value nick="flag3" value="4"/>
//      </flags>
//
//      <schema id="org.gtk.Test">
//
//        <key name="key-with-range" type="i">
//          <range min="1" max="100"/>
//          <default>10</default>
//        </key>
//
//        <key name="key-with-choices" type="s">
//          <choices>
//            <choice value='Elisabeth'/>
//            <choice value='Annabeth'/>
//            <choice value='Joe'/>
//          </choices>
//          <aliases>
//            <alias value='Anna' target='Annabeth'/>
//            <alias value='Beth' target='Elisabeth'/>
//          </aliases>
//          <default>'Joe'</default>
//        </key>
//
//        <key name='enumerated-key' enum='org.gtk.Test.myenum'>
//          <default>'first'</default>
//        </key>
//
//        <key name='flags-key' flags='org.gtk.Test.myflags'>
//          <default>["flag1","flag2"]</default>
//        </key>
//      </schema>
//    </schemalist>
//
//
// Vendor overrides
//
// Default values are defined in the schemas that get installed by an
// application. Sometimes, it is necessary for a vendor or distributor to adjust
// these defaults. Since patching the XML source for the schema is inconvenient
// and error-prone, [glib-compile-schemas][glib-compile-schemas] reads so-called
// vendor override' files. These are keyfiles in the same directory as the XML
// schema sources which can override default values. The schema id serves as the
// group name in the key file, and the values are expected in serialized
// GVariant form, as in the following example:
//
//    [org.gtk.Example]
//    key1='string'
//    key2=1.5
//
// glib-compile-schemas expects schema files to have the extension
// .gschema.override.
//
//
// Binding
//
// A very convenient feature of GSettings lets you bind #GObject properties
// directly to settings, using g_settings_bind(). Once a GObject property has
// been bound to a setting, changes on either side are automatically propagated
// to the other side. GSettings handles details like mapping between GObject and
// GVariant types, and preventing infinite cycles.
//
// This makes it very easy to hook up a preferences dialog to the underlying
// settings. To make this even more convenient, GSettings looks for a boolean
// property with the name "sensitivity" and automatically binds it to the
// writability of the bound setting. If this 'magic' gets in the way, it can be
// suppressed with the SETTINGS_BIND_NO_SENSITIVITY flag.
//
//
// Relocatable schemas
//
// A relocatable schema is one with no path attribute specified on its <schema>
// element. By using g_settings_new_with_path(), a #GSettings object can be
// instantiated for a relocatable schema, assigning a path to the instance.
// Paths passed to g_settings_new_with_path() will typically be constructed
// dynamically from a constant prefix plus some form of instance identifier; but
// they must still be valid GSettings paths. Paths could also be constant and
// used with a globally installed schema originating from a dependency library.
//
// For example, a relocatable schema could be used to store geometry information
// for different windows in an application. If the schema ID was
// org.foo.MyApp.Window, it could be instantiated for paths
// /org/foo/MyApp/main/, /org/foo/MyApp/document-1/, /org/foo/MyApp/document-2/,
// etc. If any of the paths are well-known they can be specified as <child>
// elements in the parent schema, e.g.:
//
//    <schema id="org.foo.MyApp" path="/org/foo/MyApp/">
//      <child name="main" schema="org.foo.MyApp.Window"/>
//    </schema>
//
//
// Build system integration
//
// GSettings comes with autotools integration to simplify compiling and
// installing schemas. To add GSettings support to an application, add the
// following to your configure.ac:
//
//    GLIB_GSETTINGS
//
// In the appropriate Makefile.am, use the following snippet to compile and
// install the named schema:
//
//    gsettings_SCHEMAS = org.foo.MyApp.gschema.xml
//    EXTRA_DIST = $(gsettings_SCHEMAS)
//
//    GSETTINGS_RULES@
//
// No changes are needed to the build system to mark a schema XML file for
// translation. Assuming it sets the gettext-domain attribute, a schema may be
// marked for translation by adding it to POTFILES.in, assuming gettext 0.19 is
// in use (the preferred method for translation):
//
//    data/org.foo.MyApp.gschema.xml
//
// Alternatively, if intltool 0.50.1 is in use:
//
//    [type: gettext/gsettings]data/org.foo.MyApp.gschema.xml
//
// GSettings will use gettext to look up translations for the <summary> and
// <description> elements, and also any <default> elements which have a l10n
// attribute set. Translations must not be included in the .gschema.xml file by
// the build system, for example by using intltool XML rules with a
// .gschema.xml.in template.
//
// If an enumerated type defined in a C header file is to be used in a GSettings
// schema, it can either be defined manually using an <enum> element in the
// schema XML, or it can be extracted automatically from the C header. This
// approach is preferred, as it ensures the two representations are always
// synchronised. To do so, add the following to the relevant Makefile.am:
//
//    gsettings_ENUM_NAMESPACE = org.foo.MyApp
//    gsettings_ENUM_FILES = my-app-enums.h my-app-misc.h
//
// gsettings_ENUM_NAMESPACE specifies the schema namespace for the enum files,
// which are specified in gsettings_ENUM_FILES. This will generate a
// org.foo.MyApp.enums.xml file containing the extracted enums, which will be
// automatically included in the schema compilation, install and uninstall
// rules. It should not be committed to version control or included in
// EXTRA_DIST.
type Settings struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Settings)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Settings, *SettingsClass, SettingsOverrides](
		GTypeSettings,
		initSettingsClass,
		wrapSettings,
		defaultSettingsOverrides,
	)
}

func initSettingsClass(gclass unsafe.Pointer, overrides SettingsOverrides, classInitFunc func(*SettingsClass)) {
	pclass := (*C.GSettingsClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSettings))))

	if overrides.ChangeEvent != nil {
		pclass.change_event = (*[0]byte)(C._gotk4_gio2_SettingsClass_change_event)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gio2_SettingsClass_changed)
	}

	if overrides.WritableChangeEvent != nil {
		pclass.writable_change_event = (*[0]byte)(C._gotk4_gio2_SettingsClass_writable_change_event)
	}

	if overrides.WritableChanged != nil {
		pclass.writable_changed = (*[0]byte)(C._gotk4_gio2_SettingsClass_writable_changed)
	}

	if classInitFunc != nil {
		class := (*SettingsClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSettings(obj *coreglib.Object) *Settings {
	return &Settings{
		Object: obj,
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	return wrapSettings(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChangeEvent: "change-event" signal is emitted once per change event
// that affects this settings object. You should connect to this signal only if
// you are interested in viewing groups of changes before they are split out
// into multiple emissions of the "changed" signal. For most use cases it is
// more appropriate to use the "changed" signal.
//
// In the event that the change event applies to one or more specified keys,
// keys will be an array of #GQuark of length n_keys. In the event that the
// change event applies to the #GSettings object as a whole (ie: potentially
// every key has been changed) then keys will be NULL and n_keys will be 0.
//
// The default handler for this signal invokes the "changed" signal for each
// affected key. If any other connected handler returns TRUE then this default
// functionality will be suppressed.
func (settings *Settings) ConnectChangeEvent(f func(keys []glib.Quark) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(settings, "change-event", false, unsafe.Pointer(C._gotk4_gio2_Settings_ConnectChangeEvent), f)
}

// ConnectChanged: "changed" signal is emitted when a key has potentially
// changed. You should call one of the g_settings_get() calls to check the new
// value.
//
// This signal supports detailed connections. You can connect to the detailed
// signal "changed::x" in order to only receive callbacks when key "x" changes.
//
// Note that settings only emits this signal if you have read key at least once
// while a signal handler was already connected for key.
func (settings *Settings) ConnectChanged(f func(key string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(settings, "changed", false, unsafe.Pointer(C._gotk4_gio2_Settings_ConnectChanged), f)
}

// ConnectWritableChangeEvent: "writable-change-event" signal is emitted once
// per writability change event that affects this settings object. You should
// connect to this signal if you are interested in viewing groups of changes
// before they are split out into multiple emissions of the "writable-changed"
// signal. For most use cases it is more appropriate to use the
// "writable-changed" signal.
//
// In the event that the writability change applies only to a single key, key
// will be set to the #GQuark for that key. In the event that the writability
// change affects the entire settings object, key will be 0.
//
// The default handler for this signal invokes the "writable-changed" and
// "changed" signals for each affected key. This is done because changes in
// writability might also imply changes in value (if for example, a new
// mandatory setting is introduced). If any other connected handler returns TRUE
// then this default functionality will be suppressed.
func (settings *Settings) ConnectWritableChangeEvent(f func(key uint) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(settings, "writable-change-event", false, unsafe.Pointer(C._gotk4_gio2_Settings_ConnectWritableChangeEvent), f)
}

// ConnectWritableChanged: "writable-changed" signal is emitted when the
// writability of a key has potentially changed. You should call
// g_settings_is_writable() in order to determine the new status.
//
// This signal supports detailed connections. You can connect to the detailed
// signal "writable-changed::x" in order to only receive callbacks when the
// writability of "x" changes.
func (settings *Settings) ConnectWritableChanged(f func(key string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(settings, "writable-changed", false, unsafe.Pointer(C._gotk4_gio2_Settings_ConnectWritableChanged), f)
}

// Apply applies any changes that have been made to the settings. This function
// does nothing unless settings is in 'delay-apply' mode; see
// g_settings_delay(). In the normal case settings are always applied
// immediately.
func (settings *Settings) Apply() {
	var _arg0 *C.GSettings // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	C.g_settings_apply(_arg0)
	runtime.KeepAlive(settings)
}

// Mapped gets the value that is stored at key in settings, subject to
// application-level validation/mapping.
//
// You should use this function when the application needs to perform some
// processing on the value of the key (for example, parsing). The mapping
// function performs that processing. If the function indicates that the
// processing was unsuccessful (due to a parse error, for example) then the
// mapping is tried again with another value.
//
// This allows a robust 'fall back to defaults' behaviour to be implemented
// somewhat automatically.
//
// The first value that is tried is the user's setting for the key. If the
// mapping function fails to map this value, other values may be tried in an
// unspecified order (system or site defaults, translated schema default values,
// untranslated schema default values, etc).
//
// If the mapping function fails for all possible values, one additional attempt
// is made: the mapping function is called with a NULL value. If the mapping
// function still indicates failure at this point then the application will be
// aborted.
//
// The result parameter for the mapping function is pointed to a #gpointer which
// is initially set to NULL. The same pointer is given to each invocation of
// mapping. The final value of that #gpointer is what is returned by this
// function. NULL is valid; it is returned just as any other value would be.
//
// The function takes the following parameters:
//
//    - key to get the value for.
//    - mapping: function to map the value in the settings database to the value
//      used by the application.
//
// The function returns the following values:
//
//    - gpointer (optional): result, which may be NULL.
//
func (settings *Settings) Mapped(key string, mapping SettingsGetMapping) unsafe.Pointer {
	var _arg0 *C.GSettings          // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GSettingsGetMapping // out
	var _arg3 C.gpointer
	var _cret C.gpointer // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*[0]byte)(C._gotk4_gio2_SettingsGetMapping)
	_arg3 = C.gpointer(gbox.Assign(mapping))
	defer gbox.Delete(uintptr(_arg3))

	_cret = C.g_settings_get_mapped(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(mapping)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// ListChildren gets the list of children on settings.
//
// The list is exactly the list of strings for which it is not an error to call
// g_settings_get_child().
//
// There is little reason to call this function from "normal" code, since you
// should already know what children are in your schema. This function may still
// be useful there for introspection reasons, however.
//
// You should free the return value with g_strfreev() when you are done with it.
//
// The function returns the following values:
//
//    - utf8s: list of the children on settings, in no defined order.
//
func (settings *Settings) ListChildren() []string {
	var _arg0 *C.GSettings // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.g_settings_list_children(_arg0)
	runtime.KeepAlive(settings)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ListKeys introspects the list of keys on settings.
//
// You should probably not be calling this function from "normal" code (since
// you should already know what keys are in your schema). This function is
// intended for introspection reasons.
//
// You should free the return value with g_strfreev() when you are done with it.
//
// Deprecated: Use g_settings_schema_list_keys() instead.
//
// The function returns the following values:
//
//    - utf8s: list of the keys on settings, in no defined order.
//
func (settings *Settings) ListKeys() []string {
	var _arg0 *C.GSettings // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.g_settings_list_keys(_arg0)
	runtime.KeepAlive(settings)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Reset resets key to its default value.
//
// This call resets the key, as much as possible, to its default value. That
// might be the value specified in the schema or the one set by the
// administrator.
//
// The function takes the following parameters:
//
//    - key: name of a key.
//
func (settings *Settings) Reset(key string) {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_settings_reset(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// Revert reverts all non-applied changes to the settings. This function does
// nothing unless settings is in 'delay-apply' mode; see g_settings_delay(). In
// the normal case settings are always applied immediately.
//
// Change notifications will be emitted for affected keys.
func (settings *Settings) Revert() {
	var _arg0 *C.GSettings // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	C.g_settings_revert(_arg0)
	runtime.KeepAlive(settings)
}

// SetEnum looks up the enumerated type nick for value and writes it to key,
// within settings.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings or is not marked as an enumerated type, or for value not to be a
// valid value for the named type.
//
// After performing the write, accessing key directly with
// g_settings_get_string() will return the 'nick' associated with value.
//
// The function takes the following parameters:
//
//    - key: key, within settings.
//    - value: enumerated value.
//
// The function returns the following values:
//
//    - ok: TRUE, if the set succeeds.
//
func (settings *Settings) SetEnum(key string, value int) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(value)

	_cret = C.g_settings_set_enum(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFlags looks up the flags type nicks for the bits specified by value, puts
// them in an array of strings and writes the array to key, within settings.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings or is not marked as a flags type, or for value to contain any bits
// that are not value for the named type.
//
// After performing the write, accessing key directly with g_settings_get_strv()
// will return an array of 'nicks'; one for each bit in value.
//
// The function takes the following parameters:
//
//    - key: key, within settings.
//    - value flags value.
//
// The function returns the following values:
//
//    - ok: TRUE, if the set succeeds.
//
func (settings *Settings) SetFlags(key string, value uint) bool {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _arg2 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(value)

	_cret = C.g_settings_set_flags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - keys
//    - nKeys
//
// The function returns the following values:
//
func (settings *Settings) changeEvent(keys *glib.Quark, nKeys int) bool {
	gclass := (*C.GSettingsClass)(coreglib.PeekParentClass(settings))
	fnarg := gclass.change_event

	var _arg0 *C.GSettings // out
	var _arg1 *C.GQuark    // out
	var _arg2 C.gint       // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.guint32)(unsafe.Pointer(keys))
	_arg2 = C.gint(nKeys)

	_cret = C._gotk4_gio2_Settings_virtual_change_event(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(keys)
	runtime.KeepAlive(nKeys)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (settings *Settings) changed(key string) {
	gclass := (*C.GSettingsClass)(coreglib.PeekParentClass(settings))
	fnarg := gclass.changed

	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_Settings_virtual_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (settings *Settings) writableChangeEvent(key glib.Quark) bool {
	gclass := (*C.GSettingsClass)(coreglib.PeekParentClass(settings))
	fnarg := gclass.writable_change_event

	var _arg0 *C.GSettings // out
	var _arg1 C.GQuark     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.guint32(key)

	_cret = C._gotk4_gio2_Settings_virtual_writable_change_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (settings *Settings) writableChanged(key string) {
	gclass := (*C.GSettingsClass)(coreglib.PeekParentClass(settings))
	fnarg := gclass.writable_changed

	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_Settings_virtual_writable_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// SettingsSync ensures that all pending operations are complete for the default
// backend.
//
// Writes made to a #GSettings are handled asynchronously. For this reason, it
// is very unlikely that the changes have it to disk by the time
// g_settings_set() returns.
//
// This call will block until all of the writes have made it to the backend.
// Since the mainloop is not running, no change notifications will be dispatched
// during this call (but some may be queued by the time the call is done).
func SettingsSync() {
	C.g_settings_sync()
}

// SettingsClass: instance of this type is always passed by reference.
type SettingsClass struct {
	*settingsClass
}

// settingsClass is the struct that's finalized.
type settingsClass struct {
	native *C.GSettingsClass
}

func (s *SettingsClass) Padding() [20]unsafe.Pointer {
	valptr := &s.native.padding
	var _v [20]unsafe.Pointer // out
	{
		src := &*valptr
		for i := 0; i < 20; i++ {
			_v[i] = (unsafe.Pointer)(unsafe.Pointer(src[i]))
		}
	}
	return _v
}

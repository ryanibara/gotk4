// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// BusNameAppearedCallback: invoked when the name being watched is known to have
// to have an owner.
type BusNameAppearedCallback func(connection *DBusConnection, name, nameOwner string)

//export _gotk4_gio2_BusNameAppearedCallback
func _gotk4_gio2_BusNameAppearedCallback(arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 C.gpointer) {
	var fn BusNameAppearedCallback
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(BusNameAppearedCallback)
	}

	var _connection *DBusConnection // out
	var _name string                // out
	var _nameOwner string           // out

	_connection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(arg1)))
	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_nameOwner = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	fn(_connection, _name, _nameOwner)
}

// BusNameVanishedCallback: invoked when the name being watched is known not to
// have to have an owner.
//
// This is also invoked when the BusConnection on which the watch was
// established has been closed. In that case, connection will be NULL.
type BusNameVanishedCallback func(connection *DBusConnection, name string)

//export _gotk4_gio2_BusNameVanishedCallback
func _gotk4_gio2_BusNameVanishedCallback(arg1 *C.void, arg2 *C.void, arg3 C.gpointer) {
	var fn BusNameVanishedCallback
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(BusNameVanishedCallback)
	}

	var _connection *DBusConnection // out
	var _name string                // out

	_connection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(arg1)))
	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	fn(_connection, _name)
}

// BusUnwatchName stops watching a name.
//
// Note that there may still be D-Bus traffic to process (relating to watching
// and unwatching the name) in the current thread-default Context after this
// function has returned. You should continue to iterate the Context until the
// Notify function passed to g_bus_watch_name() is called, in order to avoid
// memory leaks through callbacks queued on the Context after itâ€™s stopped being
// iterated.
//
// The function takes the following parameters:
//
//    - watcherId: identifier obtained from g_bus_watch_name().
//
func BusUnwatchName(watcherId uint32) {
	var _args [1]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(watcherId)

	_info := girepository.MustFind("Gio", "bus_unwatch_name")
	_info.Invoke(_args[:], nil)

	runtime.KeepAlive(watcherId)
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// ConditionTimedWait waits for up to timeout_us microseconds for condition to
// become true on socket. If the condition is met, TRUE is returned.
//
// If cancellable is cancelled before the condition is met, or if timeout_us (or
// the socket's #GSocket:timeout) is reached before the condition is met, then
// FALSE is returned and error, if non-NULL, is set to the appropriate value
// (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// If you don't want a timeout, use g_socket_condition_wait(). (Alternatively,
// you can pass -1 for timeout_us.)
//
// Note that although timeout_us is in microseconds for consistency with other
// GLib APIs, this function actually only has millisecond resolution, and the
// behavior is undefined if timeout_us is not an exact number of milliseconds.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - condition mask to wait for.
//    - timeoutUs: maximum time (in microseconds) to wait, or -1.
//
func (socket *Socket) ConditionTimedWait(ctx context.Context, condition glib.IOCondition, timeoutUs int64) error {
	var _arg0 *C.GSocket      // out
	var _arg3 *C.GCancellable // out
	var _arg1 C.GIOCondition  // out
	var _arg2 C.gint64        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GIOCondition(condition)
	_arg2 = C.gint64(timeoutUs)

	C.g_socket_condition_timed_wait(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeoutUs)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AvailableBytes: get the amount of data pending in the OS input buffer,
// without blocking.
//
// If socket is a UDP or SCTP socket, this will return the size of just the next
// packet, even if additional packets are buffered after that one.
//
// Note that on Windows, this function is rather inefficient in the UDP case,
// and so if you know any plausible upper bound on the size of the incoming
// packet, it is better to just do a g_socket_receive() with a buffer of that
// size, rather than calling g_socket_get_available_bytes() first and then doing
// a receive of exactly the right size.
//
// The function returns the following values:
//
//    - gssize: number of bytes that can be read from the socket without blocking
//      or truncating, or -1 on error.
//
func (socket *Socket) AvailableBytes() int {
	var _arg0 *C.GSocket // out
	var _cret C.gssize   // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_available_bytes(_arg0)
	runtime.KeepAlive(socket)

	var _gssize int // out

	_gssize = int(_cret)

	return _gssize
}

// Broadcast gets the broadcast setting on socket; if TRUE, it is possible to
// send packets to broadcast addresses.
//
// The function returns the following values:
//
//    - ok: broadcast setting on socket.
//
func (socket *Socket) Broadcast() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_broadcast(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MulticastLoopback gets the multicast loopback setting on socket; if TRUE (the
// default), outgoing multicast packets will be looped back to multicast
// listeners on the same host.
//
// The function returns the following values:
//
//    - ok: multicast loopback setting on socket.
//
func (socket *Socket) MulticastLoopback() bool {
	var _arg0 *C.GSocket // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_multicast_loopback(_arg0)
	runtime.KeepAlive(socket)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MulticastTTL gets the multicast time-to-live setting on socket; see
// g_socket_set_multicast_ttl() for more details.
//
// The function returns the following values:
//
//    - guint: multicast time-to-live setting on socket.
//
func (socket *Socket) MulticastTTL() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_multicast_ttl(_arg0)
	runtime.KeepAlive(socket)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TTL gets the unicast time-to-live setting on socket; see g_socket_set_ttl()
// for more details.
//
// The function returns the following values:
//
//    - guint: time-to-live setting on socket.
//
func (socket *Socket) TTL() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_ttl(_arg0)
	runtime.KeepAlive(socket)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// JoinMulticastGroup registers socket to receive multicast messages sent to
// group. socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have been
// bound to an appropriate interface and port with g_socket_bind().
//
// If iface is NULL, the system will automatically pick an interface to bind to
// based on group.
//
// If source_specific is TRUE, source-specific multicast as defined in RFC 4604
// is used. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// To bind to a given source-specific multicast address, use
// g_socket_join_multicast_group_ssm() instead.
//
// The function takes the following parameters:
//
//    - group specifying the group address to join.
//    - sourceSpecific: TRUE if source-specific multicast should be used.
//    - iface (optional): name of the interface to use, or NULL.
//
func (socket *Socket) JoinMulticastGroup(group *InetAddress, sourceSpecific bool, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 C.gboolean      // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific {
		_arg2 = C.TRUE
	}
	if iface != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_socket_join_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LeaveMulticastGroup removes socket from the multicast group defined by group,
// iface, and source_specific (which must all have the same values they had when
// you joined the group).
//
// socket remains bound to its address and port, and can still receive unicast
// messages after calling this.
//
// To unbind to a given source-specific multicast address, use
// g_socket_leave_multicast_group_ssm() instead.
//
// The function takes the following parameters:
//
//    - group specifying the group address to leave.
//    - sourceSpecific: TRUE if source-specific multicast was used.
//    - iface (optional): interface used.
//
func (socket *Socket) LeaveMulticastGroup(group *InetAddress, sourceSpecific bool, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 C.gboolean      // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific {
		_arg2 = C.TRUE
	}
	if iface != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_socket_leave_multicast_group(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetBroadcast sets whether socket should allow sending to broadcast addresses.
// This is FALSE by default.
//
// The function takes the following parameters:
//
//    - broadcast: whether socket should allow sending to broadcast addresses.
//
func (socket *Socket) SetBroadcast(broadcast bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if broadcast {
		_arg1 = C.TRUE
	}

	C.g_socket_set_broadcast(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(broadcast)
}

// SetMulticastLoopback sets whether outgoing multicast packets will be received
// by sockets listening on that multicast address on the same host. This is TRUE
// by default.
//
// The function takes the following parameters:
//
//    - loopback: whether socket should receive messages sent to its multicast
//      groups from the local host.
//
func (socket *Socket) SetMulticastLoopback(loopback bool) {
	var _arg0 *C.GSocket // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if loopback {
		_arg1 = C.TRUE
	}

	C.g_socket_set_multicast_loopback(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(loopback)
}

// SetMulticastTTL sets the time-to-live for outgoing multicast datagrams on
// socket. By default, this is 1, meaning that multicast packets will not leave
// the local network.
//
// The function takes the following parameters:
//
//    - ttl: time-to-live value for all multicast datagrams on socket.
//
func (socket *Socket) SetMulticastTTL(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.guint(ttl)

	C.g_socket_set_multicast_ttl(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// SetTTL sets the time-to-live for outgoing unicast packets on socket. By
// default the platform-specific default value is used.
//
// The function takes the following parameters:
//
//    - ttl: time-to-live value for all unicast packets on socket.
//
func (socket *Socket) SetTTL(ttl uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.guint(ttl)

	C.g_socket_set_ttl(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern gboolean _gotk4_gio2_FileMonitorClass_cancel(GFileMonitor*);
// extern void _gotk4_gio2_FileMonitorClass_changed(GFileMonitor*, GFile*, GFile*, GFileMonitorEvent);
// extern void _gotk4_gio2_FileMonitor_ConnectChanged(gpointer, GFile*, GFile*, GFileMonitorEvent, guintptr);
import "C"

// GType values.
var (
	GTypeFileMonitor = coreglib.Type(C.g_file_monitor_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeFileMonitor, F: marshalFileMonitor},
	})
}

// FileMonitorOverrider contains methods that are overridable.
type FileMonitorOverrider interface {
	// Cancel cancels a file monitor.
	//
	// The function returns the following values:
	//
	//    - ok always TRUE.
	//
	Cancel() bool
	// The function takes the following parameters:
	//
	//    - file
	//    - otherFile
	//    - eventType
	//
	Changed(file, otherFile Filer, eventType FileMonitorEvent)
}

// FileMonitor monitors a file or directory for changes.
//
// To obtain a Monitor for a file or directory, use g_file_monitor(),
// g_file_monitor_file(), or g_file_monitor_directory().
//
// To get informed about changes to the file or directory you are monitoring,
// connect to the Monitor::changed signal. The signal will be emitted in the
// [thread-default main context][g-main-context-push-thread-default] of the
// thread that the monitor was created in (though if the global default main
// context is blocked, this may cause notifications to be blocked even if the
// thread-default context is still running).
type FileMonitor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FileMonitor)(nil)
)

// FileMonitorrer describes types inherited from class FileMonitor.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FileMonitorrer interface {
	coreglib.Objector
	baseFileMonitor() *FileMonitor
}

var _ FileMonitorrer = (*FileMonitor)(nil)

func init() {
	coreglib.RegisterClassInfo(coreglib.ClassTypeInfo{
		GType:     GTypeFileMonitor,
		GoType:    reflect.TypeOf((*FileMonitor)(nil)),
		InitClass: initClassFileMonitor,
	})
}

func initClassFileMonitor(gclass unsafe.Pointer, goval any) {

	pclass := (*C.GFileMonitorClass)(unsafe.Pointer(gclass))

	if _, ok := goval.(interface{ Cancel() bool }); ok {
		pclass.cancel = (*[0]byte)(C._gotk4_gio2_FileMonitorClass_cancel)
	}

	if _, ok := goval.(interface {
		Changed(file, otherFile Filer, eventType FileMonitorEvent)
	}); ok {
		pclass.changed = (*[0]byte)(C._gotk4_gio2_FileMonitorClass_changed)
	}
	if goval, ok := goval.(interface{ InitFileMonitor(*FileMonitorClass) }); ok {
		klass := (*FileMonitorClass)(gextras.NewStructNative(gclass))
		goval.InitFileMonitor(klass)
	}
}

//export _gotk4_gio2_FileMonitorClass_cancel
func _gotk4_gio2_FileMonitorClass_cancel(arg0 *C.GFileMonitor) (cret C.gboolean) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ Cancel() bool })

	ok := iface.Cancel()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_FileMonitorClass_changed
func _gotk4_gio2_FileMonitorClass_changed(arg0 *C.GFileMonitor, arg1 *C.GFile, arg2 *C.GFile, arg3 C.GFileMonitorEvent) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Changed(file, otherFile Filer, eventType FileMonitorEvent)
	})

	var _file Filer                 // out
	var _otherFile Filer            // out
	var _eventType FileMonitorEvent // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Filer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Filer)
			return ok
		})
		rv, ok := casted.(Filer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
		}
		_file = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gio.Filer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Filer)
			return ok
		})
		rv, ok := casted.(Filer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
		}
		_otherFile = rv
	}
	_eventType = FileMonitorEvent(arg3)

	iface.Changed(_file, _otherFile, _eventType)
}

func wrapFileMonitor(obj *coreglib.Object) *FileMonitor {
	return &FileMonitor{
		Object: obj,
	}
}

func marshalFileMonitor(p uintptr) (interface{}, error) {
	return wrapFileMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (monitor *FileMonitor) baseFileMonitor() *FileMonitor {
	return monitor
}

// BaseFileMonitor returns the underlying base object.
func BaseFileMonitor(obj FileMonitorrer) *FileMonitor {
	return obj.baseFileMonitor()
}

//export _gotk4_gio2_FileMonitor_ConnectChanged
func _gotk4_gio2_FileMonitor_ConnectChanged(arg0 C.gpointer, arg1 *C.GFile, arg2 *C.GFile, arg3 C.GFileMonitorEvent, arg4 C.guintptr) {
	var f func(file, otherFile Filer, eventType FileMonitorEvent)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(file, otherFile Filer, eventType FileMonitorEvent))
	}

	var _file Filer                 // out
	var _otherFile Filer            // out
	var _eventType FileMonitorEvent // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Filer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Filer)
			return ok
		})
		rv, ok := casted.(Filer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
		}
		_file = rv
	}
	if arg2 != nil {
		{
			objptr := unsafe.Pointer(arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Filer)
				return ok
			})
			rv, ok := casted.(Filer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
			}
			_otherFile = rv
		}
	}
	_eventType = FileMonitorEvent(arg3)

	f(_file, _otherFile, _eventType)
}

// ConnectChanged is emitted when file has been changed.
//
// If using G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and the
// information is available (and if supported by the backend), event_type may be
// G_FILE_MONITOR_EVENT_RENAMED, G_FILE_MONITOR_EVENT_MOVED_IN or
// G_FILE_MONITOR_EVENT_MOVED_OUT.
//
// In all cases file will be a child of the monitored directory. For renames,
// file will be the old name and other_file is the new name. For "moved in"
// events, file is the name of the file that appeared and other_file is the old
// name that it was moved from (in another directory). For "moved out" events,
// file is the name of the file that used to be in this directory and other_file
// is the name of the file at its new location.
//
// It makes sense to treat G_FILE_MONITOR_EVENT_MOVED_IN as equivalent to
// G_FILE_MONITOR_EVENT_CREATED and G_FILE_MONITOR_EVENT_MOVED_OUT as equivalent
// to G_FILE_MONITOR_EVENT_DELETED, with extra information.
// G_FILE_MONITOR_EVENT_RENAMED is equivalent to a delete/create pair. This is
// exactly how the events will be reported in the case that the
// G_FILE_MONITOR_WATCH_MOVES flag is not in use.
//
// If using the deprecated flag G_FILE_MONITOR_SEND_MOVED flag and event_type is
// FILE_MONITOR_EVENT_MOVED, file will be set to a #GFile containing the old
// path, and other_file will be set to a #GFile containing the new path.
//
// In all the other cases, other_file will be set to LL.
func (monitor *FileMonitor) ConnectChanged(f func(file, otherFile Filer, eventType FileMonitorEvent)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(monitor, "changed", false, unsafe.Pointer(C._gotk4_gio2_FileMonitor_ConnectChanged), f)
}

// Cancel cancels a file monitor.
//
// The function returns the following values:
//
//    - ok always TRUE.
//
func (monitor *FileMonitor) Cancel() bool {
	var _arg0 *C.GFileMonitor // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.g_file_monitor_cancel(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EmitEvent emits the Monitor::changed signal if a change has taken place.
// Should be called from file monitor implementations only.
//
// Implementations are responsible to call this method from the [thread-default
// main context][g-main-context-push-thread-default] of the thread that the
// monitor was created in.
//
// The function takes the following parameters:
//
//    - child: #GFile.
//    - otherFile: #GFile.
//    - eventType: set of MonitorEvent flags.
//
func (monitor *FileMonitor) EmitEvent(child, otherFile Filer, eventType FileMonitorEvent) {
	var _arg0 *C.GFileMonitor     // out
	var _arg1 *C.GFile            // out
	var _arg2 *C.GFile            // out
	var _arg3 C.GFileMonitorEvent // out

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(otherFile).Native()))
	_arg3 = C.GFileMonitorEvent(eventType)

	C.g_file_monitor_emit_event(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(child)
	runtime.KeepAlive(otherFile)
	runtime.KeepAlive(eventType)
}

// IsCancelled returns whether the monitor is canceled.
//
// The function returns the following values:
//
//    - ok: TRUE if monitor is canceled. FALSE otherwise.
//
func (monitor *FileMonitor) IsCancelled() bool {
	var _arg0 *C.GFileMonitor // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	_cret = C.g_file_monitor_is_cancelled(_arg0)
	runtime.KeepAlive(monitor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetRateLimit sets the rate limit to which the monitor will report consecutive
// change events to the same file.
//
// The function takes the following parameters:
//
//    - limitMsecs: non-negative integer with the limit in milliseconds to poll
//      for changes.
//
func (monitor *FileMonitor) SetRateLimit(limitMsecs int) {
	var _arg0 *C.GFileMonitor // out
	var _arg1 C.gint          // out

	_arg0 = (*C.GFileMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	_arg1 = C.gint(limitMsecs)

	C.g_file_monitor_set_rate_limit(_arg0, _arg1)
	runtime.KeepAlive(monitor)
	runtime.KeepAlive(limitMsecs)
}

// FileMonitorClass: instance of this type is always passed by reference.
type FileMonitorClass struct {
	*fileMonitorClass
}

// fileMonitorClass is the struct that's finalized.
type fileMonitorClass struct {
	native *C.GFileMonitorClass
}

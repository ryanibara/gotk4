// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be polled.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = "mountable::can-poll"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_START: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START = "mountable::can-start"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: key in the "mountable" namespace
// for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started
// degraded. Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED = "mountable::can-start-degraded"

// FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: key in the "mountable" namespace for
// checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be stopped.
// Corresponding AttributeType is G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = "mountable::can-stop"

// FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: key in the "mountable"
// namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) is
// automatically polled for media. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = "mountable::is-media-check-automatic"

// FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: key in the "mountable" namespace
// for getting the StartStopType. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_UINT32.
const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE = "mountable::start-stop-type"

// FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: key in the "mountable" namespace
// for getting the unix device file. Corresponding AttributeType is
// G_FILE_ATTRIBUTE_TYPE_STRING.
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE = "mountable::unix-device-file"

// AttributeStringv gets the value of a stringv attribute. If the attribute does
// not contain a stringv, NULL will be returned.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//
// The function returns the following values:
//
//    - utf8s (optional) contents of the attribute value as a stringv, or NULL
//      otherwise. Do not free. These returned strings are UTF-8.
//
func (info *FileInfo) AttributeStringv(attribute string) []string {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret **C.char     // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_get_attribute_stringv(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)

	var _utf8s []string // out

	if _cret != nil {
		{
			var i int
			var z *C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			}
		}
	}

	return _utf8s
}

// HasNamespace checks if a file info structure has an attribute in the
// specified name_space.
//
// The function takes the following parameters:
//
//    - nameSpace: file attribute namespace.
//
// The function returns the following values:
//
//    - ok: TRUE if info has an attribute in name_space, FALSE otherwise.
//
func (info *FileInfo) HasNamespace(nameSpace string) bool {
	var _arg0 *C.GFileInfo // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(nameSpace)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_file_info_has_namespace(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(nameSpace)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAttributeStatus sets the attribute status for an attribute key. This is
// only needed by external code that implement g_file_set_attributes_from_info()
// or similar functions.
//
// The attribute must exist in info for this to work. Otherwise FALSE is
// returned and info is unchanged.
//
// The function takes the following parameters:
//
//    - attribute: file attribute key.
//    - status: AttributeStatus.
//
// The function returns the following values:
//
//    - ok: TRUE if the status was changed, FALSE if the key was not set.
//
func (info *FileInfo) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
	var _arg0 *C.GFileInfo           // out
	var _arg1 *C.char                // out
	var _arg2 C.GFileAttributeStatus // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GFileInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GFileAttributeStatus(status)

	_cret = C.g_file_info_set_attribute_status(_arg0, _arg1, _arg2)
	runtime.KeepAlive(info)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(status)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

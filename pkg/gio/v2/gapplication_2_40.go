// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// AddMainOptionEntries adds main option entries to be handled by application.
//
// This function is comparable to g_option_context_add_main_entries().
//
// After the commandline arguments are parsed, the
// #GApplication::handle-local-options signal will be emitted. At this point,
// the application can inspect the values pointed to by arg_data in the given
// Entrys.
//
// Unlike Context, #GApplication supports giving a NULL arg_data for a
// non-callback Entry. This results in the argument in question being packed
// into a Dict which is also passed to #GApplication::handle-local-options,
// where it can be inspected and modified. If G_APPLICATION_HANDLES_COMMAND_LINE
// is set, then the resulting dictionary is sent to the primary instance, where
// g_application_command_line_get_options_dict() will return it. This "packing"
// is done according to the type of the argument -- booleans for normal flags,
// strings for strings, bytestrings for filenames, etc. The packing only occurs
// if the flag is given (ie: we do not pack a "false" #GVariant in the case that
// a flag is missing).
//
// In general, it is recommended that all commandline arguments are parsed
// locally. The options dictionary should then be used to transmit the result of
// the parsing to the primary instance, where g_variant_dict_lookup() can be
// used. For local options, it is possible to either use arg_data in the usual
// way, or to consult (and potentially remove) the option from the options
// dictionary.
//
// This function is new in GLib 2.40. Before then, the only real choice was to
// send all of the commandline arguments (options and all) to the primary
// instance for handling. #GApplication ignored them completely on the local
// side. Calling this function "opts in" to the new behaviour, and in
// particular, means that unrecognised options will be treated as errors.
// Unrecognised options have never been ignored when
// G_APPLICATION_HANDLES_COMMAND_LINE is unset.
//
// If #GApplication::handle-local-options needs to see the list of filenames,
// then the use of G_OPTION_REMAINING is recommended. If arg_data is NULL then
// G_OPTION_REMAINING can be used as a key into the options dictionary. If you
// do use G_OPTION_REMAINING then you need to handle these arguments for
// yourself because once they are consumed, they will no longer be visible to
// the default handling (which treats them as filenames to be opened).
//
// It is important to use the proper GVariant format when retrieving the options
// with g_variant_dict_lookup():
//
// - for G_OPTION_ARG_NONE, use b
//
// - for G_OPTION_ARG_STRING, use &s
//
// - for G_OPTION_ARG_INT, use i
//
// - for G_OPTION_ARG_INT64, use x
//
// - for G_OPTION_ARG_DOUBLE, use d
//
// - for G_OPTION_ARG_FILENAME, use ^&ay
//
// - for G_OPTION_ARG_STRING_ARRAY, use ^a&s
//
// - for G_OPTION_ARG_FILENAME_ARRAY, use ^a&ay.
//
// The function takes the following parameters:
//
//    - entries: a NULL-terminated list of Entrys.
//
func (application *Application) AddMainOptionEntries(entries []glib.OptionEntry) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GOptionEntry // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	{
		_arg1 = (*C.GOptionEntry)(C.calloc(C.size_t((len(entries) + 1)), C.size_t(C.sizeof_GOptionEntry)))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(entries)+1)
			var zero C.GOptionEntry
			out[len(entries)] = zero
			for i := range entries {
				out[i] = *(*C.GOptionEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
			}
		}
	}

	C.g_application_add_main_option_entries(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(entries)
}

// AddOptionGroup adds a Group to the commandline handling of application.
//
// This function is comparable to g_option_context_add_group().
//
// Unlike g_application_add_main_option_entries(), this function does not deal
// with NULL arg_data and never transmits options to the primary instance.
//
// The reason for that is because, by the time the options arrive at the primary
// instance, it is typically too late to do anything with them. Taking the GTK
// option group as an example: GTK will already have been initialised by the
// time the #GApplication::command-line handler runs. In the case that this is
// not the first-running instance of the application, the existing instance may
// already have been running for a very long time.
//
// This means that the options from Group are only really usable in the case
// that the instance of the application being run is the first instance. Passing
// options like --display= or --gdk-debug= on future runs will have no effect on
// the existing primary instance.
//
// Calling this function will cause the options in the supplied option group to
// be parsed, but it does not cause you to be "opted in" to the new
// functionality whereby unrecognised options are rejected even if
// G_APPLICATION_HANDLES_COMMAND_LINE was given.
//
// The function takes the following parameters:
//
//    - group: Group.
//
func (application *Application) AddOptionGroup(group *glib.OptionGroup) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GOptionGroup // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GOptionGroup)(gextras.StructNative(unsafe.Pointer(group)))

	C.g_application_add_option_group(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(group)
}

// SendNotification sends a notification on behalf of application to the desktop
// shell. There is no guarantee that the notification is displayed immediately,
// or even at all.
//
// Notifications may persist after the application exits. It will be
// D-Bus-activated when the notification or one of its actions is activated.
//
// Modifying notification after this call has no effect. However, the object can
// be reused for a later call to this function.
//
// id may be any string that uniquely identifies the event for the application.
// It does not need to be in any special format. For example, "new-message"
// might be appropriate for a notification about new messages.
//
// If a previous notification was sent with the same id, it will be replaced
// with notification and shown again as if it was a new notification. This works
// even for notifications sent from a previous execution of the application, as
// long as id is the same string.
//
// id may be NULL, but it is impossible to replace or withdraw notifications
// without an id.
//
// If notification is no longer relevant, it can be withdrawn with
// g_application_withdraw_notification().
//
// The function takes the following parameters:
//
//    - id (optional) of the notification, or NULL.
//    - notification to send.
//
func (application *Application) SendNotification(id string, notification *Notification) {
	var _arg0 *C.GApplication  // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GNotification // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if id != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))

	C.g_application_send_notification(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
	runtime.KeepAlive(notification)
}

// WithdrawNotification withdraws a notification that was sent with
// g_application_send_notification().
//
// This call does nothing if a notification with id doesn't exist or the
// notification was never sent.
//
// This function works even for notifications sent in previous executions of
// this application, as long id is the same as it was for the sent notification.
//
// Note that notifications are dismissed when the user clicks on one of the
// buttons in a notification or triggers its default action, so there is no need
// to explicitly withdraw the notification in that case.
//
// The function takes the following parameters:
//
//    - id of a previously sent notification.
//
func (application *Application) WithdrawNotification(id string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_withdraw_notification(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
}

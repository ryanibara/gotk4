// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// void _gotk4_gio2_TLSClientConnection_virtual_copy_session_state(void* fnptr, GTlsClientConnection* arg0, GTlsClientConnection* arg1) {
//   ((void (*)(GTlsClientConnection*, GTlsClientConnection*))(fnptr))(arg0, arg1);
// };
import "C"

// CopySessionState: possibly copies session state from one connection to
// another, for use in TLS session resumption. This is not normally needed, but
// may be used when the same session needs to be used between different
// endpoints, as is required by some protocols, such as FTP over TLS. source
// should have already completed a handshake and, since TLS 1.3, it should have
// been used to read data at least once. conn should not have completed a
// handshake.
//
// It is not possible to know whether a call to this function will actually do
// anything. Because session resumption is normally used only for performance
// benefit, the TLS backend might not implement this function. Even if
// implemented, it may not actually succeed in allowing conn to resume source's
// TLS session, because the server may not have sent a session resumption token
// to source, or it may refuse to accept the token from conn. There is no way to
// know whether a call to this function is actually successful.
//
// Using this function is not required to benefit from session resumption. If
// the TLS backend supports session resumption, the session will be resumed
// automatically if it is possible to do so without weakening the privacy
// guarantees normally provided by TLS, without need to call this function. For
// example, with TLS 1.3, a session ticket will be automatically copied from any
// ClientConnection that has previously received session tickets from the
// server, provided a ticket is available that has not previously been used for
// session resumption, since session ticket reuse would be a privacy weakness.
// Using this function causes the ticket to be copied without regard for privacy
// considerations.
//
// The function takes the following parameters:
//
//    - source: ClientConnection.
//
func (conn *TLSClientConnection) CopySessionState(source TLSClientConnectioner) {
	var _arg0 *C.GTlsClientConnection // out
	var _arg1 *C.GTlsClientConnection // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(source).Native()))

	C.g_tls_client_connection_copy_session_state(_arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(source)
}

// copySessionState: possibly copies session state from one connection to
// another, for use in TLS session resumption. This is not normally needed, but
// may be used when the same session needs to be used between different
// endpoints, as is required by some protocols, such as FTP over TLS. source
// should have already completed a handshake and, since TLS 1.3, it should have
// been used to read data at least once. conn should not have completed a
// handshake.
//
// It is not possible to know whether a call to this function will actually do
// anything. Because session resumption is normally used only for performance
// benefit, the TLS backend might not implement this function. Even if
// implemented, it may not actually succeed in allowing conn to resume source's
// TLS session, because the server may not have sent a session resumption token
// to source, or it may refuse to accept the token from conn. There is no way to
// know whether a call to this function is actually successful.
//
// Using this function is not required to benefit from session resumption. If
// the TLS backend supports session resumption, the session will be resumed
// automatically if it is possible to do so without weakening the privacy
// guarantees normally provided by TLS, without need to call this function. For
// example, with TLS 1.3, a session ticket will be automatically copied from any
// ClientConnection that has previously received session tickets from the
// server, provided a ticket is available that has not previously been used for
// session resumption, since session ticket reuse would be a privacy weakness.
// Using this function causes the ticket to be copied without regard for privacy
// considerations.
//
// The function takes the following parameters:
//
//    - source: ClientConnection.
//
func (conn *TLSClientConnection) copySessionState(source TLSClientConnectioner) {
	gclass := (*C.GTlsClientConnectionInterface)(coreglib.PeekParentClass(conn))
	fnarg := gclass.copy_session_state

	var _arg0 *C.GTlsClientConnection // out
	var _arg1 *C.GTlsClientConnection // out

	_arg0 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(conn).Native()))
	_arg1 = (*C.GTlsClientConnection)(unsafe.Pointer(coreglib.InternObject(source).Native()))

	C._gotk4_gio2_TLSClientConnection_virtual_copy_session_state(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(conn)
	runtime.KeepAlive(source)
}

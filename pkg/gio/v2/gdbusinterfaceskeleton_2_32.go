// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// Connections gets a list of the connections that interface_ is exported on.
//
// The function returns the following values:
//
//    - list of all the connections that interface_ is exported on. The returned
//      list should be freed with g_list_free() after each element has been freed
//      with g_object_unref().
//
func (interface_ *DBusInterfaceSkeleton) Connections() []*DBusConnection {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _cret *C.GList                  // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))

	_cret = C.g_dbus_interface_skeleton_get_connections(_arg0)
	runtime.KeepAlive(interface_)

	var _list []*DBusConnection // out

	_list = make([]*DBusConnection, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDBusConnection)(v)
		var dst *DBusConnection // out
		dst = wrapDBusConnection(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// HasConnection checks if interface_ is exported on connection.
//
// The function takes the following parameters:
//
//    - connection: BusConnection.
//
// The function returns the following values:
//
//    - ok: TRUE if interface_ is exported on connection, FALSE otherwise.
//
func (interface_ *DBusInterfaceSkeleton) HasConnection(connection *DBusConnection) bool {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusConnection        // out
	var _cret C.gboolean                // in

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	_cret = C.g_dbus_interface_skeleton_has_connection(_arg0, _arg1)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(connection)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnexportFromConnection stops exporting interface_ on connection.
//
// To stop exporting on all connections the interface is exported on, use
// g_dbus_interface_skeleton_unexport().
//
// The function takes the following parameters:
//
//    - connection: BusConnection.
//
func (interface_ *DBusInterfaceSkeleton) UnexportFromConnection(connection *DBusConnection) {
	var _arg0 *C.GDBusInterfaceSkeleton // out
	var _arg1 *C.GDBusConnection        // out

	_arg0 = (*C.GDBusInterfaceSkeleton)(unsafe.Pointer(coreglib.InternObject(interface_).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))

	C.g_dbus_interface_skeleton_unexport_from_connection(_arg0, _arg1)
	runtime.KeepAlive(interface_)
	runtime.KeepAlive(connection)
}

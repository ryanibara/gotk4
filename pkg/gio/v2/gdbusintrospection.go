// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gdbusintrospection.go.
var (
	GTypeDBusAnnotationInfo = coreglib.Type(C.g_dbus_annotation_info_get_type())
	GTypeDBusArgInfo        = coreglib.Type(C.g_dbus_arg_info_get_type())
	GTypeDBusInterfaceInfo  = coreglib.Type(C.g_dbus_interface_info_get_type())
	GTypeDBusMethodInfo     = coreglib.Type(C.g_dbus_method_info_get_type())
	GTypeDBusNodeInfo       = coreglib.Type(C.g_dbus_node_info_get_type())
	GTypeDBusPropertyInfo   = coreglib.Type(C.g_dbus_property_info_get_type())
	GTypeDBusSignalInfo     = coreglib.Type(C.g_dbus_signal_info_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeDBusAnnotationInfo, F: marshalDBusAnnotationInfo},
		{T: GTypeDBusArgInfo, F: marshalDBusArgInfo},
		{T: GTypeDBusInterfaceInfo, F: marshalDBusInterfaceInfo},
		{T: GTypeDBusMethodInfo, F: marshalDBusMethodInfo},
		{T: GTypeDBusNodeInfo, F: marshalDBusNodeInfo},
		{T: GTypeDBusPropertyInfo, F: marshalDBusPropertyInfo},
		{T: GTypeDBusSignalInfo, F: marshalDBusSignalInfo},
	})
}

// DBusAnnotationInfo: information about an annotation.
//
// An instance of this type is always passed by reference.
type DBusAnnotationInfo struct {
	*dBusAnnotationInfo
}

// dBusAnnotationInfo is the struct that's finalized.
type dBusAnnotationInfo struct {
	native unsafe.Pointer
}

func marshalDBusAnnotationInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusAnnotationInfo{&dBusAnnotationInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusAnnotationInfo) RefCount() int32 {
	offset := girepository.MustFind("Gio", "DBusAnnotationInfo").StructFieldOffset("ref_count")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Key: name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
func (d *DBusAnnotationInfo) Key() string {
	offset := girepository.MustFind("Gio", "DBusAnnotationInfo").StructFieldOffset("key")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(valptr)))
	return v
}

// Value: value of the annotation.
func (d *DBusAnnotationInfo) Value() string {
	offset := girepository.MustFind("Gio", "DBusAnnotationInfo").StructFieldOffset("value")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(valptr)))
	return v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusAnnotationInfo) Annotations() []*DBusAnnotationInfo {
	offset := girepository.MustFind("Gio", "DBusAnnotationInfo").StructFieldOffset("annotations")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// DBusAnnotationInfoLookup looks up the value of an annotation.
//
// The cost of this function is O(n) in number of annotations.
//
// The function takes the following parameters:
//
//    - annotations (optional): NULL-terminated array of annotations or NULL.
//    - name of the annotation to look up.
//
// The function returns the following values:
//
//    - utf8 (optional): value or NULL if not found. Do not free, it is owned by
//      annotations.
//
func DBusAnnotationInfoLookup(annotations []*DBusAnnotationInfo, name string) string {
	var _args [2]girepository.Argument

	if annotations != nil {
		{
			*(***C.void)(unsafe.Pointer(&_args[0])) = (**C.void)(C.calloc(C.size_t((len(annotations) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
			defer C.free(unsafe.Pointer(_args[0]))
			{
				out := unsafe.Slice(_args[0], len(annotations)+1)
				var zero *C.void
				out[len(annotations)] = zero
				for i := range annotations {
					*(**C.void)(unsafe.Pointer(&out[i])) = (*C.void)(gextras.StructNative(unsafe.Pointer(annotations[i])))
				}
			}
		}
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))

	_gret := girepository.MustFind("Gio", "lookup").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(annotations)
	runtime.KeepAlive(name)

	var _utf8 string // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DBusArgInfo: information about an argument for a method or a signal.
//
// An instance of this type is always passed by reference.
type DBusArgInfo struct {
	*dBusArgInfo
}

// dBusArgInfo is the struct that's finalized.
type dBusArgInfo struct {
	native unsafe.Pointer
}

func marshalDBusArgInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusArgInfo{&dBusArgInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusArgInfo) RefCount() int32 {
	offset := girepository.MustFind("Gio", "DBusArgInfo").StructFieldOffset("ref_count")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Name of the argument, e.g. unix_user_id.
func (d *DBusArgInfo) Name() string {
	offset := girepository.MustFind("Gio", "DBusArgInfo").StructFieldOffset("name")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(valptr)))
	return v
}

// Signature d-Bus signature of the argument (a single complete type).
func (d *DBusArgInfo) Signature() string {
	offset := girepository.MustFind("Gio", "DBusArgInfo").StructFieldOffset("signature")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(valptr)))
	return v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusArgInfo) Annotations() []*DBusAnnotationInfo {
	offset := girepository.MustFind("Gio", "DBusArgInfo").StructFieldOffset("annotations")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// DBusInterfaceInfo: information about a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusInterfaceInfo struct {
	*dBusInterfaceInfo
}

// dBusInterfaceInfo is the struct that's finalized.
type dBusInterfaceInfo struct {
	native unsafe.Pointer
}

func marshalDBusInterfaceInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusInterfaceInfo{&dBusInterfaceInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusInterfaceInfo) RefCount() int32 {
	offset := girepository.MustFind("Gio", "DBusInterfaceInfo").StructFieldOffset("ref_count")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Name: name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
func (d *DBusInterfaceInfo) Name() string {
	offset := girepository.MustFind("Gio", "DBusInterfaceInfo").StructFieldOffset("name")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(valptr)))
	return v
}

// Methods: pointer to a NULL-terminated array of pointers to BusMethodInfo
// structures or NULL if there are no methods.
func (d *DBusInterfaceInfo) Methods() []*DBusMethodInfo {
	offset := girepository.MustFind("Gio", "DBusInterfaceInfo").StructFieldOffset("methods")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusMethodInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusMethodInfo, i)
		for i := range src {
			v[i] = (*DBusMethodInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_method_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// Signals: pointer to a NULL-terminated array of pointers to BusSignalInfo
// structures or NULL if there are no signals.
func (d *DBusInterfaceInfo) Signals() []*DBusSignalInfo {
	offset := girepository.MustFind("Gio", "DBusInterfaceInfo").StructFieldOffset("signals")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusSignalInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusSignalInfo, i)
		for i := range src {
			v[i] = (*DBusSignalInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_signal_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_signal_info_unref((*C.GDBusSignalInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// Properties: pointer to a NULL-terminated array of pointers to BusPropertyInfo
// structures or NULL if there are no properties.
func (d *DBusInterfaceInfo) Properties() []*DBusPropertyInfo {
	offset := girepository.MustFind("Gio", "DBusInterfaceInfo").StructFieldOffset("properties")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusPropertyInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusPropertyInfo, i)
		for i := range src {
			v[i] = (*DBusPropertyInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_property_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusInterfaceInfo) Annotations() []*DBusAnnotationInfo {
	offset := girepository.MustFind("Gio", "DBusInterfaceInfo").StructFieldOffset("annotations")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// CacheBuild builds a lookup-cache to speed up
// g_dbus_interface_info_lookup_method(), g_dbus_interface_info_lookup_signal()
// and g_dbus_interface_info_lookup_property().
//
// If this has already been called with info, the existing cache is used and its
// use count is increased.
//
// Note that info cannot be modified until g_dbus_interface_info_cache_release()
// is called.
func (info *DBusInterfaceInfo) CacheBuild() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(info)))

	runtime.KeepAlive(info)
}

// CacheRelease decrements the usage count for the cache for info built by
// g_dbus_interface_info_cache_build() (if any) and frees the resources used by
// the cache if the usage count drops to zero.
func (info *DBusInterfaceInfo) CacheRelease() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(info)))

	runtime.KeepAlive(info)
}

// LookupMethod looks up information about a method.
//
// The cost of this function is O(n) in number of methods unless
// g_dbus_interface_info_cache_build() has been used on info.
//
// The function takes the following parameters:
//
//    - name d-Bus method name (typically in CamelCase).
//
// The function returns the following values:
//
//    - dBusMethodInfo (optional) or NULL if not found. Do not free, it is owned
//      by info.
//
func (info *DBusInterfaceInfo) LookupMethod(name string) *DBusMethodInfo {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(info)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(info)
	runtime.KeepAlive(name)

	var _dBusMethodInfo *DBusMethodInfo // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_dBusMethodInfo = (*DBusMethodInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_method_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusMethodInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(intern.C))
			},
		)
	}

	return _dBusMethodInfo
}

// LookupProperty looks up information about a property.
//
// The cost of this function is O(n) in number of properties unless
// g_dbus_interface_info_cache_build() has been used on info.
//
// The function takes the following parameters:
//
//    - name d-Bus property name (typically in CamelCase).
//
// The function returns the following values:
//
//    - dBusPropertyInfo (optional) or NULL if not found. Do not free, it is
//      owned by info.
//
func (info *DBusInterfaceInfo) LookupProperty(name string) *DBusPropertyInfo {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(info)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(info)
	runtime.KeepAlive(name)

	var _dBusPropertyInfo *DBusPropertyInfo // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_dBusPropertyInfo = (*DBusPropertyInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_property_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusPropertyInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(intern.C))
			},
		)
	}

	return _dBusPropertyInfo
}

// LookupSignal looks up information about a signal.
//
// The cost of this function is O(n) in number of signals unless
// g_dbus_interface_info_cache_build() has been used on info.
//
// The function takes the following parameters:
//
//    - name d-Bus signal name (typically in CamelCase).
//
// The function returns the following values:
//
//    - dBusSignalInfo (optional) or NULL if not found. Do not free, it is owned
//      by info.
//
func (info *DBusInterfaceInfo) LookupSignal(name string) *DBusSignalInfo {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(info)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(info)
	runtime.KeepAlive(name)

	var _dBusSignalInfo *DBusSignalInfo // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_dBusSignalInfo = (*DBusSignalInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_signal_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusSignalInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_signal_info_unref((*C.GDBusSignalInfo)(intern.C))
			},
		)
	}

	return _dBusSignalInfo
}

// DBusMethodInfo: information about a method on an D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusMethodInfo struct {
	*dBusMethodInfo
}

// dBusMethodInfo is the struct that's finalized.
type dBusMethodInfo struct {
	native unsafe.Pointer
}

func marshalDBusMethodInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusMethodInfo{&dBusMethodInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusMethodInfo) RefCount() int32 {
	offset := girepository.MustFind("Gio", "DBusMethodInfo").StructFieldOffset("ref_count")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Name: name of the D-Bus method, e.g. RequestName.
func (d *DBusMethodInfo) Name() string {
	offset := girepository.MustFind("Gio", "DBusMethodInfo").StructFieldOffset("name")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(valptr)))
	return v
}

// InArgs: pointer to a NULL-terminated array of pointers to BusArgInfo
// structures or NULL if there are no in arguments.
func (d *DBusMethodInfo) InArgs() []*DBusArgInfo {
	offset := girepository.MustFind("Gio", "DBusMethodInfo").StructFieldOffset("in_args")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusArgInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusArgInfo, i)
		for i := range src {
			v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_arg_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_arg_info_unref((*C.GDBusArgInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// OutArgs: pointer to a NULL-terminated array of pointers to BusArgInfo
// structures or NULL if there are no out arguments.
func (d *DBusMethodInfo) OutArgs() []*DBusArgInfo {
	offset := girepository.MustFind("Gio", "DBusMethodInfo").StructFieldOffset("out_args")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusArgInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusArgInfo, i)
		for i := range src {
			v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_arg_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_arg_info_unref((*C.GDBusArgInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusMethodInfo) Annotations() []*DBusAnnotationInfo {
	offset := girepository.MustFind("Gio", "DBusMethodInfo").StructFieldOffset("annotations")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// DBusNodeInfo: information about nodes in a remote object hierarchy.
//
// An instance of this type is always passed by reference.
type DBusNodeInfo struct {
	*dBusNodeInfo
}

// dBusNodeInfo is the struct that's finalized.
type dBusNodeInfo struct {
	native unsafe.Pointer
}

func marshalDBusNodeInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusNodeInfo{&dBusNodeInfo{(unsafe.Pointer)(b)}}, nil
}

// NewDBusNodeInfoForXML constructs a struct DBusNodeInfo.
func NewDBusNodeInfoForXML(xmlData string) (*DBusNodeInfo, error) {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(xmlData)))
	defer C.free(unsafe.Pointer(_args[0]))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(xmlData)

	var _dBusNodeInfo *DBusNodeInfo // out
	var _goerr error                // out

	_dBusNodeInfo = (*DBusNodeInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dBusNodeInfo)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_dbus_node_info_unref((*C.GDBusNodeInfo)(intern.C))
		},
	)
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _dBusNodeInfo, _goerr
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusNodeInfo) RefCount() int32 {
	offset := girepository.MustFind("Gio", "DBusNodeInfo").StructFieldOffset("ref_count")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Path: path of the node or NULL if omitted. Note that this may be a relative
// path. See the D-Bus specification for more details.
func (d *DBusNodeInfo) Path() string {
	offset := girepository.MustFind("Gio", "DBusNodeInfo").StructFieldOffset("path")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(valptr)))
	return v
}

// Interfaces: pointer to a NULL-terminated array of pointers to
// BusInterfaceInfo structures or NULL if there are no interfaces.
func (d *DBusNodeInfo) Interfaces() []*DBusInterfaceInfo {
	offset := girepository.MustFind("Gio", "DBusNodeInfo").StructFieldOffset("interfaces")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusInterfaceInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusInterfaceInfo, i)
		for i := range src {
			v[i] = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_interface_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// Nodes: pointer to a NULL-terminated array of pointers to BusNodeInfo
// structures or NULL if there are no nodes.
func (d *DBusNodeInfo) Nodes() []*DBusNodeInfo {
	offset := girepository.MustFind("Gio", "DBusNodeInfo").StructFieldOffset("nodes")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusNodeInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusNodeInfo, i)
		for i := range src {
			v[i] = (*DBusNodeInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_node_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_node_info_unref((*C.GDBusNodeInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusNodeInfo) Annotations() []*DBusAnnotationInfo {
	offset := girepository.MustFind("Gio", "DBusNodeInfo").StructFieldOffset("annotations")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// LookupInterface looks up information about an interface.
//
// The cost of this function is O(n) in number of interfaces.
//
// The function takes the following parameters:
//
//    - name d-Bus interface name.
//
// The function returns the following values:
//
//    - dBusInterfaceInfo (optional) or NULL if not found. Do not free, it is
//      owned by info.
//
func (info *DBusNodeInfo) LookupInterface(name string) *DBusInterfaceInfo {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(info)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(info)
	runtime.KeepAlive(name)

	var _dBusInterfaceInfo *DBusInterfaceInfo // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_dBusInterfaceInfo = (*DBusInterfaceInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_dbus_interface_info_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_dBusInterfaceInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(intern.C))
			},
		)
	}

	return _dBusInterfaceInfo
}

// DBusPropertyInfo: information about a D-Bus property on a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusPropertyInfo struct {
	*dBusPropertyInfo
}

// dBusPropertyInfo is the struct that's finalized.
type dBusPropertyInfo struct {
	native unsafe.Pointer
}

func marshalDBusPropertyInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusPropertyInfo{&dBusPropertyInfo{(unsafe.Pointer)(b)}}, nil
}

// DBusSignalInfo: information about a signal on a D-Bus interface.
//
// An instance of this type is always passed by reference.
type DBusSignalInfo struct {
	*dBusSignalInfo
}

// dBusSignalInfo is the struct that's finalized.
type dBusSignalInfo struct {
	native unsafe.Pointer
}

func marshalDBusSignalInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &DBusSignalInfo{&dBusSignalInfo{(unsafe.Pointer)(b)}}, nil
}

// RefCount: reference count or -1 if statically allocated.
func (d *DBusSignalInfo) RefCount() int32 {
	offset := girepository.MustFind("Gio", "DBusSignalInfo").StructFieldOffset("ref_count")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Name: name of the D-Bus signal, e.g. "NameOwnerChanged".
func (d *DBusSignalInfo) Name() string {
	offset := girepository.MustFind("Gio", "DBusSignalInfo").StructFieldOffset("name")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(valptr)))
	return v
}

// Args: pointer to a NULL-terminated array of pointers to BusArgInfo structures
// or NULL if there are no arguments.
func (d *DBusSignalInfo) Args() []*DBusArgInfo {
	offset := girepository.MustFind("Gio", "DBusSignalInfo").StructFieldOffset("args")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusArgInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusArgInfo, i)
		for i := range src {
			v[i] = (*DBusArgInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_arg_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_arg_info_unref((*C.GDBusArgInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// Annotations: pointer to a NULL-terminated array of pointers to
// BusAnnotationInfo structures or NULL if there are no annotations.
func (d *DBusSignalInfo) Annotations() []*DBusAnnotationInfo {
	offset := girepository.MustFind("Gio", "DBusSignalInfo").StructFieldOffset("annotations")
	valptr := unsafe.Add(unsafe.Pointer(d), offset)
	var v []*DBusAnnotationInfo // out
	{
		var i int
		var z *C.void
		for p := valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(valptr, i)
		v = make([]*DBusAnnotationInfo, i)
		for i := range src {
			v[i] = (*DBusAnnotationInfo)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			C.g_dbus_annotation_info_ref(src[i])
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(v[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(intern.C))
				},
			)
		}
	}
	return v
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// MakeDirectoryWithParents creates a directory and any parent directories that
// may not exist similar to 'mkdir -p'. If the file system does not support
// creating directories, this function will fail, setting error to
// G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this
// function will fail setting error to G_IO_ERROR_EXISTS, unlike the similar
// g_mkdir_with_parents().
//
// For a local #GFile the newly created directories will have the default
// (current) ownership and permissions of the current process.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//
func (file *File) MakeDirectoryWithParents(ctx context.Context) error {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_file_make_directory_with_parents(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Monitor obtains a file or directory monitor for the given file, depending on
// the type of the file.
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags: set of MonitorFlags.
//
// The function returns the following values:
//
//    - fileMonitor for the given file, or NULL on error. Free the returned
//      object with g_object_unref().
//
func (file *File) Monitor(ctx context.Context, flags FileMonitorFlags) (FileMonitorrer, error) {
	var _arg0 *C.GFile            // out
	var _arg2 *C.GCancellable     // out
	var _arg1 C.GFileMonitorFlags // out
	var _cret *C.GFileMonitor     // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileMonitorFlags(flags)

	_cret = C.g_file_monitor(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileMonitor FileMonitorrer // out
	var _goerr error                // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.FileMonitorrer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FileMonitorrer)
			return ok
		})
		rv, ok := casted.(FileMonitorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.FileMonitorrer")
		}
		_fileMonitor = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileMonitor, _goerr
}

// QueryFileType: utility function to inspect the Type of a file. This is
// implemented using g_file_query_info() and as such does blocking I/O.
//
// The primary use case of this method is to check if a file is a regular file,
// directory, or symlink.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - flags: set of QueryInfoFlags passed to g_file_query_info().
//
// The function returns the following values:
//
//    - fileType of the file and FILE_TYPE_UNKNOWN if the file does not exist.
//
func (file *File) QueryFileType(ctx context.Context, flags FileQueryInfoFlags) FileType {
	var _arg0 *C.GFile              // out
	var _arg2 *C.GCancellable       // out
	var _arg1 C.GFileQueryInfoFlags // out
	var _cret C.GFileType           // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.GFileQueryInfoFlags(flags)

	_cret = C.g_file_query_file_type(_arg0, _arg1, _arg2)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _fileType FileType // out

	_fileType = FileType(_cret)

	return _fileType
}

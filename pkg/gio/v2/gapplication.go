// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// gboolean _gotk4_gio2_Application_virtual_dbus_register(void* fnptr, GApplication* arg0, GDBusConnection* arg1, gchar* arg2, GError** arg3) {
//   return ((gboolean (*)(GApplication*, GDBusConnection*, gchar*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_Application_virtual_name_lost(void* fnptr, GApplication* arg0) {
//   return ((gboolean (*)(GApplication*))(fnptr))(arg0);
// };
// gint _gotk4_gio2_Application_virtual_handle_local_options(void* fnptr, GApplication* arg0, GVariantDict* arg1) {
//   return ((gint (*)(GApplication*, GVariantDict*))(fnptr))(arg0, arg1);
// };
// int _gotk4_gio2_Application_virtual_command_line(void* fnptr, GApplication* arg0, GApplicationCommandLine* arg1) {
//   return ((int (*)(GApplication*, GApplicationCommandLine*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Application_virtual_add_platform_data(void* fnptr, GApplication* arg0, GVariantBuilder* arg1) {
//   ((void (*)(GApplication*, GVariantBuilder*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Application_virtual_after_emit(void* fnptr, GApplication* arg0, GVariant* arg1) {
//   ((void (*)(GApplication*, GVariant*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Application_virtual_before_emit(void* fnptr, GApplication* arg0, GVariant* arg1) {
//   ((void (*)(GApplication*, GVariant*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_Application_virtual_dbus_unregister(void* fnptr, GApplication* arg0, GDBusConnection* arg1, gchar* arg2) {
//   ((void (*)(GApplication*, GDBusConnection*, gchar*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_Application_virtual_quit_mainloop(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Application_virtual_run_mainloop(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Application_virtual_shutdown(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Application_virtual_startup(void* fnptr, GApplication* arg0) {
//   ((void (*)(GApplication*))(fnptr))(arg0);
// };
import "C"

// NewApplication creates a new #GApplication instance.
//
// If non-NULL, the application id must be valid. See
// g_application_id_is_valid().
//
// If no application ID is given then some features of #GApplication (most
// notably application uniqueness) will be disabled.
//
// The function takes the following parameters:
//
//    - applicationId (optional): application id.
//    - flags: application flags.
//
// The function returns the following values:
//
//    - application: new #GApplication instance.
//
func NewApplication(applicationId string, flags ApplicationFlags) *Application {
	var _arg1 *C.gchar            // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GApplication     // in

	if applicationId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GApplicationFlags(flags)

	_cret = C.g_application_new(_arg1, _arg2)
	runtime.KeepAlive(applicationId)
	runtime.KeepAlive(flags)

	var _application *Application // out

	_application = wrapApplication(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _application
}

// Hold increases the use count of application.
//
// Use this function to indicate that the application has a reason to continue
// to run. For example, g_application_hold() is called by GTK+ when a toplevel
// window is on the screen.
//
// To cancel the hold, call g_application_release().
func (application *Application) Hold() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_hold(_arg0)
	runtime.KeepAlive(application)
}

// Release: decrease the use count of application.
//
// When the use count reaches zero, the application will stop running.
//
// Never call this function except to cancel the effect of a previous call to
// g_application_hold().
func (application *Application) Release() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_release(_arg0)
	runtime.KeepAlive(application)
}

// The function takes the following parameters:
//
func (application *Application) addPlatformData(builder *glib.VariantBuilder) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.add_platform_data

	var _arg0 *C.GApplication    // out
	var _arg1 *C.GVariantBuilder // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GVariantBuilder)(gextras.StructNative(unsafe.Pointer(builder)))

	C._gotk4_gio2_Application_virtual_add_platform_data(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(builder)
}

// The function takes the following parameters:
//
func (application *Application) afterEmit(platformData *glib.Variant) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.after_emit

	var _arg0 *C.GApplication // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_Application_virtual_after_emit(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(platformData)
}

// The function takes the following parameters:
//
func (application *Application) beforeEmit(platformData *glib.Variant) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.before_emit

	var _arg0 *C.GApplication // out
	var _arg1 *C.GVariant     // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_Application_virtual_before_emit(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(platformData)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (application *Application) commandLine(commandLine *ApplicationCommandLine) int {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.command_line

	var _arg0 *C.GApplication            // out
	var _arg1 *C.GApplicationCommandLine // out
	var _cret C.int                      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GApplicationCommandLine)(unsafe.Pointer(coreglib.InternObject(commandLine).Native()))

	_cret = C._gotk4_gio2_Application_virtual_command_line(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(commandLine)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function takes the following parameters:
//
//    - connection
//    - objectPath
//
func (application *Application) dBusRegister(connection *DBusConnection, objectPath string) error {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.dbus_register

	var _arg0 *C.GApplication    // out
	var _arg1 *C.GDBusConnection // out
	var _arg2 *C.gchar           // out
	var _cerr *C.GError          // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gio2_Application_virtual_dbus_register(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(application)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function takes the following parameters:
//
//    - connection
//    - objectPath
//
func (application *Application) dBusUnregister(connection *DBusConnection, objectPath string) {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.dbus_unregister

	var _arg0 *C.GApplication    // out
	var _arg1 *C.GDBusConnection // out
	var _arg2 *C.gchar           // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GDBusConnection)(unsafe.Pointer(coreglib.InternObject(connection).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(objectPath)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gio2_Application_virtual_dbus_unregister(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(connection)
	runtime.KeepAlive(objectPath)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (application *Application) handleLocalOptions(options *glib.VariantDict) int {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.handle_local_options

	var _arg0 *C.GApplication // out
	var _arg1 *C.GVariantDict // out
	var _cret C.gint          // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GVariantDict)(gextras.StructNative(unsafe.Pointer(options)))

	_cret = C._gotk4_gio2_Application_virtual_handle_local_options(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(options)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// The function returns the following values:
//
func (application *Application) nameLost() bool {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.name_lost

	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C._gotk4_gio2_Application_virtual_name_lost(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (application *Application) quitMainloop() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.quit_mainloop

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_quit_mainloop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

func (application *Application) runMainloop() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.run_mainloop

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_run_mainloop(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

func (application *Application) shutdown() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.shutdown

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_shutdown(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

func (application *Application) startup() {
	gclass := (*C.GApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.startup

	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C._gotk4_gio2_Application_virtual_startup(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(application)
}

// ApplicationIDIsValid checks if application_id is a valid application
// identifier.
//
// A valid ID is required for calls to g_application_new() and
// g_application_set_application_id().
//
// Application identifiers follow the same format as D-Bus well-known bus names
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// For convenience, the restrictions on application identifiers are reproduced
// here:
//
// - Application identifiers are composed of 1 or more elements separated by a
// period (.) character. All elements must contain at least one character.
//
// - Each element must only contain the ASCII characters [A-Z][a-z][0-9]_-, with
// - discouraged in new application identifiers. Each element must not begin
// with a digit.
//
// - Application identifiers must contain at least one . (period) character (and
// thus at least two elements).
//
// - Application identifiers must not begin with a . (period) character.
//
// - Application identifiers must not exceed 255 characters.
//
// Note that the hyphen (-) character is allowed in application identifiers, but
// is problematic or not allowed in various specifications and APIs that refer
// to D-Bus, such as Flatpak application IDs
// (http://docs.flatpak.org/en/latest/introduction.html#identifiers), the
// DBusActivatable interface in the Desktop Entry Specification
// (https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
// and the convention that an application's "main" interface and object path
// resemble its application identifier and bus name. To avoid situations that
// require special-case handling, it is recommended that new application
// identifiers consistently replace hyphens with underscores.
//
// Like D-Bus interface names, application identifiers should start with the
// reversed DNS domain name of the author of the interface (in lower-case), and
// it is conventional for the rest of the application identifier to consist of
// words run together, with initial capital letters.
//
// As with D-Bus interface names, if the author's DNS domain name contains
// hyphen/minus characters they should be replaced by underscores, and if it
// contains leading digits they should be escaped by prepending an underscore.
// For example, if the owner of 7-zip.org used an application identifier for an
// archiving application, it might be named org._7_zip.Archiver.
//
// The function takes the following parameters:
//
//    - applicationId: potential application identifier.
//
// The function returns the following values:
//
//    - ok: TRUE if application_id is valid.
//
func ApplicationIDIsValid(applicationId string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_application_id_is_valid(_arg1)
	runtime.KeepAlive(applicationId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern gboolean _gotk4_gio2_ApplicationClass_dbus_register(GApplication*, GDBusConnection*, gchar*, GError**);
// extern gboolean _gotk4_gio2_ApplicationClass_name_lost(GApplication*);
// extern gboolean _gotk4_gio2_Application_ConnectNameLost(gpointer, guintptr);
// extern gint _gotk4_gio2_ApplicationClass_handle_local_options(GApplication*, GVariantDict*);
// extern gint _gotk4_gio2_Application_ConnectCommandLine(gpointer, GApplicationCommandLine*, guintptr);
// extern gint _gotk4_gio2_Application_ConnectHandleLocalOptions(gpointer, GVariantDict*, guintptr);
// extern int _gotk4_gio2_ApplicationClass_command_line(GApplication*, GApplicationCommandLine*);
// extern void _gotk4_gio2_ApplicationClass_activate(GApplication*);
// extern void _gotk4_gio2_ApplicationClass_add_platform_data(GApplication*, GVariantBuilder*);
// extern void _gotk4_gio2_ApplicationClass_after_emit(GApplication*, GVariant*);
// extern void _gotk4_gio2_ApplicationClass_before_emit(GApplication*, GVariant*);
// extern void _gotk4_gio2_ApplicationClass_dbus_unregister(GApplication*, GDBusConnection*, gchar*);
// extern void _gotk4_gio2_ApplicationClass_open(GApplication*, GFile**, gint, gchar*);
// extern void _gotk4_gio2_ApplicationClass_quit_mainloop(GApplication*);
// extern void _gotk4_gio2_ApplicationClass_run_mainloop(GApplication*);
// extern void _gotk4_gio2_ApplicationClass_shutdown(GApplication*);
// extern void _gotk4_gio2_ApplicationClass_startup(GApplication*);
// extern void _gotk4_gio2_Application_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gio2_Application_ConnectOpen(gpointer, GFile**, gint, gchar*, guintptr);
// extern void _gotk4_gio2_Application_ConnectShutdown(gpointer, guintptr);
// extern void _gotk4_gio2_Application_ConnectStartup(gpointer, guintptr);
import "C"

// GTypeApplication returns the GType for the type Application.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeApplication() coreglib.Type {
	gtype := coreglib.Type(C.g_application_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalApplication)
	return gtype
}

// ApplicationOverrider contains methods that are overridable.
type ApplicationOverrider interface {
	// Activate activates the application.
	//
	// In essence, this results in the #GApplication::activate signal being
	// emitted in the primary instance.
	//
	// The application must be registered before calling this function.
	Activate()
	// The function takes the following parameters:
	//
	AddPlatformData(builder *glib.VariantBuilder)
	// The function takes the following parameters:
	//
	AfterEmit(platformData *glib.Variant)
	// The function takes the following parameters:
	//
	BeforeEmit(platformData *glib.Variant)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	CommandLine(commandLine *ApplicationCommandLine) int32
	// The function takes the following parameters:
	//
	//    - connection
	//    - objectPath
	//
	DBusRegister(connection *DBusConnection, objectPath string) error
	// The function takes the following parameters:
	//
	//    - connection
	//    - objectPath
	//
	DBusUnregister(connection *DBusConnection, objectPath string)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	HandleLocalOptions(options *glib.VariantDict) int32
	// The function returns the following values:
	//
	NameLost() bool
	// Open opens the given files.
	//
	// In essence, this results in the #GApplication::open signal being emitted
	// in the primary instance.
	//
	// n_files must be greater than zero.
	//
	// hint is simply passed through to the ::open signal. It is intended to be
	// used by applications that have multiple modes for opening files (eg:
	// "view" vs "edit", etc). Unless you have a need for this functionality,
	// you should use "".
	//
	// The application must be registered before calling this function and it
	// must have the G_APPLICATION_HANDLES_OPEN flag set.
	//
	// The function takes the following parameters:
	//
	//    - files: array of #GFiles to open.
	//    - hint (or ""), but never NULL.
	//
	Open(files []Filer, hint string)
	QuitMainloop()
	RunMainloop()
	Shutdown()
	Startup()
}

// Application is the foundation of an application. It wraps some low-level
// platform-specific services and is intended to act as the foundation for
// higher-level application classes such as Application or Application. In
// general, you should not use this class outside of a higher level framework.
//
// GApplication provides convenient life cycle management by maintaining a "use
// count" for the primary application instance. The use count can be changed
// using g_application_hold() and g_application_release(). If it drops to zero,
// the application exits. Higher-level classes such as Application employ the
// use count to ensure that the application stays alive as long as it has any
// opened windows.
//
// Another feature that GApplication (optionally) provides is process
// uniqueness. Applications can make use of this functionality by providing a
// unique application ID. If given, only one application with this ID can be
// running at a time per session. The session concept is platform-dependent, but
// corresponds roughly to a graphical desktop login. When your application is
// launched again, its arguments are passed through platform communication to
// the already running program. The already running instance of the program is
// called the "primary instance"; for non-unique applications this is always the
// current instance. On Linux, the D-Bus session bus is used for communication.
//
// The use of #GApplication differs from some other commonly-used uniqueness
// libraries (such as libunique) in important ways. The application is not
// expected to manually register itself and check if it is the primary instance.
// Instead, the main() function of a #GApplication should do very little more
// than instantiating the application instance, possibly connecting signal
// handlers, then calling g_application_run(). All checks for uniqueness are
// done internally. If the application is the primary instance then the startup
// signal is emitted and the mainloop runs. If the application is not the
// primary instance then a signal is sent to the primary instance and
// g_application_run() promptly returns. See the code examples below.
//
// If used, the expected form of an application identifier is the same as that
// of of a D-Bus well-known bus name
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// Examples include: com.example.MyApp, org.example.internal_apps.Calculator,
// org._7_zip.Archiver. For details on valid application identifiers, see
// g_application_id_is_valid().
//
// On Linux, the application identifier is claimed as a well-known bus name on
// the user's session bus. This means that the uniqueness of your application is
// scoped to the current session. It also means that your application may
// provide additional services (through registration of other object paths) at
// that bus name. The registration of these object paths should be done with the
// shared GDBus session bus. Note that due to the internal architecture of
// GDBus, method calls can be dispatched at any time (even if a main loop is not
// running). For this reason, you must ensure that any object paths that you
// wish to register are registered before #GApplication attempts to acquire the
// bus name of your application (which happens in g_application_register()).
// Unfortunately, this means that you cannot use g_application_get_is_remote()
// to decide if you want to register object paths.
//
// GApplication also implements the Group and Map interfaces and lets you easily
// export actions by adding them with g_action_map_add_action(). When invoking
// an action by calling g_action_group_activate_action() on the application, it
// is always invoked in the primary instance. The actions are also exported on
// the session bus, and GIO provides the BusActionGroup wrapper to conveniently
// access them remotely. GIO provides a BusMenuModel wrapper for remote access
// to exported Models.
//
// There is a number of different entry points into a GApplication:
//
// - via 'Activate' (i.e. just starting the application)
//
// - via 'Open' (i.e. opening some files)
//
// - by handling a command-line
//
// - via activating an action
//
// The #GApplication::startup signal lets you handle the application
// initialization for all of these in a single place.
//
// Regardless of which of these entry points is used to start the application,
// GApplication passes some ‘platform data’ from the launching instance to the
// primary instance, in the form of a #GVariant dictionary mapping strings to
// variants. To use platform data, override the before_emit or after_emit
// virtual functions in your #GApplication subclass. When dealing with
// CommandLine objects, the platform data is directly available via
// g_application_command_line_get_cwd(),
// g_application_command_line_get_environ() and
// g_application_command_line_get_platform_data().
//
// As the name indicates, the platform data may vary depending on the operating
// system, but it always includes the current directory (key "cwd"), and
// optionally the environment (ie the set of environment variables and their
// values) of the calling process (key "environ"). The environment is only added
// to the platform data if the G_APPLICATION_SEND_ENVIRONMENT flag is set.
// #GApplication subclasses can add their own platform data by overriding the
// add_platform_data virtual function. For instance, Application adds startup
// notification data in this way.
//
// To parse commandline arguments you may handle the #GApplication::command-line
// signal or override the local_command_line() vfunc, to parse them in either
// the primary instance or the local instance, respectively.
//
// For an example of opening files with a GApplication, see
// gapplication-example-open.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).
//
// For an example of using actions with GApplication, see
// gapplication-example-actions.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).
//
// For an example of using extra D-Bus hooks with GApplication, see
// gapplication-example-dbushooks.c
// (https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).
type Application struct {
	_ [0]func() // equal guard
	*coreglib.Object

	ActionGroup
	ActionMap
}

var (
	_ coreglib.Objector = (*Application)(nil)
)

func classInitApplicationer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GApplicationClass)(unsafe.Pointer(gclassPtr))

	if _, ok := goval.(interface{ Activate() }); ok {
		pclass.activate = (*[0]byte)(C._gotk4_gio2_ApplicationClass_activate)
	}

	if _, ok := goval.(interface {
		AddPlatformData(builder *glib.VariantBuilder)
	}); ok {
		pclass.add_platform_data = (*[0]byte)(C._gotk4_gio2_ApplicationClass_add_platform_data)
	}

	if _, ok := goval.(interface {
		AfterEmit(platformData *glib.Variant)
	}); ok {
		pclass.after_emit = (*[0]byte)(C._gotk4_gio2_ApplicationClass_after_emit)
	}

	if _, ok := goval.(interface {
		BeforeEmit(platformData *glib.Variant)
	}); ok {
		pclass.before_emit = (*[0]byte)(C._gotk4_gio2_ApplicationClass_before_emit)
	}

	if _, ok := goval.(interface {
		CommandLine(commandLine *ApplicationCommandLine) int32
	}); ok {
		pclass.command_line = (*[0]byte)(C._gotk4_gio2_ApplicationClass_command_line)
	}

	if _, ok := goval.(interface {
		DBusRegister(connection *DBusConnection, objectPath string) error
	}); ok {
		pclass.dbus_register = (*[0]byte)(C._gotk4_gio2_ApplicationClass_dbus_register)
	}

	if _, ok := goval.(interface {
		DBusUnregister(connection *DBusConnection, objectPath string)
	}); ok {
		pclass.dbus_unregister = (*[0]byte)(C._gotk4_gio2_ApplicationClass_dbus_unregister)
	}

	if _, ok := goval.(interface {
		HandleLocalOptions(options *glib.VariantDict) int32
	}); ok {
		pclass.handle_local_options = (*[0]byte)(C._gotk4_gio2_ApplicationClass_handle_local_options)
	}

	if _, ok := goval.(interface{ NameLost() bool }); ok {
		pclass.name_lost = (*[0]byte)(C._gotk4_gio2_ApplicationClass_name_lost)
	}

	if _, ok := goval.(interface {
		Open(files []Filer, hint string)
	}); ok {
		pclass.open = (*[0]byte)(C._gotk4_gio2_ApplicationClass_open)
	}

	if _, ok := goval.(interface{ QuitMainloop() }); ok {
		pclass.quit_mainloop = (*[0]byte)(C._gotk4_gio2_ApplicationClass_quit_mainloop)
	}

	if _, ok := goval.(interface{ RunMainloop() }); ok {
		pclass.run_mainloop = (*[0]byte)(C._gotk4_gio2_ApplicationClass_run_mainloop)
	}

	if _, ok := goval.(interface{ Shutdown() }); ok {
		pclass.shutdown = (*[0]byte)(C._gotk4_gio2_ApplicationClass_shutdown)
	}

	if _, ok := goval.(interface{ Startup() }); ok {
		pclass.startup = (*[0]byte)(C._gotk4_gio2_ApplicationClass_startup)
	}
}

//export _gotk4_gio2_ApplicationClass_activate
func _gotk4_gio2_ApplicationClass_activate(arg0 *C.GApplication) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Activate() })

	iface.Activate()
}

//export _gotk4_gio2_ApplicationClass_add_platform_data
func _gotk4_gio2_ApplicationClass_add_platform_data(arg0 *C.GApplication, arg1 *C.GVariantBuilder) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		AddPlatformData(builder *glib.VariantBuilder)
	})

	var _builder *glib.VariantBuilder // out

	_builder = (*glib.VariantBuilder)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_builder_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_builder)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	iface.AddPlatformData(_builder)
}

//export _gotk4_gio2_ApplicationClass_after_emit
func _gotk4_gio2_ApplicationClass_after_emit(arg0 *C.GApplication, arg1 *C.GVariant) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		AfterEmit(platformData *glib.Variant)
	})

	var _platformData *glib.Variant // out

	_platformData = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_platformData)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	iface.AfterEmit(_platformData)
}

//export _gotk4_gio2_ApplicationClass_before_emit
func _gotk4_gio2_ApplicationClass_before_emit(arg0 *C.GApplication, arg1 *C.GVariant) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		BeforeEmit(platformData *glib.Variant)
	})

	var _platformData *glib.Variant // out

	_platformData = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_platformData)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	iface.BeforeEmit(_platformData)
}

//export _gotk4_gio2_ApplicationClass_command_line
func _gotk4_gio2_ApplicationClass_command_line(arg0 *C.GApplication, arg1 *C.GApplicationCommandLine) (cret C.int) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		CommandLine(commandLine *ApplicationCommandLine) int32
	})

	var _commandLine *ApplicationCommandLine // out

	_commandLine = wrapApplicationCommandLine(coreglib.Take(unsafe.Pointer(arg1)))

	gint := iface.CommandLine(_commandLine)

	cret = C.int(gint)

	return cret
}

//export _gotk4_gio2_ApplicationClass_dbus_register
func _gotk4_gio2_ApplicationClass_dbus_register(arg0 *C.GApplication, arg1 *C.GDBusConnection, arg2 *C.gchar, _cerr **C.GError) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DBusRegister(connection *DBusConnection, objectPath string) error
	})

	var _connection *DBusConnection // out
	var _objectPath string          // out

	_connection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(arg1)))
	_objectPath = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	_goerr := iface.DBusRegister(_connection, _objectPath)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ApplicationClass_dbus_unregister
func _gotk4_gio2_ApplicationClass_dbus_unregister(arg0 *C.GApplication, arg1 *C.GDBusConnection, arg2 *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DBusUnregister(connection *DBusConnection, objectPath string)
	})

	var _connection *DBusConnection // out
	var _objectPath string          // out

	_connection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(arg1)))
	_objectPath = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	iface.DBusUnregister(_connection, _objectPath)
}

//export _gotk4_gio2_ApplicationClass_handle_local_options
func _gotk4_gio2_ApplicationClass_handle_local_options(arg0 *C.GApplication, arg1 *C.GVariantDict) (cret C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		HandleLocalOptions(options *glib.VariantDict) int32
	})

	var _options *glib.VariantDict // out

	_options = (*glib.VariantDict)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_dict_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	gint := iface.HandleLocalOptions(_options)

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gio2_ApplicationClass_name_lost
func _gotk4_gio2_ApplicationClass_name_lost(arg0 *C.GApplication) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ NameLost() bool })

	ok := iface.NameLost()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_ApplicationClass_open
func _gotk4_gio2_ApplicationClass_open(arg0 *C.GApplication, arg1 **C.GFile, arg2 C.gint, arg3 *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Open(files []Filer, hint string)
	})

	var _files []Filer // out
	var _hint string   // out

	{
		src := unsafe.Slice((**C.GFile)(arg1), arg2)
		_files = make([]Filer, arg2)
		for i := 0; i < int(arg2); i++ {
			{
				objptr := unsafe.Pointer(src[i])
				if objptr == nil {
					panic("object of type gio.Filer is nil")
				}

				object := coreglib.Take(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(Filer)
					return ok
				})
				rv, ok := casted.(Filer)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
				}
				_files[i] = rv
			}
		}
	}
	_hint = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	iface.Open(_files, _hint)
}

//export _gotk4_gio2_ApplicationClass_quit_mainloop
func _gotk4_gio2_ApplicationClass_quit_mainloop(arg0 *C.GApplication) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ QuitMainloop() })

	iface.QuitMainloop()
}

//export _gotk4_gio2_ApplicationClass_run_mainloop
func _gotk4_gio2_ApplicationClass_run_mainloop(arg0 *C.GApplication) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ RunMainloop() })

	iface.RunMainloop()
}

//export _gotk4_gio2_ApplicationClass_shutdown
func _gotk4_gio2_ApplicationClass_shutdown(arg0 *C.GApplication) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Shutdown() })

	iface.Shutdown()
}

//export _gotk4_gio2_ApplicationClass_startup
func _gotk4_gio2_ApplicationClass_startup(arg0 *C.GApplication) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Startup() })

	iface.Startup()
}

func wrapApplication(obj *coreglib.Object) *Application {
	return &Application{
		Object: obj,
		ActionGroup: ActionGroup{
			Object: obj,
		},
		ActionMap: ActionMap{
			Object: obj,
		},
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	return wrapApplication(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gio2_Application_ConnectActivate
func _gotk4_gio2_Application_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivate signal is emitted on the primary instance when an activation
// occurs. See g_application_activate().
func (application *Application) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "activate", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectActivate), f)
}

//export _gotk4_gio2_Application_ConnectCommandLine
func _gotk4_gio2_Application_ConnectCommandLine(arg0 C.gpointer, arg1 *C.GApplicationCommandLine, arg2 C.guintptr) (cret C.gint) {
	var f func(commandLine *ApplicationCommandLine) (gint int32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(commandLine *ApplicationCommandLine) (gint int32))
	}

	var _commandLine *ApplicationCommandLine // out

	_commandLine = wrapApplicationCommandLine(coreglib.Take(unsafe.Pointer(arg1)))

	gint := f(_commandLine)

	cret = C.gint(gint)

	return cret
}

// ConnectCommandLine signal is emitted on the primary instance when a
// commandline is not handled locally. See g_application_run() and the
// CommandLine documentation for more information.
func (application *Application) ConnectCommandLine(f func(commandLine *ApplicationCommandLine) (gint int32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "command-line", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectCommandLine), f)
}

//export _gotk4_gio2_Application_ConnectHandleLocalOptions
func _gotk4_gio2_Application_ConnectHandleLocalOptions(arg0 C.gpointer, arg1 *C.GVariantDict, arg2 C.guintptr) (cret C.gint) {
	var f func(options *glib.VariantDict) (gint int32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(options *glib.VariantDict) (gint int32))
	}

	var _options *glib.VariantDict // out

	_options = (*glib.VariantDict)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_dict_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	gint := f(_options)

	cret = C.gint(gint)

	return cret
}

// ConnectHandleLocalOptions signal is emitted on the local instance after the
// parsing of the commandline options has occurred.
//
// You can add options to be recognised during commandline option parsing using
// g_application_add_main_option_entries() and g_application_add_option_group().
//
// Signal handlers can inspect options (along with values pointed to from the
// arg_data of an installed Entrys) in order to decide to perform certain
// actions, including direct local handling (which may be useful for options
// like --version).
//
// In the event that the application is marked
// G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will send the
// options dictionary to the primary instance where it can be read with
// g_application_command_line_get_options_dict(). The signal handler can modify
// the dictionary before returning, and the modified dictionary will be sent.
//
// In the event that G_APPLICATION_HANDLES_COMMAND_LINE is not set, "normal
// processing" will treat the remaining uncollected command line arguments as
// filenames or URIs. If there are no arguments, the application is activated by
// g_application_activate(). One or more arguments results in a call to
// g_application_open().
//
// If you want to handle the local commandline arguments for yourself by
// converting them to calls to g_application_open() or
// g_action_group_activate_action() then you must be sure to register the
// application first. You should probably not call g_application_activate() for
// yourself, however: just return -1 and allow the default handler to do it for
// you. This will ensure that the --gapplication-service switch works properly
// (i.e. no activation in that case).
//
// Note that this signal is emitted from the default implementation of
// local_command_line(). If you override that function and don't chain up then
// this signal will never be emitted.
//
// You can override local_command_line() if you need more powerful capabilities
// than what is provided here, but this should not normally be required.
func (application *Application) ConnectHandleLocalOptions(f func(options *glib.VariantDict) (gint int32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "handle-local-options", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectHandleLocalOptions), f)
}

//export _gotk4_gio2_Application_ConnectNameLost
func _gotk4_gio2_Application_ConnectNameLost(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectNameLost signal is emitted only on the registered primary instance
// when a new instance has taken over. This can only happen if the application
// is using the G_APPLICATION_ALLOW_REPLACEMENT flag.
//
// The default handler for this signal calls g_application_quit().
func (application *Application) ConnectNameLost(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "name-lost", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectNameLost), f)
}

//export _gotk4_gio2_Application_ConnectOpen
func _gotk4_gio2_Application_ConnectOpen(arg0 C.gpointer, arg1 **C.GFile, arg2 C.gint, arg3 *C.gchar, arg4 C.guintptr) {
	var f func(files []Filer, hint string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(files []Filer, hint string))
	}

	var _files []Filer // out
	var _hint string   // out

	{
		src := unsafe.Slice((**C.GFile)(arg1), arg2)
		_files = make([]Filer, arg2)
		for i := 0; i < int(arg2); i++ {
			{
				objptr := unsafe.Pointer(src[i])
				if objptr == nil {
					panic("object of type gio.Filer is nil")
				}

				object := coreglib.Take(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(Filer)
					return ok
				})
				rv, ok := casted.(Filer)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Filer")
				}
				_files[i] = rv
			}
		}
	}
	_hint = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	f(_files, _hint)
}

// ConnectOpen signal is emitted on the primary instance when there are files to
// open. See g_application_open() for more information.
func (application *Application) ConnectOpen(f func(files []Filer, hint string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "open", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectOpen), f)
}

//export _gotk4_gio2_Application_ConnectShutdown
func _gotk4_gio2_Application_ConnectShutdown(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectShutdown signal is emitted only on the registered primary instance
// immediately after the main loop terminates.
func (application *Application) ConnectShutdown(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "shutdown", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectShutdown), f)
}

//export _gotk4_gio2_Application_ConnectStartup
func _gotk4_gio2_Application_ConnectStartup(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectStartup signal is emitted on the primary instance immediately after
// registration. See g_application_register().
func (application *Application) ConnectStartup(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "startup", false, unsafe.Pointer(C._gotk4_gio2_Application_ConnectStartup), f)
}

// NewApplication creates a new #GApplication instance.
//
// If non-NULL, the application id must be valid. See
// g_application_id_is_valid().
//
// If no application ID is given then some features of #GApplication (most
// notably application uniqueness) will be disabled.
//
// The function takes the following parameters:
//
//    - applicationId (optional): application id.
//    - flags: application flags.
//
// The function returns the following values:
//
//    - application: new #GApplication instance.
//
func NewApplication(applicationId string, flags ApplicationFlags) *Application {
	var _arg1 *C.gchar            // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GApplication     // in

	if applicationId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GApplicationFlags(flags)

	_cret = C.g_application_new(_arg1, _arg2)
	runtime.KeepAlive(applicationId)
	runtime.KeepAlive(flags)

	var _application *Application // out

	_application = wrapApplication(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _application
}

// Activate activates the application.
//
// In essence, this results in the #GApplication::activate signal being emitted
// in the primary instance.
//
// The application must be registered before calling this function.
func (application *Application) Activate() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_activate(_arg0)
	runtime.KeepAlive(application)
}

// AddMainOption: add an option to be handled by application.
//
// Calling this function is the equivalent of calling
// g_application_add_main_option_entries() with a single Entry that has its
// arg_data member set to NULL.
//
// The parsed arguments will be packed into a Dict which is passed to
// #GApplication::handle-local-options. If G_APPLICATION_HANDLES_COMMAND_LINE is
// set, then it will also be sent to the primary instance. See
// g_application_add_main_option_entries() for more details.
//
// See Entry for more documentation of the arguments.
//
// The function takes the following parameters:
//
//    - longName: long name of an option used to specify it in a commandline.
//    - shortName: short name of an option.
//    - flags from Flags.
//    - arg: type of the option, as a Arg.
//    - description for the option in --help output.
//    - argDescription (optional): placeholder to use for the extra argument
//      parsed by the option in --help output.
//
func (application *Application) AddMainOption(longName string, shortName byte, flags glib.OptionFlags, arg glib.OptionArg, description, argDescription string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.char         // out
	var _arg2 C.char          // out
	var _arg3 C.GOptionFlags  // out
	var _arg4 C.GOptionArg    // out
	var _arg5 *C.char         // out
	var _arg6 *C.char         // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(longName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.char(shortName)
	_arg3 = C.GOptionFlags(flags)
	_arg4 = C.GOptionArg(arg)
	_arg5 = (*C.char)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg5))
	if argDescription != "" {
		_arg6 = (*C.char)(unsafe.Pointer(C.CString(argDescription)))
		defer C.free(unsafe.Pointer(_arg6))
	}

	C.g_application_add_main_option(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(application)
	runtime.KeepAlive(longName)
	runtime.KeepAlive(shortName)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(arg)
	runtime.KeepAlive(description)
	runtime.KeepAlive(argDescription)
}

// AddMainOptionEntries adds main option entries to be handled by application.
//
// This function is comparable to g_option_context_add_main_entries().
//
// After the commandline arguments are parsed, the
// #GApplication::handle-local-options signal will be emitted. At this point,
// the application can inspect the values pointed to by arg_data in the given
// Entrys.
//
// Unlike Context, #GApplication supports giving a NULL arg_data for a
// non-callback Entry. This results in the argument in question being packed
// into a Dict which is also passed to #GApplication::handle-local-options,
// where it can be inspected and modified. If G_APPLICATION_HANDLES_COMMAND_LINE
// is set, then the resulting dictionary is sent to the primary instance, where
// g_application_command_line_get_options_dict() will return it. This "packing"
// is done according to the type of the argument -- booleans for normal flags,
// strings for strings, bytestrings for filenames, etc. The packing only occurs
// if the flag is given (ie: we do not pack a "false" #GVariant in the case that
// a flag is missing).
//
// In general, it is recommended that all commandline arguments are parsed
// locally. The options dictionary should then be used to transmit the result of
// the parsing to the primary instance, where g_variant_dict_lookup() can be
// used. For local options, it is possible to either use arg_data in the usual
// way, or to consult (and potentially remove) the option from the options
// dictionary.
//
// This function is new in GLib 2.40. Before then, the only real choice was to
// send all of the commandline arguments (options and all) to the primary
// instance for handling. #GApplication ignored them completely on the local
// side. Calling this function "opts in" to the new behaviour, and in
// particular, means that unrecognised options will be treated as errors.
// Unrecognised options have never been ignored when
// G_APPLICATION_HANDLES_COMMAND_LINE is unset.
//
// If #GApplication::handle-local-options needs to see the list of filenames,
// then the use of G_OPTION_REMAINING is recommended. If arg_data is NULL then
// G_OPTION_REMAINING can be used as a key into the options dictionary. If you
// do use G_OPTION_REMAINING then you need to handle these arguments for
// yourself because once they are consumed, they will no longer be visible to
// the default handling (which treats them as filenames to be opened).
//
// It is important to use the proper GVariant format when retrieving the options
// with g_variant_dict_lookup():
//
// - for G_OPTION_ARG_NONE, use b
//
// - for G_OPTION_ARG_STRING, use &s
//
// - for G_OPTION_ARG_INT, use i
//
// - for G_OPTION_ARG_INT64, use x
//
// - for G_OPTION_ARG_DOUBLE, use d
//
// - for G_OPTION_ARG_FILENAME, use ^&ay
//
// - for G_OPTION_ARG_STRING_ARRAY, use ^a&s
//
// - for G_OPTION_ARG_FILENAME_ARRAY, use ^a&ay.
//
// The function takes the following parameters:
//
//    - entries: a NULL-terminated list of Entrys.
//
func (application *Application) AddMainOptionEntries(entries []glib.OptionEntry) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GOptionEntry // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	{
		_arg1 = (*C.GOptionEntry)(C.calloc(C.size_t((len(entries) + 1)), C.size_t(C.sizeof_GOptionEntry)))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(entries)+1)
			var zero C.GOptionEntry
			out[len(entries)] = zero
			for i := range entries {
				out[i] = *(*C.GOptionEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
			}
		}
	}

	C.g_application_add_main_option_entries(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(entries)
}

// AddOptionGroup adds a Group to the commandline handling of application.
//
// This function is comparable to g_option_context_add_group().
//
// Unlike g_application_add_main_option_entries(), this function does not deal
// with NULL arg_data and never transmits options to the primary instance.
//
// The reason for that is because, by the time the options arrive at the primary
// instance, it is typically too late to do anything with them. Taking the GTK
// option group as an example: GTK will already have been initialised by the
// time the #GApplication::command-line handler runs. In the case that this is
// not the first-running instance of the application, the existing instance may
// already have been running for a very long time.
//
// This means that the options from Group are only really usable in the case
// that the instance of the application being run is the first instance. Passing
// options like --display= or --gdk-debug= on future runs will have no effect on
// the existing primary instance.
//
// Calling this function will cause the options in the supplied option group to
// be parsed, but it does not cause you to be "opted in" to the new
// functionality whereby unrecognised options are rejected even if
// G_APPLICATION_HANDLES_COMMAND_LINE was given.
//
// The function takes the following parameters:
//
//    - group: Group.
//
func (application *Application) AddOptionGroup(group *glib.OptionGroup) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GOptionGroup // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GOptionGroup)(gextras.StructNative(unsafe.Pointer(group)))

	C.g_application_add_option_group(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(group)
}

// BindBusyProperty marks application as busy (see g_application_mark_busy())
// while property on object is TRUE.
//
// The binding holds a reference to application while it is active, but not to
// object. Instead, the binding is destroyed when object is finalized.
//
// The function takes the following parameters:
//
//    - object: #GObject.
//    - property: name of a boolean property of object.
//
func (application *Application) BindBusyProperty(object *coreglib.Object, property string) {
	var _arg0 *C.GApplication // out
	var _arg1 C.gpointer      // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_application_bind_busy_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(object)
	runtime.KeepAlive(property)
}

// ApplicationID gets the unique identifier for application.
//
// The function returns the following values:
//
//    - utf8 (optional): identifier for application, owned by application.
//
func (application *Application) ApplicationID() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_application_id(_arg0)
	runtime.KeepAlive(application)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DBusConnection gets the BusConnection being used by the application, or NULL.
//
// If #GApplication is using its D-Bus backend then this function will return
// the BusConnection being used for uniqueness and communication with the
// desktop environment and other instances of the application.
//
// If #GApplication is not using D-Bus then this function will return NULL. This
// includes the situation where the D-Bus backend would normally be in use but
// we were unable to connect to the bus.
//
// This function must not be called before the application has been registered.
// See g_application_get_is_registered().
//
// The function returns the following values:
//
//    - dBusConnection (optional) or NULL.
//
func (application *Application) DBusConnection() *DBusConnection {
	var _arg0 *C.GApplication    // out
	var _cret *C.GDBusConnection // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_dbus_connection(_arg0)
	runtime.KeepAlive(application)

	var _dBusConnection *DBusConnection // out

	if _cret != nil {
		_dBusConnection = wrapDBusConnection(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _dBusConnection
}

// DBusObjectPath gets the D-Bus object path being used by the application, or
// NULL.
//
// If #GApplication is using its D-Bus backend then this function will return
// the D-Bus object path that #GApplication is using. If the application is the
// primary instance then there is an object published at this path. If the
// application is not the primary instance then the result of this function is
// undefined.
//
// If #GApplication is not using D-Bus then this function will return NULL. This
// includes the situation where the D-Bus backend would normally be in use but
// we were unable to connect to the bus.
//
// This function must not be called before the application has been registered.
// See g_application_get_is_registered().
//
// The function returns the following values:
//
//    - utf8 (optional): object path, or NULL.
//
func (application *Application) DBusObjectPath() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_dbus_object_path(_arg0)
	runtime.KeepAlive(application)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Flags gets the flags for application.
//
// See Flags.
//
// The function returns the following values:
//
//    - applicationFlags flags for application.
//
func (application *Application) Flags() ApplicationFlags {
	var _arg0 *C.GApplication     // out
	var _cret C.GApplicationFlags // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_flags(_arg0)
	runtime.KeepAlive(application)

	var _applicationFlags ApplicationFlags // out

	_applicationFlags = ApplicationFlags(_cret)

	return _applicationFlags
}

// InactivityTimeout gets the current inactivity timeout for the application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
//
// The function returns the following values:
//
//    - guint: timeout, in milliseconds.
//
func (application *Application) InactivityTimeout() uint32 {
	var _arg0 *C.GApplication // out
	var _cret C.guint         // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_inactivity_timeout(_arg0)
	runtime.KeepAlive(application)

	var _guint uint32 // out

	_guint = uint32(_cret)

	return _guint
}

// IsBusy gets the application's current busy state, as set through
// g_application_mark_busy() or g_application_bind_busy_property().
//
// The function returns the following values:
//
//    - ok: TRUE if application is currently marked as busy.
//
func (application *Application) IsBusy() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_is_busy(_arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRegistered checks if application is registered.
//
// An application is registered if g_application_register() has been
// successfully called.
//
// The function returns the following values:
//
//    - ok: TRUE if application is registered.
//
func (application *Application) IsRegistered() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_is_registered(_arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRemote checks if application is remote.
//
// If application is remote then it means that another instance of application
// already exists (the 'primary' instance). Calls to perform actions on
// application will result in the actions being performed by the primary
// instance.
//
// The value of this property cannot be accessed before g_application_register()
// has been called. See g_application_get_is_registered().
//
// The function returns the following values:
//
//    - ok: TRUE if application is remote.
//
func (application *Application) IsRemote() bool {
	var _arg0 *C.GApplication // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_is_remote(_arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResourceBasePath gets the resource base path of application.
//
// See g_application_set_resource_base_path() for more information.
//
// The function returns the following values:
//
//    - utf8 (optional): base resource path, if one is set.
//
func (application *Application) ResourceBasePath() string {
	var _arg0 *C.GApplication // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.g_application_get_resource_base_path(_arg0)
	runtime.KeepAlive(application)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Hold increases the use count of application.
//
// Use this function to indicate that the application has a reason to continue
// to run. For example, g_application_hold() is called by GTK+ when a toplevel
// window is on the screen.
//
// To cancel the hold, call g_application_release().
func (application *Application) Hold() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_hold(_arg0)
	runtime.KeepAlive(application)
}

// MarkBusy increases the busy count of application.
//
// Use this function to indicate that the application is busy, for instance
// while a long running operation is pending.
//
// The busy state will be exposed to other processes, so a session shell will
// use that information to indicate the state to the user (e.g. with a spinner).
//
// To cancel the busy indication, use g_application_unmark_busy().
func (application *Application) MarkBusy() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_mark_busy(_arg0)
	runtime.KeepAlive(application)
}

// Open opens the given files.
//
// In essence, this results in the #GApplication::open signal being emitted in
// the primary instance.
//
// n_files must be greater than zero.
//
// hint is simply passed through to the ::open signal. It is intended to be used
// by applications that have multiple modes for opening files (eg: "view" vs
// "edit", etc). Unless you have a need for this functionality, you should use
// "".
//
// The application must be registered before calling this function and it must
// have the G_APPLICATION_HANDLES_OPEN flag set.
//
// The function takes the following parameters:
//
//    - files: array of #GFiles to open.
//    - hint (or ""), but never NULL.
//
func (application *Application) Open(files []Filer, hint string) {
	var _arg0 *C.GApplication // out
	var _arg1 **C.GFile       // out
	var _arg2 C.gint
	var _arg3 *C.gchar // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg2 = (C.gint)(len(files))
	_arg1 = (**C.GFile)(C.calloc(C.size_t(len(files)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GFile)(_arg1), len(files))
		for i := range files {
			out[i] = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(files[i]).Native()))
		}
	}
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(hint)))
	defer C.free(unsafe.Pointer(_arg3))

	C.g_application_open(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(files)
	runtime.KeepAlive(hint)
}

// Quit: immediately quits the application.
//
// Upon return to the mainloop, g_application_run() will return, calling only
// the 'shutdown' function before doing so.
//
// The hold count is ignored. Take care if your code has called
// g_application_hold() on the application and is therefore still expecting it
// to exist. (Note that you may have called g_application_hold() indirectly, for
// example through gtk_application_add_window().)
//
// The result of calling g_application_run() again after it returns is
// unspecified.
func (application *Application) Quit() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_quit(_arg0)
	runtime.KeepAlive(application)
}

// Register attempts registration of the application.
//
// This is the point at which the application discovers if it is the primary
// instance or merely acting as a remote for an already-existing primary
// instance. This is implemented by attempting to acquire the application
// identifier as a unique bus name on the session bus using GDBus.
//
// If there is no application ID or if G_APPLICATION_NON_UNIQUE was given, then
// this process will always become the primary instance.
//
// Due to the internal architecture of GDBus, method calls can be dispatched at
// any time (even if a main loop is not running). For this reason, you must
// ensure that any object paths that you wish to register are registered before
// calling this function.
//
// If the application has already been registered then TRUE is returned with no
// work performed.
//
// The #GApplication::startup signal is emitted if registration succeeds and
// application is the primary instance (including the non-unique case).
//
// In the event of an error (such as cancellable being cancelled, or a failure
// to connect to the session bus), FALSE is returned and error is set
// appropriately.
//
// Note: the return value of this function is not an indicator that this
// instance is or is not the primary instance of the application. See
// g_application_get_is_remote() for that.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//
func (application *Application) Register(ctx context.Context) error {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GCancellable // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.g_application_register(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(application)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Release: decrease the use count of application.
//
// When the use count reaches zero, the application will stop running.
//
// Never call this function except to cancel the effect of a previous call to
// g_application_hold().
func (application *Application) Release() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_release(_arg0)
	runtime.KeepAlive(application)
}

// Run runs the application.
//
// This function is intended to be run from main() and its return value is
// intended to be returned by main(). Although you are expected to pass the
// argc, argv parameters from main() to this function, it is possible to pass
// NULL if argv is not available or commandline handling is not required. Note
// that on Windows, argc and argv are ignored, and g_win32_get_command_line() is
// called internally (for proper support of Unicode commandline arguments).
//
// #GApplication will attempt to parse the commandline arguments. You can add
// commandline flags to the list of recognised options by way of
// g_application_add_main_option_entries(). After this, the
// #GApplication::handle-local-options signal is emitted, from which the
// application can inspect the values of its Entrys.
//
// #GApplication::handle-local-options is a good place to handle options such as
// --version, where an immediate reply from the local process is desired
// (instead of communicating with an already-running instance). A
// #GApplication::handle-local-options handler can stop further processing by
// returning a non-negative value, which then becomes the exit status of the
// process.
//
// What happens next depends on the flags: if G_APPLICATION_HANDLES_COMMAND_LINE
// was specified then the remaining commandline arguments are sent to the
// primary instance, where a #GApplication::command-line signal is emitted.
// Otherwise, the remaining commandline arguments are assumed to be a list of
// files. If there are no files listed, the application is activated via the
// #GApplication::activate signal. If there are one or more files, and
// G_APPLICATION_HANDLES_OPEN was specified then the files are opened via the
// #GApplication::open signal.
//
// If you are interested in doing more complicated local handling of the
// commandline then you should implement your own #GApplication subclass and
// override local_command_line(). In this case, you most likely want to return
// TRUE from your local_command_line() implementation to suppress the default
// handling. See
// [gapplication-example-cmdline2.c][gapplication-example-cmdline2] for an
// example.
//
// If, after the above is done, the use count of the application is zero then
// the exit status is returned immediately. If the use count is non-zero then
// the default main context is iterated until the use count falls to zero, at
// which point 0 is returned.
//
// If the G_APPLICATION_IS_SERVICE flag is set, then the service will run for as
// much as 10 seconds with a use count of zero while waiting for the message
// that caused the activation to arrive. After that, if the use count falls to
// zero the application will exit immediately, except in the case that
// g_application_set_inactivity_timeout() is in use.
//
// This function sets the prgname (g_set_prgname()), if not already set, to the
// basename of argv[0].
//
// Much like g_main_loop_run(), this function will acquire the main context for
// the duration that the application is running.
//
// Since 2.40, applications that are not explicitly flagged as services or
// launchers (ie: neither G_APPLICATION_IS_SERVICE or G_APPLICATION_IS_LAUNCHER
// are given as flags) will check (from the default handler for
// local_command_line) if "--gapplication-service" was given in the command
// line. If this flag is present then normal commandline processing is
// interrupted and the G_APPLICATION_IS_SERVICE flag is set. This provides a
// "compromise" solution whereby running an application directly from the
// commandline will invoke it in the normal way (which can be useful for
// debugging) while still allowing applications to be D-Bus activated in service
// mode. The D-Bus service file should invoke the executable with
// "--gapplication-service" as the sole commandline argument. This approach is
// suitable for use by most graphical applications but should not be used from
// applications like editors that need precise control over when processes
// invoked via the commandline will exit and what their exit status will be.
//
// The function takes the following parameters:
//
//    - argv (optional): the argv from main(), or NULL.
//
// The function returns the following values:
//
//    - gint: exit status.
//
func (application *Application) Run(argv []string) int32 {
	var _arg0 *C.GApplication // out
	var _arg2 **C.char        // out
	var _arg1 C.int
	var _cret C.int // in

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (C.int)(len(argv))
	_arg2 = (**C.char)(C.calloc(C.size_t(len(argv)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((**C.char)(_arg2), len(argv))
		for i := range argv {
			out[i] = (*C.char)(unsafe.Pointer(C.CString(argv[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	_cret = C.g_application_run(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(argv)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// SendNotification sends a notification on behalf of application to the desktop
// shell. There is no guarantee that the notification is displayed immediately,
// or even at all.
//
// Notifications may persist after the application exits. It will be
// D-Bus-activated when the notification or one of its actions is activated.
//
// Modifying notification after this call has no effect. However, the object can
// be reused for a later call to this function.
//
// id may be any string that uniquely identifies the event for the application.
// It does not need to be in any special format. For example, "new-message"
// might be appropriate for a notification about new messages.
//
// If a previous notification was sent with the same id, it will be replaced
// with notification and shown again as if it was a new notification. This works
// even for notifications sent from a previous execution of the application, as
// long as id is the same string.
//
// id may be NULL, but it is impossible to replace or withdraw notifications
// without an id.
//
// If notification is no longer relevant, it can be withdrawn with
// g_application_withdraw_notification().
//
// The function takes the following parameters:
//
//    - id (optional) of the notification, or NULL.
//    - notification to send.
//
func (application *Application) SendNotification(id string, notification *Notification) {
	var _arg0 *C.GApplication  // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GNotification // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if id != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GNotification)(unsafe.Pointer(coreglib.InternObject(notification).Native()))

	C.g_application_send_notification(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
	runtime.KeepAlive(notification)
}

// SetActionGroup: this used to be how actions were associated with a
// #GApplication. Now there is Map for that.
//
// Deprecated: Use the Map interface instead. Never ever mix use of this API
// with use of Map on the same application or things will go very badly wrong.
// This function is known to introduce buggy behaviour (ie: signals not emitted
// on changes to the action group), so you should really use Map instead.
//
// The function takes the following parameters:
//
//    - actionGroup (optional) or NULL.
//
func (application *Application) SetActionGroup(actionGroup ActionGrouper) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.GActionGroup // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if actionGroup != nil {
		_arg1 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	}

	C.g_application_set_action_group(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(actionGroup)
}

// SetApplicationID sets the unique identifier for application.
//
// The application id can only be modified if application has not yet been
// registered.
//
// If non-NULL, the application id must be valid. See
// g_application_id_is_valid().
//
// The function takes the following parameters:
//
//    - applicationId (optional): identifier for application.
//
func (application *Application) SetApplicationID(applicationId string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if applicationId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_application_id(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(applicationId)
}

// SetDefault sets or unsets the default application for the process, as
// returned by g_application_get_default().
//
// This function does not take its own reference on application. If application
// is destroyed then the default application will revert back to NULL.
func (application *Application) SetDefault() {
	var _arg0 *C.GApplication // out

	if application != nil {
		_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	}

	C.g_application_set_default(_arg0)
	runtime.KeepAlive(application)
}

// SetFlags sets the flags for application.
//
// The flags can only be modified if application has not yet been registered.
//
// See Flags.
//
// The function takes the following parameters:
//
//    - flags for application.
//
func (application *Application) SetFlags(flags ApplicationFlags) {
	var _arg0 *C.GApplication     // out
	var _arg1 C.GApplicationFlags // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.GApplicationFlags(flags)

	C.g_application_set_flags(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(flags)
}

// SetInactivityTimeout sets the current inactivity timeout for the application.
//
// This is the amount of time (in milliseconds) after the last call to
// g_application_release() before the application stops running.
//
// This call has no side effects of its own. The value set here is only used for
// next time g_application_release() drops the use count to zero. Any timeouts
// currently in progress are not impacted.
//
// The function takes the following parameters:
//
//    - inactivityTimeout: timeout, in milliseconds.
//
func (application *Application) SetInactivityTimeout(inactivityTimeout uint32) {
	var _arg0 *C.GApplication // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.guint(inactivityTimeout)

	C.g_application_set_inactivity_timeout(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(inactivityTimeout)
}

// SetOptionContextDescription adds a description to the application option
// context.
//
// See g_option_context_set_description() for more information.
//
// The function takes the following parameters:
//
//    - description (optional): string to be shown in --help output after the
//      list of options, or NULL.
//
func (application *Application) SetOptionContextDescription(description string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if description != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_option_context_description(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(description)
}

// SetOptionContextParameterString sets the parameter string to be used by the
// commandline handling of application.
//
// This function registers the argument to be passed to g_option_context_new()
// when the internal Context of application is created.
//
// See g_option_context_new() for more information about parameter_string.
//
// The function takes the following parameters:
//
//    - parameterString (optional): string which is displayed in the first line
//      of --help output, after the usage summary programname [OPTION...].
//
func (application *Application) SetOptionContextParameterString(parameterString string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if parameterString != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(parameterString)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_option_context_parameter_string(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(parameterString)
}

// SetOptionContextSummary adds a summary to the application option context.
//
// See g_option_context_set_summary() for more information.
//
// The function takes the following parameters:
//
//    - summary (optional): string to be shown in --help output before the list
//      of options, or NULL.
//
func (application *Application) SetOptionContextSummary(summary string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if summary != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(summary)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_option_context_summary(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(summary)
}

// SetResourceBasePath sets (or unsets) the base resource path of application.
//
// The path is used to automatically load various [application
// resources][gresource] such as menu layouts and action descriptions. The
// various types of resources will be found at fixed names relative to the given
// base path.
//
// By default, the resource base path is determined from the application ID by
// prefixing '/' and replacing each '.' with '/'. This is done at the time that
// the #GApplication object is constructed. Changes to the application ID after
// that point will not have an impact on the resource base path.
//
// As an example, if the application has an ID of "org.example.app" then the
// default resource base path will be "/org/example/app". If this is a
// Application (and you have not manually changed the path) then Gtk will then
// search for the menus of the application at "/org/example/app/gtk/menus.ui".
//
// See #GResource for more information about adding resources to your
// application.
//
// You can disable automatic resource loading functionality by setting the path
// to NULL.
//
// Changing the resource base path once the application is running is not
// recommended. The point at which the resource path is consulted for forming
// paths for various purposes is unspecified. When writing a sub-class of
// #GApplication you should either set the #GApplication:resource-base-path
// property at construction time, or call this function during the instance
// initialization. Alternatively, you can call this function in the
// Class.startup virtual function, before chaining up to the parent
// implementation.
//
// The function takes the following parameters:
//
//    - resourcePath (optional): resource path to use.
//
func (application *Application) SetResourceBasePath(resourcePath string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if resourcePath != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.g_application_set_resource_base_path(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(resourcePath)
}

// UnbindBusyProperty destroys a binding between property and the busy state of
// application that was previously created with
// g_application_bind_busy_property().
//
// The function takes the following parameters:
//
//    - object: #GObject.
//    - property: name of a boolean property of object.
//
func (application *Application) UnbindBusyProperty(object *coreglib.Object, property string) {
	var _arg0 *C.GApplication // out
	var _arg1 C.gpointer      // out
	var _arg2 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(object.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_application_unbind_busy_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(object)
	runtime.KeepAlive(property)
}

// UnmarkBusy decreases the busy count of application.
//
// When the busy count reaches zero, the new state will be propagated to other
// processes.
//
// This function must only be called to cancel the effect of a previous call to
// g_application_mark_busy().
func (application *Application) UnmarkBusy() {
	var _arg0 *C.GApplication // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	C.g_application_unmark_busy(_arg0)
	runtime.KeepAlive(application)
}

// WithdrawNotification withdraws a notification that was sent with
// g_application_send_notification().
//
// This call does nothing if a notification with id doesn't exist or the
// notification was never sent.
//
// This function works even for notifications sent in previous executions of
// this application, as long id is the same as it was for the sent notification.
//
// Note that notifications are dismissed when the user clicks on one of the
// buttons in a notification or triggers its default action, so there is no need
// to explicitly withdraw the notification in that case.
//
// The function takes the following parameters:
//
//    - id of a previously sent notification.
//
func (application *Application) WithdrawNotification(id string) {
	var _arg0 *C.GApplication // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_application_withdraw_notification(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)
}

// ApplicationGetDefault returns the default #GApplication instance for this
// process.
//
// Normally there is only one #GApplication per process and it becomes the
// default when it is created. You can exercise more control over this by using
// g_application_set_default().
//
// If there is no default application then NULL is returned.
//
// The function returns the following values:
//
//    - application (optional): default application for this process, or NULL.
//
func ApplicationGetDefault() *Application {
	var _cret *C.GApplication // in

	_cret = C.g_application_get_default()

	var _application *Application // out

	if _cret != nil {
		_application = wrapApplication(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _application
}

// ApplicationIDIsValid checks if application_id is a valid application
// identifier.
//
// A valid ID is required for calls to g_application_new() and
// g_application_set_application_id().
//
// Application identifiers follow the same format as D-Bus well-known bus names
// (https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
// For convenience, the restrictions on application identifiers are reproduced
// here:
//
// - Application identifiers are composed of 1 or more elements separated by a
// period (.) character. All elements must contain at least one character.
//
// - Each element must only contain the ASCII characters [A-Z][a-z][0-9]_-, with
// - discouraged in new application identifiers. Each element must not begin
// with a digit.
//
// - Application identifiers must contain at least one . (period) character (and
// thus at least two elements).
//
// - Application identifiers must not begin with a . (period) character.
//
// - Application identifiers must not exceed 255 characters.
//
// Note that the hyphen (-) character is allowed in application identifiers, but
// is problematic or not allowed in various specifications and APIs that refer
// to D-Bus, such as Flatpak application IDs
// (http://docs.flatpak.org/en/latest/introduction.html#identifiers), the
// DBusActivatable interface in the Desktop Entry Specification
// (https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
// and the convention that an application's "main" interface and object path
// resemble its application identifier and bus name. To avoid situations that
// require special-case handling, it is recommended that new application
// identifiers consistently replace hyphens with underscores.
//
// Like D-Bus interface names, application identifiers should start with the
// reversed DNS domain name of the author of the interface (in lower-case), and
// it is conventional for the rest of the application identifier to consist of
// words run together, with initial capital letters.
//
// As with D-Bus interface names, if the author's DNS domain name contains
// hyphen/minus characters they should be replaced by underscores, and if it
// contains leading digits they should be escaped by prepending an underscore.
// For example, if the owner of 7-zip.org used an application identifier for an
// archiving application, it might be named org._7_zip.Archiver.
//
// The function takes the following parameters:
//
//    - applicationId: potential application identifier.
//
// The function returns the following values:
//
//    - ok: TRUE if application_id is valid.
//
func ApplicationIDIsValid(applicationId string) bool {
	var _arg1 *C.gchar   // out
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_application_id_is_valid(_arg1)
	runtime.KeepAlive(applicationId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

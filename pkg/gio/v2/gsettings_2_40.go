// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// DefaultValue gets the "default value" of a key.
//
// This is the value that would be read if g_settings_reset() were to be called
// on the key.
//
// Note that this may be a different value than returned by
// g_settings_schema_key_get_default_value() if the system administrator has
// provided a default value.
//
// Comparing the return values of g_settings_get_default_value() and
// g_settings_get_value() is not sufficient for determining if a value has been
// set because the user may have explicitly set the value to something that
// happens to be equal to the default. The difference here is that if the
// default changes in the future, the user's key will still be set.
//
// This function may be useful for adding an indication to a UI of what the
// default value was before the user set it.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings.
//
// The function takes the following parameters:
//
//    - key to get the default value for.
//
// The function returns the following values:
//
//    - variant (optional): default value.
//
func (settings *Settings) DefaultValue(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_default_value(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// UserValue checks the "user value" of a key, if there is one.
//
// The user value of a key is the last value that was set by the user.
//
// After calling g_settings_reset() this function should always return NULL
// (assuming something is not wrong with the system configuration).
//
// It is possible that g_settings_get_value() will return a different value than
// this function. This can happen in the case that the user set a value for a
// key that was subsequently locked down by the system administrator -- this
// function will return the user's old value.
//
// This function may be useful for adding a "reset" option to a UI or for
// providing indication that a particular value has been changed.
//
// It is a programmer error to give a key that isn't contained in the schema for
// settings.
//
// The function takes the following parameters:
//
//    - key to get the user value for.
//
// The function returns the following values:
//
//    - variant (optional) user's value, if set.
//
func (settings *Settings) UserValue(key string) *glib.Variant {
	var _arg0 *C.GSettings // out
	var _arg1 *C.gchar     // out
	var _cret *C.GVariant  // in

	_arg0 = (*C.GSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_settings_get_user_value(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

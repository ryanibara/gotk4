// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// Credentials returns the credentials of the foreign process connected to this
// socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX sockets).
//
// If this operation isn't supported on the OS, the method fails with the
// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading the
// SO_PEERCRED option on the underlying socket.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26
//
// - OpenBSD since GLib 2.30
//
// - Solaris, Illumos and OpenSolaris since GLib 2.40
//
// - NetBSD since GLib 2.42
//
// - macOS, tvOS, iOS since GLib 2.66
//
// Other ways to obtain credentials from a foreign peer includes the
// CredentialsMessage type and g_unix_connection_send_credentials() /
// g_unix_connection_receive_credentials() functions.
//
// The function returns the following values:
//
//    - credentials: NULL if error is set, otherwise a #GCredentials object that
//      must be freed with g_object_unref().
//
func (socket *Socket) Credentials() (*Credentials, error) {
	var _arg0 *C.GSocket      // out
	var _cret *C.GCredentials // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_credentials(_arg0, &_cerr)
	runtime.KeepAlive(socket)

	var _credentials *Credentials // out
	var _goerr error              // out

	_credentials = wrapCredentials(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _credentials, _goerr
}

// Timeout gets the timeout setting of the socket. For details on this, see
// g_socket_set_timeout().
//
// The function returns the following values:
//
//    - guint: timeout in seconds.
//
func (socket *Socket) Timeout() uint {
	var _arg0 *C.GSocket // out
	var _cret C.guint    // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_cret = C.g_socket_get_timeout(_arg0)
	runtime.KeepAlive(socket)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
// except that the choice of blocking or non-blocking behavior is determined by
// the blocking argument rather than by socket's properties.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - buffer: a buffer to read data into (which should be at least size bytes
//      long).
//    - blocking: whether to do blocking or non-blocking I/O.
//
// The function returns the following values:
//
//    - gssize: number of bytes read, or 0 if the connection was closed by the
//      peer, or -1 on error.
//
func (socket *Socket) ReceiveWithBlocking(ctx context.Context, buffer []byte, blocking bool) (int, error) {
	var _arg0 *C.GSocket      // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gsize
	var _arg3 C.gboolean // out
	var _cret C.gssize   // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	_arg1 = (*C.gchar)(C.CBytes(buffer))
	defer C.free(unsafe.Pointer(_arg1))
	if blocking {
		_arg3 = C.TRUE
	}

	_cret = C.g_socket_receive_with_blocking(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SendWithBlocking: this behaves exactly the same as g_socket_send(), except
// that the choice of blocking or non-blocking behavior is determined by the
// blocking argument rather than by socket's properties.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - buffer: buffer containing the data to send.
//    - blocking: whether to do blocking or non-blocking I/O.
//
// The function returns the following values:
//
//    - gssize: number of bytes written (which may be less than size), or -1 on
//      error.
//
func (socket *Socket) SendWithBlocking(ctx context.Context, buffer string, blocking bool) (int, error) {
	var _arg0 *C.GSocket      // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gsize
	var _arg3 C.gboolean // out
	var _cret C.gssize   // in
	var _cerr *C.GError  // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(buffer) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(buffer)), buffer)
	defer C.free(unsafe.Pointer(_arg1))
	if blocking {
		_arg3 = C.TRUE
	}

	_cret = C.g_socket_send_with_blocking(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// SetTimeout sets the time in seconds after which I/O operations on socket will
// time out if they have not yet completed.
//
// On a blocking socket, this means that any blocking #GSocket operation will
// time out after timeout seconds of inactivity, returning G_IO_ERROR_TIMED_OUT.
//
// On a non-blocking socket, calls to g_socket_condition_wait() will also fail
// with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
// g_socket_create_source() will trigger after timeout seconds of inactivity,
// with the requested condition set, at which point calling g_socket_receive(),
// g_socket_send(), g_socket_check_connect_result(), etc, will fail with
// G_IO_ERROR_TIMED_OUT.
//
// If timeout is 0 (the default), operations will never time out on their own.
//
// Note that if an I/O operation is interrupted by a signal, this may cause the
// timeout to be reset.
//
// The function takes the following parameters:
//
//    - timeout for socket, in seconds, or 0 for none.
//
func (socket *Socket) SetTimeout(timeout uint) {
	var _arg0 *C.GSocket // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = C.guint(timeout)

	C.g_socket_set_timeout(_arg0, _arg1)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(timeout)
}

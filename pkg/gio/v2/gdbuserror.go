// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// DBusErrorEncodeGError creates a D-Bus error name to use for error. If error
// matches a registered error (cf. g_dbus_error_register_error()), the
// corresponding D-Bus error name will be returned.
//
// Otherwise the a name of the form
// org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE will
// be used. This allows other GDBus applications to map the error on the wire
// back to a #GError using g_dbus_error_new_for_dbus_error().
//
// This function is typically only used in object mappings to put a #GError on
// the wire. Regular applications should not use it.
//
// The function takes the following parameters:
//
//    - err: #GError.
//
// The function returns the following values:
//
//    - utf8 d-Bus error name (never NULL). Free with g_free().
//
func DBusErrorEncodeGError(err error) string {
	var _args [1]girepository.Argument

	if err != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gerror.New(err))
	}

	_info := girepository.MustFind("Gio", "encode_gerror")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(err)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret))))

	return _utf8
}

// DBusErrorGetRemoteError gets the D-Bus error name used for error, if any.
//
// This function is guaranteed to return a D-Bus error name for all #GErrors
// returned from functions handling remote method calls (e.g.
// g_dbus_connection_call_finish()) unless g_dbus_error_strip_remote_error() has
// been used on error.
//
// The function takes the following parameters:
//
//    - err: #GError.
//
// The function returns the following values:
//
//    - utf8 (optional): allocated string or NULL if the D-Bus error name could
//      not be found. Free with g_free().
//
func DBusErrorGetRemoteError(err error) string {
	var _args [1]girepository.Argument

	if err != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gerror.New(err))
	}

	_info := girepository.MustFind("Gio", "get_remote_error")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(err)

	var _utf8 string // out

	if *(**C.gchar)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret))))
	}

	return _utf8
}

// DBusErrorIsRemoteError checks if error represents an error received via D-Bus
// from a remote peer. If so, use g_dbus_error_get_remote_error() to get the
// name of the error.
//
// The function takes the following parameters:
//
//    - err: #GError.
//
// The function returns the following values:
//
//    - ok: TRUE if error represents an error from a remote peer, FALSE
//      otherwise.
//
func DBusErrorIsRemoteError(err error) bool {
	var _args [1]girepository.Argument

	if err != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gerror.New(err))
	}

	_info := girepository.MustFind("Gio", "is_remote_error")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(err)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// NewDBusErrorForDBusError creates a #GError based on the contents of
// dbus_error_name and dbus_error_message.
//
// Errors registered with g_dbus_error_register_error() will be looked up using
// dbus_error_name and if a match is found, the error domain and code is used.
// Applications can use g_dbus_error_get_remote_error() to recover
// dbus_error_name.
//
// If a match against a registered error is not found and the D-Bus error name
// is in a form as returned by g_dbus_error_encode_gerror() the error domain and
// code encoded in the name is used to create the #GError. Also, dbus_error_name
// is added to the error message such that it can be recovered with
// g_dbus_error_get_remote_error().
//
// Otherwise, a #GError with the error code G_IO_ERROR_DBUS_ERROR in the
// IO_ERROR error domain is returned. Also, dbus_error_name is added to the
// error message such that it can be recovered with
// g_dbus_error_get_remote_error().
//
// In all three cases, dbus_error_name can always be recovered from the returned
// #GError using the g_dbus_error_get_remote_error() function (unless
// g_dbus_error_strip_remote_error() hasn't been used on the returned error).
//
// This function is typically only used in object mappings to prepare #GError
// instances for applications. Regular applications should not use it.
//
// The function takes the following parameters:
//
//    - dbusErrorName d-Bus error name.
//    - dbusErrorMessage d-Bus error message.
//
// The function returns the following values:
//
//    - err: allocated #GError. Free with g_error_free().
//
func NewDBusErrorForDBusError(dbusErrorName, dbusErrorMessage string) error {
	var _args [2]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(dbusErrorName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(dbusErrorMessage)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "new_for_dbus_error")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(dbusErrorName)
	runtime.KeepAlive(dbusErrorMessage)

	var _err error // out

	_err = gerror.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret))))

	return _err
}

// DBusErrorRegisterError creates an association to map between dbus_error_name
// and #GErrors specified by error_domain and error_code.
//
// This is typically done in the routine that returns the #GQuark for an error
// domain.
//
// The function takes the following parameters:
//
//    - errorDomain for an error domain.
//    - errorCode: error code.
//    - dbusErrorName d-Bus error name.
//
// The function returns the following values:
//
//    - ok: TRUE if the association was created, FALSE if it already exists.
//
func DBusErrorRegisterError(errorDomain glib.Quark, errorCode int32, dbusErrorName string) bool {
	var _args [3]girepository.Argument

	*(*C.guint32)(unsafe.Pointer(&_args[0])) = C.guint32(errorDomain)
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(errorCode)
	*(**C.gchar)(unsafe.Pointer(&_args[2])) = (*C.gchar)(unsafe.Pointer(C.CString(dbusErrorName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[2]))))

	_info := girepository.MustFind("Gio", "register_error")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(errorDomain)
	runtime.KeepAlive(errorCode)
	runtime.KeepAlive(dbusErrorName)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DBusErrorStripRemoteError looks for extra information in the error message
// used to recover the D-Bus error name and strips it if found. If stripped, the
// message field in error will correspond exactly to what was received on the
// wire.
//
// This is typically used when presenting errors to the end user.
//
// The function takes the following parameters:
//
//    - err: #GError.
//
// The function returns the following values:
//
//    - ok: TRUE if information was stripped, FALSE otherwise.
//
func DBusErrorStripRemoteError(err error) bool {
	var _args [1]girepository.Argument

	if err != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gerror.New(err))
	}

	_info := girepository.MustFind("Gio", "strip_remote_error")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(err)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DBusErrorUnregisterError destroys an association previously set up with
// g_dbus_error_register_error().
//
// The function takes the following parameters:
//
//    - errorDomain for an error domain.
//    - errorCode: error code.
//    - dbusErrorName d-Bus error name.
//
// The function returns the following values:
//
//    - ok: TRUE if the association was destroyed, FALSE if it wasn't found.
//
func DBusErrorUnregisterError(errorDomain glib.Quark, errorCode int32, dbusErrorName string) bool {
	var _args [3]girepository.Argument

	*(*C.guint32)(unsafe.Pointer(&_args[0])) = C.guint32(errorDomain)
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(errorCode)
	*(**C.gchar)(unsafe.Pointer(&_args[2])) = (*C.gchar)(unsafe.Pointer(C.CString(dbusErrorName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[2]))))

	_info := girepository.MustFind("Gio", "unregister_error")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(errorDomain)
	runtime.KeepAlive(errorCode)
	runtime.KeepAlive(dbusErrorName)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DBusErrorEntry: struct used in g_dbus_error_register_error_domain().
//
// An instance of this type is always passed by reference.
type DBusErrorEntry struct {
	*dBusErrorEntry
}

// dBusErrorEntry is the struct that's finalized.
type dBusErrorEntry struct {
	native unsafe.Pointer
}

// ErrorCode: error code.
func (d *DBusErrorEntry) ErrorCode() int32 {
	offset := girepository.MustFind("Gio", "DBusErrorEntry").StructFieldOffset("error_code")
	valptr := (*uintptr)(unsafe.Add(d.native, offset))
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&*valptr)))
	return v
}

// DBusErrorName d-Bus error name to associate with error_code.
func (d *DBusErrorEntry) DBusErrorName() string {
	offset := girepository.MustFind("Gio", "DBusErrorEntry").StructFieldOffset("dbus_error_name")
	valptr := (*uintptr)(unsafe.Add(d.native, offset))
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&*valptr)))))
	return v
}

// ErrorCode: error code.
func (d *DBusErrorEntry) SetErrorCode(errorCode int32) {
	offset := girepository.MustFind("Gio", "DBusErrorEntry").StructFieldOffset("error_code")
	valptr := (*uintptr)(unsafe.Add(d.native, offset))
	*(*C.gint)(unsafe.Pointer(&*valptr)) = C.gint(errorCode)
}

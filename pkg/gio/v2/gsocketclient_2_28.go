// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// TLS gets whether client creates TLS connections. See
// g_socket_client_set_tls() for details.
//
// The function returns the following values:
//
//    - ok: whether client uses TLS.
//
func (client *SocketClient) TLS() bool {
	var _arg0 *C.GSocketClient // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_tls(_arg0)
	runtime.KeepAlive(client)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TLSValidationFlags gets the TLS validation flags used creating TLS
// connections via client.
//
// The function returns the following values:
//
//    - tlsCertificateFlags: TLS validation flags.
//
func (client *SocketClient) TLSValidationFlags() TLSCertificateFlags {
	var _arg0 *C.GSocketClient       // out
	var _cret C.GTlsCertificateFlags // in

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))

	_cret = C.g_socket_client_get_tls_validation_flags(_arg0)
	runtime.KeepAlive(client)

	var _tlsCertificateFlags TLSCertificateFlags // out

	_tlsCertificateFlags = TLSCertificateFlags(_cret)

	return _tlsCertificateFlags
}

// SetTLS sets whether client creates TLS (aka SSL) connections. If tls is TRUE,
// client will wrap its connections in a ClientConnection and perform a TLS
// handshake when connecting.
//
// Note that since Client must return a Connection, but ClientConnection is not
// a Connection, this actually wraps the resulting ClientConnection in a
// WrapperConnection when returning it. You can use
// g_tcp_wrapper_connection_get_base_io_stream() on the return value to extract
// the ClientConnection.
//
// If you need to modify the behavior of the TLS handshake (eg, by setting a
// client-side certificate to use, or connecting to the
// Connection::accept-certificate signal), you can connect to client's
// Client::event signal and wait for it to be emitted with
// G_SOCKET_CLIENT_TLS_HANDSHAKING, which will give you a chance to see the
// ClientConnection before the handshake starts.
//
// The function takes the following parameters:
//
//    - tls: whether to use TLS.
//
func (client *SocketClient) SetTLS(tls bool) {
	var _arg0 *C.GSocketClient // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	if tls {
		_arg1 = C.TRUE
	}

	C.g_socket_client_set_tls(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(tls)
}

// SetTLSValidationFlags sets the TLS validation flags used when creating TLS
// connections via client. The default value is G_TLS_CERTIFICATE_VALIDATE_ALL.
//
// The function takes the following parameters:
//
//    - flags: validation flags.
//
func (client *SocketClient) SetTLSValidationFlags(flags TLSCertificateFlags) {
	var _arg0 *C.GSocketClient       // out
	var _arg1 C.GTlsCertificateFlags // out

	_arg0 = (*C.GSocketClient)(unsafe.Pointer(coreglib.InternObject(client).Native()))
	_arg1 = C.GTlsCertificateFlags(flags)

	C.g_socket_client_set_tls_validation_flags(_arg0, _arg1)
	runtime.KeepAlive(client)
	runtime.KeepAlive(flags)
}

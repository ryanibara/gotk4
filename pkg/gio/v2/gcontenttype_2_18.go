// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// ContentTypeFromMIMEType tries to find a content type based on the mime type
// name.
//
// The function takes the following parameters:
//
//   - mimeType: mime type string.
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string with content type or NULL.
//     Free with g_free().
//
func ContentTypeFromMIMEType(mimeType string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_content_type_from_mime_type(_arg1)
	runtime.KeepAlive(mimeType)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// ContentTypeGuessForTree tries to guess the type of the tree with root root,
// by looking at the files it contains. The result is an array of content types,
// with the best guess coming first.
//
// The types returned all have the form x-content/foo, e.g.
// x-content/audio-cdda (for audio CDs) or x-content/image-dcf
// (for a camera memory card). See the shared-mime-info
// (http://www.freedesktop.org/wiki/Specifications/shared-mime-info-spec)
// specification for more on x-content types.
//
// This function is useful in the implementation of
// g_mount_guess_content_type().
//
// The function takes the following parameters:
//
//   - root of the tree to guess a type for.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of zero or more content types. Free with
//     g_strfreev().
//
func ContentTypeGuessForTree(root Filer) []string {
	var _arg1 *C.GFile  // out
	var _cret **C.gchar // in

	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(root).Native()))

	_cret = C.g_content_type_guess_for_tree(_arg1)
	runtime.KeepAlive(root)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

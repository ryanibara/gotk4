// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// JoinMulticastGroupSSM registers socket to receive multicast messages sent to
// group. socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have been
// bound to an appropriate interface and port with g_socket_bind().
//
// If iface is NULL, the system will automatically pick an interface to bind to
// based on group.
//
// If source_specific is not NULL, use source-specific multicast as defined in
// RFC 4604. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// Note that this function can be called multiple times for the same group with
// different source_specific in order to receive multicast packets from more
// than one source.
//
// The function takes the following parameters:
//
//    - group specifying the group address to join.
//    - sourceSpecific (optional) specifying the source-specific multicast
//      address or NULL to ignore.
//    - iface (optional): name of the interface to use, or NULL.
//
func (socket *Socket) JoinMulticastGroupSSM(group, sourceSpecific *InetAddress, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GInetAddress // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific != nil {
		_arg2 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(sourceSpecific).Native()))
	}
	if iface != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_socket_join_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LeaveMulticastGroupSSM removes socket from the multicast group defined by
// group, iface, and source_specific (which must all have the same values they
// had when you joined the group).
//
// socket remains bound to its address and port, and can still receive unicast
// messages after calling this.
//
// The function takes the following parameters:
//
//    - group specifying the group address to leave.
//    - sourceSpecific (optional) specifying the source-specific multicast
//      address or NULL to ignore.
//    - iface (optional): name of the interface to use, or NULL.
//
func (socket *Socket) LeaveMulticastGroupSSM(group, sourceSpecific *InetAddress, iface string) error {
	var _arg0 *C.GSocket      // out
	var _arg1 *C.GInetAddress // out
	var _arg2 *C.GInetAddress // out
	var _arg3 *C.gchar        // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific != nil {
		_arg2 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(sourceSpecific).Native()))
	}
	if iface != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.g_socket_leave_multicast_group_ssm(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

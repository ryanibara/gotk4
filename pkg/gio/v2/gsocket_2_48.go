// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// ReceiveMessages: receive multiple data messages from socket in one go. This
// is the most complicated and fully-featured version of this call. For easier
// use, see g_socket_receive(), g_socket_receive_from(), and
// g_socket_receive_message().
//
// messages must point to an array of Message structs and num_messages must be
// the length of this array. Each Message contains a pointer to an array of
// Vector structs describing the buffers that the data received in each message
// will be written to. Using multiple Vectors is more memory-efficient than
// manually copying data out of a single buffer to multiple sources, and more
// system-call-efficient than making multiple calls to g_socket_receive(), such
// as in scenarios where a lot of data packets need to be received (e.g.
// high-bandwidth video streaming over RTP/UDP).
//
// flags modify how all messages are received. The commonly available arguments
// for this are available in the MsgFlags enum, but the values there are the
// same as the system values, and the flags are passed in as-is, so you can pass
// in system-specific flags too. These flags affect the overall receive
// operation. Flags affecting individual messages are returned in Message.flags.
//
// The other members of Message are treated as described in its documentation.
//
// If #GSocket:blocking is TRUE the call will block until num_messages have been
// received, or the end of the stream is reached.
//
// If #GSocket:blocking is FALSE the call will return up to num_messages without
// blocking, or G_IO_ERROR_WOULD_BLOCK if no messages are queued in the
// operating system to be received.
//
// In blocking mode, if #GSocket:timeout is positive and is reached before any
// messages are received, G_IO_ERROR_TIMED_OUT is returned, otherwise up to
// num_messages are returned. (Note: This is effectively the behaviour of
// MSG_WAITFORONE with recvmmsg().)
//
// To be notified when messages are available, wait for the G_IO_IN condition.
// Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_socket_receive_messages() even if you were previously notified of a G_IO_IN
// condition.
//
// If the remote peer closes the connection, any messages queued in the
// operating system will be returned, and subsequent calls to
// g_socket_receive_messages() will return 0 (with no error set).
//
// On error -1 is returned and error is set accordingly. An error will only be
// returned if zero messages could be received; otherwise the number of messages
// successfully received before the error will be returned.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - messages: array of Message structs.
//    - flags: int containing MsgFlags flags for the overall operation, which may
//      additionally contain other platform specific flags
//      (http://man7.org/linux/man-pages/man2/recv.2.html).
//
// The function returns the following values:
//
//    - gint: number of messages received, or -1 on error. Note that the number
//      of messages received may be smaller than num_messages if in non-blocking
//      mode, if the peer closed the connection, or if num_messages was larger
//      than UIO_MAXIOV (1024), in which case the caller may re-try to receive
//      the remaining messages.
//
func (socket *Socket) ReceiveMessages(ctx context.Context, messages []InputMessage, flags int) (int, error) {
	var _arg0 *C.GSocket       // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GInputMessage // out
	var _arg2 C.guint
	var _arg3 C.gint    // out
	var _cret C.gint    // in
	var _cerr *C.GError // in

	_arg0 = (*C.GSocket)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.guint)(len(messages))
	_arg1 = (*C.GInputMessage)(C.calloc(C.size_t(len(messages)), C.size_t(C.sizeof_GInputMessage)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GInputMessage)(_arg1), len(messages))
		for i := range messages {
			out[i] = *(*C.GInputMessage)(gextras.StructNative(unsafe.Pointer((&messages[i]))))
		}
	}
	_arg3 = C.gint(flags)

	_cret = C.g_socket_receive_messages(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(messages)
	runtime.KeepAlive(flags)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

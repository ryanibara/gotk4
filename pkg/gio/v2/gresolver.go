// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name(void*, void*, void*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name_finish(void*, void*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish(void*, void*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_records_finish(void*, void*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_service_finish(void*, void*, GError**);
// extern gchar* _gotk4_gio2_ResolverClass_lookup_by_address(void*, void*, void*, GError**);
// extern gchar* _gotk4_gio2_ResolverClass_lookup_by_address_finish(void*, void*, GError**);
// extern void _gotk4_gio2_AsyncReadyCallback(void*, void*, gpointer);
// extern void _gotk4_gio2_ResolverClass_reload(void*);
// extern void _gotk4_gio2_Resolver_ConnectReload(gpointer, guintptr);
import "C"

// glib.Type values for gresolver.go.
var (
	GTypeResolverNameLookupFlags = coreglib.Type(C.g_resolver_name_lookup_flags_get_type())
	GTypeResolver                = coreglib.Type(C.g_resolver_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeResolverNameLookupFlags, F: marshalResolverNameLookupFlags},
		{T: GTypeResolver, F: marshalResolver},
	})
}

// ResolverNameLookupFlags flags to modify lookup behavior.
type ResolverNameLookupFlags C.guint

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name()).
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0b0
	// ResolverNameLookupFlagsIPv4Only: only resolve ipv4 addresses.
	ResolverNameLookupFlagsIPv4Only ResolverNameLookupFlags = 0b1
	// ResolverNameLookupFlagsIPv6Only: only resolve ipv6 addresses.
	ResolverNameLookupFlagsIPv6Only ResolverNameLookupFlags = 0b10
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResolverNameLookupFlags.
func (r ResolverNameLookupFlags) String() string {
	if r == 0 {
		return "ResolverNameLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(94)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResolverNameLookupFlagsDefault:
			builder.WriteString("Default|")
		case ResolverNameLookupFlagsIPv4Only:
			builder.WriteString("IPv4Only|")
		case ResolverNameLookupFlagsIPv6Only:
			builder.WriteString("IPv6Only|")
		default:
			builder.WriteString(fmt.Sprintf("ResolverNameLookupFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResolverNameLookupFlags) Has(other ResolverNameLookupFlags) bool {
	return (r & other) == other
}

// ResolverOverrider contains methods that are overridable.
type ResolverOverrider interface {
	// LookupByAddress: synchronously reverse-resolves address to determine its
	// associated hostname.
	//
	// If the DNS resolution fails, error (if non-NULL) will be set to a value
	// from Error.
	//
	// If cancellable is non-NULL, it can be used to cancel the operation, in
	// which case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - ctx (optional) or NULL.
	//    - address to reverse-resolve.
	//
	// The function returns the following values:
	//
	//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL
	//      on error.
	//
	LookupByAddress(ctx context.Context, address *InetAddress) (string, error)
	// LookupByAddressFinish retrieves the result of a previous call to
	// g_resolver_lookup_by_address_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL
	//      on error.
	//
	LookupByAddressFinish(result AsyncResulter) (string, error)
	// LookupByName: synchronously resolves hostname to determine its associated
	// IP address(es). hostname may be an ASCII-only or UTF-8 hostname, or the
	// textual form of an IP address (in which case this just becomes a wrapper
	// around g_inet_address_new_from_string()).
	//
	// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
	// Address, sorted in order of preference and guaranteed to not contain
	// duplicates. That is, if using the result to connect to hostname, you
	// should attempt to connect to the first address first, then the second if
	// the first fails, etc. If you are using the result to listen on a socket,
	// it is appropriate to add each result using e.g.
	// g_socket_listener_add_address().
	//
	// If the DNS resolution fails, error (if non-NULL) will be set to a value
	// from Error and NULL will be returned.
	//
	// If cancellable is non-NULL, it can be used to cancel the operation, in
	// which case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
	//
	// If you are planning to connect to a socket on the resolved IP address, it
	// may be easier to create a Address and use its Connectable interface.
	//
	// The function takes the following parameters:
	//
	//    - ctx (optional) or NULL.
	//    - hostname to look up.
	//
	// The function returns the following values:
	//
	//    - list: non-empty #GList of Address, or NULL on error. You must unref
	//      each of the addresses and free the list when you are done with it.
	//      (You can use g_resolver_free_addresses() to do this.).
	//
	LookupByName(ctx context.Context, hostname string) ([]*InetAddress, error)
	// LookupByNameFinish retrieves the result of a call to
	// g_resolver_lookup_by_name_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for
	//      more details.
	//
	LookupByNameFinish(result AsyncResulter) ([]*InetAddress, error)
	// LookupByNameWithFlagsFinish retrieves the result of a call to
	// g_resolver_lookup_by_name_with_flags_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for
	//      more details.
	//
	LookupByNameWithFlagsFinish(result AsyncResulter) ([]*InetAddress, error)
	// LookupRecordsFinish retrieves the result of a previous call to
	// g_resolver_lookup_records_async(). Returns a non-empty list of records as
	// #GVariant tuples. See RecordType for information on what the records
	// contain.
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - list: non-empty #GList of #GVariant, or NULL on error. You must free
	//      each of the records and the list when you are done with it. (You can
	//      use g_list_free_full() with g_variant_unref() to do this.).
	//
	LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error)
	// LookupServiceFinish retrieves the result of a previous call to
	// g_resolver_lookup_service_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - list: non-empty #GList of Target, or NULL on error. See
	//      g_resolver_lookup_service() for more details.
	//
	LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error)
	Reload()
}

// Resolver provides cancellable synchronous and asynchronous DNS resolution,
// for hostnames (g_resolver_lookup_by_address(), g_resolver_lookup_by_name()
// and their async variants) and SRV (service) records
// (g_resolver_lookup_service()).
//
// Address and Service provide wrappers around #GResolver functionality that
// also implement Connectable, making it easy to connect to a remote
// host/service.
type Resolver struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Resolver)(nil)
)

// Resolverer describes types inherited from class Resolver.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Resolverer interface {
	coreglib.Objector
	baseResolver() *Resolver
}

var _ Resolverer = (*Resolver)(nil)

func classInitResolverer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GResolverClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GResolverClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface {
		LookupByAddress(ctx context.Context, address *InetAddress) (string, error)
	}); ok {
		pclass.lookup_by_address = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_address)
	}

	if _, ok := goval.(interface {
		LookupByAddressFinish(result AsyncResulter) (string, error)
	}); ok {
		pclass.lookup_by_address_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_address_finish)
	}

	if _, ok := goval.(interface {
		LookupByName(ctx context.Context, hostname string) ([]*InetAddress, error)
	}); ok {
		pclass.lookup_by_name = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name)
	}

	if _, ok := goval.(interface {
		LookupByNameFinish(result AsyncResulter) ([]*InetAddress, error)
	}); ok {
		pclass.lookup_by_name_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name_finish)
	}

	if _, ok := goval.(interface {
		LookupByNameWithFlagsFinish(result AsyncResulter) ([]*InetAddress, error)
	}); ok {
		pclass.lookup_by_name_with_flags_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish)
	}

	if _, ok := goval.(interface {
		LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error)
	}); ok {
		pclass.lookup_records_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_records_finish)
	}

	if _, ok := goval.(interface {
		LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error)
	}); ok {
		pclass.lookup_service_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_service_finish)
	}

	if _, ok := goval.(interface{ Reload() }); ok {
		pclass.reload = (*[0]byte)(C._gotk4_gio2_ResolverClass_reload)
	}
}

//export _gotk4_gio2_ResolverClass_lookup_by_address
func _gotk4_gio2_ResolverClass_lookup_by_address(arg0 *C.void, arg1 *C.void, arg2 *C.void, _cerr **C.GError) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByAddress(ctx context.Context, address *InetAddress) (string, error)
	})

	var _cancellable context.Context // out
	var _address *InetAddress        // out

	if arg2 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg2))
	}
	_address = wrapInetAddress(coreglib.Take(unsafe.Pointer(arg1)))

	utf8, _goerr := iface.LookupByAddress(_cancellable, _address)

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.void)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_address_finish
func _gotk4_gio2_ResolverClass_lookup_by_address_finish(arg0 *C.void, arg1 *C.void, _cerr **C.GError) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByAddressFinish(result AsyncResulter) (string, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	utf8, _goerr := iface.LookupByAddressFinish(_result)

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.void)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_name
func _gotk4_gio2_ResolverClass_lookup_by_name(arg0 *C.void, arg1 *C.void, arg2 *C.void, _cerr **C.GError) (cret *C.GList) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByName(ctx context.Context, hostname string) ([]*InetAddress, error)
	})

	var _cancellable context.Context // out
	var _hostname string             // out

	if arg2 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg2))
	}
	_hostname = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	list, _goerr := iface.LookupByName(_cancellable, _hostname)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.void // out
		dst = (*C.void)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.void)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_name_finish
func _gotk4_gio2_ResolverClass_lookup_by_name_finish(arg0 *C.void, arg1 *C.void, _cerr **C.GError) (cret *C.GList) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByNameFinish(result AsyncResulter) ([]*InetAddress, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	list, _goerr := iface.LookupByNameFinish(_result)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.void // out
		dst = (*C.void)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.void)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish
func _gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish(arg0 *C.void, arg1 *C.void, _cerr **C.GError) (cret *C.GList) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByNameWithFlagsFinish(result AsyncResulter) ([]*InetAddress, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	list, _goerr := iface.LookupByNameWithFlagsFinish(_result)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.void // out
		dst = (*C.void)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.void)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_records_finish
func _gotk4_gio2_ResolverClass_lookup_records_finish(arg0 *C.void, arg1 *C.void, _cerr **C.GError) (cret *C.GList) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	list, _goerr := iface.LookupRecordsFinish(_result)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.void // out
		dst = (*C.void)(gextras.StructNative(unsafe.Pointer(src)))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.void)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_service_finish
func _gotk4_gio2_ResolverClass_lookup_service_finish(arg0 *C.void, arg1 *C.void, _cerr **C.GError) (cret *C.GList) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	list, _goerr := iface.LookupServiceFinish(_result)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.void // out
		dst = (*C.void)(gextras.StructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(src)), nil)
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.void)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_reload
func _gotk4_gio2_ResolverClass_reload(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Reload() })

	iface.Reload()
}

func wrapResolver(obj *coreglib.Object) *Resolver {
	return &Resolver{
		Object: obj,
	}
}

func marshalResolver(p uintptr) (interface{}, error) {
	return wrapResolver(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (resolver *Resolver) baseResolver() *Resolver {
	return resolver
}

// BaseResolver returns the underlying base object.
func BaseResolver(obj Resolverer) *Resolver {
	return obj.baseResolver()
}

//export _gotk4_gio2_Resolver_ConnectReload
func _gotk4_gio2_Resolver_ConnectReload(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectReload is emitted when the resolver notices that the system resolver
// configuration has changed.
func (resolver *Resolver) ConnectReload(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(resolver, "reload", false, unsafe.Pointer(C._gotk4_gio2_Resolver_ConnectReload), f)
}

// LookupByAddress: synchronously reverse-resolves address to determine its
// associated hostname.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - address to reverse-resolve.
//
// The function returns the following values:
//
//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//      error.
//
func (resolver *Resolver) LookupByAddress(ctx context.Context, address *InetAddress) (string, error) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.void)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_gret := girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_by_address", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LookupByAddressAsync begins asynchronously reverse-resolving address to
// determine its associated hostname, and eventually calls callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - address to reverse-resolve.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupByAddressAsync(ctx context.Context, address *InetAddress, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.void)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_by_address_async", _args[:], nil)

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(callback)
}

// LookupByAddressFinish retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//      error.
//
func (resolver *Resolver) LookupByAddressFinish(result AsyncResulter) (string, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_gret := girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_by_address_finish", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LookupByName: synchronously resolves hostname to determine its associated IP
// address(es). hostname may be an ASCII-only or UTF-8 hostname, or the textual
// form of an IP address (in which case this just becomes a wrapper around
// g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// Address, sorted in order of preference and guaranteed to not contain
// duplicates. That is, if using the result to connect to hostname, you should
// attempt to connect to the first address first, then the second if the first
// fails, etc. If you are using the result to listen on a socket, it is
// appropriate to add each result using e.g. g_socket_listener_add_address().
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP address, it may
// be easier to create a Address and use its Connectable interface.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Address, or NULL on error. You must unref each
//      of the addresses and free the list when you are done with it. (You can
//      use g_resolver_free_addresses() to do this.).
//
func (resolver *Resolver) LookupByName(ctx context.Context, hostname string) ([]*InetAddress, error) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.void)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_args[1]))

	_gret := girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_by_name", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameAsync begins asynchronously resolving hostname to determine its
// associated IP address(es), and eventually calls callback, which must call
// g_resolver_lookup_by_name_finish() to get the result. See
// g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up the address of.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupByNameAsync(ctx context.Context, hostname string, callback AsyncReadyCallback) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.void)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_args[1]))
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[4] = C.gpointer(gbox.AssignOnce(callback))
	}

	girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_by_name_async", _args[:], nil)

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(callback)
}

// LookupByNameFinish retrieves the result of a call to
// g_resolver_lookup_by_name_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//      details.
//
func (resolver *Resolver) LookupByNameFinish(result AsyncResulter) ([]*InetAddress, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_gret := girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_by_name_finish", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameWithFlagsFinish retrieves the result of a call to
// g_resolver_lookup_by_name_with_flags_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//      details.
//
func (resolver *Resolver) LookupByNameWithFlagsFinish(result AsyncResulter) ([]*InetAddress, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_gret := girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_by_name_with_flags_finish", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupRecordsFinish retrieves the result of a previous call to
// g_resolver_lookup_records_async(). Returns a non-empty list of records as
// #GVariant tuples. See RecordType for information on what the records contain.
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list: non-empty #GList of #GVariant, or NULL on error. You must free each
//      of the records and the list when you are done with it. (You can use
//      g_list_free_full() with g_variant_unref() to do this.).
//
func (resolver *Resolver) LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_gret := girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_records_finish", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*glib.Variant // out
	var _goerr error          // out

	_list = make([]*glib.Variant, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *glib.Variant // out
		dst = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
		_list = append(_list, dst)
	})
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupService: synchronously performs a DNS SRV lookup for the given service
// and protocol in the given domain and returns an array of Target. domain may
// be an ASCII-only or UTF-8 hostname. Note also that the service and protocol
// arguments do not include the leading underscore that appears in the actual
// DNS entry.
//
// On success, g_resolver_lookup_service() will return a non-empty #GList of
// Target, sorted in order of preference. (That is, you should attempt to
// connect to the first target first, then the second if the first fails, etc.)
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to the service, it is usually easier to create
// a Service and use its Connectable interface.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - service type to look up (eg, "ldap").
//    - protocol: networking protocol to use for service (eg, "tcp").
//    - domain: DNS domain to look up the service in.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Target, or NULL on error. You must free each of
//      the targets and the list when you are done with it. (You can use
//      g_resolver_free_targets() to do this.).
//
func (resolver *Resolver) LookupService(ctx context.Context, service, protocol, domain string) ([]*SrvTarget, error) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[4] = (*C.void)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_args[1]))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_args[2]))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_args[3]))

	_gret := girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_service", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Gio", "SrvTarget").InvokeMethod("free", args[:], nil)
				}
			},
		)
		_list = append(_list, dst)
	})
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupServiceAsync begins asynchronously performing a DNS SRV lookup for the
// given service and protocol in the given domain, and eventually calls
// callback, which must call g_resolver_lookup_service_finish() to get the final
// result. See g_resolver_lookup_service() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - service type to look up (eg, "ldap").
//    - protocol: networking protocol to use for service (eg, "tcp").
//    - domain: DNS domain to look up the service in.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupServiceAsync(ctx context.Context, service, protocol, domain string, callback AsyncReadyCallback) {
	var _args [7]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[4] = (*C.void)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_args[1]))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_args[2]))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_args[3]))
	if callback != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[5])) = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_args[6] = C.gpointer(gbox.AssignOnce(callback))
	}

	girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_service_async", _args[:], nil)

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(callback)
}

// LookupServiceFinish retrieves the result of a previous call to
// g_resolver_lookup_service_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Target, or NULL on error. See
//      g_resolver_lookup_service() for more details.
//
func (resolver *Resolver) LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_gret := girepository.MustFind("Gio", "Resolver").InvokeMethod("lookup_service_finish", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Gio", "SrvTarget").InvokeMethod("free", args[:], nil)
				}
			},
		)
		_list = append(_list, dst)
	})
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SetDefault sets resolver to be the application's default resolver (reffing
// resolver, and unreffing the previous default resolver, if any). Future calls
// to g_resolver_get_default() will return this resolver.
//
// This can be used if an application wants to perform any sort of DNS caching
// or "pinning"; it can implement its own #GResolver that calls the original
// default resolver for DNS operations, and implements its own cache policies on
// top of that, and then set itself as the default resolver for all later code
// to use.
func (resolver *Resolver) SetDefault() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))

	girepository.MustFind("Gio", "Resolver").InvokeMethod("set_default", _args[:], nil)

	runtime.KeepAlive(resolver)
}

// ResolverGetDefault gets the default #GResolver. You should unref it when you
// are done with it. #GResolver may use its reference count as a hint about how
// many threads it should allocate for concurrent DNS resolutions.
//
// The function returns the following values:
//
//    - resolver: default #GResolver.
//
func ResolverGetDefault() Resolverer {
	_gret := girepository.MustFind("Gio", "get_default").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _resolver Resolverer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.Resolverer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Resolverer)
			return ok
		})
		rv, ok := casted.(Resolverer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Resolverer")
		}
		_resolver = rv
	}

	return _resolver
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name(GResolver*, gchar*, GCancellable*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name_finish(GResolver*, GAsyncResult*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name_with_flags(GResolver*, gchar*, GResolverNameLookupFlags, GCancellable*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish(GResolver*, GAsyncResult*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_records(GResolver*, gchar*, GResolverRecordType, GCancellable*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_records_finish(GResolver*, GAsyncResult*, GError**);
// extern GList* _gotk4_gio2_ResolverClass_lookup_service_finish(GResolver*, GAsyncResult*, GError**);
// extern gchar* _gotk4_gio2_ResolverClass_lookup_by_address(GResolver*, GInetAddress*, GCancellable*, GError**);
// extern gchar* _gotk4_gio2_ResolverClass_lookup_by_address_finish(GResolver*, GAsyncResult*, GError**);
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern void _gotk4_gio2_ResolverClass_reload(GResolver*);
// extern void _gotk4_gio2_Resolver_ConnectReload(gpointer, guintptr);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_resolver_name_lookup_flags_get_type()), F: marshalResolverNameLookupFlags},
		{T: externglib.Type(C.g_resolver_get_type()), F: marshalResolverer},
	})
}

// ResolverNameLookupFlags flags to modify lookup behavior.
type ResolverNameLookupFlags C.guint

const (
	// ResolverNameLookupFlagsDefault: default behavior (same as
	// g_resolver_lookup_by_name()).
	ResolverNameLookupFlagsDefault ResolverNameLookupFlags = 0b0
	// ResolverNameLookupFlagsIPv4Only: only resolve ipv4 addresses.
	ResolverNameLookupFlagsIPv4Only ResolverNameLookupFlags = 0b1
	// ResolverNameLookupFlagsIPv6Only: only resolve ipv6 addresses.
	ResolverNameLookupFlagsIPv6Only ResolverNameLookupFlags = 0b10
)

func marshalResolverNameLookupFlags(p uintptr) (interface{}, error) {
	return ResolverNameLookupFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ResolverNameLookupFlags.
func (r ResolverNameLookupFlags) String() string {
	if r == 0 {
		return "ResolverNameLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(94)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case ResolverNameLookupFlagsDefault:
			builder.WriteString("Default|")
		case ResolverNameLookupFlagsIPv4Only:
			builder.WriteString("IPv4Only|")
		case ResolverNameLookupFlagsIPv6Only:
			builder.WriteString("IPv6Only|")
		default:
			builder.WriteString(fmt.Sprintf("ResolverNameLookupFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r ResolverNameLookupFlags) Has(other ResolverNameLookupFlags) bool {
	return (r & other) == other
}

// ResolverOverrider contains methods that are overridable.
type ResolverOverrider interface {
	// LookupByAddress: synchronously reverse-resolves address to determine its
	// associated hostname.
	//
	// If the DNS resolution fails, error (if non-NULL) will be set to a value
	// from Error.
	//
	// If cancellable is non-NULL, it can be used to cancel the operation, in
	// which case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - ctx (optional) or NULL.
	//    - address to reverse-resolve.
	//
	// The function returns the following values:
	//
	//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL
	//      on error.
	//
	LookupByAddress(ctx context.Context, address *InetAddress) (string, error)
	// LookupByAddressFinish retrieves the result of a previous call to
	// g_resolver_lookup_by_address_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL
	//      on error.
	//
	LookupByAddressFinish(result AsyncResulter) (string, error)
	// LookupByName: synchronously resolves hostname to determine its associated
	// IP address(es). hostname may be an ASCII-only or UTF-8 hostname, or the
	// textual form of an IP address (in which case this just becomes a wrapper
	// around g_inet_address_new_from_string()).
	//
	// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
	// Address, sorted in order of preference and guaranteed to not contain
	// duplicates. That is, if using the result to connect to hostname, you
	// should attempt to connect to the first address first, then the second if
	// the first fails, etc. If you are using the result to listen on a socket,
	// it is appropriate to add each result using e.g.
	// g_socket_listener_add_address().
	//
	// If the DNS resolution fails, error (if non-NULL) will be set to a value
	// from Error and NULL will be returned.
	//
	// If cancellable is non-NULL, it can be used to cancel the operation, in
	// which case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
	//
	// If you are planning to connect to a socket on the resolved IP address, it
	// may be easier to create a Address and use its Connectable interface.
	//
	// The function takes the following parameters:
	//
	//    - ctx (optional) or NULL.
	//    - hostname to look up.
	//
	// The function returns the following values:
	//
	//    - list: non-empty #GList of Address, or NULL on error. You must unref
	//      each of the addresses and free the list when you are done with it.
	//      (You can use g_resolver_free_addresses() to do this.).
	//
	LookupByName(ctx context.Context, hostname string) ([]InetAddress, error)
	// LookupByNameFinish retrieves the result of a call to
	// g_resolver_lookup_by_name_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for
	//      more details.
	//
	LookupByNameFinish(result AsyncResulter) ([]InetAddress, error)
	// LookupByNameWithFlags: this differs from g_resolver_lookup_by_name() in
	// that you can modify the lookup behavior with flags. For example this can
	// be used to limit results with RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
	//
	// The function takes the following parameters:
	//
	//    - ctx (optional) or NULL.
	//    - hostname to look up.
	//    - flags: extra NameLookupFlags for the lookup.
	//
	// The function returns the following values:
	//
	//    - list: non-empty #GList of Address, or NULL on error. You must unref
	//      each of the addresses and free the list when you are done with it.
	//      (You can use g_resolver_free_addresses() to do this.).
	//
	LookupByNameWithFlags(ctx context.Context, hostname string, flags ResolverNameLookupFlags) ([]InetAddress, error)
	// LookupByNameWithFlagsFinish retrieves the result of a call to
	// g_resolver_lookup_by_name_with_flags_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for
	//      more details.
	//
	LookupByNameWithFlagsFinish(result AsyncResulter) ([]InetAddress, error)
	// LookupRecords: synchronously performs a DNS record lookup for the given
	// rrname and returns a list of records as #GVariant tuples. See RecordType
	// for information on what the records contain for each record_type.
	//
	// If the DNS resolution fails, error (if non-NULL) will be set to a value
	// from Error and NULL will be returned.
	//
	// If cancellable is non-NULL, it can be used to cancel the operation, in
	// which case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - ctx (optional) or NULL.
	//    - rrname: DNS name to look up the record for.
	//    - recordType: type of DNS record to look up.
	//
	// The function returns the following values:
	//
	//    - list: non-empty #GList of #GVariant, or NULL on error. You must free
	//      each of the records and the list when you are done with it. (You can
	//      use g_list_free_full() with g_variant_unref() to do this.).
	//
	LookupRecords(ctx context.Context, rrname string, recordType ResolverRecordType) ([]*glib.Variant, error)
	// LookupRecordsFinish retrieves the result of a previous call to
	// g_resolver_lookup_records_async(). Returns a non-empty list of records as
	// #GVariant tuples. See RecordType for information on what the records
	// contain.
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - list: non-empty #GList of #GVariant, or NULL on error. You must free
	//      each of the records and the list when you are done with it. (You can
	//      use g_list_free_full() with g_variant_unref() to do this.).
	//
	LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error)
	// LookupServiceFinish retrieves the result of a previous call to
	// g_resolver_lookup_service_async().
	//
	// If the DNS resolution failed, error (if non-NULL) will be set to a value
	// from Error. If the operation was cancelled, error will be set to
	// G_IO_ERROR_CANCELLED.
	//
	// The function takes the following parameters:
	//
	//    - result passed to your ReadyCallback.
	//
	// The function returns the following values:
	//
	//    - list: non-empty #GList of Target, or NULL on error. See
	//      g_resolver_lookup_service() for more details.
	//
	LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error)
	Reload()
}

// Resolver provides cancellable synchronous and asynchronous DNS resolution,
// for hostnames (g_resolver_lookup_by_address(), g_resolver_lookup_by_name()
// and their async variants) and SRV (service) records
// (g_resolver_lookup_service()).
//
// Address and Service provide wrappers around #GResolver functionality that
// also implement Connectable, making it easy to connect to a remote
// host/service.
type Resolver struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*Resolver)(nil)
)

// Resolverer describes types inherited from class Resolver.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Resolverer interface {
	externglib.Objector
	baseResolver() *Resolver
}

var _ Resolverer = (*Resolver)(nil)

func classInitResolverer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GResolverClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GResolverClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface {
		LookupByAddress(ctx context.Context, address *InetAddress) (string, error)
	}); ok {
		pclass.lookup_by_address = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_address)
	}

	if _, ok := goval.(interface {
		LookupByAddressFinish(result AsyncResulter) (string, error)
	}); ok {
		pclass.lookup_by_address_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_address_finish)
	}

	if _, ok := goval.(interface {
		LookupByName(ctx context.Context, hostname string) ([]InetAddress, error)
	}); ok {
		pclass.lookup_by_name = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name)
	}

	if _, ok := goval.(interface {
		LookupByNameFinish(result AsyncResulter) ([]InetAddress, error)
	}); ok {
		pclass.lookup_by_name_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name_finish)
	}

	if _, ok := goval.(interface {
		LookupByNameWithFlags(ctx context.Context, hostname string, flags ResolverNameLookupFlags) ([]InetAddress, error)
	}); ok {
		pclass.lookup_by_name_with_flags = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name_with_flags)
	}

	if _, ok := goval.(interface {
		LookupByNameWithFlagsFinish(result AsyncResulter) ([]InetAddress, error)
	}); ok {
		pclass.lookup_by_name_with_flags_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish)
	}

	if _, ok := goval.(interface {
		LookupRecords(ctx context.Context, rrname string, recordType ResolverRecordType) ([]*glib.Variant, error)
	}); ok {
		pclass.lookup_records = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_records)
	}

	if _, ok := goval.(interface {
		LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error)
	}); ok {
		pclass.lookup_records_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_records_finish)
	}

	if _, ok := goval.(interface {
		LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error)
	}); ok {
		pclass.lookup_service_finish = (*[0]byte)(C._gotk4_gio2_ResolverClass_lookup_service_finish)
	}

	if _, ok := goval.(interface{ Reload() }); ok {
		pclass.reload = (*[0]byte)(C._gotk4_gio2_ResolverClass_reload)
	}
}

//export _gotk4_gio2_ResolverClass_lookup_by_address
func _gotk4_gio2_ResolverClass_lookup_by_address(arg0 *C.GResolver, arg1 *C.GInetAddress, arg2 *C.GCancellable, _cerr **C.GError) (cret *C.gchar) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByAddress(ctx context.Context, address *InetAddress) (string, error)
	})

	var _cancellable context.Context // out
	var _address *InetAddress        // out

	if arg2 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg2))
	}
	_address = wrapInetAddress(externglib.Take(unsafe.Pointer(arg1)))

	utf8, _goerr := iface.LookupByAddress(_cancellable, _address)

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_address_finish
func _gotk4_gio2_ResolverClass_lookup_by_address_finish(arg0 *C.GResolver, arg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.gchar) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByAddressFinish(result AsyncResulter) (string, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	utf8, _goerr := iface.LookupByAddressFinish(_result)

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_name
func _gotk4_gio2_ResolverClass_lookup_by_name(arg0 *C.GResolver, arg1 *C.gchar, arg2 *C.GCancellable, _cerr **C.GError) (cret *C.GList) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByName(ctx context.Context, hostname string) ([]InetAddress, error)
	})

	var _cancellable context.Context // out
	var _hostname string             // out

	if arg2 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg2))
	}
	_hostname = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	list, _goerr := iface.LookupByName(_cancellable, _hostname)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GInetAddress // out
		dst = (*C.GInetAddress)(unsafe.Pointer((&src).Native()))
		C.g_object_ref(C.gpointer((&src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_name_finish
func _gotk4_gio2_ResolverClass_lookup_by_name_finish(arg0 *C.GResolver, arg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByNameFinish(result AsyncResulter) ([]InetAddress, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	list, _goerr := iface.LookupByNameFinish(_result)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GInetAddress // out
		dst = (*C.GInetAddress)(unsafe.Pointer((&src).Native()))
		C.g_object_ref(C.gpointer((&src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_name_with_flags
func _gotk4_gio2_ResolverClass_lookup_by_name_with_flags(arg0 *C.GResolver, arg1 *C.gchar, arg2 C.GResolverNameLookupFlags, arg3 *C.GCancellable, _cerr **C.GError) (cret *C.GList) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByNameWithFlags(ctx context.Context, hostname string, flags ResolverNameLookupFlags) ([]InetAddress, error)
	})

	var _cancellable context.Context   // out
	var _hostname string               // out
	var _flags ResolverNameLookupFlags // out

	if arg3 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg3))
	}
	_hostname = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_flags = ResolverNameLookupFlags(arg2)

	list, _goerr := iface.LookupByNameWithFlags(_cancellable, _hostname, _flags)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GInetAddress // out
		dst = (*C.GInetAddress)(unsafe.Pointer((&src).Native()))
		C.g_object_ref(C.gpointer((&src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish
func _gotk4_gio2_ResolverClass_lookup_by_name_with_flags_finish(arg0 *C.GResolver, arg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupByNameWithFlagsFinish(result AsyncResulter) ([]InetAddress, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	list, _goerr := iface.LookupByNameWithFlagsFinish(_result)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GInetAddress // out
		dst = (*C.GInetAddress)(unsafe.Pointer((&src).Native()))
		C.g_object_ref(C.gpointer((&src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_records
func _gotk4_gio2_ResolverClass_lookup_records(arg0 *C.GResolver, arg1 *C.gchar, arg2 C.GResolverRecordType, arg3 *C.GCancellable, _cerr **C.GError) (cret *C.GList) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupRecords(ctx context.Context, rrname string, recordType ResolverRecordType) ([]*glib.Variant, error)
	})

	var _cancellable context.Context   // out
	var _rrname string                 // out
	var _recordType ResolverRecordType // out

	if arg3 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg3))
	}
	_rrname = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_recordType = ResolverRecordType(arg2)

	list, _goerr := iface.LookupRecords(_cancellable, _rrname, _recordType)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GVariant // out
		dst = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(src)))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_records_finish
func _gotk4_gio2_ResolverClass_lookup_records_finish(arg0 *C.GResolver, arg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	list, _goerr := iface.LookupRecordsFinish(_result)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GVariant // out
		dst = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(src)))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_lookup_service_finish
func _gotk4_gio2_ResolverClass_lookup_service_finish(arg0 *C.GResolver, arg1 *C.GAsyncResult, _cerr **C.GError) (cret *C.GList) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error)
	})

	var _result AsyncResulter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.AsyncResulter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(AsyncResulter)
			return ok
		})
		rv, ok := casted.(AsyncResulter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.AsyncResulter")
		}
		_result = rv
	}

	list, _goerr := iface.LookupServiceFinish(_result)

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GSrvTarget // out
		dst = (*C.GSrvTarget)(gextras.StructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(src)), nil)
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}
	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_gio2_ResolverClass_reload
func _gotk4_gio2_ResolverClass_reload(arg0 *C.GResolver) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Reload() })

	iface.Reload()
}

func wrapResolver(obj *externglib.Object) *Resolver {
	return &Resolver{
		Object: obj,
	}
}

func marshalResolverer(p uintptr) (interface{}, error) {
	return wrapResolver(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (resolver *Resolver) baseResolver() *Resolver {
	return resolver
}

// BaseResolver returns the underlying base object.
func BaseResolver(obj Resolverer) *Resolver {
	return obj.baseResolver()
}

//export _gotk4_gio2_Resolver_ConnectReload
func _gotk4_gio2_Resolver_ConnectReload(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectReload: emitted when the resolver notices that the system resolver
// configuration has changed.
func (resolver *Resolver) ConnectReload(f func()) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(resolver, "reload", false, unsafe.Pointer(C._gotk4_gio2_Resolver_ConnectReload), f)
}

// LookupByAddress: synchronously reverse-resolves address to determine its
// associated hostname.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - address to reverse-resolve.
//
// The function returns the following values:
//
//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//      error.
//
func (resolver *Resolver) LookupByAddress(ctx context.Context, address *InetAddress) (string, error) {
	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.GInetAddress // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(address.Native()))

	_cret = C.g_resolver_lookup_by_address(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LookupByAddressAsync begins asynchronously reverse-resolving address to
// determine its associated hostname, and eventually calls callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - address to reverse-resolve.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupByAddressAsync(ctx context.Context, address *InetAddress, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GInetAddress       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(address.Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_by_address_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(callback)
}

// LookupByAddressFinish retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//      error.
//
func (resolver *Resolver) LookupByAddressFinish(result AsyncResulter) (string, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_resolver_lookup_by_address_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LookupByName: synchronously resolves hostname to determine its associated IP
// address(es). hostname may be an ASCII-only or UTF-8 hostname, or the textual
// form of an IP address (in which case this just becomes a wrapper around
// g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// Address, sorted in order of preference and guaranteed to not contain
// duplicates. That is, if using the result to connect to hostname, you should
// attempt to connect to the first address first, then the second if the first
// fails, etc. If you are using the result to listen on a socket, it is
// appropriate to add each result using e.g. g_socket_listener_add_address().
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP address, it may
// be easier to create a Address and use its Connectable interface.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Address, or NULL on error. You must unref each
//      of the addresses and free the list when you are done with it. (You can
//      use g_resolver_free_addresses() to do this.).
//
func (resolver *Resolver) LookupByName(ctx context.Context, hostname string) ([]InetAddress, error) {
	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_resolver_lookup_by_name(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)

	var _list []InetAddress // out
	var _goerr error        // out

	_list = make([]InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst InetAddress // out
		dst = *wrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameAsync begins asynchronously resolving hostname to determine its
// associated IP address(es), and eventually calls callback, which must call
// g_resolver_lookup_by_name_finish() to get the result. See
// g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up the address of.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupByNameAsync(ctx context.Context, hostname string, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_by_name_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(callback)
}

// LookupByNameFinish retrieves the result of a call to
// g_resolver_lookup_by_name_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//      details.
//
func (resolver *Resolver) LookupByNameFinish(result AsyncResulter) ([]InetAddress, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_resolver_lookup_by_name_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []InetAddress // out
	var _goerr error        // out

	_list = make([]InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst InetAddress // out
		dst = *wrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameWithFlags: this differs from g_resolver_lookup_by_name() in that
// you can modify the lookup behavior with flags. For example this can be used
// to limit results with RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up.
//    - flags: extra NameLookupFlags for the lookup.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Address, or NULL on error. You must unref each
//      of the addresses and free the list when you are done with it. (You can
//      use g_resolver_free_addresses() to do this.).
//
func (resolver *Resolver) LookupByNameWithFlags(ctx context.Context, hostname string, flags ResolverNameLookupFlags) ([]InetAddress, error) {
	var _arg0 *C.GResolver               // out
	var _arg3 *C.GCancellable            // out
	var _arg1 *C.gchar                   // out
	var _arg2 C.GResolverNameLookupFlags // out
	var _cret *C.GList                   // in
	var _cerr *C.GError                  // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverNameLookupFlags(flags)

	_cret = C.g_resolver_lookup_by_name_with_flags(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)

	var _list []InetAddress // out
	var _goerr error        // out

	_list = make([]InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst InetAddress // out
		dst = *wrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameWithFlagsAsync begins asynchronously resolving hostname to
// determine its associated IP address(es), and eventually calls callback, which
// must call g_resolver_lookup_by_name_with_flags_finish() to get the result.
// See g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up the address of.
//    - flags: extra NameLookupFlags for the lookup.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupByNameWithFlagsAsync(ctx context.Context, hostname string, flags ResolverNameLookupFlags, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver               // out
	var _arg3 *C.GCancellable            // out
	var _arg1 *C.gchar                   // out
	var _arg2 C.GResolverNameLookupFlags // out
	var _arg4 C.GAsyncReadyCallback      // out
	var _arg5 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverNameLookupFlags(flags)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_by_name_with_flags_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(callback)
}

// LookupByNameWithFlagsFinish retrieves the result of a call to
// g_resolver_lookup_by_name_with_flags_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//      details.
//
func (resolver *Resolver) LookupByNameWithFlagsFinish(result AsyncResulter) ([]InetAddress, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_resolver_lookup_by_name_with_flags_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []InetAddress // out
	var _goerr error        // out

	_list = make([]InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst InetAddress // out
		dst = *wrapInetAddress(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupRecords: synchronously performs a DNS record lookup for the given
// rrname and returns a list of records as #GVariant tuples. See RecordType for
// information on what the records contain for each record_type.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - rrname: DNS name to look up the record for.
//    - recordType: type of DNS record to look up.
//
// The function returns the following values:
//
//    - list: non-empty #GList of #GVariant, or NULL on error. You must free each
//      of the records and the list when you are done with it. (You can use
//      g_list_free_full() with g_variant_unref() to do this.).
//
func (resolver *Resolver) LookupRecords(ctx context.Context, rrname string, recordType ResolverRecordType) ([]*glib.Variant, error) {
	var _arg0 *C.GResolver          // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GResolverRecordType // out
	var _cret *C.GList              // in
	var _cerr *C.GError             // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverRecordType(recordType)

	_cret = C.g_resolver_lookup_records(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(recordType)

	var _list []*glib.Variant // out
	var _goerr error          // out

	_list = make([]*glib.Variant, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVariant)(v)
		var dst *glib.Variant // out
		dst = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupRecordsAsync begins asynchronously performing a DNS lookup for the
// given rrname, and eventually calls callback, which must call
// g_resolver_lookup_records_finish() to get the final result. See
// g_resolver_lookup_records() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - rrname: DNS name to look up the record for.
//    - recordType: type of DNS record to look up.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupRecordsAsync(ctx context.Context, rrname string, recordType ResolverRecordType, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg3 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 C.GResolverRecordType // out
	var _arg4 C.GAsyncReadyCallback // out
	var _arg5 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(rrname)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GResolverRecordType(recordType)
	if callback != nil {
		_arg4 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg5 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_records_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(rrname)
	runtime.KeepAlive(recordType)
	runtime.KeepAlive(callback)
}

// LookupRecordsFinish retrieves the result of a previous call to
// g_resolver_lookup_records_async(). Returns a non-empty list of records as
// #GVariant tuples. See RecordType for information on what the records contain.
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list: non-empty #GList of #GVariant, or NULL on error. You must free each
//      of the records and the list when you are done with it. (You can use
//      g_list_free_full() with g_variant_unref() to do this.).
//
func (resolver *Resolver) LookupRecordsFinish(result AsyncResulter) ([]*glib.Variant, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_resolver_lookup_records_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*glib.Variant // out
	var _goerr error          // out

	_list = make([]*glib.Variant, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVariant)(v)
		var dst *glib.Variant // out
		dst = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupService: synchronously performs a DNS SRV lookup for the given service
// and protocol in the given domain and returns an array of Target. domain may
// be an ASCII-only or UTF-8 hostname. Note also that the service and protocol
// arguments do not include the leading underscore that appears in the actual
// DNS entry.
//
// On success, g_resolver_lookup_service() will return a non-empty #GList of
// Target, sorted in order of preference. (That is, you should attempt to
// connect to the first target first, then the second if the first fails, etc.)
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to the service, it is usually easier to create
// a Service and use its Connectable interface.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - service type to look up (eg, "ldap").
//    - protocol: networking protocol to use for service (eg, "tcp").
//    - domain: DNS domain to look up the service in.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Target, or NULL on error. You must free each of
//      the targets and the list when you are done with it. (You can use
//      g_resolver_free_targets() to do this.).
//
func (resolver *Resolver) LookupService(ctx context.Context, service, protocol, domain string) ([]*SrvTarget, error) {
	var _arg0 *C.GResolver    // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_resolver_lookup_service(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSrvTarget)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_srv_target_free((*C.GSrvTarget)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupServiceAsync begins asynchronously performing a DNS SRV lookup for the
// given service and protocol in the given domain, and eventually calls
// callback, which must call g_resolver_lookup_service_finish() to get the final
// result. See g_resolver_lookup_service() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - service type to look up (eg, "ldap").
//    - protocol: networking protocol to use for service (eg, "tcp").
//    - domain: DNS domain to look up the service in.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupServiceAsync(ctx context.Context, service, protocol, domain string, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg3))
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_service_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(callback)
}

// LookupServiceFinish retrieves the result of a previous call to
// g_resolver_lookup_service_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Target, or NULL on error. See
//      g_resolver_lookup_service() for more details.
//
func (resolver *Resolver) LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

	_cret = C.g_resolver_lookup_service_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSrvTarget)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_srv_target_free((*C.GSrvTarget)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SetDefault sets resolver to be the application's default resolver (reffing
// resolver, and unreffing the previous default resolver, if any). Future calls
// to g_resolver_get_default() will return this resolver.
//
// This can be used if an application wants to perform any sort of DNS caching
// or "pinning"; it can implement its own #GResolver that calls the original
// default resolver for DNS operations, and implements its own cache policies on
// top of that, and then set itself as the default resolver for all later code
// to use.
func (resolver *Resolver) SetDefault() {
	var _arg0 *C.GResolver // out

	_arg0 = (*C.GResolver)(unsafe.Pointer(resolver.Native()))

	C.g_resolver_set_default(_arg0)
	runtime.KeepAlive(resolver)
}

// ResolverGetDefault gets the default #GResolver. You should unref it when you
// are done with it. #GResolver may use its reference count as a hint about how
// many threads it should allocate for concurrent DNS resolutions.
//
// The function returns the following values:
//
//    - resolver: default #GResolver.
//
func ResolverGetDefault() Resolverer {
	var _cret *C.GResolver // in

	_cret = C.g_resolver_get_default()

	var _resolver Resolverer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.Resolverer is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Resolverer)
			return ok
		})
		rv, ok := casted.(Resolverer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Resolverer")
		}
		_resolver = rv
	}

	return _resolver
}

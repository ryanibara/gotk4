// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunched(gpointer, GAppInfo*, GVariant*, guintptr);
// extern void _gotk4_gio2_AppLaunchContext_ConnectLaunchFailed(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_AppLaunchContextClass_launched(GAppLaunchContext*, GAppInfo*, GVariant*);
// extern void _gotk4_gio2_AppLaunchContextClass_launch_failed(GAppLaunchContext*, char*);
// extern char* _gotk4_gio2_AppLaunchContextClass_get_startup_notify_id(GAppLaunchContext*, GAppInfo*, GList*);
// extern char* _gotk4_gio2_AppLaunchContextClass_get_display(GAppLaunchContext*, GAppInfo*, GList*);
// GAppInfo* _gotk4_gio2_AppInfo_virtual_dup(void* fnptr, GAppInfo* arg0) {
//   return ((GAppInfo* (*)(GAppInfo*))(fnptr))(arg0);
// };
// GIcon* _gotk4_gio2_AppInfo_virtual_get_icon(void* fnptr, GAppInfo* arg0) {
//   return ((GIcon* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_description(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_executable(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_id(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppInfo_virtual_get_name(void* fnptr, GAppInfo* arg0) {
//   return ((char* (*)(GAppInfo*))(fnptr))(arg0);
// };
// char* _gotk4_gio2_AppLaunchContext_virtual_get_display(void* fnptr, GAppLaunchContext* arg0, GAppInfo* arg1, GList* arg2) {
//   return ((char* (*)(GAppLaunchContext*, GAppInfo*, GList*))(fnptr))(arg0, arg1, arg2);
// };
// char* _gotk4_gio2_AppLaunchContext_virtual_get_startup_notify_id(void* fnptr, GAppLaunchContext* arg0, GAppInfo* arg1, GList* arg2) {
//   return ((char* (*)(GAppLaunchContext*, GAppInfo*, GList*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_add_supports_type(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_can_remove_supports_type(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_equal(void* fnptr, GAppInfo* arg0, GAppInfo* arg1) {
//   return ((gboolean (*)(GAppInfo*, GAppInfo*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_launch(void* fnptr, GAppInfo* arg0, GList* arg1, GAppLaunchContext* arg2, GError** arg3) {
//   return ((gboolean (*)(GAppInfo*, GList*, GAppLaunchContext*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_launch_uris(void* fnptr, GAppInfo* arg0, GList* arg1, GAppLaunchContext* arg2, GError** arg3) {
//   return ((gboolean (*)(GAppInfo*, GList*, GAppLaunchContext*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_remove_supports_type(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_set_as_default_for_extension(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_set_as_default_for_type(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_set_as_last_used_for_type(void* fnptr, GAppInfo* arg0, char* arg1, GError** arg2) {
//   return ((gboolean (*)(GAppInfo*, char*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_should_show(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_supports_files(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_AppInfo_virtual_supports_uris(void* fnptr, GAppInfo* arg0) {
//   return ((gboolean (*)(GAppInfo*))(fnptr))(arg0);
// };
// void _gotk4_gio2_AppLaunchContext_virtual_launch_failed(void* fnptr, GAppLaunchContext* arg0, char* arg1) {
//   ((void (*)(GAppLaunchContext*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_AppLaunchContext_virtual_launched(void* fnptr, GAppLaunchContext* arg0, GAppInfo* arg1, GVariant* arg2) {
//   ((void (*)(GAppLaunchContext*, GAppInfo*, GVariant*))(fnptr))(arg0, arg1, arg2);
// };
import "C"

// GType values.
var (
	GTypeAppInfo          = coreglib.Type(C.g_app_info_get_type())
	GTypeAppLaunchContext = coreglib.Type(C.g_app_launch_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAppInfo, F: marshalAppInfo},
		coreglib.TypeMarshaler{T: GTypeAppLaunchContext, F: marshalAppLaunchContext},
	})
}

// AppInfo and LaunchContext are used for describing and launching applications
// installed on the system.
//
// As of GLib 2.20, URIs will always be converted to POSIX paths (using
// g_file_get_path()) when using g_app_info_launch() even if the application
// requested an URI and not a POSIX path. For example for a desktop-file based
// application with Exec key totem U and a single URI, sftp://foo/file.avi, then
// /home/user/.gvfs/sftp on foo/file.avi will be passed. This will only work if
// a set of suitable GIO extensions (such as gvfs 2.26 compiled with FUSE
// support), is available and operational; if this is not the case, the URI will
// be passed unmodified to the application. Some URIs, such as mailto:, of
// course cannot be mapped to a POSIX path (in gvfs there's no FUSE mount for
// it); such URIs will be passed unmodified to the application.
//
// Specifically for gvfs 2.26 and later, the POSIX URI will be mapped back to
// the GIO URI in the #GFile constructors (since gvfs implements the #GVfs
// extension point). As such, if the application needs to examine the URI, it
// needs to use g_file_get_uri() or similar on #GFile. In other words, an
// application cannot assume that the URI passed to e.g.
// g_file_new_for_commandline_arg() is equal to the result of g_file_get_uri().
// The following snippet illustrates this:
//
//    GFile *f;
//    char *uri;
//
//    file = g_file_new_for_commandline_arg (uri_from_commandline);
//
//    uri = g_file_get_uri (file);
//    strcmp (uri, uri_from_commandline) == 0;
//    g_free (uri);
//
//    if (g_file_has_uri_scheme (file, "cdda"))
//      {
//        // do something special with uri
//      }
//    g_object_unref (file);
//
// This code will work when both cdda://sr0/Track 1.wav and
// /home/user/.gvfs/cdda on sr0/Track 1.wav is passed to the application. It
// should be noted that it's generally not safe for applications to rely on the
// format of a particular URIs. Different launcher applications (e.g. file
// managers) may have different ideas of what a given URI means.
//
// AppInfo wraps an interface. This means the user can get the
// underlying type by calling Cast().
type AppInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AppInfo)(nil)
)

// AppInfor describes AppInfo's interface methods.
type AppInfor interface {
	coreglib.Objector

	// AddSupportsType adds a content type to the application information to
	// indicate the application is capable of opening files with the given
	// content type.
	AddSupportsType(contentType string) error
	// CanDelete obtains the information whether the Info can be deleted.
	CanDelete() bool
	// CanRemoveSupportsType checks if a supported content type can be removed
	// from an application.
	CanRemoveSupportsType() bool
	// Delete tries to delete a Info.
	Delete() bool
	// Dup creates a duplicate of a Info.
	Dup() *AppInfo
	// Equal checks if two Infos are equal.
	Equal(appinfo2 AppInfor) bool
	// Commandline gets the commandline with which the application will be
	// started.
	Commandline() string
	// Description gets a human-readable description of an installed
	// application.
	Description() string
	// DisplayName gets the display name of the application.
	DisplayName() string
	// Executable gets the executable's name for the installed application.
	Executable() string
	// Icon gets the icon for the application.
	Icon() *Icon
	// ID gets the ID of an application.
	ID() string
	// Name gets the installed name of the application.
	Name() string
	// SupportedTypes retrieves the list of content types that app_info claims
	// to support.
	SupportedTypes() []string
	// Launch launches the application.
	Launch(files []Filer, context *AppLaunchContext) error
	// LaunchURIs launches the application.
	LaunchURIs(uris []string, context *AppLaunchContext) error
	// LaunchURIsAsync: async version of g_app_info_launch_uris().
	LaunchURIsAsync(ctx context.Context, uris []string, context *AppLaunchContext, callback AsyncReadyCallback)
	// LaunchURIsFinish finishes a g_app_info_launch_uris_async() operation.
	LaunchURIsFinish(result AsyncResulter) error
	// RemoveSupportsType removes a supported type from an application, if
	// possible.
	RemoveSupportsType(contentType string) error
	// SetAsDefaultForExtension sets the application as the default handler for
	// the given file extension.
	SetAsDefaultForExtension(extension string) error
	// SetAsDefaultForType sets the application as the default handler for a
	// given type.
	SetAsDefaultForType(contentType string) error
	// SetAsLastUsedForType sets the application as the last used application
	// for a given type.
	SetAsLastUsedForType(contentType string) error
	// ShouldShow checks if the application info should be shown in menus that
	// list available applications.
	ShouldShow() bool
	// SupportsFiles checks if the application accepts files as arguments.
	SupportsFiles() bool
	// SupportsURIs checks if the application supports reading files and
	// directories from URIs.
	SupportsURIs() bool
}

var _ AppInfor = (*AppInfo)(nil)

func wrapAppInfo(obj *coreglib.Object) *AppInfo {
	return &AppInfo{
		Object: obj,
	}
}

func marshalAppInfo(p uintptr) (interface{}, error) {
	return wrapAppInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddSupportsType adds a content type to the application information to
// indicate the application is capable of opening files with the given content
// type.
//
// The function takes the following parameters:
//
//    - contentType: string.
//
func (appinfo *AppInfo) AddSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_add_supports_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CanRemoveSupportsType checks if a supported content type can be removed from
// an application.
//
// The function returns the following values:
//
//    - ok: TRUE if it is possible to remove supported content types from a given
//      appinfo, FALSE if not.
//
func (appinfo *AppInfo) CanRemoveSupportsType() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_can_remove_supports_type(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dup creates a duplicate of a Info.
//
// The function returns the following values:
//
//    - appInfo: duplicate of appinfo.
//
func (appinfo *AppInfo) Dup() *AppInfo {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GAppInfo // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_dup(_arg0)
	runtime.KeepAlive(appinfo)

	var _appInfo *AppInfo // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appInfo
}

// Equal checks if two Infos are equal.
//
// Note that the check *may not* compare each individual field, and only does an
// identity check. In case detecting changes in the contents is needed, program
// code must additionally compare relevant fields.
//
// The function takes the following parameters:
//
//    - appinfo2: second Info.
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo1 is equal to appinfo2. FALSE otherwise.
//
func (appinfo1 *AppInfo) Equal(appinfo2 AppInfor) bool {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo1).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo2).Native()))

	_cret = C.g_app_info_equal(_arg0, _arg1)
	runtime.KeepAlive(appinfo1)
	runtime.KeepAlive(appinfo2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Description gets a human-readable description of an installed application.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing a description of the application
//      appinfo, or NULL if none.
//
func (appinfo *AppInfo) Description() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_description(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Executable gets the executable's name for the installed application.
//
// The function returns the following values:
//
//    - filename: string containing the appinfo's application binaries name.
//
func (appinfo *AppInfo) Executable() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_executable(_arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Icon gets the icon for the application.
//
// The function returns the following values:
//
//    - icon (optional): default #GIcon for appinfo or NULL if there is no
//      default icon.
//
func (appinfo *AppInfo) Icon() *Icon {
	var _arg0 *C.GAppInfo // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_icon(_arg0)
	runtime.KeepAlive(appinfo)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _icon
}

// ID gets the ID of an application. An id is a string that identifies the
// application. The exact format of the id is platform dependent. For instance,
// on Unix this is the desktop file id from the xdg menu specification.
//
// Note that the returned ID may be NULL, depending on how the appinfo has been
// constructed.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the application's ID.
//
func (appinfo *AppInfo) ID() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_id(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Name gets the installed name of the application.
//
// The function returns the following values:
//
//    - utf8: name of the application for appinfo.
//
func (appinfo *AppInfo) Name() string {
	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_get_name(_arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Launch launches the application. Passes files to the launched application as
// arguments, using the optional context to get information about the details of
// the launcher (like what screen it is on). On error, error will be set
// accordingly.
//
// To launch the application without arguments pass a NULL files list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// Some URIs can be changed when passed through a GFile (for instance
// unsupported URIs with strange formats like mailto:), so if you have a textual
// URI you want to pass in as argument, consider using g_app_info_launch_uris()
// instead.
//
// The launched application inherits the environment of the launching process,
// but it can be modified with g_app_launch_context_setenv() and
// g_app_launch_context_unsetenv().
//
// On UNIX, this function sets the GIO_LAUNCHED_DESKTOP_FILE environment
// variable with the path of the launched desktop file and
// GIO_LAUNCHED_DESKTOP_FILE_PID to the process id of the launched process. This
// can be used to ignore GIO_LAUNCHED_DESKTOP_FILE, should it be inherited by
// further processes. The DISPLAY and DESKTOP_STARTUP_ID environment variables
// are also set, based on information provided in context.
//
// The function takes the following parameters:
//
//    - files (optional) of #GFile objects.
//    - context (optional) or NULL.
//
func (appinfo *AppInfo) Launch(files []Filer, context *AppLaunchContext) error {
	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	if files != nil {
		for i := len(files) - 1; i >= 0; i-- {
			src := files[i]
			var dst *C.GFile // out
			dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C.g_app_info_launch(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(files)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LaunchURIs launches the application. This passes the uris to the launched
// application as arguments, using the optional context to get information about
// the details of the launcher (like what screen it is on). On error, error will
// be set accordingly.
//
// To launch the application without arguments pass a NULL uris list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// The function takes the following parameters:
//
//    - uris (optional) containing URIs to launch.
//    - context (optional) or NULL.
//
func (appinfo *AppInfo) LaunchURIs(uris []string, context *AppLaunchContext) error {
	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	if uris != nil {
		for i := len(uris) - 1; i >= 0; i-- {
			src := uris[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C.g_app_info_launch_uris(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(uris)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveSupportsType removes a supported type from an application, if possible.
//
// The function takes the following parameters:
//
//    - contentType: string.
//
func (appinfo *AppInfo) RemoveSupportsType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_remove_supports_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsDefaultForExtension sets the application as the default handler for the
// given file extension.
//
// The function takes the following parameters:
//
//    - extension: string containing the file extension (without the dot).
//
func (appinfo *AppInfo) SetAsDefaultForExtension(extension string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_extension(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(extension)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsDefaultForType sets the application as the default handler for a given
// type.
//
// The function takes the following parameters:
//
//    - contentType: content type.
//
func (appinfo *AppInfo) SetAsDefaultForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_default_for_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAsLastUsedForType sets the application as the last used application for a
// given type. This will make the application appear as first in the list
// returned by g_app_info_get_recommended_for_type(), regardless of the default
// application for that content type.
//
// The function takes the following parameters:
//
//    - contentType: content type.
//
func (appinfo *AppInfo) SetAsLastUsedForType(contentType string) error {
	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_info_set_as_last_used_for_type(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ShouldShow checks if the application info should be shown in menus that list
// available applications.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo should be shown, FALSE otherwise.
//
func (appinfo *AppInfo) ShouldShow() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_should_show(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsFiles checks if the application accepts files as arguments.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo supports files.
//
func (appinfo *AppInfo) SupportsFiles() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_supports_files(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsURIs checks if the application supports reading files and directories
// from URIs.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo supports URIs.
//
func (appinfo *AppInfo) SupportsURIs() bool {
	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C.g_app_info_supports_uris(_arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// addSupportsType adds a content type to the application information to
// indicate the application is capable of opening files with the given content
// type.
//
// The function takes the following parameters:
//
//    - contentType: string.
//
func (appinfo *AppInfo) addSupportsType(contentType string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.add_supports_type

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_add_supports_type(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// canRemoveSupportsType checks if a supported content type can be removed from
// an application.
//
// The function returns the following values:
//
//    - ok: TRUE if it is possible to remove supported content types from a given
//      appinfo, FALSE if not.
//
func (appinfo *AppInfo) canRemoveSupportsType() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.can_remove_supports_type

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_can_remove_supports_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dup creates a duplicate of a Info.
//
// The function returns the following values:
//
//    - appInfo: duplicate of appinfo.
//
func (appinfo *AppInfo) dup() *AppInfo {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.dup

	var _arg0 *C.GAppInfo // out
	var _cret *C.GAppInfo // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_dup(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _appInfo *AppInfo // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appInfo
}

// Equal checks if two Infos are equal.
//
// Note that the check *may not* compare each individual field, and only does an
// identity check. In case detecting changes in the contents is needed, program
// code must additionally compare relevant fields.
//
// The function takes the following parameters:
//
//    - appinfo2: second Info.
//
// The function returns the following values:
//
//    - ok: TRUE if appinfo1 is equal to appinfo2. FALSE otherwise.
//
func (appinfo1 *AppInfo) equal(appinfo2 AppInfor) bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo1))
	fnarg := gclass.equal

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo1).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo2).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_equal(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(appinfo1)
	runtime.KeepAlive(appinfo2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Description gets a human-readable description of an installed application.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing a description of the application
//      appinfo, or NULL if none.
//
func (appinfo *AppInfo) description() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_description

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_description(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Executable gets the executable's name for the installed application.
//
// The function returns the following values:
//
//    - filename: string containing the appinfo's application binaries name.
//
func (appinfo *AppInfo) executable() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_executable

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_executable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// Icon gets the icon for the application.
//
// The function returns the following values:
//
//    - icon (optional): default #GIcon for appinfo or NULL if there is no
//      default icon.
//
func (appinfo *AppInfo) icon() *Icon {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_icon

	var _arg0 *C.GAppInfo // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_icon(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _icon *Icon // out

	if _cret != nil {
		_icon = wrapIcon(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _icon
}

// iD gets the ID of an application. An id is a string that identifies the
// application. The exact format of the id is platform dependent. For instance,
// on Unix this is the desktop file id from the xdg menu specification.
//
// Note that the returned ID may be NULL, depending on how the appinfo has been
// constructed.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the application's ID.
//
func (appinfo *AppInfo) iD() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_id

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_id(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Name gets the installed name of the application.
//
// The function returns the following values:
//
//    - utf8: name of the application for appinfo.
//
func (appinfo *AppInfo) name() string {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.get_name

	var _arg0 *C.GAppInfo // out
	var _cret *C.char     // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_get_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Launch launches the application. Passes files to the launched application as
// arguments, using the optional context to get information about the details of
// the launcher (like what screen it is on). On error, error will be set
// accordingly.
//
// To launch the application without arguments pass a NULL files list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// Some URIs can be changed when passed through a GFile (for instance
// unsupported URIs with strange formats like mailto:), so if you have a textual
// URI you want to pass in as argument, consider using g_app_info_launch_uris()
// instead.
//
// The launched application inherits the environment of the launching process,
// but it can be modified with g_app_launch_context_setenv() and
// g_app_launch_context_unsetenv().
//
// On UNIX, this function sets the GIO_LAUNCHED_DESKTOP_FILE environment
// variable with the path of the launched desktop file and
// GIO_LAUNCHED_DESKTOP_FILE_PID to the process id of the launched process. This
// can be used to ignore GIO_LAUNCHED_DESKTOP_FILE, should it be inherited by
// further processes. The DISPLAY and DESKTOP_STARTUP_ID environment variables
// are also set, based on information provided in context.
//
// The function takes the following parameters:
//
//    - files (optional) of #GFile objects.
//    - context (optional) or NULL.
//
func (appinfo *AppInfo) launch(files []Filer, context *AppLaunchContext) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.launch

	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	if files != nil {
		for i := len(files) - 1; i >= 0; i-- {
			src := files[i]
			var dst *C.GFile // out
			dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C._gotk4_gio2_AppInfo_virtual_launch(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(files)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// launchURIs launches the application. This passes the uris to the launched
// application as arguments, using the optional context to get information about
// the details of the launcher (like what screen it is on). On error, error will
// be set accordingly.
//
// To launch the application without arguments pass a NULL uris list.
//
// Note that even if the launch is successful the application launched can fail
// to start if it runs into problems during startup. There is no way to detect
// this.
//
// The function takes the following parameters:
//
//    - uris (optional) containing URIs to launch.
//    - context (optional) or NULL.
//
func (appinfo *AppInfo) launchURIs(uris []string, context *AppLaunchContext) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.launch_uris

	var _arg0 *C.GAppInfo          // out
	var _arg1 *C.GList             // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	if uris != nil {
		for i := len(uris) - 1; i >= 0; i-- {
			src := uris[i]
			var dst *C.gchar // out
			dst = (*C.gchar)(unsafe.Pointer(C.CString(src)))
			defer C.free(unsafe.Pointer(dst))
			_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_list_free(_arg1)
	}
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C._gotk4_gio2_AppInfo_virtual_launch_uris(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(uris)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// removeSupportsType removes a supported type from an application, if possible.
//
// The function takes the following parameters:
//
//    - contentType: string.
//
func (appinfo *AppInfo) removeSupportsType(contentType string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.remove_supports_type

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_remove_supports_type(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setAsDefaultForExtension sets the application as the default handler for the
// given file extension.
//
// The function takes the following parameters:
//
//    - extension: string containing the file extension (without the dot).
//
func (appinfo *AppInfo) setAsDefaultForExtension(extension string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.set_as_default_for_extension

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(extension)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_set_as_default_for_extension(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(extension)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setAsDefaultForType sets the application as the default handler for a given
// type.
//
// The function takes the following parameters:
//
//    - contentType: content type.
//
func (appinfo *AppInfo) setAsDefaultForType(contentType string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.set_as_default_for_type

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_set_as_default_for_type(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// setAsLastUsedForType sets the application as the last used application for a
// given type. This will make the application appear as first in the list
// returned by g_app_info_get_recommended_for_type(), regardless of the default
// application for that content type.
//
// The function takes the following parameters:
//
//    - contentType: content type.
//
func (appinfo *AppInfo) setAsLastUsedForType(contentType string) error {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.set_as_last_used_for_type

	var _arg0 *C.GAppInfo // out
	var _arg1 *C.char     // out
	var _cerr *C.GError   // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppInfo_virtual_set_as_last_used_for_type(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(appinfo)
	runtime.KeepAlive(contentType)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// shouldShow checks if the application info should be shown in menus that list
// available applications.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo should be shown, FALSE otherwise.
//
func (appinfo *AppInfo) shouldShow() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.should_show

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_should_show(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// supportsFiles checks if the application accepts files as arguments.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo supports files.
//
func (appinfo *AppInfo) supportsFiles() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.supports_files

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_supports_files(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// supportsURIs checks if the application supports reading files and directories
// from URIs.
//
// The function returns the following values:
//
//    - ok: TRUE if the appinfo supports URIs.
//
func (appinfo *AppInfo) supportsURIs() bool {
	gclass := (*C.GAppInfoIface)(coreglib.PeekParentClass(appinfo))
	fnarg := gclass.supports_uris

	var _arg0 *C.GAppInfo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(appinfo).Native()))

	_cret = C._gotk4_gio2_AppInfo_virtual_supports_uris(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(appinfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AppInfoCreateFromCommandline creates a new Info from the given information.
//
// Note that for commandline, the quoting rules of the Exec key of the
// freedesktop.org Desktop Entry Specification
// (http://freedesktop.org/Standards/desktop-entry-spec) are applied. For
// example, if the commandline contains percent-encoded URIs, the
// percent-character must be doubled in order to prevent it from being swallowed
// by Exec key unquoting. See the specification for exact quoting rules.
//
// The function takes the following parameters:
//
//    - commandline to use.
//    - applicationName (optional): application name, or NULL to use commandline.
//    - flags that can specify details of the created Info.
//
// The function returns the following values:
//
//    - appInfo: new Info for given command.
//
func AppInfoCreateFromCommandline(commandline, applicationName string, flags AppInfoCreateFlags) (*AppInfo, error) {
	var _arg1 *C.char               // out
	var _arg2 *C.char               // out
	var _arg3 C.GAppInfoCreateFlags // out
	var _cret *C.GAppInfo           // in
	var _cerr *C.GError             // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(commandline)))
	defer C.free(unsafe.Pointer(_arg1))
	if applicationName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(applicationName)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = C.GAppInfoCreateFlags(flags)

	_cret = C.g_app_info_create_from_commandline(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(commandline)
	runtime.KeepAlive(applicationName)
	runtime.KeepAlive(flags)

	var _appInfo *AppInfo // out
	var _goerr error      // out

	_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _appInfo, _goerr
}

// AppInfoGetAll gets a list of all of the applications currently registered on
// this system.
//
// For desktop files, this includes applications that have NoDisplay=true set or
// are excluded from display by means of OnlyShowIn or NotShowIn. See
// g_app_info_should_show(). The returned list does not include applications
// which have the Hidden key set.
//
// The function returns the following values:
//
//    - list: newly allocated #GList of references to Infos.
//
func AppInfoGetAll() []*AppInfo {
	var _cret *C.GList // in

	_cret = C.g_app_info_get_all()

	var _list []*AppInfo // out

	_list = make([]*AppInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst *AppInfo // out
		dst = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetAllForType gets a list of all Infos for a given content type,
// including the recommended and fallback Infos. See
// g_app_info_get_recommended_for_type() and g_app_info_get_fallback_for_type().
//
// The function takes the following parameters:
//
//    - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//    - list of Infos for given content_type or NULL on error.
//
func AppInfoGetAllForType(contentType string) []*AppInfo {
	var _arg1 *C.char  // out
	var _cret *C.GList // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_all_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []*AppInfo // out

	_list = make([]*AppInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst *AppInfo // out
		dst = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetDefaultForType gets the default Info for a given content type.
//
// The function takes the following parameters:
//
//    - contentType: content type to find a Info for.
//    - mustSupportUris: if TRUE, the Info is expected to support URIs.
//
// The function returns the following values:
//
//    - appInfo (optional) for given content_type or NULL on error.
//
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) *AppInfo {
	var _arg1 *C.char     // out
	var _arg2 C.gboolean  // out
	var _cret *C.GAppInfo // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))
	if mustSupportUris {
		_arg2 = C.TRUE
	}

	_cret = C.g_app_info_get_default_for_type(_arg1, _arg2)
	runtime.KeepAlive(contentType)
	runtime.KeepAlive(mustSupportUris)

	var _appInfo *AppInfo // out

	if _cret != nil {
		_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _appInfo
}

// AppInfoGetDefaultForURIScheme gets the default application for handling URIs
// with the given URI scheme. A URI scheme is the initial part of the URI, up to
// but not including the ':', e.g. "http", "ftp" or "sip".
//
// The function takes the following parameters:
//
//    - uriScheme: string containing a URI scheme.
//
// The function returns the following values:
//
//    - appInfo (optional) for given uri_scheme or NULL on error.
//
func AppInfoGetDefaultForURIScheme(uriScheme string) *AppInfo {
	var _arg1 *C.char     // out
	var _cret *C.GAppInfo // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uriScheme)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_default_for_uri_scheme(_arg1)
	runtime.KeepAlive(uriScheme)

	var _appInfo *AppInfo // out

	if _cret != nil {
		_appInfo = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _appInfo
}

// AppInfoLaunchDefaultForURI: utility function that launches the default
// application registered to handle the specified uri. Synchronous I/O is done
// on the uri to detect the type of the file if required.
//
// The D-Bus–activated applications don't have to be started if your application
// terminates too soon after this function. To prevent this, use
// g_app_info_launch_default_for_uri_async() instead.
//
// The function takes the following parameters:
//
//    - uri to show.
//    - context (optional): optional LaunchContext.
//
func AppInfoLaunchDefaultForURI(uri string, context *AppLaunchContext) error {
	var _arg1 *C.char              // out
	var _arg2 *C.GAppLaunchContext // out
	var _cerr *C.GError            // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if context != nil {
		_arg2 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	}

	C.g_app_info_launch_default_for_uri(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AppLaunchContextOverrides contains methods that are overridable.
type AppLaunchContextOverrides struct {
	// Display gets the display string for the context. This is used to ensure
	// new applications are started on the same display as the launching
	// application, by setting the DISPLAY environment variable.
	//
	// The function takes the following parameters:
	//
	//    - info: Info.
	//    - files of #GFile objects.
	//
	// The function returns the following values:
	//
	//    - utf8 (optional): display string for the display.
	//
	Display func(info AppInfor, files []Filer) string
	// StartupNotifyID initiates startup notification for the application and
	// returns the DESKTOP_STARTUP_ID for the launched operation, if supported.
	//
	// Startup notification IDs are defined in the FreeDesktop.Org Startup
	// Notifications standard
	// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
	//
	// The function takes the following parameters:
	//
	//    - info: Info.
	//    - files of of #GFile objects.
	//
	// The function returns the following values:
	//
	//    - utf8 (optional): startup notification ID for the application, or NULL
	//      if not supported.
	//
	StartupNotifyID func(info AppInfor, files []Filer) string
	// LaunchFailed: called when an application has failed to launch, so that it
	// can cancel the application startup notification started in
	// g_app_launch_context_get_startup_notify_id().
	//
	// The function takes the following parameters:
	//
	//    - startupNotifyId: startup notification id that was returned by
	//      g_app_launch_context_get_startup_notify_id().
	//
	LaunchFailed func(startupNotifyId string)
	// The function takes the following parameters:
	//
	//    - info
	//    - platformData
	//
	Launched func(info AppInfor, platformData *glib.Variant)
}

func defaultAppLaunchContextOverrides(v *AppLaunchContext) AppLaunchContextOverrides {
	return AppLaunchContextOverrides{
		Display:         v.display,
		StartupNotifyID: v.startupNotifyID,
		LaunchFailed:    v.launchFailed,
		Launched:        v.launched,
	}
}

// AppLaunchContext: integrating the launch with the launching application. This
// is used to handle for instance startup notification and launching the new
// application on the same screen as the launching window.
type AppLaunchContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AppLaunchContext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*AppLaunchContext, *AppLaunchContextClass, AppLaunchContextOverrides](
		GTypeAppLaunchContext,
		initAppLaunchContextClass,
		wrapAppLaunchContext,
		defaultAppLaunchContextOverrides,
	)
}

func initAppLaunchContextClass(gclass unsafe.Pointer, overrides AppLaunchContextOverrides, classInitFunc func(*AppLaunchContextClass)) {
	pclass := (*C.GAppLaunchContextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAppLaunchContext))))

	if overrides.Display != nil {
		pclass.get_display = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_get_display)
	}

	if overrides.StartupNotifyID != nil {
		pclass.get_startup_notify_id = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_get_startup_notify_id)
	}

	if overrides.LaunchFailed != nil {
		pclass.launch_failed = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_launch_failed)
	}

	if overrides.Launched != nil {
		pclass.launched = (*[0]byte)(C._gotk4_gio2_AppLaunchContextClass_launched)
	}

	if classInitFunc != nil {
		class := (*AppLaunchContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAppLaunchContext(obj *coreglib.Object) *AppLaunchContext {
	return &AppLaunchContext{
		Object: obj,
	}
}

func marshalAppLaunchContext(p uintptr) (interface{}, error) {
	return wrapAppLaunchContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectLaunchFailed signal is emitted when a Info launch fails. The startup
// notification id is provided, so that the launcher can cancel the startup
// notification.
func (context *AppLaunchContext) ConnectLaunchFailed(f func(startupNotifyId string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "launch-failed", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunchFailed), f)
}

// ConnectLaunched signal is emitted when a Info is successfully launched. The
// platform_data is an GVariant dictionary mapping strings to variants (ie
// a{sv}), which contains additional, platform-specific data about this launch.
// On UNIX, at least the "pid" and "startup-notification-id" keys will be
// present.
func (context *AppLaunchContext) ConnectLaunched(f func(info AppInfor, platformData *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "launched", false, unsafe.Pointer(C._gotk4_gio2_AppLaunchContext_ConnectLaunched), f)
}

// NewAppLaunchContext creates a new application launch context. This is not
// normally used, instead you instantiate a subclass of this, such as
// AppLaunchContext.
//
// The function returns the following values:
//
//    - appLaunchContext: LaunchContext.
//
func NewAppLaunchContext() *AppLaunchContext {
	var _cret *C.GAppLaunchContext // in

	_cret = C.g_app_launch_context_new()

	var _appLaunchContext *AppLaunchContext // out

	_appLaunchContext = wrapAppLaunchContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appLaunchContext
}

// Display gets the display string for the context. This is used to ensure new
// applications are started on the same display as the launching application, by
// setting the DISPLAY environment variable.
//
// The function takes the following parameters:
//
//    - info: Info.
//    - files of #GFile objects.
//
// The function returns the following values:
//
//    - utf8 (optional): display string for the display.
//
func (context *AppLaunchContext) Display(info AppInfor, files []Filer) string {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C.g_app_launch_context_get_display(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// StartupNotifyID initiates startup notification for the application and
// returns the DESKTOP_STARTUP_ID for the launched operation, if supported.
//
// Startup notification IDs are defined in the FreeDesktop.Org Startup
// Notifications standard
// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
//
// The function takes the following parameters:
//
//    - info: Info.
//    - files of of #GFile objects.
//
// The function returns the following values:
//
//    - utf8 (optional): startup notification ID for the application, or NULL if
//      not supported.
//
func (context *AppLaunchContext) StartupNotifyID(info AppInfor, files []Filer) string {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C.g_app_launch_context_get_startup_notify_id(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// LaunchFailed: called when an application has failed to launch, so that it can
// cancel the application startup notification started in
// g_app_launch_context_get_startup_notify_id().
//
// The function takes the following parameters:
//
//    - startupNotifyId: startup notification id that was returned by
//      g_app_launch_context_get_startup_notify_id().
//
func (context *AppLaunchContext) LaunchFailed(startupNotifyId string) {
	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_app_launch_context_launch_failed(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(startupNotifyId)
}

// Display gets the display string for the context. This is used to ensure new
// applications are started on the same display as the launching application, by
// setting the DISPLAY environment variable.
//
// The function takes the following parameters:
//
//    - info: Info.
//    - files of #GFile objects.
//
// The function returns the following values:
//
//    - utf8 (optional): display string for the display.
//
func (context *AppLaunchContext) display(info AppInfor, files []Filer) string {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_display

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C._gotk4_gio2_AppLaunchContext_virtual_get_display(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// startupNotifyID initiates startup notification for the application and
// returns the DESKTOP_STARTUP_ID for the launched operation, if supported.
//
// Startup notification IDs are defined in the FreeDesktop.Org Startup
// Notifications standard
// (http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
//
// The function takes the following parameters:
//
//    - info: Info.
//    - files of of #GFile objects.
//
// The function returns the following values:
//
//    - utf8 (optional): startup notification ID for the application, or NULL if
//      not supported.
//
func (context *AppLaunchContext) startupNotifyID(info AppInfor, files []Filer) string {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_startup_notify_id

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GList             // out
	var _cret *C.char              // in

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	for i := len(files) - 1; i >= 0; i-- {
		src := files[i]
		var dst *C.GFile // out
		dst = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg2 = C.g_list_prepend(_arg2, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg2)

	_cret = C._gotk4_gio2_AppLaunchContext_virtual_get_startup_notify_id(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(files)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// launchFailed: called when an application has failed to launch, so that it can
// cancel the application startup notification started in
// g_app_launch_context_get_startup_notify_id().
//
// The function takes the following parameters:
//
//    - startupNotifyId: startup notification id that was returned by
//      g_app_launch_context_get_startup_notify_id().
//
func (context *AppLaunchContext) launchFailed(startupNotifyId string) {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.launch_failed

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(startupNotifyId)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gio2_AppLaunchContext_virtual_launch_failed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(startupNotifyId)
}

// The function takes the following parameters:
//
//    - info
//    - platformData
//
func (context *AppLaunchContext) launched(info AppInfor, platformData *glib.Variant) {
	gclass := (*C.GAppLaunchContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.launched

	var _arg0 *C.GAppLaunchContext // out
	var _arg1 *C.GAppInfo          // out
	var _arg2 *C.GVariant          // out

	_arg0 = (*C.GAppLaunchContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GAppInfo)(unsafe.Pointer(coreglib.InternObject(info).Native()))
	_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(platformData)))

	C._gotk4_gio2_AppLaunchContext_virtual_launched(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(info)
	runtime.KeepAlive(platformData)
}

// AppInfoIface: application Information interface, for operating system
// portability.
//
// An instance of this type is always passed by reference.
type AppInfoIface struct {
	*appInfoIface
}

// appInfoIface is the struct that's finalized.
type appInfoIface struct {
	native *C.GAppInfoIface
}

// AppLaunchContextClass: instance of this type is always passed by reference.
type AppLaunchContextClass struct {
	*appLaunchContextClass
}

// appLaunchContextClass is the struct that's finalized.
type appLaunchContextClass struct {
	native *C.GAppLaunchContextClass
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

// LoadBytes loads the contents of file and returns it as #GBytes.
//
// If file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents() and g_bytes_new_take().
//
// For resources, etag_out will be set to NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//
// The function returns the following values:
//
//    - etagOut (optional): location to place the current entity tag for the
//      file, or NULL if the entity tag is not needed.
//    - bytes or NULL and error is set.
//
func (file *File) LoadBytes(ctx context.Context) (string, *glib.Bytes, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GCancellable // out
	var _arg2 *C.gchar        // in
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.g_file_load_bytes(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)

	var _etagOut string    // out
	var _bytes *glib.Bytes // out
	var _goerr error       // out

	if _arg2 != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _etagOut, _bytes, _goerr
}

// LoadBytesAsync: asynchronously loads the contents of file as #GBytes.
//
// If file is a resource:// based URI, the resulting bytes will reference the
// embedded resource instead of a copy. Otherwise, this is equivalent to calling
// g_file_load_contents_async() and g_bytes_new_take().
//
// callback should call g_file_load_bytes_finish() to get the result of this
// asynchronous operation.
//
// See g_file_load_bytes() for more information.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - callback (optional) to call when the request is satisfied.
//
func (file *File) LoadBytesAsync(ctx context.Context, callback AsyncReadyCallback) {
	var _arg0 *C.GFile              // out
	var _arg1 *C.GCancellable       // out
	var _arg2 C.GAsyncReadyCallback // out
	var _arg3 C.gpointer

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if callback != nil {
		_arg2 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg3 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_file_load_bytes_async(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(callback)
}

// LoadBytesFinish completes an asynchronous request to
// g_file_load_bytes_async().
//
// For resources, etag_out will be set to NULL.
//
// The data contained in the resulting #GBytes is always zero-terminated, but
// this is not included in the #GBytes length. The resulting #GBytes should be
// freed with g_bytes_unref() when no longer in use.
//
// See g_file_load_bytes() for more information.
//
// The function takes the following parameters:
//
//    - result provided to the callback.
//
// The function returns the following values:
//
//    - etagOut (optional): location to place the current entity tag for the
//      file, or NULL if the entity tag is not needed.
//    - bytes or NULL and error is set.
//
func (file *File) LoadBytesFinish(result AsyncResulter) (string, *glib.Bytes, error) {
	var _arg0 *C.GFile        // out
	var _arg1 *C.GAsyncResult // out
	var _arg2 *C.gchar        // in
	var _cret *C.GBytes       // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_file_load_bytes_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(file)
	runtime.KeepAlive(result)

	var _etagOut string    // out
	var _bytes *glib.Bytes // out
	var _goerr error       // out

	if _arg2 != nil {
		_etagOut = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _etagOut, _bytes, _goerr
}

// PeekPath: exactly like g_file_get_path(), but caches the result via
// g_object_set_qdata_full(). This is useful for example in C applications which
// mix g_file_* APIs with native ones. It also avoids an extra duplicated string
// when possible, so will be generally more efficient.
//
// This call does no blocking I/O.
//
// The function returns the following values:
//
//    - filename (optional): string containing the #GFile's path, or NULL if no
//      such path exists. The returned string is owned by file.
//
func (file *File) PeekPath() string {
	var _arg0 *C.GFile // out
	var _cret *C.char  // in

	_arg0 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.g_file_peek_path(_arg0)
	runtime.KeepAlive(file)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

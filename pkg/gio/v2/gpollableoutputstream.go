// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// gssize _gotk4_gio2_PollableOutputStream_virtual_write_nonblocking(void* fnptr, GPollableOutputStream* arg0, void* arg1, gsize arg2, GError** arg3) {
//   return ((gssize (*)(GPollableOutputStream*, void*, gsize, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// WriteNonblocking attempts to write up to count bytes from buffer to stream,
// as with g_output_stream_write(). If stream is not currently writable, this
// will immediately return G_IO_ERROR_WOULD_BLOCK, and you can use
// g_pollable_output_stream_create_source() to create a #GSource that will be
// triggered when stream is writable.
//
// Note that since this method never blocks, you cannot actually use cancellable
// to cancel it. However, it will return an error if cancellable has already
// been cancelled when you call, which may happen if you call this method after
// a source triggers due to having been cancelled.
//
// Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same buffer and count in
// the next write call.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - buffer to write data from.
//
// The function returns the following values:
//
//    - gssize: number of bytes written, or -1 on error (including
//      G_IO_ERROR_WOULD_BLOCK).
//
func (stream *PollableOutputStream) WriteNonblocking(ctx context.Context, buffer []byte) (int, error) {
	var _arg0 *C.GPollableOutputStream // out
	var _arg3 *C.GCancellable          // out
	var _arg1 *C.void                  // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C.g_pollable_output_stream_write_nonblocking(_arg0, unsafe.Pointer(_arg1), _arg2, _arg3, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

// writeNonblocking attempts to write up to count bytes from buffer to stream,
// as with g_output_stream_write(). If stream is not currently writable, this
// will immediately return G_IO_ERROR_WOULD_BLOCK, and you can use
// g_pollable_output_stream_create_source() to create a #GSource that will be
// triggered when stream is writable.
//
// Note that since this method never blocks, you cannot actually use cancellable
// to cancel it. However, it will return an error if cancellable has already
// been cancelled when you call, which may happen if you call this method after
// a source triggers due to having been cancelled.
//
// Also note that if G_IO_ERROR_WOULD_BLOCK is returned some underlying
// transports like D/TLS require that you re-send the same buffer and count in
// the next write call.
//
// The function takes the following parameters:
//
//    - buffer (optional) to write data from.
//
// The function returns the following values:
//
//    - gssize: number of bytes written, or -1 on error (including
//      G_IO_ERROR_WOULD_BLOCK).
//
func (stream *PollableOutputStream) writeNonblocking(buffer []byte) (int, error) {
	gclass := (*C.GPollableOutputStreamInterface)(coreglib.PeekParentClass(stream))
	fnarg := gclass.write_nonblocking

	var _arg0 *C.GPollableOutputStream // out
	var _arg1 *C.void                  // out
	var _arg2 C.gsize
	var _cret C.gssize  // in
	var _cerr *C.GError // in

	_arg0 = (*C.GPollableOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg2 = (C.gsize)(len(buffer))
	if len(buffer) > 0 {
		_arg1 = (*C.void)(unsafe.Pointer(&buffer[0]))
	}

	_cret = C._gotk4_gio2_PollableOutputStream_virtual_write_nonblocking(unsafe.Pointer(fnarg), _arg0, unsafe.Pointer(_arg1), _arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gssize, _goerr
}

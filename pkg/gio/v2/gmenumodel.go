// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gboolean _gotk4_gio2_MenuAttributeIterClass_get_next(void*, void**, void**);
// extern gboolean _gotk4_gio2_MenuLinkIterClass_get_next(void*, void**, void**);
// extern gboolean _gotk4_gio2_MenuModelClass_is_mutable(void*);
// extern gint _gotk4_gio2_MenuModelClass_get_n_items(void*);
// extern void _gotk4_gio2_MenuModelClass_get_item_attributes(void*, gint, void**);
// extern void _gotk4_gio2_MenuModelClass_get_item_links(void*, gint, void**);
// extern void _gotk4_gio2_MenuModel_ConnectItemsChanged(gpointer, gint, gint, gint, guintptr);
// extern void* _gotk4_gio2_MenuModelClass_get_item_attribute_value(void*, gint, void*, void*);
// extern void* _gotk4_gio2_MenuModelClass_get_item_link(void*, gint, void*);
// extern void* _gotk4_gio2_MenuModelClass_iterate_item_attributes(void*, gint);
// extern void* _gotk4_gio2_MenuModelClass_iterate_item_links(void*, gint);
import "C"

// GTypeMenuAttributeIter returns the GType for the type MenuAttributeIter.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeMenuAttributeIter() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "MenuAttributeIter").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalMenuAttributeIter)
	return gtype
}

// GTypeMenuLinkIter returns the GType for the type MenuLinkIter.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeMenuLinkIter() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "MenuLinkIter").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalMenuLinkIter)
	return gtype
}

// GTypeMenuModel returns the GType for the type MenuModel.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeMenuModel() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "MenuModel").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalMenuModel)
	return gtype
}

// MENU_ATTRIBUTE_ACTION: menu item attribute which holds the action name of the
// item. Action names are namespaced with an identifier for the action group in
// which the action resides. For example, "win." for window-specific actions and
// "app." for application-wide actions.
//
// See also g_menu_model_get_item_attribute() and g_menu_item_set_attribute().
const MENU_ATTRIBUTE_ACTION = "action"

// MENU_ATTRIBUTE_ACTION_NAMESPACE: menu item attribute that holds the namespace
// for all action names in menus that are linked from this item.
const MENU_ATTRIBUTE_ACTION_NAMESPACE = "action-namespace"

// MENU_ATTRIBUTE_ICON: menu item attribute which holds the icon of the item.
//
// The icon is stored in the format returned by g_icon_serialize().
//
// This attribute is intended only to represent 'noun' icons such as favicons
// for a webpage, or application icons. It should not be used for 'verbs' (ie:
// stock icons).
const MENU_ATTRIBUTE_ICON = "icon"

// MENU_ATTRIBUTE_LABEL: menu item attribute which holds the label of the item.
const MENU_ATTRIBUTE_LABEL = "label"

// MENU_ATTRIBUTE_TARGET: menu item attribute which holds the target with which
// the item's action will be activated.
//
// See also g_menu_item_set_action_and_target().
const MENU_ATTRIBUTE_TARGET = "target"

// MENU_LINK_SECTION: name of the link that associates a menu item with a
// section. The linked menu will usually be shown in place of the menu item,
// using the item's label as a header.
//
// See also g_menu_item_set_link().
const MENU_LINK_SECTION = "section"

// MENU_LINK_SUBMENU: name of the link that associates a menu item with a
// submenu.
//
// See also g_menu_item_set_link().
const MENU_LINK_SUBMENU = "submenu"

// MenuAttributeIterOverrider contains methods that are overridable.
type MenuAttributeIterOverrider interface {
	// Next: this function combines g_menu_attribute_iter_next() with
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) attribute. If
	// that fails, then FALSE is returned and there are no other effects.
	//
	// If successful, name and value are set to the name and value of the
	// attribute that has just been advanced to. At this point,
	// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value()
	// will return the same values again.
	//
	// The value returned in name remains valid for as long as the iterator
	// remains at the current position. The value returned in value must be
	// unreffed using g_variant_unref() when it is no longer in use.
	//
	// The function returns the following values:
	//
	//    - outName (optional): type of the attribute.
	//    - value (optional): attribute value.
	//    - ok: TRUE on success, or FALSE if there is no additional attribute.
	//
	Next() (string, *glib.Variant, bool)
}

// MenuAttributeIter is an opaque structure type. You must access it using the
// functions below.
type MenuAttributeIter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*MenuAttributeIter)(nil)
)

// MenuAttributeIterer describes types inherited from class MenuAttributeIter.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MenuAttributeIterer interface {
	coreglib.Objector
	baseMenuAttributeIter() *MenuAttributeIter
}

var _ MenuAttributeIterer = (*MenuAttributeIter)(nil)

func classInitMenuAttributeIterer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gio", "MenuAttributeIterClass")

	if _, ok := goval.(interface {
		Next() (string, *glib.Variant, bool)
	}); ok {
		o := pclass.StructFieldOffset("get_next")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuAttributeIterClass_get_next)
	}
}

//export _gotk4_gio2_MenuAttributeIterClass_get_next
func _gotk4_gio2_MenuAttributeIterClass_get_next(arg0 *C.void, arg1 **C.void, arg2 **C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Next() (string, *glib.Variant, bool)
	})

	outName, value, ok := iface.Next()

	if outName != "" {
		*arg1 = (*C.void)(unsafe.Pointer(C.CString(outName)))
		defer C.free(unsafe.Pointer(arg1))
	}
	if value != nil {
		if value != nil {
			*arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(value)))
		}
	}
	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapMenuAttributeIter(obj *coreglib.Object) *MenuAttributeIter {
	return &MenuAttributeIter{
		Object: obj,
	}
}

func marshalMenuAttributeIter(p uintptr) (interface{}, error) {
	return wrapMenuAttributeIter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (iter *MenuAttributeIter) baseMenuAttributeIter() *MenuAttributeIter {
	return iter
}

// BaseMenuAttributeIter returns the underlying base object.
func BaseMenuAttributeIter(obj MenuAttributeIterer) *MenuAttributeIter {
	return obj.baseMenuAttributeIter()
}

// Name gets the name of the attribute at the current iterator position, as a
// string.
//
// The iterator is not advanced.
//
// The function returns the following values:
//
//    - utf8: name of the attribute.
//
func (iter *MenuAttributeIter) Name() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_info := girepository.MustFind("Gio", "MenuAttributeIter")
	_gret := _info.InvokeClassMethod("get_name", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GetNext: this function combines g_menu_attribute_iter_next() with
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) attribute. If
// that fails, then FALSE is returned and there are no other effects.
//
// If successful, name and value are set to the name and value of the attribute
// that has just been advanced to. At this point,
// g_menu_attribute_iter_get_name() and g_menu_attribute_iter_get_value() will
// return the same values again.
//
// The value returned in name remains valid for as long as the iterator remains
// at the current position. The value returned in value must be unreffed using
// g_variant_unref() when it is no longer in use.
//
// The function returns the following values:
//
//    - outName (optional): type of the attribute.
//    - value (optional): attribute value.
//    - ok: TRUE on success, or FALSE if there is no additional attribute.
//
func (iter *MenuAttributeIter) GetNext() (string, *glib.Variant, bool) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_info := girepository.MustFind("Gio", "MenuAttributeIter")
	_gret := _info.InvokeClassMethod("get_next", _args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _outName string      // out
	var _value *glib.Variant // out
	var _ok bool             // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_outName = C.GoString((*C.gchar)(unsafe.Pointer(_outs[0])))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_value = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_outs[1])))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_value)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _outName, _value, _ok
}

// Value gets the value of the attribute at the current iterator position.
//
// The iterator is not advanced.
//
// The function returns the following values:
//
//    - variant: value of the current attribute.
//
func (iter *MenuAttributeIter) Value() *glib.Variant {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_info := girepository.MustFind("Gio", "MenuAttributeIter")
	_gret := _info.InvokeClassMethod("get_value", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _variant
}

// Next attempts to advance the iterator to the next (possibly first) attribute.
//
// TRUE is returned on success, or FALSE if there are no more attributes.
//
// You must call this function when you first acquire the iterator to advance it
// to the first attribute (and determine if the first attribute exists at all).
//
// The function returns the following values:
//
//    - ok: TRUE on success, or FALSE when there are no more attributes.
//
func (iter *MenuAttributeIter) Next() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_info := girepository.MustFind("Gio", "MenuAttributeIter")
	_gret := _info.InvokeClassMethod("next", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// MenuLinkIterOverrider contains methods that are overridable.
type MenuLinkIterOverrider interface {
	// Next: this function combines g_menu_link_iter_next() with
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
	//
	// First the iterator is advanced to the next (possibly first) link. If that
	// fails, then FALSE is returned and there are no other effects.
	//
	// If successful, out_link and value are set to the name and Model of the
	// link that has just been advanced to. At this point,
	// g_menu_link_iter_get_name() and g_menu_link_iter_get_value() will return
	// the same values again.
	//
	// The value returned in out_link remains valid for as long as the iterator
	// remains at the current position. The value returned in value must be
	// unreffed using g_object_unref() when it is no longer in use.
	//
	// The function returns the following values:
	//
	//    - outLink (optional): name of the link.
	//    - value (optional): linked Model.
	//    - ok: TRUE on success, or FALSE if there is no additional link.
	//
	Next() (string, MenuModeller, bool)
}

// MenuLinkIter is an opaque structure type. You must access it using the
// functions below.
type MenuLinkIter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*MenuLinkIter)(nil)
)

// MenuLinkIterer describes types inherited from class MenuLinkIter.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MenuLinkIterer interface {
	coreglib.Objector
	baseMenuLinkIter() *MenuLinkIter
}

var _ MenuLinkIterer = (*MenuLinkIter)(nil)

func classInitMenuLinkIterer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gio", "MenuLinkIterClass")

	if _, ok := goval.(interface {
		Next() (string, MenuModeller, bool)
	}); ok {
		o := pclass.StructFieldOffset("get_next")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuLinkIterClass_get_next)
	}
}

//export _gotk4_gio2_MenuLinkIterClass_get_next
func _gotk4_gio2_MenuLinkIterClass_get_next(arg0 *C.void, arg1 **C.void, arg2 **C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Next() (string, MenuModeller, bool)
	})

	outLink, value, ok := iface.Next()

	if outLink != "" {
		*arg1 = (*C.void)(unsafe.Pointer(C.CString(outLink)))
		defer C.free(unsafe.Pointer(arg1))
	}
	if value != nil {
		if value != nil {
			*arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(value).Native()))
			C.g_object_ref(C.gpointer(coreglib.InternObject(value).Native()))
		}
	}
	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapMenuLinkIter(obj *coreglib.Object) *MenuLinkIter {
	return &MenuLinkIter{
		Object: obj,
	}
}

func marshalMenuLinkIter(p uintptr) (interface{}, error) {
	return wrapMenuLinkIter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (iter *MenuLinkIter) baseMenuLinkIter() *MenuLinkIter {
	return iter
}

// BaseMenuLinkIter returns the underlying base object.
func BaseMenuLinkIter(obj MenuLinkIterer) *MenuLinkIter {
	return obj.baseMenuLinkIter()
}

// Name gets the name of the link at the current iterator position.
//
// The iterator is not advanced.
//
// The function returns the following values:
//
//    - utf8: type of the link.
//
func (iter *MenuLinkIter) Name() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_info := girepository.MustFind("Gio", "MenuLinkIter")
	_gret := _info.InvokeClassMethod("get_name", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GetNext: this function combines g_menu_link_iter_next() with
// g_menu_link_iter_get_name() and g_menu_link_iter_get_value().
//
// First the iterator is advanced to the next (possibly first) link. If that
// fails, then FALSE is returned and there are no other effects.
//
// If successful, out_link and value are set to the name and Model of the link
// that has just been advanced to. At this point, g_menu_link_iter_get_name()
// and g_menu_link_iter_get_value() will return the same values again.
//
// The value returned in out_link remains valid for as long as the iterator
// remains at the current position. The value returned in value must be unreffed
// using g_object_unref() when it is no longer in use.
//
// The function returns the following values:
//
//    - outLink (optional): name of the link.
//    - value (optional): linked Model.
//    - ok: TRUE on success, or FALSE if there is no additional link.
//
func (iter *MenuLinkIter) GetNext() (string, MenuModeller, bool) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_info := girepository.MustFind("Gio", "MenuLinkIter")
	_gret := _info.InvokeClassMethod("get_next", _args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _outLink string     // out
	var _value MenuModeller // out
	var _ok bool            // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_outLink = C.GoString((*C.gchar)(unsafe.Pointer(_outs[0])))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		{
			objptr := unsafe.Pointer(_outs[1])

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MenuModeller)
				return ok
			})
			rv, ok := casted.(MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_value = rv
		}
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _outLink, _value, _ok
}

// Value gets the linked Model at the current iterator position.
//
// The iterator is not advanced.
//
// The function returns the following values:
//
//    - menuModel that is linked to.
//
func (iter *MenuLinkIter) Value() MenuModeller {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_info := girepository.MustFind("Gio", "MenuLinkIter")
	_gret := _info.InvokeClassMethod("get_value", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _menuModel MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(MenuModeller)
			return ok
		})
		rv, ok := casted.(MenuModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// Next attempts to advance the iterator to the next (possibly first) link.
//
// TRUE is returned on success, or FALSE if there are no more links.
//
// You must call this function when you first acquire the iterator to advance it
// to the first link (and determine if the first link exists at all).
//
// The function returns the following values:
//
//    - ok: TRUE on success, or FALSE when there are no more links.
//
func (iter *MenuLinkIter) Next() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(iter).Native()))

	_info := girepository.MustFind("Gio", "MenuLinkIter")
	_gret := _info.InvokeClassMethod("next", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// MenuModelOverrider contains methods that are overridable.
type MenuModelOverrider interface {
	// ItemAttributeValue queries the item at position item_index in model for
	// the attribute specified by attribute.
	//
	// If expected_type is non-NULL then it specifies the expected type of the
	// attribute. If it is NULL then any type will be accepted.
	//
	// If the attribute exists and matches expected_type (or if the expected
	// type is unspecified) then the value is returned.
	//
	// If the attribute does not exist, or does not match the expected type then
	// NULL is returned.
	//
	// The function takes the following parameters:
	//
	//    - itemIndex: index of the item.
	//    - attribute to query.
	//    - expectedType (optional): expected type of the attribute, or NULL.
	//
	// The function returns the following values:
	//
	//    - variant (optional): value of the attribute.
	//
	ItemAttributeValue(itemIndex int32, attribute string, expectedType *glib.VariantType) *glib.Variant
	// ItemAttributes gets all the attributes associated with the item in the
	// menu model.
	//
	// The function takes the following parameters:
	//
	//    - itemIndex to query.
	//
	// The function returns the following values:
	//
	//    - attributes attributes on the item.
	//
	ItemAttributes(itemIndex int32) map[string]*glib.Variant
	// ItemLink queries the item at position item_index in model for the link
	// specified by link.
	//
	// If the link exists, the linked Model is returned. If the link does not
	// exist, NULL is returned.
	//
	// The function takes the following parameters:
	//
	//    - itemIndex: index of the item.
	//    - link to query.
	//
	// The function returns the following values:
	//
	//    - menuModel (optional): linked Model, or NULL.
	//
	ItemLink(itemIndex int32, link string) MenuModeller
	// ItemLinks gets all the links associated with the item in the menu model.
	//
	// The function takes the following parameters:
	//
	//    - itemIndex to query.
	//
	// The function returns the following values:
	//
	//    - links links from the item.
	//
	ItemLinks(itemIndex int32) map[string]MenuModeller
	// NItems: query the number of items in model.
	//
	// The function returns the following values:
	//
	//    - gint: number of items.
	//
	NItems() int32
	// IsMutable queries if model is mutable.
	//
	// An immutable Model will never emit the Model::items-changed signal.
	// Consumers of the model may make optimisations accordingly.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the model is mutable (ie: "items-changed" may be
	//      emitted).
	//
	IsMutable() bool
	// IterateItemAttributes creates a AttributeIter to iterate over the
	// attributes of the item at position item_index in model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	//
	// The function takes the following parameters:
	//
	//    - itemIndex: index of the item.
	//
	// The function returns the following values:
	//
	//    - menuAttributeIter: new AttributeIter.
	//
	IterateItemAttributes(itemIndex int32) MenuAttributeIterer
	// IterateItemLinks creates a LinkIter to iterate over the links of the item
	// at position item_index in model.
	//
	// You must free the iterator with g_object_unref() when you are done.
	//
	// The function takes the following parameters:
	//
	//    - itemIndex: index of the item.
	//
	// The function returns the following values:
	//
	//    - menuLinkIter: new LinkIter.
	//
	IterateItemLinks(itemIndex int32) MenuLinkIterer
}

// MenuModel represents the contents of a menu -- an ordered list of menu items.
// The items are associated with actions, which can be activated through them.
// Items can be grouped in sections, and may have submenus associated with them.
// Both items and sections usually have some representation data, such as labels
// or icons. The type of the associated action (ie whether it is stateful, and
// what kind of state it has) can influence the representation of the item.
//
// The conceptual model of menus in Model is hierarchical: sections and submenus
// are again represented by Models. Menus themselves do not define their own
// roles. Rather, the role of a particular Model is defined by the item that
// references it (or, in the case of the 'root' menu, is defined by the context
// in which it is used).
//
// As an example, consider the visible portions of this menu:
//
//
// An example menu
//
// ! (menu-example.png)
//
// There are 8 "menus" visible in the screenshot: one menubar, two submenus and
// 5 sections:
//
// - the toplevel menubar (containing 4 items)
//
// - the View submenu (containing 3 sections)
//
// - the first section of the View submenu (containing 2 items)
//
// - the second section of the View submenu (containing 1 item)
//
// - the final section of the View submenu (containing 1 item)
//
// - the Highlight Mode submenu (containing 2 sections)
//
// - the Sources section (containing 2 items)
//
// - the Markup section (containing 2 items)
//
// The [example][menu-model] illustrates the conceptual connection between these
// 8 menus. Each large block in the figure represents a menu and the smaller
// blocks within the large block represent items in that menu. Some items
// contain references to other menus.
//
//
// A menu example
//
// ! (menu-model.png)
//
// Notice that the separators visible in the [example][menu-example] appear
// nowhere in the [menu model][menu-model]. This is because separators are not
// explicitly represented in the menu model. Instead, a separator is inserted
// between any two non-empty sections of a menu. Section items can have labels
// just like any other item. In that case, a display system may show a section
// header instead of a separator.
//
// The motivation for this abstract model of application controls is that modern
// user interfaces tend to make these controls available outside the
// application. Examples include global menus, jumplists, dash boards, etc. To
// support such uses, it is necessary to 'export' information about actions and
// their representation in menus, which is exactly what the [GActionGroup
// exporter][gio-GActionGroup-exporter] and the [GMenuModel
// exporter][gio-GMenuModel-exporter] do for Group and Model. The client-side
// counterparts to make use of the exported information are BusActionGroup and
// BusMenuModel.
//
// The API of Model is very generic, with iterators for the attributes and links
// of an item, see g_menu_model_iterate_item_attributes() and
// g_menu_model_iterate_item_links(). The 'standard' attributes and link types
// have predefined names: G_MENU_ATTRIBUTE_LABEL, G_MENU_ATTRIBUTE_ACTION,
// G_MENU_ATTRIBUTE_TARGET, G_MENU_LINK_SECTION and G_MENU_LINK_SUBMENU.
//
// Items in a Model represent active controls if they refer to an action that
// can get activated when the user interacts with the menu item. The reference
// to the action is encoded by the string id in the G_MENU_ATTRIBUTE_ACTION
// attribute. An action id uniquely identifies an action in an action group.
// Which action group(s) provide actions depends on the context in which the
// menu model is used. E.g. when the model is exported as the application menu
// of a Application, actions can be application-wide or window-specific (and
// thus come from two different action groups). By convention, the
// application-wide actions have names that start with "app.", while the names
// of window-specific actions start with "win.".
//
// While a wide variety of stateful actions is possible, the following is the
// minimum that is expected to be supported by all users of exported menu
// information:
//
// - an action with no parameter type and no state
//
// - an action with no parameter type and boolean state
//
// - an action with string parameter type and string state
//
//
// Stateless
//
// A stateless action typically corresponds to an ordinary menu item.
//
// Selecting such a menu item will activate the action (with no parameter).
//
//
// Boolean State
//
// An action with a boolean state will most typically be used with a "toggle" or
// "switch" menu item. The state can be set directly, but activating the action
// (with no parameter) results in the state being toggled.
//
// Selecting a toggle menu item will activate the action. The menu item should
// be rendered as "checked" when the state is true.
//
//
// String Parameter and State
//
// Actions with string parameters and state will most typically be used to
// represent an enumerated choice over the items available for a group of radio
// menu items. Activating the action with a string parameter is equivalent to
// setting that parameter as the state.
//
// Radio menu items, in addition to being associated with the action, will have
// a target value. Selecting that menu item will result in activation of the
// action with the target value as the parameter. The menu item should be
// rendered as "selected" when the state of the action is equal to the target
// value of the menu item.
type MenuModel struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*MenuModel)(nil)
)

// MenuModeller describes types inherited from class MenuModel.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MenuModeller interface {
	coreglib.Objector
	baseMenuModel() *MenuModel
}

var _ MenuModeller = (*MenuModel)(nil)

func classInitMenuModeller(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gio", "MenuModelClass")

	if _, ok := goval.(interface {
		ItemAttributeValue(itemIndex int32, attribute string, expectedType *glib.VariantType) *glib.Variant
	}); ok {
		o := pclass.StructFieldOffset("get_item_attribute_value")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuModelClass_get_item_attribute_value)
	}

	if _, ok := goval.(interface {
		ItemAttributes(itemIndex int32) map[string]*glib.Variant
	}); ok {
		o := pclass.StructFieldOffset("get_item_attributes")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuModelClass_get_item_attributes)
	}

	if _, ok := goval.(interface {
		ItemLink(itemIndex int32, link string) MenuModeller
	}); ok {
		o := pclass.StructFieldOffset("get_item_link")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuModelClass_get_item_link)
	}

	if _, ok := goval.(interface {
		ItemLinks(itemIndex int32) map[string]MenuModeller
	}); ok {
		o := pclass.StructFieldOffset("get_item_links")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuModelClass_get_item_links)
	}

	if _, ok := goval.(interface{ NItems() int32 }); ok {
		o := pclass.StructFieldOffset("get_n_items")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuModelClass_get_n_items)
	}

	if _, ok := goval.(interface{ IsMutable() bool }); ok {
		o := pclass.StructFieldOffset("is_mutable")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuModelClass_is_mutable)
	}

	if _, ok := goval.(interface {
		IterateItemAttributes(itemIndex int32) MenuAttributeIterer
	}); ok {
		o := pclass.StructFieldOffset("iterate_item_attributes")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuModelClass_iterate_item_attributes)
	}

	if _, ok := goval.(interface {
		IterateItemLinks(itemIndex int32) MenuLinkIterer
	}); ok {
		o := pclass.StructFieldOffset("iterate_item_links")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gio2_MenuModelClass_iterate_item_links)
	}
}

//export _gotk4_gio2_MenuModelClass_get_item_attribute_value
func _gotk4_gio2_MenuModelClass_get_item_attribute_value(arg0 *C.void, arg1 C.gint, arg2 *C.void, arg3 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ItemAttributeValue(itemIndex int32, attribute string, expectedType *glib.VariantType) *glib.Variant
	})

	var _itemIndex int32                // out
	var _attribute string               // out
	var _expectedType *glib.VariantType // out

	_itemIndex = int32(arg1)
	_attribute = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	if arg3 != nil {
		_expectedType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	}

	variant := iface.ItemAttributeValue(_itemIndex, _attribute, _expectedType)

	if variant != nil {
		cret = (*C.void)(gextras.StructNative(unsafe.Pointer(variant)))
	}

	return cret
}

//export _gotk4_gio2_MenuModelClass_get_item_attributes
func _gotk4_gio2_MenuModelClass_get_item_attributes(arg0 *C.void, arg1 C.gint, arg2 **C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ItemAttributes(itemIndex int32) map[string]*glib.Variant
	})

	var _itemIndex int32 // out

	_itemIndex = int32(arg1)

	attributes := iface.ItemAttributes(_itemIndex)

	*arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range attributes {
		var kdst *C.void // out
		var vdst *C.void // out
		kdst = (*C.void)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.void)(gextras.StructNative(unsafe.Pointer(vsrc)))
		C.g_hash_table_insert(*arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
}

//export _gotk4_gio2_MenuModelClass_get_item_link
func _gotk4_gio2_MenuModelClass_get_item_link(arg0 *C.void, arg1 C.gint, arg2 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ItemLink(itemIndex int32, link string) MenuModeller
	})

	var _itemIndex int32 // out
	var _link string     // out

	_itemIndex = int32(arg1)
	_link = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	menuModel := iface.ItemLink(_itemIndex, _link)

	if menuModel != nil {
		cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(menuModel).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(menuModel).Native()))
	}

	return cret
}

//export _gotk4_gio2_MenuModelClass_get_item_links
func _gotk4_gio2_MenuModelClass_get_item_links(arg0 *C.void, arg1 C.gint, arg2 **C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ItemLinks(itemIndex int32) map[string]MenuModeller
	})

	var _itemIndex int32 // out

	_itemIndex = int32(arg1)

	links := iface.ItemLinks(_itemIndex)

	*arg2 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range links {
		var kdst *C.void // out
		var vdst *C.void // out
		kdst = (*C.void)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.void)(unsafe.Pointer(coreglib.InternObject(vsrc).Native()))
		C.g_hash_table_insert(*arg2, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
}

//export _gotk4_gio2_MenuModelClass_get_n_items
func _gotk4_gio2_MenuModelClass_get_n_items(arg0 *C.void) (cret C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ NItems() int32 })

	gint := iface.NItems()

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gio2_MenuModelClass_is_mutable
func _gotk4_gio2_MenuModelClass_is_mutable(arg0 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ IsMutable() bool })

	ok := iface.IsMutable()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gio2_MenuModelClass_iterate_item_attributes
func _gotk4_gio2_MenuModelClass_iterate_item_attributes(arg0 *C.void, arg1 C.gint) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		IterateItemAttributes(itemIndex int32) MenuAttributeIterer
	})

	var _itemIndex int32 // out

	_itemIndex = int32(arg1)

	menuAttributeIter := iface.IterateItemAttributes(_itemIndex)

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(menuAttributeIter).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(menuAttributeIter).Native()))

	return cret
}

//export _gotk4_gio2_MenuModelClass_iterate_item_links
func _gotk4_gio2_MenuModelClass_iterate_item_links(arg0 *C.void, arg1 C.gint) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		IterateItemLinks(itemIndex int32) MenuLinkIterer
	})

	var _itemIndex int32 // out

	_itemIndex = int32(arg1)

	menuLinkIter := iface.IterateItemLinks(_itemIndex)

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(menuLinkIter).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(menuLinkIter).Native()))

	return cret
}

func wrapMenuModel(obj *coreglib.Object) *MenuModel {
	return &MenuModel{
		Object: obj,
	}
}

func marshalMenuModel(p uintptr) (interface{}, error) {
	return wrapMenuModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (model *MenuModel) baseMenuModel() *MenuModel {
	return model
}

// BaseMenuModel returns the underlying base object.
func BaseMenuModel(obj MenuModeller) *MenuModel {
	return obj.baseMenuModel()
}

//export _gotk4_gio2_MenuModel_ConnectItemsChanged
func _gotk4_gio2_MenuModel_ConnectItemsChanged(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.gint, arg4 C.guintptr) {
	var f func(position, removed, added int32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(position, removed, added int32))
	}

	var _position int32 // out
	var _removed int32  // out
	var _added int32    // out

	_position = int32(arg1)
	_removed = int32(arg2)
	_added = int32(arg3)

	f(_position, _removed, _added)
}

// ConnectItemsChanged is emitted when a change has occurred to the menu.
//
// The only changes that can occur to a menu is that items are removed or added.
// Items may not change (except by being removed and added back in the same
// location). This signal is capable of describing both of those changes (at the
// same time).
//
// The signal means that starting at the index position, removed items were
// removed and added items were added in their place. If removed is zero then
// only items were added. If added is zero then only items were removed.
//
// As an example, if the menu contains items a, b, c, d (in that order) and the
// signal (2, 1, 3) occurs then the new composition of the menu will be a, b, _,
// _, _, d (with each _ representing some new item).
//
// Signal handlers may query the model (particularly the added items) and expect
// to see the results of the modification that is being reported. The signal is
// emitted after the modification.
func (model *MenuModel) ConnectItemsChanged(f func(position, removed, added int32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(model, "items-changed", false, unsafe.Pointer(C._gotk4_gio2_MenuModel_ConnectItemsChanged), f)
}

// ItemAttributeValue queries the item at position item_index in model for the
// attribute specified by attribute.
//
// If expected_type is non-NULL then it specifies the expected type of the
// attribute. If it is NULL then any type will be accepted.
//
// If the attribute exists and matches expected_type (or if the expected type is
// unspecified) then the value is returned.
//
// If the attribute does not exist, or does not match the expected type then
// NULL is returned.
//
// The function takes the following parameters:
//
//    - itemIndex: index of the item.
//    - attribute to query.
//    - expectedType (optional): expected type of the attribute, or NULL.
//
// The function returns the following values:
//
//    - variant (optional): value of the attribute.
//
func (model *MenuModel) ItemAttributeValue(itemIndex int32, attribute string, expectedType *glib.VariantType) *glib.Variant {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(itemIndex)
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_args[2]))
	if expectedType != nil {
		*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(expectedType)))
	}

	_info := girepository.MustFind("Gio", "MenuModel")
	_gret := _info.InvokeClassMethod("get_item_attribute_value", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(expectedType)

	var _variant *glib.Variant // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _variant
}

// ItemLink queries the item at position item_index in model for the link
// specified by link.
//
// If the link exists, the linked Model is returned. If the link does not exist,
// NULL is returned.
//
// The function takes the following parameters:
//
//    - itemIndex: index of the item.
//    - link to query.
//
// The function returns the following values:
//
//    - menuModel (optional): linked Model, or NULL.
//
func (model *MenuModel) ItemLink(itemIndex int32, link string) MenuModeller {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(itemIndex)
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(C.CString(link)))
	defer C.free(unsafe.Pointer(_args[2]))

	_info := girepository.MustFind("Gio", "MenuModel")
	_gret := _info.InvokeClassMethod("get_item_link", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)
	runtime.KeepAlive(link)

	var _menuModel MenuModeller // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MenuModeller)
				return ok
			})
			rv, ok := casted.(MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// NItems: query the number of items in model.
//
// The function returns the following values:
//
//    - gint: number of items.
//
func (model *MenuModel) NItems() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_info := girepository.MustFind("Gio", "MenuModel")
	_gret := _info.InvokeClassMethod("get_n_items", _args[:], nil)
	_cret := *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// IsMutable queries if model is mutable.
//
// An immutable Model will never emit the Model::items-changed signal. Consumers
// of the model may make optimisations accordingly.
//
// The function returns the following values:
//
//    - ok: TRUE if the model is mutable (ie: "items-changed" may be emitted).
//
func (model *MenuModel) IsMutable() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_info := girepository.MustFind("Gio", "MenuModel")
	_gret := _info.InvokeClassMethod("is_mutable", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ItemsChanged requests emission of the Model::items-changed signal on model.
//
// This function should never be called except by Model subclasses. Any other
// calls to this function will very likely lead to a violation of the interface
// of the model.
//
// The implementation should update its internal representation of the menu
// before emitting the signal. The implementation should further expect to
// receive queries about the new state of the menu (and particularly added menu
// items) while signal handlers are running.
//
// The implementation must dispatch this call directly from a mainloop entry and
// not in response to calls -- particularly those from the Model API. Said
// another way: the menu must not change while user code is running without
// returning to the mainloop.
//
// The function takes the following parameters:
//
//    - position of the change.
//    - removed: number of items removed.
//    - added: number of items added.
//
func (model *MenuModel) ItemsChanged(position, removed, added int32) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(position)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(removed)
	*(*C.gint)(unsafe.Pointer(&_args[3])) = C.gint(added)

	_info := girepository.MustFind("Gio", "MenuModel")
	_info.InvokeClassMethod("items_changed", _args[:], nil)

	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(removed)
	runtime.KeepAlive(added)
}

// IterateItemAttributes creates a AttributeIter to iterate over the attributes
// of the item at position item_index in model.
//
// You must free the iterator with g_object_unref() when you are done.
//
// The function takes the following parameters:
//
//    - itemIndex: index of the item.
//
// The function returns the following values:
//
//    - menuAttributeIter: new AttributeIter.
//
func (model *MenuModel) IterateItemAttributes(itemIndex int32) MenuAttributeIterer {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(itemIndex)

	_info := girepository.MustFind("Gio", "MenuModel")
	_gret := _info.InvokeClassMethod("iterate_item_attributes", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _menuAttributeIter MenuAttributeIterer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuAttributeIterer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(MenuAttributeIterer)
			return ok
		})
		rv, ok := casted.(MenuAttributeIterer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuAttributeIterer")
		}
		_menuAttributeIter = rv
	}

	return _menuAttributeIter
}

// IterateItemLinks creates a LinkIter to iterate over the links of the item at
// position item_index in model.
//
// You must free the iterator with g_object_unref() when you are done.
//
// The function takes the following parameters:
//
//    - itemIndex: index of the item.
//
// The function returns the following values:
//
//    - menuLinkIter: new LinkIter.
//
func (model *MenuModel) IterateItemLinks(itemIndex int32) MenuLinkIterer {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(itemIndex)

	_info := girepository.MustFind("Gio", "MenuModel")
	_gret := _info.InvokeClassMethod("iterate_item_links", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(itemIndex)

	var _menuLinkIter MenuLinkIterer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuLinkIterer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(MenuLinkIterer)
			return ok
		})
		rv, ok := casted.(MenuLinkIterer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuLinkIterer")
		}
		_menuLinkIter = rv
	}

	return _menuLinkIter
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeSocket returns the GType for the type Socket.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeSocket() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gio", "Socket").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalSocket)
	return gtype
}

// SocketOverrider contains methods that are overridable.
type SocketOverrider interface {
}

// Socket is a low-level networking primitive. It is a more or less direct
// mapping of the BSD socket API in a portable GObject based API. It supports
// both the UNIX socket implementations and winsock2 on Windows.
//
// #GSocket is the platform independent base upon which the higher level network
// primitives are based. Applications are not typically meant to use it
// directly, but rather through classes like Client, Service and Connection.
// However there may be cases where direct use of #GSocket is useful.
//
// #GSocket implements the #GInitable interface, so if it is manually
// constructed by e.g. g_object_new() you must call g_initable_init() and check
// the results before using the object. This is done automatically in
// g_socket_new() and g_socket_new_from_fd(), so these functions can return
// NULL.
//
// Sockets operate in two general modes, blocking or non-blocking. When in
// blocking mode all operations (which donâ€™t take an explicit blocking
// parameter) block until the requested operation is finished or there is an
// error. In non-blocking mode all calls that would block return immediately
// with a G_IO_ERROR_WOULD_BLOCK error. To know when a call would successfully
// run you can call g_socket_condition_check(), or g_socket_condition_wait().
// You can also use g_socket_create_source() and attach it to a Context to get
// callbacks when I/O is possible. Note that all sockets are always set to non
// blocking mode in the system, and blocking mode is emulated in GSocket.
//
// When working in non-blocking mode applications should always be able to
// handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other function
// said that I/O was possible. This can easily happen in case of a race
// condition in the application, but it can also happen for other reasons. For
// instance, on Windows a socket is always seen as writable until a write
// returns G_IO_ERROR_WOULD_BLOCK.
//
// #GSockets can be either connection oriented or datagram based. For connection
// oriented types you must first establish a connection by either connecting to
// an address or accepting a connection from another address. For connectionless
// socket types the target/source address is specified or received in each I/O
// operation.
//
// All socket file descriptors are set to be close-on-exec.
//
// Note that creating a #GSocket causes the signal SIGPIPE to be ignored for the
// remainder of the program. If you are writing a command-line utility that uses
// #GSocket, you may need to take into account the fact that your program will
// not automatically be killed if it tries to write to stdout after it has been
// closed.
//
// Like most other APIs in GLib, #GSocket is not inherently thread safe. To use
// a #GSocket concurrently from multiple threads, you must implement your own
// locking.
type Socket struct {
	_ [0]func() // equal guard
	*coreglib.Object

	DatagramBased
	Initable
}

var (
	_ coreglib.Objector = (*Socket)(nil)
)

func classInitSocketter(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapSocket(obj *coreglib.Object) *Socket {
	return &Socket{
		Object: obj,
		DatagramBased: DatagramBased{
			Object: obj,
		},
		Initable: Initable{
			Object: obj,
		},
	}
}

func marshalSocket(p uintptr) (interface{}, error) {
	return wrapSocket(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSocketFromFd creates a new #GSocket from a native file descriptor or
// winsock SOCKET handle.
//
// This reads all the settings from the file descriptor so that all properties
// should work. Note that the file descriptor will be set to non-blocking mode,
// independent on the blocking mode of the #GSocket.
//
// On success, the returned #GSocket takes ownership of fd. On failure, the
// caller must close fd themselves.
//
// Since GLib 2.46, it is no longer a fatal error to call this on a non-socket
// descriptor. Instead, a GError will be set with code G_IO_ERROR_FAILED.
//
// The function takes the following parameters:
//
//    - fd: native socket file descriptor.
//
// The function returns the following values:
//
//    - socket or NULL on error. Free the returned object with g_object_unref().
//
func NewSocketFromFd(fd int32) (*Socket, error) {
	var _args [1]girepository.Argument

	*(*C.gint)(unsafe.Pointer(&_args[0])) = C.gint(fd)

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("new_Socket_from_fd", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(fd)

	var _socket *Socket // out
	var _goerr error    // out

	_socket = wrapSocket(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _socket, _goerr
}

// Accept incoming connections on a connection-based socket. This removes the
// first outstanding connection request from the listening socket and creates a
// #GSocket object for it.
//
// The socket must be bound to a local address with g_socket_bind() and must be
// listening for incoming connections (g_socket_listen()).
//
// If there are no outstanding connections then the operation will block or
// return G_IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be notified
// of an incoming connection, wait for the G_IO_IN condition.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//
// The function returns the following values:
//
//    - ret: new #GSocket, or NULL on error. Free the returned object with
//      g_object_unref().
//
func (socket *Socket) Accept(ctx context.Context) (*Socket, error) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[1] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("accept", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)

	var _ret *Socket // out
	var _goerr error // out

	_ret = wrapSocket(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _ret, _goerr
}

// Bind: when a socket is created it is attached to an address family, but it
// doesn't have an address in this family. g_socket_bind() assigns the address
// (sometimes called name) of the socket.
//
// It is generally required to bind to a local address before you can receive
// connections. (See g_socket_listen() and g_socket_accept() ). In certain
// situations, you may also want to bind a socket that will be used to initiate
// connections, though this is not normally required.
//
// If socket is a TCP socket, then allow_reuse controls the setting of the
// SO_REUSEADDR socket option; normally it should be TRUE for server sockets
// (sockets that you will eventually call g_socket_accept() on), and FALSE for
// client sockets. (Failing to set this flag on a server socket may cause
// g_socket_bind() to return G_IO_ERROR_ADDRESS_IN_USE if the server program is
// stopped and then immediately restarted.)
//
// If socket is a UDP socket, then allow_reuse determines whether or not other
// UDP sockets can be bound to the same address at the same time. In particular,
// you can have several UDP sockets bound to the same address, and they will all
// receive all of the multicast and broadcast packets sent to that address. (The
// behavior of unicast UDP packets to an address with multiple listeners is not
// defined.).
//
// The function takes the following parameters:
//
//    - address specifying the local address.
//    - allowReuse: whether to allow reusing this address.
//
func (socket *Socket) Bind(address SocketAddresser, allowReuse bool) error {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	if allowReuse {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("bind", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(address)
	runtime.KeepAlive(allowReuse)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// CheckConnectResult checks and resets the pending connect error for the
// socket. This is used to check for errors when g_socket_connect() is used in
// non-blocking mode.
func (socket *Socket) CheckConnectResult() error {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("check_connect_result", _args[:], nil)

	runtime.KeepAlive(socket)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// Close closes the socket, shutting down any active connection.
//
// Closing a socket does not wait for all outstanding I/O operations to finish,
// so the caller should not rely on them to be guaranteed to complete even if
// the close returns with no error.
//
// Once the socket is closed, all other operations will return
// G_IO_ERROR_CLOSED. Closing a socket multiple times will not return an error.
//
// Sockets will be automatically closed when the last reference is dropped, but
// you might want to call this function to make sure resources are released as
// early as possible.
//
// Beware that due to the way that TCP works, it is possible for recently-sent
// data to be lost if either you close a socket while the G_IO_IN condition is
// set, or else if the remote connection tries to send something to you after
// you close the socket but before it has finished reading all of the data you
// sent. There is no easy generic way to avoid this problem; the easiest fix is
// to design the network protocol such that the client will never send data "out
// of turn". Another solution is for the server to half-close the connection by
// calling g_socket_shutdown() with only the shutdown_write flag set, and then
// wait for the client to notice this and close its side of the connection,
// after which the server can safely call g_socket_close(). (This is what
// Connection does if you call g_tcp_connection_set_graceful_disconnect(). But
// of course, this only works if the client will close its connection after the
// server does.).
func (socket *Socket) Close() error {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("close", _args[:], nil)

	runtime.KeepAlive(socket)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// ConditionCheck checks on the readiness of socket to perform operations. The
// operations specified in condition are checked for and masked against the
// currently-satisfied conditions on socket. The result is returned.
//
// Note that on Windows, it is possible for an operation to return
// G_IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check() has
// claimed that the socket is ready for writing. Rather than calling
// g_socket_condition_check() and then writing to the socket if it succeeds, it
// is generally better to simply try writing to the socket right away, and try
// again later if the initial attempt returns G_IO_ERROR_WOULD_BLOCK.
//
// It is meaningless to specify G_IO_ERR or G_IO_HUP in condition; these
// conditions will always be set in the output if they are true.
//
// This call never blocks.
//
// The function takes the following parameters:
//
//    - condition mask to check.
//
// The function returns the following values:
//
//    - ioCondition: GIOCondition mask of the current state.
//
func (socket *Socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(*C.GIOCondition)(unsafe.Pointer(&_args[1])) = C.GIOCondition(condition)

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("condition_check", _args[:], nil)
	_cret := *(*C.GIOCondition)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)
	runtime.KeepAlive(condition)

	var _ioCondition glib.IOCondition // out

	_ioCondition = glib.IOCondition(*(*C.GIOCondition)(unsafe.Pointer(&_cret)))

	return _ioCondition
}

// ConditionTimedWait waits for up to timeout_us microseconds for condition to
// become true on socket. If the condition is met, TRUE is returned.
//
// If cancellable is cancelled before the condition is met, or if timeout_us (or
// the socket's #GSocket:timeout) is reached before the condition is met, then
// FALSE is returned and error, if non-NULL, is set to the appropriate value
// (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// If you don't want a timeout, use g_socket_condition_wait(). (Alternatively,
// you can pass -1 for timeout_us.)
//
// Note that although timeout_us is in microseconds for consistency with other
// GLib APIs, this function actually only has millisecond resolution, and the
// behavior is undefined if timeout_us is not an exact number of milliseconds.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - condition mask to wait for.
//    - timeoutUs: maximum time (in microseconds) to wait, or -1.
//
func (socket *Socket) ConditionTimedWait(ctx context.Context, condition glib.IOCondition, timeoutUs int64) error {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[3] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.GIOCondition)(unsafe.Pointer(&_args[1])) = C.GIOCondition(condition)
	*(*C.gint64)(unsafe.Pointer(&_args[2])) = C.gint64(timeoutUs)

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("condition_timed_wait", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)
	runtime.KeepAlive(timeoutUs)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// ConditionWait waits for condition to become true on socket. When the
// condition is met, TRUE is returned.
//
// If cancellable is cancelled before the condition is met, or if the socket has
// a timeout set and it is reached before the condition is met, then FALSE is
// returned and error, if non-NULL, is set to the appropriate value
// (G_IO_ERROR_CANCELLED or G_IO_ERROR_TIMED_OUT).
//
// See also g_socket_condition_timed_wait().
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - condition mask to wait for.
//
func (socket *Socket) ConditionWait(ctx context.Context, condition glib.IOCondition) error {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.GIOCondition)(unsafe.Pointer(&_args[1])) = C.GIOCondition(condition)

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("condition_wait", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(condition)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// ConnectSocket: connect the socket to the specified remote address.
//
// For connection oriented socket this generally means we attempt to make a
// connection to the address. For a connection-less socket it sets the default
// address for g_socket_send() and discards all incoming datagrams from other
// sources.
//
// Generally connection oriented sockets can only connect once, but
// connection-less sockets can connect multiple times to change the default
// address.
//
// If the connect call needs to do network I/O it will block, unless
// non-blocking I/O is enabled. Then G_IO_ERROR_PENDING is returned and the user
// can be notified of the connection finishing by waiting for the G_IO_OUT
// condition. The result of the connection must then be checked with
// g_socket_check_connect_result().
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - address specifying the remote address.
//
func (socket *Socket) ConnectSocket(ctx context.Context, address SocketAddresser) error {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[2] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("connect", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// AvailableBytes: get the amount of data pending in the OS input buffer,
// without blocking.
//
// If socket is a UDP or SCTP socket, this will return the size of just the next
// packet, even if additional packets are buffered after that one.
//
// Note that on Windows, this function is rather inefficient in the UDP case,
// and so if you know any plausible upper bound on the size of the incoming
// packet, it is better to just do a g_socket_receive() with a buffer of that
// size, rather than calling g_socket_get_available_bytes() first and then doing
// a receive of exactly the right size.
//
// The function returns the following values:
//
//    - gssize: number of bytes that can be read from the socket without blocking
//      or truncating, or -1 on error.
//
func (socket *Socket) AvailableBytes() int {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_available_bytes", _args[:], nil)
	_cret := *(*C.gssize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _gssize int // out

	_gssize = int(*(*C.gssize)(unsafe.Pointer(&_cret)))

	return _gssize
}

// Blocking gets the blocking mode of the socket. For details on blocking I/O,
// see g_socket_set_blocking().
//
// The function returns the following values:
//
//    - ok: TRUE if blocking I/O is used, FALSE otherwise.
//
func (socket *Socket) Blocking() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_blocking", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Broadcast gets the broadcast setting on socket; if TRUE, it is possible to
// send packets to broadcast addresses.
//
// The function returns the following values:
//
//    - ok: broadcast setting on socket.
//
func (socket *Socket) Broadcast() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_broadcast", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Credentials returns the credentials of the foreign process connected to this
// socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX sockets).
//
// If this operation isn't supported on the OS, the method fails with the
// G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading the
// SO_PEERCRED option on the underlying socket.
//
// This method can be expected to be available on the following platforms:
//
// - Linux since GLib 2.26
//
// - OpenBSD since GLib 2.30
//
// - Solaris, Illumos and OpenSolaris since GLib 2.40
//
// - NetBSD since GLib 2.42
//
// - macOS, tvOS, iOS since GLib 2.66
//
// Other ways to obtain credentials from a foreign peer includes the
// CredentialsMessage type and g_unix_connection_send_credentials() /
// g_unix_connection_receive_credentials() functions.
//
// The function returns the following values:
//
//    - credentials: NULL if error is set, otherwise a #GCredentials object that
//      must be freed with g_object_unref().
//
func (socket *Socket) Credentials() (*Credentials, error) {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_credentials", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _credentials *Credentials // out
	var _goerr error              // out

	_credentials = wrapCredentials(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _credentials, _goerr
}

// Fd returns the underlying OS socket object. On unix this is a socket file
// descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be
// useful for doing platform specific or otherwise unusual operations on the
// socket.
//
// The function returns the following values:
//
//    - gint: file descriptor of the socket.
//
func (socket *Socket) Fd() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_fd", _args[:], nil)
	_cret := *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// Keepalive gets the keepalive mode of the socket. For details on this, see
// g_socket_set_keepalive().
//
// The function returns the following values:
//
//    - ok: TRUE if keepalive is active, FALSE otherwise.
//
func (socket *Socket) Keepalive() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_keepalive", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ListenBacklog gets the listen backlog setting of the socket. For details on
// this, see g_socket_set_listen_backlog().
//
// The function returns the following values:
//
//    - gint: maximum number of pending connections.
//
func (socket *Socket) ListenBacklog() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_listen_backlog", _args[:], nil)
	_cret := *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// LocalAddress: try to get the local address of a bound socket. This is only
// useful if the socket has been bound to a local address, either explicitly or
// implicitly when connecting.
//
// The function returns the following values:
//
//    - socketAddress or NULL on error. Free the returned object with
//      g_object_unref().
//
func (socket *Socket) LocalAddress() (SocketAddresser, error) {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_local_address", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gio.SocketAddresser is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddresser)
			return ok
		})
		rv, ok := casted.(SocketAddresser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
		}
		_socketAddress = rv
	}
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _socketAddress, _goerr
}

// MulticastLoopback gets the multicast loopback setting on socket; if TRUE (the
// default), outgoing multicast packets will be looped back to multicast
// listeners on the same host.
//
// The function returns the following values:
//
//    - ok: multicast loopback setting on socket.
//
func (socket *Socket) MulticastLoopback() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_multicast_loopback", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// MulticastTTL gets the multicast time-to-live setting on socket; see
// g_socket_set_multicast_ttl() for more details.
//
// The function returns the following values:
//
//    - guint: multicast time-to-live setting on socket.
//
func (socket *Socket) MulticastTTL() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_multicast_ttl", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Option gets the value of an integer-valued option on socket, as with
// getsockopt(). (If you need to fetch a non-integer-valued option, you will
// need to call getsockopt() directly.)
//
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system headers
// that will define most of the standard/portable socket options. For unusual
// socket protocols or platform-dependent options, you may need to include
// additional headers.
//
// Note that even for socket options that are a single byte in size, value is
// still a pointer to a #gint variable, not a #guchar; g_socket_get_option()
// will handle the conversion internally.
//
// The function takes the following parameters:
//
//    - level: "API level" of the option (eg, SOL_SOCKET).
//    - optname: "name" of the option (eg, SO_BROADCAST).
//
// The function returns the following values:
//
//    - value: return location for the option value.
//
func (socket *Socket) Option(level, optname int32) (int32, error) {
	var _args [3]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(level)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(optname)

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("get_option", _args[:], _outs[:])

	runtime.KeepAlive(socket)
	runtime.KeepAlive(level)
	runtime.KeepAlive(optname)

	var _value int32 // out
	var _goerr error // out

	_value = int32(*(*C.gint)(unsafe.Pointer(&_outs[0])))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _value, _goerr
}

// RemoteAddress: try to get the remote address of a connected socket. This is
// only useful for connection oriented sockets that have been connected.
//
// The function returns the following values:
//
//    - socketAddress or NULL on error. Free the returned object with
//      g_object_unref().
//
func (socket *Socket) RemoteAddress() (SocketAddresser, error) {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_remote_address", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _socketAddress SocketAddresser // out
	var _goerr error                   // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gio.SocketAddresser is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(SocketAddresser)
			return ok
		})
		rv, ok := casted.(SocketAddresser)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
		}
		_socketAddress = rv
	}
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _socketAddress, _goerr
}

// Timeout gets the timeout setting of the socket. For details on this, see
// g_socket_set_timeout().
//
// The function returns the following values:
//
//    - guint: timeout in seconds.
//
func (socket *Socket) Timeout() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_timeout", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// TTL gets the unicast time-to-live setting on socket; see g_socket_set_ttl()
// for more details.
//
// The function returns the following values:
//
//    - guint: time-to-live setting on socket.
//
func (socket *Socket) TTL() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("get_ttl", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// IsClosed checks whether a socket is closed.
//
// The function returns the following values:
//
//    - ok: TRUE if socket is closed, FALSE otherwise.
//
func (socket *Socket) IsClosed() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("is_closed", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsConnected: check whether the socket is connected. This is only useful for
// connection-oriented sockets.
//
// If using g_socket_shutdown(), this function will return TRUE until the socket
// has been shut down for reading and writing. If you do a non-blocking connect,
// this function will not return TRUE until after you call
// g_socket_check_connect_result().
//
// The function returns the following values:
//
//    - ok: TRUE if socket is connected, FALSE otherwise.
//
func (socket *Socket) IsConnected() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("is_connected", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// JoinMulticastGroup registers socket to receive multicast messages sent to
// group. socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have been
// bound to an appropriate interface and port with g_socket_bind().
//
// If iface is NULL, the system will automatically pick an interface to bind to
// based on group.
//
// If source_specific is TRUE, source-specific multicast as defined in RFC 4604
// is used. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// To bind to a given source-specific multicast address, use
// g_socket_join_multicast_group_ssm() instead.
//
// The function takes the following parameters:
//
//    - group specifying the group address to join.
//    - sourceSpecific: TRUE if source-specific multicast should be used.
//    - iface (optional): name of the interface to use, or NULL.
//
func (socket *Socket) JoinMulticastGroup(group *InetAddress, sourceSpecific bool, iface string) error {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}
	if iface != "" {
		*(**C.gchar)(unsafe.Pointer(&_args[3])) = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[3]))))
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("join_multicast_group", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// JoinMulticastGroupSSM registers socket to receive multicast messages sent to
// group. socket must be a G_SOCKET_TYPE_DATAGRAM socket, and must have been
// bound to an appropriate interface and port with g_socket_bind().
//
// If iface is NULL, the system will automatically pick an interface to bind to
// based on group.
//
// If source_specific is not NULL, use source-specific multicast as defined in
// RFC 4604. Note that on older platforms this may fail with a
// G_IO_ERROR_NOT_SUPPORTED error.
//
// Note that this function can be called multiple times for the same group with
// different source_specific in order to receive multicast packets from more
// than one source.
//
// The function takes the following parameters:
//
//    - group specifying the group address to join.
//    - sourceSpecific (optional) specifying the source-specific multicast
//      address or NULL to ignore.
//    - iface (optional): name of the interface to use, or NULL.
//
func (socket *Socket) JoinMulticastGroupSSM(group, sourceSpecific *InetAddress, iface string) error {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific != nil {
		*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(sourceSpecific).Native()))
	}
	if iface != "" {
		*(**C.gchar)(unsafe.Pointer(&_args[3])) = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[3]))))
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("join_multicast_group_ssm", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// LeaveMulticastGroup removes socket from the multicast group defined by group,
// iface, and source_specific (which must all have the same values they had when
// you joined the group).
//
// socket remains bound to its address and port, and can still receive unicast
// messages after calling this.
//
// To unbind to a given source-specific multicast address, use
// g_socket_leave_multicast_group_ssm() instead.
//
// The function takes the following parameters:
//
//    - group specifying the group address to leave.
//    - sourceSpecific: TRUE if source-specific multicast was used.
//    - iface (optional): interface used.
//
func (socket *Socket) LeaveMulticastGroup(group *InetAddress, sourceSpecific bool, iface string) error {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}
	if iface != "" {
		*(**C.gchar)(unsafe.Pointer(&_args[3])) = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[3]))))
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("leave_multicast_group", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// LeaveMulticastGroupSSM removes socket from the multicast group defined by
// group, iface, and source_specific (which must all have the same values they
// had when you joined the group).
//
// socket remains bound to its address and port, and can still receive unicast
// messages after calling this.
//
// The function takes the following parameters:
//
//    - group specifying the group address to leave.
//    - sourceSpecific (optional) specifying the source-specific multicast
//      address or NULL to ignore.
//    - iface (optional): name of the interface to use, or NULL.
//
func (socket *Socket) LeaveMulticastGroupSSM(group, sourceSpecific *InetAddress, iface string) error {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if sourceSpecific != nil {
		*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(sourceSpecific).Native()))
	}
	if iface != "" {
		*(**C.gchar)(unsafe.Pointer(&_args[3])) = (*C.gchar)(unsafe.Pointer(C.CString(iface)))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[3]))))
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("leave_multicast_group_ssm", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(group)
	runtime.KeepAlive(sourceSpecific)
	runtime.KeepAlive(iface)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// Listen marks the socket as a server socket, i.e. a socket that is used to
// accept incoming requests using g_socket_accept().
//
// Before calling this the socket must be bound to a local address using
// g_socket_bind().
//
// To set the maximum amount of outstanding clients, use
// g_socket_set_listen_backlog().
func (socket *Socket) Listen() error {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("listen", _args[:], nil)

	runtime.KeepAlive(socket)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// Receive data (up to size bytes) from a socket. This is mainly used by
// connection-oriented sockets; it is identical to g_socket_receive_from() with
// address set to NULL.
//
// For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,
// g_socket_receive() will always read either 0 or 1 complete messages from the
// socket. If the received message is too large to fit in buffer, then the data
// beyond size bytes will be discarded, without any explicit indication that
// this has occurred.
//
// For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any number of
// bytes, up to size. If more than size bytes have been received, the additional
// data will be returned in future calls to g_socket_receive().
//
// If the socket is in blocking mode the call will block until there is some
// data to receive, the connection is closed, or there is an error. If there is
// no data available and the socket is in non-blocking mode, a
// G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data is
// available, wait for the G_IO_IN condition.
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - buffer: a buffer to read data into (which should be at least size bytes
//      long).
//
// The function returns the following values:
//
//    - gssize: number of bytes read, or 0 if the connection was closed by the
//      peer, or -1 on error.
//
func (socket *Socket) Receive(ctx context.Context, buffer []byte) (int, error) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[3] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.gsize)(unsafe.Pointer(&_args[2])) = (C.gsize)(len(buffer))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(C.CBytes(buffer))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("receive", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(*(*C.gssize)(unsafe.Pointer(&_cret)))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _gssize, _goerr
}

// ReceiveFrom: receive data (up to size bytes) from a socket.
//
// If address is non-NULL then address will be set equal to the source address
// of the received packet. address is owned by the caller.
//
// See g_socket_receive() for additional information.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - buffer: a buffer to read data into (which should be at least size bytes
//      long).
//
// The function returns the following values:
//
//    - address (optional): pointer to a Address pointer, or NULL.
//    - gssize: number of bytes read, or 0 if the connection was closed by the
//      peer, or -1 on error.
//
func (socket *Socket) ReceiveFrom(ctx context.Context, buffer []byte) (SocketAddresser, int, error) {
	var _args [4]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[3] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.gsize)(unsafe.Pointer(&_args[2])) = (C.gsize)(len(buffer))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(C.CBytes(buffer))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("receive_from", _args[:], _outs[:])
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _address SocketAddresser // out
	var _gssize int              // out
	var _goerr error             // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0])))

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(SocketAddresser)
				return ok
			})
			rv, ok := casted.(SocketAddresser)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.SocketAddresser")
			}
			_address = rv
		}
	}
	_gssize = int(*(*C.gssize)(unsafe.Pointer(&_cret)))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _address, _gssize, _goerr
}

// ReceiveWithBlocking: this behaves exactly the same as g_socket_receive(),
// except that the choice of blocking or non-blocking behavior is determined by
// the blocking argument rather than by socket's properties.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - buffer: a buffer to read data into (which should be at least size bytes
//      long).
//    - blocking: whether to do blocking or non-blocking I/O.
//
// The function returns the following values:
//
//    - gssize: number of bytes read, or 0 if the connection was closed by the
//      peer, or -1 on error.
//
func (socket *Socket) ReceiveWithBlocking(ctx context.Context, buffer []byte, blocking bool) (int, error) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[4] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.gsize)(unsafe.Pointer(&_args[2])) = (C.gsize)(len(buffer))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(C.CBytes(buffer))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))
	if blocking {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("receive_with_blocking", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(*(*C.gssize)(unsafe.Pointer(&_cret)))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _gssize, _goerr
}

// Send tries to send size bytes from buffer on the socket. This is mainly used
// by connection-oriented sockets; it is identical to g_socket_send_to() with
// address set to NULL.
//
// If the socket is in blocking mode the call will block until there is space
// for the data in the socket queue. If there is no space available and the
// socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error will be
// returned. To be notified when space is available, wait for the G_IO_OUT
// condition. Note though that you may still receive G_IO_ERROR_WOULD_BLOCK from
// g_socket_send() even if you were previously notified of a G_IO_OUT condition.
// (On Windows in particular, this is very common due to the way the underlying
// APIs work.)
//
// On error -1 is returned and error is set accordingly.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - buffer: buffer containing the data to send.
//
// The function returns the following values:
//
//    - gssize: number of bytes written (which may be less than size), or -1 on
//      error.
//
func (socket *Socket) Send(ctx context.Context, buffer string) (int, error) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[3] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.gsize)(unsafe.Pointer(&_args[2])) = (C.gsize)(len(buffer))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(C.calloc(C.size_t((len(buffer) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1])))), len(buffer)), buffer)
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("send", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(*(*C.gssize)(unsafe.Pointer(&_cret)))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _gssize, _goerr
}

// SendTo tries to send size bytes from buffer to address. If address is NULL
// then the message is sent to the default receiver (set by g_socket_connect()).
//
// See g_socket_send() for additional information.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - address (optional) or NULL.
//    - buffer: buffer containing the data to send.
//
// The function returns the following values:
//
//    - gssize: number of bytes written (which may be less than size), or -1 on
//      error.
//
func (socket *Socket) SendTo(ctx context.Context, address SocketAddresser, buffer string) (int, error) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[4] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if address != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	}
	*(*C.gsize)(unsafe.Pointer(&_args[3])) = (C.gsize)(len(buffer))
	*(**C.gchar)(unsafe.Pointer(&_args[2])) = (*C.gchar)(C.calloc(C.size_t((len(buffer) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[2])))), len(buffer)), buffer)
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[2]))))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("send_to", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(buffer)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(*(*C.gssize)(unsafe.Pointer(&_cret)))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _gssize, _goerr
}

// SendWithBlocking: this behaves exactly the same as g_socket_send(), except
// that the choice of blocking or non-blocking behavior is determined by the
// blocking argument rather than by socket's properties.
//
// The function takes the following parameters:
//
//    - ctx (optional): GCancellable or NULL.
//    - buffer: buffer containing the data to send.
//    - blocking: whether to do blocking or non-blocking I/O.
//
// The function returns the following values:
//
//    - gssize: number of bytes written (which may be less than size), or -1 on
//      error.
//
func (socket *Socket) SendWithBlocking(ctx context.Context, buffer string, blocking bool) (int, error) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_args[4] = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	*(*C.gsize)(unsafe.Pointer(&_args[2])) = (C.gsize)(len(buffer))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(C.calloc(C.size_t((len(buffer) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1])))), len(buffer)), buffer)
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))
	if blocking {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("send_with_blocking", _args[:], nil)
	_cret := *(**C.GError)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(blocking)

	var _gssize int  // out
	var _goerr error // out

	_gssize = int(*(*C.gssize)(unsafe.Pointer(&_cret)))
	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _gssize, _goerr
}

// SetBlocking sets the blocking mode of the socket. In blocking mode all
// operations (which donâ€™t take an explicit blocking parameter) block until they
// succeed or there is an error. In non-blocking mode all functions return
// results immediately or with a G_IO_ERROR_WOULD_BLOCK error.
//
// All sockets are created in blocking mode. However, note that the platform
// level socket is always non-blocking, and blocking mode is a GSocket level
// feature.
//
// The function takes the following parameters:
//
//    - blocking: whether to use blocking I/O or not.
//
func (socket *Socket) SetBlocking(blocking bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if blocking {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_blocking", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(blocking)
}

// SetBroadcast sets whether socket should allow sending to broadcast addresses.
// This is FALSE by default.
//
// The function takes the following parameters:
//
//    - broadcast: whether socket should allow sending to broadcast addresses.
//
func (socket *Socket) SetBroadcast(broadcast bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if broadcast {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_broadcast", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(broadcast)
}

// SetKeepalive sets or unsets the SO_KEEPALIVE flag on the underlying socket.
// When this flag is set on a socket, the system will attempt to verify that the
// remote socket endpoint is still present if a sufficiently long period of time
// passes with no data being exchanged. If the system is unable to verify the
// presence of the remote endpoint, it will automatically close the connection.
//
// This option is only functional on certain kinds of sockets. (Notably,
// G_SOCKET_PROTOCOL_TCP sockets.)
//
// The exact time between pings is system- and protocol-dependent, but will
// normally be at least two hours. Most commonly, you would set this flag on a
// server socket if you want to allow clients to remain idle for long periods of
// time, but also want to ensure that connections are eventually
// garbage-collected if clients crash or become unreachable.
//
// The function takes the following parameters:
//
//    - keepalive: value for the keepalive flag.
//
func (socket *Socket) SetKeepalive(keepalive bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if keepalive {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_keepalive", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(keepalive)
}

// SetListenBacklog sets the maximum number of outstanding connections allowed
// when listening on this socket. If more clients than this are connecting to
// the socket and the application is not handling them on time then the new
// connections will be refused.
//
// Note that this must be called before g_socket_listen() and has no effect if
// called after that.
//
// The function takes the following parameters:
//
//    - backlog: maximum number of pending connections.
//
func (socket *Socket) SetListenBacklog(backlog int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(backlog)

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_listen_backlog", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(backlog)
}

// SetMulticastLoopback sets whether outgoing multicast packets will be received
// by sockets listening on that multicast address on the same host. This is TRUE
// by default.
//
// The function takes the following parameters:
//
//    - loopback: whether socket should receive messages sent to its multicast
//      groups from the local host.
//
func (socket *Socket) SetMulticastLoopback(loopback bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if loopback {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_multicast_loopback", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(loopback)
}

// SetMulticastTTL sets the time-to-live for outgoing multicast datagrams on
// socket. By default, this is 1, meaning that multicast packets will not leave
// the local network.
//
// The function takes the following parameters:
//
//    - ttl: time-to-live value for all multicast datagrams on socket.
//
func (socket *Socket) SetMulticastTTL(ttl uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(ttl)

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_multicast_ttl", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// SetOption sets the value of an integer-valued option on socket, as with
// setsockopt(). (If you need to set a non-integer-valued option, you will need
// to call setsockopt() directly.)
//
// The [<gio/gnetworking.h>][gio-gnetworking.h] header pulls in system headers
// that will define most of the standard/portable socket options. For unusual
// socket protocols or platform-dependent options, you may need to include
// additional headers.
//
// The function takes the following parameters:
//
//    - level: "API level" of the option (eg, SOL_SOCKET).
//    - optname: "name" of the option (eg, SO_BROADCAST).
//    - value to set the option to.
//
func (socket *Socket) SetOption(level, optname, value int32) error {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(level)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(optname)
	*(*C.gint)(unsafe.Pointer(&_args[3])) = C.gint(value)

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_option", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(level)
	runtime.KeepAlive(optname)
	runtime.KeepAlive(value)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// SetTimeout sets the time in seconds after which I/O operations on socket will
// time out if they have not yet completed.
//
// On a blocking socket, this means that any blocking #GSocket operation will
// time out after timeout seconds of inactivity, returning G_IO_ERROR_TIMED_OUT.
//
// On a non-blocking socket, calls to g_socket_condition_wait() will also fail
// with G_IO_ERROR_TIMED_OUT after the given time. Sources created with
// g_socket_create_source() will trigger after timeout seconds of inactivity,
// with the requested condition set, at which point calling g_socket_receive(),
// g_socket_send(), g_socket_check_connect_result(), etc, will fail with
// G_IO_ERROR_TIMED_OUT.
//
// If timeout is 0 (the default), operations will never time out on their own.
//
// Note that if an I/O operation is interrupted by a signal, this may cause the
// timeout to be reset.
//
// The function takes the following parameters:
//
//    - timeout for socket, in seconds, or 0 for none.
//
func (socket *Socket) SetTimeout(timeout uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(timeout)

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_timeout", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(timeout)
}

// SetTTL sets the time-to-live for outgoing unicast packets on socket. By
// default the platform-specific default value is used.
//
// The function takes the following parameters:
//
//    - ttl: time-to-live value for all unicast packets on socket.
//
func (socket *Socket) SetTTL(ttl uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(ttl)

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("set_ttl", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(ttl)
}

// Shutdown: shut down part or all of a full-duplex connection.
//
// If shutdown_read is TRUE then the receiving side of the connection is shut
// down, and further reading is disallowed.
//
// If shutdown_write is TRUE then the sending side of the connection is shut
// down, and further writing is disallowed.
//
// It is allowed for both shutdown_read and shutdown_write to be TRUE.
//
// One example where it is useful to shut down only one side of a connection is
// graceful disconnect for TCP connections where you close the sending side,
// then wait for the other side to close the connection, thus ensuring that the
// other side saw all sent data.
//
// The function takes the following parameters:
//
//    - shutdownRead: whether to shut down the read side.
//    - shutdownWrite: whether to shut down the write side.
//
func (socket *Socket) Shutdown(shutdownRead, shutdownWrite bool) error {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))
	if shutdownRead {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}
	if shutdownWrite {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	_info := girepository.MustFind("Gio", "Socket")
	_info.InvokeClassMethod("shutdown", _args[:], nil)

	runtime.KeepAlive(socket)
	runtime.KeepAlive(shutdownRead)
	runtime.KeepAlive(shutdownWrite)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// SpeaksIPv4 checks if a socket is capable of speaking IPv4.
//
// IPv4 sockets are capable of speaking IPv4. On some operating systems and
// under some combinations of circumstances IPv6 sockets are also capable of
// speaking IPv4. See RFC 3493 section 3.7 for more information.
//
// No other types of sockets are currently considered as being capable of
// speaking IPv4.
//
// The function returns the following values:
//
//    - ok: TRUE if this socket can be used with IPv4.
//
func (socket *Socket) SpeaksIPv4() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(socket).Native()))

	_info := girepository.MustFind("Gio", "Socket")
	_gret := _info.InvokeClassMethod("speaks_ipv4", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(socket)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

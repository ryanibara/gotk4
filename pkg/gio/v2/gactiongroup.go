// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_ActionGroup_ConnectActionStateChanged(gpointer, gchar*, GVariant*, guintptr);
// extern void _gotk4_gio2_ActionGroup_ConnectActionRemoved(gpointer, gchar*, guintptr);
// extern void _gotk4_gio2_ActionGroup_ConnectActionEnabledChanged(gpointer, gchar*, gboolean, guintptr);
// extern void _gotk4_gio2_ActionGroup_ConnectActionAdded(gpointer, gchar*, guintptr);
import "C"

// GType values.
var (
	GTypeActionGroup = coreglib.Type(C.g_action_group_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeActionGroup, F: marshalActionGroup},
	})
}

// ActionGroup represents a group of actions. Actions can be used to expose
// functionality in a structured way, either from one part of a program to
// another, or to the outside world. Action groups are often used together with
// a Model that provides additional representation data for displaying the
// actions to the user, e.g. in a menu.
//
// The main way to interact with the actions in a GActionGroup is to activate
// them with g_action_group_activate_action(). Activating an action may require
// a #GVariant parameter. The required type of the parameter can be inquired
// with g_action_group_get_action_parameter_type(). Actions may be disabled, see
// g_action_group_get_action_enabled(). Activating a disabled action has no
// effect.
//
// Actions may optionally have a state in the form of a #GVariant. The current
// state of an action can be inquired with g_action_group_get_action_state().
// Activating a stateful action may change its state, but it is also possible to
// set the state by calling g_action_group_change_action_state().
//
// As typical example, consider a text editing application which has an option
// to change the current font to 'bold'. A good way to represent this would be a
// stateful action, with a boolean state. Activating the action would toggle the
// state.
//
// Each action in the group has a unique name (which is a string). All method
// calls, except g_action_group_list_actions() take the name of an action as an
// argument.
//
// The Group API is meant to be the 'public' API to the action group. The calls
// here are exactly the interaction that 'external forces' (eg: UI, incoming
// D-Bus messages, etc.) are supposed to have with actions. 'Internal' APIs (ie:
// ones meant only to be accessed by the action group implementation) are found
// on subclasses. This is why you will find - for example -
// g_action_group_get_action_enabled() but not an equivalent set() call.
//
// Signals are emitted on the action group in response to state changes on
// individual actions.
//
// Implementations of Group should provide implementations for the virtual
// functions g_action_group_list_actions() and g_action_group_query_action().
// The other virtual functions should not be implemented - their "wrappers" are
// actually implemented with calls to g_action_group_query_action().
//
// ActionGroup wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ActionGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ActionGroup)(nil)
)

// ActionGrouper describes ActionGroup's interface methods.
type ActionGrouper interface {
	coreglib.Objector

	// ActionAdded emits the Group::action-added signal on action_group.
	ActionAdded(actionName string)
	// ActionEnabledChanged emits the Group::action-enabled-changed signal on
	// action_group.
	ActionEnabledChanged(actionName string, enabled bool)
	// ActionRemoved emits the Group::action-removed signal on action_group.
	ActionRemoved(actionName string)
	// ActionStateChanged emits the Group::action-state-changed signal on
	// action_group.
	ActionStateChanged(actionName string, state *glib.Variant)
	// ActivateAction: activate the named action within action_group.
	ActivateAction(actionName string, parameter *glib.Variant)
	// ChangeActionState: request for the state of the named action within
	// action_group to be changed to value.
	ChangeActionState(actionName string, value *glib.Variant)
	// ActionEnabled checks if the named action within action_group is currently
	// enabled.
	ActionEnabled(actionName string) bool
	// ActionParameterType queries the type of the parameter that must be given
	// when activating the named action within action_group.
	ActionParameterType(actionName string) *glib.VariantType
	// ActionState queries the current state of the named action within
	// action_group.
	ActionState(actionName string) *glib.Variant
	// ActionStateHint requests a hint about the valid range of values for the
	// state of the named action within action_group.
	ActionStateHint(actionName string) *glib.Variant
	// ActionStateType queries the type of the state of the named action within
	// action_group.
	ActionStateType(actionName string) *glib.VariantType
	// HasAction checks if the named action exists within action_group.
	HasAction(actionName string) bool
	// ListActions lists the actions contained within action_group.
	ListActions() []string
	// QueryAction queries all aspects of the named action within an
	// action_group.
	QueryAction(actionName string) (enabled bool, parameterType, stateType *glib.VariantType, stateHint, state *glib.Variant, ok bool)

	// Action-added signals that a new action was just added to the group.
	ConnectActionAdded(func(actionName string)) coreglib.SignalHandle
	// Action-enabled-changed signals that the enabled status of the named
	// action has changed.
	ConnectActionEnabledChanged(func(actionName string, enabled bool)) coreglib.SignalHandle
	// Action-removed signals that an action is just about to be removed from
	// the group.
	ConnectActionRemoved(func(actionName string)) coreglib.SignalHandle
	// Action-state-changed signals that the state of the named action has
	// changed.
	ConnectActionStateChanged(func(actionName string, value *glib.Variant)) coreglib.SignalHandle
}

var _ ActionGrouper = (*ActionGroup)(nil)

func wrapActionGroup(obj *coreglib.Object) *ActionGroup {
	return &ActionGroup{
		Object: obj,
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	return wrapActionGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActionAdded signals that a new action was just added to the group.
// This signal is emitted after the action has been added and is now visible.
func (actionGroup *ActionGroup) ConnectActionAdded(f func(actionName string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "action-added", false, unsafe.Pointer(C._gotk4_gio2_ActionGroup_ConnectActionAdded), f)
}

// ConnectActionEnabledChanged signals that the enabled status of the named
// action has changed.
func (actionGroup *ActionGroup) ConnectActionEnabledChanged(f func(actionName string, enabled bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "action-enabled-changed", false, unsafe.Pointer(C._gotk4_gio2_ActionGroup_ConnectActionEnabledChanged), f)
}

// ConnectActionRemoved signals that an action is just about to be removed from
// the group. This signal is emitted before the action is removed, so the action
// is still visible and can be queried from the signal handler.
func (actionGroup *ActionGroup) ConnectActionRemoved(f func(actionName string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "action-removed", false, unsafe.Pointer(C._gotk4_gio2_ActionGroup_ConnectActionRemoved), f)
}

// ConnectActionStateChanged signals that the state of the named action has
// changed.
func (actionGroup *ActionGroup) ConnectActionStateChanged(f func(actionName string, value *glib.Variant)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "action-state-changed", false, unsafe.Pointer(C._gotk4_gio2_ActionGroup_ConnectActionStateChanged), f)
}

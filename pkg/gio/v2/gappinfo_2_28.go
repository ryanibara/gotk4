// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// AppInfoGetFallbackForType gets a list of fallback Infos for a given content
// type, i.e. those applications which claim to support the given content type
// by MIME type subclassing and not directly.
//
// The function takes the following parameters:
//
//    - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//    - list of Infos for given content_type or NULL on error.
//
func AppInfoGetFallbackForType(contentType string) []*AppInfo {
	var _arg1 *C.gchar // out
	var _cret *C.GList // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_fallback_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []*AppInfo // out

	_list = make([]*AppInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst *AppInfo // out
		dst = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// AppInfoGetRecommendedForType gets a list of recommended Infos for a given
// content type, i.e. those applications which claim to support the given
// content type exactly, and not by MIME type subclassing. Note that the first
// application of the list is the last used one, i.e. the last one for which
// g_app_info_set_as_last_used_for_type() has been called.
//
// The function takes the following parameters:
//
//    - contentType: content type to find a Info for.
//
// The function returns the following values:
//
//    - list of Infos for given content_type or NULL on error.
//
func AppInfoGetRecommendedForType(contentType string) []*AppInfo {
	var _arg1 *C.gchar // out
	var _cret *C.GList // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_app_info_get_recommended_for_type(_arg1)
	runtime.KeepAlive(contentType)

	var _list []*AppInfo // out

	_list = make([]*AppInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GAppInfo)(v)
		var dst *AppInfo // out
		dst = wrapAppInfo(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// DBusEscapeObjectPath: this is a language binding friendly version of
// g_dbus_escape_object_path_bytestring().
//
// The function takes the following parameters:
//
//    - s: string to escape.
//
// The function returns the following values:
//
//    - utf8: escaped version of s. Free with g_free().
//
func DBusEscapeObjectPath(s string) string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gio", "dbus_escape_object_path").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(s)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusEscapeObjectPathBytestring escapes bytes for use in a D-Bus object path
// component. bytes is an array of zero or more nonzero bytes in an unspecified
// encoding, followed by a single zero byte.
//
// The escaping method consists of replacing all non-alphanumeric characters
// (see g_ascii_isalnum()) with their hexadecimal value preceded by an
// underscore (_). For example: foo.bar.baz will become foo_2ebar_2ebaz.
//
// This method is appropriate to use when the input is nearly a valid object
// path component but is not when your input is far from being a valid object
// path component. Other escaping algorithms are also valid to use with D-Bus
// object paths.
//
// This can be reversed with g_dbus_unescape_object_path().
//
// The function takes the following parameters:
//
//    - bytes: string of bytes to escape.
//
// The function returns the following values:
//
//    - utf8: escaped version of bytes. Free with g_free().
//
func DBusEscapeObjectPathBytestring(bytes []byte) string {
	var _args [1]girepository.Argument

	{
		var zero byte
		bytes = append(bytes, zero)
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(&bytes[0]))
	}

	_gret := girepository.MustFind("Gio", "dbus_escape_object_path_bytestring").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(bytes)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusGenerateGUID: generate a D-Bus GUID that can be used with e.g.
// g_dbus_connection_new().
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
//
// The function returns the following values:
//
//    - utf8: valid D-Bus GUID. Free with g_free().
//
func DBusGenerateGUID() string {
	_gret := girepository.MustFind("Gio", "dbus_generate_guid").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DBusGValueToGVariant converts a #GValue to a #GVariant of the type indicated
// by the type parameter.
//
// The conversion is using the following rules:
//
// - TYPE_STRING: 's', 'o', 'g' or 'ay'
//
// - TYPE_STRV: 'as', 'ao' or 'aay'
//
// - TYPE_BOOLEAN: 'b'
//
// - TYPE_UCHAR: 'y'
//
// - TYPE_INT: 'i', 'n'
//
// - TYPE_UINT: 'u', 'q'
//
// - TYPE_INT64 'x'
//
// - TYPE_UINT64: 't'
//
// - TYPE_DOUBLE: 'd'
//
// - TYPE_VARIANT: Any Type
//
// This can fail if e.g. gvalue is of type TYPE_STRING and type is
// ['i'][G-VARIANT-TYPE-INT32:CAPS]. It will also fail for any #GType (including
// e.g. TYPE_OBJECT and TYPE_BOXED derived-types) not in the table above.
//
// Note that if gvalue is of type TYPE_VARIANT and its value is NULL, the empty
// #GVariant instance (never NULL) for type is returned (e.g. 0 for scalar
// types, the empty string for string types, '/' for object path types, the
// empty array for any array type and so on).
//
// See the g_dbus_gvariant_to_gvalue() function for how to convert a #GVariant
// to a #GValue.
//
// The function takes the following parameters:
//
//    - gvalue to convert to a #GVariant.
//    - typ: Type.
//
// The function returns the following values:
//
//    - variant (never floating) of Type type holding the data from gvalue or an
//      empty #GVariant in case of failure. Free with g_variant_unref().
//
func DBusGValueToGVariant(gvalue *coreglib.Value, typ *glib.VariantType) *glib.Variant {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(gvalue.Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(typ)))

	_gret := girepository.MustFind("Gio", "dbus_gvalue_to_gvariant").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(gvalue)
	runtime.KeepAlive(typ)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// DBusGVariantToGValue converts a #GVariant to a #GValue. If value is floating,
// it is consumed.
//
// The rules specified in the g_dbus_gvalue_to_gvariant() function are used -
// this function is essentially its reverse form. So, a #GVariant containing any
// basic or string array type will be converted to a #GValue containing a basic
// value or string array. Any other #GVariant (handle, variant, tuple, dict
// entry) will be converted to a #GValue containing that #GVariant.
//
// The conversion never fails - a valid #GValue is always returned in
// out_gvalue.
//
// The function takes the following parameters:
//
//    - value: #GVariant.
//
// The function returns the following values:
//
//    - outGvalue: return location pointing to a zero-filled (uninitialized)
//      #GValue.
//
func DBusGVariantToGValue(value *glib.Variant) coreglib.Value {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(value)))

	girepository.MustFind("Gio", "dbus_gvariant_to_gvalue").Invoke(_args[:], _outs[:])

	runtime.KeepAlive(value)

	var _outGvalue coreglib.Value // out

	_outGvalue = *coreglib.ValueFromNative(unsafe.Pointer(_outs[0]))

	return _outGvalue
}

// DBusIsGUID checks if string is a D-Bus GUID.
//
// See the D-Bus specification regarding what strings are valid D-Bus GUID (for
// example, D-Bus GUIDs are not RFC-4122 compliant).
//
// The function takes the following parameters:
//
//    - str: string to check.
//
// The function returns the following values:
//
//    - ok: TRUE if string is a guid, FALSE otherwise.
//
func DBusIsGUID(str string) bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gio", "dbus_is_guid").Invoke(_args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsInterfaceName checks if string is a valid D-Bus interface name.
//
// The function takes the following parameters:
//
//    - str: string to check.
//
// The function returns the following values:
//
//    - ok: TRUE if valid, FALSE otherwise.
//
func DBusIsInterfaceName(str string) bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gio", "dbus_is_interface_name").Invoke(_args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsMemberName checks if string is a valid D-Bus member (e.g. signal or
// method) name.
//
// The function takes the following parameters:
//
//    - str: string to check.
//
// The function returns the following values:
//
//    - ok: TRUE if valid, FALSE otherwise.
//
func DBusIsMemberName(str string) bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gio", "dbus_is_member_name").Invoke(_args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsName checks if string is a valid D-Bus bus name (either unique or
// well-known).
//
// The function takes the following parameters:
//
//    - str: string to check.
//
// The function returns the following values:
//
//    - ok: TRUE if valid, FALSE otherwise.
//
func DBusIsName(str string) bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gio", "dbus_is_name").Invoke(_args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DBusIsUniqueName checks if string is a valid D-Bus unique bus name.
//
// The function takes the following parameters:
//
//    - str: string to check.
//
// The function returns the following values:
//
//    - ok: TRUE if valid, FALSE otherwise.
//
func DBusIsUniqueName(str string) bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gio", "dbus_is_unique_name").Invoke(_args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DBusUnescapeObjectPath unescapes an string that was previously escaped with
// g_dbus_escape_object_path(). If the string is in a format that could not have
// been returned by g_dbus_escape_object_path(), this function returns NULL.
//
// Encoding alphanumeric characters which do not need to be encoded is not
// allowed (e.g _63 is not valid, the string should contain c instead).
//
// The function takes the following parameters:
//
//    - s: string to unescape.
//
// The function returns the following values:
//
//    - guint8s (optional): an unescaped version of s, or NULL if s is not a
//      string returned from g_dbus_escape_object_path(). Free with g_free().
//
func DBusUnescapeObjectPath(s string) []byte {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(s)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gio", "dbus_unescape_object_path").Invoke(_args[:], nil)
	_cret = *(**C.guint8)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(s)

	var _guint8s []byte // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			var i int
			var z C.guint8
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_guint8s = make([]byte, i)
			for i := range src {
				_guint8s[i] = byte(*(*C.guint8)(unsafe.Pointer(&src[i])))
			}
		}
	}

	return _guint8s
}

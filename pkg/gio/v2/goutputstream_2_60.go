// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// gboolean _gotk4_gio2_OutputStream_virtual_writev_finish(void* fnptr, GOutputStream* arg0, GAsyncResult* arg1, gsize* arg2, GError** arg3) {
//   return ((gboolean (*)(GOutputStream*, GAsyncResult*, gsize*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gio2_OutputStream_virtual_writev_fn(void* fnptr, GOutputStream* arg0, GOutputVector* arg1, gsize arg2, gsize* arg3, GCancellable* arg4, GError** arg5) {
//   return ((gboolean (*)(GOutputStream*, GOutputVector*, gsize, gsize*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gio2_OutputStream_virtual_writev_async(void* fnptr, GOutputStream* arg0, GOutputVector* arg1, gsize arg2, int arg3, GCancellable* arg4, GAsyncReadyCallback arg5, gpointer arg6) {
//   ((void (*)(GOutputStream*, GOutputVector*, gsize, int, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
import "C"

// Writev tries to write the bytes contained in the n_vectors vectors into the
// stream. Will block during the operation.
//
// If n_vectors is 0 or the sum of all bytes in vectors is 0, returns 0 and does
// nothing.
//
// On success, the number of bytes written to the stream is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// on a partial I/O error, or if there is not enough storage in the stream. All
// writes block until at least one byte is written or an error occurs; 0 is
// never returned (unless n_vectors is 0 or the sum of all bytes in vectors is
// 0).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// Some implementations of g_output_stream_writev() may have limitations on the
// aggregate buffer size, and will return G_IO_ERROR_INVALID_ARGUMENT if these
// are exceeded. For example, when writing to a local file on UNIX platforms,
// the aggregate buffer size must not exceed G_MAXSSIZE bytes.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellable object.
//    - vectors: buffer containing the Vectors to write.
//
// The function returns the following values:
//
//    - bytesWritten (optional): location to store the number of bytes that were
//      written to the stream.
//
func (stream *OutputStream) Writev(ctx context.Context, vectors []OutputVector) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}

	C.g_output_stream_writev(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// WritevAll tries to write the bytes contained in the n_vectors vectors into
// the stream. Will block during the operation.
//
// This function is similar to g_output_stream_writev(), except it tries to
// write as many bytes as requested, only stopping on an error.
//
// On a successful write of all n_vectors vectors, TRUE is returned, and
// bytes_written is set to the sum of all the sizes of vectors.
//
// If there is an error during the operation FALSE is returned and error is set
// to indicate the error status.
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns FALSE (and sets error) then bytes_written
// will be set to the number of bytes that were successfully written before the
// error was encountered. This functionality is only available from C. If you
// need it from another language then you must write your own loop around
// g_output_stream_write().
//
// The content of the individual elements of vectors might be changed by this
// function.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - vectors: buffer containing the Vectors to write.
//
// The function returns the following values:
//
//    - bytesWritten (optional): location to store the number of bytes that were
//      written to the stream.
//
func (stream *OutputStream) WritevAll(ctx context.Context, vectors []OutputVector) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}

	C.g_output_stream_writev_all(_arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// WritevAllAsync: request an asynchronous write of the bytes contained in the
// n_vectors vectors into the stream. When the operation is finished callback
// will be called. You can then call g_output_stream_writev_all_finish() to get
// the result of the operation.
//
// This is the asynchronous version of g_output_stream_writev_all().
//
// Call g_output_stream_writev_all_finish() to collect the result.
//
// Any outstanding I/O request with higher priority (lower numerical value) will
// be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// Note that no copy of vectors will be made, so it must stay valid until
// callback is called. The content of the individual elements of vectors might
// be changed by this function.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - vectors: buffer containing the Vectors to write.
//    - ioPriority: i/O priority of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (stream *OutputStream) WritevAllAsync(ctx context.Context, vectors []OutputVector, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_writev_all_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WritevAllFinish finishes an asynchronous stream write operation started with
// g_output_stream_writev_all_async().
//
// As a special exception to the normal conventions for functions that use
// #GError, if this function returns FALSE (and sets error) then bytes_written
// will be set to the number of bytes that were successfully written before the
// error was encountered. This functionality is only available from C. If you
// need it from another language then you must write your own loop around
// g_output_stream_writev_async().
//
// The function takes the following parameters:
//
//    - result: Result.
//
// The function returns the following values:
//
//    - bytesWritten (optional): location to store the number of bytes that were
//      written to the stream.
//
func (stream *OutputStream) WritevAllFinish(result AsyncResulter) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_output_stream_writev_all_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// WritevAsync: request an asynchronous write of the bytes contained in
// n_vectors vectors into the stream. When the operation is finished callback
// will be called. You can then call g_output_stream_writev_finish() to get the
// result of the operation.
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// On success, the number of bytes written will be passed to the callback. It is
// not an error if this is not the same as the requested size, as it can happen
// e.g. on a partial I/O error, but generally we try to write as many bytes as
// requested.
//
// You are guaranteed that this method will never fail with
// G_IO_ERROR_WOULD_BLOCK — if stream can't accept more data, the method will
// just wait until this changes.
//
// Any outstanding I/O request with higher priority (lower numerical value) will
// be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_writev().
//
// Note that no copy of vectors will be made, so it must stay valid until
// callback is called.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - vectors: buffer containing the Vectors to write.
//    - ioPriority: i/O priority of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (stream *OutputStream) WritevAsync(ctx context.Context, vectors []OutputVector, ioPriority int, callback AsyncReadyCallback) {
	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_output_stream_writev_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// WritevFinish finishes a stream writev operation.
//
// The function takes the following parameters:
//
//    - result: Result.
//
// The function returns the following values:
//
//    - bytesWritten (optional): location to store the number of bytes that were
//      written to the stream.
//
func (stream *OutputStream) WritevFinish(result AsyncResulter) (uint, error) {
	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.g_output_stream_writev_finish(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// writevAsync: request an asynchronous write of the bytes contained in
// n_vectors vectors into the stream. When the operation is finished callback
// will be called. You can then call g_output_stream_writev_finish() to get the
// result of the operation.
//
// During an async request no other sync and async calls are allowed, and will
// result in G_IO_ERROR_PENDING errors.
//
// On success, the number of bytes written will be passed to the callback. It is
// not an error if this is not the same as the requested size, as it can happen
// e.g. on a partial I/O error, but generally we try to write as many bytes as
// requested.
//
// You are guaranteed that this method will never fail with
// G_IO_ERROR_WOULD_BLOCK — if stream can't accept more data, the method will
// just wait until this changes.
//
// Any outstanding I/O request with higher priority (lower numerical value) will
// be executed before an outstanding request with lower priority. Default
// priority is G_PRIORITY_DEFAULT.
//
// The asynchronous methods have a default fallback that uses threads to
// implement asynchronicity, so they are optional for inheriting classes.
// However, if you override one you must override all.
//
// For the synchronous, blocking version of this function, see
// g_output_stream_writev().
//
// Note that no copy of vectors will be made, so it must stay valid until
// callback is called.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional #GCancellable object, NULL to ignore.
//    - vectors: buffer containing the Vectors to write.
//    - ioPriority: i/O priority of the request.
//    - callback (optional) to call when the request is satisfied.
//
func (stream *OutputStream) writevAsync(ctx context.Context, vectors []OutputVector, ioPriority int, callback AsyncReadyCallback) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.writev_async

	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.int                 // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}
	_arg3 = C.int(ioPriority)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_OutputStream_virtual_writev_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)
	runtime.KeepAlive(ioPriority)
	runtime.KeepAlive(callback)
}

// writevFinish finishes a stream writev operation.
//
// The function takes the following parameters:
//
//    - result: Result.
//
// The function returns the following values:
//
//    - bytesWritten (optional): location to store the number of bytes that were
//      written to the stream.
//
func (stream *OutputStream) writevFinish(result AsyncResulter) (uint, error) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.writev_finish

	var _arg0 *C.GOutputStream // out
	var _arg1 *C.GAsyncResult  // out
	var _arg2 C.gsize          // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C._gotk4_gio2_OutputStream_virtual_writev_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(result)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

// writevFn tries to write the bytes contained in the n_vectors vectors into the
// stream. Will block during the operation.
//
// If n_vectors is 0 or the sum of all bytes in vectors is 0, returns 0 and does
// nothing.
//
// On success, the number of bytes written to the stream is returned. It is not
// an error if this is not the same as the requested size, as it can happen e.g.
// on a partial I/O error, or if there is not enough storage in the stream. All
// writes block until at least one byte is written or an error occurs; 0 is
// never returned (unless n_vectors is 0 or the sum of all bytes in vectors is
// 0).
//
// If cancellable is not NULL, then the operation can be cancelled by triggering
// the cancellable object from another thread. If the operation was cancelled,
// the error G_IO_ERROR_CANCELLED will be returned. If an operation was
// partially finished when the operation was cancelled the partial result will
// be returned, without an error.
//
// Some implementations of g_output_stream_writev() may have limitations on the
// aggregate buffer size, and will return G_IO_ERROR_INVALID_ARGUMENT if these
// are exceeded. For example, when writing to a local file on UNIX platforms,
// the aggregate buffer size must not exceed G_MAXSSIZE bytes.
//
// The function takes the following parameters:
//
//    - ctx (optional): optional cancellable object.
//    - vectors: buffer containing the Vectors to write.
//
// The function returns the following values:
//
//    - bytesWritten (optional): location to store the number of bytes that were
//      written to the stream.
//
func (stream *OutputStream) writevFn(ctx context.Context, vectors []OutputVector) (uint, error) {
	gclass := (*C.GOutputStreamClass)(coreglib.PeekParentClass(stream))
	fnarg := gclass.writev_fn

	var _arg0 *C.GOutputStream // out
	var _arg4 *C.GCancellable  // out
	var _arg1 *C.GOutputVector // out
	var _arg2 C.gsize
	var _arg3 C.gsize   // in
	var _cerr *C.GError // in

	_arg0 = (*C.GOutputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg2 = (C.gsize)(len(vectors))
	_arg1 = (*C.GOutputVector)(C.calloc(C.size_t(len(vectors)), C.size_t(C.sizeof_GOutputVector)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GOutputVector)(_arg1), len(vectors))
		for i := range vectors {
			out[i] = *(*C.GOutputVector)(gextras.StructNative(unsafe.Pointer((&vectors[i]))))
		}
	}

	C._gotk4_gio2_OutputStream_virtual_writev_fn(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, _arg4, &_cerr)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(vectors)

	var _bytesWritten uint // out
	var _goerr error       // out

	_bytesWritten = uint(_arg3)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesWritten, _goerr
}

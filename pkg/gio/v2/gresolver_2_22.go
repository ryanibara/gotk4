// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// GList* _gotk4_gio2_Resolver_virtual_lookup_by_name(void* fnptr, GResolver* arg0, gchar* arg1, GCancellable* arg2, GError** arg3) {
//   return ((GList* (*)(GResolver*, gchar*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_by_name_finish(void* fnptr, GResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GList* (*)(GResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// GList* _gotk4_gio2_Resolver_virtual_lookup_service_finish(void* fnptr, GResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((GList* (*)(GResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// gchar* _gotk4_gio2_Resolver_virtual_lookup_by_address(void* fnptr, GResolver* arg0, GInetAddress* arg1, GCancellable* arg2, GError** arg3) {
//   return ((gchar* (*)(GResolver*, GInetAddress*, GCancellable*, GError**))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gchar* _gotk4_gio2_Resolver_virtual_lookup_by_address_finish(void* fnptr, GResolver* arg0, GAsyncResult* arg1, GError** arg2) {
//   return ((gchar* (*)(GResolver*, GAsyncResult*, GError**))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gio2_Resolver_virtual_lookup_by_address_async(void* fnptr, GResolver* arg0, GInetAddress* arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GResolver*, GInetAddress*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gio2_Resolver_virtual_lookup_by_name_async(void* fnptr, GResolver* arg0, gchar* arg1, GCancellable* arg2, GAsyncReadyCallback arg3, gpointer arg4) {
//   ((void (*)(GResolver*, gchar*, GCancellable*, GAsyncReadyCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
import "C"

// LookupByAddress: synchronously reverse-resolves address to determine its
// associated hostname.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - address to reverse-resolve.
//
// The function returns the following values:
//
//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//      error.
//
func (resolver *Resolver) LookupByAddress(ctx context.Context, address *InetAddress) (string, error) {
	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.GInetAddress // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C.g_resolver_lookup_by_address(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LookupByAddressAsync begins asynchronously reverse-resolving address to
// determine its associated hostname, and eventually calls callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - address to reverse-resolve.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupByAddressAsync(ctx context.Context, address *InetAddress, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GInetAddress       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_by_address_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(callback)
}

// LookupByAddressFinish retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//      error.
//
func (resolver *Resolver) LookupByAddressFinish(result AsyncResulter) (string, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_resolver_lookup_by_address_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// LookupByName: synchronously resolves hostname to determine its associated IP
// address(es). hostname may be an ASCII-only or UTF-8 hostname, or the textual
// form of an IP address (in which case this just becomes a wrapper around
// g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// Address, sorted in order of preference and guaranteed to not contain
// duplicates. That is, if using the result to connect to hostname, you should
// attempt to connect to the first address first, then the second if the first
// fails, etc. If you are using the result to listen on a socket, it is
// appropriate to add each result using e.g. g_socket_listener_add_address().
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP address, it may
// be easier to create a Address and use its Connectable interface.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Address, or NULL on error. You must unref each
//      of the addresses and free the list when you are done with it. (You can
//      use g_resolver_free_addresses() to do this.).
//
func (resolver *Resolver) LookupByName(ctx context.Context, hostname string) ([]*InetAddress, error) {
	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_resolver_lookup_by_name(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupByNameAsync begins asynchronously resolving hostname to determine its
// associated IP address(es), and eventually calls callback, which must call
// g_resolver_lookup_by_name_finish() to get the result. See
// g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up the address of.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupByNameAsync(ctx context.Context, hostname string, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_by_name_async(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(callback)
}

// LookupByNameFinish retrieves the result of a call to
// g_resolver_lookup_by_name_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//      details.
//
func (resolver *Resolver) LookupByNameFinish(result AsyncResulter) ([]*InetAddress, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_resolver_lookup_by_name_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupService: synchronously performs a DNS SRV lookup for the given service
// and protocol in the given domain and returns an array of Target. domain may
// be an ASCII-only or UTF-8 hostname. Note also that the service and protocol
// arguments do not include the leading underscore that appears in the actual
// DNS entry.
//
// On success, g_resolver_lookup_service() will return a non-empty #GList of
// Target, sorted in order of preference. (That is, you should attempt to
// connect to the first target first, then the second if the first fails, etc.)
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to the service, it is usually easier to create
// a Service and use its Connectable interface.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - service type to look up (eg, "ldap").
//    - protocol: networking protocol to use for service (eg, "tcp").
//    - domain: DNS domain to look up the service in.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Target, or NULL on error. You must free each of
//      the targets and the list when you are done with it. (You can use
//      g_resolver_free_targets() to do this.).
//
func (resolver *Resolver) LookupService(ctx context.Context, service, protocol, domain string) ([]*SrvTarget, error) {
	var _arg0 *C.GResolver    // out
	var _arg4 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.gchar        // out
	var _arg3 *C.gchar        // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.g_resolver_lookup_service(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSrvTarget)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_srv_target_free((*C.GSrvTarget)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// LookupServiceAsync begins asynchronously performing a DNS SRV lookup for the
// given service and protocol in the given domain, and eventually calls
// callback, which must call g_resolver_lookup_service_finish() to get the final
// result. See g_resolver_lookup_service() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - service type to look up (eg, "ldap").
//    - protocol: networking protocol to use for service (eg, "tcp").
//    - domain: DNS domain to look up the service in.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) LookupServiceAsync(ctx context.Context, service, protocol, domain string, callback AsyncReadyCallback) {
	var _arg0 *C.GResolver          // out
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg2 *C.gchar              // out
	var _arg3 *C.gchar              // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(service)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(protocol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg3))
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.g_resolver_lookup_service_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(service)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(callback)
}

// LookupServiceFinish retrieves the result of a previous call to
// g_resolver_lookup_service_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Target, or NULL on error. See
//      g_resolver_lookup_service() for more details.
//
func (resolver *Resolver) LookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error) {
	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C.g_resolver_lookup_service_finish(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSrvTarget)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_srv_target_free((*C.GSrvTarget)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// SetDefault sets resolver to be the application's default resolver (reffing
// resolver, and unreffing the previous default resolver, if any). Future calls
// to g_resolver_get_default() will return this resolver.
//
// This can be used if an application wants to perform any sort of DNS caching
// or "pinning"; it can implement its own #GResolver that calls the original
// default resolver for DNS operations, and implements its own cache policies on
// top of that, and then set itself as the default resolver for all later code
// to use.
func (resolver *Resolver) SetDefault() {
	var _arg0 *C.GResolver // out

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))

	C.g_resolver_set_default(_arg0)
	runtime.KeepAlive(resolver)
}

// lookupByAddress: synchronously reverse-resolves address to determine its
// associated hostname.
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - address to reverse-resolve.
//
// The function returns the following values:
//
//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//      error.
//
func (resolver *Resolver) lookupByAddress(ctx context.Context, address *InetAddress) (string, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_address

	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.GInetAddress // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_address(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// lookupByAddressAsync begins asynchronously reverse-resolving address to
// determine its associated hostname, and eventually calls callback, which must
// call g_resolver_lookup_by_address_finish() to get the final result.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - address to reverse-resolve.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) lookupByAddressAsync(ctx context.Context, address *InetAddress, callback AsyncReadyCallback) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_address_async

	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.GInetAddress       // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInetAddress)(unsafe.Pointer(coreglib.InternObject(address).Native()))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Resolver_virtual_lookup_by_address_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(address)
	runtime.KeepAlive(callback)
}

// lookupByAddressFinish retrieves the result of a previous call to
// g_resolver_lookup_by_address_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - utf8: hostname (either ASCII-only, or in ASCII-encoded form), or NULL on
//      error.
//
func (resolver *Resolver) lookupByAddressFinish(result AsyncResulter) (string, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_address_finish

	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.gchar        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_address_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// lookupByName: synchronously resolves hostname to determine its associated IP
// address(es). hostname may be an ASCII-only or UTF-8 hostname, or the textual
// form of an IP address (in which case this just becomes a wrapper around
// g_inet_address_new_from_string()).
//
// On success, g_resolver_lookup_by_name() will return a non-empty #GList of
// Address, sorted in order of preference and guaranteed to not contain
// duplicates. That is, if using the result to connect to hostname, you should
// attempt to connect to the first address first, then the second if the first
// fails, etc. If you are using the result to listen on a socket, it is
// appropriate to add each result using e.g. g_socket_listener_add_address().
//
// If the DNS resolution fails, error (if non-NULL) will be set to a value from
// Error and NULL will be returned.
//
// If cancellable is non-NULL, it can be used to cancel the operation, in which
// case error (if non-NULL) will be set to G_IO_ERROR_CANCELLED.
//
// If you are planning to connect to a socket on the resolved IP address, it may
// be easier to create a Address and use its Connectable interface.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Address, or NULL on error. You must unref each
//      of the addresses and free the list when you are done with it. (You can
//      use g_resolver_free_addresses() to do this.).
//
func (resolver *Resolver) lookupByName(ctx context.Context, hostname string) ([]*InetAddress, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name

	var _arg0 *C.GResolver    // out
	var _arg2 *C.GCancellable // out
	var _arg1 *C.gchar        // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_name(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// lookupByNameAsync begins asynchronously resolving hostname to determine its
// associated IP address(es), and eventually calls callback, which must call
// g_resolver_lookup_by_name_finish() to get the result. See
// g_resolver_lookup_by_name() for more details.
//
// The function takes the following parameters:
//
//    - ctx (optional) or NULL.
//    - hostname to look up the address of.
//    - callback (optional) to call after resolution completes.
//
func (resolver *Resolver) lookupByNameAsync(ctx context.Context, hostname string, callback AsyncReadyCallback) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name_async

	var _arg0 *C.GResolver          // out
	var _arg2 *C.GCancellable       // out
	var _arg1 *C.gchar              // out
	var _arg3 C.GAsyncReadyCallback // out
	var _arg4 C.gpointer

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
	defer C.free(unsafe.Pointer(_arg1))
	if callback != nil {
		_arg3 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg4 = C.gpointer(gbox.AssignOnce(callback))
	}

	C._gotk4_gio2_Resolver_virtual_lookup_by_name_async(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(hostname)
	runtime.KeepAlive(callback)
}

// lookupByNameFinish retrieves the result of a call to
// g_resolver_lookup_by_name_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list Address, or NULL on error. See g_resolver_lookup_by_name() for more
//      details.
//
func (resolver *Resolver) lookupByNameFinish(result AsyncResulter) ([]*InetAddress, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_by_name_finish

	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_by_name_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*InetAddress // out
	var _goerr error         // out

	_list = make([]*InetAddress, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GInetAddress)(v)
		var dst *InetAddress // out
		dst = wrapInetAddress(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// lookupServiceFinish retrieves the result of a previous call to
// g_resolver_lookup_service_async().
//
// If the DNS resolution failed, error (if non-NULL) will be set to a value from
// Error. If the operation was cancelled, error will be set to
// G_IO_ERROR_CANCELLED.
//
// The function takes the following parameters:
//
//    - result passed to your ReadyCallback.
//
// The function returns the following values:
//
//    - list: non-empty #GList of Target, or NULL on error. See
//      g_resolver_lookup_service() for more details.
//
func (resolver *Resolver) lookupServiceFinish(result AsyncResulter) ([]*SrvTarget, error) {
	gclass := (*C.GResolverClass)(coreglib.PeekParentClass(resolver))
	fnarg := gclass.lookup_service_finish

	var _arg0 *C.GResolver    // out
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GList        // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GResolver)(unsafe.Pointer(coreglib.InternObject(resolver).Native()))
	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	_cret = C._gotk4_gio2_Resolver_virtual_lookup_service_finish(unsafe.Pointer(fnarg), _arg0, _arg1, &_cerr)
	runtime.KeepAlive(resolver)
	runtime.KeepAlive(result)

	var _list []*SrvTarget // out
	var _goerr error       // out

	_list = make([]*SrvTarget, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GSrvTarget)(v)
		var dst *SrvTarget // out
		dst = (*SrvTarget)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_srv_target_free((*C.GSrvTarget)(intern.C))
			},
		)
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// ResolverGetDefault gets the default #GResolver. You should unref it when you
// are done with it. #GResolver may use its reference count as a hint about how
// many threads it should allocate for concurrent DNS resolutions.
//
// The function returns the following values:
//
//    - resolver: default #GResolver.
//
func ResolverGetDefault() Resolverer {
	var _cret *C.GResolver // in

	_cret = C.g_resolver_get_default()

	var _resolver Resolverer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.Resolverer is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Resolverer)
			return ok
		})
		rv, ok := casted.(Resolverer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Resolverer")
		}
		_resolver = rv
	}

	return _resolver
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gio-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_volume_monitor_get_type()), F: marshalVolumeMonitorrer},
	})
}

// VOLUME_MONITOR_EXTENSION_POINT_NAME: extension point for volume monitor
// functionality. See [Extending GIO][extending-gio].
const VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-volume-monitor"

// VolumeMonitorOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type VolumeMonitorOverrider interface {
	// The function takes the following parameters:
	//
	DriveChanged(drive Driver)
	// The function takes the following parameters:
	//
	DriveConnected(drive Driver)
	// The function takes the following parameters:
	//
	DriveDisconnected(drive Driver)
	// The function takes the following parameters:
	//
	DriveEjectButton(drive Driver)
	// The function takes the following parameters:
	//
	DriveStopButton(drive Driver)
	// ConnectedDrives gets a list of drives connected to the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of connected #GDrive objects.
	//
	ConnectedDrives() []Driver
	// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
	//
	// The function takes the following parameters:
	//
	//    - uuid: UUID to look for.
	//
	// The function returns the following values:
	//
	//    - mount (optional) or NULL if no such mount is available. Free the
	//      returned object with g_object_unref().
	//
	MountForUUID(uuid string) Mounter
	// Mounts gets a list of the mounts on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of #GMount objects.
	//
	Mounts() []Mounter
	// VolumeForUUID finds a #GVolume object by its UUID (see
	// g_volume_get_uuid()).
	//
	// The function takes the following parameters:
	//
	//    - uuid: UUID to look for.
	//
	// The function returns the following values:
	//
	//    - volume (optional) or NULL if no such volume is available. Free the
	//      returned object with g_object_unref().
	//
	VolumeForUUID(uuid string) Volumer
	// Volumes gets a list of the volumes on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of #GVolume objects.
	//
	Volumes() []Volumer
	// The function takes the following parameters:
	//
	MountAdded(mount Mounter)
	// The function takes the following parameters:
	//
	MountChanged(mount Mounter)
	// The function takes the following parameters:
	//
	MountPreUnmount(mount Mounter)
	// The function takes the following parameters:
	//
	MountRemoved(mount Mounter)
	// The function takes the following parameters:
	//
	VolumeAdded(volume Volumer)
	// The function takes the following parameters:
	//
	VolumeChanged(volume Volumer)
	// The function takes the following parameters:
	//
	VolumeRemoved(volume Volumer)
}

// VolumeMonitor is for listing the user interesting devices and volumes on the
// computer. In other words, what a file selector or file manager would show in
// a sidebar.
//
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*VolumeMonitor)(nil)
)

func wrapVolumeMonitor(obj *externglib.Object) *VolumeMonitor {
	return &VolumeMonitor{
		Object: obj,
	}
}

func marshalVolumeMonitorrer(p uintptr) (interface{}, error) {
	return wrapVolumeMonitor(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDriveChanged: emitted when a drive changes.
func (volumeMonitor *VolumeMonitor) ConnectDriveChanged(f func(drive Driver)) externglib.SignalHandle {
	return volumeMonitor.Connect("drive-changed", f)
}

// ConnectDriveConnected: emitted when a drive is connected to the system.
func (volumeMonitor *VolumeMonitor) ConnectDriveConnected(f func(drive Driver)) externglib.SignalHandle {
	return volumeMonitor.Connect("drive-connected", f)
}

// ConnectDriveDisconnected: emitted when a drive is disconnected from the
// system.
func (volumeMonitor *VolumeMonitor) ConnectDriveDisconnected(f func(drive Driver)) externglib.SignalHandle {
	return volumeMonitor.Connect("drive-disconnected", f)
}

// ConnectDriveEjectButton: emitted when the eject button is pressed on drive.
func (volumeMonitor *VolumeMonitor) ConnectDriveEjectButton(f func(drive Driver)) externglib.SignalHandle {
	return volumeMonitor.Connect("drive-eject-button", f)
}

// ConnectDriveStopButton: emitted when the stop button is pressed on drive.
func (volumeMonitor *VolumeMonitor) ConnectDriveStopButton(f func(drive Driver)) externglib.SignalHandle {
	return volumeMonitor.Connect("drive-stop-button", f)
}

// ConnectMountAdded: emitted when a mount is added.
func (volumeMonitor *VolumeMonitor) ConnectMountAdded(f func(mount Mounter)) externglib.SignalHandle {
	return volumeMonitor.Connect("mount-added", f)
}

// ConnectMountChanged: emitted when a mount changes.
func (volumeMonitor *VolumeMonitor) ConnectMountChanged(f func(mount Mounter)) externglib.SignalHandle {
	return volumeMonitor.Connect("mount-changed", f)
}

// ConnectMountPreUnmount: may be emitted when a mount is about to be removed.
//
// This signal depends on the backend and is only emitted if GIO was used to
// unmount.
func (volumeMonitor *VolumeMonitor) ConnectMountPreUnmount(f func(mount Mounter)) externglib.SignalHandle {
	return volumeMonitor.Connect("mount-pre-unmount", f)
}

// ConnectMountRemoved: emitted when a mount is removed.
func (volumeMonitor *VolumeMonitor) ConnectMountRemoved(f func(mount Mounter)) externglib.SignalHandle {
	return volumeMonitor.Connect("mount-removed", f)
}

// ConnectVolumeAdded: emitted when a mountable volume is added to the system.
func (volumeMonitor *VolumeMonitor) ConnectVolumeAdded(f func(volume Volumer)) externglib.SignalHandle {
	return volumeMonitor.Connect("volume-added", f)
}

// ConnectVolumeChanged: emitted when mountable volume is changed.
func (volumeMonitor *VolumeMonitor) ConnectVolumeChanged(f func(volume Volumer)) externglib.SignalHandle {
	return volumeMonitor.Connect("volume-changed", f)
}

// ConnectVolumeRemoved: emitted when a mountable volume is removed from the
// system.
func (volumeMonitor *VolumeMonitor) ConnectVolumeRemoved(f func(volume Volumer)) externglib.SignalHandle {
	return volumeMonitor.Connect("volume-removed", f)
}

// ConnectedDrives gets a list of drives connected to the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of connected #GDrive objects.
//
func (volumeMonitor *VolumeMonitor) ConnectedDrives() []Driver {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(volumeMonitor.Native()))

	_cret = C.g_volume_monitor_get_connected_drives(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []Driver // out

	_list = make([]Driver, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDrive)(v)
		var dst Driver // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.Driver is nil")
			}

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(Driver)
				return ok
			})
			rv, ok := casted.(Driver)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
//
// The function takes the following parameters:
//
//    - uuid: UUID to look for.
//
// The function returns the following values:
//
//    - mount (optional) or NULL if no such mount is available. Free the returned
//      object with g_object_unref().
//
func (volumeMonitor *VolumeMonitor) MountForUUID(uuid string) Mounter {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GMount         // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(volumeMonitor.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_mount_for_uuid(_arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _mount Mounter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(Mounter)
				return ok
			})
			rv, ok := casted.(Mounter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
			}
			_mount = rv
		}
	}

	return _mount
}

// Mounts gets a list of the mounts on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of #GMount objects.
//
func (volumeMonitor *VolumeMonitor) Mounts() []Mounter {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(volumeMonitor.Native()))

	_cret = C.g_volume_monitor_get_mounts(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []Mounter // out

	_list = make([]Mounter, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GMount)(v)
		var dst Mounter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.Mounter is nil")
			}

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(Mounter)
				return ok
			})
			rv, ok := casted.(Mounter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// VolumeForUUID finds a #GVolume object by its UUID (see g_volume_get_uuid()).
//
// The function takes the following parameters:
//
//    - uuid: UUID to look for.
//
// The function returns the following values:
//
//    - volume (optional) or NULL if no such volume is available. Free the
//      returned object with g_object_unref().
//
func (volumeMonitor *VolumeMonitor) VolumeForUUID(uuid string) Volumer {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GVolume        // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(volumeMonitor.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_volume_for_uuid(_arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _volume Volumer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(Volumer)
				return ok
			})
			rv, ok := casted.(Volumer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
			}
			_volume = rv
		}
	}

	return _volume
}

// Volumes gets a list of the volumes on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of #GVolume objects.
//
func (volumeMonitor *VolumeMonitor) Volumes() []Volumer {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(volumeMonitor.Native()))

	_cret = C.g_volume_monitor_get_volumes(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []Volumer // out

	_list = make([]Volumer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVolume)(v)
		var dst Volumer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gio.Volumer is nil")
			}

			object := externglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(Volumer)
				return ok
			})
			rv, ok := casted.(Volumer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// VolumeMonitorAdoptOrphanMount: this function should be called by any Monitor
// implementation when a new #GMount object is created that is not associated
// with a #GVolume object. It must be called just before emitting the
// mount_added signal.
//
// If the return value is not NULL, the caller must associate the returned
// #GVolume object with the #GMount. This involves returning it in its
// g_mount_get_volume() implementation. The caller must also listen for the
// "removed" signal on the returned object and give up its reference when
// handling that signal
//
// Similarly, if implementing g_volume_monitor_adopt_orphan_mount(), the
// implementor must take a reference to mount and return it in its
// g_volume_get_mount() implemented. Also, the implementor must listen for the
// "unmounted" signal on mount and give up its reference upon handling that
// signal.
//
// There are two main use cases for this function.
//
// One is when implementing a user space file system driver that reads blocks of
// a block device that is already represented by the native volume monitor (for
// example a CD Audio file system driver). Such a driver will generate its own
// #GMount object that needs to be associated with the #GVolume object that
// represents the volume.
//
// The other is for implementing a Monitor whose sole purpose is to return
// #GVolume objects representing entries in the users "favorite servers" list or
// similar.
//
// Deprecated: Instead of using this function, Monitor implementations should
// instead create shadow mounts with the URI of the mount they intend to adopt.
// See the proxy volume monitor in gvfs for an example of this. Also see
// g_mount_is_shadowed(), g_mount_shadow() and g_mount_unshadow() functions.
//
// The function takes the following parameters:
//
//    - mount object to find a parent for.
//
// The function returns the following values:
//
//    - volume object that is the parent for mount or NULL if no wants to adopt
//      the #GMount.
//
func VolumeMonitorAdoptOrphanMount(mount Mounter) Volumer {
	var _arg1 *C.GMount  // out
	var _cret *C.GVolume // in

	_arg1 = (*C.GMount)(unsafe.Pointer(mount.Native()))

	_cret = C.g_volume_monitor_adopt_orphan_mount(_arg1)
	runtime.KeepAlive(mount)

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	return _volume
}

// VolumeMonitorGet gets the volume monitor used by gio.
//
// The function returns the following values:
//
//    - volumeMonitor: reference to the Monitor used by gio. Call
//      g_object_unref() when done with it.
//
func VolumeMonitorGet() *VolumeMonitor {
	var _cret *C.GVolumeMonitor // in

	_cret = C.g_volume_monitor_get()

	var _volumeMonitor *VolumeMonitor // out

	_volumeMonitor = wrapVolumeMonitor(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _volumeMonitor
}

// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved(gpointer, GVolume*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeChanged(gpointer, GVolume*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeAdded(gpointer, GVolume*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountRemoved(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountChanged(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountAdded(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveStopButton(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveConnected(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveChanged(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_removed(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_changed(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_added(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_removed(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_pre_unmount(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_changed(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_added(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_stop_button(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_eject_button(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_disconnected(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_connected(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_changed(GVolumeMonitor*, GDrive*);
// extern GVolume* _gotk4_gio2_VolumeMonitorClass_get_volume_for_uuid(GVolumeMonitor*, char*);
// extern GMount* _gotk4_gio2_VolumeMonitorClass_get_mount_for_uuid(GVolumeMonitor*, char*);
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_volumes(GVolumeMonitor*);
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_mounts(GVolumeMonitor*);
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_connected_drives(GVolumeMonitor*);
// GList* _gotk4_gio2_VolumeMonitor_virtual_get_connected_drives(void* fnptr, GVolumeMonitor* arg0) {
//   return ((GList* (*)(GVolumeMonitor*))(fnptr))(arg0);
// };
// GList* _gotk4_gio2_VolumeMonitor_virtual_get_mounts(void* fnptr, GVolumeMonitor* arg0) {
//   return ((GList* (*)(GVolumeMonitor*))(fnptr))(arg0);
// };
// GList* _gotk4_gio2_VolumeMonitor_virtual_get_volumes(void* fnptr, GVolumeMonitor* arg0) {
//   return ((GList* (*)(GVolumeMonitor*))(fnptr))(arg0);
// };
// GMount* _gotk4_gio2_VolumeMonitor_virtual_get_mount_for_uuid(void* fnptr, GVolumeMonitor* arg0, char* arg1) {
//   return ((GMount* (*)(GVolumeMonitor*, char*))(fnptr))(arg0, arg1);
// };
// GVolume* _gotk4_gio2_VolumeMonitor_virtual_get_volume_for_uuid(void* fnptr, GVolumeMonitor* arg0, char* arg1) {
//   return ((GVolume* (*)(GVolumeMonitor*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_changed(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_connected(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_disconnected(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_eject_button(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_drive_stop_button(void* fnptr, GVolumeMonitor* arg0, GDrive* arg1) {
//   ((void (*)(GVolumeMonitor*, GDrive*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_mount_added(void* fnptr, GVolumeMonitor* arg0, GMount* arg1) {
//   ((void (*)(GVolumeMonitor*, GMount*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_mount_changed(void* fnptr, GVolumeMonitor* arg0, GMount* arg1) {
//   ((void (*)(GVolumeMonitor*, GMount*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_mount_pre_unmount(void* fnptr, GVolumeMonitor* arg0, GMount* arg1) {
//   ((void (*)(GVolumeMonitor*, GMount*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_mount_removed(void* fnptr, GVolumeMonitor* arg0, GMount* arg1) {
//   ((void (*)(GVolumeMonitor*, GMount*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_volume_added(void* fnptr, GVolumeMonitor* arg0, GVolume* arg1) {
//   ((void (*)(GVolumeMonitor*, GVolume*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_volume_changed(void* fnptr, GVolumeMonitor* arg0, GVolume* arg1) {
//   ((void (*)(GVolumeMonitor*, GVolume*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gio2_VolumeMonitor_virtual_volume_removed(void* fnptr, GVolumeMonitor* arg0, GVolume* arg1) {
//   ((void (*)(GVolumeMonitor*, GVolume*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeVolumeMonitor = coreglib.Type(C.g_volume_monitor_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVolumeMonitor, F: marshalVolumeMonitor},
	})
}

// VOLUME_MONITOR_EXTENSION_POINT_NAME: extension point for volume monitor
// functionality. See [Extending GIO][extending-gio].
const VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-volume-monitor"

// VolumeMonitorOverrides contains methods that are overridable.
type VolumeMonitorOverrides struct {
	// The function takes the following parameters:
	//
	DriveChanged func(drive Driver)
	// The function takes the following parameters:
	//
	DriveConnected func(drive Driver)
	// The function takes the following parameters:
	//
	DriveDisconnected func(drive Driver)
	// The function takes the following parameters:
	//
	DriveEjectButton func(drive Driver)
	// The function takes the following parameters:
	//
	DriveStopButton func(drive Driver)
	// ConnectedDrives gets a list of drives connected to the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of connected #GDrive objects.
	//
	ConnectedDrives func() []*Drive
	// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
	//
	// The function takes the following parameters:
	//
	//    - uuid: UUID to look for.
	//
	// The function returns the following values:
	//
	//    - mount (optional) or NULL if no such mount is available. Free the
	//      returned object with g_object_unref().
	//
	MountForUUID func(uuid string) *Mount
	// Mounts gets a list of the mounts on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of #GMount objects.
	//
	Mounts func() []*Mount
	// VolumeForUUID finds a #GVolume object by its UUID (see
	// g_volume_get_uuid()).
	//
	// The function takes the following parameters:
	//
	//    - uuid: UUID to look for.
	//
	// The function returns the following values:
	//
	//    - volume (optional) or NULL if no such volume is available. Free the
	//      returned object with g_object_unref().
	//
	VolumeForUUID func(uuid string) *Volume
	// Volumes gets a list of the volumes on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of #GVolume objects.
	//
	Volumes func() []*Volume
	// The function takes the following parameters:
	//
	MountAdded func(mount Mounter)
	// The function takes the following parameters:
	//
	MountChanged func(mount Mounter)
	// The function takes the following parameters:
	//
	MountPreUnmount func(mount Mounter)
	// The function takes the following parameters:
	//
	MountRemoved func(mount Mounter)
	// The function takes the following parameters:
	//
	VolumeAdded func(volume Volumer)
	// The function takes the following parameters:
	//
	VolumeChanged func(volume Volumer)
	// The function takes the following parameters:
	//
	VolumeRemoved func(volume Volumer)
}

func defaultVolumeMonitorOverrides(v *VolumeMonitor) VolumeMonitorOverrides {
	return VolumeMonitorOverrides{
		DriveChanged:      v.driveChanged,
		DriveConnected:    v.driveConnected,
		DriveDisconnected: v.driveDisconnected,
		DriveEjectButton:  v.driveEjectButton,
		DriveStopButton:   v.driveStopButton,
		ConnectedDrives:   v.connectedDrives,
		MountForUUID:      v.mountForUUID,
		Mounts:            v.mounts,
		VolumeForUUID:     v.volumeForUUID,
		Volumes:           v.volumes,
		MountAdded:        v.mountAdded,
		MountChanged:      v.mountChanged,
		MountPreUnmount:   v.mountPreUnmount,
		MountRemoved:      v.mountRemoved,
		VolumeAdded:       v.volumeAdded,
		VolumeChanged:     v.volumeChanged,
		VolumeRemoved:     v.volumeRemoved,
	}
}

// VolumeMonitor is for listing the user interesting devices and volumes on the
// computer. In other words, what a file selector or file manager would show in
// a sidebar.
//
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*VolumeMonitor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*VolumeMonitor, *VolumeMonitorClass, VolumeMonitorOverrides](
		GTypeVolumeMonitor,
		initVolumeMonitorClass,
		wrapVolumeMonitor,
		defaultVolumeMonitorOverrides,
	)
}

func initVolumeMonitorClass(gclass unsafe.Pointer, overrides VolumeMonitorOverrides, classInitFunc func(*VolumeMonitorClass)) {
	pclass := (*C.GVolumeMonitorClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeVolumeMonitor))))

	if overrides.DriveChanged != nil {
		pclass.drive_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_changed)
	}

	if overrides.DriveConnected != nil {
		pclass.drive_connected = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_connected)
	}

	if overrides.DriveDisconnected != nil {
		pclass.drive_disconnected = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_disconnected)
	}

	if overrides.DriveEjectButton != nil {
		pclass.drive_eject_button = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_eject_button)
	}

	if overrides.DriveStopButton != nil {
		pclass.drive_stop_button = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_stop_button)
	}

	if overrides.ConnectedDrives != nil {
		pclass.get_connected_drives = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_connected_drives)
	}

	if overrides.MountForUUID != nil {
		pclass.get_mount_for_uuid = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_mount_for_uuid)
	}

	if overrides.Mounts != nil {
		pclass.get_mounts = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_mounts)
	}

	if overrides.VolumeForUUID != nil {
		pclass.get_volume_for_uuid = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_volume_for_uuid)
	}

	if overrides.Volumes != nil {
		pclass.get_volumes = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_volumes)
	}

	if overrides.MountAdded != nil {
		pclass.mount_added = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_added)
	}

	if overrides.MountChanged != nil {
		pclass.mount_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_changed)
	}

	if overrides.MountPreUnmount != nil {
		pclass.mount_pre_unmount = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_pre_unmount)
	}

	if overrides.MountRemoved != nil {
		pclass.mount_removed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_removed)
	}

	if overrides.VolumeAdded != nil {
		pclass.volume_added = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_added)
	}

	if overrides.VolumeChanged != nil {
		pclass.volume_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_changed)
	}

	if overrides.VolumeRemoved != nil {
		pclass.volume_removed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_removed)
	}

	if classInitFunc != nil {
		class := (*VolumeMonitorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVolumeMonitor(obj *coreglib.Object) *VolumeMonitor {
	return &VolumeMonitor{
		Object: obj,
	}
}

func marshalVolumeMonitor(p uintptr) (interface{}, error) {
	return wrapVolumeMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDriveChanged is emitted when a drive changes.
func (volumeMonitor *VolumeMonitor) ConnectDriveChanged(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveChanged), f)
}

// ConnectDriveConnected is emitted when a drive is connected to the system.
func (volumeMonitor *VolumeMonitor) ConnectDriveConnected(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-connected", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveConnected), f)
}

// ConnectDriveDisconnected is emitted when a drive is disconnected from the
// system.
func (volumeMonitor *VolumeMonitor) ConnectDriveDisconnected(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-disconnected", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected), f)
}

// ConnectDriveEjectButton is emitted when the eject button is pressed on drive.
func (volumeMonitor *VolumeMonitor) ConnectDriveEjectButton(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-eject-button", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton), f)
}

// ConnectDriveStopButton is emitted when the stop button is pressed on drive.
func (volumeMonitor *VolumeMonitor) ConnectDriveStopButton(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-stop-button", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveStopButton), f)
}

// ConnectMountAdded is emitted when a mount is added.
func (volumeMonitor *VolumeMonitor) ConnectMountAdded(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-added", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountAdded), f)
}

// ConnectMountChanged is emitted when a mount changes.
func (volumeMonitor *VolumeMonitor) ConnectMountChanged(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountChanged), f)
}

// ConnectMountPreUnmount: may be emitted when a mount is about to be removed.
//
// This signal depends on the backend and is only emitted if GIO was used to
// unmount.
func (volumeMonitor *VolumeMonitor) ConnectMountPreUnmount(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-pre-unmount", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount), f)
}

// ConnectMountRemoved is emitted when a mount is removed.
func (volumeMonitor *VolumeMonitor) ConnectMountRemoved(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-removed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountRemoved), f)
}

// ConnectVolumeAdded is emitted when a mountable volume is added to the system.
func (volumeMonitor *VolumeMonitor) ConnectVolumeAdded(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-added", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeAdded), f)
}

// ConnectVolumeChanged is emitted when mountable volume is changed.
func (volumeMonitor *VolumeMonitor) ConnectVolumeChanged(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeChanged), f)
}

// ConnectVolumeRemoved is emitted when a mountable volume is removed from the
// system.
func (volumeMonitor *VolumeMonitor) ConnectVolumeRemoved(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-removed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved), f)
}

// ConnectedDrives gets a list of drives connected to the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of connected #GDrive objects.
//
func (volumeMonitor *VolumeMonitor) ConnectedDrives() []*Drive {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_connected_drives(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Drive // out

	_list = make([]*Drive, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDrive)(v)
		var dst *Drive // out
		dst = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
//
// The function takes the following parameters:
//
//    - uuid: UUID to look for.
//
// The function returns the following values:
//
//    - mount (optional) or NULL if no such mount is available. Free the returned
//      object with g_object_unref().
//
func (volumeMonitor *VolumeMonitor) MountForUUID(uuid string) *Mount {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GMount         // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_mount_for_uuid(_arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _mount *Mount // out

	if _cret != nil {
		_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _mount
}

// Mounts gets a list of the mounts on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of #GMount objects.
//
func (volumeMonitor *VolumeMonitor) Mounts() []*Mount {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_mounts(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Mount // out

	_list = make([]*Mount, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GMount)(v)
		var dst *Mount // out
		dst = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// VolumeForUUID finds a #GVolume object by its UUID (see g_volume_get_uuid()).
//
// The function takes the following parameters:
//
//    - uuid: UUID to look for.
//
// The function returns the following values:
//
//    - volume (optional) or NULL if no such volume is available. Free the
//      returned object with g_object_unref().
//
func (volumeMonitor *VolumeMonitor) VolumeForUUID(uuid string) *Volume {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GVolume        // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_volume_for_uuid(_arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _volume *Volume // out

	if _cret != nil {
		_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _volume
}

// Volumes gets a list of the volumes on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of #GVolume objects.
//
func (volumeMonitor *VolumeMonitor) Volumes() []*Volume {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_volumes(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Volume // out

	_list = make([]*Volume, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVolume)(v)
		var dst *Volume // out
		dst = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) driveChanged(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_changed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) driveConnected(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_connected

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_connected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) driveDisconnected(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_disconnected

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_disconnected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) driveEjectButton(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_eject_button

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_eject_button(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) driveStopButton(drive Driver) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.drive_stop_button

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GDrive         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(drive).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_drive_stop_button(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(drive)
}

// connectedDrives gets a list of drives connected to the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of connected #GDrive objects.
//
func (volumeMonitor *VolumeMonitor) connectedDrives() []*Drive {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_connected_drives

	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_connected_drives(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Drive // out

	_list = make([]*Drive, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDrive)(v)
		var dst *Drive // out
		dst = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// mountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
//
// The function takes the following parameters:
//
//    - uuid: UUID to look for.
//
// The function returns the following values:
//
//    - mount (optional) or NULL if no such mount is available. Free the returned
//      object with g_object_unref().
//
func (volumeMonitor *VolumeMonitor) mountForUUID(uuid string) *Mount {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_mount_for_uuid

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GMount         // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_mount_for_uuid(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _mount *Mount // out

	if _cret != nil {
		_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _mount
}

// Mounts gets a list of the mounts on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of #GMount objects.
//
func (volumeMonitor *VolumeMonitor) mounts() []*Mount {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_mounts

	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_mounts(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Mount // out

	_list = make([]*Mount, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GMount)(v)
		var dst *Mount // out
		dst = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// volumeForUUID finds a #GVolume object by its UUID (see g_volume_get_uuid()).
//
// The function takes the following parameters:
//
//    - uuid: UUID to look for.
//
// The function returns the following values:
//
//    - volume (optional) or NULL if no such volume is available. Free the
//      returned object with g_object_unref().
//
func (volumeMonitor *VolumeMonitor) volumeForUUID(uuid string) *Volume {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_volume_for_uuid

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GVolume        // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_volume_for_uuid(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _volume *Volume // out

	if _cret != nil {
		_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _volume
}

// Volumes gets a list of the volumes on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of #GVolume objects.
//
func (volumeMonitor *VolumeMonitor) volumes() []*Volume {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.get_volumes

	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C._gotk4_gio2_VolumeMonitor_virtual_get_volumes(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Volume // out

	_list = make([]*Volume, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVolume)(v)
		var dst *Volume // out
		dst = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) mountAdded(mount Mounter) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.mount_added

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GMount         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_mount_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) mountChanged(mount Mounter) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.mount_changed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GMount         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_mount_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) mountPreUnmount(mount Mounter) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.mount_pre_unmount

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GMount         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_mount_pre_unmount(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) mountRemoved(mount Mounter) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.mount_removed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GMount         // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_mount_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(mount)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) volumeAdded(volume Volumer) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.volume_added

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GVolume        // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_volume_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) volumeChanged(volume Volumer) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.volume_changed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GVolume        // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_volume_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// The function takes the following parameters:
//
func (volumeMonitor *VolumeMonitor) volumeRemoved(volume Volumer) {
	gclass := (*C.GVolumeMonitorClass)(coreglib.PeekParentClass(volumeMonitor))
	fnarg := gclass.volume_removed

	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.GVolume        // out

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))

	C._gotk4_gio2_VolumeMonitor_virtual_volume_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(volume)
}

// VolumeMonitorAdoptOrphanMount: this function should be called by any Monitor
// implementation when a new #GMount object is created that is not associated
// with a #GVolume object. It must be called just before emitting the
// mount_added signal.
//
// If the return value is not NULL, the caller must associate the returned
// #GVolume object with the #GMount. This involves returning it in its
// g_mount_get_volume() implementation. The caller must also listen for the
// "removed" signal on the returned object and give up its reference when
// handling that signal
//
// Similarly, if implementing g_volume_monitor_adopt_orphan_mount(), the
// implementor must take a reference to mount and return it in its
// g_volume_get_mount() implemented. Also, the implementor must listen for the
// "unmounted" signal on mount and give up its reference upon handling that
// signal.
//
// There are two main use cases for this function.
//
// One is when implementing a user space file system driver that reads blocks of
// a block device that is already represented by the native volume monitor (for
// example a CD Audio file system driver). Such a driver will generate its own
// #GMount object that needs to be associated with the #GVolume object that
// represents the volume.
//
// The other is for implementing a Monitor whose sole purpose is to return
// #GVolume objects representing entries in the users "favorite servers" list or
// similar.
//
// Deprecated: Instead of using this function, Monitor implementations should
// instead create shadow mounts with the URI of the mount they intend to adopt.
// See the proxy volume monitor in gvfs for an example of this. Also see
// g_mount_is_shadowed(), g_mount_shadow() and g_mount_unshadow() functions.
//
// The function takes the following parameters:
//
//    - mount object to find a parent for.
//
// The function returns the following values:
//
//    - volume object that is the parent for mount or NULL if no wants to adopt
//      the #GMount.
//
func VolumeMonitorAdoptOrphanMount(mount Mounter) *Volume {
	var _arg1 *C.GMount  // out
	var _cret *C.GVolume // in

	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_volume_monitor_adopt_orphan_mount(_arg1)
	runtime.KeepAlive(mount)

	var _volume *Volume // out

	_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _volume
}

// VolumeMonitorGet gets the volume monitor used by gio.
//
// The function returns the following values:
//
//    - volumeMonitor: reference to the Monitor used by gio. Call
//      g_object_unref() when done with it.
//
func VolumeMonitorGet() *VolumeMonitor {
	var _cret *C.GVolumeMonitor // in

	_cret = C.g_volume_monitor_get()

	var _volumeMonitor *VolumeMonitor // out

	_volumeMonitor = wrapVolumeMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _volumeMonitor
}

// VolumeMonitorClass: instance of this type is always passed by reference.
type VolumeMonitorClass struct {
	*volumeMonitorClass
}

// volumeMonitorClass is the struct that's finalized.
type volumeMonitorClass struct {
	native *C.GVolumeMonitorClass
}

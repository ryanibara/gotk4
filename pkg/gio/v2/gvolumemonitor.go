// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// #include <glib-object.h>
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_connected_drives(GVolumeMonitor*);
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_mounts(GVolumeMonitor*);
// extern GList* _gotk4_gio2_VolumeMonitorClass_get_volumes(GVolumeMonitor*);
// extern GMount* _gotk4_gio2_VolumeMonitorClass_get_mount_for_uuid(GVolumeMonitor*, char*);
// extern GVolume* _gotk4_gio2_VolumeMonitorClass_get_volume_for_uuid(GVolumeMonitor*, char*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_changed(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_connected(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_disconnected(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_eject_button(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_drive_stop_button(GVolumeMonitor*, GDrive*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_added(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_changed(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_pre_unmount(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_mount_removed(GVolumeMonitor*, GMount*);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_added(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_changed(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitorClass_volume_removed(GVolumeMonitor*, GVolume*);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveChanged(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveConnected(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectDriveStopButton(gpointer, GDrive*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountAdded(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountChanged(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectMountRemoved(gpointer, GMount*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeAdded(gpointer, GVolume*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeChanged(gpointer, GVolume*, guintptr);
// extern void _gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved(gpointer, GVolume*, guintptr);
import "C"

// GType values.
var (
	GTypeVolumeMonitor = coreglib.Type(C.g_volume_monitor_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeVolumeMonitor, F: marshalVolumeMonitor},
	})
}

// VOLUME_MONITOR_EXTENSION_POINT_NAME: extension point for volume monitor
// functionality. See [Extending GIO][extending-gio].
const VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-volume-monitor"

// VolumeMonitorOverrider contains methods that are overridable.
type VolumeMonitorOverrider interface {
	// The function takes the following parameters:
	//
	DriveChanged(drive Driver)
	// The function takes the following parameters:
	//
	DriveConnected(drive Driver)
	// The function takes the following parameters:
	//
	DriveDisconnected(drive Driver)
	// The function takes the following parameters:
	//
	DriveEjectButton(drive Driver)
	// The function takes the following parameters:
	//
	DriveStopButton(drive Driver)
	// ConnectedDrives gets a list of drives connected to the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of connected #GDrive objects.
	//
	ConnectedDrives() []*Drive
	// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
	//
	// The function takes the following parameters:
	//
	//    - uuid: UUID to look for.
	//
	// The function returns the following values:
	//
	//    - mount (optional) or NULL if no such mount is available. Free the
	//      returned object with g_object_unref().
	//
	MountForUUID(uuid string) *Mount
	// Mounts gets a list of the mounts on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of #GMount objects.
	//
	Mounts() []*Mount
	// VolumeForUUID finds a #GVolume object by its UUID (see
	// g_volume_get_uuid()).
	//
	// The function takes the following parameters:
	//
	//    - uuid: UUID to look for.
	//
	// The function returns the following values:
	//
	//    - volume (optional) or NULL if no such volume is available. Free the
	//      returned object with g_object_unref().
	//
	VolumeForUUID(uuid string) *Volume
	// Volumes gets a list of the volumes on the system.
	//
	// The returned list should be freed with g_list_free(), after its elements
	// have been unreffed with g_object_unref().
	//
	// The function returns the following values:
	//
	//    - list of #GVolume objects.
	//
	Volumes() []*Volume
	// The function takes the following parameters:
	//
	MountAdded(mount Mounter)
	// The function takes the following parameters:
	//
	MountChanged(mount Mounter)
	// The function takes the following parameters:
	//
	MountPreUnmount(mount Mounter)
	// The function takes the following parameters:
	//
	MountRemoved(mount Mounter)
	// The function takes the following parameters:
	//
	VolumeAdded(volume Volumer)
	// The function takes the following parameters:
	//
	VolumeChanged(volume Volumer)
	// The function takes the following parameters:
	//
	VolumeRemoved(volume Volumer)
}

// VolumeMonitor is for listing the user interesting devices and volumes on the
// computer. In other words, what a file selector or file manager would show in
// a sidebar.
//
// Monitor is not [thread-default-context
// aware][g-main-context-push-thread-default], and so should not be used other
// than from the main thread, with no thread-default-context active.
//
// In order to receive updates about volumes and mounts monitored through GVFS,
// a main loop must be running.
type VolumeMonitor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*VolumeMonitor)(nil)
)

func init() {
	coreglib.RegisterClassInfo(coreglib.ClassTypeInfo{
		GType:         GTypeVolumeMonitor,
		GoType:        reflect.TypeOf((*VolumeMonitor)(nil)),
		InitClass:     initClassVolumeMonitor,
		FinalizeClass: finalizeClassVolumeMonitor,
	})
}

func initClassVolumeMonitor(gclass unsafe.Pointer, goval any) {

	pclass := (*C.GVolumeMonitorClass)(unsafe.Pointer(gclass))

	if _, ok := goval.(interface{ DriveChanged(drive Driver) }); ok {
		pclass.drive_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_changed)
	}

	if _, ok := goval.(interface{ DriveConnected(drive Driver) }); ok {
		pclass.drive_connected = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_connected)
	}

	if _, ok := goval.(interface{ DriveDisconnected(drive Driver) }); ok {
		pclass.drive_disconnected = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_disconnected)
	}

	if _, ok := goval.(interface{ DriveEjectButton(drive Driver) }); ok {
		pclass.drive_eject_button = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_eject_button)
	}

	if _, ok := goval.(interface{ DriveStopButton(drive Driver) }); ok {
		pclass.drive_stop_button = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_drive_stop_button)
	}

	if _, ok := goval.(interface{ ConnectedDrives() []*Drive }); ok {
		pclass.get_connected_drives = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_connected_drives)
	}

	if _, ok := goval.(interface{ MountForUUID(uuid string) *Mount }); ok {
		pclass.get_mount_for_uuid = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_mount_for_uuid)
	}

	if _, ok := goval.(interface{ Mounts() []*Mount }); ok {
		pclass.get_mounts = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_mounts)
	}

	if _, ok := goval.(interface{ VolumeForUUID(uuid string) *Volume }); ok {
		pclass.get_volume_for_uuid = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_volume_for_uuid)
	}

	if _, ok := goval.(interface{ Volumes() []*Volume }); ok {
		pclass.get_volumes = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_get_volumes)
	}

	if _, ok := goval.(interface{ MountAdded(mount Mounter) }); ok {
		pclass.mount_added = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_added)
	}

	if _, ok := goval.(interface{ MountChanged(mount Mounter) }); ok {
		pclass.mount_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_changed)
	}

	if _, ok := goval.(interface{ MountPreUnmount(mount Mounter) }); ok {
		pclass.mount_pre_unmount = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_pre_unmount)
	}

	if _, ok := goval.(interface{ MountRemoved(mount Mounter) }); ok {
		pclass.mount_removed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_mount_removed)
	}

	if _, ok := goval.(interface{ VolumeAdded(volume Volumer) }); ok {
		pclass.volume_added = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_added)
	}

	if _, ok := goval.(interface{ VolumeChanged(volume Volumer) }); ok {
		pclass.volume_changed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_changed)
	}

	if _, ok := goval.(interface{ VolumeRemoved(volume Volumer) }); ok {
		pclass.volume_removed = (*[0]byte)(C._gotk4_gio2_VolumeMonitorClass_volume_removed)
	}
	if goval, ok := goval.(interface{ InitVolumeMonitor(*VolumeMonitorClass) }); ok {
		klass := (*VolumeMonitorClass)(gextras.NewStructNative(gclass))
		goval.InitVolumeMonitor(klass)
	}
}

func finalizeClassVolumeMonitor(gclass unsafe.Pointer, goval any) {
	if goval, ok := goval.(interface{ FinalizeVolumeMonitor(*VolumeMonitorClass) }); ok {
		klass := (*VolumeMonitorClass)(gextras.NewStructNative(gclass))
		goval.FinalizeVolumeMonitor(klass)
	}
}

//export _gotk4_gio2_VolumeMonitorClass_drive_changed
func _gotk4_gio2_VolumeMonitorClass_drive_changed(arg0 *C.GVolumeMonitor, arg1 *C.GDrive) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ DriveChanged(drive Driver) })

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	iface.DriveChanged(_drive)
}

//export _gotk4_gio2_VolumeMonitorClass_drive_connected
func _gotk4_gio2_VolumeMonitorClass_drive_connected(arg0 *C.GVolumeMonitor, arg1 *C.GDrive) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ DriveConnected(drive Driver) })

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	iface.DriveConnected(_drive)
}

//export _gotk4_gio2_VolumeMonitorClass_drive_disconnected
func _gotk4_gio2_VolumeMonitorClass_drive_disconnected(arg0 *C.GVolumeMonitor, arg1 *C.GDrive) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ DriveDisconnected(drive Driver) })

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	iface.DriveDisconnected(_drive)
}

//export _gotk4_gio2_VolumeMonitorClass_drive_eject_button
func _gotk4_gio2_VolumeMonitorClass_drive_eject_button(arg0 *C.GVolumeMonitor, arg1 *C.GDrive) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ DriveEjectButton(drive Driver) })

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	iface.DriveEjectButton(_drive)
}

//export _gotk4_gio2_VolumeMonitorClass_drive_stop_button
func _gotk4_gio2_VolumeMonitorClass_drive_stop_button(arg0 *C.GVolumeMonitor, arg1 *C.GDrive) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ DriveStopButton(drive Driver) })

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	iface.DriveStopButton(_drive)
}

//export _gotk4_gio2_VolumeMonitorClass_get_connected_drives
func _gotk4_gio2_VolumeMonitorClass_get_connected_drives(arg0 *C.GVolumeMonitor) (cret *C.GList) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ ConnectedDrives() []*Drive })

	list := iface.ConnectedDrives()

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GDrive // out
		dst = (*C.GDrive)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}

	return cret
}

//export _gotk4_gio2_VolumeMonitorClass_get_mount_for_uuid
func _gotk4_gio2_VolumeMonitorClass_get_mount_for_uuid(arg0 *C.GVolumeMonitor, arg1 *C.char) (cret *C.GMount) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ MountForUUID(uuid string) *Mount })

	var _uuid string // out

	_uuid = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	mount := iface.MountForUUID(_uuid)

	if mount != nil {
		cret = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(mount).Native()))
	}

	return cret
}

//export _gotk4_gio2_VolumeMonitorClass_get_mounts
func _gotk4_gio2_VolumeMonitorClass_get_mounts(arg0 *C.GVolumeMonitor) (cret *C.GList) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ Mounts() []*Mount })

	list := iface.Mounts()

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GMount // out
		dst = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}

	return cret
}

//export _gotk4_gio2_VolumeMonitorClass_get_volume_for_uuid
func _gotk4_gio2_VolumeMonitorClass_get_volume_for_uuid(arg0 *C.GVolumeMonitor, arg1 *C.char) (cret *C.GVolume) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ VolumeForUUID(uuid string) *Volume })

	var _uuid string // out

	_uuid = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	volume := iface.VolumeForUUID(_uuid)

	if volume != nil {
		cret = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(volume).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(volume).Native()))
	}

	return cret
}

//export _gotk4_gio2_VolumeMonitorClass_get_volumes
func _gotk4_gio2_VolumeMonitorClass_get_volumes(arg0 *C.GVolumeMonitor) (cret *C.GList) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ Volumes() []*Volume })

	list := iface.Volumes()

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GVolume // out
		dst = (*C.GVolume)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(src).Native()))
		cret = C.g_list_prepend(cret, C.gpointer(unsafe.Pointer(dst)))
	}

	return cret
}

//export _gotk4_gio2_VolumeMonitorClass_mount_added
func _gotk4_gio2_VolumeMonitorClass_mount_added(arg0 *C.GVolumeMonitor, arg1 *C.GMount) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ MountAdded(mount Mounter) })

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	iface.MountAdded(_mount)
}

//export _gotk4_gio2_VolumeMonitorClass_mount_changed
func _gotk4_gio2_VolumeMonitorClass_mount_changed(arg0 *C.GVolumeMonitor, arg1 *C.GMount) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ MountChanged(mount Mounter) })

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	iface.MountChanged(_mount)
}

//export _gotk4_gio2_VolumeMonitorClass_mount_pre_unmount
func _gotk4_gio2_VolumeMonitorClass_mount_pre_unmount(arg0 *C.GVolumeMonitor, arg1 *C.GMount) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ MountPreUnmount(mount Mounter) })

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	iface.MountPreUnmount(_mount)
}

//export _gotk4_gio2_VolumeMonitorClass_mount_removed
func _gotk4_gio2_VolumeMonitorClass_mount_removed(arg0 *C.GVolumeMonitor, arg1 *C.GMount) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ MountRemoved(mount Mounter) })

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	iface.MountRemoved(_mount)
}

//export _gotk4_gio2_VolumeMonitorClass_volume_added
func _gotk4_gio2_VolumeMonitorClass_volume_added(arg0 *C.GVolumeMonitor, arg1 *C.GVolume) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ VolumeAdded(volume Volumer) })

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	iface.VolumeAdded(_volume)
}

//export _gotk4_gio2_VolumeMonitorClass_volume_changed
func _gotk4_gio2_VolumeMonitorClass_volume_changed(arg0 *C.GVolumeMonitor, arg1 *C.GVolume) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ VolumeChanged(volume Volumer) })

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	iface.VolumeChanged(_volume)
}

//export _gotk4_gio2_VolumeMonitorClass_volume_removed
func _gotk4_gio2_VolumeMonitorClass_volume_removed(arg0 *C.GVolumeMonitor, arg1 *C.GVolume) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ VolumeRemoved(volume Volumer) })

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	iface.VolumeRemoved(_volume)
}

func wrapVolumeMonitor(obj *coreglib.Object) *VolumeMonitor {
	return &VolumeMonitor{
		Object: obj,
	}
}

func marshalVolumeMonitor(p uintptr) (interface{}, error) {
	return wrapVolumeMonitor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveChanged
func _gotk4_gio2_VolumeMonitor_ConnectDriveChanged(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

// ConnectDriveChanged is emitted when a drive changes.
func (volumeMonitor *VolumeMonitor) ConnectDriveChanged(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveChanged), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveConnected
func _gotk4_gio2_VolumeMonitor_ConnectDriveConnected(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

// ConnectDriveConnected is emitted when a drive is connected to the system.
func (volumeMonitor *VolumeMonitor) ConnectDriveConnected(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-connected", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveConnected), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected
func _gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

// ConnectDriveDisconnected is emitted when a drive is disconnected from the
// system.
func (volumeMonitor *VolumeMonitor) ConnectDriveDisconnected(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-disconnected", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveDisconnected), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton
func _gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

// ConnectDriveEjectButton is emitted when the eject button is pressed on drive.
func (volumeMonitor *VolumeMonitor) ConnectDriveEjectButton(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-eject-button", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveEjectButton), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectDriveStopButton
func _gotk4_gio2_VolumeMonitor_ConnectDriveStopButton(arg0 C.gpointer, arg1 *C.GDrive, arg2 C.guintptr) {
	var f func(drive Driver)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(drive Driver))
	}

	var _drive Driver // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Driver is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Driver)
			return ok
		})
		rv, ok := casted.(Driver)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Driver")
		}
		_drive = rv
	}

	f(_drive)
}

// ConnectDriveStopButton is emitted when the stop button is pressed on drive.
func (volumeMonitor *VolumeMonitor) ConnectDriveStopButton(f func(drive Driver)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "drive-stop-button", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectDriveStopButton), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectMountAdded
func _gotk4_gio2_VolumeMonitor_ConnectMountAdded(arg0 C.gpointer, arg1 *C.GMount, arg2 C.guintptr) {
	var f func(mount Mounter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mount Mounter))
	}

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	f(_mount)
}

// ConnectMountAdded is emitted when a mount is added.
func (volumeMonitor *VolumeMonitor) ConnectMountAdded(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-added", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountAdded), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectMountChanged
func _gotk4_gio2_VolumeMonitor_ConnectMountChanged(arg0 C.gpointer, arg1 *C.GMount, arg2 C.guintptr) {
	var f func(mount Mounter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mount Mounter))
	}

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	f(_mount)
}

// ConnectMountChanged is emitted when a mount changes.
func (volumeMonitor *VolumeMonitor) ConnectMountChanged(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountChanged), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount
func _gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount(arg0 C.gpointer, arg1 *C.GMount, arg2 C.guintptr) {
	var f func(mount Mounter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mount Mounter))
	}

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	f(_mount)
}

// ConnectMountPreUnmount: may be emitted when a mount is about to be removed.
//
// This signal depends on the backend and is only emitted if GIO was used to
// unmount.
func (volumeMonitor *VolumeMonitor) ConnectMountPreUnmount(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-pre-unmount", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountPreUnmount), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectMountRemoved
func _gotk4_gio2_VolumeMonitor_ConnectMountRemoved(arg0 C.gpointer, arg1 *C.GMount, arg2 C.guintptr) {
	var f func(mount Mounter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mount Mounter))
	}

	var _mount Mounter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Mounter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Mounter)
			return ok
		})
		rv, ok := casted.(Mounter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Mounter")
		}
		_mount = rv
	}

	f(_mount)
}

// ConnectMountRemoved is emitted when a mount is removed.
func (volumeMonitor *VolumeMonitor) ConnectMountRemoved(f func(mount Mounter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "mount-removed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectMountRemoved), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectVolumeAdded
func _gotk4_gio2_VolumeMonitor_ConnectVolumeAdded(arg0 C.gpointer, arg1 *C.GVolume, arg2 C.guintptr) {
	var f func(volume Volumer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(volume Volumer))
	}

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	f(_volume)
}

// ConnectVolumeAdded is emitted when a mountable volume is added to the system.
func (volumeMonitor *VolumeMonitor) ConnectVolumeAdded(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-added", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeAdded), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectVolumeChanged
func _gotk4_gio2_VolumeMonitor_ConnectVolumeChanged(arg0 C.gpointer, arg1 *C.GVolume, arg2 C.guintptr) {
	var f func(volume Volumer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(volume Volumer))
	}

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	f(_volume)
}

// ConnectVolumeChanged is emitted when mountable volume is changed.
func (volumeMonitor *VolumeMonitor) ConnectVolumeChanged(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-changed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeChanged), f)
}

//export _gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved
func _gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved(arg0 C.gpointer, arg1 *C.GVolume, arg2 C.guintptr) {
	var f func(volume Volumer)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(volume Volumer))
	}

	var _volume Volumer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gio.Volumer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Volumer)
			return ok
		})
		rv, ok := casted.(Volumer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Volumer")
		}
		_volume = rv
	}

	f(_volume)
}

// ConnectVolumeRemoved is emitted when a mountable volume is removed from the
// system.
func (volumeMonitor *VolumeMonitor) ConnectVolumeRemoved(f func(volume Volumer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(volumeMonitor, "volume-removed", false, unsafe.Pointer(C._gotk4_gio2_VolumeMonitor_ConnectVolumeRemoved), f)
}

// ConnectedDrives gets a list of drives connected to the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of connected #GDrive objects.
//
func (volumeMonitor *VolumeMonitor) ConnectedDrives() []*Drive {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_connected_drives(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Drive // out

	_list = make([]*Drive, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GDrive)(v)
		var dst *Drive // out
		dst = wrapDrive(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// MountForUUID finds a #GMount object by its UUID (see g_mount_get_uuid()).
//
// The function takes the following parameters:
//
//    - uuid: UUID to look for.
//
// The function returns the following values:
//
//    - mount (optional) or NULL if no such mount is available. Free the returned
//      object with g_object_unref().
//
func (volumeMonitor *VolumeMonitor) MountForUUID(uuid string) *Mount {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GMount         // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_mount_for_uuid(_arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _mount *Mount // out

	if _cret != nil {
		_mount = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _mount
}

// Mounts gets a list of the mounts on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of #GMount objects.
//
func (volumeMonitor *VolumeMonitor) Mounts() []*Mount {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_mounts(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Mount // out

	_list = make([]*Mount, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GMount)(v)
		var dst *Mount // out
		dst = wrapMount(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// VolumeForUUID finds a #GVolume object by its UUID (see g_volume_get_uuid()).
//
// The function takes the following parameters:
//
//    - uuid: UUID to look for.
//
// The function returns the following values:
//
//    - volume (optional) or NULL if no such volume is available. Free the
//      returned object with g_object_unref().
//
func (volumeMonitor *VolumeMonitor) VolumeForUUID(uuid string) *Volume {
	var _arg0 *C.GVolumeMonitor // out
	var _arg1 *C.char           // out
	var _cret *C.GVolume        // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_volume_monitor_get_volume_for_uuid(_arg0, _arg1)
	runtime.KeepAlive(volumeMonitor)
	runtime.KeepAlive(uuid)

	var _volume *Volume // out

	if _cret != nil {
		_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _volume
}

// Volumes gets a list of the volumes on the system.
//
// The returned list should be freed with g_list_free(), after its elements have
// been unreffed with g_object_unref().
//
// The function returns the following values:
//
//    - list of #GVolume objects.
//
func (volumeMonitor *VolumeMonitor) Volumes() []*Volume {
	var _arg0 *C.GVolumeMonitor // out
	var _cret *C.GList          // in

	_arg0 = (*C.GVolumeMonitor)(unsafe.Pointer(coreglib.InternObject(volumeMonitor).Native()))

	_cret = C.g_volume_monitor_get_volumes(_arg0)
	runtime.KeepAlive(volumeMonitor)

	var _list []*Volume // out

	_list = make([]*Volume, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GVolume)(v)
		var dst *Volume // out
		dst = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// VolumeMonitorAdoptOrphanMount: this function should be called by any Monitor
// implementation when a new #GMount object is created that is not associated
// with a #GVolume object. It must be called just before emitting the
// mount_added signal.
//
// If the return value is not NULL, the caller must associate the returned
// #GVolume object with the #GMount. This involves returning it in its
// g_mount_get_volume() implementation. The caller must also listen for the
// "removed" signal on the returned object and give up its reference when
// handling that signal
//
// Similarly, if implementing g_volume_monitor_adopt_orphan_mount(), the
// implementor must take a reference to mount and return it in its
// g_volume_get_mount() implemented. Also, the implementor must listen for the
// "unmounted" signal on mount and give up its reference upon handling that
// signal.
//
// There are two main use cases for this function.
//
// One is when implementing a user space file system driver that reads blocks of
// a block device that is already represented by the native volume monitor (for
// example a CD Audio file system driver). Such a driver will generate its own
// #GMount object that needs to be associated with the #GVolume object that
// represents the volume.
//
// The other is for implementing a Monitor whose sole purpose is to return
// #GVolume objects representing entries in the users "favorite servers" list or
// similar.
//
// Deprecated: Instead of using this function, Monitor implementations should
// instead create shadow mounts with the URI of the mount they intend to adopt.
// See the proxy volume monitor in gvfs for an example of this. Also see
// g_mount_is_shadowed(), g_mount_shadow() and g_mount_unshadow() functions.
//
// The function takes the following parameters:
//
//    - mount object to find a parent for.
//
// The function returns the following values:
//
//    - volume object that is the parent for mount or NULL if no wants to adopt
//      the #GMount.
//
func VolumeMonitorAdoptOrphanMount(mount Mounter) *Volume {
	var _arg1 *C.GMount  // out
	var _cret *C.GVolume // in

	_arg1 = (*C.GMount)(unsafe.Pointer(coreglib.InternObject(mount).Native()))

	_cret = C.g_volume_monitor_adopt_orphan_mount(_arg1)
	runtime.KeepAlive(mount)

	var _volume *Volume // out

	_volume = wrapVolume(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _volume
}

// VolumeMonitorGet gets the volume monitor used by gio.
//
// The function returns the following values:
//
//    - volumeMonitor: reference to the Monitor used by gio. Call
//      g_object_unref() when done with it.
//
func VolumeMonitorGet() *VolumeMonitor {
	var _cret *C.GVolumeMonitor // in

	_cret = C.g_volume_monitor_get()

	var _volumeMonitor *VolumeMonitor // out

	_volumeMonitor = wrapVolumeMonitor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _volumeMonitor
}

// VolumeMonitorClass: instance of this type is always passed by reference.
type VolumeMonitorClass struct {
	*volumeMonitorClass
}

// volumeMonitorClass is the struct that's finalized.
type volumeMonitorClass struct {
	native *C.GVolumeMonitorClass
}

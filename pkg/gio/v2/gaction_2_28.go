// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gio/gio.h>
// GVariant* _gotk4_gio2_Action_virtual_get_state(void* fnptr, GAction* arg0) {
//   return ((GVariant* (*)(GAction*))(fnptr))(arg0);
// };
// GVariant* _gotk4_gio2_Action_virtual_get_state_hint(void* fnptr, GAction* arg0) {
//   return ((GVariant* (*)(GAction*))(fnptr))(arg0);
// };
// GVariantType* _gotk4_gio2_Action_virtual_get_parameter_type(void* fnptr, GAction* arg0) {
//   return ((GVariantType* (*)(GAction*))(fnptr))(arg0);
// };
// GVariantType* _gotk4_gio2_Action_virtual_get_state_type(void* fnptr, GAction* arg0) {
//   return ((GVariantType* (*)(GAction*))(fnptr))(arg0);
// };
// gboolean _gotk4_gio2_Action_virtual_get_enabled(void* fnptr, GAction* arg0) {
//   return ((gboolean (*)(GAction*))(fnptr))(arg0);
// };
// gchar* _gotk4_gio2_Action_virtual_get_name(void* fnptr, GAction* arg0) {
//   return ((gchar* (*)(GAction*))(fnptr))(arg0);
// };
// void _gotk4_gio2_Action_virtual_activate(void* fnptr, GAction* arg0, GVariant* arg1) {
//   ((void (*)(GAction*, GVariant*))(fnptr))(arg0, arg1);
// };
import "C"

// Activate activates the action.
//
// parameter must be the correct type of parameter for the action (ie: the
// parameter type given at construction time). If the parameter type was NULL
// then parameter must also be NULL.
//
// If the parameter GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//    - parameter (optional) to the activation.
//
func (action *Action) Activate(parameter *glib.Variant) {
	var _arg0 *C.GAction  // out
	var _arg1 *C.GVariant // out

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if parameter != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}

	C.g_action_activate(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(parameter)
}

// Enabled checks if action is currently enabled.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// The function returns the following values:
//
//    - ok: whether the action is enabled.
//
func (action *Action) Enabled() bool {
	var _arg0 *C.GAction // out
	var _cret C.gboolean // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_enabled(_arg0)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name queries the name of action.
//
// The function returns the following values:
//
//    - utf8: name of the action.
//
func (action *Action) Name() string {
	var _arg0 *C.GAction // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_name(_arg0)
	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ParameterType queries the type of the parameter that must be given when
// activating action.
//
// When activating the action using g_action_activate(), the #GVariant given to
// that function must be of the type returned by this function.
//
// In the case that this function returns NULL, you must not give any #GVariant,
// but NULL instead.
//
// The function returns the following values:
//
//    - variantType (optional): parameter type.
//
func (action *Action) ParameterType() *glib.VariantType {
	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_parameter_type(_arg0)
	runtime.KeepAlive(action)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// State queries the current state of action.
//
// If the action is not stateful then NULL will be returned. If the action is
// stateful then the type of the return value is the type given by
// g_action_get_state_type().
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function returns the following values:
//
//    - variant (optional): current state of the action.
//
func (action *Action) State() *glib.Variant {
	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_state(_arg0)
	runtime.KeepAlive(action)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// StateHint requests a hint about the valid range of values for the state of
// action.
//
// If NULL is returned it either means that the action is not stateful or that
// there is no hint about the valid range of values for the state of the action.
//
// If a #GVariant array is returned then each item in the array is a possible
// value for the state. If a #GVariant pair (ie: two-tuple) is returned then the
// tuple specifies the inclusive lower and upper bound of valid values for the
// state.
//
// In any case, the information is merely a hint. It may be possible to have a
// state value outside of the hinted range and setting a value within the range
// may fail.
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function returns the following values:
//
//    - variant (optional): state range hint.
//
func (action *Action) StateHint() *glib.Variant {
	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_state_hint(_arg0)
	runtime.KeepAlive(action)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// StateType queries the type of the state of action.
//
// If the action is stateful (e.g. created with g_simple_action_new_stateful())
// then this function returns the Type of the state. This is the type of the
// initial value given as the state. All calls to g_action_change_state() must
// give a #GVariant of this type and g_action_get_state() will return a
// #GVariant of the same type.
//
// If the action is not stateful (e.g. created with g_simple_action_new()) then
// this function will return NULL. In that case, g_action_get_state() will
// return NULL and you must not call g_action_change_state().
//
// The function returns the following values:
//
//    - variantType (optional): state type, if the action is stateful.
//
func (action *Action) StateType() *glib.VariantType {
	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.g_action_get_state_type(_arg0)
	runtime.KeepAlive(action)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// Activate activates the action.
//
// parameter must be the correct type of parameter for the action (ie: the
// parameter type given at construction time). If the parameter type was NULL
// then parameter must also be NULL.
//
// If the parameter GVariant is floating, it is consumed.
//
// The function takes the following parameters:
//
//    - parameter (optional) to the activation.
//
func (action *Action) activate(parameter *glib.Variant) {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.activate

	var _arg0 *C.GAction  // out
	var _arg1 *C.GVariant // out

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if parameter != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}

	C._gotk4_gio2_Action_virtual_activate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(parameter)
}

// Enabled checks if action is currently enabled.
//
// An action must be enabled in order to be activated or in order to have its
// state changed from outside callers.
//
// The function returns the following values:
//
//    - ok: whether the action is enabled.
//
func (action *Action) enabled() bool {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_enabled

	var _arg0 *C.GAction // out
	var _cret C.gboolean // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_enabled(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name queries the name of action.
//
// The function returns the following values:
//
//    - utf8: name of the action.
//
func (action *Action) name() string {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_name

	var _arg0 *C.GAction // out
	var _cret *C.gchar   // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// parameterType queries the type of the parameter that must be given when
// activating action.
//
// When activating the action using g_action_activate(), the #GVariant given to
// that function must be of the type returned by this function.
//
// In the case that this function returns NULL, you must not give any #GVariant,
// but NULL instead.
//
// The function returns the following values:
//
//    - variantType (optional): parameter type.
//
func (action *Action) parameterType() *glib.VariantType {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_parameter_type

	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_parameter_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// State queries the current state of action.
//
// If the action is not stateful then NULL will be returned. If the action is
// stateful then the type of the return value is the type given by
// g_action_get_state_type().
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function returns the following values:
//
//    - variant (optional): current state of the action.
//
func (action *Action) state() *glib.Variant {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_state

	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_state(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// stateHint requests a hint about the valid range of values for the state of
// action.
//
// If NULL is returned it either means that the action is not stateful or that
// there is no hint about the valid range of values for the state of the action.
//
// If a #GVariant array is returned then each item in the array is a possible
// value for the state. If a #GVariant pair (ie: two-tuple) is returned then the
// tuple specifies the inclusive lower and upper bound of valid values for the
// state.
//
// In any case, the information is merely a hint. It may be possible to have a
// state value outside of the hinted range and setting a value within the range
// may fail.
//
// The return value (if non-NULL) should be freed with g_variant_unref() when it
// is no longer required.
//
// The function returns the following values:
//
//    - variant (optional): state range hint.
//
func (action *Action) stateHint() *glib.Variant {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_state_hint

	var _arg0 *C.GAction  // out
	var _cret *C.GVariant // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_state_hint(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// stateType queries the type of the state of action.
//
// If the action is stateful (e.g. created with g_simple_action_new_stateful())
// then this function returns the Type of the state. This is the type of the
// initial value given as the state. All calls to g_action_change_state() must
// give a #GVariant of this type and g_action_get_state() will return a
// #GVariant of the same type.
//
// If the action is not stateful (e.g. created with g_simple_action_new()) then
// this function will return NULL. In that case, g_action_get_state() will
// return NULL and you must not call g_action_change_state().
//
// The function returns the following values:
//
//    - variantType (optional): state type, if the action is stateful.
//
func (action *Action) stateType() *glib.VariantType {
	gclass := (*C.GActionInterface)(coreglib.PeekParentClass(action))
	fnarg := gclass.get_state_type

	var _arg0 *C.GAction      // out
	var _cret *C.GVariantType // in

	_arg0 = (*C.GAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gio2_Action_virtual_get_state_type(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _variantType *glib.VariantType // out

	if _cret != nil {
		_variantType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _variantType
}

// ActionInterface: virtual function table for #GAction.
//
// An instance of this type is always passed by reference.
type ActionInterface struct {
	*actionInterface
}

// actionInterface is the struct that's finalized.
type actionInterface struct {
	native *C.GActionInterface
}

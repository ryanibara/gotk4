// Code generated by girgen. DO NOT EDIT.

package gio

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gio/gio.h>
import "C"

// Disconnect disconnects a handler from a cancellable instance similar to
// g_signal_handler_disconnect(). Additionally, in the event that a signal
// handler is currently running, this call will block until the handler has
// finished. Calling this function from a #GCancellable::cancelled signal
// handler will therefore result in a deadlock.
//
// This avoids a race condition where a thread cancels at the same time as the
// cancellable operation is finished and the signal handler is removed. See
// #GCancellable::cancelled for details on how to use this.
//
// If cancellable is NULL or handler_id is 0 this function does nothing.
//
// The function takes the following parameters:
//
//    - handlerId: handler id of the handler to be disconnected, or 0.
//
func (cancellable *Cancellable) Disconnect(handlerId uint32) {
	var _arg0 *C.GCancellable // out
	var _arg1 C.gulong        // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}
	_arg1 = C.gulong(handlerId)

	C.g_cancellable_disconnect(_arg0, _arg1)
	runtime.KeepAlive(cancellable)
	runtime.KeepAlive(handlerId)
}

// ReleaseFd releases a resources previously allocated by g_cancellable_get_fd()
// or g_cancellable_make_pollfd().
//
// For compatibility reasons with older releases, calling this function is not
// strictly required, the resources will be automatically freed when the
// cancellable is finalized. However, the cancellable will block scarce file
// descriptors until it is finalized if this function is not called. This can
// cause the application to run out of file descriptors when many #GCancellables
// are used at the same time.
func (cancellable *Cancellable) ReleaseFd() {
	var _arg0 *C.GCancellable // out

	if cancellable != nil {
		_arg0 = (*C.GCancellable)(unsafe.Pointer(coreglib.InternObject(cancellable).Native()))
	}

	C.g_cancellable_release_fd(_arg0)
	runtime.KeepAlive(cancellable)
}

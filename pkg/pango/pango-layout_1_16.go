// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <pango/pango.h>
import "C"

// LineReadonly retrieves a particular line from a PangoLayout.
//
// This is a faster alternative to pango.Layout.GetLine(), but the user is not
// expected to modify the contents of the line (glyphs, glyph widths, etc.).
//
// The function takes the following parameters:
//
//    - line: index of a line, which must be between 0 and
//      pango_layout_get_line_count(layout) - 1, inclusive.
//
// The function returns the following values:
//
//    - layoutLine (optional): requested PangoLayoutLine, or NULL if the index is
//      out of range. This layout line can be ref'ed and retained, but will
//      become invalid if changes are made to the PangoLayout. No changes should
//      be made to the line.
//
func (layout *Layout) LineReadonly(line int) *LayoutLine {
	var _arg0 *C.PangoLayout     // out
	var _arg1 C.int              // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = C.int(line)

	_cret = C.pango_layout_get_line_readonly(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(line)

	var _layoutLine *LayoutLine // out

	if _cret != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
	}

	return _layoutLine
}

// LinesReadonly returns the lines of the layout as a list.
//
// This is a faster alternative to pango.Layout.GetLines(), but the user is not
// expected to modify the contents of the lines (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//    - sList: GSList containing the lines in the layout. This points to internal
//      data of the PangoLayout and must be used with care. It will become
//      invalid on any change to the layout's text or properties. No changes
//      should be made to the lines.
//
func (layout *Layout) LinesReadonly() []*LayoutLine {
	var _arg0 *C.PangoLayout // out
	var _cret *C.GSList      // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_lines_readonly(_arg0)
	runtime.KeepAlive(layout)

	var _sList []*LayoutLine // out

	_sList = make([]*LayoutLine, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.PangoLayoutLine)(v)
		var dst *LayoutLine // out
		dst = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(src)))
		C.pango_layout_line_ref(src)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// UnknownGlyphsCount counts the number of unknown glyphs in layout.
//
// This function can be used to determine if there are any fonts available to
// render all characters in a certain string, or when used in combination with
// PANGO_ATTR_FALLBACK, to check if a certain font supports all the characters
// in the string.
//
// The function returns the following values:
//
//    - gint: number of unknown glyphs in layout.
//
func (layout *Layout) UnknownGlyphsCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_get_unknown_glyphs_count(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsEllipsized queries whether the layout had to ellipsize any paragraphs.
//
// This returns TRUE if the ellipsization mode for layout is not
// PANGO_ELLIPSIZE_NONE, a positive width is set on layout, and there are
// paragraphs exceeding that width that have to be ellipsized.
//
// The function returns the following values:
//
//    - ok: TRUE if any paragraphs had to be ellipsized, FALSE otherwise.
//
func (layout *Layout) IsEllipsized() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_is_ellipsized(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsWrapped queries whether the layout had to wrap any paragraphs.
//
// This returns TRUE if a positive width is set on layout, ellipsization mode of
// layout is set to PANGO_ELLIPSIZE_NONE, and there are paragraphs exceeding the
// layout width that have to be wrapped.
//
// The function returns the following values:
//
//    - ok: TRUE if any paragraphs had to be wrapped, FALSE otherwise.
//
func (layout *Layout) IsWrapped() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.pango_layout_is_wrapped(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

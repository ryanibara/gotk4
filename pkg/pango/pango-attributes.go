// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gboolean _gotk4_pango1_AttrFilterFunc(void*, gpointer);
import "C"

// GTypeAttrType returns the GType for the type AttrType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeAttrType() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "AttrType").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalAttrType)
	return gtype
}

// GTypeOverline returns the GType for the type Overline.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeOverline() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Overline").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalOverline)
	return gtype
}

// GTypeUnderline returns the GType for the type Underline.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeUnderline() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Underline").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalUnderline)
	return gtype
}

// GTypeShowFlags returns the GType for the type ShowFlags.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeShowFlags() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "ShowFlags").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalShowFlags)
	return gtype
}

// GTypeAttrIterator returns the GType for the type AttrIterator.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeAttrIterator() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "AttrIterator").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalAttrIterator)
	return gtype
}

// GTypeAttrList returns the GType for the type AttrList.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeAttrList() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "AttrList").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalAttrList)
	return gtype
}

// GTypeAttribute returns the GType for the type Attribute.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeAttribute() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Attribute").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalAttribute)
	return gtype
}

// GTypeColor returns the GType for the type Color.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeColor() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Color").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalColor)
	return gtype
}

// ATTR_INDEX_FROM_TEXT_BEGINNING: value for start_index in PangoAttribute that
// indicates the beginning of the text.
const ATTR_INDEX_FROM_TEXT_BEGINNING = 0

// ATTR_INDEX_TO_TEXT_END: value for end_index in PangoAttribute that indicates
// the end of the text.
const ATTR_INDEX_TO_TEXT_END = 4294967295

// AttrType: PangoAttrType distinguishes between different types of attributes.
//
// Along with the predefined values, it is possible to allocate additional
// values for custom attributes using attr_type_register. The predefined values
// are given below. The type of structure used to store the attribute is listed
// in parentheses after the description.
type AttrType C.gint

const (
	// AttrTypeInvalid does not happen.
	AttrTypeInvalid AttrType = iota
	// AttrTypeLanguage: language (pango.AttrLanguage).
	AttrTypeLanguage
	// AttrTypeFamily: font family name list (pango.AttrString).
	AttrTypeFamily
	// AttrTypeStyle: font slant style (pango.AttrInt).
	AttrTypeStyle
	// AttrTypeWeight: font weight (pango.AttrInt).
	AttrTypeWeight
	// AttrTypeVariant: font variant (normal or small caps) (pango.AttrInt).
	AttrTypeVariant
	// AttrTypeStretch: font stretch (pango.AttrInt).
	AttrTypeStretch
	// AttrTypeSize: font size in points scaled by PANGO_SCALE (pango.AttrInt).
	AttrTypeSize
	// AttrTypeFontDesc: font description (pango.AttrFontDesc).
	AttrTypeFontDesc
	// AttrTypeForeground: foreground color (pango.AttrColor).
	AttrTypeForeground
	// AttrTypeBackground: background color (pango.AttrColor).
	AttrTypeBackground
	// AttrTypeUnderline: whether the text has an underline (pango.AttrInt).
	AttrTypeUnderline
	// AttrTypeStrikethrough: whether the text is struck-through
	// (pango.AttrInt).
	AttrTypeStrikethrough
	// AttrTypeRise: baseline displacement (pango.AttrInt).
	AttrTypeRise
	// AttrTypeShape: shape (pango.AttrShape).
	AttrTypeShape
	// AttrTypeScale: font size scale factor (pango.AttrFloat).
	AttrTypeScale
	// AttrTypeFallback: whether fallback is enabled (pango.AttrInt).
	AttrTypeFallback
	// AttrTypeLetterSpacing: letter spacing (pangoattrint).
	AttrTypeLetterSpacing
	// AttrTypeUnderlineColor: underline color (pango.AttrColor).
	AttrTypeUnderlineColor
	// AttrTypeStrikethroughColor: strikethrough color (pango.AttrColor).
	AttrTypeStrikethroughColor
	// AttrTypeAbsoluteSize: font size in pixels scaled by PANGO_SCALE
	// (pango.AttrInt).
	AttrTypeAbsoluteSize
	// AttrTypeGravity: base text gravity (pango.AttrInt).
	AttrTypeGravity
	// AttrTypeGravityHint: gravity hint (pango.AttrInt).
	AttrTypeGravityHint
	// AttrTypeFontFeatures: openType font features (pango.AttrString). Since
	// 1.38.
	AttrTypeFontFeatures
	// AttrTypeForegroundAlpha: foreground alpha (pango.AttrInt). Since 1.38.
	AttrTypeForegroundAlpha
	// AttrTypeBackgroundAlpha: background alpha (pango.AttrInt). Since 1.38.
	AttrTypeBackgroundAlpha
	// AttrTypeAllowBreaks: whether breaks are allowed (pango.AttrInt). Since
	// 1.44.
	AttrTypeAllowBreaks
	// AttrTypeShow: how to render invisible characters (pango.AttrInt). Since
	// 1.44.
	AttrTypeShow
	// AttrTypeInsertHyphens: whether to insert hyphens at intra-word line
	// breaks (pango.AttrInt). Since 1.44.
	AttrTypeInsertHyphens
	// AttrTypeOverline: whether the text has an overline (pango.AttrInt). Since
	// 1.46.
	AttrTypeOverline
	// AttrTypeOverlineColor: overline color (pango.AttrColor). Since 1.46.
	AttrTypeOverlineColor
)

func marshalAttrType(p uintptr) (interface{}, error) {
	return AttrType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AttrType.
func (a AttrType) String() string {
	switch a {
	case AttrTypeInvalid:
		return "Invalid"
	case AttrTypeLanguage:
		return "Language"
	case AttrTypeFamily:
		return "Family"
	case AttrTypeStyle:
		return "Style"
	case AttrTypeWeight:
		return "Weight"
	case AttrTypeVariant:
		return "Variant"
	case AttrTypeStretch:
		return "Stretch"
	case AttrTypeSize:
		return "Size"
	case AttrTypeFontDesc:
		return "FontDesc"
	case AttrTypeForeground:
		return "Foreground"
	case AttrTypeBackground:
		return "Background"
	case AttrTypeUnderline:
		return "Underline"
	case AttrTypeStrikethrough:
		return "Strikethrough"
	case AttrTypeRise:
		return "Rise"
	case AttrTypeShape:
		return "Shape"
	case AttrTypeScale:
		return "Scale"
	case AttrTypeFallback:
		return "Fallback"
	case AttrTypeLetterSpacing:
		return "LetterSpacing"
	case AttrTypeUnderlineColor:
		return "UnderlineColor"
	case AttrTypeStrikethroughColor:
		return "StrikethroughColor"
	case AttrTypeAbsoluteSize:
		return "AbsoluteSize"
	case AttrTypeGravity:
		return "Gravity"
	case AttrTypeGravityHint:
		return "GravityHint"
	case AttrTypeFontFeatures:
		return "FontFeatures"
	case AttrTypeForegroundAlpha:
		return "ForegroundAlpha"
	case AttrTypeBackgroundAlpha:
		return "BackgroundAlpha"
	case AttrTypeAllowBreaks:
		return "AllowBreaks"
	case AttrTypeShow:
		return "Show"
	case AttrTypeInsertHyphens:
		return "InsertHyphens"
	case AttrTypeOverline:
		return "Overline"
	case AttrTypeOverlineColor:
		return "OverlineColor"
	default:
		return fmt.Sprintf("AttrType(%d)", a)
	}
}

// Overline: PangoOverline enumeration is used to specify whether text should be
// overlined, and if so, the type of line.
type Overline C.gint

const (
	// OverlineNone: no overline should be drawn.
	OverlineNone Overline = iota
	// OverlineSingle: draw a single line above the ink extents of the text
	// being underlined.
	OverlineSingle
)

func marshalOverline(p uintptr) (interface{}, error) {
	return Overline(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Overline.
func (o Overline) String() string {
	switch o {
	case OverlineNone:
		return "None"
	case OverlineSingle:
		return "Single"
	default:
		return fmt.Sprintf("Overline(%d)", o)
	}
}

// Underline: PangoUnderline enumeration is used to specify whether text should
// be underlined, and if so, the type of underlining.
type Underline C.gint

const (
	// UnderlineNone: no underline should be drawn.
	UnderlineNone Underline = iota
	// UnderlineSingle: single underline should be drawn.
	UnderlineSingle
	// UnderlineDouble: double underline should be drawn.
	UnderlineDouble
	// UnderlineLow: single underline should be drawn at a position beneath the
	// ink extents of the text being underlined. This should be used only for
	// underlining single characters, such as for keyboard accelerators.
	// PANGO_UNDERLINE_SINGLE should be used for extended portions of text.
	UnderlineLow
	// UnderlineError: wavy underline should be drawn below. This underline is
	// typically used to indicate an error such as a possible mispelling; in
	// some cases a contrasting color may automatically be used. This type of
	// underlining is available since Pango 1.4.
	UnderlineError
	// UnderlineSingleLine: like PANGO_UNDERLINE_SINGLE, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineSingleLine
	// UnderlineDoubleLine: like PANGO_UNDERLINE_DOUBLE, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineDoubleLine
	// UnderlineErrorLine: like PANGO_UNDERLINE_ERROR, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineErrorLine
)

func marshalUnderline(p uintptr) (interface{}, error) {
	return Underline(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Underline.
func (u Underline) String() string {
	switch u {
	case UnderlineNone:
		return "None"
	case UnderlineSingle:
		return "Single"
	case UnderlineDouble:
		return "Double"
	case UnderlineLow:
		return "Low"
	case UnderlineError:
		return "Error"
	case UnderlineSingleLine:
		return "SingleLine"
	case UnderlineDoubleLine:
		return "DoubleLine"
	case UnderlineErrorLine:
		return "ErrorLine"
	default:
		return fmt.Sprintf("Underline(%d)", u)
	}
}

// ShowFlags: these flags affect how Pango treats characters that are normally
// not visible in the output.
type ShowFlags C.guint

const (
	// ShowNone: no special treatment for invisible characters.
	ShowNone ShowFlags = 0b0
	// ShowSpaces: render spaces, tabs and newlines visibly.
	ShowSpaces ShowFlags = 0b1
	// ShowLineBreaks: render line breaks visibly.
	ShowLineBreaks ShowFlags = 0b10
	// ShowIgnorables: render default-ignorable Unicode characters visibly.
	ShowIgnorables ShowFlags = 0b100
)

func marshalShowFlags(p uintptr) (interface{}, error) {
	return ShowFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ShowFlags.
func (s ShowFlags) String() string {
	if s == 0 {
		return "ShowFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(49)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case ShowNone:
			builder.WriteString("None|")
		case ShowSpaces:
			builder.WriteString("Spaces|")
		case ShowLineBreaks:
			builder.WriteString("LineBreaks|")
		case ShowIgnorables:
			builder.WriteString("Ignorables|")
		default:
			builder.WriteString(fmt.Sprintf("ShowFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s ShowFlags) Has(other ShowFlags) bool {
	return (s & other) == other
}

// AttrDataCopyFunc: type of a function that can duplicate user data for an
// attribute.
type AttrDataCopyFunc func() (gpointer unsafe.Pointer)

//export _gotk4_pango1_AttrDataCopyFunc
func _gotk4_pango1_AttrDataCopyFunc(arg1 C.gpointer) (cret C.gpointer) {
	var fn AttrDataCopyFunc
	{
		v := gbox.Get(uintptr(arg1))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(AttrDataCopyFunc)
	}

	gpointer := fn()

	cret = (C.gpointer)(unsafe.Pointer(gpointer))

	return cret
}

// AttrFilterFunc: type of a function filtering a list of attributes.
type AttrFilterFunc func(attribute *Attribute) (ok bool)

//export _gotk4_pango1_AttrFilterFunc
func _gotk4_pango1_AttrFilterFunc(arg1 *C.void, arg2 C.gpointer) (cret C.gboolean) {
	var fn AttrFilterFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(AttrFilterFunc)
	}

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := fn(_attribute)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// NewAttrAllowBreaks: create a new allow-breaks attribute.
//
// If breaks are disabled, the range will be kept in a single run, as far as
// possible.
//
// The function takes the following parameters:
//
//    - allowBreaks: TRUE if we line breaks are allowed.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrAllowBreaks(allowBreaks bool) *Attribute {
	var _args [1]girepository.Argument

	if allowBreaks {
		*(*C.gboolean)(unsafe.Pointer(&_args[0])) = C.TRUE
	}

	_gret := girepository.MustFind("Pango", "attr_allow_breaks_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(allowBreaks)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrBackgroundAlpha: create a new background alpha attribute.
//
// The function takes the following parameters:
//
//    - alpha value, between 1 and 65536.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrBackgroundAlpha(alpha uint16) *Attribute {
	var _args [1]girepository.Argument

	*(*C.guint16)(unsafe.Pointer(&_args[0])) = C.guint16(alpha)

	_gret := girepository.MustFind("Pango", "attr_background_alpha_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(alpha)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrBackground: create a new background color attribute.
//
// The function takes the following parameters:
//
//    - red value (ranging from 0 to 65535).
//    - green value.
//    - blue value.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrBackground(red, green, blue uint16) *Attribute {
	var _args [3]girepository.Argument

	*(*C.guint16)(unsafe.Pointer(&_args[0])) = C.guint16(red)
	*(*C.guint16)(unsafe.Pointer(&_args[1])) = C.guint16(green)
	*(*C.guint16)(unsafe.Pointer(&_args[2])) = C.guint16(blue)

	_gret := girepository.MustFind("Pango", "attr_background_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrFallback: create a new font fallback attribute.
//
// If fallback is disabled, characters will only be used from the closest
// matching font on the system. No fallback will be done to other fonts on the
// system that might contain the characters in the text.
//
// The function takes the following parameters:
//
//    - enableFallback: TRUE if we should fall back on other fonts for characters
//      the active font is missing.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrFallback(enableFallback bool) *Attribute {
	var _args [1]girepository.Argument

	if enableFallback {
		*(*C.gboolean)(unsafe.Pointer(&_args[0])) = C.TRUE
	}

	_gret := girepository.MustFind("Pango", "attr_fallback_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(enableFallback)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrFamily: create a new font family attribute.
//
// The function takes the following parameters:
//
//    - family or comma separated list of families.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrFamily(family string) *Attribute {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(family)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Pango", "attr_family_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(family)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrForegroundAlpha: create a new foreground alpha attribute.
//
// The function takes the following parameters:
//
//    - alpha value, between 1 and 65536.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrForegroundAlpha(alpha uint16) *Attribute {
	var _args [1]girepository.Argument

	*(*C.guint16)(unsafe.Pointer(&_args[0])) = C.guint16(alpha)

	_gret := girepository.MustFind("Pango", "attr_foreground_alpha_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(alpha)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrForeground: create a new foreground color attribute.
//
// The function takes the following parameters:
//
//    - red value (ranging from 0 to 65535).
//    - green value.
//    - blue value.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrForeground(red, green, blue uint16) *Attribute {
	var _args [3]girepository.Argument

	*(*C.guint16)(unsafe.Pointer(&_args[0])) = C.guint16(red)
	*(*C.guint16)(unsafe.Pointer(&_args[1])) = C.guint16(green)
	*(*C.guint16)(unsafe.Pointer(&_args[2])) = C.guint16(blue)

	_gret := girepository.MustFind("Pango", "attr_foreground_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrInsertHyphens: create a new insert-hyphens attribute.
//
// Pango will insert hyphens when breaking lines in the middle of a word. This
// attribute can be used to suppress the hyphen.
//
// The function takes the following parameters:
//
//    - insertHyphens: TRUE if hyphens should be inserted.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrInsertHyphens(insertHyphens bool) *Attribute {
	var _args [1]girepository.Argument

	if insertHyphens {
		*(*C.gboolean)(unsafe.Pointer(&_args[0])) = C.TRUE
	}

	_gret := girepository.MustFind("Pango", "attr_insert_hyphens_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(insertHyphens)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrLetterSpacing: create a new letter-spacing attribute.
//
// The function takes the following parameters:
//
//    - letterSpacing: amount of extra space to add between graphemes of the
//      text, in Pango units.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrLetterSpacing(letterSpacing int32) *Attribute {
	var _args [1]girepository.Argument

	*(*C.int)(unsafe.Pointer(&_args[0])) = C.int(letterSpacing)

	_gret := girepository.MustFind("Pango", "attr_letter_spacing_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(letterSpacing)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrOverlineColor: create a new overline color attribute.
//
// This attribute modifies the color of overlines. If not set, overlines will
// use the foreground color.
//
// The function takes the following parameters:
//
//    - red value (ranging from 0 to 65535).
//    - green value.
//    - blue value.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrOverlineColor(red, green, blue uint16) *Attribute {
	var _args [3]girepository.Argument

	*(*C.guint16)(unsafe.Pointer(&_args[0])) = C.guint16(red)
	*(*C.guint16)(unsafe.Pointer(&_args[1])) = C.guint16(green)
	*(*C.guint16)(unsafe.Pointer(&_args[2])) = C.guint16(blue)

	_gret := girepository.MustFind("Pango", "attr_overline_color_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrRise: create a new baseline displacement attribute.
//
// The function takes the following parameters:
//
//    - rise: amount that the text should be displaced vertically, in Pango
//      units. Positive values displace the text upwards.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrRise(rise int32) *Attribute {
	var _args [1]girepository.Argument

	*(*C.int)(unsafe.Pointer(&_args[0])) = C.int(rise)

	_gret := girepository.MustFind("Pango", "attr_rise_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(rise)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrScale: create a new font size scale attribute.
//
// The base font for the affected text will have its size multiplied by
// scale_factor.
//
// The function takes the following parameters:
//
//    - scaleFactor: factor to scale the font.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrScale(scaleFactor float64) *Attribute {
	var _args [1]girepository.Argument

	*(*C.double)(unsafe.Pointer(&_args[0])) = C.double(scaleFactor)

	_gret := girepository.MustFind("Pango", "attr_scale_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scaleFactor)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrStrikethroughColor: create a new strikethrough color attribute.
//
// This attribute modifies the color of strikethrough lines. If not set,
// strikethrough lines will use the foreground color.
//
// The function takes the following parameters:
//
//    - red value (ranging from 0 to 65535).
//    - green value.
//    - blue value.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrStrikethroughColor(red, green, blue uint16) *Attribute {
	var _args [3]girepository.Argument

	*(*C.guint16)(unsafe.Pointer(&_args[0])) = C.guint16(red)
	*(*C.guint16)(unsafe.Pointer(&_args[1])) = C.guint16(green)
	*(*C.guint16)(unsafe.Pointer(&_args[2])) = C.guint16(blue)

	_gret := girepository.MustFind("Pango", "attr_strikethrough_color_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrStrikethrough: create a new strike-through attribute.
//
// The function takes the following parameters:
//
//    - strikethrough: TRUE if the text should be struck-through.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrStrikethrough(strikethrough bool) *Attribute {
	var _args [1]girepository.Argument

	if strikethrough {
		*(*C.gboolean)(unsafe.Pointer(&_args[0])) = C.TRUE
	}

	_gret := girepository.MustFind("Pango", "attr_strikethrough_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(strikethrough)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrUnderlineColor: create a new underline color attribute.
//
// This attribute modifies the color of underlines. If not set, underlines will
// use the foreground color.
//
// The function takes the following parameters:
//
//    - red value (ranging from 0 to 65535).
//    - green value.
//    - blue value.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrUnderlineColor(red, green, blue uint16) *Attribute {
	var _args [3]girepository.Argument

	*(*C.guint16)(unsafe.Pointer(&_args[0])) = C.guint16(red)
	*(*C.guint16)(unsafe.Pointer(&_args[1])) = C.guint16(green)
	*(*C.guint16)(unsafe.Pointer(&_args[2])) = C.guint16(blue)

	_gret := girepository.MustFind("Pango", "attr_underline_color_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(red)
	runtime.KeepAlive(green)
	runtime.KeepAlive(blue)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// MarkupParserFinish finishes parsing markup.
//
// After feeding a Pango markup parser some data with
// g_markup_parse_context_parse(), use this function to get the list of
// attributes and text out of the markup. This function will not free context,
// use g_markup_parse_context_free() to do so.
//
// The function takes the following parameters:
//
//    - context: valid parse context that was returned from markup_parser_new.
//
// The function returns the following values:
//
//    - attrList (optional) address of return location for a PangoAttrList, or
//      NULL.
//    - text (optional) address of return location for text with tags stripped,
//      or NULL.
//    - accelChar (optional) address of return location for accelerator char, or
//      NULL.
//
func MarkupParserFinish(context *glib.MarkupParseContext) (*AttrList, string, uint32, error) {
	var _args [1]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(context)))

	girepository.MustFind("Pango", "markup_parser_finish").Invoke(_args[:], _outs[:])

	runtime.KeepAlive(context)

	var _attrList *AttrList // out
	var _text string        // out
	var _accelChar uint32   // out
	var _goerr error        // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(_outs[1])))
		defer C.free(unsafe.Pointer(_outs[1]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[2])) != nil {
		_accelChar = *(*uint32)(unsafe.Pointer(_outs[2]))
	}
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _attrList, _text, _accelChar, _goerr
}

// NewMarkupParser: incrementally parses marked-up text to create a plain-text
// string and an attribute list.
//
// See the Pango Markup (pango_markup.html) docs for details about the supported
// markup.
//
// If accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in accel_char, when calling markup_parser_finish. Two accel_marker
// characters following each other produce a single literal accel_marker
// character.
//
// To feed markup to the parser, use g_markup_parse_context_parse() on the
// returned GMarkupParseContext. When done with feeding markup to the parser,
// use markup_parser_finish to get the data out of it, and then use
// g_markup_parse_context_free() to free it.
//
// This function is designed for applications that read Pango markup from
// streams. To simply parse a string containing Pango markup, the parse_markup
// API is recommended instead.
//
// The function takes the following parameters:
//
//    - accelMarker: character that precedes an accelerator, or 0 for none.
//
// The function returns the following values:
//
//    - markupParseContext: GMarkupParseContext that should be destroyed with
//      g_markup_parse_context_free().
//
func NewMarkupParser(accelMarker uint32) *glib.MarkupParseContext {
	var _args [1]girepository.Argument

	*(*C.gunichar)(unsafe.Pointer(&_args[0])) = C.gunichar(accelMarker)

	_gret := girepository.MustFind("Pango", "markup_parser_new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accelMarker)

	var _markupParseContext *glib.MarkupParseContext // out

	_markupParseContext = (*glib.MarkupParseContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_markup_parse_context_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_markupParseContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("GLib", "MarkupParseContext").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _markupParseContext
}

// ParseMarkup parses marked-up text to create a plain-text string and an
// attribute list.
//
// See the Pango Markup (pango_markup.html) docs for details about the supported
// markup.
//
// If accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in accel_char. Two accel_marker characters following each other
// produce a single literal accel_marker character.
//
// To parse a stream of pango markup incrementally, use markup_parser_new.
//
// If any error happens, none of the output arguments are touched except for
// error.
//
// The function takes the following parameters:
//
//    - markupText: markup to parse (see the Pango Markup docs).
//    - length of markup_text, or -1 if nul-terminated.
//    - accelMarker: character that precedes an accelerator, or 0 for none.
//
// The function returns the following values:
//
//    - attrList (optional) address of return location for a PangoAttrList, or
//      NULL.
//    - text (optional) address of return location for text with tags stripped,
//      or NULL.
//    - accelChar (optional) address of return location for accelerator char, or
//      NULL.
//
func ParseMarkup(markupText string, length int32, accelMarker uint32) (*AttrList, string, uint32, error) {
	var _args [3]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(markupText)))
	defer C.free(unsafe.Pointer(_args[0]))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(length)
	*(*C.gunichar)(unsafe.Pointer(&_args[2])) = C.gunichar(accelMarker)

	girepository.MustFind("Pango", "parse_markup").Invoke(_args[:], _outs[:])

	runtime.KeepAlive(markupText)
	runtime.KeepAlive(length)
	runtime.KeepAlive(accelMarker)

	var _attrList *AttrList // out
	var _text string        // out
	var _accelChar uint32   // out
	var _goerr error        // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(_outs[1])))
		defer C.free(unsafe.Pointer(_outs[1]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[2])) != nil {
		_accelChar = *(*uint32)(unsafe.Pointer(_outs[2]))
	}
	if *(**C.void)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _attrList, _text, _accelChar, _goerr
}

// AttrColor: PangoAttrColor structure is used to represent attributes that are
// colors.
//
// An instance of this type is always passed by reference.
type AttrColor struct {
	*attrColor
}

// attrColor is the struct that's finalized.
type attrColor struct {
	native unsafe.Pointer
}

// AttrFloat: PangoAttrFloat structure is used to represent attributes with a
// float or double value.
//
// An instance of this type is always passed by reference.
type AttrFloat struct {
	*attrFloat
}

// attrFloat is the struct that's finalized.
type attrFloat struct {
	native unsafe.Pointer
}

// AttrFontDesc: PangoAttrFontDesc structure is used to store an attribute that
// sets all aspects of the font description at once.
//
// An instance of this type is always passed by reference.
type AttrFontDesc struct {
	*attrFontDesc
}

// attrFontDesc is the struct that's finalized.
type attrFontDesc struct {
	native unsafe.Pointer
}

// NewAttrFontDesc: create a new font description attribute.
//
// This attribute allows setting family, style, weight, variant, stretch, and
// size simultaneously.
//
// The function takes the following parameters:
//
//    - desc: font description.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrFontDesc(desc *FontDescription) *Attribute {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))

	_gret := girepository.MustFind("Pango", "new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// AttrFontFeatures: PangoAttrFontFeatures structure is used to represent
// OpenType font features as an attribute.
//
// An instance of this type is always passed by reference.
type AttrFontFeatures struct {
	*attrFontFeatures
}

// attrFontFeatures is the struct that's finalized.
type attrFontFeatures struct {
	native unsafe.Pointer
}

// NewAttrFontFeatures: create a new font features tag attribute.
//
// The function takes the following parameters:
//
//    - features: string with OpenType font features, in CSS syntax.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrFontFeatures(features string) *Attribute {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(features)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Pango", "new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(features)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// AttrInt: PangoAttrInt structure is used to represent attributes with an
// integer or enumeration value.
//
// An instance of this type is always passed by reference.
type AttrInt struct {
	*attrInt
}

// attrInt is the struct that's finalized.
type attrInt struct {
	native unsafe.Pointer
}

// AttrIterator: PangoAttrIterator is used to iterate through a PangoAttrList.
//
// A new iterator is created with pango.AttrList.GetIterator(). Once the
// iterator is created, it can be advanced through the style changes in the text
// using pango.AttrIterator.Next(). At each style change, the range of the
// current style segment and the attributes currently in effect can be queried.
//
// An instance of this type is always passed by reference.
type AttrIterator struct {
	*attrIterator
}

// attrIterator is the struct that's finalized.
type attrIterator struct {
	native unsafe.Pointer
}

func marshalAttrIterator(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AttrIterator{&attrIterator{(unsafe.Pointer)(b)}}, nil
}

// Copy a PangoAttrIterator.
//
// The function returns the following values:
//
//    - attrIterator: newly allocated PangoAttrIterator, which should be freed
//      with pango.AttrIterator.Destroy().
//
func (iterator *AttrIterator) Copy() *AttrIterator {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iterator)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iterator)

	var _attrIterator *AttrIterator // out

	_attrIterator = (*AttrIterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attrIterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "AttrIterator").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attrIterator
}

// Destroy a PangoAttrIterator and free all associated memory.
func (iterator *AttrIterator) Destroy() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iterator)))

	runtime.KeepAlive(iterator)
}

// Attrs gets a list of all attributes at the current position of the iterator.
//
// The function returns the following values:
//
//    - sList: a list of all attributes for the current range. To free this
//      value, call pango.Attribute.Destroy() on each value and g_slist_free() on
//      the list.
//
func (iterator *AttrIterator) Attrs() []*Attribute {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iterator)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iterator)

	var _sList []*Attribute // out

	_sList = make([]*Attribute, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *Attribute // out
		dst = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
				}
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// Next: advance the iterator until the next change of style.
//
// The function returns the following values:
//
//    - ok: FALSE if the iterator is at the end of the list, otherwise TRUE.
//
func (iterator *AttrIterator) Next() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iterator)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iterator)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Range: get the range of the current segment. Note that the stored return
// values are signed, not unsigned like the values in PangoAttribute. To deal
// with this API oversight, stored return values that wouldn't fit into a signed
// integer are clamped to G_MAXINT.
//
// The function returns the following values:
//
//    - start: location to store the start of the range.
//    - end: location to store the end of the range.
//
func (iterator *AttrIterator) Range() (start int32, end int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iterator)))

	runtime.KeepAlive(iterator)

	var _start int32 // out
	var _end int32   // out

	_start = *(*int32)(unsafe.Pointer(_outs[0]))
	_end = *(*int32)(unsafe.Pointer(_outs[1]))

	return _start, _end
}

// AttrLanguage: PangoAttrLanguage structure is used to represent attributes
// that are languages.
//
// An instance of this type is always passed by reference.
type AttrLanguage struct {
	*attrLanguage
}

// attrLanguage is the struct that's finalized.
type attrLanguage struct {
	native unsafe.Pointer
}

// NewAttrLanguage: create a new language tag attribute.
//
// The function takes the following parameters:
//
//    - language tag.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrLanguage(language *Language) *Attribute {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(language)))

	_gret := girepository.MustFind("Pango", "new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(language)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// AttrList: PangoAttrList represents a list of attributes that apply to a
// section of text.
//
// The attributes in a PangoAttrList are, in general, allowed to overlap in an
// arbitrary fashion. However, if the attributes are manipulated only through
// pango.AttrList.Change(), the overlap between properties will meet stricter
// criteria.
//
// Since the PangoAttrList structure is stored as a linear list, it is not
// suitable for storing attributes for large amounts of text. In general, you
// should not use a single PangoAttrList for more than one paragraph of text.
//
// An instance of this type is always passed by reference.
type AttrList struct {
	*attrList
}

// attrList is the struct that's finalized.
type attrList struct {
	native unsafe.Pointer
}

func marshalAttrList(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AttrList{&attrList{(unsafe.Pointer)(b)}}, nil
}

// NewAttrList constructs a struct AttrList.
func NewAttrList() *AttrList {
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _attrList *AttrList // out

	_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attrList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _attrList
}

// Change: insert the given attribute into the PangoAttrList.
//
// It will replace any attributes of the same type on that segment and be merged
// with any adjoining attributes that are identical.
//
// This function is slower than pango.AttrList.Insert() for creating an
// attribute list in order (potentially much slower for large lists). However,
// pango.AttrList.Insert() is not suitable for continually changing a set of
// attributes since it never removes or combines existing attributes.
//
// The function takes the following parameters:
//
//    - attr: attribute to insert. Ownership of this value is assumed by the
//      list.
//
func (list *AttrList) Change(attr *Attribute) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(attr)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(attr)), nil)

	runtime.KeepAlive(list)
	runtime.KeepAlive(attr)
}

// Copy list and return an identical new list.
//
// The function returns the following values:
//
//    - attrList (optional): newly allocated PangoAttrList, with a reference
//      count of one, which should be freed with pango.AttrList.Unref(). Returns
//      NULL if list was NULL.
//
func (list *AttrList) Copy() *AttrList {
	var _args [1]girepository.Argument

	if list != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))
	}

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(list)

	var _attrList *AttrList // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _attrList
}

// Equal checks whether list and other_list contain the same attributes and
// whether those attributes apply to the same ranges. Beware that this will
// return wrong values if any list contains duplicates.
//
// The function takes the following parameters:
//
//    - otherList: other PangoAttrList.
//
// The function returns the following values:
//
//    - ok: TRUE if the lists are equal, FALSE if they aren't.
//
func (list *AttrList) Equal(otherList *AttrList) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(otherList)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(list)
	runtime.KeepAlive(otherList)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Filter: given a PangoAttrList and callback function, removes any elements of
// list for which func returns TRUE and inserts them into a new list.
//
// The function takes the following parameters:
//
//    - fn: callback function; returns TRUE if an attribute should be filtered
//      out.
//
// The function returns the following values:
//
//    - attrList (optional): new PangoAttrList or NULL if no attributes of the
//      given types were found.
//
func (list *AttrList) Filter(fn AttrFilterFunc) *AttrList {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_pango1_AttrFilterFunc)
	_args[2] = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_args[2]))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(list)
	runtime.KeepAlive(fn)

	var _attrList *AttrList // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _attrList
}

// Attributes gets a list of all attributes in list.
//
// The function returns the following values:
//
//    - sList: a list of all attributes in list. To free this value, call
//      pango.Attribute.Destroy on each value and g_slist_free() on the list.
//
func (list *AttrList) Attributes() []*Attribute {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(list)

	var _sList []*Attribute // out

	_sList = make([]*Attribute, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *Attribute // out
		dst = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
				}
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// Iterator: create a iterator initialized to the beginning of the list. list
// must not be modified until this iterator is freed.
//
// The function returns the following values:
//
//    - attrIterator: newly allocated PangoAttrIterator, which should be freed
//      with pango.AttrIterator.Destroy().
//
func (list *AttrList) Iterator() *AttrIterator {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(list)

	var _attrIterator *AttrIterator // out

	_attrIterator = (*AttrIterator)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attrIterator)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "AttrIterator").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attrIterator
}

// Insert the given attribute into the PangoAttrList.
//
// It will be inserted after all other attributes with a matching start_index.
//
// The function takes the following parameters:
//
//    - attr: attribute to insert. Ownership of this value is assumed by the
//      list.
//
func (list *AttrList) Insert(attr *Attribute) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(attr)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(attr)), nil)

	runtime.KeepAlive(list)
	runtime.KeepAlive(attr)
}

// InsertBefore: insert the given attribute into the PangoAttrList.
//
// It will be inserted before all other attributes with a matching start_index.
//
// The function takes the following parameters:
//
//    - attr: attribute to insert. Ownership of this value is assumed by the
//      list.
//
func (list *AttrList) InsertBefore(attr *Attribute) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(attr)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(attr)), nil)

	runtime.KeepAlive(list)
	runtime.KeepAlive(attr)
}

// Splice: this function opens up a hole in list, fills it in with attributes
// from the left, and then merges other on top of the hole.
//
// This operation is equivalent to stretching every attribute that applies at
// position pos in list by an amount len, and then calling
// pango.AttrList.Change() with a copy of each attribute in other in sequence
// (offset in position by pos).
//
// This operation proves useful for, for instance, inserting a pre-edit string
// in the middle of an edit buffer.
//
// The function takes the following parameters:
//
//    - other PangoAttrList.
//    - pos: position in list at which to insert other.
//    - len: length of the spliced segment. (Note that this must be specified
//      since the attributes in other may only be present at some subsection of
//      this range).
//
func (list *AttrList) Splice(other *AttrList, pos int32, len int32) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(other)))
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(pos)
	*(*C.gint)(unsafe.Pointer(&_args[3])) = C.gint(len)

	runtime.KeepAlive(list)
	runtime.KeepAlive(other)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(len)
}

// Update indices of attributes in list for a change in the text they refer to.
//
// The change that this function applies is removing remove bytes at position
// pos and inserting add bytes instead.
//
// Attributes that fall entirely in the (pos, pos + remove) range are removed.
//
// Attributes that start or end inside the (pos, pos + remove) range are
// shortened to reflect the removal.
//
// Attributes start and end positions are updated if they are behind pos +
// remove.
//
// The function takes the following parameters:
//
//    - pos: position of the change.
//    - remove: number of removed bytes.
//    - add: number of added bytes.
//
func (list *AttrList) Update(pos int32, remove int32, add int32) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(list)))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(pos)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(remove)
	*(*C.int)(unsafe.Pointer(&_args[3])) = C.int(add)

	runtime.KeepAlive(list)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(remove)
	runtime.KeepAlive(add)
}

// AttrShape: PangoAttrShape structure is used to represent attributes which
// impose shape restrictions.
//
// An instance of this type is always passed by reference.
type AttrShape struct {
	*attrShape
}

// attrShape is the struct that's finalized.
type attrShape struct {
	native unsafe.Pointer
}

// NewAttrShape: create a new shape attribute.
//
// A shape is used to impose a particular ink and logical rectangle on the
// result of shaping a particular glyph. This might be used, for instance, for
// embedding a picture or a widget inside a PangoLayout.
//
// The function takes the following parameters:
//
//    - inkRect: ink rectangle to assign to each character.
//    - logicalRect: logical rectangle to assign to each character.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrShape(inkRect, logicalRect *Rectangle) *Attribute {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(inkRect)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(logicalRect)))

	_gret := girepository.MustFind("Pango", "new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(inkRect)
	runtime.KeepAlive(logicalRect)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// AttrSize: PangoAttrSize structure is used to represent attributes which set
// font size.
//
// An instance of this type is always passed by reference.
type AttrSize struct {
	*attrSize
}

// attrSize is the struct that's finalized.
type attrSize struct {
	native unsafe.Pointer
}

// NewAttrSize: create a new font-size attribute in fractional points.
//
// The function takes the following parameters:
//
//    - size: font size, in PANGO_SCALEths of a point.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrSize(size int32) *Attribute {
	var _args [1]girepository.Argument

	*(*C.int)(unsafe.Pointer(&_args[0])) = C.int(size)

	_gret := girepository.MustFind("Pango", "new").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(size)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// NewAttrSizeAbsolute: create a new font-size attribute in device units.
//
// The function takes the following parameters:
//
//    - size: font size, in PANGO_SCALEths of a device unit.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func NewAttrSizeAbsolute(size int32) *Attribute {
	var _args [1]girepository.Argument

	*(*C.int)(unsafe.Pointer(&_args[0])) = C.int(size)

	_gret := girepository.MustFind("Pango", "new_absolute").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(size)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// AttrString: PangoAttrString structure is used to represent attributes with a
// string value.
//
// An instance of this type is always passed by reference.
type AttrString struct {
	*attrString
}

// attrString is the struct that's finalized.
type attrString struct {
	native unsafe.Pointer
}

// Attribute: PangoAttribute structure represents the common portions of all
// attributes.
//
// Particular types of attributes include this structure as their initial
// portion. The common portion of the attribute holds the range to which the
// value in the type-specific part of the attribute applies and should be
// initialized using pango.Attribute.Init(). By default, an attribute will have
// an all-inclusive range of [0,G_MAXUINT].
//
// An instance of this type is always passed by reference.
type Attribute struct {
	*attribute
}

// attribute is the struct that's finalized.
type attribute struct {
	native unsafe.Pointer
}

func marshalAttribute(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Attribute{&attribute{(unsafe.Pointer)(b)}}, nil
}

// Copy: make a copy of an attribute.
//
// The function returns the following values:
//
//    - attribute: newly allocated PangoAttribute, which should be freed with
//      pango.Attribute.Destroy().
//
func (attr *Attribute) Copy() *Attribute {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(attr)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(attr)

	var _attribute *Attribute // out

	_attribute = (*Attribute)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attribute)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "Attribute").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _attribute
}

// Destroy a PangoAttribute and free all associated memory.
func (attr *Attribute) Destroy() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(attr)))

	runtime.KeepAlive(attr)
}

// Equal: compare two attributes for equality. This compares only the actual
// value of the two attributes and not the ranges that the attributes apply to.
//
// The function takes the following parameters:
//
//    - attr2: another PangoAttribute.
//
// The function returns the following values:
//
//    - ok: TRUE if the two attributes have the same value.
//
func (attr1 *Attribute) Equal(attr2 *Attribute) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(attr1)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(attr2)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(attr1)
	runtime.KeepAlive(attr2)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Color: PangoColor structure is used to represent a color in an uncalibrated
// RGB color-space.
//
// An instance of this type is always passed by reference.
type Color struct {
	*color
}

// color is the struct that's finalized.
type color struct {
	native unsafe.Pointer
}

func marshalColor(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Color{&color{(unsafe.Pointer)(b)}}, nil
}

// Red: value of red component.
func (c *Color) Red() uint16 {
	offset := girepository.MustFind("Pango", "Color").StructFieldOffset("red")
	valptr := (*uintptr)(unsafe.Add(c.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

// Green: value of green component.
func (c *Color) Green() uint16 {
	offset := girepository.MustFind("Pango", "Color").StructFieldOffset("green")
	valptr := (*uintptr)(unsafe.Add(c.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

// Blue: value of blue component.
func (c *Color) Blue() uint16 {
	offset := girepository.MustFind("Pango", "Color").StructFieldOffset("blue")
	valptr := (*uintptr)(unsafe.Add(c.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

// Red: value of red component.
func (c *Color) SetRed(red uint16) {
	offset := girepository.MustFind("Pango", "Color").StructFieldOffset("red")
	valptr := (*uintptr)(unsafe.Add(c.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(red)
}

// Green: value of green component.
func (c *Color) SetGreen(green uint16) {
	offset := girepository.MustFind("Pango", "Color").StructFieldOffset("green")
	valptr := (*uintptr)(unsafe.Add(c.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(green)
}

// Blue: value of blue component.
func (c *Color) SetBlue(blue uint16) {
	offset := girepository.MustFind("Pango", "Color").StructFieldOffset("blue")
	valptr := (*uintptr)(unsafe.Add(c.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(blue)
}

// Copy creates a copy of src.
//
// The copy should be freed with pango_color_free(). Primarily used by language
// bindings, not that useful otherwise (since colors can just be copied by
// assignment in C).
//
// The function returns the following values:
//
//    - color (optional): newly allocated PangoColor, which should be freed with
//      pango.Color.Free(), or NULL if src was NULL.
//
func (src *Color) Copy() *Color {
	var _args [1]girepository.Argument

	if src != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(src)))
	}

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(src)

	var _color *Color // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_color = (*Color)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_color)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Pango", "Color").InvokeMethod("free", args[:], nil)
				}
			},
		)
	}

	return _color
}

// Parse: fill in the fields of a color from a string specification.
//
// The string can either one of a large set of standard names. (Taken from the
// CSS Color specification (https://www.w3.org/TR/css-color-4/#named-colors), or
// it can be a value in the form #rgb, #rrggbb, #rrrgggbbb or #rrrrggggbbbb,
// where r, g and b are hex digits of the red, green, and blue components of the
// color, respectively. (White in the four forms is #fff, #ffffff, #fffffffff
// and #ffffffffffff.).
//
// The function takes the following parameters:
//
//    - spec: string specifying the new color.
//
// The function returns the following values:
//
//    - ok: TRUE if parsing of the specifier succeeded, otherwise false.
//
func (color *Color) Parse(spec string) bool {
	var _args [2]girepository.Argument

	if color != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(spec)))
	defer C.free(unsafe.Pointer(_args[1]))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(color)
	runtime.KeepAlive(spec)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ParseWithAlpha: fill in the fields of a color from a string specification.
//
// The string can either one of a large set of standard names. (Taken from the
// CSS Color specification (https://www.w3.org/TR/css-color-4/#named-colors), or
// it can be a hexadecimal value in the form #rgb, #rrggbb, #rrrgggbbb or
// #rrrrggggbbbb where r, g and b are hex digits of the red, green, and blue
// components of the color, respectively. (White in the four forms is #fff,
// #ffffff, #fffffffff and #ffffffffffff.)
//
// Additionally, parse strings of the form #rgba, #rrggbbaa, #rrrrggggbbbbaaaa,
// if alpha is not NULL, and set alpha to the value specified by the hex digits
// for a. If no alpha component is found in spec, alpha is set to 0xffff (for a
// solid color).
//
// The function takes the following parameters:
//
//    - spec: string specifying the new color.
//
// The function returns the following values:
//
//    - alpha (optional): return location for alpha, or NULL.
//    - ok: TRUE if parsing of the specifier succeeded, otherwise false.
//
func (color *Color) ParseWithAlpha(spec string) (uint16, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	if color != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	}
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(spec)))
	defer C.free(unsafe.Pointer(_args[1]))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(color)
	runtime.KeepAlive(spec)

	var _alpha uint16 // out
	var _ok bool      // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_alpha = *(*uint16)(unsafe.Pointer(_outs[0]))
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _alpha, _ok
}

// String returns a textual specification of color.
//
// The string is in the hexadecimal form #rrrrggggbbbb, where r, g and b are hex
// digits representing the red, green, and blue components respectively.
//
// The function returns the following values:
//
//    - utf8: newly-allocated text string that must be freed with g_free().
//
func (color *Color) String() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(color)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

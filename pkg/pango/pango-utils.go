// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// IsZeroWidth checks if a character that should not be normally rendered.
//
// This includes all Unicode characters with "ZERO WIDTH" in their name, as well
// as *bidi* formatting characters, and a few other ones. This is totally
// different from g_unichar_iszerowidth() and is at best misnamed.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//
// The function returns the following values:
//
//    - ok: TRUE if ch is a zero-width character, FALSE otherwise.
//
func IsZeroWidth(ch uint32) bool {
	var _args [1]girepository.Argument

	*(*C.gunichar)(unsafe.Pointer(&_args[0])) = C.gunichar(ch)

	_info := girepository.MustFind("Pango", "is_zero_width")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(ch)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Log2VisGetEmbeddingLevels: return the bidirectional embedding levels of the
// input paragraph.
//
// The bidirectional embedding levels are defined by the Unicode Bidirectional
// Algorithm available at:
//
//    http://www.unicode.org/reports/tr9/
//
// If the input base direction is a weak direction, the direction of the
// characters in the text will determine the final resolved direction.
//
// The function takes the following parameters:
//
//    - text to itemize.
//    - length: number of bytes (not characters) to process, or -1 if text is
//      nul-terminated and the length should be calculated.
//    - pbaseDir: input base direction, and output resolved direction.
//
// The function returns the following values:
//
//    - guint8: newly allocated array of embedding levels, one item per character
//      (not byte), that should be freed using g_free().
//
func Log2VisGetEmbeddingLevels(text string, length int32, pbaseDir *Direction) *byte {
	var _args [3]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(length)
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(pbaseDir))

	_info := girepository.MustFind("Pango", "log2vis_get_embedding_levels")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.guint8)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)
	runtime.KeepAlive(length)
	runtime.KeepAlive(pbaseDir)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(*(**C.guint8)(unsafe.Pointer(&_cret))))

	return _guint8
}

// ParseEnum parses an enum type and stores the result in value.
//
// If str does not match the nick name of any of the possible values for the
// enum and is not an integer, FALSE is returned, a warning is issued if warn is
// TRUE, and a string representing the list of possible values is stored in
// possible_values. The list is slash-separated, eg. "none/start/middle/end". If
// failed and possible_values is not NULL, returned string should be freed using
// g_free().
//
// Deprecated: since version 1.38.
//
// The function takes the following parameters:
//
//    - typ: enum type to parse, eg. PANGO_TYPE_ELLIPSIZE_MODE.
//    - str (optional): string to parse. May be NULL.
//    - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//    - value (optional): integer to store the result in, or NULL.
//    - possibleValues (optional): place to store list of possible values on
//      failure, or NULL.
//    - ok: TRUE if str was successfully parsed.
//
func ParseEnum(typ coreglib.Type, str string, warn bool) (int32, string, bool) {
	var _args [3]girepository.Argument
	var _outs [2]girepository.Argument

	*(*C.GType)(unsafe.Pointer(&_args[0])) = C.GType(typ)
	if str != "" {
		*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))
	}
	if warn {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	_info := girepository.MustFind("Pango", "parse_enum")
	_gret := _info.InvokeFunction(_args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(typ)
	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _value int32           // out
	var _possibleValues string // out
	var _ok bool               // out

	_value = int32(*(*C.int)(unsafe.Pointer(&_outs[0])))
	if *(**C.char)(unsafe.Pointer(&_outs[1])) != nil {
		_possibleValues = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[1])))))
		defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_outs[1]))))
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _value, _possibleValues, _ok
}

// ParseStretch parses a font stretch.
//
// The allowed values are "ultra_condensed", "extra_condensed", "condensed",
// "semi_condensed", "normal", "semi_expanded", "expanded", "extra_expanded" and
// "ultra_expanded". Case variations are ignored and the '_' characters may be
// omitted.
//
// The function takes the following parameters:
//
//    - str: string to parse.
//    - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//    - stretch: PangoStretch to store the result in.
//    - ok: TRUE if str was successfully parsed.
//
func ParseStretch(str string, warn bool) (Stretch, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))
	if warn {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Pango", "parse_stretch")
	_gret := _info.InvokeFunction(_args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _stretch Stretch // out
	var _ok bool         // out

	_stretch = *(*Stretch)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0]))))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _stretch, _ok
}

// ParseStyle parses a font style.
//
// The allowed values are "normal", "italic" and "oblique", case variations
// being ignored.
//
// The function takes the following parameters:
//
//    - str: string to parse.
//    - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//    - style: PangoStyle to store the result in.
//    - ok: TRUE if str was successfully parsed.
//
func ParseStyle(str string, warn bool) (Style, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))
	if warn {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Pango", "parse_style")
	_gret := _info.InvokeFunction(_args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _style Style // out
	var _ok bool     // out

	_style = *(*Style)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0]))))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _style, _ok
}

// ParseVariant parses a font variant.
//
// The allowed values are "normal" and "smallcaps" or "small_caps", case
// variations being ignored.
//
// The function takes the following parameters:
//
//    - str: string to parse.
//    - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//    - variant: PangoVariant to store the result in.
//    - ok: TRUE if str was successfully parsed.
//
func ParseVariant(str string, warn bool) (Variant, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))
	if warn {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Pango", "parse_variant")
	_gret := _info.InvokeFunction(_args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _variant Variant // out
	var _ok bool         // out

	_variant = *(*Variant)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0]))))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _variant, _ok
}

// ParseWeight parses a font weight.
//
// The allowed values are "heavy", "ultrabold", "bold", "normal", "light",
// "ultraleight" and integers. Case variations are ignored.
//
// The function takes the following parameters:
//
//    - str: string to parse.
//    - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//    - weight: PangoWeight to store the result in.
//    - ok: TRUE if str was successfully parsed.
//
func ParseWeight(str string, warn bool) (Weight, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))
	if warn {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Pango", "parse_weight")
	_gret := _info.InvokeFunction(_args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _weight Weight // out
	var _ok bool       // out

	_weight = *(*Weight)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0]))))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _weight, _ok
}

// SplitFileList splits a G_SEARCHPATH_SEPARATOR-separated list of files,
// stripping white space and substituting ~/ with $HOME/.
//
// Deprecated: since version 1.38.
//
// The function takes the following parameters:
//
//    - str: G_SEARCHPATH_SEPARATOR separated list of filenames.
//
// The function returns the following values:
//
//    - utf8s: list of strings to be freed with g_strfreev().
//
func SplitFileList(str string) []string {
	var _args [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Pango", "split_file_list")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(***C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(*(***C.char)(unsafe.Pointer(&_cret))))
	{
		var i int
		var z *C.char
		for p := *(***C.char)(unsafe.Pointer(&_cret)); *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*(***C.char)(unsafe.Pointer(&_cret)), i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&src[i])))))
			defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&src[i]))))
		}
	}

	return _utf8s
}

// TrimString trims leading and trailing whitespace from a string.
//
// Deprecated: since version 1.38.
//
// The function takes the following parameters:
//
//    - str: string.
//
// The function returns the following values:
//
//    - utf8: newly-allocated string that must be freed with g_free().
//
func TrimString(str string) string {
	var _args [1]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Pango", "trim_string")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))

	return _utf8
}

// Version returns the encoded version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION except that the macro returns the
// encoded version available at compile-time. A version number can be encoded
// into an integer using PANGO_VERSION_ENCODE().
//
// The function returns the following values:
//
//    - gint: encoded version of Pango library available at run time.
//
func Version() int32 {
	_info := girepository.MustFind("Pango", "version")
	_gret := _info.InvokeFunction(nil, nil)
	_cret := *(*C.int)(unsafe.Pointer(&_gret))

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// VersionCheck checks that the Pango library in use is compatible with the
// given version.
//
// Generally you would pass in the constants PANGO_VERSION_MAJOR,
// PANGO_VERSION_MINOR, PANGO_VERSION_MICRO as the three arguments to this
// function; that produces a check that the library in use at run-time is
// compatible with the version of Pango the application or module was compiled
// against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// required_major.required_minor.required_micro. Second the running library must
// be binary compatible with the version
// required_major.required_minor.required_micro (same major version.)
//
// For compile-time version checking use PANGO_VERSION_CHECK().
//
// The function takes the following parameters:
//
//    - requiredMajor: required major version.
//    - requiredMinor: required minor version.
//    - requiredMicro: required major version.
//
// The function returns the following values:
//
//    - utf8 (optional): NULL if the Pango library is compatible with the given
//      version, or a string describing the version mismatch. The returned string
//      is owned by Pango and should not be modified or freed.
//
func VersionCheck(requiredMajor, requiredMinor, requiredMicro int32) string {
	var _args [3]girepository.Argument

	*(*C.int)(unsafe.Pointer(&_args[0])) = C.int(requiredMajor)
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(requiredMinor)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(requiredMicro)

	_info := girepository.MustFind("Pango", "version_check")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(requiredMajor)
	runtime.KeepAlive(requiredMinor)
	runtime.KeepAlive(requiredMicro)

	var _utf8 string // out

	if *(**C.char)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
	}

	return _utf8
}

// VersionString returns the version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION_STRING except that the macro
// returns the version available at compile-time.
//
// The function returns the following values:
//
//    - utf8: string containing the version of Pango library available at run
//      time. The returned string is owned by Pango and should not be modified or
//      freed.
//
func VersionString() string {
	_info := girepository.MustFind("Pango", "version_string")
	_gret := _info.InvokeFunction(nil, nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))

	return _utf8
}

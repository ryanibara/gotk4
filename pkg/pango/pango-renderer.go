// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_pango1_RendererClass_begin(void*);
// extern void _gotk4_pango1_RendererClass_draw_error_underline(void*, int, int, int, int);
// extern void _gotk4_pango1_RendererClass_draw_glyph(void*, void*, guint32, double, double);
// extern void _gotk4_pango1_RendererClass_draw_glyph_item(void*, void*, void*, int, int);
// extern void _gotk4_pango1_RendererClass_draw_glyphs(void*, void*, void*, int, int);
// extern void _gotk4_pango1_RendererClass_draw_shape(void*, void*, int, int);
// extern void _gotk4_pango1_RendererClass_end(void*);
// extern void _gotk4_pango1_RendererClass_prepare_run(void*, void*);
import "C"

// glib.Type values for pango-renderer.go.
var (
	GTypeRenderPart = coreglib.Type(C.pango_render_part_get_type())
	GTypeRenderer   = coreglib.Type(C.pango_renderer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeRenderPart, F: marshalRenderPart},
		{T: GTypeRenderer, F: marshalRenderer},
	})
}

// RenderPart defines different items to render for such purposes as setting
// colors.
type RenderPart C.gint

const (
	// RenderPartForeground: text itself.
	RenderPartForeground RenderPart = iota
	// RenderPartBackground: area behind the text.
	RenderPartBackground
	// RenderPartUnderline: underlines.
	RenderPartUnderline
	// RenderPartStrikethrough: strikethrough lines.
	RenderPartStrikethrough
	// RenderPartOverline: overlines.
	RenderPartOverline
)

func marshalRenderPart(p uintptr) (interface{}, error) {
	return RenderPart(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RenderPart.
func (r RenderPart) String() string {
	switch r {
	case RenderPartForeground:
		return "Foreground"
	case RenderPartBackground:
		return "Background"
	case RenderPartUnderline:
		return "Underline"
	case RenderPartStrikethrough:
		return "Strikethrough"
	case RenderPartOverline:
		return "Overline"
	default:
		return fmt.Sprintf("RenderPart(%d)", r)
	}
}

// RendererOverrider contains methods that are overridable.
type RendererOverrider interface {
	Begin()
	// DrawErrorUnderline: draw a squiggly line that approximately covers the
	// given rectangle in the style of an underline used to indicate a spelling
	// error.
	//
	// The width of the underline is rounded to an integer number of up/down
	// segments and the resulting rectangle is centered in the original
	// rectangle.
	//
	// This should be called while renderer is already active. Use
	// pango.Renderer.Activate() to activate a renderer.
	//
	// The function takes the following parameters:
	//
	//    - x: x coordinate of underline, in Pango units in user coordinate
	//      system.
	//    - y: y coordinate of underline, in Pango units in user coordinate
	//      system.
	//    - width of underline, in Pango units in user coordinate system.
	//    - height of underline, in Pango units in user coordinate system.
	//
	DrawErrorUnderline(x, y, width, height int32)
	// DrawGlyph draws a single glyph with coordinates in device space.
	//
	// The function takes the following parameters:
	//
	//    - font: Font.
	//    - glyph index of a single glyph.
	//    - x: x coordinate of left edge of baseline of glyph.
	//    - y: y coordinate of left edge of baseline of glyph.
	//
	DrawGlyph(font Fonter, glyph Glyph, x, y float64)
	// DrawGlyphItem draws the glyphs in glyph_item with the specified
	// PangoRenderer, embedding the text associated with the glyphs in the
	// output if the output format supports it.
	//
	// This is useful for rendering text in PDF.
	//
	// Note that text is the start of the text for layout, which is then indexed
	// by glyph_item->item->offset.
	//
	// If text is NULL, this simply calls pango.Renderer.DrawGlyphs().
	//
	// The default implementation of this method simply falls back to
	// pango.Renderer.DrawGlyphs().
	//
	// The function takes the following parameters:
	//
	//    - text (optional): UTF-8 text that glyph_item refers to, or NULL.
	//    - glyphItem: PangoGlyphItem.
	//    - x: x position of left edge of baseline, in user space coordinates in
	//      Pango units.
	//    - y: y position of left edge of baseline, in user space coordinates in
	//      Pango units.
	//
	DrawGlyphItem(text string, glyphItem *GlyphItem, x, y int32)
	// DrawGlyphs draws the glyphs in glyphs with the specified PangoRenderer.
	//
	// The function takes the following parameters:
	//
	//    - font: PangoFont.
	//    - glyphs: PangoGlyphString.
	//    - x: x position of left edge of baseline, in user space coordinates in
	//      Pango units.
	//    - y: y position of left edge of baseline, in user space coordinates in
	//      Pango units.
	//
	DrawGlyphs(font Fonter, glyphs *GlyphString, x, y int32)
	// The function takes the following parameters:
	//
	//    - attr
	//    - x
	//    - y
	//
	DrawShape(attr *AttrShape, x, y int32)
	End()
	// The function takes the following parameters:
	//
	PrepareRun(run *LayoutRun)
}

// Renderer: PangoRenderer is a base class for objects that can render text
// provided as PangoGlyphString or PangoLayout.
//
// By subclassing PangoRenderer and overriding operations such as draw_glyphs
// and draw_rectangle, renderers for particular font backends and destinations
// can be created.
type Renderer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Renderer)(nil)
)

// Rendererer describes types inherited from class Renderer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Rendererer interface {
	coreglib.Objector
	baseRenderer() *Renderer
}

var _ Rendererer = (*Renderer)(nil)

func classInitRendererer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Pango", "RendererClass")

	if _, ok := goval.(interface{ Begin() }); ok {
		o := pclass.StructFieldOffset("begin")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_RendererClass_begin)
	}

	if _, ok := goval.(interface {
		DrawErrorUnderline(x, y, width, height int32)
	}); ok {
		o := pclass.StructFieldOffset("draw_error_underline")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_RendererClass_draw_error_underline)
	}

	if _, ok := goval.(interface {
		DrawGlyph(font Fonter, glyph Glyph, x, y float64)
	}); ok {
		o := pclass.StructFieldOffset("draw_glyph")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_RendererClass_draw_glyph)
	}

	if _, ok := goval.(interface {
		DrawGlyphItem(text string, glyphItem *GlyphItem, x, y int32)
	}); ok {
		o := pclass.StructFieldOffset("draw_glyph_item")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_RendererClass_draw_glyph_item)
	}

	if _, ok := goval.(interface {
		DrawGlyphs(font Fonter, glyphs *GlyphString, x, y int32)
	}); ok {
		o := pclass.StructFieldOffset("draw_glyphs")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_RendererClass_draw_glyphs)
	}

	if _, ok := goval.(interface {
		DrawShape(attr *AttrShape, x, y int32)
	}); ok {
		o := pclass.StructFieldOffset("draw_shape")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_RendererClass_draw_shape)
	}

	if _, ok := goval.(interface{ End() }); ok {
		o := pclass.StructFieldOffset("end")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_RendererClass_end)
	}

	if _, ok := goval.(interface{ PrepareRun(run *LayoutRun) }); ok {
		o := pclass.StructFieldOffset("prepare_run")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_RendererClass_prepare_run)
	}
}

//export _gotk4_pango1_RendererClass_begin
func _gotk4_pango1_RendererClass_begin(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Begin() })

	iface.Begin()
}

//export _gotk4_pango1_RendererClass_draw_error_underline
func _gotk4_pango1_RendererClass_draw_error_underline(arg0 *C.void, arg1 C.int, arg2 C.int, arg3 C.int, arg4 C.int) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DrawErrorUnderline(x, y, width, height int32)
	})

	var _x int32      // out
	var _y int32      // out
	var _width int32  // out
	var _height int32 // out

	_x = int32(arg1)
	_y = int32(arg2)
	_width = int32(arg3)
	_height = int32(arg4)

	iface.DrawErrorUnderline(_x, _y, _width, _height)
}

//export _gotk4_pango1_RendererClass_draw_glyph
func _gotk4_pango1_RendererClass_draw_glyph(arg0 *C.void, arg1 *C.void, arg2 C.guint32, arg3 C.double, arg4 C.double) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DrawGlyph(font Fonter, glyph Glyph, x, y float64)
	})

	var _font Fonter // out
	var _glyph Glyph // out
	var _x float64   // out
	var _y float64   // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Fonter)
			return ok
		})
		rv, ok := casted.(Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_font = rv
	}
	_glyph = uint32(arg2)
	_x = float64(arg3)
	_y = float64(arg4)

	iface.DrawGlyph(_font, _glyph, _x, _y)
}

//export _gotk4_pango1_RendererClass_draw_glyph_item
func _gotk4_pango1_RendererClass_draw_glyph_item(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 C.int, arg4 C.int) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DrawGlyphItem(text string, glyphItem *GlyphItem, x, y int32)
	})

	var _text string          // out
	var _glyphItem *GlyphItem // out
	var _x int32              // out
	var _y int32              // out

	if arg1 != nil {
		_text = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}
	_glyphItem = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_x = int32(arg3)
	_y = int32(arg4)

	iface.DrawGlyphItem(_text, _glyphItem, _x, _y)
}

//export _gotk4_pango1_RendererClass_draw_glyphs
func _gotk4_pango1_RendererClass_draw_glyphs(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 C.int, arg4 C.int) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DrawGlyphs(font Fonter, glyphs *GlyphString, x, y int32)
	})

	var _font Fonter         // out
	var _glyphs *GlyphString // out
	var _x int32             // out
	var _y int32             // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Fonter)
			return ok
		})
		rv, ok := casted.(Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_font = rv
	}
	_glyphs = (*GlyphString)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_x = int32(arg3)
	_y = int32(arg4)

	iface.DrawGlyphs(_font, _glyphs, _x, _y)
}

//export _gotk4_pango1_RendererClass_draw_shape
func _gotk4_pango1_RendererClass_draw_shape(arg0 *C.void, arg1 *C.void, arg2 C.int, arg3 C.int) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DrawShape(attr *AttrShape, x, y int32)
	})

	var _attr *AttrShape // out
	var _x int32         // out
	var _y int32         // out

	_attr = (*AttrShape)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_x = int32(arg2)
	_y = int32(arg3)

	iface.DrawShape(_attr, _x, _y)
}

//export _gotk4_pango1_RendererClass_end
func _gotk4_pango1_RendererClass_end(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ End() })

	iface.End()
}

//export _gotk4_pango1_RendererClass_prepare_run
func _gotk4_pango1_RendererClass_prepare_run(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ PrepareRun(run *LayoutRun) })

	var _run *LayoutRun // out

	_run = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	iface.PrepareRun(_run)
}

func wrapRenderer(obj *coreglib.Object) *Renderer {
	return &Renderer{
		Object: obj,
	}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	return wrapRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (renderer *Renderer) baseRenderer() *Renderer {
	return renderer
}

// BaseRenderer returns the underlying base object.
func BaseRenderer(obj Rendererer) *Renderer {
	return obj.baseRenderer()
}

// Activate does initial setup before rendering operations on renderer.
//
// pango.Renderer.Deactivate() should be called when done drawing. Calls such as
// pango.Renderer.DrawLayout() automatically activate the layout before drawing
// on it. Calls to pango_renderer_activate() and pango_renderer_deactivate() can
// be nested and the renderer will only be initialized and deinitialized once.
func (renderer *Renderer) Activate() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	girepository.MustFind("Pango", "Renderer").InvokeMethod("activate", _args[:], nil)

	runtime.KeepAlive(renderer)
}

// Deactivate cleans up after rendering operations on renderer.
//
// See docs for pango.Renderer.Activate().
func (renderer *Renderer) Deactivate() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	girepository.MustFind("Pango", "Renderer").InvokeMethod("deactivate", _args[:], nil)

	runtime.KeepAlive(renderer)
}

// DrawErrorUnderline: draw a squiggly line that approximately covers the given
// rectangle in the style of an underline used to indicate a spelling error.
//
// The width of the underline is rounded to an integer number of up/down
// segments and the resulting rectangle is centered in the original rectangle.
//
// This should be called while renderer is already active. Use
// pango.Renderer.Activate() to activate a renderer.
//
// The function takes the following parameters:
//
//    - x: x coordinate of underline, in Pango units in user coordinate system.
//    - y: y coordinate of underline, in Pango units in user coordinate system.
//    - width of underline, in Pango units in user coordinate system.
//    - height of underline, in Pango units in user coordinate system.
//
func (renderer *Renderer) DrawErrorUnderline(x, y, width, height int32) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(x)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(y)
	*(*C.int)(unsafe.Pointer(&_args[3])) = C.int(width)
	*(*C.int)(unsafe.Pointer(&_args[4])) = C.int(height)

	girepository.MustFind("Pango", "Renderer").InvokeMethod("draw_error_underline", _args[:], nil)

	runtime.KeepAlive(renderer)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// DrawGlyph draws a single glyph with coordinates in device space.
//
// The function takes the following parameters:
//
//    - font: Font.
//    - glyph index of a single glyph.
//    - x: x coordinate of left edge of baseline of glyph.
//    - y: y coordinate of left edge of baseline of glyph.
//
func (renderer *Renderer) DrawGlyph(font Fonter, glyph Glyph, x, y float64) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	*(*C.guint32)(unsafe.Pointer(&_args[2])) = C.guint32(glyph)
	*(*C.double)(unsafe.Pointer(&_args[3])) = C.double(x)
	*(*C.double)(unsafe.Pointer(&_args[4])) = C.double(y)

	girepository.MustFind("Pango", "Renderer").InvokeMethod("draw_glyph", _args[:], nil)

	runtime.KeepAlive(renderer)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyph)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawGlyphItem draws the glyphs in glyph_item with the specified
// PangoRenderer, embedding the text associated with the glyphs in the output if
// the output format supports it.
//
// This is useful for rendering text in PDF.
//
// Note that text is the start of the text for layout, which is then indexed by
// glyph_item->item->offset.
//
// If text is NULL, this simply calls pango.Renderer.DrawGlyphs().
//
// The default implementation of this method simply falls back to
// pango.Renderer.DrawGlyphs().
//
// The function takes the following parameters:
//
//    - text (optional): UTF-8 text that glyph_item refers to, or NULL.
//    - glyphItem: PangoGlyphItem.
//    - x: x position of left edge of baseline, in user space coordinates in
//      Pango units.
//    - y: y position of left edge of baseline, in user space coordinates in
//      Pango units.
//
func (renderer *Renderer) DrawGlyphItem(text string, glyphItem *GlyphItem, x, y int32) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if text != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_args[1]))
	}
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(glyphItem)))
	*(*C.int)(unsafe.Pointer(&_args[3])) = C.int(x)
	*(*C.int)(unsafe.Pointer(&_args[4])) = C.int(y)

	girepository.MustFind("Pango", "Renderer").InvokeMethod("draw_glyph_item", _args[:], nil)

	runtime.KeepAlive(renderer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(glyphItem)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawGlyphs draws the glyphs in glyphs with the specified PangoRenderer.
//
// The function takes the following parameters:
//
//    - font: PangoFont.
//    - glyphs: PangoGlyphString.
//    - x: x position of left edge of baseline, in user space coordinates in
//      Pango units.
//    - y: y position of left edge of baseline, in user space coordinates in
//      Pango units.
//
func (renderer *Renderer) DrawGlyphs(font Fonter, glyphs *GlyphString, x, y int32) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(glyphs)))
	*(*C.int)(unsafe.Pointer(&_args[3])) = C.int(x)
	*(*C.int)(unsafe.Pointer(&_args[4])) = C.int(y)

	girepository.MustFind("Pango", "Renderer").InvokeMethod("draw_glyphs", _args[:], nil)

	runtime.KeepAlive(renderer)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawLayout draws layout with the specified PangoRenderer.
//
// The function takes the following parameters:
//
//    - layout: PangoLayout.
//    - x: x position of left edge of baseline, in user space coordinates in
//      Pango units.
//    - y: y position of left edge of baseline, in user space coordinates in
//      Pango units.
//
func (renderer *Renderer) DrawLayout(layout *Layout, x, y int32) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(x)
	*(*C.int)(unsafe.Pointer(&_args[3])) = C.int(y)

	girepository.MustFind("Pango", "Renderer").InvokeMethod("draw_layout", _args[:], nil)

	runtime.KeepAlive(renderer)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DrawLayoutLine draws line with the specified PangoRenderer.
//
// The function takes the following parameters:
//
//    - line: PangoLayoutLine.
//    - x: x position of left edge of baseline, in user space coordinates in
//      Pango units.
//    - y: y position of left edge of baseline, in user space coordinates in
//      Pango units.
//
func (renderer *Renderer) DrawLayoutLine(line *LayoutLine, x, y int32) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(line)))
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(x)
	*(*C.int)(unsafe.Pointer(&_args[3])) = C.int(y)

	girepository.MustFind("Pango", "Renderer").InvokeMethod("draw_layout_line", _args[:], nil)

	runtime.KeepAlive(renderer)
	runtime.KeepAlive(line)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// Layout gets the layout currently being rendered using renderer.
//
// Calling this function only makes sense from inside a subclass's methods, like
// in its draw_shape vfunc, for example.
//
// The returned layout should not be modified while still being rendered.
//
// The function returns the following values:
//
//    - layout (optional): layout, or NULL if no layout is being rendered using
//      renderer at this time.
//
func (renderer *Renderer) Layout() *Layout {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_gret := girepository.MustFind("Pango", "Renderer").InvokeMethod("get_layout", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(renderer)

	var _layout *Layout // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_layout = wrapLayout(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _layout
}

// LayoutLine gets the layout line currently being rendered using renderer.
//
// Calling this function only makes sense from inside a subclass's methods, like
// in its draw_shape vfunc, for example.
//
// The returned layout line should not be modified while still being rendered.
//
// The function returns the following values:
//
//    - layoutLine (optional): layout line, or NULL if no layout line is being
//      rendered using renderer at this time.
//
func (renderer *Renderer) LayoutLine() *LayoutLine {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_gret := girepository.MustFind("Pango", "Renderer").InvokeMethod("get_layout_line", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(renderer)

	var _layoutLine *LayoutLine // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _layoutLine
}

// Matrix gets the transformation matrix that will be applied when rendering.
//
// See pango.Renderer.SetMatrix().
//
// The function returns the following values:
//
//    - matrix (optional): matrix, or NULL if no matrix has been set (which is
//      the same as the identity matrix). The returned matrix is owned by Pango
//      and must not be modified or freed.
//
func (renderer *Renderer) Matrix() *Matrix {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_gret := girepository.MustFind("Pango", "Renderer").InvokeMethod("get_matrix", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(renderer)

	var _matrix *Matrix // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_matrix = (*Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _matrix
}

// SetMatrix sets the transformation matrix that will be applied when rendering.
//
// The function takes the following parameters:
//
//    - matrix (optional): PangoMatrix, or NULL to unset any existing matrix. (No
//      matrix set is the same as setting the identity matrix.).
//
func (renderer *Renderer) SetMatrix(matrix *Matrix) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if matrix != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	girepository.MustFind("Pango", "Renderer").InvokeMethod("set_matrix", _args[:], nil)

	runtime.KeepAlive(renderer)
	runtime.KeepAlive(matrix)
}

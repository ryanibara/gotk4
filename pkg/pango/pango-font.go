// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern PangoCoverage* _gotk4_pango1_FontClass_get_coverage(void*, void*);
// extern PangoFontDescription* _gotk4_pango1_FontClass_describe(void*);
// extern PangoFontDescription* _gotk4_pango1_FontClass_describe_absolute(void*);
// extern PangoFontDescription* _gotk4_pango1_FontFaceClass_describe(void*);
// extern PangoFontFace* _gotk4_pango1_FontFamilyClass_get_face(void*, void*);
// extern PangoFontFamily* _gotk4_pango1_FontFaceClass_get_family(void*);
// extern PangoFontMap* _gotk4_pango1_FontClass_get_font_map(void*);
// extern PangoFontMetrics* _gotk4_pango1_FontClass_get_metrics(void*, void*);
// extern char* _gotk4_pango1_FontFaceClass_get_face_name(void*);
// extern char* _gotk4_pango1_FontFamilyClass_get_name(void*);
// extern gboolean _gotk4_pango1_FontFaceClass_is_synthesized(void*);
// extern gboolean _gotk4_pango1_FontFamilyClass_is_monospace(void*);
// extern gboolean _gotk4_pango1_FontFamilyClass_is_variable(void*);
// extern void _gotk4_pango1_FontClass_get_glyph_extents(void*, guint32, void*, void*);
// extern void _gotk4_pango1_FontFaceClass_list_sizes(void*, void**, void*);
// extern void _gotk4_pango1_FontFamilyClass_list_faces(void*, void***, void*);
import "C"

// GTypeStretch returns the GType for the type Stretch.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeStretch() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Stretch").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalStretch)
	return gtype
}

// GTypeStyle returns the GType for the type Style.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeStyle() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Style").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalStyle)
	return gtype
}

// GTypeVariant returns the GType for the type Variant.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeVariant() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Variant").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalVariant)
	return gtype
}

// GTypeWeight returns the GType for the type Weight.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeWeight() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Weight").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalWeight)
	return gtype
}

// GTypeFontMask returns the GType for the type FontMask.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFontMask() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "FontMask").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFontMask)
	return gtype
}

// GTypeFont returns the GType for the type Font.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFont() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Font").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFont)
	return gtype
}

// GTypeFontFace returns the GType for the type FontFace.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFontFace() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "FontFace").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFontFace)
	return gtype
}

// GTypeFontFamily returns the GType for the type FontFamily.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFontFamily() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "FontFamily").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFontFamily)
	return gtype
}

// GTypeFontDescription returns the GType for the type FontDescription.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFontDescription() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "FontDescription").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFontDescription)
	return gtype
}

// GTypeFontMetrics returns the GType for the type FontMetrics.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeFontMetrics() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "FontMetrics").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalFontMetrics)
	return gtype
}

// Stretch: enumeration specifying the width of the font relative to other
// designs within a family.
type Stretch C.gint

const (
	// StretchUltraCondensed: ultra condensed width.
	StretchUltraCondensed Stretch = iota
	// StretchExtraCondensed: extra condensed width.
	StretchExtraCondensed
	// StretchCondensed: condensed width.
	StretchCondensed
	// StretchSemiCondensed: semi condensed width.
	StretchSemiCondensed
	// StretchNormal: normal width.
	StretchNormal
	// StretchSemiExpanded: semi expanded width.
	StretchSemiExpanded
	// StretchExpanded: expanded width.
	StretchExpanded
	// StretchExtraExpanded: extra expanded width.
	StretchExtraExpanded
	// StretchUltraExpanded: ultra expanded width.
	StretchUltraExpanded
)

func marshalStretch(p uintptr) (interface{}, error) {
	return Stretch(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Stretch.
func (s Stretch) String() string {
	switch s {
	case StretchUltraCondensed:
		return "UltraCondensed"
	case StretchExtraCondensed:
		return "ExtraCondensed"
	case StretchCondensed:
		return "Condensed"
	case StretchSemiCondensed:
		return "SemiCondensed"
	case StretchNormal:
		return "Normal"
	case StretchSemiExpanded:
		return "SemiExpanded"
	case StretchExpanded:
		return "Expanded"
	case StretchExtraExpanded:
		return "ExtraExpanded"
	case StretchUltraExpanded:
		return "UltraExpanded"
	default:
		return fmt.Sprintf("Stretch(%d)", s)
	}
}

// Style: enumeration specifying the various slant styles possible for a font.
type Style C.gint

const (
	// StyleNormal: font is upright.
	StyleNormal Style = iota
	// StyleOblique: font is slanted, but in a roman style.
	StyleOblique
	// StyleItalic: font is slanted in an italic style.
	StyleItalic
)

func marshalStyle(p uintptr) (interface{}, error) {
	return Style(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Style.
func (s Style) String() string {
	switch s {
	case StyleNormal:
		return "Normal"
	case StyleOblique:
		return "Oblique"
	case StyleItalic:
		return "Italic"
	default:
		return fmt.Sprintf("Style(%d)", s)
	}
}

// Variant: enumeration specifying capitalization variant of the font.
type Variant C.gint

const (
	// VariantNormal: normal font.
	VariantNormal Variant = iota
	// VariantSmallCaps: font with the lower case characters replaced by smaller
	// variants of the capital characters.
	VariantSmallCaps
)

func marshalVariant(p uintptr) (interface{}, error) {
	return Variant(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Variant.
func (v Variant) String() string {
	switch v {
	case VariantNormal:
		return "Normal"
	case VariantSmallCaps:
		return "SmallCaps"
	default:
		return fmt.Sprintf("Variant(%d)", v)
	}
}

// Weight: enumeration specifying the weight (boldness) of a font.
//
// This is a numerical value ranging from 100 to 1000, but there are some
// predefined values.
type Weight C.gint

const (
	// WeightThin: thin weight (= 100; Since: 1.24).
	WeightThin Weight = 100
	// WeightUltralight: ultralight weight (= 200).
	WeightUltralight Weight = 200
	// WeightLight: light weight (= 300).
	WeightLight Weight = 300
	// WeightSemilight: semilight weight (= 350; Since: 1.36.7).
	WeightSemilight Weight = 350
	// WeightBook: book weight (= 380; Since: 1.24).
	WeightBook Weight = 380
	// WeightNormal: default weight (= 400).
	WeightNormal Weight = 400
	// WeightMedium: normal weight (= 500; Since: 1.24).
	WeightMedium Weight = 500
	// WeightSemibold: semibold weight (= 600).
	WeightSemibold Weight = 600
	// WeightBold: bold weight (= 700).
	WeightBold Weight = 700
	// WeightUltrabold: ultrabold weight (= 800).
	WeightUltrabold Weight = 800
	// WeightHeavy: heavy weight (= 900).
	WeightHeavy Weight = 900
	// WeightUltraheavy: ultraheavy weight (= 1000; Since: 1.24).
	WeightUltraheavy Weight = 1000
)

func marshalWeight(p uintptr) (interface{}, error) {
	return Weight(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Weight.
func (w Weight) String() string {
	switch w {
	case WeightThin:
		return "Thin"
	case WeightUltralight:
		return "Ultralight"
	case WeightLight:
		return "Light"
	case WeightSemilight:
		return "Semilight"
	case WeightBook:
		return "Book"
	case WeightNormal:
		return "Normal"
	case WeightMedium:
		return "Medium"
	case WeightSemibold:
		return "Semibold"
	case WeightBold:
		return "Bold"
	case WeightUltrabold:
		return "Ultrabold"
	case WeightHeavy:
		return "Heavy"
	case WeightUltraheavy:
		return "Ultraheavy"
	default:
		return fmt.Sprintf("Weight(%d)", w)
	}
}

// FontMask bits in a PangoFontMask correspond to the set fields in a
// PangoFontDescription.
type FontMask C.guint

const (
	// FontMaskFamily: font family is specified.
	FontMaskFamily FontMask = 0b1
	// FontMaskStyle: font style is specified.
	FontMaskStyle FontMask = 0b10
	// FontMaskVariant: font variant is specified.
	FontMaskVariant FontMask = 0b100
	// FontMaskWeight: font weight is specified.
	FontMaskWeight FontMask = 0b1000
	// FontMaskStretch: font stretch is specified.
	FontMaskStretch FontMask = 0b10000
	// FontMaskSize: font size is specified.
	FontMaskSize FontMask = 0b100000
	// FontMaskGravity: font gravity is specified (Since: 1.16.).
	FontMaskGravity FontMask = 0b1000000
	// FontMaskVariations: openType font variations are specified (Since: 1.42).
	FontMaskVariations FontMask = 0b10000000
)

func marshalFontMask(p uintptr) (interface{}, error) {
	return FontMask(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FontMask.
func (f FontMask) String() string {
	if f == 0 {
		return "FontMask(0)"
	}

	var builder strings.Builder
	builder.Grow(123)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FontMaskFamily:
			builder.WriteString("Family|")
		case FontMaskStyle:
			builder.WriteString("Style|")
		case FontMaskVariant:
			builder.WriteString("Variant|")
		case FontMaskWeight:
			builder.WriteString("Weight|")
		case FontMaskStretch:
			builder.WriteString("Stretch|")
		case FontMaskSize:
			builder.WriteString("Size|")
		case FontMaskGravity:
			builder.WriteString("Gravity|")
		case FontMaskVariations:
			builder.WriteString("Variations|")
		default:
			builder.WriteString(fmt.Sprintf("FontMask(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FontMask) Has(other FontMask) bool {
	return (f & other) == other
}

// FontOverrider contains methods that are overridable.
type FontOverrider interface {
	// Describe returns a description of the font, with font size set in points.
	//
	// Use pango.Font.DescribeWithAbsoluteSize() if you want the font size in
	// device units.
	//
	// The function returns the following values:
	//
	//    - fontDescription: newly-allocated PangoFontDescription object.
	//
	Describe() *FontDescription
	// The function returns the following values:
	//
	DescribeAbsolute() *FontDescription
	// Coverage computes the coverage map for a given font and language tag.
	//
	// The function takes the following parameters:
	//
	//    - language tag.
	//
	// The function returns the following values:
	//
	//    - coverage: newly-allocated PangoCoverage object.
	//
	Coverage(language *Language) *Coverage
	// FontMap gets the font map for which the font was created.
	//
	// Note that the font maintains a *weak* reference to the font map, so if
	// all references to font map are dropped, the font map will be finalized
	// even if there are fonts created with the font map that are still alive.
	// In that case this function will return NULL.
	//
	// It is the responsibility of the user to ensure that the font map is kept
	// alive. In most uses this is not an issue as a Context holds a reference
	// to the font map.
	//
	// The function returns the following values:
	//
	//    - fontMap (optional): PangoFontMap for the font, or NULL if font is
	//      NULL.
	//
	FontMap() FontMapper
	// GlyphExtents gets the logical and ink extents of a glyph within a font.
	//
	// The coordinate system for each rectangle has its origin at the base line
	// and horizontal origin of the character with increasing coordinates
	// extending to the right and down. The macros PANGO_ASCENT(),
	// PANGO_DESCENT(), PANGO_LBEARING(), and PANGO_RBEARING() can be used to
	// convert from the extents rectangle to more traditional font metrics. The
	// units of the rectangles are in 1/PANGO_SCALE of a device unit.
	//
	// If font is NULL, this function gracefully sets some sane values in the
	// output variables and returns.
	//
	// The function takes the following parameters:
	//
	//    - glyph index.
	//
	// The function returns the following values:
	//
	//    - inkRect (optional): rectangle used to store the extents of the glyph
	//      as drawn or NULL to indicate that the result is not needed.
	//    - logicalRect (optional): rectangle used to store the logical extents
	//      of the glyph or NULL to indicate that the result is not needed.
	//
	GlyphExtents(glyph Glyph) (inkRect, logicalRect *Rectangle)
	// Metrics gets overall metric information for a font.
	//
	// Since the metrics may be substantially different for different scripts, a
	// language tag can be provided to indicate that the metrics should be
	// retrieved that correspond to the script(s) used by that language.
	//
	// If font is NULL, this function gracefully sets some sane values in the
	// output variables and returns.
	//
	// The function takes the following parameters:
	//
	//    - language (optional) tag used to determine which script to get the
	//      metrics for, or NULL to indicate to get the metrics for the entire
	//      font.
	//
	// The function returns the following values:
	//
	//    - fontMetrics: PangoFontMetrics object. The caller must call
	//      pango.FontMetrics.Unref() when finished using the object.
	//
	Metrics(language *Language) *FontMetrics
}

// Font: PangoFont is used to represent a font in a rendering-system-independent
// manner.
type Font struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Font)(nil)
)

// Fonter describes types inherited from class Font.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Fonter interface {
	coreglib.Objector
	baseFont() *Font
}

var _ Fonter = (*Font)(nil)

func classInitFonter(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Pango", "FontClass")

	if _, ok := goval.(interface{ Describe() *FontDescription }); ok {
		o := pclass.StructFieldOffset("describe")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontClass_describe)
	}

	if _, ok := goval.(interface{ DescribeAbsolute() *FontDescription }); ok {
		o := pclass.StructFieldOffset("describe_absolute")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontClass_describe_absolute)
	}

	if _, ok := goval.(interface {
		Coverage(language *Language) *Coverage
	}); ok {
		o := pclass.StructFieldOffset("get_coverage")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontClass_get_coverage)
	}

	if _, ok := goval.(interface{ FontMap() FontMapper }); ok {
		o := pclass.StructFieldOffset("get_font_map")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontClass_get_font_map)
	}

	if _, ok := goval.(interface {
		GlyphExtents(glyph Glyph) (inkRect, logicalRect *Rectangle)
	}); ok {
		o := pclass.StructFieldOffset("get_glyph_extents")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontClass_get_glyph_extents)
	}

	if _, ok := goval.(interface {
		Metrics(language *Language) *FontMetrics
	}); ok {
		o := pclass.StructFieldOffset("get_metrics")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontClass_get_metrics)
	}
}

//export _gotk4_pango1_FontClass_describe
func _gotk4_pango1_FontClass_describe(arg0 *C.void) (cret *C.PangoFontDescription) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Describe() *FontDescription })

	fontDescription := iface.Describe()

	cret = (*C.void)(gextras.StructNative(unsafe.Pointer(fontDescription)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(fontDescription)), nil)

	return cret
}

//export _gotk4_pango1_FontClass_describe_absolute
func _gotk4_pango1_FontClass_describe_absolute(arg0 *C.void) (cret *C.PangoFontDescription) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ DescribeAbsolute() *FontDescription })

	fontDescription := iface.DescribeAbsolute()

	cret = (*C.void)(gextras.StructNative(unsafe.Pointer(fontDescription)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(fontDescription)), nil)

	return cret
}

//export _gotk4_pango1_FontClass_get_coverage
func _gotk4_pango1_FontClass_get_coverage(arg0 *C.void, arg1 *C.void) (cret *C.PangoCoverage) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Coverage(language *Language) *Coverage
	})

	var _language *Language // out

	_language = (*Language)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	coverage := iface.Coverage(_language)

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(coverage).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(coverage).Native()))

	return cret
}

//export _gotk4_pango1_FontClass_get_font_map
func _gotk4_pango1_FontClass_get_font_map(arg0 *C.void) (cret *C.PangoFontMap) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ FontMap() FontMapper })

	fontMap := iface.FontMap()

	if fontMap != nil {
		cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(fontMap).Native()))
	}

	return cret
}

//export _gotk4_pango1_FontClass_get_glyph_extents
func _gotk4_pango1_FontClass_get_glyph_extents(arg0 *C.void, arg1 C.guint32, arg2 *C.void, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		GlyphExtents(glyph Glyph) (inkRect, logicalRect *Rectangle)
	})

	var _glyph Glyph // out

	_glyph = uint32(arg1)

	inkRect, logicalRect := iface.GlyphExtents(_glyph)

	if inkRect != nil {
		if inkRect != nil {
			*arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(inkRect)))
		}
	}
	if logicalRect != nil {
		if logicalRect != nil {
			*arg3 = (*C.void)(gextras.StructNative(unsafe.Pointer(logicalRect)))
		}
	}
}

//export _gotk4_pango1_FontClass_get_metrics
func _gotk4_pango1_FontClass_get_metrics(arg0 *C.void, arg1 *C.void) (cret *C.PangoFontMetrics) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Metrics(language *Language) *FontMetrics
	})

	var _language *Language // out

	if arg1 != nil {
		_language = (*Language)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}

	fontMetrics := iface.Metrics(_language)

	cret = (*C.void)(gextras.StructNative(unsafe.Pointer(fontMetrics)))

	return cret
}

func wrapFont(obj *coreglib.Object) *Font {
	return &Font{
		Object: obj,
	}
}

func marshalFont(p uintptr) (interface{}, error) {
	return wrapFont(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (font *Font) baseFont() *Font {
	return font
}

// BaseFont returns the underlying base object.
func BaseFont(obj Fonter) *Font {
	return obj.baseFont()
}

// Describe returns a description of the font, with font size set in points.
//
// Use pango.Font.DescribeWithAbsoluteSize() if you want the font size in device
// units.
//
// The function returns the following values:
//
//    - fontDescription: newly-allocated PangoFontDescription object.
//
func (font *Font) Describe() *FontDescription {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_gret := girepository.MustFind("Pango", "Font").InvokeMethod("describe", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "FontDescription").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _fontDescription
}

// DescribeWithAbsoluteSize returns a description of the font, with absolute
// font size set in device units.
//
// Use pango.Font.Describe() if you want the font size in points.
//
// The function returns the following values:
//
//    - fontDescription: newly-allocated PangoFontDescription object.
//
func (font *Font) DescribeWithAbsoluteSize() *FontDescription {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_gret := girepository.MustFind("Pango", "Font").InvokeMethod("describe_with_absolute_size", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "FontDescription").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _fontDescription
}

// Coverage computes the coverage map for a given font and language tag.
//
// The function takes the following parameters:
//
//    - language tag.
//
// The function returns the following values:
//
//    - coverage: newly-allocated PangoCoverage object.
//
func (font *Font) Coverage(language *Language) *Coverage {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(language)))

	_gret := girepository.MustFind("Pango", "Font").InvokeMethod("get_coverage", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)
	runtime.KeepAlive(language)

	var _coverage *Coverage // out

	_coverage = wrapCoverage(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _coverage
}

// Face gets the PangoFontFace to which font belongs.
//
// The function returns the following values:
//
//    - fontFace: PangoFontFace.
//
func (font *Font) Face() FontFacer {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))

	_gret := girepository.MustFind("Pango", "Font").InvokeMethod("get_face", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)

	var _fontFace FontFacer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.FontFacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FontFacer)
			return ok
		})
		rv, ok := casted.(FontFacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
		}
		_fontFace = rv
	}

	return _fontFace
}

// FontMap gets the font map for which the font was created.
//
// Note that the font maintains a *weak* reference to the font map, so if all
// references to font map are dropped, the font map will be finalized even if
// there are fonts created with the font map that are still alive. In that case
// this function will return NULL.
//
// It is the responsibility of the user to ensure that the font map is kept
// alive. In most uses this is not an issue as a Context holds a reference to
// the font map.
//
// The function returns the following values:
//
//    - fontMap (optional): PangoFontMap for the font, or NULL if font is NULL.
//
func (font *Font) FontMap() FontMapper {
	var _args [1]girepository.Argument

	if font != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}

	_gret := girepository.MustFind("Pango", "Font").InvokeMethod("get_font_map", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)

	var _fontMap FontMapper // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontMapper)
				return ok
			})
			rv, ok := casted.(FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// GlyphExtents gets the logical and ink extents of a glyph within a font.
//
// The coordinate system for each rectangle has its origin at the base line and
// horizontal origin of the character with increasing coordinates extending to
// the right and down. The macros PANGO_ASCENT(), PANGO_DESCENT(),
// PANGO_LBEARING(), and PANGO_RBEARING() can be used to convert from the
// extents rectangle to more traditional font metrics. The units of the
// rectangles are in 1/PANGO_SCALE of a device unit.
//
// If font is NULL, this function gracefully sets some sane values in the output
// variables and returns.
//
// The function takes the following parameters:
//
//    - glyph index.
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle used to store the extents of the glyph as
//      drawn or NULL to indicate that the result is not needed.
//    - logicalRect (optional): rectangle used to store the logical extents of
//      the glyph or NULL to indicate that the result is not needed.
//
func (font *Font) GlyphExtents(glyph Glyph) (inkRect, logicalRect *Rectangle) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument

	if font != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}
	*(*C.guint32)(unsafe.Pointer(&_args[1])) = C.guint32(glyph)

	girepository.MustFind("Pango", "Font").InvokeMethod("get_glyph_extents", _args[:], _outs[:])

	runtime.KeepAlive(font)
	runtime.KeepAlive(glyph)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer(_outs[1])))
	}

	return _inkRect, _logicalRect
}

// Metrics gets overall metric information for a font.
//
// Since the metrics may be substantially different for different scripts, a
// language tag can be provided to indicate that the metrics should be retrieved
// that correspond to the script(s) used by that language.
//
// If font is NULL, this function gracefully sets some sane values in the output
// variables and returns.
//
// The function takes the following parameters:
//
//    - language (optional) tag used to determine which script to get the metrics
//      for, or NULL to indicate to get the metrics for the entire font.
//
// The function returns the following values:
//
//    - fontMetrics: PangoFontMetrics object. The caller must call
//      pango.FontMetrics.Unref() when finished using the object.
//
func (font *Font) Metrics(language *Language) *FontMetrics {
	var _args [2]girepository.Argument

	if font != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}
	if language != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(language)))
	}

	_gret := girepository.MustFind("Pango", "Font").InvokeMethod("get_metrics", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)
	runtime.KeepAlive(language)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = (*FontMetrics)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontMetrics)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _fontMetrics
}

// HasChar returns whether the font provides a glyph for this character.
//
// Returns TRUE if font can render wc.
//
// The function takes the following parameters:
//
//    - wc: unicode character.
//
// The function returns the following values:
//
func (font *Font) HasChar(wc uint32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	*(*C.gunichar)(unsafe.Pointer(&_args[1])) = C.gunichar(wc)

	_gret := girepository.MustFind("Pango", "Font").InvokeMethod("has_char", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)
	runtime.KeepAlive(wc)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// FontFaceOverrider contains methods that are overridable.
type FontFaceOverrider interface {
	// Describe returns the family, style, variant, weight and stretch of a
	// PangoFontFace. The size field of the resulting font description will be
	// unset.
	//
	// The function returns the following values:
	//
	//    - fontDescription: newly-created PangoFontDescription structure holding
	//      the description of the face. Use pango.FontDescription.Free() to free
	//      the result.
	//
	Describe() *FontDescription
	// FaceName gets a name representing the style of this face among the
	// different faces in the PangoFontFamily for the face. The name is suitable
	// for displaying to users.
	//
	// The function returns the following values:
	//
	//    - utf8: face name for the face. This string is owned by the face object
	//      and must not be modified or freed.
	//
	FaceName() string
	// Family gets the PangoFontFamily that face belongs to.
	//
	// The function returns the following values:
	//
	//    - fontFamily: PangoFontFamily.
	//
	Family() FontFamilier
	// IsSynthesized returns whether a PangoFontFace is synthesized by the
	// underlying font rendering engine from another face, perhaps by shearing,
	// emboldening, or lightening it.
	//
	// The function returns the following values:
	//
	//    - ok: whether face is synthesized.
	//
	IsSynthesized() bool
	// ListSizes: list the available sizes for a font.
	//
	// This is only applicable to bitmap fonts. For scalable fonts, stores NULL
	// at the location pointed to by sizes and 0 at the location pointed to by
	// n_sizes. The sizes returned are in Pango units and are sorted in
	// ascending order.
	//
	// The function returns the following values:
	//
	//    - sizes (optional): location to store a pointer to an array of int.
	//      This array should be freed with g_free().
	//
	ListSizes() []int32
}

// FontFace: PangoFontFace is used to represent a group of fonts with the same
// family, slant, weight, and width, but varying sizes.
type FontFace struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FontFace)(nil)
)

// FontFacer describes types inherited from class FontFace.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FontFacer interface {
	coreglib.Objector
	baseFontFace() *FontFace
}

var _ FontFacer = (*FontFace)(nil)

func classInitFontFacer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Pango", "FontFaceClass")

	if _, ok := goval.(interface{ Describe() *FontDescription }); ok {
		o := pclass.StructFieldOffset("describe")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFaceClass_describe)
	}

	if _, ok := goval.(interface{ FaceName() string }); ok {
		o := pclass.StructFieldOffset("get_face_name")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFaceClass_get_face_name)
	}

	if _, ok := goval.(interface{ Family() FontFamilier }); ok {
		o := pclass.StructFieldOffset("get_family")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFaceClass_get_family)
	}

	if _, ok := goval.(interface{ IsSynthesized() bool }); ok {
		o := pclass.StructFieldOffset("is_synthesized")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFaceClass_is_synthesized)
	}

	if _, ok := goval.(interface{ ListSizes() []int32 }); ok {
		o := pclass.StructFieldOffset("list_sizes")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFaceClass_list_sizes)
	}
}

//export _gotk4_pango1_FontFaceClass_describe
func _gotk4_pango1_FontFaceClass_describe(arg0 *C.void) (cret *C.PangoFontDescription) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Describe() *FontDescription })

	fontDescription := iface.Describe()

	cret = (*C.void)(gextras.StructNative(unsafe.Pointer(fontDescription)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(fontDescription)), nil)

	return cret
}

//export _gotk4_pango1_FontFaceClass_get_face_name
func _gotk4_pango1_FontFaceClass_get_face_name(arg0 *C.void) (cret *C.char) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ FaceName() string })

	utf8 := iface.FaceName()

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_pango1_FontFaceClass_get_family
func _gotk4_pango1_FontFaceClass_get_family(arg0 *C.void) (cret *C.PangoFontFamily) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Family() FontFamilier })

	fontFamily := iface.Family()

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(fontFamily).Native()))

	return cret
}

//export _gotk4_pango1_FontFaceClass_is_synthesized
func _gotk4_pango1_FontFaceClass_is_synthesized(arg0 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ IsSynthesized() bool })

	ok := iface.IsSynthesized()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_pango1_FontFaceClass_list_sizes
func _gotk4_pango1_FontFaceClass_list_sizes(arg0 *C.void, arg1 **C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ListSizes() []int32 })

	sizes := iface.ListSizes()

	*arg2 = (*C.void)(len(sizes))
	*arg1 = (*C.void)(C.calloc(C.size_t(len(sizes)), C.size_t(unsafe.Sizeof(uint(0)))))
	{
		out := unsafe.Slice((**C.void)(*arg1), len(sizes))
		for i := range sizes {
			out[i] = (*C.void)(unsafe.Pointer(sizes[i]))
		}
	}
}

func wrapFontFace(obj *coreglib.Object) *FontFace {
	return &FontFace{
		Object: obj,
	}
}

func marshalFontFace(p uintptr) (interface{}, error) {
	return wrapFontFace(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (face *FontFace) baseFontFace() *FontFace {
	return face
}

// BaseFontFace returns the underlying base object.
func BaseFontFace(obj FontFacer) *FontFace {
	return obj.baseFontFace()
}

// Describe returns the family, style, variant, weight and stretch of a
// PangoFontFace. The size field of the resulting font description will be
// unset.
//
// The function returns the following values:
//
//    - fontDescription: newly-created PangoFontDescription structure holding the
//      description of the face. Use pango.FontDescription.Free() to free the
//      result.
//
func (face *FontFace) Describe() *FontDescription {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_gret := girepository.MustFind("Pango", "FontFace").InvokeMethod("describe", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(face)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "FontDescription").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _fontDescription
}

// FaceName gets a name representing the style of this face among the different
// faces in the PangoFontFamily for the face. The name is suitable for
// displaying to users.
//
// The function returns the following values:
//
//    - utf8: face name for the face. This string is owned by the face object and
//      must not be modified or freed.
//
func (face *FontFace) FaceName() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_gret := girepository.MustFind("Pango", "FontFace").InvokeMethod("get_face_name", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(face)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Family gets the PangoFontFamily that face belongs to.
//
// The function returns the following values:
//
//    - fontFamily: PangoFontFamily.
//
func (face *FontFace) Family() FontFamilier {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_gret := girepository.MustFind("Pango", "FontFace").InvokeMethod("get_family", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(face)

	var _fontFamily FontFamilier // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.FontFamilier is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FontFamilier)
			return ok
		})
		rv, ok := casted.(FontFamilier)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
		}
		_fontFamily = rv
	}

	return _fontFamily
}

// IsSynthesized returns whether a PangoFontFace is synthesized by the
// underlying font rendering engine from another face, perhaps by shearing,
// emboldening, or lightening it.
//
// The function returns the following values:
//
//    - ok: whether face is synthesized.
//
func (face *FontFace) IsSynthesized() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	_gret := girepository.MustFind("Pango", "FontFace").InvokeMethod("is_synthesized", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(face)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ListSizes: list the available sizes for a font.
//
// This is only applicable to bitmap fonts. For scalable fonts, stores NULL at
// the location pointed to by sizes and 0 at the location pointed to by n_sizes.
// The sizes returned are in Pango units and are sorted in ascending order.
//
// The function returns the following values:
//
//    - sizes (optional): location to store a pointer to an array of int. This
//      array should be freed with g_free().
//
func (face *FontFace) ListSizes() []int32 {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(face).Native()))

	girepository.MustFind("Pango", "FontFace").InvokeMethod("list_sizes", _args[:], _outs[:])

	runtime.KeepAlive(face)

	var _sizes []int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		defer C.free(unsafe.Pointer(_outs[0]))
		{
			src := unsafe.Slice((**C.void)(_outs[0]), _outs[1])
			_sizes = make([]int32, _outs[1])
			for i := 0; i < int(_outs[1]); i++ {
				_sizes[i] = *(*int32)(unsafe.Pointer(src[i]))
			}
		}
	}

	return _sizes
}

// FontFamilyOverrider contains methods that are overridable.
type FontFamilyOverrider interface {
	// Face gets the PangoFontFace of family with the given name.
	//
	// The function takes the following parameters:
	//
	//    - name (optional) of a face. If the name is NULL, the family's default
	//      face (fontconfig calls it "Regular") will be returned.
	//
	// The function returns the following values:
	//
	//    - fontFace (optional): PangoFontFace, or NULL if no face with the given
	//      name exists.
	//
	Face(name string) FontFacer
	// Name gets the name of the family.
	//
	// The name is unique among all fonts for the font backend and can be used
	// in a PangoFontDescription to specify that a face from this family is
	// desired.
	//
	// The function returns the following values:
	//
	//    - utf8: name of the family. This string is owned by the family object
	//      and must not be modified or freed.
	//
	Name() string
	// IsMonospace: monospace font is a font designed for text display where the
	// the characters form a regular grid.
	//
	// For Western languages this would mean that the advance width of all
	// characters are the same, but this categorization also includes Asian
	// fonts which include double-width characters: characters that occupy two
	// grid cells. g_unichar_iswide() returns a result that indicates whether a
	// character is typically double-width in a monospace font.
	//
	// The best way to find out the grid-cell size is to call
	// pango.FontMetrics.GetApproximateDigitWidth(), since the results of
	// pango.FontMetrics.GetApproximateCharWidth() may be affected by
	// double-width characters.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the family is monospace.
	//
	IsMonospace() bool
	// IsVariable: variable font is a font which has axes that can be modified
	// to produce different faces.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the family is variable.
	//
	IsVariable() bool
	// ListFaces lists the different font faces that make up family.
	//
	// The faces in a family share a common design, but differ in slant, weight,
	// width and other aspects.
	//
	// The function returns the following values:
	//
	//    - faces (optional): location to store an array of pointers to
	//      PangoFontFace objects, or NULL. This array should be freed with
	//      g_free() when it is no longer needed.
	//
	ListFaces() []FontFacer
}

// FontFamily: PangoFontFamily is used to represent a family of related font
// faces.
//
// The font faces in a family share a common design, but differ in slant,
// weight, width or other aspects.
type FontFamily struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FontFamily)(nil)
)

// FontFamilier describes types inherited from class FontFamily.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type FontFamilier interface {
	coreglib.Objector
	baseFontFamily() *FontFamily
}

var _ FontFamilier = (*FontFamily)(nil)

func classInitFontFamilier(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Pango", "FontFamilyClass")

	if _, ok := goval.(interface{ Face(name string) FontFacer }); ok {
		o := pclass.StructFieldOffset("get_face")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFamilyClass_get_face)
	}

	if _, ok := goval.(interface{ Name() string }); ok {
		o := pclass.StructFieldOffset("get_name")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFamilyClass_get_name)
	}

	if _, ok := goval.(interface{ IsMonospace() bool }); ok {
		o := pclass.StructFieldOffset("is_monospace")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFamilyClass_is_monospace)
	}

	if _, ok := goval.(interface{ IsVariable() bool }); ok {
		o := pclass.StructFieldOffset("is_variable")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFamilyClass_is_variable)
	}

	if _, ok := goval.(interface{ ListFaces() []FontFacer }); ok {
		o := pclass.StructFieldOffset("list_faces")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_pango1_FontFamilyClass_list_faces)
	}
}

//export _gotk4_pango1_FontFamilyClass_get_face
func _gotk4_pango1_FontFamilyClass_get_face(arg0 *C.void, arg1 *C.void) (cret *C.PangoFontFace) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Face(name string) FontFacer })

	var _name string // out

	if arg1 != nil {
		_name = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}

	fontFace := iface.Face(_name)

	if fontFace != nil {
		cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(fontFace).Native()))
	}

	return cret
}

//export _gotk4_pango1_FontFamilyClass_get_name
func _gotk4_pango1_FontFamilyClass_get_name(arg0 *C.void) (cret *C.char) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Name() string })

	utf8 := iface.Name()

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_pango1_FontFamilyClass_is_monospace
func _gotk4_pango1_FontFamilyClass_is_monospace(arg0 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ IsMonospace() bool })

	ok := iface.IsMonospace()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_pango1_FontFamilyClass_is_variable
func _gotk4_pango1_FontFamilyClass_is_variable(arg0 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ IsVariable() bool })

	ok := iface.IsVariable()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_pango1_FontFamilyClass_list_faces
func _gotk4_pango1_FontFamilyClass_list_faces(arg0 *C.void, arg1 ***C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ListFaces() []FontFacer })

	faces := iface.ListFaces()

	if faces != nil {
		*arg2 = (*C.void)(len(faces))
		*arg1 = (**C.void)(C.calloc(C.size_t(len(faces)), C.size_t(unsafe.Sizeof(uint(0)))))
		{
			out := unsafe.Slice((**C.void)(*arg1), len(faces))
			for i := range faces {
				out[i] = (*C.void)(unsafe.Pointer(coreglib.InternObject(faces[i]).Native()))
			}
		}
	}
}

func wrapFontFamily(obj *coreglib.Object) *FontFamily {
	return &FontFamily{
		Object: obj,
	}
}

func marshalFontFamily(p uintptr) (interface{}, error) {
	return wrapFontFamily(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (family *FontFamily) baseFontFamily() *FontFamily {
	return family
}

// BaseFontFamily returns the underlying base object.
func BaseFontFamily(obj FontFamilier) *FontFamily {
	return obj.baseFontFamily()
}

// Face gets the PangoFontFace of family with the given name.
//
// The function takes the following parameters:
//
//    - name (optional) of a face. If the name is NULL, the family's default face
//      (fontconfig calls it "Regular") will be returned.
//
// The function returns the following values:
//
//    - fontFace (optional): PangoFontFace, or NULL if no face with the given
//      name exists.
//
func (family *FontFamily) Face(name string) FontFacer {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(family).Native()))
	if name != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_args[1]))
	}

	_gret := girepository.MustFind("Pango", "FontFamily").InvokeMethod("get_face", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(family)
	runtime.KeepAlive(name)

	var _fontFace FontFacer // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontFacer)
				return ok
			})
			rv, ok := casted.(FontFacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
			}
			_fontFace = rv
		}
	}

	return _fontFace
}

// Name gets the name of the family.
//
// The name is unique among all fonts for the font backend and can be used in a
// PangoFontDescription to specify that a face from this family is desired.
//
// The function returns the following values:
//
//    - utf8: name of the family. This string is owned by the family object and
//      must not be modified or freed.
//
func (family *FontFamily) Name() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_gret := girepository.MustFind("Pango", "FontFamily").InvokeMethod("get_name", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(family)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsMonospace: monospace font is a font designed for text display where the the
// characters form a regular grid.
//
// For Western languages this would mean that the advance width of all
// characters are the same, but this categorization also includes Asian fonts
// which include double-width characters: characters that occupy two grid cells.
// g_unichar_iswide() returns a result that indicates whether a character is
// typically double-width in a monospace font.
//
// The best way to find out the grid-cell size is to call
// pango.FontMetrics.GetApproximateDigitWidth(), since the results of
// pango.FontMetrics.GetApproximateCharWidth() may be affected by double-width
// characters.
//
// The function returns the following values:
//
//    - ok: TRUE if the family is monospace.
//
func (family *FontFamily) IsMonospace() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_gret := girepository.MustFind("Pango", "FontFamily").InvokeMethod("is_monospace", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(family)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsVariable: variable font is a font which has axes that can be modified to
// produce different faces.
//
// The function returns the following values:
//
//    - ok: TRUE if the family is variable.
//
func (family *FontFamily) IsVariable() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	_gret := girepository.MustFind("Pango", "FontFamily").InvokeMethod("is_variable", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(family)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ListFaces lists the different font faces that make up family.
//
// The faces in a family share a common design, but differ in slant, weight,
// width and other aspects.
//
// The function returns the following values:
//
//    - faces (optional): location to store an array of pointers to PangoFontFace
//      objects, or NULL. This array should be freed with g_free() when it is no
//      longer needed.
//
func (family *FontFamily) ListFaces() []FontFacer {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(family).Native()))

	girepository.MustFind("Pango", "FontFamily").InvokeMethod("list_faces", _args[:], _outs[:])

	runtime.KeepAlive(family)

	var _faces []FontFacer // out

	if *(***C.void)(unsafe.Pointer(&_outs[0])) != nil {
		defer C.free(unsafe.Pointer(_outs[0]))
		{
			src := unsafe.Slice((**C.void)(_outs[0]), _outs[1])
			_faces = make([]FontFacer, _outs[1])
			for i := 0; i < int(_outs[1]); i++ {
				{
					objptr := unsafe.Pointer(src[i])
					if objptr == nil {
						panic("object of type pango.FontFacer is nil")
					}

					object := coreglib.Take(objptr)
					casted := object.WalkCast(func(obj coreglib.Objector) bool {
						_, ok := obj.(FontFacer)
						return ok
					})
					rv, ok := casted.(FontFacer)
					if !ok {
						panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
					}
					_faces[i] = rv
				}
			}
		}
	}

	return _faces
}

// FontDescription: PangoFontDescription describes a font in an
// implementation-independent manner.
//
// PangoFontDescription structures are used both to list what fonts are
// available on the system and also for specifying the characteristics of a font
// to load.
//
// An instance of this type is always passed by reference.
type FontDescription struct {
	*fontDescription
}

// fontDescription is the struct that's finalized.
type fontDescription struct {
	native unsafe.Pointer
}

func marshalFontDescription(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FontDescription{&fontDescription{(unsafe.Pointer)(b)}}, nil
}

// NewFontDescription constructs a struct FontDescription.
func NewFontDescription() *FontDescription {
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "FontDescription").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _fontDescription
}

// BetterMatch determines if the style attributes of new_match are a closer
// match for desc than those of old_match are, or if old_match is NULL,
// determines if new_match is a match at all.
//
// Approximate matching is done for weight and style; other style attributes
// must match exactly. Style attributes are all attributes other than family and
// size-related attributes. Approximate matching for style considers
// PANGO_STYLE_OBLIQUE and PANGO_STYLE_ITALIC as matches, but not as good a
// match as when the styles are equal.
//
// Note that old_match must match desc.
//
// The function takes the following parameters:
//
//    - oldMatch (optional): PangoFontDescription, or NULL.
//    - newMatch: PangoFontDescription.
//
// The function returns the following values:
//
//    - ok: TRUE if new_match is a better match.
//
func (desc *FontDescription) BetterMatch(oldMatch *FontDescription, newMatch *FontDescription) bool {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	if oldMatch != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(oldMatch)))
	}
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(newMatch)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)
	runtime.KeepAlive(oldMatch)
	runtime.KeepAlive(newMatch)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Copy: make a copy of a PangoFontDescription.
//
// The function returns the following values:
//
//    - fontDescription (optional): newly allocated PangoFontDescription, which
//      should be freed with pango.FontDescription.Free(), or NULL if desc was
//      NULL.
//
func (desc *FontDescription) Copy() *FontDescription {
	var _args [1]girepository.Argument

	if desc != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	}

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _fontDescription *FontDescription // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_fontDescription)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Pango", "FontDescription").InvokeMethod("free", args[:], nil)
				}
			},
		)
	}

	return _fontDescription
}

// CopyStatic: make a copy of a PangoFontDescription, but don't duplicate
// allocated fields.
//
// This is like pango.FontDescription.Copy(), but only a shallow copy is made of
// the family name and other allocated fields. The result can only be used until
// desc is modified or freed. This is meant to be used when the copy is only
// needed temporarily.
//
// The function returns the following values:
//
//    - fontDescription (optional): newly allocated PangoFontDescription, which
//      should be freed with pango.FontDescription.Free(), or NULL if desc was
//      NULL.
//
func (desc *FontDescription) CopyStatic() *FontDescription {
	var _args [1]girepository.Argument

	if desc != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	}

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _fontDescription *FontDescription // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_fontDescription)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Pango", "FontDescription").InvokeMethod("free", args[:], nil)
				}
			},
		)
	}

	return _fontDescription
}

// Equal compares two font descriptions for equality.
//
// Two font descriptions are considered equal if the fonts they describe are
// provably identical. This means that their masks do not have to match, as long
// as other fields are all the same. (Two font descriptions may result in
// identical fonts being loaded, but still compare FALSE.).
//
// The function takes the following parameters:
//
//    - desc2: another PangoFontDescription.
//
// The function returns the following values:
//
//    - ok: TRUE if the two font descriptions are identical, FALSE otherwise.
//
func (desc1 *FontDescription) Equal(desc2 *FontDescription) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc1)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc2)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc1)
	runtime.KeepAlive(desc2)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Family gets the family name field of a font description.
//
// See pango.FontDescription.SetFamily().
//
// The function returns the following values:
//
//    - utf8 (optional): family name field for the font description, or NULL if
//      not previously set. This has the same life-time as the font description
//      itself and should not be freed.
//
func (desc *FontDescription) Family() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _utf8 string // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Size gets the size field of a font description.
//
// See pango.FontDescription.SetSize().
//
// The function returns the following values:
//
//    - gint: size field for the font description in points or device units. You
//      must call pango.FontDescription.GetSizeIsAbsolute() to find out which is
//      the case. Returns 0 if the size field has not previously been set or it
//      has been set to 0 explicitly. Use pango.FontDescription.GetSetFields() to
//      find out if the field was explicitly set or not.
//
func (desc *FontDescription) Size() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// SizeIsAbsolute determines whether the size of the font is in points (not
// absolute) or device units (absolute).
//
// See pango.FontDescription.SetSize() and
// pango.FontDescription.SetAbsoluteSize().
//
// The function returns the following values:
//
//    - ok: whether the size for the font description is in points or device
//      units. Use pango.FontDescription.GetSetFields() to find out if the size
//      field of the font description was explicitly set or not.
//
func (desc *FontDescription) SizeIsAbsolute() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Variations gets the variations field of a font description.
//
// See pango.FontDescription.SetVariations().
//
// The function returns the following values:
//
//    - utf8 (optional) variations field for the font description, or NULL if not
//      previously set. This has the same life-time as the font description
//      itself and should not be freed.
//
func (desc *FontDescription) Variations() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _utf8 string // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Hash computes a hash of a PangoFontDescription structure.
//
// This is suitable to be used, for example, as an argument to
// g_hash_table_new(). The hash value is independent of desc->mask.
//
// The function returns the following values:
//
//    - guint: hash value.
//
func (desc *FontDescription) Hash() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Merge merges the fields that are set in desc_to_merge into the fields in
// desc.
//
// If replace_existing is FALSE, only fields in desc that are not already set
// are affected. If TRUE, then fields that are already set will be replaced as
// well.
//
// If desc_to_merge is NULL, this function performs nothing.
//
// The function takes the following parameters:
//
//    - descToMerge (optional): PangoFontDescription to merge from, or NULL.
//    - replaceExisting: if TRUE, replace fields in desc with the corresponding
//      values from desc_to_merge, even if they are already exist.
//
func (desc *FontDescription) Merge(descToMerge *FontDescription, replaceExisting bool) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	if descToMerge != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(descToMerge)))
	}
	if replaceExisting {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	runtime.KeepAlive(desc)
	runtime.KeepAlive(descToMerge)
	runtime.KeepAlive(replaceExisting)
}

// MergeStatic merges the fields that are set in desc_to_merge into the fields
// in desc, without copying allocated fields.
//
// This is like pango.FontDescription.Merge(), but only a shallow copy is made
// of the family name and other allocated fields. desc can only be used until
// desc_to_merge is modified or freed. This is meant to be used when the merged
// font description is only needed temporarily.
//
// The function takes the following parameters:
//
//    - descToMerge: PangoFontDescription to merge from.
//    - replaceExisting: if TRUE, replace fields in desc with the corresponding
//      values from desc_to_merge, even if they are already exist.
//
func (desc *FontDescription) MergeStatic(descToMerge *FontDescription, replaceExisting bool) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(descToMerge)))
	if replaceExisting {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	runtime.KeepAlive(desc)
	runtime.KeepAlive(descToMerge)
	runtime.KeepAlive(replaceExisting)
}

// SetAbsoluteSize sets the size field of a font description, in device units.
//
// This is mutually exclusive with pango.FontDescription.SetSize() which sets
// the font size in points.
//
// The function takes the following parameters:
//
//    - size: new size, in Pango units. There are PANGO_SCALE Pango units in one
//      device unit. For an output backend where a device unit is a pixel, a size
//      value of 10 * PANGO_SCALE gives a 10 pixel font.
//
func (desc *FontDescription) SetAbsoluteSize(size float64) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	*(*C.double)(unsafe.Pointer(&_args[1])) = C.double(size)

	runtime.KeepAlive(desc)
	runtime.KeepAlive(size)
}

// SetFamily sets the family name field of a font description.
//
// The family name represents a family of related font styles, and will resolve
// to a particular PangoFontFamily. In some uses of PangoFontDescription, it is
// also possible to use a comma separated list of family names for this field.
//
// The function takes the following parameters:
//
//    - family: string representing the family name.
//
func (desc *FontDescription) SetFamily(family string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(family)))
	defer C.free(unsafe.Pointer(_args[1]))

	runtime.KeepAlive(desc)
	runtime.KeepAlive(family)
}

// SetFamilyStatic sets the family name field of a font description, without
// copying the string.
//
// This is like pango.FontDescription.SetFamily(), except that no copy of family
// is made. The caller must make sure that the string passed in stays around
// until desc has been freed or the name is set again. This function can be used
// if family is a static string such as a C string literal, or if desc is only
// needed temporarily.
//
// The function takes the following parameters:
//
//    - family: string representing the family name.
//
func (desc *FontDescription) SetFamilyStatic(family string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(family)))
	defer C.free(unsafe.Pointer(_args[1]))

	runtime.KeepAlive(desc)
	runtime.KeepAlive(family)
}

// SetSize sets the size field of a font description in fractional points.
//
// This is mutually exclusive with pango.FontDescription.SetAbsoluteSize().
//
// The function takes the following parameters:
//
//    - size of the font in points, scaled by PANGO_SCALE. (That is, a size value
//      of 10 * PANGO_SCALE is a 10 point font. The conversion factor between
//      points and device units depends on system configuration and the output
//      device. For screen display, a logical DPI of 96 is common, in which case
//      a 10 point font corresponds to a 10 * (96 / 72) = 13.3 pixel font. Use
//      pango.FontDescription.SetAbsoluteSize() if you need a particular size in
//      device units.
//
func (desc *FontDescription) SetSize(size int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(size)

	runtime.KeepAlive(desc)
	runtime.KeepAlive(size)
}

// SetVariations sets the variations field of a font description.
//
// OpenType font variations allow to select a font instance by specifying values
// for a number of axes, such as width or weight.
//
// The format of the variations string is
//
//    AXIS1=VALUE,AXIS2=VALUE...
//
// with each AXIS a 4 character tag that identifies a font axis, and each VALUE
// a floating point number. Unknown axes are ignored, and values are clamped to
// their allowed range.
//
// Pango does not currently have a way to find supported axes of a font. Both
// harfbuzz or freetype have API for this.
//
// The function takes the following parameters:
//
//    - variations: string representing the variations.
//
func (desc *FontDescription) SetVariations(variations string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(variations)))
	defer C.free(unsafe.Pointer(_args[1]))

	runtime.KeepAlive(desc)
	runtime.KeepAlive(variations)
}

// SetVariationsStatic sets the variations field of a font description.
//
// This is like pango.FontDescription.SetVariations(), except that no copy of
// variations is made. The caller must make sure that the string passed in stays
// around until desc has been freed or the name is set again. This function can
// be used if variations is a static string such as a C string literal, or if
// desc is only needed temporarily.
//
// The function takes the following parameters:
//
//    - variations: string representing the variations.
//
func (desc *FontDescription) SetVariationsStatic(variations string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(variations)))
	defer C.free(unsafe.Pointer(_args[1]))

	runtime.KeepAlive(desc)
	runtime.KeepAlive(variations)
}

// ToFilename creates a filename representation of a font description.
//
// The filename is identical to the result from calling
// pango.FontDescription.ToString(), but with underscores instead of characters
// that are untypical in filenames, and in lower case only.
//
// The function returns the following values:
//
//    - utf8: new string that must be freed with g_free().
//
func (desc *FontDescription) ToFilename() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String creates a string representation of a font description.
//
// See pango.FontDescription.FromString for a description of the format of the
// string representation. The family list in the string description will only
// have a terminating comma if the last word of the list is a valid style
// option.
//
// The function returns the following values:
//
//    - utf8: new string that must be freed with g_free().
//
func (desc *FontDescription) String() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(desc)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(desc)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FontDescriptionFromString creates a new font description from a string
// representation.
//
// The string must have the form
//
//    "\[FAMILY-LIST] \[STYLE-OPTIONS] \[SIZE] \[VARIATIONS]",
//
// where FAMILY-LIST is a comma-separated list of families optionally terminated
// by a comma, STYLE_OPTIONS is a whitespace-separated list of words where each
// word describes one of style, variant, weight, stretch, or gravity, and SIZE
// is a decimal number (size in points) or optionally followed by the unit
// modifier "px" for absolute size. VARIATIONS is a comma-separated list of font
// variation specifications of the form "\axis=value" (the = sign is optional).
//
// The following words are understood as styles: "Normal", "Roman", "Oblique",
// "Italic".
//
// The following words are understood as variants: "Small-Caps".
//
// The following words are understood as weights: "Thin", "Ultra-Light",
// "Extra-Light", "Light", "Semi-Light", "Demi-Light", "Book", "Regular",
// "Medium", "Semi-Bold", "Demi-Bold", "Bold", "Ultra-Bold", "Extra-Bold",
// "Heavy", "Black", "Ultra-Black", "Extra-Black".
//
// The following words are understood as stretch values: "Ultra-Condensed",
// "Extra-Condensed", "Condensed", "Semi-Condensed", "Semi-Expanded",
// "Expanded", "Extra-Expanded", "Ultra-Expanded".
//
// The following words are understood as gravity values: "Not-Rotated", "South",
// "Upside-Down", "North", "Rotated-Left", "East", "Rotated-Right", "West".
//
// Any one of the options may be absent. If FAMILY-LIST is absent, then the
// family_name field of the resulting font description will be initialized to
// NULL. If STYLE-OPTIONS is missing, then all style options will be set to the
// default values. If SIZE is missing, the size in the resulting font
// description will be set to 0.
//
// A typical example:
//
//    "Cantarell Italic Light 15 \wght=200".
//
// The function takes the following parameters:
//
//    - str: string representation of a font description.
//
// The function returns the following values:
//
//    - fontDescription: new PangoFontDescription.
//
func FontDescriptionFromString(str string) *FontDescription {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Pango", "from_string").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _fontDescription *FontDescription // out

	_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_fontDescription)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Pango", "FontDescription").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _fontDescription
}

// FontMetrics: PangoFontMetrics structure holds the overall metric information
// for a font.
//
// The information in a PangoFontMetrics structure may be restricted to a
// script. The fields of this structure are private to implementations of a font
// backend. See the documentation of the corresponding getters for documentation
// of their meaning.
//
// An instance of this type is always passed by reference.
type FontMetrics struct {
	*fontMetrics
}

// fontMetrics is the struct that's finalized.
type fontMetrics struct {
	native unsafe.Pointer
}

func marshalFontMetrics(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &FontMetrics{&fontMetrics{(unsafe.Pointer)(b)}}, nil
}

// ApproximateCharWidth gets the approximate character width for a font metrics
// structure.
//
// This is merely a representative value useful, for example, for determining
// the initial size for a window. Actual characters in text will be wider and
// narrower than this.
//
// The function returns the following values:
//
//    - gint: character width, in Pango units.
//
func (metrics *FontMetrics) ApproximateCharWidth() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// ApproximateDigitWidth gets the approximate digit width for a font metrics
// structure.
//
// This is merely a representative value useful, for example, for determining
// the initial size for a window. Actual digits in text can be wider or narrower
// than this, though this value is generally somewhat more accurate than the
// result of pango_font_metrics_get_approximate_char_width() for digits.
//
// The function returns the following values:
//
//    - gint: digit width, in Pango units.
//
func (metrics *FontMetrics) ApproximateDigitWidth() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// Ascent gets the ascent from a font metrics structure.
//
// The ascent is the distance from the baseline to the logical top of a line of
// text. (The logical top may be above or below the top of the actual drawn ink.
// It is necessary to lay out the text to figure where the ink will be.).
//
// The function returns the following values:
//
//    - gint: ascent, in Pango units.
//
func (metrics *FontMetrics) Ascent() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// Descent gets the descent from a font metrics structure.
//
// The descent is the distance from the baseline to the logical bottom of a line
// of text. (The logical bottom may be above or below the bottom of the actual
// drawn ink. It is necessary to lay out the text to figure where the ink will
// be.).
//
// The function returns the following values:
//
//    - gint: descent, in Pango units.
//
func (metrics *FontMetrics) Descent() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// Height gets the line height from a font metrics structure.
//
// The line height is the distance between successive baselines in wrapped text.
//
// If the line height is not available, 0 is returned.
//
// The function returns the following values:
//
//    - gint: height, in Pango units.
//
func (metrics *FontMetrics) Height() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// StrikethroughPosition gets the suggested position to draw the strikethrough.
//
// The value returned is the distance *above* the baseline of the top of the
// strikethrough.
//
// The function returns the following values:
//
//    - gint: suggested strikethrough position, in Pango units.
//
func (metrics *FontMetrics) StrikethroughPosition() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// StrikethroughThickness gets the suggested thickness to draw for the
// strikethrough.
//
// The function returns the following values:
//
//    - gint: suggested strikethrough thickness, in Pango units.
//
func (metrics *FontMetrics) StrikethroughThickness() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// UnderlinePosition gets the suggested position to draw the underline.
//
// The value returned is the distance *above* the baseline of the top of the
// underline. Since most fonts have underline positions beneath the baseline,
// this value is typically negative.
//
// The function returns the following values:
//
//    - gint: suggested underline position, in Pango units.
//
func (metrics *FontMetrics) UnderlinePosition() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// UnderlineThickness gets the suggested thickness to draw for the underline.
//
// The function returns the following values:
//
//    - gint: suggested underline thickness, in Pango units.
//
func (metrics *FontMetrics) UnderlineThickness() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(metrics)))

	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(metrics)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

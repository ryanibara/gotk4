// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

// ParseEnum parses an enum type and stores the result in value.
//
// If str does not match the nick name of any of the possible values for the
// enum and is not an integer, FALSE is returned, a warning is issued if warn
// is TRUE, and a string representing the list of possible values is stored in
// possible_values. The list is slash-separated, eg. "none/start/middle/end".
// If failed and possible_values is not NULL, returned string should be freed
// using g_free().
//
// Deprecated: since version 1.38.
//
// The function takes the following parameters:
//
//   - typ: enum type to parse, eg. PANGO_TYPE_ELLIPSIZE_MODE.
//   - str (optional): string to parse. May be NULL.
//   - warn: if TRUE, issue a g_warning() on bad input.
//
// The function returns the following values:
//
//   - value (optional): integer to store the result in, or NULL.
//   - possibleValues (optional): place to store list of possible values on
//     failure, or NULL.
//   - ok: TRUE if str was successfully parsed.
//
func ParseEnum(typ coreglib.Type, str string, warn bool) (int, string, bool) {
	var _arg1 C.GType    // out
	var _arg2 *C.char    // out
	var _arg3 C.int      // in
	var _arg4 C.gboolean // out
	var _arg5 *C.char    // in
	var _cret C.gboolean // in

	_arg1 = C.GType(typ)
	if str != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if warn {
		_arg4 = C.TRUE
	}

	_cret = C.pango_parse_enum(_arg1, _arg2, &_arg3, _arg4, &_arg5)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(str)
	runtime.KeepAlive(warn)

	var _value int             // out
	var _possibleValues string // out
	var _ok bool               // out

	_value = int(_arg3)
	if _arg5 != nil {
		_possibleValues = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if _cret != 0 {
		_ok = true
	}

	return _value, _possibleValues, _ok
}

// Version returns the encoded version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION except that the macro returns the
// encoded version available at compile-time. A version number can be encoded
// into an integer using PANGO_VERSION_ENCODE().
//
// The function returns the following values:
//
//   - gint: encoded version of Pango library available at run time.
//
func Version() int {
	var _cret C.int // in

	_cret = C.pango_version()

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VersionCheck checks that the Pango library in use is compatible with the
// given version.
//
// Generally you would pass in the constants PANGO_VERSION_MAJOR,
// PANGO_VERSION_MINOR, PANGO_VERSION_MICRO as the three arguments to this
// function; that produces a check that the library in use at run-time is
// compatible with the version of Pango the application or module was compiled
// against.
//
// Compatibility is defined by two things: first the
// version of the running library is newer than the version
// required_major.required_minor.required_micro. Second the
// running library must be binary compatible with the version
// required_major.required_minor.required_micro (same major version.)
//
// For compile-time version checking use PANGO_VERSION_CHECK().
//
// The function takes the following parameters:
//
//   - requiredMajor: required major version.
//   - requiredMinor: required minor version.
//   - requiredMicro: required major version.
//
// The function returns the following values:
//
//   - utf8 (optional): NULL if the Pango library is compatible with the given
//     version, or a string describing the version mismatch. The returned string
//     is owned by Pango and should not be modified or freed.
//
func VersionCheck(requiredMajor, requiredMinor, requiredMicro int) string {
	var _arg1 C.int   // out
	var _arg2 C.int   // out
	var _arg3 C.int   // out
	var _cret *C.char // in

	_arg1 = C.int(requiredMajor)
	_arg2 = C.int(requiredMinor)
	_arg3 = C.int(requiredMicro)

	_cret = C.pango_version_check(_arg1, _arg2, _arg3)
	runtime.KeepAlive(requiredMajor)
	runtime.KeepAlive(requiredMinor)
	runtime.KeepAlive(requiredMicro)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// VersionString returns the version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION_STRING except that the macro
// returns the version available at compile-time.
//
// The function returns the following values:
//
//   - utf8: string containing the version of Pango library available at run
//     time. The returned string is owned by Pango and should not be modified or
//     freed.
//
func VersionString() string {
	var _cret *C.char // in

	_cret = C.pango_version_string()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

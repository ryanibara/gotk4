// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_alignment_get_type()), F: marshalAlignment},
		{T: externglib.Type(C.pango_ellipsize_mode_get_type()), F: marshalEllipsizeMode},
		{T: externglib.Type(C.pango_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.pango_layout_get_type()), F: marshalLayouter},
		{T: externglib.Type(C.pango_layout_iter_get_type()), F: marshalLayoutIter},
		{T: externglib.Type(C.pango_layout_line_get_type()), F: marshalLayoutLine},
	})
}

// LayoutRun: PangoLayoutRun represents a single run within a PangoLayoutLine.
//
// It is simply an alternate name for pango.GlyphItem. See the pango.GlyphItem
// docs for details on the fields.
type LayoutRun = GlyphItem

// Alignment: PangoAlignment describes how to align the lines of a PangoLayout
// within the available space.
//
// If the PangoLayout is set to justify using pango.Layout.SetJustify(), this
// only has effect for partial lines.
type Alignment C.gint

const (
	// AlignLeft: put all available space on the right.
	AlignLeft Alignment = iota
	// AlignCenter: center the line within the available space.
	AlignCenter
	// AlignRight: put all available space on the left.
	AlignRight
)

func marshalAlignment(p uintptr) (interface{}, error) {
	return Alignment(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Alignment.
func (a Alignment) String() string {
	switch a {
	case AlignLeft:
		return "Left"
	case AlignCenter:
		return "Center"
	case AlignRight:
		return "Right"
	default:
		return fmt.Sprintf("Alignment(%d)", a)
	}
}

// EllipsizeMode: PangoEllipsizeMode describes what sort of ellipsization should
// be applied to text.
//
// In the ellipsization process characters are removed from the text in order to
// make it fit to a given width and replaced with an ellipsis.
type EllipsizeMode C.gint

const (
	// EllipsizeNone: no ellipsization.
	EllipsizeNone EllipsizeMode = iota
	// EllipsizeStart: omit characters at the start of the text.
	EllipsizeStart
	// EllipsizeMiddle: omit characters in the middle of the text.
	EllipsizeMiddle
	// EllipsizeEnd: omit characters at the end of the text.
	EllipsizeEnd
)

func marshalEllipsizeMode(p uintptr) (interface{}, error) {
	return EllipsizeMode(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EllipsizeMode.
func (e EllipsizeMode) String() string {
	switch e {
	case EllipsizeNone:
		return "None"
	case EllipsizeStart:
		return "Start"
	case EllipsizeMiddle:
		return "Middle"
	case EllipsizeEnd:
		return "End"
	default:
		return fmt.Sprintf("EllipsizeMode(%d)", e)
	}
}

// WrapMode: PangoWrapMode describes how to wrap the lines of a PangoLayout to
// the desired width.
type WrapMode C.gint

const (
	// WrapWord: wrap lines at word boundaries.
	WrapWord WrapMode = iota
	// WrapChar: wrap lines at character boundaries.
	WrapChar
	// WrapWordChar: wrap lines at word boundaries, but fall back to character
	// boundaries if there is not enough space for a full word.
	WrapWordChar
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WrapMode.
func (w WrapMode) String() string {
	switch w {
	case WrapWord:
		return "Word"
	case WrapChar:
		return "Char"
	case WrapWordChar:
		return "WordChar"
	default:
		return fmt.Sprintf("WrapMode(%d)", w)
	}
}

// Layout: PangoLayout structure represents an entire paragraph of text.
//
// While complete access to the layout capabilities of Pango is provided using
// the detailed interfaces for itemization and shaping, using that functionality
// directly involves writing a fairly large amount of code. PangoLayout provides
// a high-level driver for formatting entire paragraphs of text at once. This
// includes paragraph-level functionality such as line breaking, justification,
// alignment and ellipsization.
//
// A PangoLayout is initialized with a PangoContext`, UTF-8 string and set of
// attributes for that string. Once that is done, the set of formatted lines can
// be extracted from the object, the layout can be rendered, and conversion
// between logical character positions within the layout's text, and the
// physical position of the resulting glyphs can be made.
//
// There are a number of parameters to adjust the formatting of a PangoLayout.
// The following image shows adjustable parameters (on the left) and font
// metrics (on the right):
//
// !Pango Layout Parameters (layout.png)
//
// It is possible, as well, to ignore the 2-D setup, and simply treat the
// results of a PangoLayout as a list of lines.
type Layout struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*Layout)(nil)
)

func wrapLayout(obj *externglib.Object) *Layout {
	return &Layout{
		Object: obj,
	}
}

func marshalLayouter(p uintptr) (interface{}, error) {
	return wrapLayout(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewLayout: create a new PangoLayout object with attributes initialized to
// default values for a particular PangoContext.
//
// The function takes the following parameters:
//
//    - context: PangoContext.
//
// The function returns the following values:
//
//    - layout: newly allocated PangoLayout, with a reference count of one, which
//      should be freed with g_object_unref().
//
func NewLayout(context *Context) *Layout {
	var _arg1 *C.PangoContext // out
	var _cret *C.PangoLayout  // in

	_arg1 = (*C.PangoContext)(unsafe.Pointer(context.Native()))

	_cret = C.pango_layout_new(_arg1)
	runtime.KeepAlive(context)

	var _layout *Layout // out

	_layout = wrapLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _layout
}

// ContextChanged forces recomputation of any state in the PangoLayout that
// might depend on the layout's context.
//
// This function should be called if you make changes to the context subsequent
// to creating the layout.
func (layout *Layout) ContextChanged() {
	var _arg0 *C.PangoLayout // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.pango_layout_context_changed(_arg0)
	runtime.KeepAlive(layout)
}

// Copy creates a deep copy-by-value of the layout.
//
// The attribute list, tab array, and text from the original layout are all
// copied by value.
//
// The function returns the following values:
//
//    - layout: newly allocated PangoLayout, with a reference count of one, which
//      should be freed with g_object_unref().
//
func (src *Layout) Copy() *Layout {
	var _arg0 *C.PangoLayout // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(src.Native()))

	_cret = C.pango_layout_copy(_arg0)
	runtime.KeepAlive(src)

	var _layout *Layout // out

	_layout = wrapLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _layout
}

// Alignment gets the alignment for the layout: how partial lines are positioned
// within the horizontal space available.
//
// The function returns the following values:
//
//    - alignment: alignment.
//
func (layout *Layout) Alignment() Alignment {
	var _arg0 *C.PangoLayout   // out
	var _cret C.PangoAlignment // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_alignment(_arg0)
	runtime.KeepAlive(layout)

	var _alignment Alignment // out

	_alignment = Alignment(_cret)

	return _alignment
}

// Attributes gets the attribute list for the layout, if any.
//
// The function returns the following values:
//
//    - attrList (optional): PangoAttrList or NULL if none was set.
//
func (layout *Layout) Attributes() *AttrList {
	var _arg0 *C.PangoLayout   // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_attributes(_arg0)
	runtime.KeepAlive(layout)

	var _attrList *AttrList // out

	if _cret != nil {
		_attrList = (*AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// AutoDir gets whether to calculate the base direction for the layout according
// to its contents.
//
// See pango.Layout.SetAutoDir().
//
// The function returns the following values:
//
//    - ok: TRUE if the bidirectional base direction is computed from the
//      layout's contents, FALSE otherwise.
//
func (layout *Layout) AutoDir() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_auto_dir(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Baseline gets the Y position of baseline of the first line in layout.
//
// The function returns the following values:
//
//    - gint: baseline of first line, from top of layout.
//
func (layout *Layout) Baseline() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_baseline(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CharacterCount returns the number of Unicode characters in the the text of
// layout.
//
// The function returns the following values:
//
//    - gint: number of Unicode characters in the text of layout.
//
func (layout *Layout) CharacterCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.gint         // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_character_count(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Context retrieves the PangoContext used for this layout.
//
// The function returns the following values:
//
//    - context: PangoContext for the layout. This does not have an additional
//      refcount added, so if you want to keep a copy of this around, you must
//      reference it yourself.
//
func (layout *Layout) Context() *Context {
	var _arg0 *C.PangoLayout  // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_context(_arg0)
	runtime.KeepAlive(layout)

	var _context *Context // out

	_context = wrapContext(externglib.Take(unsafe.Pointer(_cret)))

	return _context
}

// CursorPos: given an index within a layout, determines the positions that of
// the strong and weak cursors if the insertion point is at that index.
//
// The position of each cursor is stored as a zero-width rectangle. The strong
// cursor location is the location where characters of the directionality equal
// to the base direction of the layout are inserted. The weak cursor location is
// the location where characters of the directionality opposite to the base
// direction of the layout are inserted.
//
// The function takes the following parameters:
//
//    - index_: byte index of the cursor.
//
// The function returns the following values:
//
//    - strongPos (optional): location to store the strong cursor position (may
//      be NULL).
//    - weakPos (optional): location to store the weak cursor position (may be
//      NULL).
//
func (layout *Layout) CursorPos(index_ int) (strongPos *Rectangle, weakPos *Rectangle) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.int            // out
	var _arg2 C.PangoRectangle // in
	var _arg3 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(index_)

	C.pango_layout_get_cursor_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index_)

	var _strongPos *Rectangle // out
	var _weakPos *Rectangle   // out

	_strongPos = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_weakPos = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _strongPos, _weakPos
}

// Direction gets the text direction at the given character position in layout.
//
// The function takes the following parameters:
//
//    - index: byte index of the char.
//
// The function returns the following values:
//
//    - direction: text direction at index.
//
func (layout *Layout) Direction(index int) Direction {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.int            // out
	var _cret C.PangoDirection // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(index)

	_cret = C.pango_layout_get_direction(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

// Ellipsize gets the type of ellipsization being performed for layout.
//
// See pango.Layout.SetEllipsize().
//
// Use pango.Layout.IsEllipsized() to query whether any paragraphs were actually
// ellipsized.
//
// The function returns the following values:
//
//    - ellipsizeMode: current ellipsization mode for layout.
//
func (layout *Layout) Ellipsize() EllipsizeMode {
	var _arg0 *C.PangoLayout       // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_ellipsize(_arg0)
	runtime.KeepAlive(layout)

	var _ellipsizeMode EllipsizeMode // out

	_ellipsizeMode = EllipsizeMode(_cret)

	return _ellipsizeMode
}

// Extents computes the logical and ink extents of layout.
//
// Logical extents are usually what you want for positioning things. Note that
// both extents may have non-zero x and y. You may want to use those to offset
// where you render the layout. Not doing that is a very typical bug that shows
// up as right-to-left layouts not being correctly positioned in a layout with a
// set width.
//
// The extents are given in layout coordinates and in Pango units; layout
// coordinates begin at the top left corner of the layout.
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle used to store the extents of the layout as
//      drawn or NULL to indicate that the result is not needed.
//    - logicalRect (optional): rectangle used to store the logical extents of
//      the layout or NULL to indicate that the result is not needed.
//
func (layout *Layout) Extents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.PangoRectangle // in
	var _arg2 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.pango_layout_get_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// FontDescription gets the font description for the layout, if any.
//
// The function returns the following values:
//
//    - fontDescription (optional): pointer to the layout's font description, or
//      NULL if the font description from the layout's context is inherited. This
//      value is owned by the layout and must not be modified or freed.
//
func (layout *Layout) FontDescription() *FontDescription {
	var _arg0 *C.PangoLayout          // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_font_description(_arg0)
	runtime.KeepAlive(layout)

	var _fontDescription *FontDescription // out

	if _cret != nil {
		_fontDescription = (*FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _fontDescription
}

// Height gets the height of layout used for ellipsization.
//
// See pango.Layout.SetHeight() for details.
//
// The function returns the following values:
//
//    - gint: height, in Pango units if positive, or number of lines if negative.
//
func (layout *Layout) Height() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_height(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Indent gets the paragraph indent width in Pango units.
//
// A negative value indicates a hanging indentation.
//
// The function returns the following values:
//
//    - gint: indent in Pango units.
//
func (layout *Layout) Indent() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_indent(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Iter returns an iterator to iterate over the visual extents of the layout.
//
// The function returns the following values:
//
//    - layoutIter: new PangoLayoutIter that should be freed using
//      pango.LayoutIter.Free().
//
func (layout *Layout) Iter() *LayoutIter {
	var _arg0 *C.PangoLayout     // out
	var _cret *C.PangoLayoutIter // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_iter(_arg0)
	runtime.KeepAlive(layout)

	var _layoutIter *LayoutIter // out

	_layoutIter = (*LayoutIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_layoutIter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_layout_iter_free((*C.PangoLayoutIter)(intern.C))
		},
	)

	return _layoutIter
}

// Justify gets whether each complete line should be stretched to fill the
// entire width of the layout.
//
// The function returns the following values:
//
//    - ok: justify.
//
func (layout *Layout) Justify() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_justify(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Line retrieves a particular line from a PangoLayout.
//
// Use the faster pango.Layout.GetLineReadonly() if you do not plan to modify
// the contents of the line (glyphs, glyph widths, etc.).
//
// The function takes the following parameters:
//
//    - line: index of a line, which must be between 0 and
//      pango_layout_get_line_count(layout) - 1, inclusive.
//
// The function returns the following values:
//
//    - layoutLine (optional): requested PangoLayoutLine, or NULL if the index is
//      out of range. This layout line can be ref'ed and retained, but will
//      become invalid if changes are made to the PangoLayout.
//
func (layout *Layout) Line(line int) *LayoutLine {
	var _arg0 *C.PangoLayout     // out
	var _arg1 C.int              // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(line)

	_cret = C.pango_layout_get_line(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(line)

	var _layoutLine *LayoutLine // out

	if _cret != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
	}

	return _layoutLine
}

// LineCount retrieves the count of lines for the layout.
//
// The function returns the following values:
//
//    - gint: line count.
//
func (layout *Layout) LineCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_line_count(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineReadonly retrieves a particular line from a PangoLayout.
//
// This is a faster alternative to pango.Layout.GetLine(), but the user is not
// expected to modify the contents of the line (glyphs, glyph widths, etc.).
//
// The function takes the following parameters:
//
//    - line: index of a line, which must be between 0 and
//      pango_layout_get_line_count(layout) - 1, inclusive.
//
// The function returns the following values:
//
//    - layoutLine (optional): requested PangoLayoutLine, or NULL if the index is
//      out of range. This layout line can be ref'ed and retained, but will
//      become invalid if changes are made to the PangoLayout. No changes should
//      be made to the line.
//
func (layout *Layout) LineReadonly(line int) *LayoutLine {
	var _arg0 *C.PangoLayout     // out
	var _arg1 C.int              // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(line)

	_cret = C.pango_layout_get_line_readonly(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(line)

	var _layoutLine *LayoutLine // out

	if _cret != nil {
		_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_layout_line_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutLine)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
	}

	return _layoutLine
}

// LineSpacing gets the line spacing factor of layout.
//
// See pango.Layout.SetLineSpacing().
//
// The function returns the following values:
//
func (layout *Layout) LineSpacing() float32 {
	var _arg0 *C.PangoLayout // out
	var _cret C.float        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_line_spacing(_arg0)
	runtime.KeepAlive(layout)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Lines returns the lines of the layout as a list.
//
// Use the faster pango.Layout.GetLinesReadonly() if you do not plan to modify
// the contents of the lines (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//    - sList: GSList containing the lines in the layout. This points to internal
//      data of the PangoLayout and must be used with care. It will become
//      invalid on any change to the layout's text or properties.
//
func (layout *Layout) Lines() []*LayoutLine {
	var _arg0 *C.PangoLayout // out
	var _cret *C.GSList      // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_lines(_arg0)
	runtime.KeepAlive(layout)

	var _sList []*LayoutLine // out

	_sList = make([]*LayoutLine, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.PangoLayoutLine)(v)
		var dst *LayoutLine // out
		dst = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(src)))
		C.pango_layout_line_ref(src)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// LinesReadonly returns the lines of the layout as a list.
//
// This is a faster alternative to pango.Layout.GetLines(), but the user is not
// expected to modify the contents of the lines (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//    - sList: GSList containing the lines in the layout. This points to internal
//      data of the PangoLayout and must be used with care. It will become
//      invalid on any change to the layout's text or properties. No changes
//      should be made to the lines.
//
func (layout *Layout) LinesReadonly() []*LayoutLine {
	var _arg0 *C.PangoLayout // out
	var _cret *C.GSList      // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_lines_readonly(_arg0)
	runtime.KeepAlive(layout)

	var _sList []*LayoutLine // out

	_sList = make([]*LayoutLine, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.PangoLayoutLine)(v)
		var dst *LayoutLine // out
		dst = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(src)))
		C.pango_layout_line_ref(src)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
			},
		)
		_sList = append(_sList, dst)
	})

	return _sList
}

// LogAttrs retrieves an array of logical attributes for each character in the
// layout.
//
// The function returns the following values:
//
//    - attrs: location to store a pointer to an array of logical attributes This
//      value must be freed with g_free().
//
func (layout *Layout) LogAttrs() []LogAttr {
	var _arg0 *C.PangoLayout  // out
	var _arg1 *C.PangoLogAttr // in
	var _arg2 C.gint          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.pango_layout_get_log_attrs(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _attrs []LogAttr // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice(_arg1, _arg2)
		_attrs = make([]LogAttr, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_attrs[i] = *(*LogAttr)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _attrs
}

// LogAttrsReadonly retrieves an array of logical attributes for each character
// in the layout.
//
// This is a faster alternative to pango.Layout.GetLogAttrs(). The returned
// array is part of layout and must not be modified. Modifying the layout will
// invalidate the returned array.
//
// The number of attributes returned in n_attrs will be one more than the total
// number of characters in the layout, since there need to be attributes
// corresponding to both the position before the first character and the
// position after the last character.
//
// The function returns the following values:
//
//    - logAttrs: array of logical attributes.
//
func (layout *Layout) LogAttrsReadonly() []LogAttr {
	var _arg0 *C.PangoLayout  // out
	var _cret *C.PangoLogAttr // in
	var _arg1 C.gint          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_log_attrs_readonly(_arg0, &_arg1)
	runtime.KeepAlive(layout)

	var _logAttrs []LogAttr // out

	{
		src := unsafe.Slice(_cret, _arg1)
		_logAttrs = make([]LogAttr, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_logAttrs[i] = *(*LogAttr)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _logAttrs
}

// PixelExtents computes the logical and ink extents of layout in device units.
//
// This function just calls pango.Layout.GetExtents() followed by two
// extents_to_pixels calls, rounding ink_rect and logical_rect such that the
// rounded rectangles fully contain the unrounded one (that is, passes them as
// first argument to pango_extents_to_pixels()).
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle used to store the extents of the layout as
//      drawn or NULL to indicate that the result is not needed.
//    - logicalRect (optional): rectangle used to store the logical extents of
//      the layout or NULL to indicate that the result is not needed.
//
func (layout *Layout) PixelExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.PangoRectangle // in
	var _arg2 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.pango_layout_get_pixel_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// PixelSize determines the logical width and height of a PangoLayout in device
// units.
//
// pango.Layout.GetSize() returns the width and height scaled by PANGO_SCALE.
// This is simply a convenience function around pango.Layout.GetPixelExtents().
//
// The function returns the following values:
//
//    - width (optional): location to store the logical width, or NULL.
//    - height (optional): location to store the logical height, or NULL.
//
func (layout *Layout) PixelSize() (width int, height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.pango_layout_get_pixel_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// Serial returns the current serial number of layout.
//
// The serial number is initialized to an small number larger than zero when a
// new layout is created and is increased whenever the layout is changed using
// any of the setter functions, or the PangoContext it uses has changed. The
// serial may wrap, but will never have the value 0. Since it can wrap, never
// compare it with "less than", always use "not equals".
//
// This can be used to automatically detect changes to a PangoLayout, and is
// useful for example to decide whether a layout needs redrawing. To force the
// serial to be increased, use pango.Layout.ContextChanged().
//
// The function returns the following values:
//
//    - guint: current serial number of layout.
//
func (layout *Layout) Serial() uint {
	var _arg0 *C.PangoLayout // out
	var _cret C.guint        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_serial(_arg0)
	runtime.KeepAlive(layout)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SingleParagraphMode obtains whether layout is in single paragraph mode.
//
// See pango.Layout.SetSingleParagraphMode().
//
// The function returns the following values:
//
//    - ok: TRUE if the layout does not break paragraphs at paragraph separator
//      characters, FALSE otherwise.
//
func (layout *Layout) SingleParagraphMode() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_single_paragraph_mode(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size determines the logical width and height of a PangoLayout in Pango units.
//
// This is simply a convenience function around pango.Layout.GetExtents().
//
// The function returns the following values:
//
//    - width (optional): location to store the logical width, or NULL.
//    - height (optional): location to store the logical height, or NULL.
//
func (layout *Layout) Size() (width int, height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	C.pango_layout_get_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layout)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// Spacing gets the amount of spacing between the lines of the layout.
//
// The function returns the following values:
//
//    - gint: spacing in Pango units.
//
func (layout *Layout) Spacing() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_spacing(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Tabs gets the current PangoTabArray used by this layout.
//
// If no PangoTabArray has been set, then the default tabs are in use and NULL
// is returned. Default tabs are every 8 spaces.
//
// The return value should be freed with pango.TabArray.Free().
//
// The function returns the following values:
//
//    - tabArray (optional): copy of the tabs for this layout, or NULL.
//
func (layout *Layout) Tabs() *TabArray {
	var _arg0 *C.PangoLayout   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_tabs(_arg0)
	runtime.KeepAlive(layout)

	var _tabArray *TabArray // out

	if _cret != nil {
		_tabArray = (*TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tabArray)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
			},
		)
	}

	return _tabArray
}

// Text gets the text in the layout. The returned text should not be freed or
// modified.
//
// The function returns the following values:
//
//    - utf8: text in the layout.
//
func (layout *Layout) Text() string {
	var _arg0 *C.PangoLayout // out
	var _cret *C.char        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_text(_arg0)
	runtime.KeepAlive(layout)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UnknownGlyphsCount counts the number of unknown glyphs in layout.
//
// This function can be used to determine if there are any fonts available to
// render all characters in a certain string, or when used in combination with
// PANGO_ATTR_FALLBACK, to check if a certain font supports all the characters
// in the string.
//
// The function returns the following values:
//
//    - gint: number of unknown glyphs in layout.
//
func (layout *Layout) UnknownGlyphsCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_unknown_glyphs_count(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Width gets the width to which the lines of the PangoLayout should wrap.
//
// The function returns the following values:
//
//    - gint: width in Pango units, or -1 if no width set.
//
func (layout *Layout) Width() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_width(_arg0)
	runtime.KeepAlive(layout)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Wrap gets the wrap mode for the layout.
//
// Use pango.Layout.IsWrapped() to query whether any paragraphs were actually
// wrapped.
//
// The function returns the following values:
//
//    - wrapMode: active wrap mode.
//
func (layout *Layout) Wrap() WrapMode {
	var _arg0 *C.PangoLayout  // out
	var _cret C.PangoWrapMode // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_get_wrap(_arg0)
	runtime.KeepAlive(layout)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

// IndexToLineX converts from byte index_ within the layout to line and X
// position.
//
// The X position is measured from the left edge of the line.
//
// The function takes the following parameters:
//
//    - index_: byte index of a grapheme within the layout.
//    - trailing: integer indicating the edge of the grapheme to retrieve the
//      position of. If > 0, the trailing edge of the grapheme, if 0, the leading
//      of the grapheme.
//
// The function returns the following values:
//
//    - line (optional): location to store resulting line index. (which will
//      between 0 and pango_layout_get_line_count(layout) - 1), or NULL.
//    - xPos (optional): location to store resulting position within line
//      (PANGO_SCALE units per device unit), or NULL.
//
func (layout *Layout) IndexToLineX(index_ int, trailing bool) (line int, xPos int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out
	var _arg2 C.gboolean     // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(index_)
	if trailing {
		_arg2 = C.TRUE
	}

	C.pango_layout_index_to_line_x(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(trailing)

	var _line int // out
	var _xPos int // out

	_line = int(_arg3)
	_xPos = int(_arg4)

	return _line, _xPos
}

// IndexToPos converts from an index within a PangoLayout to the onscreen
// position corresponding to the grapheme at that index.
//
// The return value is represented as rectangle. Note that pos->x is always the
// leading edge of the grapheme and pos->x + pos->width the trailing edge of the
// grapheme. If the directionality of the grapheme is right-to-left, then
// pos->width will be negative.
//
// The function takes the following parameters:
//
//    - index_: byte index within layout.
//
// The function returns the following values:
//
//    - pos: rectangle in which to store the position of the grapheme.
//
func (layout *Layout) IndexToPos(index_ int) *Rectangle {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.int            // out
	var _arg2 C.PangoRectangle // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(index_)

	C.pango_layout_index_to_pos(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index_)

	var _pos *Rectangle // out

	_pos = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _pos
}

// IsEllipsized queries whether the layout had to ellipsize any paragraphs.
//
// This returns TRUE if the ellipsization mode for layout is not
// PANGO_ELLIPSIZE_NONE, a positive width is set on layout, and there are
// paragraphs exceeding that width that have to be ellipsized.
//
// The function returns the following values:
//
//    - ok: TRUE if any paragraphs had to be ellipsized, FALSE otherwise.
//
func (layout *Layout) IsEllipsized() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_is_ellipsized(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsWrapped queries whether the layout had to wrap any paragraphs.
//
// This returns TRUE if a positive width is set on layout, ellipsization mode of
// layout is set to PANGO_ELLIPSIZE_NONE, and there are paragraphs exceeding the
// layout width that have to be wrapped.
//
// The function returns the following values:
//
//    - ok: TRUE if any paragraphs had to be wrapped, FALSE otherwise.
//
func (layout *Layout) IsWrapped() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

	_cret = C.pango_layout_is_wrapped(_arg0)
	runtime.KeepAlive(layout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveCursorVisually computes a new cursor position from an old position and a
// count of positions to move visually.
//
// If direction is positive, then the new strong cursor position will be one
// position to the right of the old cursor position. If direction is negative,
// then the new strong cursor position will be one position to the left of the
// old cursor position.
//
// In the presence of bidirectional text, the correspondence between logical and
// visual order will depend on the direction of the current run, and there may
// be jumps when the cursor is moved off of the end of a run.
//
// Motion here is in cursor positions, not in characters, so a single call to
// pango.Layout.MoveCursorVisually() may move the cursor over multiple
// characters when multiple characters combine to form a single grapheme.
//
// The function takes the following parameters:
//
//    - strong: whether the moving cursor is the strong cursor or the weak
//      cursor. The strong cursor is the cursor corresponding to text insertion
//      in the base direction for the layout.
//    - oldIndex: byte index of the grapheme for the old index.
//    - oldTrailing: if 0, the cursor was at the leading edge of the grapheme
//      indicated by old_index, if > 0, the cursor was at the trailing edge.
//    - direction to move cursor. A negative value indicates motion to the left.
//
// The function returns the following values:
//
//    - newIndex: location to store the new cursor byte index. A value of -1
//      indicates that the cursor has been moved off the beginning of the layout.
//      A value of G_MAXINT indicates that the cursor has been moved off the end
//      of the layout.
//    - newTrailing: number of characters to move forward from the location
//      returned for new_index to get the position where the cursor should be
//      displayed. This allows distinguishing the position at the beginning of
//      one line from the position at the end of the preceding line. new_index is
//      always on the line where the cursor should be displayed.
//
func (layout *Layout) MoveCursorVisually(strong bool, oldIndex, oldTrailing, direction int) (newIndex int, newTrailing int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out
	var _arg4 C.int          // out
	var _arg5 C.int          // in
	var _arg6 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	if strong {
		_arg1 = C.TRUE
	}
	_arg2 = C.int(oldIndex)
	_arg3 = C.int(oldTrailing)
	_arg4 = C.int(direction)

	C.pango_layout_move_cursor_visually(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(strong)
	runtime.KeepAlive(oldIndex)
	runtime.KeepAlive(oldTrailing)
	runtime.KeepAlive(direction)

	var _newIndex int    // out
	var _newTrailing int // out

	_newIndex = int(_arg5)
	_newTrailing = int(_arg6)

	return _newIndex, _newTrailing
}

// SetAlignment sets the alignment for the layout: how partial lines are
// positioned within the horizontal space available.
//
// The function takes the following parameters:
//
//    - alignment: alignment.
//
func (layout *Layout) SetAlignment(alignment Alignment) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.PangoAlignment // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.PangoAlignment(alignment)

	C.pango_layout_set_alignment(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(alignment)
}

// SetAttributes sets the text attributes for a layout object. References attrs,
// so the caller can unref its reference.
//
// The function takes the following parameters:
//
//    - attrs (optional) can be NULL.
//
func (layout *Layout) SetAttributes(attrs *AttrList) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	if attrs != nil {
		_arg1 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	}

	C.pango_layout_set_attributes(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(attrs)
}

// SetAutoDir sets whether to calculate the base direction for the layout
// according to its contents.
//
// When this flag is on (the default), then paragraphs in layout that begin with
// strong right-to-left characters (Arabic and Hebrew principally), will have
// right-to-left layout, paragraphs with letters from other scripts will have
// left-to-right layout. Paragraphs with only neutral characters get their
// direction from the surrounding paragraphs.
//
// When FALSE, the choice between left-to-right and right-to-left layout is done
// according to the base direction of the layout's PangoContext. (See
// pango.Context.SetBaseDir()).
//
// When the auto-computed direction of a paragraph differs from the base
// direction of the context, the interpretation of PANGO_ALIGN_LEFT and
// PANGO_ALIGN_RIGHT are swapped.
//
// The function takes the following parameters:
//
//    - autoDir: if TRUE, compute the bidirectional base direction from the
//      layout's contents.
//
func (layout *Layout) SetAutoDir(autoDir bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	if autoDir {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_auto_dir(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(autoDir)
}

// SetEllipsize sets the type of ellipsization being performed for layout.
//
// Depending on the ellipsization mode ellipsize text is removed from the start,
// middle, or end of text so they fit within the width and height of layout set
// with pango.Layout.SetWidth() and pango.Layout.SetHeight().
//
// If the layout contains characters such as newlines that force it to be layed
// out in multiple paragraphs, then whether each paragraph is ellipsized
// separately or the entire layout is ellipsized as a whole depends on the set
// height of the layout. See pango.Layout.SetHeight() for details.
//
// The function takes the following parameters:
//
//    - ellipsize: new ellipsization mode for layout.
//
func (layout *Layout) SetEllipsize(ellipsize EllipsizeMode) {
	var _arg0 *C.PangoLayout       // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.PangoEllipsizeMode(ellipsize)

	C.pango_layout_set_ellipsize(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(ellipsize)
}

// SetFontDescription sets the default font description for the layout.
//
// If no font description is set on the layout, the font description from the
// layout's context is used.
//
// The function takes the following parameters:
//
//    - desc (optional): new PangoFontDescription, or NULL to unset the current
//      font description.
//
func (layout *Layout) SetFontDescription(desc *FontDescription) {
	var _arg0 *C.PangoLayout          // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	if desc != nil {
		_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(desc)))
	}

	C.pango_layout_set_font_description(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(desc)
}

// SetHeight sets the height to which the PangoLayout should be ellipsized at.
//
// There are two different behaviors, based on whether height is positive or
// negative.
//
// If height is positive, it will be the maximum height of the layout. Only
// lines would be shown that would fit, and if there is any text omitted, an
// ellipsis added. At least one line is included in each paragraph regardless of
// how small the height value is. A value of zero will render exactly one line
// for the entire layout.
//
// If height is negative, it will be the (negative of) maximum number of lines
// per paragraph. That is, the total number of lines shown may well be more than
// this value if the layout contains multiple paragraphs of text. The default
// value of -1 means that first line of each paragraph is ellipsized. This
// behavior may be changed in the future to act per layout instead of per
// paragraph. File a bug against pango at https://gitlab.gnome.org/gnome/pango
// (https://gitlab.gnome.org/gnome/pango) if your code relies on this behavior.
//
// Height setting only has effect if a positive width is set on layout and
// ellipsization mode of layout is not PANGO_ELLIPSIZE_NONE. The behavior is
// undefined if a height other than -1 is set and ellipsization mode is set to
// PANGO_ELLIPSIZE_NONE, and may change in the future.
//
// The function takes the following parameters:
//
//    - height: desired height of the layout in Pango units if positive, or
//      desired number of lines if negative.
//
func (layout *Layout) SetHeight(height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(height)

	C.pango_layout_set_height(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(height)
}

// SetIndent sets the width in Pango units to indent each paragraph.
//
// A negative value of indent will produce a hanging indentation. That is, the
// first line will have the full width, and subsequent lines will be indented by
// the absolute value of indent.
//
// The indent setting is ignored if layout alignment is set to
// PANGO_ALIGN_CENTER.
//
// The function takes the following parameters:
//
//    - indent: amount by which to indent.
//
func (layout *Layout) SetIndent(indent int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(indent)

	C.pango_layout_set_indent(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(indent)
}

// SetJustify sets whether each complete line should be stretched to fill the
// entire width of the layout.
//
// Stretching is typically done by adding whitespace, but for some scripts (such
// as Arabic), the justification may be done in more complex ways, like
// extending the characters.
//
// Note that this setting is not implemented and so is ignored in Pango older
// than 1.18.
//
// The function takes the following parameters:
//
//    - justify: whether the lines in the layout should be justified.
//
func (layout *Layout) SetJustify(justify bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	if justify {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_justify(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(justify)
}

// SetLineSpacing sets a factor for line spacing.
//
// Typical values are: 0, 1, 1.5, 2. The default values is 0.
//
// If factor is non-zero, lines are placed so that
//
//    baseline2 = baseline1 + factor * height2
//
// where height2 is the line height of the second line (as determined by the
// font(s)). In this case, the spacing set with pango.Layout.SetSpacing() is
// ignored.
//
// If factor is zero, spacing is applied as before.
//
// The function takes the following parameters:
//
//    - factor: new line spacing factor.
//
func (layout *Layout) SetLineSpacing(factor float32) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.float        // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.float(factor)

	C.pango_layout_set_line_spacing(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(factor)
}

// SetMarkup sets the layout text and attribute list from marked-up text.
//
// See Pango Markup (pango_markup.html)). Replaces the current text and
// attribute list.
//
// This is the Same as pango.Layout.SetMarkupWithAccel(), but the markup text
// isn't scanned for accelerators.
//
// The function takes the following parameters:
//
//    - markup: marked-up text.
//    - length of marked-up text in bytes, or -1 if markup is null-terminated.
//
func (layout *Layout) SetMarkup(markup string, length int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(markup)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(length)

	C.pango_layout_set_markup(_arg0, _arg1, _arg2)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(markup)
	runtime.KeepAlive(length)
}

// SetMarkupWithAccel sets the layout text and attribute list from marked-up
// text.
//
// See Pango Markup (pango_markup.html)). Replaces the current text and
// attribute list.
//
// If accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in accel_char. Two accel_marker characters following each other
// produce a single literal accel_marker character.
//
// The function takes the following parameters:
//
//    - markup: marked-up text (see Pango Markup (pango_markup.html)).
//    - length of marked-up text in bytes, or -1 if markup is null-terminated.
//    - accelMarker: marker for accelerators in the text.
//
// The function returns the following values:
//
//    - accelChar (optional): return location for first located accelerator, or
//      NULL.
//
func (layout *Layout) SetMarkupWithAccel(markup string, length int, accelMarker uint32) uint32 {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int          // out
	var _arg3 C.gunichar     // out
	var _arg4 C.gunichar     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(markup)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(length)
	_arg3 = C.gunichar(accelMarker)

	C.pango_layout_set_markup_with_accel(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(markup)
	runtime.KeepAlive(length)
	runtime.KeepAlive(accelMarker)

	var _accelChar uint32 // out

	_accelChar = uint32(_arg4)

	return _accelChar
}

// SetSingleParagraphMode sets the single paragraph mode of layout.
//
// If setting is TRUE, do not treat newlines and similar characters as paragraph
// separators; instead, keep all text in a single paragraph, and display a glyph
// for paragraph separator characters. Used when you want to allow editing of
// newlines on a single text line.
//
// The function takes the following parameters:
//
//    - setting: new setting.
//
func (layout *Layout) SetSingleParagraphMode(setting bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_single_paragraph_mode(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(setting)
}

// SetSpacing sets the amount of spacing in Pango unit between the lines of the
// layout.
//
//
// When placing lines with spacing, Pango arranges things so that
//
// line2.top = line1.bottom + spacing
//
// Note: Since 1.44, Pango defaults to using the line height (as determined by
// the font) for placing lines. The spacing set with this function is only taken
// into account when the line height factor is set to zero with
// pango.Layout.SetLineSpacing().
//
// The function takes the following parameters:
//
//    - spacing: amount of spacing.
//
func (layout *Layout) SetSpacing(spacing int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(spacing)

	C.pango_layout_set_spacing(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(spacing)
}

// SetTabs sets the tabs to use for layout, overriding the default tabs.
//
// By default, tabs are every 8 spaces. If tabs is NULL, the default tabs are
// reinstated. tabs is copied into the layout; you must free your copy of tabs
// yourself.
//
// The function takes the following parameters:
//
//    - tabs (optional): PangoTabArray, or NULL.
//
func (layout *Layout) SetTabs(tabs *TabArray) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	if tabs != nil {
		_arg1 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabs)))
	}

	C.pango_layout_set_tabs(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(tabs)
}

// SetText sets the text of the layout.
//
// This function validates text and renders invalid UTF-8 with a placeholder
// glyph.
//
// Note that if you have used pango.Layout.SetMarkup() or
// pango.Layout.SetMarkupWithAccel() on layout before, you may want to call
// pango.Layout.SetAttributes() to clear the attributes set on the layout from
// the markup as this function does not clear attributes.
//
// The function takes the following parameters:
//
//    - text: text.
//    - length: maximum length of text, in bytes. -1 indicates that the string is
//      nul-terminated and the length should be calculated. The text will also be
//      truncated on encountering a nul-termination even when length is positive.
//
func (layout *Layout) SetText(text string, length int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(length)

	C.pango_layout_set_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(text)
	runtime.KeepAlive(length)
}

// SetWidth sets the width to which the lines of the PangoLayout should wrap or
// ellipsized.
//
// The default value is -1: no width set.
//
// The function takes the following parameters:
//
//    - width: desired width in Pango units, or -1 to indicate that no wrapping
//      or ellipsization should be performed.
//
func (layout *Layout) SetWidth(width int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(width)

	C.pango_layout_set_width(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(width)
}

// SetWrap sets the wrap mode.
//
// The wrap mode only has effect if a width is set on the layout with
// pango.Layout.SetWidth(). To turn off wrapping, set the width to -1.
//
// The function takes the following parameters:
//
//    - wrap mode.
//
func (layout *Layout) SetWrap(wrap WrapMode) {
	var _arg0 *C.PangoLayout  // out
	var _arg1 C.PangoWrapMode // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.PangoWrapMode(wrap)

	C.pango_layout_set_wrap(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(wrap)
}

// XYToIndex converts from X and Y position within a layout to the byte index to
// the character at that logical position.
//
// If the Y position is not inside the layout, the closest position is chosen
// (the position will be clamped inside the layout). If the X position is not
// within the layout, then the start or the end of the line is chosen as
// described for pango.LayoutLine.XToIndex(). If either the X or Y positions
// were not inside the layout, then the function returns FALSE; on an exact hit,
// it returns TRUE.
//
// The function takes the following parameters:
//
//    - x: x offset (in Pango units) from the left edge of the layout.
//    - y: y offset (in Pango units) from the top edge of the layout.
//
// The function returns the following values:
//
//    - index_: location to store calculated byte index.
//    - trailing: location to store a integer indicating where in the grapheme
//      the user clicked. It will either be zero, or the number of characters in
//      the grapheme. 0 represents the leading edge of the grapheme.
//    - ok: TRUE if the coordinates were inside text, FALSE otherwise.
//
func (layout *Layout) XYToIndex(x, y int) (index_ int, trailing int, ok bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.pango_layout_xy_to_index(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _index_ int   // out
	var _trailing int // out
	var _ok bool      // out

	_index_ = int(_arg3)
	_trailing = int(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _index_, _trailing, _ok
}

// LayoutIter: PangoLayoutIter can be used to iterate over the visual extents of
// a PangoLayout.
//
// To obtain a PangoLayoutIter, use pango.Layout.GetIter().
//
// The PangoLayoutIter structure is opaque, and has no user-visible fields.
//
// An instance of this type is always passed by reference.
type LayoutIter struct {
	*layoutIter
}

// layoutIter is the struct that's finalized.
type layoutIter struct {
	native *C.PangoLayoutIter
}

func marshalLayoutIter(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &LayoutIter{&layoutIter{(*C.PangoLayoutIter)(b)}}, nil
}

// AtLastLine determines whether iter is on the last line of the layout.
//
// The function returns the following values:
//
//    - ok: TRUE if iter is on the last line.
//
func (iter *LayoutIter) AtLastLine() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_at_last_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy copies a PangoLayoutIter.
//
// The function returns the following values:
//
//    - layoutIter (optional): newly allocated PangoLayoutIter, which should be
//      freed with pango.LayoutIter.Free(), or NULL if iter was NULL.
//
func (iter *LayoutIter) Copy() *LayoutIter {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutIter // in

	if iter != nil {
		_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	_cret = C.pango_layout_iter_copy(_arg0)
	runtime.KeepAlive(iter)

	var _layoutIter *LayoutIter // out

	if _cret != nil {
		_layoutIter = (*LayoutIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_layoutIter)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_layout_iter_free((*C.PangoLayoutIter)(intern.C))
			},
		)
	}

	return _layoutIter
}

// Baseline gets the Y position of the current line's baseline, in layout
// coordinates (origin at top left of the entire layout).
//
// The function returns the following values:
//
//    - gint: baseline of current line.
//
func (iter *LayoutIter) Baseline() int {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_baseline(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CharExtents gets the extents of the current character, in layout coordinates
// (origin is the top left of the entire layout). Only logical extents can
// sensibly be obtained for characters; ink extents make sense only down to the
// level of clusters.
//
// The function returns the following values:
//
//    - logicalRect: rectangle to fill with logical extents.
//
func (iter *LayoutIter) CharExtents() *Rectangle {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_char_extents(_arg0, &_arg1)
	runtime.KeepAlive(iter)

	var _logicalRect *Rectangle // out

	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _logicalRect
}

// ClusterExtents gets the extents of the current cluster, in layout coordinates
// (origin is the top left of the entire layout).
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle to fill with ink extents, or NULL.
//    - logicalRect (optional): rectangle to fill with logical extents, or NULL.
//
func (iter *LayoutIter) ClusterExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_cluster_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// Index gets the current byte index. Note that iterating forward by char moves
// in visual order, not logical order, so indexes may not be sequential. Also,
// the index may be equal to the length of the text in the layout, if on the
// NULL run (see pango.LayoutIter.GetRun()).
//
// The function returns the following values:
//
//    - gint: current byte index.
//
func (iter *LayoutIter) Index() int {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_index(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Layout gets the layout associated with a PangoLayoutIter.
//
// The function returns the following values:
//
//    - layout associated with iter.
//
func (iter *LayoutIter) Layout() *Layout {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayout     // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_layout(_arg0)
	runtime.KeepAlive(iter)

	var _layout *Layout // out

	_layout = wrapLayout(externglib.Take(unsafe.Pointer(_cret)))

	return _layout
}

// LayoutExtents obtains the extents of the PangoLayout being iterated over.
// ink_rect or logical_rect can be NULL if you aren't interested in them.
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle to fill with ink extents, or NULL.
//    - logicalRect (optional): rectangle to fill with logical extents, or NULL.
//
func (iter *LayoutIter) LayoutExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_layout_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// Line gets the current line.
//
// Use the faster pango.LayoutIter.GetLineReadonly() if you do not plan to
// modify the contents of the line (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//    - layoutLine: current line.
//
func (iter *LayoutIter) Line() *LayoutLine {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_line(_arg0)
	runtime.KeepAlive(iter)

	var _layoutLine *LayoutLine // out

	_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.pango_layout_line_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_layoutLine)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
		},
	)

	return _layoutLine
}

// LineExtents obtains the extents of the current line. ink_rect or logical_rect
// can be NULL if you aren't interested in them. Extents are in layout
// coordinates (origin is the top-left corner of the entire PangoLayout). Thus
// the extents returned by this function will be the same width/height but not
// at the same x/y as the extents returned from pango.LayoutLine.GetExtents().
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle to fill with ink extents, or NULL.
//    - logicalRect (optional): rectangle to fill with logical extents, or NULL.
//
func (iter *LayoutIter) LineExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_line_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// LineReadonly gets the current line for read-only access.
//
// This is a faster alternative to pango.LayoutIter.GetLine(), but the user is
// not expected to modify the contents of the line (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//    - layoutLine: current line, that should not be modified.
//
func (iter *LayoutIter) LineReadonly() *LayoutLine {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutLine // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_line_readonly(_arg0)
	runtime.KeepAlive(iter)

	var _layoutLine *LayoutLine // out

	_layoutLine = (*LayoutLine)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.pango_layout_line_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_layoutLine)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_layout_line_unref((*C.PangoLayoutLine)(intern.C))
		},
	)

	return _layoutLine
}

// LineYrange divides the vertical space in the PangoLayout being iterated over
// between the lines in the layout, and returns the space belonging to the
// current line. A line's range includes the line's logical extents, plus half
// of the spacing above and below the line, if pango.Layout.SetSpacing() has
// been called to set layout spacing. The Y positions are in layout coordinates
// (origin at top left of the entire layout).
//
// Note: Since 1.44, Pango uses line heights for placing lines, and there may be
// gaps between the ranges returned by this function.
//
// The function returns the following values:
//
//    - y0 (optional): start of line, or NULL.
//    - y1 (optional): end of line, or NULL.
//
func (iter *LayoutIter) LineYrange() (y0 int, y1 int) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.int              // in
	var _arg2 C.int              // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_line_yrange(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _y0 int // out
	var _y1 int // out

	_y0 = int(_arg1)
	_y1 = int(_arg2)

	return _y0, _y1
}

// Run gets the current run. When iterating by run, at the end of each line,
// there's a position with a NULL run, so this function can return NULL. The
// NULL run at the end of each line ensures that all lines have at least one
// run, even lines consisting of only a newline.
//
// Use the faster pango.LayoutIter.GetRunReadonly() if you do not plan to modify
// the contents of the run (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//    - layoutRun (optional): current run.
//
func (iter *LayoutIter) Run() *LayoutRun {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutRun  // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_run(_arg0)
	runtime.KeepAlive(iter)

	var _layoutRun *LayoutRun // out

	if _cret != nil {
		_layoutRun = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _layoutRun
}

// RunExtents gets the extents of the current run in layout coordinates (origin
// is the top left of the entire layout).
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle to fill with ink extents, or NULL.
//    - logicalRect (optional): rectangle to fill with logical extents, or NULL.
//
func (iter *LayoutIter) RunExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.pango_layout_iter_get_run_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iter)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// RunReadonly gets the current run. When iterating by run, at the end of each
// line, there's a position with a NULL run, so this function can return NULL.
// The NULL run at the end of each line ensures that all lines have at least one
// run, even lines consisting of only a newline.
//
// This is a faster alternative to pango.LayoutIter.GetRun(), but the user is
// not expected to modify the contents of the run (glyphs, glyph widths, etc.).
//
// The function returns the following values:
//
//    - layoutRun (optional): current run, that should not be modified.
//
func (iter *LayoutIter) RunReadonly() *LayoutRun {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutRun  // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_get_run_readonly(_arg0)
	runtime.KeepAlive(iter)

	var _layoutRun *LayoutRun // out

	if _cret != nil {
		_layoutRun = (*GlyphItem)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _layoutRun
}

// NextChar moves iter forward to the next character in visual order. If iter
// was already at the end of the layout, returns FALSE.
//
// The function returns the following values:
//
//    - ok: whether motion was possible.
//
func (iter *LayoutIter) NextChar() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_next_char(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextCluster moves iter forward to the next cluster in visual order. If iter
// was already at the end of the layout, returns FALSE.
//
// The function returns the following values:
//
//    - ok: whether motion was possible.
//
func (iter *LayoutIter) NextCluster() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_next_cluster(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextLine moves iter forward to the start of the next line. If iter is already
// on the last line, returns FALSE.
//
// The function returns the following values:
//
//    - ok: whether motion was possible.
//
func (iter *LayoutIter) NextLine() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_next_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextRun moves iter forward to the next run in visual order. If iter was
// already at the end of the layout, returns FALSE.
//
// The function returns the following values:
//
//    - ok: whether motion was possible.
//
func (iter *LayoutIter) NextRun() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.pango_layout_iter_next_run(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LayoutLine: PangoLayoutLine represents one of the lines resulting from laying
// out a paragraph via PangoLayout.
//
// PangoLayoutLine structures are obtained by calling pango.Layout.GetLine() and
// are only valid until the text, attributes, or settings of the parent
// PangoLayout are modified.
//
// An instance of this type is always passed by reference.
type LayoutLine struct {
	*layoutLine
}

// layoutLine is the struct that's finalized.
type layoutLine struct {
	native *C.PangoLayoutLine
}

func marshalLayoutLine(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &LayoutLine{&layoutLine{(*C.PangoLayoutLine)(b)}}, nil
}

// Layout: layout this line belongs to, might be NULL.
func (l *LayoutLine) Layout() *Layout {
	var v *Layout // out
	v = wrapLayout(externglib.Take(unsafe.Pointer(l.native.layout)))
	return v
}

// StartIndex: start of line as byte index into layout->text.
func (l *LayoutLine) StartIndex() int {
	var v int // out
	v = int(l.native.start_index)
	return v
}

// Length: length of line in bytes.
func (l *LayoutLine) Length() int {
	var v int // out
	v = int(l.native.length)
	return v
}

// Extents computes the logical and ink extents of a layout line. See
// pango.Font.GetGlyphExtents() for details about the interpretation of the
// rectangles.
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle used to store the extents of the glyph
//      string as drawn, or NULL.
//    - logicalRect (optional): rectangle used to store the logical extents of
//      the glyph string, or NULL.
//
func (line *LayoutLine) Extents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))

	C.pango_layout_line_get_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(line)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// Height computes the height of the line, i.e. the distance between this and
// the previous lines baseline.
//
// The function returns the following values:
//
//    - height (optional): return location for the line height.
//
func (line *LayoutLine) Height() int {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.int              // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))

	C.pango_layout_line_get_height(_arg0, &_arg1)
	runtime.KeepAlive(line)

	var _height int // out

	_height = int(_arg1)

	return _height
}

// PixelExtents computes the logical and ink extents of layout_line in device
// units.
//
// This function just calls pango.LayoutLine.GetExtents() followed by two
// extents_to_pixels calls, rounding ink_rect and logical_rect such that the
// rounded rectangles fully contain the unrounded one (that is, passes them as
// first argument to extents_to_pixels).
//
// The function returns the following values:
//
//    - inkRect (optional): rectangle used to store the extents of the glyph
//      string as drawn, or NULL.
//    - logicalRect (optional): rectangle used to store the logical extents of
//      the glyph string, or NULL.
//
func (layoutLine *LayoutLine) PixelExtents() (inkRect *Rectangle, logicalRect *Rectangle) {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.PangoRectangle   // in
	var _arg2 C.PangoRectangle   // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(layoutLine)))

	C.pango_layout_line_get_pixel_extents(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(layoutLine)

	var _inkRect *Rectangle     // out
	var _logicalRect *Rectangle // out

	_inkRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_logicalRect = (*Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _inkRect, _logicalRect
}

// XRanges gets a list of visual ranges corresponding to a given logical range.
// This list is not necessarily minimal - there may be consecutive ranges which
// are adjacent. The ranges will be sorted from left to right. The ranges are
// with respect to the left edge of the entire layout, not with respect to the
// line.
//
// The function takes the following parameters:
//
//    - startIndex: start byte index of the logical range. If this value is less
//      than the start index for the line, then the first range will extend all
//      the way to the leading edge of the layout. Otherwise, it will start at
//      the leading edge of the first character.
//    - endIndex: ending byte index of the logical range. If this value is
//      greater than the end index for the line, then the last range will extend
//      all the way to the trailing edge of the layout. Otherwise, it will end at
//      the trailing edge of the last character.
//
// The function returns the following values:
//
//    - ranges: location to store a pointer to an array of ranges. The array will
//      be of length 2*n_ranges, with each range starting at (*ranges)[2*n] and
//      of width (*ranges)[2*n + 1] - (*ranges)[2*n]. This array must be freed
//      with g_free(). The coordinates are relative to the layout and are in
//      Pango units.
//
func (line *LayoutLine) XRanges(startIndex int, endIndex int) []int {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out
	var _arg3 *C.int             // in
	var _arg4 C.int              // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))
	_arg1 = C.int(startIndex)
	_arg2 = C.int(endIndex)

	C.pango_layout_line_get_x_ranges(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(line)
	runtime.KeepAlive(startIndex)
	runtime.KeepAlive(endIndex)

	var _ranges []int // out

	defer C.free(unsafe.Pointer(_arg3))
	{
		src := unsafe.Slice(_arg3, _arg4)
		_ranges = make([]int, _arg4)
		for i := 0; i < int(_arg4); i++ {
			_ranges[i] = int(src[i])
		}
	}

	return _ranges
}

// IndexToX converts an index within a line to a X position.
//
// The function takes the following parameters:
//
//    - index_: byte offset of a grapheme within the layout.
//    - trailing: integer indicating the edge of the grapheme to retrieve the
//      position of. If > 0, the trailing edge of the grapheme, if 0, the leading
//      of the grapheme.
//
// The function returns the following values:
//
//    - xPos: location to store the x_offset (in Pango units).
//
func (line *LayoutLine) IndexToX(index_ int, trailing bool) int {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.int              // out
	var _arg2 C.gboolean         // out
	var _arg3 C.int              // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))
	_arg1 = C.int(index_)
	if trailing {
		_arg2 = C.TRUE
	}

	C.pango_layout_line_index_to_x(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(line)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(trailing)

	var _xPos int // out

	_xPos = int(_arg3)

	return _xPos
}

// XToIndex converts from x offset to the byte index of the corresponding
// character within the text of the layout. If x_pos is outside the line, index_
// and trailing will point to the very first or very last position in the line.
// This determination is based on the resolved direction of the paragraph; for
// example, if the resolved direction is right-to-left, then an X position to
// the right of the line (after it) results in 0 being stored in index_ and
// trailing. An X position to the left of the line results in index_ pointing to
// the (logical) last grapheme in the line and trailing being set to the number
// of characters in that grapheme. The reverse is true for a left-to-right line.
//
// The function takes the following parameters:
//
//    - xPos: x offset (in Pango units) from the left edge of the line.
//
// The function returns the following values:
//
//    - index_: location to store calculated byte index for the grapheme in which
//      the user clicked.
//    - trailing: location to store an integer indicating where in the grapheme
//      the user clicked. It will either be zero, or the number of characters in
//      the grapheme. 0 represents the leading edge of the grapheme.
//    - ok: FALSE if x_pos was outside the line, TRUE if inside.
//
func (line *LayoutLine) XToIndex(xPos int) (index_ int, trailing int, ok bool) {
	var _arg0 *C.PangoLayoutLine // out
	var _arg1 C.int              // out
	var _arg2 C.int              // in
	var _arg3 C.int              // in
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutLine)(gextras.StructNative(unsafe.Pointer(line)))
	_arg1 = C.int(xPos)

	_cret = C.pango_layout_line_x_to_index(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(line)
	runtime.KeepAlive(xPos)

	var _index_ int   // out
	var _trailing int // out
	var _ok bool      // out

	_index_ = int(_arg2)
	_trailing = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _index_, _trailing, _ok
}

// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

// GTypeMatrix returns the GType for the type Matrix.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeMatrix() coreglib.Type {
	gtype := coreglib.Type(C.pango_matrix_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalMatrix)
	return gtype
}

// Matrix: PangoMatrix specifies a transformation between user-space and device
// coordinates.
//
// The transformation is given by
//
//    x_device = x_user * matrix->xx + y_user * matrix->xy + matrix->x0;
//    y_device = x_user * matrix->yx + y_user * matrix->yy + matrix->y0;
//
//
// An instance of this type is always passed by reference.
type Matrix struct {
	*matrix
}

// matrix is the struct that's finalized.
type matrix struct {
	native *C.PangoMatrix
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Matrix{&matrix{(*C.PangoMatrix)(b)}}, nil
}

// XX: 1st component of the transformation matrix.
func (m *Matrix) XX() float64 {
	valptr := &m.native.xx
	var v float64 // out
	v = float64(*valptr)
	return v
}

// XY: 2nd component of the transformation matrix.
func (m *Matrix) XY() float64 {
	valptr := &m.native.xy
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YX: 3rd component of the transformation matrix.
func (m *Matrix) YX() float64 {
	valptr := &m.native.yx
	var v float64 // out
	v = float64(*valptr)
	return v
}

// YY: 4th component of the transformation matrix.
func (m *Matrix) YY() float64 {
	valptr := &m.native.yy
	var v float64 // out
	v = float64(*valptr)
	return v
}

// X0: x translation.
func (m *Matrix) X0() float64 {
	valptr := &m.native.x0
	var v float64 // out
	v = float64(*valptr)
	return v
}

// Y0: y translation.
func (m *Matrix) Y0() float64 {
	valptr := &m.native.y0
	var v float64 // out
	v = float64(*valptr)
	return v
}

// XX: 1st component of the transformation matrix.
func (m *Matrix) SetXX(xx float64) {
	valptr := &m.native.xx
	*valptr = C.double(xx)
}

// XY: 2nd component of the transformation matrix.
func (m *Matrix) SetXY(xy float64) {
	valptr := &m.native.xy
	*valptr = C.double(xy)
}

// YX: 3rd component of the transformation matrix.
func (m *Matrix) SetYX(yx float64) {
	valptr := &m.native.yx
	*valptr = C.double(yx)
}

// YY: 4th component of the transformation matrix.
func (m *Matrix) SetYY(yy float64) {
	valptr := &m.native.yy
	*valptr = C.double(yy)
}

// X0: x translation.
func (m *Matrix) SetX0(x0 float64) {
	valptr := &m.native.x0
	*valptr = C.double(x0)
}

// Y0: y translation.
func (m *Matrix) SetY0(y0 float64) {
	valptr := &m.native.y0
	*valptr = C.double(y0)
}

// Concat changes the transformation represented by matrix to be the
// transformation given by first applying transformation given by new_matrix
// then applying the original transformation.
//
// The function takes the following parameters:
//
//    - newMatrix: PangoMatrix.
//
func (matrix *Matrix) Concat(newMatrix *Matrix) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 *C.PangoMatrix // out

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	_arg1 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(newMatrix)))

	C.pango_matrix_concat(_arg0, _arg1)
	runtime.KeepAlive(matrix)
	runtime.KeepAlive(newMatrix)
}

// Copy copies a PangoMatrix.
//
// The function returns the following values:
//
//    - ret (optional): newly allocated PangoMatrix, which should be freed with
//      pango.Matrix.Free(), or NULL if matrix was NULL.
//
func (matrix *Matrix) Copy() *Matrix {
	var _arg0 *C.PangoMatrix // out
	var _cret *C.PangoMatrix // in

	if matrix != nil {
		_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	_cret = C.pango_matrix_copy(_arg0)
	runtime.KeepAlive(matrix)

	var _ret *Matrix // out

	if _cret != nil {
		_ret = (*Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_matrix_free((*C.PangoMatrix)(intern.C))
			},
		)
	}

	return _ret
}

// FontScaleFactor returns the scale factor of a matrix on the height of the
// font.
//
// That is, the scale factor in the direction perpendicular to the vector that
// the X coordinate is mapped to. If the scale in the X coordinate is needed as
// well, use pango.Matrix.GetFontScaleFactors().
//
// The function returns the following values:
//
//    - gdouble: scale factor of matrix on the height of the font, or 1.0 if
//      matrix is NULL.
//
func (matrix *Matrix) FontScaleFactor() float64 {
	var _arg0 *C.PangoMatrix // out
	var _cret C.double       // in

	if matrix != nil {
		_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	_cret = C.pango_matrix_get_font_scale_factor(_arg0)
	runtime.KeepAlive(matrix)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// FontScaleFactors calculates the scale factor of a matrix on the width and
// height of the font.
//
// That is, xscale is the scale factor in the direction of the X coordinate, and
// yscale is the scale factor in the direction perpendicular to the vector that
// the X coordinate is mapped to.
//
// Note that output numbers will always be non-negative.
//
// The function returns the following values:
//
//    - xscale (optional): output scale factor in the x direction, or NULL.
//    - yscale (optional): output scale factor perpendicular to the x direction,
//      or NULL.
//
func (matrix *Matrix) FontScaleFactors() (xscale float64, yscale float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // in
	var _arg2 C.double       // in

	if matrix != nil {
		_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	C.pango_matrix_get_font_scale_factors(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(matrix)

	var _xscale float64 // out
	var _yscale float64 // out

	_xscale = float64(_arg1)
	_yscale = float64(_arg2)

	return _xscale, _yscale
}

// Rotate changes the transformation represented by matrix to be the
// transformation given by first rotating by degrees degrees counter-clockwise
// then applying the original transformation.
//
// The function takes the following parameters:
//
//    - degrees to rotate counter-clockwise.
//
func (matrix *Matrix) Rotate(degrees float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	_arg1 = C.double(degrees)

	C.pango_matrix_rotate(_arg0, _arg1)
	runtime.KeepAlive(matrix)
	runtime.KeepAlive(degrees)
}

// Scale changes the transformation represented by matrix to be the
// transformation given by first scaling by sx in the X direction and sy in the
// Y direction then applying the original transformation.
//
// The function takes the following parameters:
//
//    - scaleX: amount to scale by in X direction.
//    - scaleY: amount to scale by in Y direction.
//
func (matrix *Matrix) Scale(scaleX float64, scaleY float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	_arg1 = C.double(scaleX)
	_arg2 = C.double(scaleY)

	C.pango_matrix_scale(_arg0, _arg1, _arg2)
	runtime.KeepAlive(matrix)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
}

// Translate changes the transformation represented by matrix to be the
// transformation given by first translating by (tx, ty) then applying the
// original transformation.
//
// The function takes the following parameters:
//
//    - tx: amount to translate in the X direction.
//    - ty: amount to translate in the Y direction.
//
func (matrix *Matrix) Translate(tx float64, ty float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out

	_arg0 = (*C.PangoMatrix)(gextras.StructNative(unsafe.Pointer(matrix)))
	_arg1 = C.double(tx)
	_arg2 = C.double(ty)

	C.pango_matrix_translate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(matrix)
	runtime.KeepAlive(tx)
	runtime.KeepAlive(ty)
}

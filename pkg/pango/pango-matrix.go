// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeMatrix returns the GType for the type Matrix.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeMatrix() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Pango", "Matrix").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalMatrix)
	return gtype
}

// Matrix: PangoMatrix specifies a transformation between user-space and device
// coordinates.
//
// The transformation is given by
//
//    x_device = x_user * matrix->xx + y_user * matrix->xy + matrix->x0;
//    y_device = x_user * matrix->yx + y_user * matrix->yy + matrix->y0;
//
//
// An instance of this type is always passed by reference.
type Matrix struct {
	*matrix
}

// matrix is the struct that's finalized.
type matrix struct {
	native unsafe.Pointer
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Matrix{&matrix{(unsafe.Pointer)(b)}}, nil
}

// XX: 1st component of the transformation matrix.
func (m *Matrix) XX() float64 {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("xx")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	var v float64 // out
	v = float64(*(*C.double)(unsafe.Pointer(&*valptr)))
	return v
}

// XY: 2nd component of the transformation matrix.
func (m *Matrix) XY() float64 {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("xy")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	var v float64 // out
	v = float64(*(*C.double)(unsafe.Pointer(&*valptr)))
	return v
}

// YX: 3rd component of the transformation matrix.
func (m *Matrix) YX() float64 {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("yx")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	var v float64 // out
	v = float64(*(*C.double)(unsafe.Pointer(&*valptr)))
	return v
}

// YY: 4th component of the transformation matrix.
func (m *Matrix) YY() float64 {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("yy")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	var v float64 // out
	v = float64(*(*C.double)(unsafe.Pointer(&*valptr)))
	return v
}

// X0: x translation.
func (m *Matrix) X0() float64 {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("x0")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	var v float64 // out
	v = float64(*(*C.double)(unsafe.Pointer(&*valptr)))
	return v
}

// Y0: y translation.
func (m *Matrix) Y0() float64 {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("y0")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	var v float64 // out
	v = float64(*(*C.double)(unsafe.Pointer(&*valptr)))
	return v
}

// XX: 1st component of the transformation matrix.
func (m *Matrix) SetXX(xx float64) {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("xx")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	*(*C.double)(unsafe.Pointer(&*valptr)) = C.double(xx)
}

// XY: 2nd component of the transformation matrix.
func (m *Matrix) SetXY(xy float64) {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("xy")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	*(*C.double)(unsafe.Pointer(&*valptr)) = C.double(xy)
}

// YX: 3rd component of the transformation matrix.
func (m *Matrix) SetYX(yx float64) {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("yx")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	*(*C.double)(unsafe.Pointer(&*valptr)) = C.double(yx)
}

// YY: 4th component of the transformation matrix.
func (m *Matrix) SetYY(yy float64) {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("yy")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	*(*C.double)(unsafe.Pointer(&*valptr)) = C.double(yy)
}

// X0: x translation.
func (m *Matrix) SetX0(x0 float64) {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("x0")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	*(*C.double)(unsafe.Pointer(&*valptr)) = C.double(x0)
}

// Y0: y translation.
func (m *Matrix) SetY0(y0 float64) {
	offset := girepository.MustFind("Pango", "Matrix").StructFieldOffset("y0")
	valptr := (*uintptr)(unsafe.Add(m.native, offset))
	*(*C.double)(unsafe.Pointer(&*valptr)) = C.double(y0)
}

// Concat changes the transformation represented by matrix to be the
// transformation given by first applying transformation given by new_matrix
// then applying the original transformation.
//
// The function takes the following parameters:
//
//    - newMatrix: PangoMatrix.
//
func (matrix *Matrix) Concat(newMatrix *Matrix) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(newMatrix)))

	runtime.KeepAlive(matrix)
	runtime.KeepAlive(newMatrix)
}

// Copy copies a PangoMatrix.
//
// The function returns the following values:
//
//    - ret (optional): newly allocated PangoMatrix, which should be freed with
//      pango.Matrix.Free(), or NULL if matrix was NULL.
//
func (matrix *Matrix) Copy() *Matrix {
	var _args [1]girepository.Argument

	if matrix != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(matrix)

	var _ret *Matrix // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_ret = (*Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_ret)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Pango", "Matrix").InvokeMethod("free", args[:], nil)
				}
			},
		)
	}

	return _ret
}

// FontScaleFactor returns the scale factor of a matrix on the height of the
// font.
//
// That is, the scale factor in the direction perpendicular to the vector that
// the X coordinate is mapped to. If the scale in the X coordinate is needed as
// well, use pango.Matrix.GetFontScaleFactors().
//
// The function returns the following values:
//
//    - gdouble: scale factor of matrix on the height of the font, or 1.0 if
//      matrix is NULL.
//
func (matrix *Matrix) FontScaleFactor() float64 {
	var _args [1]girepository.Argument

	if matrix != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	_cret = *(*C.double)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(matrix)

	var _gdouble float64 // out

	_gdouble = float64(*(*C.double)(unsafe.Pointer(&_cret)))

	return _gdouble
}

// FontScaleFactors calculates the scale factor of a matrix on the width and
// height of the font.
//
// That is, xscale is the scale factor in the direction of the X coordinate, and
// yscale is the scale factor in the direction perpendicular to the vector that
// the X coordinate is mapped to.
//
// Note that output numbers will always be non-negative.
//
// The function returns the following values:
//
//    - xscale (optional): output scale factor in the x direction, or NULL.
//    - yscale (optional): output scale factor perpendicular to the x direction,
//      or NULL.
//
func (matrix *Matrix) FontScaleFactors() (xscale float64, yscale float64) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	if matrix != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	}

	runtime.KeepAlive(matrix)

	var _xscale float64 // out
	var _yscale float64 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_xscale = *(*float64)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_yscale = *(*float64)(unsafe.Pointer(_outs[1]))
	}

	return _xscale, _yscale
}

// Rotate changes the transformation represented by matrix to be the
// transformation given by first rotating by degrees degrees counter-clockwise
// then applying the original transformation.
//
// The function takes the following parameters:
//
//    - degrees to rotate counter-clockwise.
//
func (matrix *Matrix) Rotate(degrees float64) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	*(*C.double)(unsafe.Pointer(&_args[1])) = C.double(degrees)

	runtime.KeepAlive(matrix)
	runtime.KeepAlive(degrees)
}

// Scale changes the transformation represented by matrix to be the
// transformation given by first scaling by sx in the X direction and sy in the
// Y direction then applying the original transformation.
//
// The function takes the following parameters:
//
//    - scaleX: amount to scale by in X direction.
//    - scaleY: amount to scale by in Y direction.
//
func (matrix *Matrix) Scale(scaleX float64, scaleY float64) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	*(*C.double)(unsafe.Pointer(&_args[1])) = C.double(scaleX)
	*(*C.double)(unsafe.Pointer(&_args[2])) = C.double(scaleY)

	runtime.KeepAlive(matrix)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
}

// Translate changes the transformation represented by matrix to be the
// transformation given by first translating by (tx, ty) then applying the
// original transformation.
//
// The function takes the following parameters:
//
//    - tx: amount to translate in the X direction.
//    - ty: amount to translate in the Y direction.
//
func (matrix *Matrix) Translate(tx float64, ty float64) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	*(*C.double)(unsafe.Pointer(&_args[1])) = C.double(tx)
	*(*C.double)(unsafe.Pointer(&_args[2])) = C.double(ty)

	runtime.KeepAlive(matrix)
	runtime.KeepAlive(tx)
	runtime.KeepAlive(ty)
}

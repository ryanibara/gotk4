// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <pango/pango.h>
// PangoFontMap* _gotk4_pango1_Font_virtual_get_font_map(void* fnptr, PangoFont* arg0) {
//   return ((PangoFontMap* (*)(PangoFont*))(fnptr))(arg0);
// };
import "C"

// FontMap gets the font map for which the font was created.
//
// Note that the font maintains a *weak* reference to the font map, so if all
// references to font map are dropped, the font map will be finalized even if
// there are fonts created with the font map that are still alive. In that case
// this function will return NULL.
//
// It is the responsibility of the user to ensure that the font map is kept
// alive. In most uses this is not an issue as a Context holds a reference to
// the font map.
//
// The function returns the following values:
//
//    - fontMap (optional): PangoFontMap for the font, or NULL if font is NULL.
//
func (font *Font) FontMap() FontMapper {
	var _arg0 *C.PangoFont    // out
	var _cret *C.PangoFontMap // in

	if font != nil {
		_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}

	_cret = C.pango_font_get_font_map(_arg0)
	runtime.KeepAlive(font)

	var _fontMap FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontMapper)
				return ok
			})
			rv, ok := casted.(FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// fontMap gets the font map for which the font was created.
//
// Note that the font maintains a *weak* reference to the font map, so if all
// references to font map are dropped, the font map will be finalized even if
// there are fonts created with the font map that are still alive. In that case
// this function will return NULL.
//
// It is the responsibility of the user to ensure that the font map is kept
// alive. In most uses this is not an issue as a Context holds a reference to
// the font map.
//
// The function returns the following values:
//
//    - fontMap (optional): PangoFontMap for the font, or NULL if font is NULL.
//
func (font *Font) fontMap() FontMapper {
	gclass := (*C.PangoFontClass)(coreglib.PeekParentClass(font))
	fnarg := gclass.get_font_map

	var _arg0 *C.PangoFont    // out
	var _cret *C.PangoFontMap // in

	if font != nil {
		_arg0 = (*C.PangoFont)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	}

	_cret = C._gotk4_pango1_Font_virtual_get_font_map(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(font)

	var _fontMap FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(FontMapper)
				return ok
			})
			rv, ok := casted.(FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

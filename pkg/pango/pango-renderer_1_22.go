// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <pango/pango.h>
// void _gotk4_pango1_Renderer_virtual_draw_glyph_item(void* fnptr, PangoRenderer* arg0, char* arg1, PangoGlyphItem* arg2, int arg3, int arg4) {
//   ((void (*)(PangoRenderer*, char*, PangoGlyphItem*, int, int))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
import "C"

// DrawGlyphItem draws the glyphs in glyph_item with the specified
// PangoRenderer, embedding the text associated with the glyphs in the output if
// the output format supports it.
//
// This is useful for rendering text in PDF.
//
// Note that text is the start of the text for layout, which is then indexed by
// glyph_item->item->offset.
//
// If text is NULL, this simply calls pango.Renderer.DrawGlyphs().
//
// The default implementation of this method simply falls back to
// pango.Renderer.DrawGlyphs().
//
// The function takes the following parameters:
//
//    - text (optional): UTF-8 text that glyph_item refers to, or NULL.
//    - glyphItem: PangoGlyphItem.
//    - x: x position of left edge of baseline, in user space coordinates in
//      Pango units.
//    - y: y position of left edge of baseline, in user space coordinates in
//      Pango units.
//
func (renderer *Renderer) DrawGlyphItem(text string, glyphItem *GlyphItem, x, y int) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 *C.char           // out
	var _arg2 *C.PangoGlyphItem // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(glyphItem)))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	C.pango_renderer_draw_glyph_item(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(glyphItem)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// drawGlyphItem draws the glyphs in glyph_item with the specified
// PangoRenderer, embedding the text associated with the glyphs in the output if
// the output format supports it.
//
// This is useful for rendering text in PDF.
//
// Note that text is the start of the text for layout, which is then indexed by
// glyph_item->item->offset.
//
// If text is NULL, this simply calls pango.Renderer.DrawGlyphs().
//
// The default implementation of this method simply falls back to
// pango.Renderer.DrawGlyphs().
//
// The function takes the following parameters:
//
//    - text (optional): UTF-8 text that glyph_item refers to, or NULL.
//    - glyphItem: PangoGlyphItem.
//    - x: x position of left edge of baseline, in user space coordinates in
//      Pango units.
//    - y: y position of left edge of baseline, in user space coordinates in
//      Pango units.
//
func (renderer *Renderer) drawGlyphItem(text string, glyphItem *GlyphItem, x, y int) {
	gclass := (*C.PangoRendererClass)(coreglib.PeekParentClass(renderer))
	fnarg := gclass.draw_glyph_item

	var _arg0 *C.PangoRenderer  // out
	var _arg1 *C.char           // out
	var _arg2 *C.PangoGlyphItem // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.PangoGlyphItem)(gextras.StructNative(unsafe.Pointer(glyphItem)))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	C._gotk4_pango1_Renderer_virtual_draw_glyph_item(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(glyphItem)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

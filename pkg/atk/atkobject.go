// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"fmt"
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: atk
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <atk/atk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.atk_layer_get_type()), F: marshalLayer},
		{T: externglib.Type(C.atk_role_get_type()), F: marshalRole},
		{T: externglib.Type(C.atk_implementor_get_type()), F: marshalImplementorIfacer},
		{T: externglib.Type(C.atk_object_get_type()), F: marshalObjectClasser},
	})
}

// AttributeSet: this is a singly-linked list (a List) of Attribute. It is used
// by atk_text_get_run_attributes(), atk_text_get_default_attributes(),
// atk_editable_text_set_run_attributes(), atk_document_get_attributes() and
// atk_object_get_attributes().
type AttributeSet = externglib.SList

// Layer describes the layer of a component
//
// These enumerated "layer values" are used when determining which UI rendering
// layer a component is drawn into, which can help in making determinations of
// when components occlude one another.
type Layer int

const (
	// LayerInvalid: object does not have a layer.
	LayerInvalid Layer = iota
	// LayerBackground: this layer is reserved for the desktop background.
	LayerBackground
	// LayerCanvas: this layer is used for Canvas components.
	LayerCanvas
	// LayerWidget: this layer is normally used for components.
	LayerWidget
	// LayerMDI: this layer is used for layered components.
	LayerMDI
	// LayerPopup: this layer is used for popup components, such as menus.
	LayerPopup
	// LayerOverlay: this layer is reserved for future use.
	LayerOverlay
	// LayerWindow: this layer is used for toplevel windows.
	LayerWindow
)

func marshalLayer(p uintptr) (interface{}, error) {
	return Layer(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Layer.
func (l Layer) String() string {
	switch l {
	case LayerInvalid:
		return "Invalid"
	case LayerBackground:
		return "Background"
	case LayerCanvas:
		return "Canvas"
	case LayerWidget:
		return "Widget"
	case LayerMDI:
		return "MDI"
	case LayerPopup:
		return "Popup"
	case LayerOverlay:
		return "Overlay"
	case LayerWindow:
		return "Window"
	default:
		return fmt.Sprintf("Layer(%d)", l)
	}
}

// Role describes the role of an object
//
// These are the built-in enumerated roles that UI components can have in ATK.
// Other roles may be added at runtime, so an AtkRole >= ATK_ROLE_LAST_DEFINED
// is not necessarily an error.
type Role int

const (
	// RoleInvalid: invalid role.
	RoleInvalid Role = iota
	// RoleAccelLabel: label which represents an accelerator.
	RoleAccelLabel
	// RoleAlert: object which is an alert to the user. Assistive Technologies
	// typically respond to ATK_ROLE_ALERT by reading the entire onscreen
	// contents of containers advertising this role. Should be used for warning
	// dialogs, etc.
	RoleAlert
	// RoleAnimation: object which is an animated image.
	RoleAnimation
	// RoleArrow: arrow in one of the four cardinal directions.
	RoleArrow
	// RoleCalendar: object that displays a calendar and allows the user to
	// select a date.
	RoleCalendar
	// RoleCanvas: object that can be drawn into and is used to trap events.
	RoleCanvas
	// RoleCheckBox: choice that can be checked or unchecked and provides a
	// separate indicator for the current state.
	RoleCheckBox
	// RoleCheckMenuItem: menu item with a check box.
	RoleCheckMenuItem
	// RoleColorChooser: specialized dialog that lets the user choose a color.
	RoleColorChooser
	// RoleColumnHeader: header for a column of data.
	RoleColumnHeader
	// RoleComboBox: collapsible list of choices the user can select from.
	RoleComboBox
	// RoleDateEditor: object whose purpose is to allow a user to edit a date.
	RoleDateEditor
	// RoleDesktopIcon: inconifed internal frame within a DESKTOP_PANE.
	RoleDesktopIcon
	// RoleDesktopFrame: pane that supports internal frames and iconified
	// versions of those internal frames.
	RoleDesktopFrame
	// RoleDial: object whose purpose is to allow a user to set a value.
	RoleDial
	// RoleDialog: top level window with title bar and a border.
	RoleDialog
	// RoleDirectoryPane: pane that allows the user to navigate through and
	// select the contents of a directory.
	RoleDirectoryPane
	// RoleDrawingArea: object used for drawing custom user interface elements.
	RoleDrawingArea
	// RoleFileChooser: specialized dialog that lets the user choose a file.
	RoleFileChooser
	// RoleFiller: object that fills up space in a user interface.
	RoleFiller
	// RoleFontChooser: specialized dialog that lets the user choose a font.
	RoleFontChooser
	// RoleFrame: top level window with a title bar, border, menubar, etc.
	RoleFrame
	// RoleGlassPane: pane that is guaranteed to be painted on top of all panes
	// beneath it.
	RoleGlassPane
	// RoleHtmlContainer: document container for HTML, whose children represent
	// the document content.
	RoleHtmlContainer
	// RoleIcon: small fixed size picture, typically used to decorate
	// components.
	RoleIcon
	// RoleImage: object whose primary purpose is to display an image.
	RoleImage
	// RoleInternalFrame: frame-like object that is clipped by a desktop pane.
	RoleInternalFrame
	// RoleLabel: object used to present an icon or short string in an
	// interface.
	RoleLabel
	// RoleLayeredPane: specialized pane that allows its children to be drawn in
	// layers, providing a form of stacking order.
	RoleLayeredPane
	// RoleList: object that presents a list of objects to the user and allows
	// the user to select one or more of them.
	RoleList
	// RoleListItem: object that represents an element of a list.
	RoleListItem
	// RoleMenu: object usually found inside a menu bar that contains a list of
	// actions the user can choose from.
	RoleMenu
	// RoleMenuBar: object usually drawn at the top of the primary dialog box of
	// an application that contains a list of menus the user can choose from.
	RoleMenuBar
	// RoleMenuItem: object usually contained in a menu that presents an action
	// the user can choose.
	RoleMenuItem
	// RoleOptionPane: specialized pane whose primary use is inside a DIALOG.
	RoleOptionPane
	// RolePageTab: object that is a child of a page tab list.
	RolePageTab
	// RolePageTabList: object that presents a series of panels (or page tabs),
	// one at a time, through some mechanism provided by the object.
	RolePageTabList
	// RolePanel: generic container that is often used to group objects.
	RolePanel
	// RolePasswordText: text object uses for passwords, or other places where
	// the text content is not shown visibly to the user.
	RolePasswordText
	// RolePopupMenu: temporary window that is usually used to offer the user a
	// list of choices, and then hides when the user selects one of those
	// choices.
	RolePopupMenu
	// RoleProgressBar: object used to indicate how much of a task has been
	// completed.
	RoleProgressBar
	// RolePushButton: object the user can manipulate to tell the application to
	// do something.
	RolePushButton
	// RoleRadioButton: specialized check box that will cause other radio
	// buttons in the same group to become unchecked when this one is checked.
	RoleRadioButton
	// RoleRadioMenuItem: check menu item which belongs to a group. At each
	// instant exactly one of the radio menu items from a group is selected.
	RoleRadioMenuItem
	// RoleRootPane: specialized pane that has a glass pane and a layered pane
	// as its children.
	RoleRootPane
	// RoleRowHeader: header for a row of data.
	RoleRowHeader
	// RoleScrollBar: object usually used to allow a user to incrementally view
	// a large amount of data.
	RoleScrollBar
	// RoleScrollPane: object that allows a user to incrementally view a large
	// amount of information.
	RoleScrollPane
	// RoleSeparator: object usually contained in a menu to provide a visible
	// and logical separation of the contents in a menu.
	RoleSeparator
	// RoleSlider: object that allows the user to select from a bounded range.
	RoleSlider
	// RoleSplitPane: specialized panel that presents two other panels at the
	// same time.
	RoleSplitPane
	// RoleSpinButton: object used to get an integer or floating point number
	// from the user.
	RoleSpinButton
	// RoleStatusbar: object which reports messages of minor importance to the
	// user.
	RoleStatusbar
	// RoleTable: object used to represent information in terms of rows and
	// columns.
	RoleTable
	// RoleTableCell: cell in a table.
	RoleTableCell
	// RoleTableColumnHeader: header for a column of a table.
	RoleTableColumnHeader
	// RoleTableRowHeader: header for a row of a table.
	RoleTableRowHeader
	// RoleTearOffMenuItem: menu item used to tear off and reattach its menu.
	RoleTearOffMenuItem
	// RoleTerminal: object that represents an accessible terminal. (Since:
	// 0.6).
	RoleTerminal
	// RoleText: interactive widget that supports multiple lines of text and
	// optionally accepts user input, but whose purpose is not to solicit user
	// input. Thus ATK_ROLE_TEXT is appropriate for the text view in a plain
	// text editor but inappropriate for an input field in a dialog box or web
	// form. For widgets whose purpose is to solicit input from the user, see
	// ATK_ROLE_ENTRY and ATK_ROLE_PASSWORD_TEXT. For generic objects which
	// display a brief amount of textual information, see ATK_ROLE_STATIC.
	RoleText
	// RoleToggleButton: specialized push button that can be checked or
	// unchecked, but does not provide a separate indicator for the current
	// state.
	RoleToggleButton
	// RoleToolBar: bar or palette usually composed of push buttons or toggle
	// buttons.
	RoleToolBar
	// RoleToolTip: object that provides information about another object.
	RoleToolTip
	// RoleTree: object used to represent hierarchical information to the user.
	RoleTree
	// RoleTreeTable: object capable of expanding and collapsing rows as well as
	// showing multiple columns of data. (Since: 0.7).
	RoleTreeTable
	// RoleUnknown: object contains some Accessible information, but its role is
	// not known.
	RoleUnknown
	// RoleViewport: object usually used in a scroll pane.
	RoleViewport
	// RoleWindow: top level window with no title or border.
	RoleWindow
	// RoleHeader: object that serves as a document header. (Since: 1.1.1).
	RoleHeader
	// RoleFooter: object that serves as a document footer. (Since: 1.1.1).
	RoleFooter
	// RoleParagraph: object which is contains a paragraph of text content.
	// (Since: 1.1.1).
	RoleParagraph
	// RoleRuler: object which describes margins and tab stops, etc. for text
	// objects which it controls (should have CONTROLLER_FOR relation to such).
	// (Since: 1.1.1).
	RoleRuler
	// RoleApplication: object is an application object, which may contain
	// ATK_ROLE_FRAME objects or other types of accessibles. The root accessible
	// of any application's ATK hierarchy should have ATK_ROLE_APPLICATION.
	// (Since: 1.1.4).
	RoleApplication
	// RoleAutocomplete: object is a dialog or list containing items for
	// insertion into an entry widget, for instance a list of words for
	// completion of a text entry. (Since: 1.3).
	RoleAutocomplete
	// RoleEditbar: object is an editable text object in a toolbar. (Since:
	// 1.5).
	RoleEditbar
	// RoleEmbedded: object is an embedded container within a document or panel.
	// This role is a grouping "hint" indicating that the contained objects
	// share a context. (Since: 1.7.2).
	RoleEmbedded
	// RoleEntry: object is a component whose textual content may be entered or
	// modified by the user, provided ATK_STATE_EDITABLE is present. (Since:
	// 1.11).
	RoleEntry
	// RoleChart: object is a graphical depiction of quantitative data. It may
	// contain multiple subelements whose attributes and/or description may be
	// queried to obtain both the quantitative data and information about how
	// the data is being presented. The LABELLED_BY relation is particularly
	// important in interpreting objects of this type, as is the
	// accessible-description property. (Since: 1.11).
	RoleChart
	// RoleCaption: object contains descriptive information, usually textual,
	// about another user interface element such as a table, chart, or image.
	// (Since: 1.11).
	RoleCaption
	// RoleDocumentFrame: object is a visual frame or container which contains a
	// view of document content. Document frames may occur within another
	// Document instance, in which case the second document may be said to be
	// embedded in the containing instance. HTML frames are often
	// ROLE_DOCUMENT_FRAME. Either this object, or a singleton descendant,
	// should implement the Document interface. (Since: 1.11).
	RoleDocumentFrame
	// RoleHeading: object serves as a heading for content which follows it in a
	// document. The 'heading level' of the heading, if availabe, may be
	// obtained by querying the object's attributes.
	RoleHeading
	// RolePage: object is a containing instance which encapsulates a page of
	// information. ATK_ROLE_PAGE is used in documents and content which support
	// a paginated navigation model. (Since: 1.11).
	RolePage
	// RoleSection: object is a containing instance of document content which
	// constitutes a particular 'logical' section of the document. The type of
	// content within a section, and the nature of the section division itself,
	// may be obtained by querying the object's attributes. Sections may be
	// nested. (Since: 1.11).
	RoleSection
	// RoleRedundantObject: object is redundant with another object in the
	// hierarchy, and is exposed for purely technical reasons. Objects of this
	// role should normally be ignored by clients. (Since: 1.11).
	RoleRedundantObject
	// RoleForm: object is a container for form controls, for instance as part
	// of a web form or user-input form within a document. This role is
	// primarily a tag/convenience for clients when navigating complex
	// documents, it is not expected that ordinary GUI containers will always
	// have ATK_ROLE_FORM. (Since: 1.12.0).
	RoleForm
	// RoleLink: object is a hypertext anchor, i.e. a "link" in a hypertext
	// document. Such objects are distinct from 'inline' content which may also
	// use the Hypertext/Hyperlink interfaces to indicate the range/location
	// within a text object where an inline or embedded object lies. (Since:
	// 1.12.1).
	RoleLink
	// RoleInputMethodWindow: object is a window or similar viewport which is
	// used to allow composition or input of a 'complex character', in other
	// words it is an "input method window." (Since: 1.12.1).
	RoleInputMethodWindow
	// RoleTableRow: row in a table. (Since: 2.1.0).
	RoleTableRow
	// RoleTreeItem: object that represents an element of a tree. (Since:
	// 2.1.0).
	RoleTreeItem
	// RoleDocumentSpreadsheet: document frame which contains a spreadsheet.
	// (Since: 2.1.0).
	RoleDocumentSpreadsheet
	// RoleDocumentPresentation: document frame which contains a presentation or
	// slide content. (Since: 2.1.0).
	RoleDocumentPresentation
	// RoleDocumentText: document frame which contains textual content, such as
	// found in a word processing application. (Since: 2.1.0).
	RoleDocumentText
	// RoleDocumentWeb: document frame which contains HTML or other markup
	// suitable for display in a web browser. (Since: 2.1.0).
	RoleDocumentWeb
	// RoleDocumentEmail: document frame which contains email content to be
	// displayed or composed either in plain text or HTML. (Since: 2.1.0).
	RoleDocumentEmail
	// RoleComment: object found within a document and designed to present a
	// comment, note, or other annotation. In some cases, this object might not
	// be visible until activated. (Since: 2.1.0).
	RoleComment
	// RoleListBox: non-collapsible list of choices the user can select from.
	// (Since: 2.1.0).
	RoleListBox
	// RoleGrouping: group of related widgets. This group typically has a label.
	// (Since: 2.1.0).
	RoleGrouping
	// RoleImageMap: image map object. Usually a graphic with multiple hotspots,
	// where each hotspot can be activated resulting in the loading of another
	// document or section of a document. (Since: 2.1.0).
	RoleImageMap
	// RoleNotification: transitory object designed to present a message to the
	// user, typically at the desktop level rather than inside a particular
	// application. (Since: 2.1.0).
	RoleNotification
	// RoleInfoBar: object designed to present a message to the user within an
	// existing window. (Since: 2.1.0).
	RoleInfoBar
	// RoleLevelBar: bar that serves as a level indicator to, for instance, show
	// the strength of a password or the state of a battery. (Since: 2.7.3).
	RoleLevelBar
	// RoleTitleBar: bar that serves as the title of a window or a dialog.
	// (Since: 2.12).
	RoleTitleBar
	// RoleBlockQuote: object which contains a text section that is quoted from
	// another source. (Since: 2.12).
	RoleBlockQuote
	// RoleAudio: object which represents an audio element. (Since: 2.12).
	RoleAudio
	// RoleVideo: object which represents a video element. (Since: 2.12).
	RoleVideo
	// RoleDefinition: definition of a term or concept. (Since: 2.12).
	RoleDefinition
	// RoleArticle: section of a page that consists of a composition that forms
	// an independent part of a document, page, or site. Examples: A blog entry,
	// a news story, a forum post. (Since: 2.12).
	RoleArticle
	// RoleLandmark: region of a web page intended as a navigational landmark.
	// This is designed to allow Assistive Technologies to provide quick
	// navigation among key regions within a document. (Since: 2.12).
	RoleLandmark
	// RoleLog: text widget or container holding log content, such as chat
	// history and error logs. In this role there is a relationship between the
	// arrival of new items in the log and the reading order. The log contains a
	// meaningful sequence and new information is added only to the end of the
	// log, not at arbitrary points. (Since: 2.12).
	RoleLog
	// RoleMarquee: container where non-essential information changes
	// frequently. Common usages of marquee include stock tickers and ad
	// banners. The primary difference between a marquee and a log is that logs
	// usually have a meaningful order or sequence of important content changes.
	// (Since: 2.12).
	RoleMarquee
	// RoleMath: text widget or container that holds a mathematical expression.
	// (Since: 2.12).
	RoleMath
	// RoleRating: widget whose purpose is to display a rating, such as the
	// number of stars associated with a song in a media player. Objects of this
	// role should also implement AtkValue. (Since: 2.12).
	RoleRating
	// RoleTimer: object containing a numerical counter which indicates an
	// amount of elapsed time from a start point, or the time remaining until an
	// end point. (Since: 2.12).
	RoleTimer
	// RoleDescriptionList: object that represents a list of term-value groups.
	// A term-value group represents a individual description and consist of one
	// or more names (ATK_ROLE_DESCRIPTION_TERM) followed by one or more values
	// (ATK_ROLE_DESCRIPTION_VALUE). For each list, there should not be more
	// than one group with the same term name. (Since: 2.12).
	RoleDescriptionList
	// RoleDescriptionTerm: object that represents a term or phrase with a
	// corresponding definition. (Since: 2.12).
	RoleDescriptionTerm
	// RoleDescriptionValue: object that represents the description, definition
	// or value of a term. (Since: 2.12).
	RoleDescriptionValue
	// RoleStatic: generic non-container object whose purpose is to display a
	// brief amount of information to the user and whose role is known by the
	// implementor but lacks semantic value for the user. Examples in which
	// ATK_ROLE_STATIC is appropriate include the message displayed in a message
	// box and an image used as an alternative means to display text.
	// ATK_ROLE_STATIC should not be applied to widgets which are traditionally
	// interactive, objects which display a significant amount of content, or
	// any object which has an accessible relation pointing to another object.
	// Implementors should expose the displayed information through the
	// accessible name of the object. If doing so seems inappropriate, it may
	// indicate that a different role should be used. For labels which describe
	// another widget, see ATK_ROLE_LABEL. For text views, see ATK_ROLE_TEXT.
	// For generic containers, see ATK_ROLE_PANEL. For objects whose role is not
	// known by the implementor, see ATK_ROLE_UNKNOWN. (Since: 2.16).
	RoleStatic
	// RoleMathFraction: object that represents a mathematical fraction. (Since:
	// 2.16).
	RoleMathFraction
	// RoleMathRoot: object that represents a mathematical expression displayed
	// with a radical. (Since: 2.16).
	RoleMathRoot
	// RoleSubscript: object that contains text that is displayed as a
	// subscript. (Since: 2.16).
	RoleSubscript
	// RoleSuperscript: object that contains text that is displayed as a
	// superscript. (Since: 2.16).
	RoleSuperscript
	// RoleFootnote: object that contains the text of a footnote. (Since: 2.26).
	RoleFootnote
	// RoleContentDeletion: content previously deleted or proposed to be
	// deleted, e.g. in revision history or a content view providing suggestions
	// from reviewers. (Since: 2.34).
	RoleContentDeletion
	// RoleContentInsertion: content previously inserted or proposed to be
	// inserted, e.g. in revision history or a content view providing
	// suggestions from reviewers. (Since: 2.34).
	RoleContentInsertion
	// RoleMark: run of content that is marked or highlighted, such as for
	// reference purposes, or to call it out as having a special purpose. If the
	// marked content has an associated section in the document elaborating on
	// the reason for the mark, then ATK_RELATION_DETAILS should be used on the
	// mark to point to that associated section. In addition, the reciprocal
	// relation ATK_RELATION_DETAILS_FOR should be used on the associated
	// content section to point back to the mark. (Since: 2.36).
	RoleMark
	// RoleSuggestion: container for content that is called out as a proposed
	// change from the current version of the document, such as by a reviewer of
	// the content. This role should include either ATK_ROLE_CONTENT_DELETION
	// and/or ATK_ROLE_CONTENT_INSERTION children, in any order, to indicate
	// what the actual change is. (Since: 2.36).
	RoleSuggestion
	// RoleLastDefined: not a valid role, used for finding end of the
	// enumeration.
	RoleLastDefined
)

func marshalRole(p uintptr) (interface{}, error) {
	return Role(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Role.
func (r Role) String() string {
	switch r {
	case RoleInvalid:
		return "Invalid"
	case RoleAccelLabel:
		return "AcceleratorLabel"
	case RoleAlert:
		return "Alert"
	case RoleAnimation:
		return "Animation"
	case RoleArrow:
		return "Arrow"
	case RoleCalendar:
		return "Calendar"
	case RoleCanvas:
		return "Canvas"
	case RoleCheckBox:
		return "CheckBox"
	case RoleCheckMenuItem:
		return "CheckMenuItem"
	case RoleColorChooser:
		return "ColorChooser"
	case RoleColumnHeader:
		return "ColumnHeader"
	case RoleComboBox:
		return "ComboBox"
	case RoleDateEditor:
		return "DateEditor"
	case RoleDesktopIcon:
		return "DesktopIcon"
	case RoleDesktopFrame:
		return "DesktopFrame"
	case RoleDial:
		return "Dial"
	case RoleDialog:
		return "Dialog"
	case RoleDirectoryPane:
		return "DirectoryPane"
	case RoleDrawingArea:
		return "DrawingArea"
	case RoleFileChooser:
		return "FileChooser"
	case RoleFiller:
		return "Filler"
	case RoleFontChooser:
		return "FontChooser"
	case RoleFrame:
		return "Frame"
	case RoleGlassPane:
		return "GlassPane"
	case RoleHtmlContainer:
		return "HtmlContainer"
	case RoleIcon:
		return "Icon"
	case RoleImage:
		return "Image"
	case RoleInternalFrame:
		return "InternalFrame"
	case RoleLabel:
		return "Label"
	case RoleLayeredPane:
		return "LayeredPane"
	case RoleList:
		return "List"
	case RoleListItem:
		return "ListItem"
	case RoleMenu:
		return "Menu"
	case RoleMenuBar:
		return "MenuBar"
	case RoleMenuItem:
		return "MenuItem"
	case RoleOptionPane:
		return "OptionPane"
	case RolePageTab:
		return "PageTab"
	case RolePageTabList:
		return "PageTabList"
	case RolePanel:
		return "Panel"
	case RolePasswordText:
		return "PasswordText"
	case RolePopupMenu:
		return "PopupMenu"
	case RoleProgressBar:
		return "ProgressBar"
	case RolePushButton:
		return "PushButton"
	case RoleRadioButton:
		return "RadioButton"
	case RoleRadioMenuItem:
		return "RadioMenuItem"
	case RoleRootPane:
		return "RootPane"
	case RoleRowHeader:
		return "RowHeader"
	case RoleScrollBar:
		return "ScrollBar"
	case RoleScrollPane:
		return "ScrollPane"
	case RoleSeparator:
		return "Separator"
	case RoleSlider:
		return "Slider"
	case RoleSplitPane:
		return "SplitPane"
	case RoleSpinButton:
		return "SpinButton"
	case RoleStatusbar:
		return "Statusbar"
	case RoleTable:
		return "Table"
	case RoleTableCell:
		return "TableCell"
	case RoleTableColumnHeader:
		return "TableColumnHeader"
	case RoleTableRowHeader:
		return "TableRowHeader"
	case RoleTearOffMenuItem:
		return "TearOffMenuItem"
	case RoleTerminal:
		return "Terminal"
	case RoleText:
		return "Text"
	case RoleToggleButton:
		return "ToggleButton"
	case RoleToolBar:
		return "ToolBar"
	case RoleToolTip:
		return "ToolTip"
	case RoleTree:
		return "Tree"
	case RoleTreeTable:
		return "TreeTable"
	case RoleUnknown:
		return "Unknown"
	case RoleViewport:
		return "Viewport"
	case RoleWindow:
		return "Window"
	case RoleHeader:
		return "Header"
	case RoleFooter:
		return "Footer"
	case RoleParagraph:
		return "Paragraph"
	case RoleRuler:
		return "Ruler"
	case RoleApplication:
		return "Application"
	case RoleAutocomplete:
		return "Autocomplete"
	case RoleEditbar:
		return "EditBar"
	case RoleEmbedded:
		return "Embedded"
	case RoleEntry:
		return "Entry"
	case RoleChart:
		return "Chart"
	case RoleCaption:
		return "Caption"
	case RoleDocumentFrame:
		return "DocumentFrame"
	case RoleHeading:
		return "Heading"
	case RolePage:
		return "Page"
	case RoleSection:
		return "Section"
	case RoleRedundantObject:
		return "RedundantObject"
	case RoleForm:
		return "Form"
	case RoleLink:
		return "Link"
	case RoleInputMethodWindow:
		return "InputMethodWindow"
	case RoleTableRow:
		return "TableRow"
	case RoleTreeItem:
		return "TreeItem"
	case RoleDocumentSpreadsheet:
		return "DocumentSpreadsheet"
	case RoleDocumentPresentation:
		return "DocumentPresentation"
	case RoleDocumentText:
		return "DocumentText"
	case RoleDocumentWeb:
		return "DocumentWeb"
	case RoleDocumentEmail:
		return "DocumentEmail"
	case RoleComment:
		return "Comment"
	case RoleListBox:
		return "ListBox"
	case RoleGrouping:
		return "Grouping"
	case RoleImageMap:
		return "ImageMap"
	case RoleNotification:
		return "Notification"
	case RoleInfoBar:
		return "InfoBar"
	case RoleLevelBar:
		return "LevelBar"
	case RoleTitleBar:
		return "TitleBar"
	case RoleBlockQuote:
		return "BlockQuote"
	case RoleAudio:
		return "Audio"
	case RoleVideo:
		return "Video"
	case RoleDefinition:
		return "Definition"
	case RoleArticle:
		return "Article"
	case RoleLandmark:
		return "Landmark"
	case RoleLog:
		return "Log"
	case RoleMarquee:
		return "Marquee"
	case RoleMath:
		return "Math"
	case RoleRating:
		return "Rating"
	case RoleTimer:
		return "Timer"
	case RoleDescriptionList:
		return "DescriptionList"
	case RoleDescriptionTerm:
		return "DescriptionTerm"
	case RoleDescriptionValue:
		return "DescriptionValue"
	case RoleStatic:
		return "Static"
	case RoleMathFraction:
		return "MathFraction"
	case RoleMathRoot:
		return "MathRoot"
	case RoleSubscript:
		return "Subscript"
	case RoleSuperscript:
		return "Superscript"
	case RoleFootnote:
		return "Footnote"
	case RoleContentDeletion:
		return "ContentDeletion"
	case RoleContentInsertion:
		return "ContentInsertion"
	case RoleMark:
		return "Mark"
	case RoleSuggestion:
		return "Suggestion"
	case RoleLastDefined:
		return "LastDefined"
	default:
		return fmt.Sprintf("Role(%d)", r)
	}
}

// RoleForName: get the Role type corresponding to a rolew name.
//
// The function takes the following parameters:
//
//    - name: string which is the (non-localized) name of an ATK role.
//
func RoleForName(name string) Role {
	var _arg1 *C.gchar  // out
	var _cret C.AtkRole // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.atk_role_for_name(_arg1)
	runtime.KeepAlive(name)

	var _role Role // out

	_role = Role(_cret)

	return _role
}

// RoleGetLocalizedName gets the localized description string describing the
// Role role.
//
// The function takes the following parameters:
//
//    - role whose localized name is required.
//
func RoleGetLocalizedName(role Role) string {
	var _arg1 C.AtkRole // out
	var _cret *C.gchar  // in

	_arg1 = C.AtkRole(role)

	_cret = C.atk_role_get_localized_name(_arg1)
	runtime.KeepAlive(role)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RoleGetName gets the description string describing the Role role.
//
// The function takes the following parameters:
//
//    - role whose name is required.
//
func RoleGetName(role Role) string {
	var _arg1 C.AtkRole // out
	var _cret *C.gchar  // in

	_arg1 = C.AtkRole(role)

	_cret = C.atk_role_get_name(_arg1)
	runtime.KeepAlive(role)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RoleRegister registers the role specified by name. name must be a meaningful
// name. So it should not be empty, or consisting on whitespaces.
//
// Deprecated: Since 2.12. If your application/toolkit doesn't find a suitable
// role for a specific object defined at Role, please submit a bug in order to
// add a new role to the specification.
//
// The function takes the following parameters:
//
//    - name: character string describing the new role.
//
func RoleRegister(name string) Role {
	var _arg1 *C.gchar  // out
	var _cret C.AtkRole // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.atk_role_register(_arg1)
	runtime.KeepAlive(name)

	var _role Role // out

	_role = Role(_cret)

	return _role
}

// Function is a function definition used for padding which has been added to
// class and interface structures to allow for expansion in the future.
type Function func() (ok bool)

//export _gotk4_atk1_Function
func _gotk4_atk1_Function(arg0 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg0))
	if v == nil {
		panic(`callback not found`)
	}

	fn := v.(Function)
	ok := fn()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ImplementorIface: atkImplementor interface is implemented by objects for
// which AtkObject peers may be obtained via calls to
// iface->(ref_accessible)(implementor);.
type ImplementorIface struct {
	*externglib.Object
}

// ImplementorIfacer describes ImplementorIface's abstract methods.
type ImplementorIfacer interface {
	externglib.Objector

	privateImplementorIface()
}

var _ ImplementorIfacer = (*ImplementorIface)(nil)

func wrapImplementorIface(obj *externglib.Object) *ImplementorIface {
	return &ImplementorIface{
		Object: obj,
	}
}

func marshalImplementorIfacer(p uintptr) (interface{}, error) {
	return wrapImplementorIface(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (*ImplementorIface) privateImplementorIface() {}

// ObjectClassOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type ObjectClassOverrider interface {
	ActiveDescendantChanged(child *cgo.Handle)
	ChildrenChanged(changeIndex uint, changedChild cgo.Handle)
	FocusEvent(focusIn bool)
	// Description gets the accessible description of the accessible.
	Description() string
	// IndexInParent gets the 0-based index of this accessible in its parent;
	// returns -1 if the accessible does not have an accessible parent.
	IndexInParent() int
	// Layer gets the layer of the accessible.
	//
	// Deprecated: Use atk_component_get_layer instead.
	Layer() Layer
	// MDIZOrder gets the zorder of the accessible. The value G_MININT will be
	// returned if the layer of the accessible is not ATK_LAYER_MDI.
	//
	// Deprecated: Use atk_component_get_mdi_zorder instead.
	MDIZOrder() int
	NChildren() int
	// Name gets the accessible name of the accessible.
	Name() string
	// ObjectLocale gets a UTF-8 string indicating the POSIX-style LC_MESSAGES
	// locale of accessible.
	ObjectLocale() string
	// Parent gets the accessible parent of the accessible. By default this is
	// the one assigned with atk_object_set_parent(), but it is assumed that ATK
	// implementors have ways to get the parent of the object without the need
	// of assigning it manually with atk_object_set_parent(), and will return it
	// with this method.
	//
	// If you are only interested on the parent assigned with
	// atk_object_set_parent(), use atk_object_peek_parent().
	Parent() *ObjectClass
	// Role gets the role of the accessible.
	Role() Role
	// Initialize: this function is called when implementing subclasses of
	// Object. It does initialization required for the new object. It is
	// intended that this function should called only in the ..._new() functions
	// used to create an instance of a subclass of Object.
	Initialize(data cgo.Handle)
	PropertyChange(values *PropertyValues)
	// RefRelationSet gets the RelationSet associated with the object.
	RefRelationSet() *RelationSet
	// RefStateSet gets a reference to the state set of the accessible; the
	// caller must unreference it when it is no longer needed.
	RefStateSet() *StateSet
	// RemovePropertyChangeHandler removes a property change handler.
	//
	// Deprecated: See atk_object_connect_property_change_handler().
	RemovePropertyChangeHandler(handlerId uint)
	// SetDescription sets the accessible description of the accessible. You
	// can't set the description to NULL. This is reserved for the initial
	// value. In this aspect NULL is similar to ATK_ROLE_UNKNOWN. If you want to
	// set the name to a empty value you can use "".
	SetDescription(description string)
	// SetName sets the accessible name of the accessible. You can't set the
	// name to NULL. This is reserved for the initial value. In this aspect NULL
	// is similar to ATK_ROLE_UNKNOWN. If you want to set the name to a empty
	// value you can use "".
	SetName(name string)
	// SetParent sets the accessible parent of the accessible. parent can be
	// NULL.
	SetParent(parent *ObjectClass)
	// SetRole sets the role of the accessible.
	SetRole(role Role)
	StateChange(name string, stateSet bool)
	VisibleDataChanged()
}

// ObjectClass: this class is the primary class for accessibility support via
// the Accessibility ToolKit (ATK). Objects which are instances of Object (or
// instances of AtkObject-derived types) are queried for properties which relate
// basic (and generic) properties of a UI component such as name and
// description. Instances of Object may also be queried as to whether they
// implement other ATK interfaces (e.g. Action, Component, etc.), as appropriate
// to the role which a given UI component plays in a user interface.
//
// All UI components in an application which provide useful information or
// services to the user must provide corresponding Object instances on request
// (in GTK+, for instance, usually on a call to #gtk_widget_get_accessible ()),
// either via ATK support built into the toolkit for the widget class or
// ancestor class, or in the case of custom widgets, if the inherited Object
// implementation is insufficient, via instances of a new Object subclass.
//
// See also: ObjectFactory, Registry. (GTK+ users see also Accessible).
type ObjectClass struct {
	*externglib.Object
}

func wrapObject(obj *externglib.Object) *ObjectClass {
	return &ObjectClass{
		Object: obj,
	}
}

func marshalObjectClasser(p uintptr) (interface{}, error) {
	return wrapObject(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddRelationship adds a relationship of the specified type with the specified
// target.
//
// The function takes the following parameters:
//
//    - relationship of the relation.
//    - target which is to be the target of the relation.
//
func (object *ObjectClass) AddRelationship(relationship RelationType, target *ObjectClass) bool {
	var _arg0 *C.AtkObject      // out
	var _arg1 C.AtkRelationType // out
	var _arg2 *C.AtkObject      // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(object.Native()))
	_arg1 = C.AtkRelationType(relationship)
	_arg2 = (*C.AtkObject)(unsafe.Pointer(target.Native()))

	_cret = C.atk_object_add_relationship(_arg0, _arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(relationship)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AccessibleID gets the accessible id of the accessible.
func (accessible *ObjectClass) AccessibleID() string {
	var _arg0 *C.AtkObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_accessible_id(_arg0)
	runtime.KeepAlive(accessible)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Description gets the accessible description of the accessible.
func (accessible *ObjectClass) Description() string {
	var _arg0 *C.AtkObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_description(_arg0)
	runtime.KeepAlive(accessible)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IndexInParent gets the 0-based index of this accessible in its parent;
// returns -1 if the accessible does not have an accessible parent.
func (accessible *ObjectClass) IndexInParent() int {
	var _arg0 *C.AtkObject // out
	var _cret C.gint       // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_index_in_parent(_arg0)
	runtime.KeepAlive(accessible)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Layer gets the layer of the accessible.
//
// Deprecated: Use atk_component_get_layer instead.
func (accessible *ObjectClass) Layer() Layer {
	var _arg0 *C.AtkObject // out
	var _cret C.AtkLayer   // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_layer(_arg0)
	runtime.KeepAlive(accessible)

	var _layer Layer // out

	_layer = Layer(_cret)

	return _layer
}

// MDIZOrder gets the zorder of the accessible. The value G_MININT will be
// returned if the layer of the accessible is not ATK_LAYER_MDI.
//
// Deprecated: Use atk_component_get_mdi_zorder instead.
func (accessible *ObjectClass) MDIZOrder() int {
	var _arg0 *C.AtkObject // out
	var _cret C.gint       // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_mdi_zorder(_arg0)
	runtime.KeepAlive(accessible)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NAccessibleChildren gets the number of accessible children of the accessible.
func (accessible *ObjectClass) NAccessibleChildren() int {
	var _arg0 *C.AtkObject // out
	var _cret C.gint       // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_n_accessible_children(_arg0)
	runtime.KeepAlive(accessible)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Name gets the accessible name of the accessible.
func (accessible *ObjectClass) Name() string {
	var _arg0 *C.AtkObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_name(_arg0)
	runtime.KeepAlive(accessible)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ObjectLocale gets a UTF-8 string indicating the POSIX-style LC_MESSAGES
// locale of accessible.
func (accessible *ObjectClass) ObjectLocale() string {
	var _arg0 *C.AtkObject // out
	var _cret *C.gchar     // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_object_locale(_arg0)
	runtime.KeepAlive(accessible)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Parent gets the accessible parent of the accessible. By default this is the
// one assigned with atk_object_set_parent(), but it is assumed that ATK
// implementors have ways to get the parent of the object without the need of
// assigning it manually with atk_object_set_parent(), and will return it with
// this method.
//
// If you are only interested on the parent assigned with
// atk_object_set_parent(), use atk_object_peek_parent().
func (accessible *ObjectClass) Parent() *ObjectClass {
	var _arg0 *C.AtkObject // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_parent(_arg0)
	runtime.KeepAlive(accessible)

	var _object *ObjectClass // out

	_object = wrapObject(externglib.Take(unsafe.Pointer(_cret)))

	return _object
}

// Role gets the role of the accessible.
func (accessible *ObjectClass) Role() Role {
	var _arg0 *C.AtkObject // out
	var _cret C.AtkRole    // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_get_role(_arg0)
	runtime.KeepAlive(accessible)

	var _role Role // out

	_role = Role(_cret)

	return _role
}

// Initialize: this function is called when implementing subclasses of Object.
// It does initialization required for the new object. It is intended that this
// function should called only in the ..._new() functions used to create an
// instance of a subclass of Object.
//
// The function takes the following parameters:
//
//    - data which identifies the object for which the AtkObject was created.
//
func (accessible *ObjectClass) Initialize(data cgo.Handle) {
	var _arg0 *C.AtkObject // out
	var _arg1 C.gpointer   // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	C.atk_object_initialize(_arg0, _arg1)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(data)
}

// NotifyStateChange emits a state-change signal for the specified state.
//
// Note that as a general rule when the state of an existing object changes,
// emitting a notification is expected.
//
// The function takes the following parameters:
//
//    - state whose state is changed.
//    - value: gboolean which indicates whether the state is being set on or
//    off.
//
func (accessible *ObjectClass) NotifyStateChange(state State, value bool) {
	var _arg0 *C.AtkObject // out
	var _arg1 C.AtkState   // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = C.guint64(state)
	if value {
		_arg2 = C.TRUE
	}

	C.atk_object_notify_state_change(_arg0, _arg1, _arg2)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(state)
	runtime.KeepAlive(value)
}

// PeekParent gets the accessible parent of the accessible, if it has been
// manually assigned with atk_object_set_parent. Otherwise, this function
// returns NULL.
//
// This method is intended as an utility for ATK implementors, and not to be
// exposed to accessible tools. See atk_object_get_parent() for further
// reference.
func (accessible *ObjectClass) PeekParent() *ObjectClass {
	var _arg0 *C.AtkObject // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_peek_parent(_arg0)
	runtime.KeepAlive(accessible)

	var _object *ObjectClass // out

	_object = wrapObject(externglib.Take(unsafe.Pointer(_cret)))

	return _object
}

// RefAccessibleChild gets a reference to the specified accessible child of the
// object. The accessible children are 0-based so the first accessible child is
// at index 0, the second at index 1 and so on.
//
// The function takes the following parameters:
//
//    - i: gint representing the position of the child, starting from 0.
//
func (accessible *ObjectClass) RefAccessibleChild(i int) *ObjectClass {
	var _arg0 *C.AtkObject // out
	var _arg1 C.gint       // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = C.gint(i)

	_cret = C.atk_object_ref_accessible_child(_arg0, _arg1)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(i)

	var _object *ObjectClass // out

	_object = wrapObject(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _object
}

// RefRelationSet gets the RelationSet associated with the object.
func (accessible *ObjectClass) RefRelationSet() *RelationSet {
	var _arg0 *C.AtkObject      // out
	var _cret *C.AtkRelationSet // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_ref_relation_set(_arg0)
	runtime.KeepAlive(accessible)

	var _relationSet *RelationSet // out

	_relationSet = wrapRelationSet(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _relationSet
}

// RefStateSet gets a reference to the state set of the accessible; the caller
// must unreference it when it is no longer needed.
func (accessible *ObjectClass) RefStateSet() *StateSet {
	var _arg0 *C.AtkObject   // out
	var _cret *C.AtkStateSet // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))

	_cret = C.atk_object_ref_state_set(_arg0)
	runtime.KeepAlive(accessible)

	var _stateSet *StateSet // out

	_stateSet = wrapStateSet(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stateSet
}

// RemovePropertyChangeHandler removes a property change handler.
//
// Deprecated: See atk_object_connect_property_change_handler().
//
// The function takes the following parameters:
//
//    - handlerId: guint which identifies the handler to be removed.
//
func (accessible *ObjectClass) RemovePropertyChangeHandler(handlerId uint) {
	var _arg0 *C.AtkObject // out
	var _arg1 C.guint      // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = C.guint(handlerId)

	C.atk_object_remove_property_change_handler(_arg0, _arg1)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(handlerId)
}

// RemoveRelationship removes a relationship of the specified type with the
// specified target.
//
// The function takes the following parameters:
//
//    - relationship of the relation.
//    - target which is the target of the relation to be removed.
//
func (object *ObjectClass) RemoveRelationship(relationship RelationType, target *ObjectClass) bool {
	var _arg0 *C.AtkObject      // out
	var _arg1 C.AtkRelationType // out
	var _arg2 *C.AtkObject      // out
	var _cret C.gboolean        // in

	_arg0 = (*C.AtkObject)(unsafe.Pointer(object.Native()))
	_arg1 = C.AtkRelationType(relationship)
	_arg2 = (*C.AtkObject)(unsafe.Pointer(target.Native()))

	_cret = C.atk_object_remove_relationship(_arg0, _arg1, _arg2)
	runtime.KeepAlive(object)
	runtime.KeepAlive(relationship)
	runtime.KeepAlive(target)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAccessibleID sets the accessible ID of the accessible. This is not meant
// to be presented to the user, but to be an ID which is stable over application
// development. Typically, this is the gtkbuilder ID. Such an ID will be
// available for instance to identify a given well-known accessible object for
// tailored screen reading, or for automatic regression testing.
//
// The function takes the following parameters:
//
//    - name: character string to be set as the accessible id.
//
func (accessible *ObjectClass) SetAccessibleID(name string) {
	var _arg0 *C.AtkObject // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.atk_object_set_accessible_id(_arg0, _arg1)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(name)
}

// SetDescription sets the accessible description of the accessible. You can't
// set the description to NULL. This is reserved for the initial value. In this
// aspect NULL is similar to ATK_ROLE_UNKNOWN. If you want to set the name to a
// empty value you can use "".
//
// The function takes the following parameters:
//
//    - description: character string to be set as the accessible description.
//
func (accessible *ObjectClass) SetDescription(description string) {
	var _arg0 *C.AtkObject // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(_arg1))

	C.atk_object_set_description(_arg0, _arg1)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(description)
}

// SetName sets the accessible name of the accessible. You can't set the name to
// NULL. This is reserved for the initial value. In this aspect NULL is similar
// to ATK_ROLE_UNKNOWN. If you want to set the name to a empty value you can use
// "".
//
// The function takes the following parameters:
//
//    - name: character string to be set as the accessible name.
//
func (accessible *ObjectClass) SetName(name string) {
	var _arg0 *C.AtkObject // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.atk_object_set_name(_arg0, _arg1)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(name)
}

// SetParent sets the accessible parent of the accessible. parent can be NULL.
//
// The function takes the following parameters:
//
//    - parent to be set as the accessible parent.
//
func (accessible *ObjectClass) SetParent(parent *ObjectClass) {
	var _arg0 *C.AtkObject // out
	var _arg1 *C.AtkObject // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = (*C.AtkObject)(unsafe.Pointer(parent.Native()))

	C.atk_object_set_parent(_arg0, _arg1)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(parent)
}

// SetRole sets the role of the accessible.
//
// The function takes the following parameters:
//
//    - role to be set as the role.
//
func (accessible *ObjectClass) SetRole(role Role) {
	var _arg0 *C.AtkObject // out
	var _arg1 C.AtkRole    // out

	_arg0 = (*C.AtkObject)(unsafe.Pointer(accessible.Native()))
	_arg1 = C.AtkRole(role)

	C.atk_object_set_role(_arg0, _arg1)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(role)
}

// ConnectActiveDescendantChanged: "active-descendant-changed" signal is emitted
// by an object which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
// object in the object changes. For instance, a table will emit the signal when
// the cell in the table which has focus changes.
func (object *ObjectClass) ConnectActiveDescendantChanged(f func(arg1 *ObjectClass)) externglib.SignalHandle {
	return object.Connect("active-descendant-changed", f)
}

// ConnectChildrenChanged: signal "children-changed" is emitted when a child is
// added or removed form an object. It supports two details: "add" and "remove".
func (object *ObjectClass) ConnectChildrenChanged(f func(arg1 uint, arg2 *ObjectClass)) externglib.SignalHandle {
	return object.Connect("children-changed", f)
}

// ConnectFocusEvent: signal "focus-event" is emitted when an object gained or
// lost focus.
func (object *ObjectClass) ConnectFocusEvent(f func(arg1 bool)) externglib.SignalHandle {
	return object.Connect("focus-event", f)
}

// ConnectPropertyChange: signal "property-change" is emitted when an object's
// property value changes. arg1 contains an PropertyValues with the name and the
// new value of the property whose value has changed. Note that, as with GObject
// notify, getting this signal does not guarantee that the value of the property
// has actually changed; it may also be emitted when the setter of the property
// is called to reinstate the previous value.
//
// Toolkit implementor note: ATK implementors should use g_object_notify() to
// emit property-changed notifications. Object::property-changed is needed by
// the implementation of atk_add_global_event_listener() because GObject notify
// doesn't support emission hooks.
func (object *ObjectClass) ConnectPropertyChange(f func(arg1 *PropertyValues)) externglib.SignalHandle {
	return object.Connect("property-change", f)
}

// ConnectStateChange: "state-change" signal is emitted when an object's state
// changes. The detail value identifies the state type which has changed.
func (object *ObjectClass) ConnectStateChange(f func(arg1 string, arg2 bool)) externglib.SignalHandle {
	return object.Connect("state-change", f)
}

// ConnectVisibleDataChanged: "visible-data-changed" signal is emitted when the
// visual appearance of the object changed.
func (object *ObjectClass) ConnectVisibleDataChanged(f func()) externglib.SignalHandle {
	return object.Connect("visible-data-changed", f)
}

// Attribute is a string name/value pair representing a generic attribute. This
// can be used to expose additional information from an accessible object as a
// whole (see atk_object_get_attributes()) or an document (see
// atk_document_get_attributes()). In the case of text attributes (see
// atk_text_get_default_attributes()), TextAttribute enum defines all the
// possible text attribute names. You can use atk_text_attribute_get_name() to
// get the string name from the enum value. See also
// atk_text_attribute_for_name() and atk_text_attribute_get_value() for more
// information.
//
// A string name/value pair representing a generic attribute.
//
// An instance of this type is always passed by reference.
type Attribute struct {
	*attribute
}

// attribute is the struct that's finalized.
type attribute struct {
	native *C.AtkAttribute
}

// Name: attribute name.
func (a *Attribute) Name() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(a.native.name)))
	return v
}

// Value: value of the attribute, represented as a string.
func (a *Attribute) Value() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(a.native.value)))
	return v
}

// PropertyValues: note: old_value field of PropertyValues will not contain a
// valid value. This is a field defined with the purpose of contain the previous
// value of the property, but is not used anymore.
//
// An instance of this type is always passed by reference.
type PropertyValues struct {
	*propertyValues
}

// propertyValues is the struct that's finalized.
type propertyValues struct {
	native *C.AtkPropertyValues
}

// PropertyName: name of the ATK property which has changed.
func (p *PropertyValues) PropertyName() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(p.native.property_name)))
	return v
}

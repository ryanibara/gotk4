// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gchar* _gotk4_atk1_ObjectClass_get_description(void*);
// extern gchar* _gotk4_atk1_ObjectClass_get_name(void*);
// extern gchar* _gotk4_atk1_ObjectClass_get_object_locale(void*);
// extern gint _gotk4_atk1_ObjectClass_get_index_in_parent(void*);
// extern gint _gotk4_atk1_ObjectClass_get_mdi_zorder(void*);
// extern gint _gotk4_atk1_ObjectClass_get_n_children(void*);
// extern void _gotk4_atk1_ObjectClass_active_descendant_changed(void*, gpointer*);
// extern void _gotk4_atk1_ObjectClass_children_changed(void*, guint, gpointer);
// extern void _gotk4_atk1_ObjectClass_focus_event(void*, gboolean);
// extern void _gotk4_atk1_ObjectClass_initialize(void*, gpointer);
// extern void _gotk4_atk1_ObjectClass_property_change(void*, void*);
// extern void _gotk4_atk1_ObjectClass_remove_property_change_handler(void*, guint);
// extern void _gotk4_atk1_ObjectClass_set_description(void*, gchar*);
// extern void _gotk4_atk1_ObjectClass_set_name(void*, gchar*);
// extern void _gotk4_atk1_ObjectClass_set_parent(void*, void*);
// extern void _gotk4_atk1_ObjectClass_state_change(void*, gchar*, gboolean);
// extern void _gotk4_atk1_ObjectClass_visible_data_changed(void*);
// extern void _gotk4_atk1_Object_ConnectActiveDescendantChanged(gpointer, void*, guintptr);
// extern void _gotk4_atk1_Object_ConnectChildrenChanged(gpointer, guint, void*, guintptr);
// extern void _gotk4_atk1_Object_ConnectFocusEvent(gpointer, gboolean, guintptr);
// extern void _gotk4_atk1_Object_ConnectPropertyChange(gpointer, void*, guintptr);
// extern void _gotk4_atk1_Object_ConnectStateChange(gpointer, gchar*, gboolean, guintptr);
// extern void _gotk4_atk1_Object_ConnectVisibleDataChanged(gpointer, guintptr);
// extern void* _gotk4_atk1_ObjectClass_get_parent(void*);
// extern void* _gotk4_atk1_ObjectClass_ref_relation_set(void*);
// extern void* _gotk4_atk1_ObjectClass_ref_state_set(void*);
import "C"

// GTypeLayer returns the GType for the type Layer.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeLayer() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "Layer").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalLayer)
	return gtype
}

// GTypeRole returns the GType for the type Role.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeRole() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "Role").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalRole)
	return gtype
}

// GTypeImplementorIface returns the GType for the type ImplementorIface.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeImplementorIface() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "ImplementorIface").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalImplementorIface)
	return gtype
}

// GTypeObjectClass returns the GType for the type ObjectClass.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeObjectClass() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "Object").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalObjectClass)
	return gtype
}

// AttributeSet: this is a singly-linked list (a List) of Attribute. It is used
// by atk_text_get_run_attributes(), atk_text_get_default_attributes(),
// atk_editable_text_set_run_attributes(), atk_document_get_attributes() and
// atk_object_get_attributes().
type AttributeSet = coreglib.SList

// Layer describes the layer of a component
//
// These enumerated "layer values" are used when determining which UI rendering
// layer a component is drawn into, which can help in making determinations of
// when components occlude one another.
type Layer C.gint

const (
	// LayerInvalid: object does not have a layer.
	LayerInvalid Layer = iota
	// LayerBackground: this layer is reserved for the desktop background.
	LayerBackground
	// LayerCanvas: this layer is used for Canvas components.
	LayerCanvas
	// LayerWidget: this layer is normally used for components.
	LayerWidget
	// LayerMDI: this layer is used for layered components.
	LayerMDI
	// LayerPopup: this layer is used for popup components, such as menus.
	LayerPopup
	// LayerOverlay: this layer is reserved for future use.
	LayerOverlay
	// LayerWindow: this layer is used for toplevel windows.
	LayerWindow
)

func marshalLayer(p uintptr) (interface{}, error) {
	return Layer(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Layer.
func (l Layer) String() string {
	switch l {
	case LayerInvalid:
		return "Invalid"
	case LayerBackground:
		return "Background"
	case LayerCanvas:
		return "Canvas"
	case LayerWidget:
		return "Widget"
	case LayerMDI:
		return "MDI"
	case LayerPopup:
		return "Popup"
	case LayerOverlay:
		return "Overlay"
	case LayerWindow:
		return "Window"
	default:
		return fmt.Sprintf("Layer(%d)", l)
	}
}

// Role describes the role of an object
//
// These are the built-in enumerated roles that UI components can have in ATK.
// Other roles may be added at runtime, so an AtkRole >= ATK_ROLE_LAST_DEFINED
// is not necessarily an error.
type Role C.gint

const (
	// RoleInvalid: invalid role.
	RoleInvalid Role = iota
	// RoleAccelLabel: label which represents an accelerator.
	RoleAccelLabel
	// RoleAlert: object which is an alert to the user. Assistive Technologies
	// typically respond to ATK_ROLE_ALERT by reading the entire onscreen
	// contents of containers advertising this role. Should be used for warning
	// dialogs, etc.
	RoleAlert
	// RoleAnimation: object which is an animated image.
	RoleAnimation
	// RoleArrow: arrow in one of the four cardinal directions.
	RoleArrow
	// RoleCalendar: object that displays a calendar and allows the user to
	// select a date.
	RoleCalendar
	// RoleCanvas: object that can be drawn into and is used to trap events.
	RoleCanvas
	// RoleCheckBox: choice that can be checked or unchecked and provides a
	// separate indicator for the current state.
	RoleCheckBox
	// RoleCheckMenuItem: menu item with a check box.
	RoleCheckMenuItem
	// RoleColorChooser: specialized dialog that lets the user choose a color.
	RoleColorChooser
	// RoleColumnHeader: header for a column of data.
	RoleColumnHeader
	// RoleComboBox: collapsible list of choices the user can select from.
	RoleComboBox
	// RoleDateEditor: object whose purpose is to allow a user to edit a date.
	RoleDateEditor
	// RoleDesktopIcon: inconifed internal frame within a DESKTOP_PANE.
	RoleDesktopIcon
	// RoleDesktopFrame: pane that supports internal frames and iconified
	// versions of those internal frames.
	RoleDesktopFrame
	// RoleDial: object whose purpose is to allow a user to set a value.
	RoleDial
	// RoleDialog: top level window with title bar and a border.
	RoleDialog
	// RoleDirectoryPane: pane that allows the user to navigate through and
	// select the contents of a directory.
	RoleDirectoryPane
	// RoleDrawingArea: object used for drawing custom user interface elements.
	RoleDrawingArea
	// RoleFileChooser: specialized dialog that lets the user choose a file.
	RoleFileChooser
	// RoleFiller: object that fills up space in a user interface.
	RoleFiller
	// RoleFontChooser: specialized dialog that lets the user choose a font.
	RoleFontChooser
	// RoleFrame: top level window with a title bar, border, menubar, etc.
	RoleFrame
	// RoleGlassPane: pane that is guaranteed to be painted on top of all panes
	// beneath it.
	RoleGlassPane
	// RoleHtmlContainer: document container for HTML, whose children represent
	// the document content.
	RoleHtmlContainer
	// RoleIcon: small fixed size picture, typically used to decorate
	// components.
	RoleIcon
	// RoleImage: object whose primary purpose is to display an image.
	RoleImage
	// RoleInternalFrame: frame-like object that is clipped by a desktop pane.
	RoleInternalFrame
	// RoleLabel: object used to present an icon or short string in an
	// interface.
	RoleLabel
	// RoleLayeredPane: specialized pane that allows its children to be drawn in
	// layers, providing a form of stacking order.
	RoleLayeredPane
	// RoleList: object that presents a list of objects to the user and allows
	// the user to select one or more of them.
	RoleList
	// RoleListItem: object that represents an element of a list.
	RoleListItem
	// RoleMenu: object usually found inside a menu bar that contains a list of
	// actions the user can choose from.
	RoleMenu
	// RoleMenuBar: object usually drawn at the top of the primary dialog box of
	// an application that contains a list of menus the user can choose from.
	RoleMenuBar
	// RoleMenuItem: object usually contained in a menu that presents an action
	// the user can choose.
	RoleMenuItem
	// RoleOptionPane: specialized pane whose primary use is inside a DIALOG.
	RoleOptionPane
	// RolePageTab: object that is a child of a page tab list.
	RolePageTab
	// RolePageTabList: object that presents a series of panels (or page tabs),
	// one at a time, through some mechanism provided by the object.
	RolePageTabList
	// RolePanel: generic container that is often used to group objects.
	RolePanel
	// RolePasswordText: text object uses for passwords, or other places where
	// the text content is not shown visibly to the user.
	RolePasswordText
	// RolePopupMenu: temporary window that is usually used to offer the user a
	// list of choices, and then hides when the user selects one of those
	// choices.
	RolePopupMenu
	// RoleProgressBar: object used to indicate how much of a task has been
	// completed.
	RoleProgressBar
	// RolePushButton: object the user can manipulate to tell the application to
	// do something.
	RolePushButton
	// RoleRadioButton: specialized check box that will cause other radio
	// buttons in the same group to become unchecked when this one is checked.
	RoleRadioButton
	// RoleRadioMenuItem: check menu item which belongs to a group. At each
	// instant exactly one of the radio menu items from a group is selected.
	RoleRadioMenuItem
	// RoleRootPane: specialized pane that has a glass pane and a layered pane
	// as its children.
	RoleRootPane
	// RoleRowHeader: header for a row of data.
	RoleRowHeader
	// RoleScrollBar: object usually used to allow a user to incrementally view
	// a large amount of data.
	RoleScrollBar
	// RoleScrollPane: object that allows a user to incrementally view a large
	// amount of information.
	RoleScrollPane
	// RoleSeparator: object usually contained in a menu to provide a visible
	// and logical separation of the contents in a menu.
	RoleSeparator
	// RoleSlider: object that allows the user to select from a bounded range.
	RoleSlider
	// RoleSplitPane: specialized panel that presents two other panels at the
	// same time.
	RoleSplitPane
	// RoleSpinButton: object used to get an integer or floating point number
	// from the user.
	RoleSpinButton
	// RoleStatusbar: object which reports messages of minor importance to the
	// user.
	RoleStatusbar
	// RoleTable: object used to represent information in terms of rows and
	// columns.
	RoleTable
	// RoleTableCell: cell in a table.
	RoleTableCell
	// RoleTableColumnHeader: header for a column of a table.
	RoleTableColumnHeader
	// RoleTableRowHeader: header for a row of a table.
	RoleTableRowHeader
	// RoleTearOffMenuItem: menu item used to tear off and reattach its menu.
	RoleTearOffMenuItem
	// RoleTerminal: object that represents an accessible terminal. (Since:
	// 0.6).
	RoleTerminal
	// RoleText: interactive widget that supports multiple lines of text and
	// optionally accepts user input, but whose purpose is not to solicit user
	// input. Thus ATK_ROLE_TEXT is appropriate for the text view in a plain
	// text editor but inappropriate for an input field in a dialog box or web
	// form. For widgets whose purpose is to solicit input from the user, see
	// ATK_ROLE_ENTRY and ATK_ROLE_PASSWORD_TEXT. For generic objects which
	// display a brief amount of textual information, see ATK_ROLE_STATIC.
	RoleText
	// RoleToggleButton: specialized push button that can be checked or
	// unchecked, but does not provide a separate indicator for the current
	// state.
	RoleToggleButton
	// RoleToolBar: bar or palette usually composed of push buttons or toggle
	// buttons.
	RoleToolBar
	// RoleToolTip: object that provides information about another object.
	RoleToolTip
	// RoleTree: object used to represent hierarchical information to the user.
	RoleTree
	// RoleTreeTable: object capable of expanding and collapsing rows as well as
	// showing multiple columns of data. (Since: 0.7).
	RoleTreeTable
	// RoleUnknown: object contains some Accessible information, but its role is
	// not known.
	RoleUnknown
	// RoleViewport: object usually used in a scroll pane.
	RoleViewport
	// RoleWindow: top level window with no title or border.
	RoleWindow
	// RoleHeader: object that serves as a document header. (Since: 1.1.1).
	RoleHeader
	// RoleFooter: object that serves as a document footer. (Since: 1.1.1).
	RoleFooter
	// RoleParagraph: object which is contains a paragraph of text content.
	// (Since: 1.1.1).
	RoleParagraph
	// RoleRuler: object which describes margins and tab stops, etc. for text
	// objects which it controls (should have CONTROLLER_FOR relation to such).
	// (Since: 1.1.1).
	RoleRuler
	// RoleApplication: object is an application object, which may contain
	// ATK_ROLE_FRAME objects or other types of accessibles. The root accessible
	// of any application's ATK hierarchy should have ATK_ROLE_APPLICATION.
	// (Since: 1.1.4).
	RoleApplication
	// RoleAutocomplete: object is a dialog or list containing items for
	// insertion into an entry widget, for instance a list of words for
	// completion of a text entry. (Since: 1.3).
	RoleAutocomplete
	// RoleEditbar: object is an editable text object in a toolbar. (Since:
	// 1.5).
	RoleEditbar
	// RoleEmbedded: object is an embedded container within a document or panel.
	// This role is a grouping "hint" indicating that the contained objects
	// share a context. (Since: 1.7.2).
	RoleEmbedded
	// RoleEntry: object is a component whose textual content may be entered or
	// modified by the user, provided ATK_STATE_EDITABLE is present. (Since:
	// 1.11).
	RoleEntry
	// RoleChart: object is a graphical depiction of quantitative data. It may
	// contain multiple subelements whose attributes and/or description may be
	// queried to obtain both the quantitative data and information about how
	// the data is being presented. The LABELLED_BY relation is particularly
	// important in interpreting objects of this type, as is the
	// accessible-description property. (Since: 1.11).
	RoleChart
	// RoleCaption: object contains descriptive information, usually textual,
	// about another user interface element such as a table, chart, or image.
	// (Since: 1.11).
	RoleCaption
	// RoleDocumentFrame: object is a visual frame or container which contains a
	// view of document content. Document frames may occur within another
	// Document instance, in which case the second document may be said to be
	// embedded in the containing instance. HTML frames are often
	// ROLE_DOCUMENT_FRAME. Either this object, or a singleton descendant,
	// should implement the Document interface. (Since: 1.11).
	RoleDocumentFrame
	// RoleHeading: object serves as a heading for content which follows it in a
	// document. The 'heading level' of the heading, if availabe, may be
	// obtained by querying the object's attributes.
	RoleHeading
	// RolePage: object is a containing instance which encapsulates a page of
	// information. ATK_ROLE_PAGE is used in documents and content which support
	// a paginated navigation model. (Since: 1.11).
	RolePage
	// RoleSection: object is a containing instance of document content which
	// constitutes a particular 'logical' section of the document. The type of
	// content within a section, and the nature of the section division itself,
	// may be obtained by querying the object's attributes. Sections may be
	// nested. (Since: 1.11).
	RoleSection
	// RoleRedundantObject: object is redundant with another object in the
	// hierarchy, and is exposed for purely technical reasons. Objects of this
	// role should normally be ignored by clients. (Since: 1.11).
	RoleRedundantObject
	// RoleForm: object is a container for form controls, for instance as part
	// of a web form or user-input form within a document. This role is
	// primarily a tag/convenience for clients when navigating complex
	// documents, it is not expected that ordinary GUI containers will always
	// have ATK_ROLE_FORM. (Since: 1.12.0).
	RoleForm
	// RoleLink: object is a hypertext anchor, i.e. a "link" in a hypertext
	// document. Such objects are distinct from 'inline' content which may also
	// use the Hypertext/Hyperlink interfaces to indicate the range/location
	// within a text object where an inline or embedded object lies. (Since:
	// 1.12.1).
	RoleLink
	// RoleInputMethodWindow: object is a window or similar viewport which is
	// used to allow composition or input of a 'complex character', in other
	// words it is an "input method window." (Since: 1.12.1).
	RoleInputMethodWindow
	// RoleTableRow: row in a table. (Since: 2.1.0).
	RoleTableRow
	// RoleTreeItem: object that represents an element of a tree. (Since:
	// 2.1.0).
	RoleTreeItem
	// RoleDocumentSpreadsheet: document frame which contains a spreadsheet.
	// (Since: 2.1.0).
	RoleDocumentSpreadsheet
	// RoleDocumentPresentation: document frame which contains a presentation or
	// slide content. (Since: 2.1.0).
	RoleDocumentPresentation
	// RoleDocumentText: document frame which contains textual content, such as
	// found in a word processing application. (Since: 2.1.0).
	RoleDocumentText
	// RoleDocumentWeb: document frame which contains HTML or other markup
	// suitable for display in a web browser. (Since: 2.1.0).
	RoleDocumentWeb
	// RoleDocumentEmail: document frame which contains email content to be
	// displayed or composed either in plain text or HTML. (Since: 2.1.0).
	RoleDocumentEmail
	// RoleComment: object found within a document and designed to present a
	// comment, note, or other annotation. In some cases, this object might not
	// be visible until activated. (Since: 2.1.0).
	RoleComment
	// RoleListBox: non-collapsible list of choices the user can select from.
	// (Since: 2.1.0).
	RoleListBox
	// RoleGrouping: group of related widgets. This group typically has a label.
	// (Since: 2.1.0).
	RoleGrouping
	// RoleImageMap: image map object. Usually a graphic with multiple hotspots,
	// where each hotspot can be activated resulting in the loading of another
	// document or section of a document. (Since: 2.1.0).
	RoleImageMap
	// RoleNotification: transitory object designed to present a message to the
	// user, typically at the desktop level rather than inside a particular
	// application. (Since: 2.1.0).
	RoleNotification
	// RoleInfoBar: object designed to present a message to the user within an
	// existing window. (Since: 2.1.0).
	RoleInfoBar
	// RoleLevelBar: bar that serves as a level indicator to, for instance, show
	// the strength of a password or the state of a battery. (Since: 2.7.3).
	RoleLevelBar
	// RoleTitleBar: bar that serves as the title of a window or a dialog.
	// (Since: 2.12).
	RoleTitleBar
	// RoleBlockQuote: object which contains a text section that is quoted from
	// another source. (Since: 2.12).
	RoleBlockQuote
	// RoleAudio: object which represents an audio element. (Since: 2.12).
	RoleAudio
	// RoleVideo: object which represents a video element. (Since: 2.12).
	RoleVideo
	// RoleDefinition: definition of a term or concept. (Since: 2.12).
	RoleDefinition
	// RoleArticle: section of a page that consists of a composition that forms
	// an independent part of a document, page, or site. Examples: A blog entry,
	// a news story, a forum post. (Since: 2.12).
	RoleArticle
	// RoleLandmark: region of a web page intended as a navigational landmark.
	// This is designed to allow Assistive Technologies to provide quick
	// navigation among key regions within a document. (Since: 2.12).
	RoleLandmark
	// RoleLog: text widget or container holding log content, such as chat
	// history and error logs. In this role there is a relationship between the
	// arrival of new items in the log and the reading order. The log contains a
	// meaningful sequence and new information is added only to the end of the
	// log, not at arbitrary points. (Since: 2.12).
	RoleLog
	// RoleMarquee: container where non-essential information changes
	// frequently. Common usages of marquee include stock tickers and ad
	// banners. The primary difference between a marquee and a log is that logs
	// usually have a meaningful order or sequence of important content changes.
	// (Since: 2.12).
	RoleMarquee
	// RoleMath: text widget or container that holds a mathematical expression.
	// (Since: 2.12).
	RoleMath
	// RoleRating: widget whose purpose is to display a rating, such as the
	// number of stars associated with a song in a media player. Objects of this
	// role should also implement AtkValue. (Since: 2.12).
	RoleRating
	// RoleTimer: object containing a numerical counter which indicates an
	// amount of elapsed time from a start point, or the time remaining until an
	// end point. (Since: 2.12).
	RoleTimer
	// RoleDescriptionList: object that represents a list of term-value groups.
	// A term-value group represents a individual description and consist of one
	// or more names (ATK_ROLE_DESCRIPTION_TERM) followed by one or more values
	// (ATK_ROLE_DESCRIPTION_VALUE). For each list, there should not be more
	// than one group with the same term name. (Since: 2.12).
	RoleDescriptionList
	// RoleDescriptionTerm: object that represents a term or phrase with a
	// corresponding definition. (Since: 2.12).
	RoleDescriptionTerm
	// RoleDescriptionValue: object that represents the description, definition
	// or value of a term. (Since: 2.12).
	RoleDescriptionValue
	// RoleStatic: generic non-container object whose purpose is to display a
	// brief amount of information to the user and whose role is known by the
	// implementor but lacks semantic value for the user. Examples in which
	// ATK_ROLE_STATIC is appropriate include the message displayed in a message
	// box and an image used as an alternative means to display text.
	// ATK_ROLE_STATIC should not be applied to widgets which are traditionally
	// interactive, objects which display a significant amount of content, or
	// any object which has an accessible relation pointing to another object.
	// Implementors should expose the displayed information through the
	// accessible name of the object. If doing so seems inappropriate, it may
	// indicate that a different role should be used. For labels which describe
	// another widget, see ATK_ROLE_LABEL. For text views, see ATK_ROLE_TEXT.
	// For generic containers, see ATK_ROLE_PANEL. For objects whose role is not
	// known by the implementor, see ATK_ROLE_UNKNOWN. (Since: 2.16).
	RoleStatic
	// RoleMathFraction: object that represents a mathematical fraction. (Since:
	// 2.16).
	RoleMathFraction
	// RoleMathRoot: object that represents a mathematical expression displayed
	// with a radical. (Since: 2.16).
	RoleMathRoot
	// RoleSubscript: object that contains text that is displayed as a
	// subscript. (Since: 2.16).
	RoleSubscript
	// RoleSuperscript: object that contains text that is displayed as a
	// superscript. (Since: 2.16).
	RoleSuperscript
	// RoleFootnote: object that contains the text of a footnote. (Since: 2.26).
	RoleFootnote
	// RoleContentDeletion: content previously deleted or proposed to be
	// deleted, e.g. in revision history or a content view providing suggestions
	// from reviewers. (Since: 2.34).
	RoleContentDeletion
	// RoleContentInsertion: content previously inserted or proposed to be
	// inserted, e.g. in revision history or a content view providing
	// suggestions from reviewers. (Since: 2.34).
	RoleContentInsertion
	// RoleMark: run of content that is marked or highlighted, such as for
	// reference purposes, or to call it out as having a special purpose. If the
	// marked content has an associated section in the document elaborating on
	// the reason for the mark, then ATK_RELATION_DETAILS should be used on the
	// mark to point to that associated section. In addition, the reciprocal
	// relation ATK_RELATION_DETAILS_FOR should be used on the associated
	// content section to point back to the mark. (Since: 2.36).
	RoleMark
	// RoleSuggestion: container for content that is called out as a proposed
	// change from the current version of the document, such as by a reviewer of
	// the content. This role should include either ATK_ROLE_CONTENT_DELETION
	// and/or ATK_ROLE_CONTENT_INSERTION children, in any order, to indicate
	// what the actual change is. (Since: 2.36).
	RoleSuggestion
	// RoleLastDefined: not a valid role, used for finding end of the
	// enumeration.
	RoleLastDefined
)

func marshalRole(p uintptr) (interface{}, error) {
	return Role(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Role.
func (r Role) String() string {
	switch r {
	case RoleInvalid:
		return "Invalid"
	case RoleAccelLabel:
		return "AcceleratorLabel"
	case RoleAlert:
		return "Alert"
	case RoleAnimation:
		return "Animation"
	case RoleArrow:
		return "Arrow"
	case RoleCalendar:
		return "Calendar"
	case RoleCanvas:
		return "Canvas"
	case RoleCheckBox:
		return "CheckBox"
	case RoleCheckMenuItem:
		return "CheckMenuItem"
	case RoleColorChooser:
		return "ColorChooser"
	case RoleColumnHeader:
		return "ColumnHeader"
	case RoleComboBox:
		return "ComboBox"
	case RoleDateEditor:
		return "DateEditor"
	case RoleDesktopIcon:
		return "DesktopIcon"
	case RoleDesktopFrame:
		return "DesktopFrame"
	case RoleDial:
		return "Dial"
	case RoleDialog:
		return "Dialog"
	case RoleDirectoryPane:
		return "DirectoryPane"
	case RoleDrawingArea:
		return "DrawingArea"
	case RoleFileChooser:
		return "FileChooser"
	case RoleFiller:
		return "Filler"
	case RoleFontChooser:
		return "FontChooser"
	case RoleFrame:
		return "Frame"
	case RoleGlassPane:
		return "GlassPane"
	case RoleHtmlContainer:
		return "HtmlContainer"
	case RoleIcon:
		return "Icon"
	case RoleImage:
		return "Image"
	case RoleInternalFrame:
		return "InternalFrame"
	case RoleLabel:
		return "Label"
	case RoleLayeredPane:
		return "LayeredPane"
	case RoleList:
		return "List"
	case RoleListItem:
		return "ListItem"
	case RoleMenu:
		return "Menu"
	case RoleMenuBar:
		return "MenuBar"
	case RoleMenuItem:
		return "MenuItem"
	case RoleOptionPane:
		return "OptionPane"
	case RolePageTab:
		return "PageTab"
	case RolePageTabList:
		return "PageTabList"
	case RolePanel:
		return "Panel"
	case RolePasswordText:
		return "PasswordText"
	case RolePopupMenu:
		return "PopupMenu"
	case RoleProgressBar:
		return "ProgressBar"
	case RolePushButton:
		return "PushButton"
	case RoleRadioButton:
		return "RadioButton"
	case RoleRadioMenuItem:
		return "RadioMenuItem"
	case RoleRootPane:
		return "RootPane"
	case RoleRowHeader:
		return "RowHeader"
	case RoleScrollBar:
		return "ScrollBar"
	case RoleScrollPane:
		return "ScrollPane"
	case RoleSeparator:
		return "Separator"
	case RoleSlider:
		return "Slider"
	case RoleSplitPane:
		return "SplitPane"
	case RoleSpinButton:
		return "SpinButton"
	case RoleStatusbar:
		return "Statusbar"
	case RoleTable:
		return "Table"
	case RoleTableCell:
		return "TableCell"
	case RoleTableColumnHeader:
		return "TableColumnHeader"
	case RoleTableRowHeader:
		return "TableRowHeader"
	case RoleTearOffMenuItem:
		return "TearOffMenuItem"
	case RoleTerminal:
		return "Terminal"
	case RoleText:
		return "Text"
	case RoleToggleButton:
		return "ToggleButton"
	case RoleToolBar:
		return "ToolBar"
	case RoleToolTip:
		return "ToolTip"
	case RoleTree:
		return "Tree"
	case RoleTreeTable:
		return "TreeTable"
	case RoleUnknown:
		return "Unknown"
	case RoleViewport:
		return "Viewport"
	case RoleWindow:
		return "Window"
	case RoleHeader:
		return "Header"
	case RoleFooter:
		return "Footer"
	case RoleParagraph:
		return "Paragraph"
	case RoleRuler:
		return "Ruler"
	case RoleApplication:
		return "Application"
	case RoleAutocomplete:
		return "Autocomplete"
	case RoleEditbar:
		return "EditBar"
	case RoleEmbedded:
		return "Embedded"
	case RoleEntry:
		return "Entry"
	case RoleChart:
		return "Chart"
	case RoleCaption:
		return "Caption"
	case RoleDocumentFrame:
		return "DocumentFrame"
	case RoleHeading:
		return "Heading"
	case RolePage:
		return "Page"
	case RoleSection:
		return "Section"
	case RoleRedundantObject:
		return "RedundantObject"
	case RoleForm:
		return "Form"
	case RoleLink:
		return "Link"
	case RoleInputMethodWindow:
		return "InputMethodWindow"
	case RoleTableRow:
		return "TableRow"
	case RoleTreeItem:
		return "TreeItem"
	case RoleDocumentSpreadsheet:
		return "DocumentSpreadsheet"
	case RoleDocumentPresentation:
		return "DocumentPresentation"
	case RoleDocumentText:
		return "DocumentText"
	case RoleDocumentWeb:
		return "DocumentWeb"
	case RoleDocumentEmail:
		return "DocumentEmail"
	case RoleComment:
		return "Comment"
	case RoleListBox:
		return "ListBox"
	case RoleGrouping:
		return "Grouping"
	case RoleImageMap:
		return "ImageMap"
	case RoleNotification:
		return "Notification"
	case RoleInfoBar:
		return "InfoBar"
	case RoleLevelBar:
		return "LevelBar"
	case RoleTitleBar:
		return "TitleBar"
	case RoleBlockQuote:
		return "BlockQuote"
	case RoleAudio:
		return "Audio"
	case RoleVideo:
		return "Video"
	case RoleDefinition:
		return "Definition"
	case RoleArticle:
		return "Article"
	case RoleLandmark:
		return "Landmark"
	case RoleLog:
		return "Log"
	case RoleMarquee:
		return "Marquee"
	case RoleMath:
		return "Math"
	case RoleRating:
		return "Rating"
	case RoleTimer:
		return "Timer"
	case RoleDescriptionList:
		return "DescriptionList"
	case RoleDescriptionTerm:
		return "DescriptionTerm"
	case RoleDescriptionValue:
		return "DescriptionValue"
	case RoleStatic:
		return "Static"
	case RoleMathFraction:
		return "MathFraction"
	case RoleMathRoot:
		return "MathRoot"
	case RoleSubscript:
		return "Subscript"
	case RoleSuperscript:
		return "Superscript"
	case RoleFootnote:
		return "Footnote"
	case RoleContentDeletion:
		return "ContentDeletion"
	case RoleContentInsertion:
		return "ContentInsertion"
	case RoleMark:
		return "Mark"
	case RoleSuggestion:
		return "Suggestion"
	case RoleLastDefined:
		return "LastDefined"
	default:
		return fmt.Sprintf("Role(%d)", r)
	}
}

// Function is a function definition used for padding which has been added to
// class and interface structures to allow for expansion in the future.
type Function func() (ok bool)

//export _gotk4_atk1_Function
func _gotk4_atk1_Function(arg1 C.gpointer) (cret C.gboolean) {
	var fn Function
	{
		v := gbox.Get(uintptr(arg1))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(Function)
	}

	ok := fn()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ImplementorIface: atkImplementor interface is implemented by objects for
// which AtkObject peers may be obtained via calls to
// iface->(ref_accessible)(implementor);.
//
// ImplementorIface wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ImplementorIface struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ImplementorIface)(nil)
)

// ImplementorIfacer describes ImplementorIface's interface methods.
type ImplementorIfacer interface {
	coreglib.Objector

	baseImplementorIface() *ImplementorIface
}

var _ ImplementorIfacer = (*ImplementorIface)(nil)

func wrapImplementorIface(obj *coreglib.Object) *ImplementorIface {
	return &ImplementorIface{
		Object: obj,
	}
}

func marshalImplementorIface(p uintptr) (interface{}, error) {
	return wrapImplementorIface(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *ImplementorIface) baseImplementorIface() *ImplementorIface {
	return v
}

// BaseImplementorIface returns the underlying base object.
func BaseImplementorIface(obj ImplementorIfacer) *ImplementorIface {
	return obj.baseImplementorIface()
}

// ObjectClassOverrider contains methods that are overridable.
type ObjectClassOverrider interface {
	// The function takes the following parameters:
	//
	ActiveDescendantChanged(child *unsafe.Pointer)
	// The function takes the following parameters:
	//
	//    - changeIndex
	//    - changedChild (optional)
	//
	ChildrenChanged(changeIndex uint32, changedChild unsafe.Pointer)
	// The function takes the following parameters:
	//
	FocusEvent(focusIn bool)
	// Description gets the accessible description of the accessible.
	//
	// The function returns the following values:
	//
	//    - utf8: character string representing the accessible description of the
	//      accessible.
	//
	Description() string
	// IndexInParent gets the 0-based index of this accessible in its parent;
	// returns -1 if the accessible does not have an accessible parent.
	//
	// The function returns the following values:
	//
	//    - gint: integer which is the index of the accessible in its parent.
	//
	IndexInParent() int32
	// MDIZOrder gets the zorder of the accessible. The value G_MININT will be
	// returned if the layer of the accessible is not ATK_LAYER_MDI.
	//
	// Deprecated: Use atk_component_get_mdi_zorder instead.
	//
	// The function returns the following values:
	//
	//    - gint which is the zorder of the accessible, i.e. the depth at which
	//      the component is shown in relation to other components in the same
	//      container.
	//
	MDIZOrder() int32
	// The function returns the following values:
	//
	NChildren() int32
	// Name gets the accessible name of the accessible.
	//
	// The function returns the following values:
	//
	//    - utf8: character string representing the accessible name of the
	//      object.
	//
	Name() string
	// ObjectLocale gets a UTF-8 string indicating the POSIX-style LC_MESSAGES
	// locale of accessible.
	//
	// The function returns the following values:
	//
	//    - utf8: UTF-8 string indicating the POSIX-style LC_MESSAGES locale of
	//      accessible.
	//
	ObjectLocale() string
	// Parent gets the accessible parent of the accessible. By default this is
	// the one assigned with atk_object_set_parent(), but it is assumed that ATK
	// implementors have ways to get the parent of the object without the need
	// of assigning it manually with atk_object_set_parent(), and will return it
	// with this method.
	//
	// If you are only interested on the parent assigned with
	// atk_object_set_parent(), use atk_object_peek_parent().
	//
	// The function returns the following values:
	//
	//    - object representing the accessible parent of the accessible.
	//
	Parent() *ObjectClass
	// Initialize: this function is called when implementing subclasses of
	// Object. It does initialization required for the new object. It is
	// intended that this function should called only in the ..._new() functions
	// used to create an instance of a subclass of Object.
	//
	// The function takes the following parameters:
	//
	//    - data (optional) which identifies the object for which the AtkObject
	//      was created.
	//
	Initialize(data unsafe.Pointer)
	// The function takes the following parameters:
	//
	PropertyChange(values *PropertyValues)
	// RefRelationSet gets the RelationSet associated with the object.
	//
	// The function returns the following values:
	//
	//    - relationSet representing the relation set of the object.
	//
	RefRelationSet() *RelationSet
	// RefStateSet gets a reference to the state set of the accessible; the
	// caller must unreference it when it is no longer needed.
	//
	// The function returns the following values:
	//
	//    - stateSet: reference to an StateSet which is the state set of the
	//      accessible.
	//
	RefStateSet() *StateSet
	// RemovePropertyChangeHandler removes a property change handler.
	//
	// Deprecated: See atk_object_connect_property_change_handler().
	//
	// The function takes the following parameters:
	//
	//    - handlerId: guint which identifies the handler to be removed.
	//
	RemovePropertyChangeHandler(handlerId uint32)
	// SetDescription sets the accessible description of the accessible. You
	// can't set the description to NULL. This is reserved for the initial
	// value. In this aspect NULL is similar to ATK_ROLE_UNKNOWN. If you want to
	// set the name to a empty value you can use "".
	//
	// The function takes the following parameters:
	//
	//    - description: character string to be set as the accessible
	//      description.
	//
	SetDescription(description string)
	// SetName sets the accessible name of the accessible. You can't set the
	// name to NULL. This is reserved for the initial value. In this aspect NULL
	// is similar to ATK_ROLE_UNKNOWN. If you want to set the name to a empty
	// value you can use "".
	//
	// The function takes the following parameters:
	//
	//    - name: character string to be set as the accessible name.
	//
	SetName(name string)
	// SetParent sets the accessible parent of the accessible. parent can be
	// NULL.
	//
	// The function takes the following parameters:
	//
	//    - parent to be set as the accessible parent.
	//
	SetParent(parent *ObjectClass)
	// The function takes the following parameters:
	//
	//    - name
	//    - stateSet
	//
	StateChange(name string, stateSet bool)
	VisibleDataChanged()
}

// ObjectClass: this class is the primary class for accessibility support via
// the Accessibility ToolKit (ATK). Objects which are instances of Object (or
// instances of AtkObject-derived types) are queried for properties which relate
// basic (and generic) properties of a UI component such as name and
// description. Instances of Object may also be queried as to whether they
// implement other ATK interfaces (e.g. Action, Component, etc.), as appropriate
// to the role which a given UI component plays in a user interface.
//
// All UI components in an application which provide useful information or
// services to the user must provide corresponding Object instances on request
// (in GTK+, for instance, usually on a call to #gtk_widget_get_accessible ()),
// either via ATK support built into the toolkit for the widget class or
// ancestor class, or in the case of custom widgets, if the inherited Object
// implementation is insufficient, via instances of a new Object subclass.
//
// See also: ObjectFactory, Registry. (GTK+ users see also Accessible).
type ObjectClass struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ObjectClass)(nil)
)

func classInitObjectClasser(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Atk", "ObjectClass")

	if _, ok := goval.(interface{ ActiveDescendantChanged(child *unsafe.Pointer) }); ok {
		o := pclass.StructFieldOffset("active_descendant_changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_active_descendant_changed)
	}

	if _, ok := goval.(interface {
		ChildrenChanged(changeIndex uint32, changedChild unsafe.Pointer)
	}); ok {
		o := pclass.StructFieldOffset("children_changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_children_changed)
	}

	if _, ok := goval.(interface{ FocusEvent(focusIn bool) }); ok {
		o := pclass.StructFieldOffset("focus_event")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_focus_event)
	}

	if _, ok := goval.(interface{ Description() string }); ok {
		o := pclass.StructFieldOffset("get_description")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_get_description)
	}

	if _, ok := goval.(interface{ IndexInParent() int32 }); ok {
		o := pclass.StructFieldOffset("get_index_in_parent")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_get_index_in_parent)
	}

	if _, ok := goval.(interface{ MDIZOrder() int32 }); ok {
		o := pclass.StructFieldOffset("get_mdi_zorder")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_get_mdi_zorder)
	}

	if _, ok := goval.(interface{ NChildren() int32 }); ok {
		o := pclass.StructFieldOffset("get_n_children")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_get_n_children)
	}

	if _, ok := goval.(interface{ Name() string }); ok {
		o := pclass.StructFieldOffset("get_name")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_get_name)
	}

	if _, ok := goval.(interface{ ObjectLocale() string }); ok {
		o := pclass.StructFieldOffset("get_object_locale")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_get_object_locale)
	}

	if _, ok := goval.(interface{ Parent() *ObjectClass }); ok {
		o := pclass.StructFieldOffset("get_parent")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_get_parent)
	}

	if _, ok := goval.(interface{ Initialize(data unsafe.Pointer) }); ok {
		o := pclass.StructFieldOffset("initialize")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_initialize)
	}

	if _, ok := goval.(interface{ PropertyChange(values *PropertyValues) }); ok {
		o := pclass.StructFieldOffset("property_change")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_property_change)
	}

	if _, ok := goval.(interface{ RefRelationSet() *RelationSet }); ok {
		o := pclass.StructFieldOffset("ref_relation_set")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_ref_relation_set)
	}

	if _, ok := goval.(interface{ RefStateSet() *StateSet }); ok {
		o := pclass.StructFieldOffset("ref_state_set")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_ref_state_set)
	}

	if _, ok := goval.(interface{ RemovePropertyChangeHandler(handlerId uint32) }); ok {
		o := pclass.StructFieldOffset("remove_property_change_handler")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_remove_property_change_handler)
	}

	if _, ok := goval.(interface{ SetDescription(description string) }); ok {
		o := pclass.StructFieldOffset("set_description")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_set_description)
	}

	if _, ok := goval.(interface{ SetName(name string) }); ok {
		o := pclass.StructFieldOffset("set_name")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_set_name)
	}

	if _, ok := goval.(interface{ SetParent(parent *ObjectClass) }); ok {
		o := pclass.StructFieldOffset("set_parent")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_set_parent)
	}

	if _, ok := goval.(interface {
		StateChange(name string, stateSet bool)
	}); ok {
		o := pclass.StructFieldOffset("state_change")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_state_change)
	}

	if _, ok := goval.(interface{ VisibleDataChanged() }); ok {
		o := pclass.StructFieldOffset("visible_data_changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_atk1_ObjectClass_visible_data_changed)
	}
}

//export _gotk4_atk1_ObjectClass_active_descendant_changed
func _gotk4_atk1_ObjectClass_active_descendant_changed(arg0 *C.void, arg1 *C.gpointer) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ActiveDescendantChanged(child *unsafe.Pointer) })

	var _child *unsafe.Pointer // out

	if arg1 != nil {
		_child = (*unsafe.Pointer)(unsafe.Pointer(arg1))
	}

	iface.ActiveDescendantChanged(_child)
}

//export _gotk4_atk1_ObjectClass_children_changed
func _gotk4_atk1_ObjectClass_children_changed(arg0 *C.void, arg1 C.guint, arg2 C.gpointer) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ChildrenChanged(changeIndex uint32, changedChild unsafe.Pointer)
	})

	var _changeIndex uint32          // out
	var _changedChild unsafe.Pointer // out

	_changeIndex = uint32(arg1)
	_changedChild = (unsafe.Pointer)(unsafe.Pointer(arg2))

	iface.ChildrenChanged(_changeIndex, _changedChild)
}

//export _gotk4_atk1_ObjectClass_focus_event
func _gotk4_atk1_ObjectClass_focus_event(arg0 *C.void, arg1 C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ FocusEvent(focusIn bool) })

	var _focusIn bool // out

	if arg1 != 0 {
		_focusIn = true
	}

	iface.FocusEvent(_focusIn)
}

//export _gotk4_atk1_ObjectClass_get_description
func _gotk4_atk1_ObjectClass_get_description(arg0 *C.void) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Description() string })

	utf8 := iface.Description()

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_atk1_ObjectClass_get_index_in_parent
func _gotk4_atk1_ObjectClass_get_index_in_parent(arg0 *C.void) (cret C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ IndexInParent() int32 })

	gint := iface.IndexInParent()

	cret = C.gint(gint)

	return cret
}

//export _gotk4_atk1_ObjectClass_get_mdi_zorder
func _gotk4_atk1_ObjectClass_get_mdi_zorder(arg0 *C.void) (cret C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ MDIZOrder() int32 })

	gint := iface.MDIZOrder()

	cret = C.gint(gint)

	return cret
}

//export _gotk4_atk1_ObjectClass_get_n_children
func _gotk4_atk1_ObjectClass_get_n_children(arg0 *C.void) (cret C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ NChildren() int32 })

	gint := iface.NChildren()

	cret = C.gint(gint)

	return cret
}

//export _gotk4_atk1_ObjectClass_get_name
func _gotk4_atk1_ObjectClass_get_name(arg0 *C.void) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Name() string })

	utf8 := iface.Name()

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_atk1_ObjectClass_get_object_locale
func _gotk4_atk1_ObjectClass_get_object_locale(arg0 *C.void) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ObjectLocale() string })

	utf8 := iface.ObjectLocale()

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_atk1_ObjectClass_get_parent
func _gotk4_atk1_ObjectClass_get_parent(arg0 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Parent() *ObjectClass })

	object := iface.Parent()

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	return cret
}

//export _gotk4_atk1_ObjectClass_initialize
func _gotk4_atk1_ObjectClass_initialize(arg0 *C.void, arg1 C.gpointer) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Initialize(data unsafe.Pointer) })

	var _data unsafe.Pointer // out

	_data = (unsafe.Pointer)(unsafe.Pointer(arg1))

	iface.Initialize(_data)
}

//export _gotk4_atk1_ObjectClass_property_change
func _gotk4_atk1_ObjectClass_property_change(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ PropertyChange(values *PropertyValues) })

	var _values *PropertyValues // out

	_values = (*PropertyValues)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	iface.PropertyChange(_values)
}

//export _gotk4_atk1_ObjectClass_ref_relation_set
func _gotk4_atk1_ObjectClass_ref_relation_set(arg0 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ RefRelationSet() *RelationSet })

	relationSet := iface.RefRelationSet()

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(relationSet).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(relationSet).Native()))

	return cret
}

//export _gotk4_atk1_ObjectClass_ref_state_set
func _gotk4_atk1_ObjectClass_ref_state_set(arg0 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ RefStateSet() *StateSet })

	stateSet := iface.RefStateSet()

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(stateSet).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(stateSet).Native()))

	return cret
}

//export _gotk4_atk1_ObjectClass_remove_property_change_handler
func _gotk4_atk1_ObjectClass_remove_property_change_handler(arg0 *C.void, arg1 C.guint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ RemovePropertyChangeHandler(handlerId uint32) })

	var _handlerId uint32 // out

	_handlerId = uint32(arg1)

	iface.RemovePropertyChangeHandler(_handlerId)
}

//export _gotk4_atk1_ObjectClass_set_description
func _gotk4_atk1_ObjectClass_set_description(arg0 *C.void, arg1 *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SetDescription(description string) })

	var _description string // out

	_description = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	iface.SetDescription(_description)
}

//export _gotk4_atk1_ObjectClass_set_name
func _gotk4_atk1_ObjectClass_set_name(arg0 *C.void, arg1 *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SetName(name string) })

	var _name string // out

	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	iface.SetName(_name)
}

//export _gotk4_atk1_ObjectClass_set_parent
func _gotk4_atk1_ObjectClass_set_parent(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SetParent(parent *ObjectClass) })

	var _parent *ObjectClass // out

	_parent = wrapObject(coreglib.Take(unsafe.Pointer(arg1)))

	iface.SetParent(_parent)
}

//export _gotk4_atk1_ObjectClass_state_change
func _gotk4_atk1_ObjectClass_state_change(arg0 *C.void, arg1 *C.gchar, arg2 C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		StateChange(name string, stateSet bool)
	})

	var _name string   // out
	var _stateSet bool // out

	_name = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	if arg2 != 0 {
		_stateSet = true
	}

	iface.StateChange(_name, _stateSet)
}

//export _gotk4_atk1_ObjectClass_visible_data_changed
func _gotk4_atk1_ObjectClass_visible_data_changed(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ VisibleDataChanged() })

	iface.VisibleDataChanged()
}

func wrapObject(obj *coreglib.Object) *ObjectClass {
	return &ObjectClass{
		Object: obj,
	}
}

func marshalObjectClass(p uintptr) (interface{}, error) {
	return wrapObject(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_atk1_Object_ConnectActiveDescendantChanged
func _gotk4_atk1_Object_ConnectActiveDescendantChanged(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(arg1 *ObjectClass)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1 *ObjectClass))
	}

	var _arg1 *ObjectClass // out

	_arg1 = wrapObject(coreglib.Take(unsafe.Pointer(arg1)))

	f(_arg1)
}

// ConnectActiveDescendantChanged: "active-descendant-changed" signal is emitted
// by an object which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
// object in the object changes. For instance, a table will emit the signal when
// the cell in the table which has focus changes.
func (accessible *ObjectClass) ConnectActiveDescendantChanged(f func(arg1 *ObjectClass)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(accessible, "active-descendant-changed", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectActiveDescendantChanged), f)
}

//export _gotk4_atk1_Object_ConnectChildrenChanged
func _gotk4_atk1_Object_ConnectChildrenChanged(arg0 C.gpointer, arg1 C.guint, arg2 *C.void, arg3 C.guintptr) {
	var f func(arg1 uint32, arg2 *ObjectClass)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1 uint32, arg2 *ObjectClass))
	}

	var _arg1 uint32       // out
	var _arg2 *ObjectClass // out

	_arg1 = uint32(arg1)
	_arg2 = wrapObject(coreglib.Take(unsafe.Pointer(arg2)))

	f(_arg1, _arg2)
}

// ConnectChildrenChanged: signal "children-changed" is emitted when a child is
// added or removed form an object. It supports two details: "add" and "remove".
func (accessible *ObjectClass) ConnectChildrenChanged(f func(arg1 uint32, arg2 *ObjectClass)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(accessible, "children-changed", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectChildrenChanged), f)
}

//export _gotk4_atk1_Object_ConnectFocusEvent
func _gotk4_atk1_Object_ConnectFocusEvent(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(arg1 bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1 bool))
	}

	var _arg1 bool // out

	if arg1 != 0 {
		_arg1 = true
	}

	f(_arg1)
}

// ConnectFocusEvent: signal "focus-event" is emitted when an object gained or
// lost focus.
func (accessible *ObjectClass) ConnectFocusEvent(f func(arg1 bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(accessible, "focus-event", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectFocusEvent), f)
}

//export _gotk4_atk1_Object_ConnectPropertyChange
func _gotk4_atk1_Object_ConnectPropertyChange(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(arg1 *PropertyValues)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1 *PropertyValues))
	}

	var _arg1 *PropertyValues // out

	_arg1 = (*PropertyValues)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_arg1)
}

// ConnectPropertyChange: signal "property-change" is emitted when an object's
// property value changes. arg1 contains an PropertyValues with the name and the
// new value of the property whose value has changed. Note that, as with GObject
// notify, getting this signal does not guarantee that the value of the property
// has actually changed; it may also be emitted when the setter of the property
// is called to reinstate the previous value.
//
// Toolkit implementor note: ATK implementors should use g_object_notify() to
// emit property-changed notifications. Object::property-changed is needed by
// the implementation of atk_add_global_event_listener() because GObject notify
// doesn't support emission hooks.
func (accessible *ObjectClass) ConnectPropertyChange(f func(arg1 *PropertyValues)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(accessible, "property-change", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectPropertyChange), f)
}

//export _gotk4_atk1_Object_ConnectStateChange
func _gotk4_atk1_Object_ConnectStateChange(arg0 C.gpointer, arg1 *C.gchar, arg2 C.gboolean, arg3 C.guintptr) {
	var f func(arg1 string, arg2 bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1 string, arg2 bool))
	}

	var _arg1 string // out
	var _arg2 bool   // out

	_arg1 = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	if arg2 != 0 {
		_arg2 = true
	}

	f(_arg1, _arg2)
}

// ConnectStateChange: "state-change" signal is emitted when an object's state
// changes. The detail value identifies the state type which has changed.
func (accessible *ObjectClass) ConnectStateChange(f func(arg1 string, arg2 bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(accessible, "state-change", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectStateChange), f)
}

//export _gotk4_atk1_Object_ConnectVisibleDataChanged
func _gotk4_atk1_Object_ConnectVisibleDataChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectVisibleDataChanged: "visible-data-changed" signal is emitted when the
// visual appearance of the object changed.
func (accessible *ObjectClass) ConnectVisibleDataChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(accessible, "visible-data-changed", false, unsafe.Pointer(C._gotk4_atk1_Object_ConnectVisibleDataChanged), f)
}

// AccessibleID gets the accessible id of the accessible.
//
// The function returns the following values:
//
//    - utf8: character string representing the accessible id of the object, or
//      NULL if no such string was set.
//
func (accessible *ObjectClass) AccessibleID() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("get_accessible_id", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// Description gets the accessible description of the accessible.
//
// The function returns the following values:
//
//    - utf8: character string representing the accessible description of the
//      accessible.
//
func (accessible *ObjectClass) Description() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("get_description", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// IndexInParent gets the 0-based index of this accessible in its parent;
// returns -1 if the accessible does not have an accessible parent.
//
// The function returns the following values:
//
//    - gint: integer which is the index of the accessible in its parent.
//
func (accessible *ObjectClass) IndexInParent() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("get_index_in_parent", _args[:], nil)
	_cret := *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// MDIZOrder gets the zorder of the accessible. The value G_MININT will be
// returned if the layer of the accessible is not ATK_LAYER_MDI.
//
// Deprecated: Use atk_component_get_mdi_zorder instead.
//
// The function returns the following values:
//
//    - gint which is the zorder of the accessible, i.e. the depth at which the
//      component is shown in relation to other components in the same container.
//
func (accessible *ObjectClass) MDIZOrder() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("get_mdi_zorder", _args[:], nil)
	_cret := *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// NAccessibleChildren gets the number of accessible children of the accessible.
//
// The function returns the following values:
//
//    - gint: integer representing the number of accessible children of the
//      accessible.
//
func (accessible *ObjectClass) NAccessibleChildren() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("get_n_accessible_children", _args[:], nil)
	_cret := *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Name gets the accessible name of the accessible.
//
// The function returns the following values:
//
//    - utf8: character string representing the accessible name of the object.
//
func (accessible *ObjectClass) Name() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("get_name", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// ObjectLocale gets a UTF-8 string indicating the POSIX-style LC_MESSAGES
// locale of accessible.
//
// The function returns the following values:
//
//    - utf8: UTF-8 string indicating the POSIX-style LC_MESSAGES locale of
//      accessible.
//
func (accessible *ObjectClass) ObjectLocale() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("get_object_locale", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// Parent gets the accessible parent of the accessible. By default this is the
// one assigned with atk_object_set_parent(), but it is assumed that ATK
// implementors have ways to get the parent of the object without the need of
// assigning it manually with atk_object_set_parent(), and will return it with
// this method.
//
// If you are only interested on the parent assigned with
// atk_object_set_parent(), use atk_object_peek_parent().
//
// The function returns the following values:
//
//    - object representing the accessible parent of the accessible.
//
func (accessible *ObjectClass) Parent() *ObjectClass {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("get_parent", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _object *ObjectClass // out

	_object = wrapObject(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _object
}

// Initialize: this function is called when implementing subclasses of Object.
// It does initialization required for the new object. It is intended that this
// function should called only in the ..._new() functions used to create an
// instance of a subclass of Object.
//
// The function takes the following parameters:
//
//    - data (optional) which identifies the object for which the AtkObject was
//      created.
//
func (accessible *ObjectClass) Initialize(data unsafe.Pointer) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (C.gpointer)(unsafe.Pointer(data))

	_info := girepository.MustFind("Atk", "Object")
	_info.InvokeClassMethod("initialize", _args[:], nil)

	runtime.KeepAlive(accessible)
	runtime.KeepAlive(data)
}

// NotifyStateChange emits a state-change signal for the specified state.
//
// Note that as a general rule when the state of an existing object changes,
// emitting a notification is expected.
//
// The function takes the following parameters:
//
//    - state whose state is changed.
//    - value: gboolean which indicates whether the state is being set on or off.
//
func (accessible *ObjectClass) NotifyStateChange(state State, value bool) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	*(*C.guint64)(unsafe.Pointer(&_args[1])) = C.guint64(state)
	if value {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	_info := girepository.MustFind("Atk", "Object")
	_info.InvokeClassMethod("notify_state_change", _args[:], nil)

	runtime.KeepAlive(accessible)
	runtime.KeepAlive(state)
	runtime.KeepAlive(value)
}

// PeekParent gets the accessible parent of the accessible, if it has been
// manually assigned with atk_object_set_parent. Otherwise, this function
// returns NULL.
//
// This method is intended as an utility for ATK implementors, and not to be
// exposed to accessible tools. See atk_object_get_parent() for further
// reference.
//
// The function returns the following values:
//
//    - object representing the accessible parent of the accessible if assigned.
//
func (accessible *ObjectClass) PeekParent() *ObjectClass {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("peek_parent", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _object *ObjectClass // out

	_object = wrapObject(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _object
}

// RefAccessibleChild gets a reference to the specified accessible child of the
// object. The accessible children are 0-based so the first accessible child is
// at index 0, the second at index 1 and so on.
//
// The function takes the following parameters:
//
//    - i: gint representing the position of the child, starting from 0.
//
// The function returns the following values:
//
//    - object representing the specified accessible child of the accessible.
//
func (accessible *ObjectClass) RefAccessibleChild(i int32) *ObjectClass {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(i)

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("ref_accessible_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)
	runtime.KeepAlive(i)

	var _object *ObjectClass // out

	_object = wrapObject(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _object
}

// RefRelationSet gets the RelationSet associated with the object.
//
// The function returns the following values:
//
//    - relationSet representing the relation set of the object.
//
func (accessible *ObjectClass) RefRelationSet() *RelationSet {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("ref_relation_set", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _relationSet *RelationSet // out

	_relationSet = wrapRelationSet(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _relationSet
}

// RefStateSet gets a reference to the state set of the accessible; the caller
// must unreference it when it is no longer needed.
//
// The function returns the following values:
//
//    - stateSet: reference to an StateSet which is the state set of the
//      accessible.
//
func (accessible *ObjectClass) RefStateSet() *StateSet {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_gret := _info.InvokeClassMethod("ref_state_set", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accessible)

	var _stateSet *StateSet // out

	_stateSet = wrapStateSet(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _stateSet
}

// RemovePropertyChangeHandler removes a property change handler.
//
// Deprecated: See atk_object_connect_property_change_handler().
//
// The function takes the following parameters:
//
//    - handlerId: guint which identifies the handler to be removed.
//
func (accessible *ObjectClass) RemovePropertyChangeHandler(handlerId uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(handlerId)

	_info := girepository.MustFind("Atk", "Object")
	_info.InvokeClassMethod("remove_property_change_handler", _args[:], nil)

	runtime.KeepAlive(accessible)
	runtime.KeepAlive(handlerId)
}

// SetAccessibleID sets the accessible ID of the accessible. This is not meant
// to be presented to the user, but to be an ID which is stable over application
// development. Typically, this is the gtkbuilder ID. Such an ID will be
// available for instance to identify a given well-known accessible object for
// tailored screen reading, or for automatic regression testing.
//
// The function takes the following parameters:
//
//    - name: character string to be set as the accessible id.
//
func (accessible *ObjectClass) SetAccessibleID(name string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Atk", "Object")
	_info.InvokeClassMethod("set_accessible_id", _args[:], nil)

	runtime.KeepAlive(accessible)
	runtime.KeepAlive(name)
}

// SetDescription sets the accessible description of the accessible. You can't
// set the description to NULL. This is reserved for the initial value. In this
// aspect NULL is similar to ATK_ROLE_UNKNOWN. If you want to set the name to a
// empty value you can use "".
//
// The function takes the following parameters:
//
//    - description: character string to be set as the accessible description.
//
func (accessible *ObjectClass) SetDescription(description string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(description)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Atk", "Object")
	_info.InvokeClassMethod("set_description", _args[:], nil)

	runtime.KeepAlive(accessible)
	runtime.KeepAlive(description)
}

// SetName sets the accessible name of the accessible. You can't set the name to
// NULL. This is reserved for the initial value. In this aspect NULL is similar
// to ATK_ROLE_UNKNOWN. If you want to set the name to a empty value you can use
// "".
//
// The function takes the following parameters:
//
//    - name: character string to be set as the accessible name.
//
func (accessible *ObjectClass) SetName(name string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Atk", "Object")
	_info.InvokeClassMethod("set_name", _args[:], nil)

	runtime.KeepAlive(accessible)
	runtime.KeepAlive(name)
}

// SetParent sets the accessible parent of the accessible. parent can be NULL.
//
// The function takes the following parameters:
//
//    - parent to be set as the accessible parent.
//
func (accessible *ObjectClass) SetParent(parent *ObjectClass) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	_info := girepository.MustFind("Atk", "Object")
	_info.InvokeClassMethod("set_parent", _args[:], nil)

	runtime.KeepAlive(accessible)
	runtime.KeepAlive(parent)
}

// Attribute is a string name/value pair representing a generic attribute. This
// can be used to expose additional information from an accessible object as a
// whole (see atk_object_get_attributes()) or an document (see
// atk_document_get_attributes()). In the case of text attributes (see
// atk_text_get_default_attributes()), TextAttribute enum defines all the
// possible text attribute names. You can use atk_text_attribute_get_name() to
// get the string name from the enum value. See also
// atk_text_attribute_for_name() and atk_text_attribute_get_value() for more
// information.
//
// A string name/value pair representing a generic attribute.
//
// An instance of this type is always passed by reference.
type Attribute struct {
	*attribute
}

// attribute is the struct that's finalized.
type attribute struct {
	native unsafe.Pointer
}

// Name: attribute name.
func (a *Attribute) Name() string {
	offset := girepository.MustFind("Atk", "Attribute").StructFieldOffset("name")
	valptr := (*uintptr)(unsafe.Add(a.native, offset))
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&*valptr)))))
	return v
}

// Value: value of the attribute, represented as a string.
func (a *Attribute) Value() string {
	offset := girepository.MustFind("Atk", "Attribute").StructFieldOffset("value")
	valptr := (*uintptr)(unsafe.Add(a.native, offset))
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&*valptr)))))
	return v
}

// PropertyValues: note: old_value field of PropertyValues will not contain a
// valid value. This is a field defined with the purpose of contain the previous
// value of the property, but is not used anymore.
//
// An instance of this type is always passed by reference.
type PropertyValues struct {
	*propertyValues
}

// propertyValues is the struct that's finalized.
type propertyValues struct {
	native unsafe.Pointer
}

// PropertyName: name of the ATK property which has changed.
func (p *PropertyValues) PropertyName() string {
	offset := girepository.MustFind("Atk", "PropertyValues").StructFieldOffset("property_name")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&*valptr)))))
	return v
}

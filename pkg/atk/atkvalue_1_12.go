// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <atk/atk.h>
// #include <glib-object.h>
// void _gotk4_atk1_Value_virtual_get_minimum_increment(void* fnptr, AtkValue* arg0, GValue* arg1) {
//   ((void (*)(AtkValue*, GValue*))(fnptr))(arg0, arg1);
// };
import "C"

// MinimumIncrement gets the minimum increment by which the value of this object
// may be changed. If zero, the minimum increment is undefined, which may mean
// that it is limited only by the floating point precision of the platform.
//
// Deprecated: Since 2.12. Use atk_value_get_increment() instead.
//
// The function returns the following values:
//
//    - value representing the minimum increment by which the accessible value
//      may be changed.
//
func (obj *Value) MinimumIncrement() coreglib.Value {
	var _arg0 *C.AtkValue // out
	var _arg1 C.GValue    // in

	_arg0 = (*C.AtkValue)(unsafe.Pointer(coreglib.InternObject(obj).Native()))

	C.atk_value_get_minimum_increment(_arg0, &_arg1)
	runtime.KeepAlive(obj)

	var _value coreglib.Value // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _value
}

// minimumIncrement gets the minimum increment by which the value of this object
// may be changed. If zero, the minimum increment is undefined, which may mean
// that it is limited only by the floating point precision of the platform.
//
// Deprecated: Since 2.12. Use atk_value_get_increment() instead.
//
// The function returns the following values:
//
//    - value representing the minimum increment by which the accessible value
//      may be changed.
//
func (obj *Value) minimumIncrement() coreglib.Value {
	gclass := (*C.AtkValueIface)(coreglib.PeekParentClass(obj))
	fnarg := gclass.get_minimum_increment

	var _arg0 *C.AtkValue // out
	var _arg1 C.GValue    // in

	_arg0 = (*C.AtkValue)(unsafe.Pointer(coreglib.InternObject(obj).Native()))

	C._gotk4_atk1_Value_virtual_get_minimum_increment(unsafe.Pointer(fnarg), _arg0, &_arg1)
	runtime.KeepAlive(obj)

	var _value coreglib.Value // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg1)))

	return _value
}

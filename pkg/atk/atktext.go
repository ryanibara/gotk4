// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_atk1_TextIface_add_selection(void*, gint, gint);
// extern gboolean _gotk4_atk1_TextIface_remove_selection(void*, gint);
// extern gboolean _gotk4_atk1_TextIface_set_caret_offset(void*, gint);
// extern gboolean _gotk4_atk1_TextIface_set_selection(void*, gint, gint, gint);
// extern gchar* _gotk4_atk1_TextIface_get_selection(void*, gint, void*, void*);
// extern gchar* _gotk4_atk1_TextIface_get_text(void*, gint, gint);
// extern gint _gotk4_atk1_TextIface_get_caret_offset(void*);
// extern gint _gotk4_atk1_TextIface_get_character_count(void*);
// extern gint _gotk4_atk1_TextIface_get_n_selections(void*);
// extern gunichar _gotk4_atk1_TextIface_get_character_at_offset(void*, gint);
// extern void _gotk4_atk1_TextIface_text_attributes_changed(void*);
// extern void _gotk4_atk1_TextIface_text_caret_moved(void*, gint);
// extern void _gotk4_atk1_TextIface_text_changed(void*, gint, gint);
// extern void _gotk4_atk1_TextIface_text_selection_changed(void*);
// extern void _gotk4_atk1_Text_ConnectTextAttributesChanged(gpointer, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextCaretMoved(gpointer, gint, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextChanged(gpointer, gint, gint, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextInsert(gpointer, gint, gint, void*, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextRemove(gpointer, gint, gint, void*, guintptr);
// extern void _gotk4_atk1_Text_ConnectTextSelectionChanged(gpointer, guintptr);
import "C"

// GTypeTextAttribute returns the GType for the type TextAttribute.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTextAttribute() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "TextAttribute").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTextAttribute)
	return gtype
}

// GTypeTextBoundary returns the GType for the type TextBoundary.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTextBoundary() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "TextBoundary").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTextBoundary)
	return gtype
}

// GTypeTextClipType returns the GType for the type TextClipType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTextClipType() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "TextClipType").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTextClipType)
	return gtype
}

// GTypeTextGranularity returns the GType for the type TextGranularity.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTextGranularity() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "TextGranularity").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTextGranularity)
	return gtype
}

// GTypeText returns the GType for the type Text.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeText() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "Text").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalText)
	return gtype
}

// GTypeTextRange returns the GType for the type TextRange.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTextRange() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "TextRange").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTextRange)
	return gtype
}

// TextAttribute describes the text attributes supported.
type TextAttribute C.gint

const (
	// TextAttrInvalid: invalid attribute, like bad spelling or grammar.
	TextAttrInvalid TextAttribute = iota
	// TextAttrLeftMargin: pixel width of the left margin.
	TextAttrLeftMargin
	// TextAttrRightMargin: pixel width of the right margin.
	TextAttrRightMargin
	// TextAttrIndent: number of pixels that the text is indented.
	TextAttrIndent
	// TextAttrInvisible: either "true" or "false" indicating whether text is
	// visible or not.
	TextAttrInvisible
	// TextAttrEditable: either "true" or "false" indicating whether text is
	// editable or not.
	TextAttrEditable
	// TextAttrPixelsAboveLines pixels of blank space to leave above each
	// newline-terminated line.
	TextAttrPixelsAboveLines
	// TextAttrPixelsBelowLines pixels of blank space to leave below each
	// newline-terminated line.
	TextAttrPixelsBelowLines
	// TextAttrPixelsInsideWrap pixels of blank space to leave between wrapped
	// lines inside the same newline-terminated line (paragraph).
	TextAttrPixelsInsideWrap
	// TextAttrBgFullHeight: "true" or "false" whether to make the background
	// color for each character the height of the highest font used on the
	// current line, or the height of the font used for the current character.
	TextAttrBgFullHeight
	// TextAttrRise: number of pixels that the characters are risen above the
	// baseline. See also ATK_TEXT_ATTR_TEXT_POSITION.
	TextAttrRise
	// TextAttrUnderline: "none", "single", "double", "low", or "error".
	TextAttrUnderline
	// TextAttrStrikethrough: "true" or "false" whether the text is
	// strikethrough.
	TextAttrStrikethrough
	// TextAttrSize: size of the characters in points. eg: 10.
	TextAttrSize
	// TextAttrScale: scale of the characters. The value is a string
	// representation of a double.
	TextAttrScale
	// TextAttrWeight: weight of the characters.
	TextAttrWeight
	// TextAttrLanguage: language used.
	TextAttrLanguage
	// TextAttrFamilyName: font family name.
	TextAttrFamilyName
	// TextAttrBgColor: background color. The value is an RGB value of the
	// format "u,u,u".
	TextAttrBgColor
	// TextAttrFgColor: foreground color. The value is an RGB value of the
	// format "u,u,u".
	TextAttrFgColor
	// TextAttrBgStipple: "true" if a Bitmap is set for stippling the background
	// color.
	TextAttrBgStipple
	// TextAttrFgStipple: "true" if a Bitmap is set for stippling the foreground
	// color.
	TextAttrFgStipple
	// TextAttrWrapMode: wrap mode of the text, if any. Values are "none",
	// "char", "word", or "word_char".
	TextAttrWrapMode
	// TextAttrDirection: direction of the text, if set. Values are "none",
	// "ltr" or "rtl".
	TextAttrDirection
	// TextAttrJustification: justification of the text, if set. Values are
	// "left", "right", "center" or "fill".
	TextAttrJustification
	// TextAttrStretch: stretch of the text, if set. Values are
	// "ultra_condensed", "extra_condensed", "condensed", "semi_condensed",
	// "normal", "semi_expanded", "expanded", "extra_expanded" or
	// "ultra_expanded".
	TextAttrStretch
	// TextAttrVariant: capitalization variant of the text, if set. Values are
	// "normal" or "small_caps".
	TextAttrVariant
	// TextAttrStyle: slant style of the text, if set. Values are "normal",
	// "oblique" or "italic".
	TextAttrStyle
	// TextAttrTextPosition: vertical position with respect to the baseline.
	// Values are "baseline", "super", or "sub". Note that a super or sub text
	// attribute refers to position with respect to the baseline of the prior
	// character.
	TextAttrTextPosition
	// TextAttrLastDefined: not a valid text attribute, used for finding end of
	// enumeration.
	TextAttrLastDefined
)

func marshalTextAttribute(p uintptr) (interface{}, error) {
	return TextAttribute(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextAttribute.
func (t TextAttribute) String() string {
	switch t {
	case TextAttrInvalid:
		return "Invalid"
	case TextAttrLeftMargin:
		return "LeftMargin"
	case TextAttrRightMargin:
		return "RightMargin"
	case TextAttrIndent:
		return "Indent"
	case TextAttrInvisible:
		return "Invisible"
	case TextAttrEditable:
		return "Editable"
	case TextAttrPixelsAboveLines:
		return "PixelsAboveLines"
	case TextAttrPixelsBelowLines:
		return "PixelsBelowLines"
	case TextAttrPixelsInsideWrap:
		return "PixelsInsideWrap"
	case TextAttrBgFullHeight:
		return "BgFullHeight"
	case TextAttrRise:
		return "Rise"
	case TextAttrUnderline:
		return "Underline"
	case TextAttrStrikethrough:
		return "Strikethrough"
	case TextAttrSize:
		return "Size"
	case TextAttrScale:
		return "Scale"
	case TextAttrWeight:
		return "Weight"
	case TextAttrLanguage:
		return "Language"
	case TextAttrFamilyName:
		return "FamilyName"
	case TextAttrBgColor:
		return "BgColor"
	case TextAttrFgColor:
		return "FgColor"
	case TextAttrBgStipple:
		return "BgStipple"
	case TextAttrFgStipple:
		return "FgStipple"
	case TextAttrWrapMode:
		return "WrapMode"
	case TextAttrDirection:
		return "Direction"
	case TextAttrJustification:
		return "Justification"
	case TextAttrStretch:
		return "Stretch"
	case TextAttrVariant:
		return "Variant"
	case TextAttrStyle:
		return "Style"
	case TextAttrTextPosition:
		return "TextPosition"
	case TextAttrLastDefined:
		return "LastDefined"
	default:
		return fmt.Sprintf("TextAttribute(%d)", t)
	}
}

// TextBoundary: text boundary types used for specifying boundaries for regions
// of text. This enumeration is deprecated since 2.9.4 and should not be used.
// Use AtkTextGranularity with #atk_text_get_string_at_offset instead.
type TextBoundary C.gint

const (
	// TextBoundaryChar: boundary is the boundary between characters (including
	// non-printing characters).
	TextBoundaryChar TextBoundary = iota
	// TextBoundaryWordStart: boundary is the start (i.e. first character) of a
	// word.
	TextBoundaryWordStart
	// TextBoundaryWordEnd: boundary is the end (i.e. last character) of a word.
	TextBoundaryWordEnd
	// TextBoundarySentenceStart: boundary is the first character in a sentence.
	TextBoundarySentenceStart
	// TextBoundarySentenceEnd: boundary is the last (terminal) character in a
	// sentence; in languages which use "sentence stop" punctuation such as
	// English, the boundary is thus the '.', '?', or similar terminal
	// punctuation character.
	TextBoundarySentenceEnd
	// TextBoundaryLineStart: boundary is the initial character of the content
	// or a character immediately following a newline, linefeed, or return
	// character.
	TextBoundaryLineStart
	// TextBoundaryLineEnd: boundary is the linefeed, or return character.
	TextBoundaryLineEnd
)

func marshalTextBoundary(p uintptr) (interface{}, error) {
	return TextBoundary(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextBoundary.
func (t TextBoundary) String() string {
	switch t {
	case TextBoundaryChar:
		return "Char"
	case TextBoundaryWordStart:
		return "WordStart"
	case TextBoundaryWordEnd:
		return "WordEnd"
	case TextBoundarySentenceStart:
		return "SentenceStart"
	case TextBoundarySentenceEnd:
		return "SentenceEnd"
	case TextBoundaryLineStart:
		return "LineStart"
	case TextBoundaryLineEnd:
		return "LineEnd"
	default:
		return fmt.Sprintf("TextBoundary(%d)", t)
	}
}

// TextClipType describes the type of clipping required.
type TextClipType C.gint

const (
	// TextClipNone: no clipping to be done.
	TextClipNone TextClipType = iota
	// TextClipMin: text clipped by min coordinate is omitted.
	TextClipMin
	// TextClipMax: text clipped by max coordinate is omitted.
	TextClipMax
	// TextClipBoth: only text fully within mix/max bound is retained.
	TextClipBoth
)

func marshalTextClipType(p uintptr) (interface{}, error) {
	return TextClipType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextClipType.
func (t TextClipType) String() string {
	switch t {
	case TextClipNone:
		return "None"
	case TextClipMin:
		return "Min"
	case TextClipMax:
		return "Max"
	case TextClipBoth:
		return "Both"
	default:
		return fmt.Sprintf("TextClipType(%d)", t)
	}
}

// TextGranularity: text granularity types used for specifying the granularity
// of the region of text we are interested in.
type TextGranularity C.gint

const (
	// TextGranularityChar: granularity is defined by the boundaries between
	// characters (including non-printing characters).
	TextGranularityChar TextGranularity = iota
	// TextGranularityWord: granularity is defined by the boundaries of a word,
	// starting at the beginning of the current word and finishing at the
	// beginning of the following one, if present.
	TextGranularityWord
	// TextGranularitySentence: granularity is defined by the boundaries of a
	// sentence, starting at the beginning of the current sentence and finishing
	// at the beginning of the following one, if present.
	TextGranularitySentence
	// TextGranularityLine: granularity is defined by the boundaries of a line,
	// starting at the beginning of the current line and finishing at the
	// beginning of the following one, if present.
	TextGranularityLine
	// TextGranularityParagraph: granularity is defined by the boundaries of a
	// paragraph, starting at the beginning of the current paragraph and
	// finishing at the beginning of the following one, if present.
	TextGranularityParagraph
)

func marshalTextGranularity(p uintptr) (interface{}, error) {
	return TextGranularity(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextGranularity.
func (t TextGranularity) String() string {
	switch t {
	case TextGranularityChar:
		return "Char"
	case TextGranularityWord:
		return "Word"
	case TextGranularitySentence:
		return "Sentence"
	case TextGranularityLine:
		return "Line"
	case TextGranularityParagraph:
		return "Paragraph"
	default:
		return fmt.Sprintf("TextGranularity(%d)", t)
	}
}

// TextOverrider contains methods that are overridable.
type TextOverrider interface {
	// AddSelection adds a selection bounded by the specified offsets.
	//
	// The function takes the following parameters:
	//
	//    - startOffset: starting character offset of the selected region.
	//    - endOffset: offset of the first character after the selected region.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if successful, FALSE otherwise.
	//
	AddSelection(startOffset, endOffset int32) bool
	// CaretOffset gets the offset of the position of the caret (cursor).
	//
	// The function returns the following values:
	//
	//    - gint: character offset of the position of the caret or -1 if the
	//      caret is not located inside the element or in the case of any other
	//      failure.
	//
	CaretOffset() int32
	// CharacterAtOffset gets the specified text.
	//
	// The function takes the following parameters:
	//
	//    - offset: character offset within text.
	//
	// The function returns the following values:
	//
	//    - gunichar: character at offset or 0 in the case of failure.
	//
	CharacterAtOffset(offset int32) uint32
	// CharacterCount gets the character count.
	//
	// The function returns the following values:
	//
	//    - gint: number of characters or -1 in case of failure.
	//
	CharacterCount() int32
	// NSelections gets the number of selected regions.
	//
	// The function returns the following values:
	//
	//    - gint: number of selected regions, or -1 in the case of failure.
	//
	NSelections() int32
	// Selection gets the text from the specified selection.
	//
	// The function takes the following parameters:
	//
	//    - selectionNum: selection number. The selected regions are assigned
	//      numbers that correspond to how far the region is from the start of
	//      the text. The selected region closest to the beginning of the text
	//      region is assigned the number 0, etc. Note that adding, moving or
	//      deleting a selected region can change the numbering.
	//
	// The function returns the following values:
	//
	//    - startOffset passes back the starting character offset of the selected
	//      region.
	//    - endOffset passes back the ending character offset (offset immediately
	//      past) of the selected region.
	//    - utf8: newly allocated string containing the selected text. Use
	//      g_free() to free the returned string.
	//
	Selection(selectionNum int32) (startOffset, endOffset int32, utf8 string)
	// Text gets the specified text.
	//
	// The function takes the following parameters:
	//
	//    - startOffset: starting character offset within text.
	//    - endOffset: ending character offset within text, or -1 for the end of
	//      the string.
	//
	// The function returns the following values:
	//
	//    - utf8: newly allocated string containing the text from start_offset up
	//      to, but not including end_offset. Use g_free() to free the returned
	//      string.
	//
	Text(startOffset, endOffset int32) string
	// RemoveSelection removes the specified selection.
	//
	// The function takes the following parameters:
	//
	//    - selectionNum: selection number. The selected regions are assigned
	//      numbers that correspond to how far the region is from the start of
	//      the text. The selected region closest to the beginning of the text
	//      region is assigned the number 0, etc. Note that adding, moving or
	//      deleting a selected region can change the numbering.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if successful, FALSE otherwise.
	//
	RemoveSelection(selectionNum int32) bool
	// SetCaretOffset sets the caret (cursor) position to the specified offset.
	//
	// In the case of rich-text content, this method should either grab focus or
	// move the sequential focus navigation starting point (if the application
	// supports this concept) as if the user had clicked on the new caret
	// position. Typically, this means that the target of this operation is the
	// node containing the new caret position or one of its ancestors. In other
	// words, after this method is called, if the user advances focus, it should
	// move to the first focusable node following the new caret position.
	//
	// Calling this method should also scroll the application viewport in a way
	// that matches the behavior of the application's typical caret motion or
	// tab navigation as closely as possible. This also means that if the
	// application's caret motion or focus navigation does not trigger a scroll
	// operation, this method should not trigger one either. If the application
	// does not have a caret motion or focus navigation operation, this method
	// should try to scroll the new caret position into view while minimizing
	// unnecessary scroll motion.
	//
	// The function takes the following parameters:
	//
	//    - offset: character offset of the new caret position.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if successful, FALSE otherwise.
	//
	SetCaretOffset(offset int32) bool
	// SetSelection changes the start and end offset of the specified selection.
	//
	// The function takes the following parameters:
	//
	//    - selectionNum: selection number. The selected regions are assigned
	//      numbers that correspond to how far the region is from the start of
	//      the text. The selected region closest to the beginning of the text
	//      region is assigned the number 0, etc. Note that adding, moving or
	//      deleting a selected region can change the numbering.
	//    - startOffset: new starting character offset of the selection.
	//    - endOffset: new end position of (e.g. offset immediately past) the
	//      selection.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if successful, FALSE otherwise.
	//
	SetSelection(selectionNum, startOffset, endOffset int32) bool
	TextAttributesChanged()
	// The function takes the following parameters:
	//
	TextCaretMoved(location int32)
	// The function takes the following parameters:
	//
	//    - position
	//    - length
	//
	TextChanged(position, length int32)
	TextSelectionChanged()
}

// Text should be implemented by Objects on behalf of widgets that have text
// content which is either attributed or otherwise non-trivial. Objects whose
// text content is simple, unattributed, and very brief may expose that content
// via #atk_object_get_name instead; however if the text is editable,
// multi-line, typically longer than three or four words, attributed,
// selectable, or if the object already uses the 'name' ATK property for other
// information, the Text interface should be used to expose the text content. In
// the case of editable text content, EditableText (a subtype of the Text
// interface) should be implemented instead.
//
//    Text provides not only traversal facilities and change
//
// notification for text content, but also caret tracking and glyph bounding box
// calculations. Note that the text strings are exposed as UTF-8, and are
// therefore potentially multi-byte, and caret-to-byte offset mapping makes no
// assumptions about the character length; also bounding box glyph-to-offset
// mapping may be complex for languages which use ligatures.
//
// Text wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Text struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Text)(nil)
)

// Texter describes Text's interface methods.
type Texter interface {
	coreglib.Objector

	// AddSelection adds a selection bounded by the specified offsets.
	AddSelection(startOffset, endOffset int32) bool
	// CaretOffset gets the offset of the position of the caret (cursor).
	CaretOffset() int32
	// CharacterAtOffset gets the specified text.
	CharacterAtOffset(offset int32) uint32
	// CharacterCount gets the character count.
	CharacterCount() int32
	// NSelections gets the number of selected regions.
	NSelections() int32
	// Selection gets the text from the specified selection.
	Selection(selectionNum int32) (startOffset, endOffset int32, utf8 string)
	// Text gets the specified text.
	Text(startOffset, endOffset int32) string
	// RemoveSelection removes the specified selection.
	RemoveSelection(selectionNum int32) bool
	// SetCaretOffset sets the caret (cursor) position to the specified offset.
	SetCaretOffset(offset int32) bool
	// SetSelection changes the start and end offset of the specified selection.
	SetSelection(selectionNum, startOffset, endOffset int32) bool

	// Text-attributes-changed: "text-attributes-changed" signal is emitted when
	// the text attributes of the text of an object which implements AtkText
	// changes.
	ConnectTextAttributesChanged(func()) coreglib.SignalHandle
	// Text-caret-moved: "text-caret-moved" signal is emitted when the caret
	// position of the text of an object which implements AtkText changes.
	ConnectTextCaretMoved(func(arg1 int32)) coreglib.SignalHandle
	// Text-changed: "text-changed" signal is emitted when the text of the
	// object which implements the AtkText interface changes, This signal will
	// have a detail which is either "insert" or "delete" which identifies
	// whether the text change was an insertion or a deletion.
	ConnectTextChanged(func(arg1, arg2 int32)) coreglib.SignalHandle
	// Text-insert: "text-insert" signal is emitted when a new text is inserted.
	ConnectTextInsert(func(arg1, arg2 int32, arg3 string)) coreglib.SignalHandle
	// Text-remove: "text-remove" signal is emitted when a new text is removed.
	ConnectTextRemove(func(arg1, arg2 int32, arg3 string)) coreglib.SignalHandle
	// Text-selection-changed: "text-selection-changed" signal is emitted when
	// the selected text of an object which implements AtkText changes.
	ConnectTextSelectionChanged(func()) coreglib.SignalHandle
}

var _ Texter = (*Text)(nil)

func ifaceInitTexter(gifacePtr, data C.gpointer) {
	iface := girepository.MustFind("Atk", "TextIface")
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("add_selection"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_add_selection)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_caret_offset"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_get_caret_offset)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_character_at_offset"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_get_character_at_offset)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_character_count"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_get_character_count)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_n_selections"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_get_n_selections)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_selection"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_get_selection)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_text"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_get_text)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("remove_selection"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_remove_selection)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("set_caret_offset"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_set_caret_offset)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("set_selection"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_set_selection)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("text_attributes_changed"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_text_attributes_changed)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("text_caret_moved"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_text_caret_moved)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("text_changed"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_text_changed)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("text_selection_changed"))) = unsafe.Pointer(C._gotk4_atk1_TextIface_text_selection_changed)
}

//export _gotk4_atk1_TextIface_add_selection
func _gotk4_atk1_TextIface_add_selection(arg0 *C.void, arg1 C.gint, arg2 C.gint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _startOffset int32 // out
	var _endOffset int32   // out

	_startOffset = int32(arg1)
	_endOffset = int32(arg2)

	ok := iface.AddSelection(_startOffset, _endOffset)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_atk1_TextIface_get_caret_offset
func _gotk4_atk1_TextIface_get_caret_offset(arg0 *C.void) (cret C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	gint := iface.CaretOffset()

	cret = C.gint(gint)

	return cret
}

//export _gotk4_atk1_TextIface_get_character_at_offset
func _gotk4_atk1_TextIface_get_character_at_offset(arg0 *C.void, arg1 C.gint) (cret C.gunichar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _offset int32 // out

	_offset = int32(arg1)

	gunichar := iface.CharacterAtOffset(_offset)

	cret = C.gunichar(gunichar)

	return cret
}

//export _gotk4_atk1_TextIface_get_character_count
func _gotk4_atk1_TextIface_get_character_count(arg0 *C.void) (cret C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	gint := iface.CharacterCount()

	cret = C.gint(gint)

	return cret
}

//export _gotk4_atk1_TextIface_get_n_selections
func _gotk4_atk1_TextIface_get_n_selections(arg0 *C.void) (cret C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	gint := iface.NSelections()

	cret = C.gint(gint)

	return cret
}

//export _gotk4_atk1_TextIface_get_selection
func _gotk4_atk1_TextIface_get_selection(arg0 *C.void, arg1 C.gint, arg2 *C.void, arg3 *C.void) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _selectionNum int32 // out

	_selectionNum = int32(arg1)

	startOffset, endOffset, utf8 := iface.Selection(_selectionNum)

	*arg2 = (*C.void)(unsafe.Pointer(startOffset))
	*arg3 = (*C.void)(unsafe.Pointer(endOffset))
	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_atk1_TextIface_get_text
func _gotk4_atk1_TextIface_get_text(arg0 *C.void, arg1 C.gint, arg2 C.gint) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _startOffset int32 // out
	var _endOffset int32   // out

	_startOffset = int32(arg1)
	_endOffset = int32(arg2)

	utf8 := iface.Text(_startOffset, _endOffset)

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_atk1_TextIface_remove_selection
func _gotk4_atk1_TextIface_remove_selection(arg0 *C.void, arg1 C.gint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _selectionNum int32 // out

	_selectionNum = int32(arg1)

	ok := iface.RemoveSelection(_selectionNum)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_atk1_TextIface_set_caret_offset
func _gotk4_atk1_TextIface_set_caret_offset(arg0 *C.void, arg1 C.gint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _offset int32 // out

	_offset = int32(arg1)

	ok := iface.SetCaretOffset(_offset)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_atk1_TextIface_set_selection
func _gotk4_atk1_TextIface_set_selection(arg0 *C.void, arg1 C.gint, arg2 C.gint, arg3 C.gint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _selectionNum int32 // out
	var _startOffset int32  // out
	var _endOffset int32    // out

	_selectionNum = int32(arg1)
	_startOffset = int32(arg2)
	_endOffset = int32(arg3)

	ok := iface.SetSelection(_selectionNum, _startOffset, _endOffset)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_atk1_TextIface_text_attributes_changed
func _gotk4_atk1_TextIface_text_attributes_changed(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	iface.TextAttributesChanged()
}

//export _gotk4_atk1_TextIface_text_caret_moved
func _gotk4_atk1_TextIface_text_caret_moved(arg0 *C.void, arg1 C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _location int32 // out

	_location = int32(arg1)

	iface.TextCaretMoved(_location)
}

//export _gotk4_atk1_TextIface_text_changed
func _gotk4_atk1_TextIface_text_changed(arg0 *C.void, arg1 C.gint, arg2 C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	var _position int32 // out
	var _length int32   // out

	_position = int32(arg1)
	_length = int32(arg2)

	iface.TextChanged(_position, _length)
}

//export _gotk4_atk1_TextIface_text_selection_changed
func _gotk4_atk1_TextIface_text_selection_changed(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TextOverrider)

	iface.TextSelectionChanged()
}

func wrapText(obj *coreglib.Object) *Text {
	return &Text{
		Object: obj,
	}
}

func marshalText(p uintptr) (interface{}, error) {
	return wrapText(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_atk1_Text_ConnectTextAttributesChanged
func _gotk4_atk1_Text_ConnectTextAttributesChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectTextAttributesChanged: "text-attributes-changed" signal is emitted
// when the text attributes of the text of an object which implements AtkText
// changes.
func (text *Text) ConnectTextAttributesChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(text, "text-attributes-changed", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextAttributesChanged), f)
}

//export _gotk4_atk1_Text_ConnectTextCaretMoved
func _gotk4_atk1_Text_ConnectTextCaretMoved(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) {
	var f func(arg1 int32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1 int32))
	}

	var _arg1 int32 // out

	_arg1 = int32(arg1)

	f(_arg1)
}

// ConnectTextCaretMoved: "text-caret-moved" signal is emitted when the caret
// position of the text of an object which implements AtkText changes.
func (text *Text) ConnectTextCaretMoved(f func(arg1 int32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(text, "text-caret-moved", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextCaretMoved), f)
}

//export _gotk4_atk1_Text_ConnectTextChanged
func _gotk4_atk1_Text_ConnectTextChanged(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.guintptr) {
	var f func(arg1, arg2 int32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1, arg2 int32))
	}

	var _arg1 int32 // out
	var _arg2 int32 // out

	_arg1 = int32(arg1)
	_arg2 = int32(arg2)

	f(_arg1, _arg2)
}

// ConnectTextChanged: "text-changed" signal is emitted when the text of the
// object which implements the AtkText interface changes, This signal will have
// a detail which is either "insert" or "delete" which identifies whether the
// text change was an insertion or a deletion.
func (text *Text) ConnectTextChanged(f func(arg1, arg2 int32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(text, "text-changed", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextChanged), f)
}

//export _gotk4_atk1_Text_ConnectTextInsert
func _gotk4_atk1_Text_ConnectTextInsert(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 *C.void, arg4 C.guintptr) {
	var f func(arg1, arg2 int32, arg3 string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1, arg2 int32, arg3 string))
	}

	var _arg1 int32  // out
	var _arg2 int32  // out
	var _arg3 string // out

	_arg1 = int32(arg1)
	_arg2 = int32(arg2)
	_arg3 = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	f(_arg1, _arg2, _arg3)
}

// ConnectTextInsert: "text-insert" signal is emitted when a new text is
// inserted. If the signal was not triggered by the user (e.g. typing or pasting
// text), the "system" detail should be included.
func (text *Text) ConnectTextInsert(f func(arg1, arg2 int32, arg3 string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(text, "text-insert", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextInsert), f)
}

//export _gotk4_atk1_Text_ConnectTextRemove
func _gotk4_atk1_Text_ConnectTextRemove(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 *C.void, arg4 C.guintptr) {
	var f func(arg1, arg2 int32, arg3 string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(arg1, arg2 int32, arg3 string))
	}

	var _arg1 int32  // out
	var _arg2 int32  // out
	var _arg3 string // out

	_arg1 = int32(arg1)
	_arg2 = int32(arg2)
	_arg3 = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	f(_arg1, _arg2, _arg3)
}

// ConnectTextRemove: "text-remove" signal is emitted when a new text is
// removed. If the signal was not triggered by the user (e.g. typing or pasting
// text), the "system" detail should be included.
func (text *Text) ConnectTextRemove(f func(arg1, arg2 int32, arg3 string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(text, "text-remove", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextRemove), f)
}

//export _gotk4_atk1_Text_ConnectTextSelectionChanged
func _gotk4_atk1_Text_ConnectTextSelectionChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectTextSelectionChanged: "text-selection-changed" signal is emitted when
// the selected text of an object which implements AtkText changes.
func (text *Text) ConnectTextSelectionChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(text, "text-selection-changed", false, unsafe.Pointer(C._gotk4_atk1_Text_ConnectTextSelectionChanged), f)
}

// AddSelection adds a selection bounded by the specified offsets.
//
// The function takes the following parameters:
//
//    - startOffset: starting character offset of the selected region.
//    - endOffset: offset of the first character after the selected region.
//
// The function returns the following values:
//
//    - ok: TRUE if successful, FALSE otherwise.
//
func (text *Text) AddSelection(startOffset, endOffset int32) bool {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(startOffset)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(endOffset)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// CaretOffset gets the offset of the position of the caret (cursor).
//
// The function returns the following values:
//
//    - gint: character offset of the position of the caret or -1 if the caret is
//      not located inside the element or in the case of any other failure.
//
func (text *Text) CaretOffset() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// CharacterAtOffset gets the specified text.
//
// The function takes the following parameters:
//
//    - offset: character offset within text.
//
// The function returns the following values:
//
//    - gunichar: character at offset or 0 in the case of failure.
//
func (text *Text) CharacterAtOffset(offset int32) uint32 {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(offset)

	_cret = *(*C.gunichar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)

	var _gunichar uint32 // out

	_gunichar = uint32(*(*C.gunichar)(unsafe.Pointer(&_cret)))

	return _gunichar
}

// CharacterCount gets the character count.
//
// The function returns the following values:
//
//    - gint: number of characters or -1 in case of failure.
//
func (text *Text) CharacterCount() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// NSelections gets the number of selected regions.
//
// The function returns the following values:
//
//    - gint: number of selected regions, or -1 in the case of failure.
//
func (text *Text) NSelections() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Selection gets the text from the specified selection.
//
// The function takes the following parameters:
//
//    - selectionNum: selection number. The selected regions are assigned numbers
//      that correspond to how far the region is from the start of the text. The
//      selected region closest to the beginning of the text region is assigned
//      the number 0, etc. Note that adding, moving or deleting a selected region
//      can change the numbering.
//
// The function returns the following values:
//
//    - startOffset passes back the starting character offset of the selected
//      region.
//    - endOffset passes back the ending character offset (offset immediately
//      past) of the selected region.
//    - utf8: newly allocated string containing the selected text. Use g_free()
//      to free the returned string.
//
func (text *Text) Selection(selectionNum int32) (startOffset, endOffset int32, utf8 string) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(selectionNum)

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)
	runtime.KeepAlive(selectionNum)

	var _startOffset int32 // out
	var _endOffset int32   // out
	var _utf8 string       // out

	_startOffset = *(*int32)(unsafe.Pointer(_outs[0]))
	_endOffset = *(*int32)(unsafe.Pointer(_outs[1]))
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _startOffset, _endOffset, _utf8
}

// Text gets the specified text.
//
// The function takes the following parameters:
//
//    - startOffset: starting character offset within text.
//    - endOffset: ending character offset within text, or -1 for the end of the
//      string.
//
// The function returns the following values:
//
//    - utf8: newly allocated string containing the text from start_offset up to,
//      but not including end_offset. Use g_free() to free the returned string.
//
func (text *Text) Text(startOffset, endOffset int32) string {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(startOffset)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(endOffset)

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RemoveSelection removes the specified selection.
//
// The function takes the following parameters:
//
//    - selectionNum: selection number. The selected regions are assigned numbers
//      that correspond to how far the region is from the start of the text. The
//      selected region closest to the beginning of the text region is assigned
//      the number 0, etc. Note that adding, moving or deleting a selected region
//      can change the numbering.
//
// The function returns the following values:
//
//    - ok: TRUE if successful, FALSE otherwise.
//
func (text *Text) RemoveSelection(selectionNum int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(selectionNum)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)
	runtime.KeepAlive(selectionNum)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SetCaretOffset sets the caret (cursor) position to the specified offset.
//
// In the case of rich-text content, this method should either grab focus or
// move the sequential focus navigation starting point (if the application
// supports this concept) as if the user had clicked on the new caret position.
// Typically, this means that the target of this operation is the node
// containing the new caret position or one of its ancestors. In other words,
// after this method is called, if the user advances focus, it should move to
// the first focusable node following the new caret position.
//
// Calling this method should also scroll the application viewport in a way that
// matches the behavior of the application's typical caret motion or tab
// navigation as closely as possible. This also means that if the application's
// caret motion or focus navigation does not trigger a scroll operation, this
// method should not trigger one either. If the application does not have a
// caret motion or focus navigation operation, this method should try to scroll
// the new caret position into view while minimizing unnecessary scroll motion.
//
// The function takes the following parameters:
//
//    - offset: character offset of the new caret position.
//
// The function returns the following values:
//
//    - ok: TRUE if successful, FALSE otherwise.
//
func (text *Text) SetCaretOffset(offset int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(offset)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)
	runtime.KeepAlive(offset)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SetSelection changes the start and end offset of the specified selection.
//
// The function takes the following parameters:
//
//    - selectionNum: selection number. The selected regions are assigned numbers
//      that correspond to how far the region is from the start of the text. The
//      selected region closest to the beginning of the text region is assigned
//      the number 0, etc. Note that adding, moving or deleting a selected region
//      can change the numbering.
//    - startOffset: new starting character offset of the selection.
//    - endOffset: new end position of (e.g. offset immediately past) the
//      selection.
//
// The function returns the following values:
//
//    - ok: TRUE if successful, FALSE otherwise.
//
func (text *Text) SetSelection(selectionNum, startOffset, endOffset int32) bool {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(text).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(selectionNum)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(startOffset)
	*(*C.gint)(unsafe.Pointer(&_args[3])) = C.gint(endOffset)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(text)
	runtime.KeepAlive(selectionNum)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// TextRange: structure used to describe a text range.
//
// An instance of this type is always passed by reference.
type TextRange struct {
	*textRange
}

// textRange is the struct that's finalized.
type textRange struct {
	native unsafe.Pointer
}

func marshalTextRange(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TextRange{&textRange{(unsafe.Pointer)(b)}}, nil
}

// TextRectangle: structure used to store a rectangle used by AtkText.
//
// An instance of this type is always passed by reference.
type TextRectangle struct {
	*textRectangle
}

// textRectangle is the struct that's finalized.
type textRectangle struct {
	native unsafe.Pointer
}

// NewTextRectangle creates a new TextRectangle instance from the given
// fields.
func NewTextRectangle(x, y, width, height int32) TextRectangle {
	var f0 C.gint // out
	f0 = C.gint(x)
	var f1 C.gint // out
	f1 = C.gint(y)
	var f2 C.gint // out
	f2 = C.gint(width)
	var f3 C.gint // out
	f3 = C.gint(height)

	v := C.AtkTextRectangle{
		x:      f0,
		y:      f1,
		width:  f2,
		height: f3,
	}

	return *(*TextRectangle)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// X: horizontal coordinate of a rectangle.
func (t *TextRectangle) X() int32 {
	offset := girepository.MustFind("Atk", "TextRectangle").StructFieldOffset("x")
	valptr := unsafe.Add(unsafe.Pointer(t), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Y: vertical coordinate of a rectangle.
func (t *TextRectangle) Y() int32 {
	offset := girepository.MustFind("Atk", "TextRectangle").StructFieldOffset("y")
	valptr := unsafe.Add(unsafe.Pointer(t), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Width: width of a rectangle.
func (t *TextRectangle) Width() int32 {
	offset := girepository.MustFind("Atk", "TextRectangle").StructFieldOffset("width")
	valptr := unsafe.Add(unsafe.Pointer(t), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Height: height of a rectangle.
func (t *TextRectangle) Height() int32 {
	offset := girepository.MustFind("Atk", "TextRectangle").StructFieldOffset("height")
	valptr := unsafe.Add(unsafe.Pointer(t), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

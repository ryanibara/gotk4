// Code generated by girgen. DO NOT EDIT.

package atk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void* _gotk4_atk1_HyperlinkImplIface_get_hyperlink(void*);
import "C"

// GTypeHyperlinkImpl returns the GType for the type HyperlinkImpl.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeHyperlinkImpl() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Atk", "HyperlinkImpl").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalHyperlinkImpl)
	return gtype
}

// HyperlinkImplOverrider contains methods that are overridable.
type HyperlinkImplOverrider interface {
	// Hyperlink gets the hyperlink associated with this object.
	//
	// The function returns the following values:
	//
	//    - hyperlink: atkHyperlink object which points to this implementing
	//      AtkObject.
	//
	Hyperlink() *Hyperlink
}

// HyperlinkImpl allows AtkObjects to refer to their associated AtkHyperlink
// instance, if one exists. AtkHyperlinkImpl differs from AtkHyperlink in that
// AtkHyperlinkImpl is an interface, whereas AtkHyperlink is a object type. The
// AtkHyperlinkImpl interface allows a client to query an AtkObject for the
// availability of an associated AtkHyperlink instance, and obtain that
// instance. It is thus particularly useful in cases where embedded content or
// inline content within a text object is present, since the embedding text
// object implements AtkHypertext and the inline/embedded objects are exposed as
// children which implement AtkHyperlinkImpl, in addition to their being
// obtainable via AtkHypertext:getLink followed by AtkHyperlink:getObject.
//
// The AtkHyperlinkImpl interface should be supported by objects exposed within
// the hierarchy as children of an AtkHypertext container which correspond to
// "links" or embedded content within the text. HTML anchors are not, for
// instance, normally exposed this way, but embedded images and components which
// appear inline in the content of a text object are. The AtkHyperlinkIface
// interface allows a means of determining which children are hyperlinks in this
// sense of the word, and for obtaining their corresponding AtkHyperlink object,
// from which the embedding range, URI, etc. can be obtained.
//
// To some extent this interface exists because, for historical reasons,
// AtkHyperlink was defined as an object type, not an interface. Thus, in order
// to interact with AtkObjects via AtkHyperlink semantics, a new interface was
// required.
//
// HyperlinkImpl wraps an interface. This means the user can get the
// underlying type by calling Cast().
type HyperlinkImpl struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*HyperlinkImpl)(nil)
)

// HyperlinkImpler describes HyperlinkImpl's interface methods.
type HyperlinkImpler interface {
	coreglib.Objector

	// Hyperlink gets the hyperlink associated with this object.
	Hyperlink() *Hyperlink
}

var _ HyperlinkImpler = (*HyperlinkImpl)(nil)

func ifaceInitHyperlinkImpler(gifacePtr, data C.gpointer) {
	iface := girepository.MustFind("Atk", "HyperlinkImplIface")
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_hyperlink"))) = unsafe.Pointer(C._gotk4_atk1_HyperlinkImplIface_get_hyperlink)
}

//export _gotk4_atk1_HyperlinkImplIface_get_hyperlink
func _gotk4_atk1_HyperlinkImplIface_get_hyperlink(arg0 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(HyperlinkImplOverrider)

	hyperlink := iface.Hyperlink()

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(hyperlink).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(hyperlink).Native()))

	return cret
}

func wrapHyperlinkImpl(obj *coreglib.Object) *HyperlinkImpl {
	return &HyperlinkImpl{
		Object: obj,
	}
}

func marshalHyperlinkImpl(p uintptr) (interface{}, error) {
	return wrapHyperlinkImpl(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Hyperlink gets the hyperlink associated with this object.
//
// The function returns the following values:
//
//    - hyperlink: atkHyperlink object which points to this implementing
//      AtkObject.
//
func (impl *HyperlinkImpl) Hyperlink() *Hyperlink {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(impl).Native()))

	_info := girepository.MustFind("Atk", "HyperlinkImpl")
	_gret := _info.InvokeIfaceMethod("get_hyperlink", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(impl)

	var _hyperlink *Hyperlink // out

	_hyperlink = wrapHyperlink(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _hyperlink
}

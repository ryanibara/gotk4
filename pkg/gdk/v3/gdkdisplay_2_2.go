// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
import "C"

// Beep emits a short beep on display.
func (display *Display) Beep() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_beep(_arg0)
	runtime.KeepAlive(display)
}

// Close closes the connection to the windowing system for the given display,
// and cleans up associated resources.
func (display *Display) Close() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_close(_arg0)
	runtime.KeepAlive(display)
}

// DefaultScreen: get the default Screen for display.
//
// The function returns the following values:
//
//    - screen: default Screen object for display.
//
func (display *Display) DefaultScreen() *Screen {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GdkScreen  // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_default_screen(_arg0)
	runtime.KeepAlive(display)

	var _screen *Screen // out

	_screen = wrapScreen(coreglib.Take(unsafe.Pointer(_cret)))

	return _screen
}

// Event gets the next Event to be processed for display, fetching events from
// the windowing system if necessary.
//
// The function returns the following values:
//
//    - event (optional): next Event to be processed, or NULL if no events are
//      pending. The returned Event should be freed with gdk_event_free().
//
func (display *Display) Event() *Event {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GdkEvent   // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_event(_arg0)
	runtime.KeepAlive(display)

	var _event *Event // out

	if _cret != nil {
		{
			v := (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
			_event = v
		}
	}

	return _event
}

// NScreens gets the number of screen managed by the display.
//
// Deprecated: The number of screens is always 1.
//
// The function returns the following values:
//
//    - gint: number of screens.
//
func (display *Display) NScreens() int {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gint        // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_n_screens(_arg0)
	runtime.KeepAlive(display)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Name gets the name of the display.
//
// The function returns the following values:
//
//    - utf8: string representing the display name. This string is owned by GDK
//      and should not be modified or freed.
//
func (display *Display) Name() string {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_name(_arg0)
	runtime.KeepAlive(display)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Pointer gets the current location of the pointer and the current modifier
// mask for a given display.
//
// Deprecated: Use gdk_device_get_position() instead.
//
// The function returns the following values:
//
//    - screen (optional): location to store the screen that the cursor is on, or
//      NULL.
//    - x (optional): location to store root window X coordinate of pointer, or
//      NULL.
//    - y (optional): location to store root window Y coordinate of pointer, or
//      NULL.
//    - mask (optional): location to store current modifier mask, or NULL.
//
func (display *Display) Pointer() (screen *Screen, x, y int, mask ModifierType) {
	var _arg0 *C.GdkDisplay     // out
	var _arg1 *C.GdkScreen      // in
	var _arg2 C.gint            // in
	var _arg3 C.gint            // in
	var _arg4 C.GdkModifierType // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_get_pointer(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(display)

	var _screen *Screen    // out
	var _x int             // out
	var _y int             // out
	var _mask ModifierType // out

	if _arg1 != nil {
		_screen = wrapScreen(coreglib.Take(unsafe.Pointer(_arg1)))
	}
	_x = int(_arg2)
	_y = int(_arg3)
	_mask = ModifierType(_arg4)

	return _screen, _x, _y, _mask
}

// Screen returns a screen object for one of the screens of the display.
//
// Deprecated: There is only one screen; use gdk_display_get_default_screen() to
// get it.
//
// The function takes the following parameters:
//
//    - screenNum: screen number.
//
// The function returns the following values:
//
//    - screen: Screen object.
//
func (display *Display) Screen(screenNum int) *Screen {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.gint        // out
	var _cret *C.GdkScreen  // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.gint(screenNum)

	_cret = C.gdk_display_get_screen(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(screenNum)

	var _screen *Screen // out

	_screen = wrapScreen(coreglib.Take(unsafe.Pointer(_cret)))

	return _screen
}

// WindowAtPointer obtains the window underneath the mouse pointer, returning
// the location of the pointer in that window in win_x, win_y for screen.
// Returns NULL if the window under the mouse pointer is not known to GDK (for
// example, belongs to another application).
//
// Deprecated: Use gdk_device_get_window_at_position() instead.
//
// The function returns the following values:
//
//    - winX (optional): return location for x coordinate of the pointer location
//      relative to the window origin, or NULL.
//    - winY (optional): return location for y coordinate of the pointer location
//      relative & to the window origin, or NULL.
//    - window (optional) under the mouse pointer, or NULL.
//
func (display *Display) WindowAtPointer() (winX, winY int, window Windower) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.gint        // in
	var _arg2 C.gint        // in
	var _cret *C.GdkWindow  // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_window_at_pointer(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(display)

	var _winX int        // out
	var _winY int        // out
	var _window Windower // out

	_winX = int(_arg1)
	_winY = int(_arg2)
	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _winX, _winY, _window
}

// KeyboardUngrab: release any keyboard grab
//
// Deprecated: Use gdk_device_ungrab(), together with gdk_device_grab() instead.
//
// The function takes the following parameters:
//
//    - time_: timestap (e.g K_CURRENT_TIME).
//
func (display *Display) KeyboardUngrab(time_ uint32) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.guint32     // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.guint32(time_)

	C.gdk_display_keyboard_ungrab(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(time_)
}

// ListDevices returns the list of available input devices attached to display.
// The list is statically allocated and should not be freed.
//
// Deprecated: Use gdk_device_manager_list_devices() instead.
//
// The function returns the following values:
//
//    - list: a list of Device.
//
func (display *Display) ListDevices() []Devicer {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GList      // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_list_devices(_arg0)
	runtime.KeepAlive(display)

	var _list []Devicer // out

	_list = make([]Devicer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GdkDevice)(v)
		var dst Devicer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gdk.Devicer is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// PeekEvent gets a copy of the first Event in the displayâ€™s event queue,
// without removing the event from the queue. (Note that this function will not
// get more events from the windowing system. It only checks the events that
// have already been moved to the GDK event queue.).
//
// The function returns the following values:
//
//    - event (optional): copy of the first Event on the event queue, or NULL if
//      no events are in the queue. The returned Event should be freed with
//      gdk_event_free().
//
func (display *Display) PeekEvent() *Event {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GdkEvent   // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_peek_event(_arg0)
	runtime.KeepAlive(display)

	var _event *Event // out

	if _cret != nil {
		{
			v := (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
			_event = v
		}
	}

	return _event
}

// PointerIsGrabbed: test if the pointer is grabbed.
//
// Deprecated: Use gdk_display_device_is_grabbed() instead.
//
// The function returns the following values:
//
//    - ok: TRUE if an active X pointer grab is in effect.
//
func (display *Display) PointerIsGrabbed() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_pointer_is_grabbed(_arg0)
	runtime.KeepAlive(display)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PointerUngrab: release any pointer grab.
//
// Deprecated: Use gdk_device_ungrab(), together with gdk_device_grab() instead.
//
// The function takes the following parameters:
//
//    - time_: timestap (e.g. GDK_CURRENT_TIME).
//
func (display *Display) PointerUngrab(time_ uint32) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.guint32     // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.guint32(time_)

	C.gdk_display_pointer_ungrab(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(time_)
}

// PutEvent appends a copy of the given event onto the front of the event queue
// for display.
//
// The function takes the following parameters:
//
//    - event: Event.
//
func (display *Display) PutEvent(event *Event) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 *C.GdkEvent   // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	C.gdk_display_put_event(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(event)
}

// SetDoubleClickTime sets the double click time (two clicks within this time
// interval count as a double click and result in a K_2BUTTON_PRESS event).
// Applications should not set this, it is a global user-configured setting.
//
// The function takes the following parameters:
//
//    - msec: double click time in milliseconds (thousandths of a second).
//
func (display *Display) SetDoubleClickTime(msec uint) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.guint(msec)

	C.gdk_display_set_double_click_time(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(msec)
}

// Sync flushes any requests queued for the windowing system and waits until all
// requests have been handled. This is often used for making sure that the
// display is synchronized with the current state of the program. Calling
// gdk_display_sync() before gdk_error_trap_pop() makes sure that any errors
// generated from earlier requests are handled before the error trap is removed.
//
// This is most useful for X11. On windowing systems where requests are handled
// synchronously, this function will do nothing.
func (display *Display) Sync() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_sync(_arg0)
	runtime.KeepAlive(display)
}

// DisplayGetDefault gets the default Display. This is a convenience function
// for: gdk_display_manager_get_default_display (gdk_display_manager_get ()).
//
// The function returns the following values:
//
//    - display (optional) or NULL if there is no default display.
//
func DisplayGetDefault() *Display {
	var _cret *C.GdkDisplay // in

	_cret = C.gdk_display_get_default()

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// DisplayOpen opens a display.
//
// The function takes the following parameters:
//
//    - displayName: name of the display to open.
//
// The function returns the following values:
//
//    - display (optional) or NULL if the display could not be opened.
//
func DisplayOpen(displayName string) *Display {
	var _arg1 *C.gchar      // out
	var _cret *C.GdkDisplay // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_display_open(_arg1)
	runtime.KeepAlive(displayName)

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeDragCancelReason = coreglib.Type(C.gdk_drag_cancel_reason_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDragCancelReason, F: marshalDragCancelReason},
	})
}

// DragCancelReason: used in DragContext to the reason of a cancelled DND
// operation.
type DragCancelReason C.gint

const (
	// DragCancelNoTarget: there is no suitable drop target.
	DragCancelNoTarget DragCancelReason = iota
	// DragCancelUserCancelled: drag cancelled by the user.
	DragCancelUserCancelled
	// DragCancelError: unspecified error.
	DragCancelError
)

func marshalDragCancelReason(p uintptr) (interface{}, error) {
	return DragCancelReason(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DragCancelReason.
func (d DragCancelReason) String() string {
	switch d {
	case DragCancelNoTarget:
		return "NoTarget"
	case DragCancelUserCancelled:
		return "UserCancelled"
	case DragCancelError:
		return "Error"
	default:
		return fmt.Sprintf("DragCancelReason(%d)", d)
	}
}

// DragDropDone: inform GDK if the drop ended successfully. Passing FALSE for
// success may trigger a drag cancellation animation.
//
// This function is called by the drag source, and should be the last call
// before dropping the reference to the context.
//
// The DragContext will only take the first gdk_drag_drop_done() call as
// effective, if this function is called multiple times, all subsequent calls
// will be ignored.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - success: whether the drag was ultimatively successful.
//
func DragDropDone(context *DragContext, success bool) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gboolean        // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if success {
		_arg2 = C.TRUE
	}

	C.gdk_drag_drop_done(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(success)
}

// DragWindow returns the window on which the drag icon should be rendered
// during the drag operation. Note that the window may not be available until
// the drag operation has begun. GDK will move the window in accordance with the
// ongoing drag operation. The window is owned by context and will be destroyed
// when the drag operation is over.
//
// The function returns the following values:
//
//    - window (optional): drag window, or NULL.
//
func (context *DragContext) DragWindow() Windower {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkWindow      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gdk_drag_context_get_drag_window(_arg0)
	runtime.KeepAlive(context)

	var _window Windower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _window
}

// ManageDND requests the drag and drop operation to be managed by context. When
// a drag and drop operation becomes managed, the DragContext will internally
// handle all input and source-side EventDND events as required by the windowing
// system.
//
// Once the drag and drop operation is managed, the drag context will emit the
// following signals:
//
// - The DragContext::action-changed signal whenever the final action to be
// performed by the drag and drop operation changes.
//
// - The DragContext::drop-performed signal after the user performs the drag and
// drop gesture (typically by releasing the mouse button).
//
// - The DragContext::dnd-finished signal after the drag and drop operation
// concludes (after all Selection transfers happen).
//
// - The DragContext::cancel signal if the drag and drop operation is finished
// but doesn't happen over an accepting destination, or is cancelled through
// other means.
//
// The function takes the following parameters:
//
//    - ipcWindow: window to use for IPC messaging/events.
//    - actions supported by the drag source.
//
// The function returns the following values:
//
//    - ok if the drag and drop operation is managed.
//
func (context *DragContext) ManageDND(ipcWindow Windower, actions DragAction) bool {
	var _arg0 *C.GdkDragContext // out
	var _arg1 *C.GdkWindow      // out
	var _arg2 C.GdkDragAction   // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(ipcWindow).Native()))
	_arg2 = C.GdkDragAction(actions)

	_cret = C.gdk_drag_context_manage_dnd(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(ipcWindow)
	runtime.KeepAlive(actions)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetHotspot sets the position of the drag window that will be kept under the
// cursor hotspot. Initially, the hotspot is at the top left corner of the drag
// window.
//
// The function takes the following parameters:
//
//    - hotX: x coordinate of the drag window hotspot.
//    - hotY: y coordinate of the drag window hotspot.
//
func (context *DragContext) SetHotspot(hotX, hotY int) {
	var _arg0 *C.GdkDragContext // out
	var _arg1 C.gint            // out
	var _arg2 C.gint            // out

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.gint(hotX)
	_arg2 = C.gint(hotY)

	C.gdk_drag_context_set_hotspot(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

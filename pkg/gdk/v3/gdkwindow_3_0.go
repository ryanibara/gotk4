// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
import "C"

// DeviceCursor retrieves a Cursor pointer for the device currently set on the
// specified Window, or NULL. If the return value is NULL then there is no
// custom cursor set on the specified window, and it is using the cursor for its
// parent window.
//
// The function takes the following parameters:
//
//    - device: master, pointer Device.
//
// The function returns the following values:
//
//    - cursor (optional) or NULL. The returned object is owned by the Window and
//      should not be unreferenced directly. Use gdk_window_set_cursor() to unset
//      the cursor of the window.
//
func (window *Window) DeviceCursor(device Devicer) Cursorrer {
	var _arg0 *C.GdkWindow // out
	var _arg1 *C.GdkDevice // out
	var _cret *C.GdkCursor // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_window_get_device_cursor(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(device)

	var _cursor Cursorrer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Cursorrer)
				return ok
			})
			rv, ok := casted.(Cursorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Cursorrer")
			}
			_cursor = rv
		}
	}

	return _cursor
}

// DeviceEvents returns the event mask for window corresponding to an specific
// device.
//
// The function takes the following parameters:
//
//    - device: Device.
//
// The function returns the following values:
//
//    - eventMask: device event mask for window.
//
func (window *Window) DeviceEvents(device Devicer) EventMask {
	var _arg0 *C.GdkWindow   // out
	var _arg1 *C.GdkDevice   // out
	var _cret C.GdkEventMask // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_window_get_device_events(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(device)

	var _eventMask EventMask // out

	_eventMask = EventMask(_cret)

	return _eventMask
}

// DevicePosition obtains the current device position and modifier state. The
// position is given in coordinates relative to the upper left corner of window.
//
// Use gdk_window_get_device_position_double() if you need subpixel precision.
//
// The function takes the following parameters:
//
//    - device: pointer Device to query to.
//
// The function returns the following values:
//
//    - x (optional): return location for the X coordinate of device, or NULL.
//    - y (optional): return location for the Y coordinate of device, or NULL.
//    - mask (optional): return location for the modifier mask, or NULL.
//    - ret (optional): window underneath device (as with
//      gdk_device_get_window_at_position()), or NULL if the window is not known
//      to GDK.
//
func (window *Window) DevicePosition(device Devicer) (x, y int, mask ModifierType, ret Windower) {
	var _arg0 *C.GdkWindow      // out
	var _arg1 *C.GdkDevice      // out
	var _arg2 C.gint            // in
	var _arg3 C.gint            // in
	var _arg4 C.GdkModifierType // in
	var _cret *C.GdkWindow      // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_window_get_device_position(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(window)
	runtime.KeepAlive(device)

	var _x int             // out
	var _y int             // out
	var _mask ModifierType // out
	var _ret Windower      // out

	_x = int(_arg2)
	_y = int(_arg3)
	_mask = ModifierType(_arg4)
	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_ret = rv
		}
	}

	return _x, _y, _mask, _ret
}

// DragProtocol finds out the DND protocol supported by a window.
//
// The function returns the following values:
//
//    - target (optional): location of the window where the drop should happen.
//      This may be window or a proxy window, or NULL if window does not support
//      Drag and Drop.
//    - dragProtocol: supported DND protocol.
//
func (window *Window) DragProtocol() (Windower, DragProtocol) {
	var _arg0 *C.GdkWindow      // out
	var _arg1 *C.GdkWindow      // in
	var _cret C.GdkDragProtocol // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_drag_protocol(_arg0, &_arg1)
	runtime.KeepAlive(window)

	var _target Windower           // out
	var _dragProtocol DragProtocol // out

	if _arg1 != nil {
		{
			objptr := unsafe.Pointer(_arg1)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_target = rv
		}
	}
	_dragProtocol = DragProtocol(_cret)

	return _target, _dragProtocol
}

// SupportMultidevice returns TRUE if the window is aware of the existence of
// multiple devices.
//
// The function returns the following values:
//
//    - ok: TRUE if the window handles multidevice features.
//
func (window *Window) SupportMultidevice() bool {
	var _arg0 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_support_multidevice(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDeviceCursor sets a specific Cursor for a given device when it gets inside
// window. Use gdk_cursor_new_for_display() or gdk_cursor_new_from_pixbuf() to
// create the cursor. To make the cursor invisible, use GDK_BLANK_CURSOR.
// Passing NULL for the cursor argument to gdk_window_set_cursor() means that
// window will use the cursor of its parent window. Most windows should use this
// default.
//
// The function takes the following parameters:
//
//    - device: master, pointer Device.
//    - cursor: Cursor.
//
func (window *Window) SetDeviceCursor(device Devicer, cursor Cursorrer) {
	var _arg0 *C.GdkWindow // out
	var _arg1 *C.GdkDevice // out
	var _arg2 *C.GdkCursor // out

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))

	C.gdk_window_set_device_cursor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(device)
	runtime.KeepAlive(cursor)
}

// SetDeviceEvents sets the event mask for a given device (Normally a floating
// device, not attached to any visible pointer) to window. For example, an event
// mask including K_BUTTON_PRESS_MASK means the window should report button
// press events. The event mask is the bitwise OR of values from the EventMask
// enumeration.
//
// See the [input handling overview][event-masks] for details.
//
// The function takes the following parameters:
//
//    - device to enable events for.
//    - eventMask: event mask for window.
//
func (window *Window) SetDeviceEvents(device Devicer, eventMask EventMask) {
	var _arg0 *C.GdkWindow   // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.GdkEventMask // out

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = C.GdkEventMask(eventMask)

	C.gdk_window_set_device_events(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(device)
	runtime.KeepAlive(eventMask)
}

// SetSourceEvents sets the event mask for any floating device (i.e. not
// attached to any visible pointer) that has the source defined as source. This
// event mask will be applied both to currently existing, newly added devices
// after this call, and devices being attached/detached.
//
// The function takes the following parameters:
//
//    - source to define the source class.
//    - eventMask: event mask for window.
//
func (window *Window) SetSourceEvents(source InputSource, eventMask EventMask) {
	var _arg0 *C.GdkWindow     // out
	var _arg1 C.GdkInputSource // out
	var _arg2 C.GdkEventMask   // out

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.GdkInputSource(source)
	_arg2 = C.GdkEventMask(eventMask)

	C.gdk_window_set_source_events(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(source)
	runtime.KeepAlive(eventMask)
}

// SetSupportMultidevice: this function will enable multidevice features in
// window.
//
// Multidevice aware windows will need to handle properly multiple, per device
// enter/leave events, device grabs and grab ownerships.
//
// The function takes the following parameters:
//
//    - supportMultidevice: TRUE to enable multidevice support in window.
//
func (window *Window) SetSupportMultidevice(supportMultidevice bool) {
	var _arg0 *C.GdkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if supportMultidevice {
		_arg1 = C.TRUE
	}

	C.gdk_window_set_support_multidevice(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(supportMultidevice)
}

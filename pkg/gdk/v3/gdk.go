// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	_ "runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gdk-3.0 gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <gdk/gdk.h>
// #include <glib-object.h>
// extern void _gotk4_gdk3_DragContext_ConnectDropPerformed(gpointer, gint, guintptr);
// extern void _gotk4_gdk3_DragContext_ConnectDNDFinished(gpointer, guintptr);
// extern void _gotk4_gdk3_DragContext_ConnectCancel(gpointer, GdkDragCancelReason, guintptr);
// extern void _gotk4_gdk3_DragContext_ConnectActionChanged(gpointer, GdkDragAction, guintptr);
import "C"

// GType values.
var (
	GTypeStatus      = coreglib.Type(C.gdk_status_get_type())
	GTypeDeviceTool  = coreglib.Type(C.gdk_device_tool_get_type())
	GTypeDragContext = coreglib.Type(C.gdk_drag_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeStatus, F: marshalStatus},
		coreglib.TypeMarshaler{T: GTypeDeviceTool, F: marshalDeviceTool},
		coreglib.TypeMarshaler{T: GTypeDragContext, F: marshalDragContext},
	})
}

// The function returns the following values:
//
func GLErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gdk_gl_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)

	return _quark
}

type Status C.gint

const (
	OK         Status = 0
	Error      Status = -1
	ErrorParam Status = -2
	ErrorFile  Status = -3
	ErrorMem   Status = -4
)

func marshalStatus(p uintptr) (interface{}, error) {
	return Status(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Status.
func (s Status) String() string {
	switch s {
	case OK:
		return "OK"
	case Error:
		return "Error"
	case ErrorParam:
		return "ErrorParam"
	case ErrorFile:
		return "ErrorFile"
	case ErrorMem:
		return "ErrorMem"
	default:
		return fmt.Sprintf("Status(%d)", s)
	}
}

type DeviceTool struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DeviceTool)(nil)
)

func wrapDeviceTool(obj *coreglib.Object) *DeviceTool {
	return &DeviceTool{
		Object: obj,
	}
}

func marshalDeviceTool(p uintptr) (interface{}, error) {
	return wrapDeviceTool(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

type DragContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*DragContext)(nil)
)

func wrapDragContext(obj *coreglib.Object) *DragContext {
	return &DragContext{
		Object: obj,
	}
}

func marshalDragContext(p uintptr) (interface{}, error) {
	return wrapDragContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActionChanged: new action is being chosen for the drag and drop
// operation.
//
// This signal will only be emitted if the DragContext manages the drag and drop
// operation. See gdk_drag_context_manage_dnd() for more information.
func (context *DragContext) ConnectActionChanged(f func(action DragAction)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "action-changed", false, unsafe.Pointer(C._gotk4_gdk3_DragContext_ConnectActionChanged), f)
}

// ConnectCancel: drag and drop operation was cancelled.
//
// This signal will only be emitted if the DragContext manages the drag and drop
// operation. See gdk_drag_context_manage_dnd() for more information.
func (context *DragContext) ConnectCancel(f func(reason DragCancelReason)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "cancel", false, unsafe.Pointer(C._gotk4_gdk3_DragContext_ConnectCancel), f)
}

// ConnectDNDFinished: drag and drop operation was finished, the drag
// destination finished reading all data. The drag source can now free all
// miscellaneous data.
//
// This signal will only be emitted if the DragContext manages the drag and drop
// operation. See gdk_drag_context_manage_dnd() for more information.
func (context *DragContext) ConnectDNDFinished(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "dnd-finished", false, unsafe.Pointer(C._gotk4_gdk3_DragContext_ConnectDNDFinished), f)
}

// ConnectDropPerformed: drag and drop operation was performed on an accepting
// client.
//
// This signal will only be emitted if the DragContext manages the drag and drop
// operation. See gdk_drag_context_manage_dnd() for more information.
func (context *DragContext) ConnectDropPerformed(f func(time int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "drop-performed", false, unsafe.Pointer(C._gotk4_gdk3_DragContext_ConnectDropPerformed), f)
}

//export _gotk4_gdk3_Monitor_ConnectInvalidate
func _gotk4_gdk3_Monitor_ConnectInvalidate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gdk3_WindowClass_create_surface
func _gotk4_gdk3_WindowClass_create_surface(arg0 *C.GdkWindow, arg1 C.gint, arg2 C.gint) (cret *C.cairo_surface_t) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.CreateSurface == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.CreateSurface, got none")
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	surface := overrides.CreateSurface(_width, _height)

	cret = (*C.cairo_surface_t)(unsafe.Pointer(surface.Native()))

	return cret
}

//export _gotk4_gdk3_WindowClass_from_embedder
func _gotk4_gdk3_WindowClass_from_embedder(arg0 *C.GdkWindow, arg1 C.gdouble, arg2 C.gdouble, arg3 *C.gdouble, arg4 *C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.FromEmbedder == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.FromEmbedder, got none")
	}

	var _embedderX float64   // out
	var _embedderY float64   // out
	var _offscreenX *float64 // out
	var _offscreenY *float64 // out

	_embedderX = float64(arg1)
	_embedderY = float64(arg2)
	_offscreenX = (*float64)(unsafe.Pointer(arg3))
	_offscreenY = (*float64)(unsafe.Pointer(arg4))

	overrides.FromEmbedder(_embedderX, _embedderY, _offscreenX, _offscreenY)
}

//export _gotk4_gdk3_WindowClass_to_embedder
func _gotk4_gdk3_WindowClass_to_embedder(arg0 *C.GdkWindow, arg1 C.gdouble, arg2 C.gdouble, arg3 *C.gdouble, arg4 *C.gdouble) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.ToEmbedder == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.ToEmbedder, got none")
	}

	var _offscreenX float64 // out
	var _offscreenY float64 // out
	var _embedderX *float64 // out
	var _embedderY *float64 // out

	_offscreenX = float64(arg1)
	_offscreenY = float64(arg2)
	_embedderX = (*float64)(unsafe.Pointer(arg3))
	_embedderY = (*float64)(unsafe.Pointer(arg4))

	overrides.ToEmbedder(_offscreenX, _offscreenY, _embedderX, _embedderY)
}

// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
import "C"

// Group returns the group leader window for window. See gdk_window_set_group().
//
// The function returns the following values:
//
//    - ret: group leader window for window.
//
func (window *Window) Group() Windower {
	var _arg0 *C.GdkWindow // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_group(_arg0)
	runtime.KeepAlive(window)

	var _ret Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_ret = rv
	}

	return _ret
}

// SetAcceptFocus: setting accept_focus to FALSE hints the desktop environment
// that the window doesn’t want to receive input focus.
//
// On X, it is the responsibility of the window manager to interpret this hint.
// ICCCM-compliant window manager usually respect it.
//
// The function takes the following parameters:
//
//    - acceptFocus: TRUE if the window should receive input focus.
//
func (window *Window) SetAcceptFocus(acceptFocus bool) {
	var _arg0 *C.GdkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if acceptFocus {
		_arg1 = C.TRUE
	}

	C.gdk_window_set_accept_focus(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(acceptFocus)
}

// SetKeepAbove: set if window must be kept above other windows. If the window
// was already above, then this function does nothing.
//
// On X11, asks the window manager to keep window above, if the window manager
// supports this operation. Not all window managers support this, and some
// deliberately ignore it or don’t have a concept of “keep above”; so you can’t
// rely on the window being kept above. But it will happen with most standard
// window managers, and GDK makes a best effort to get it to happen.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window above other windows.
//
func (window *Window) SetKeepAbove(setting bool) {
	var _arg0 *C.GdkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gdk_window_set_keep_above(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetKeepBelow: set if window must be kept below other windows. If the window
// was already below, then this function does nothing.
//
// On X11, asks the window manager to keep window below, if the window manager
// supports this operation. Not all window managers support this, and some
// deliberately ignore it or don’t have a concept of “keep below”; so you can’t
// rely on the window being kept below. But it will happen with most standard
// window managers, and GDK makes a best effort to get it to happen.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window below other windows.
//
func (window *Window) SetKeepBelow(setting bool) {
	var _arg0 *C.GdkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gdk_window_set_keep_below(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

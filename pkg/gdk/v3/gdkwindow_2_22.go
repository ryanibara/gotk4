// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
import "C"

// CoordsFromParent transforms window coordinates from a parent window to a
// child window, where the parent window is the normal parent as returned by
// gdk_window_get_parent() for normal windows, and the window's embedder as
// returned by gdk_offscreen_window_get_embedder() for offscreen windows.
//
// For normal windows, calling this function is equivalent to subtracting the
// return values of gdk_window_get_position() from the parent coordinates. For
// offscreen windows however (which can be arbitrarily transformed), this
// function calls the GdkWindow::from-embedder: signal to translate the
// coordinates.
//
// You should always use this function when writing generic code that walks down
// a window hierarchy.
//
// See also: gdk_window_coords_to_parent().
//
// The function takes the following parameters:
//
//    - parentX: x coordinate in parent’s coordinate system.
//    - parentY: y coordinate in parent’s coordinate system.
//
// The function returns the following values:
//
//    - x (optional): return location for X coordinate in child’s coordinate
//      system.
//    - y (optional): return location for Y coordinate in child’s coordinate
//      system.
//
func (window *Window) CoordsFromParent(parentX, parentY float64) (x, y float64) {
	var _arg0 *C.GdkWindow // out
	var _arg1 C.gdouble    // out
	var _arg2 C.gdouble    // out
	var _arg3 C.gdouble    // in
	var _arg4 C.gdouble    // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gdouble(parentX)
	_arg2 = C.gdouble(parentY)

	C.gdk_window_coords_from_parent(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(window)
	runtime.KeepAlive(parentX)
	runtime.KeepAlive(parentY)

	var _x float64 // out
	var _y float64 // out

	_x = float64(_arg3)
	_y = float64(_arg4)

	return _x, _y
}

// CoordsToParent transforms window coordinates from a child window to its
// parent window, where the parent window is the normal parent as returned by
// gdk_window_get_parent() for normal windows, and the window's embedder as
// returned by gdk_offscreen_window_get_embedder() for offscreen windows.
//
// For normal windows, calling this function is equivalent to adding the return
// values of gdk_window_get_position() to the child coordinates. For offscreen
// windows however (which can be arbitrarily transformed), this function calls
// the GdkWindow::to-embedder: signal to translate the coordinates.
//
// You should always use this function when writing generic code that walks up a
// window hierarchy.
//
// See also: gdk_window_coords_from_parent().
//
// The function takes the following parameters:
//
//    - x: x coordinate in child’s coordinate system.
//    - y: y coordinate in child’s coordinate system.
//
// The function returns the following values:
//
//    - parentX (optional): return location for X coordinate in parent’s
//      coordinate system, or NULL.
//    - parentY (optional): return location for Y coordinate in parent’s
//      coordinate system, or NULL.
//
func (window *Window) CoordsToParent(x, y float64) (parentX, parentY float64) {
	var _arg0 *C.GdkWindow // out
	var _arg1 C.gdouble    // out
	var _arg2 C.gdouble    // out
	var _arg3 C.gdouble    // in
	var _arg4 C.gdouble    // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gdouble(x)
	_arg2 = C.gdouble(y)

	C.gdk_window_coords_to_parent(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(window)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _parentX float64 // out
	var _parentY float64 // out

	_parentX = float64(_arg3)
	_parentY = float64(_arg4)

	return _parentX, _parentY
}

// CreateSimilarSurface: create a new surface that is as compatible as possible
// with the given window. For example the new surface will have the same
// fallback resolution and font options as window. Generally, the new surface
// will also use the same backend as window, unless that is not possible for
// some reason. The type of the returned surface may be examined with
// cairo_surface_get_type().
//
// Initially the surface contents are all 0 (transparent if contents have
// transparency, black otherwise.).
//
// The function takes the following parameters:
//
//    - content for the new surface.
//    - width of the new surface.
//    - height of the new surface.
//
// The function returns the following values:
//
//    - surface: pointer to the newly allocated surface. The caller owns the
//      surface and should call cairo_surface_destroy() when done with it.
//
//      This function always returns a valid pointer, but it will return a
//      pointer to a “nil” surface if other is already in an error state or any
//      other error occurs.
//
func (window *Window) CreateSimilarSurface(content cairo.Content, width, height int) *cairo.Surface {
	var _arg0 *C.GdkWindow       // out
	var _arg1 C.cairo_content_t  // out
	var _arg2 C.int              // out
	var _arg3 C.int              // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.cairo_content_t(content)
	_arg2 = C.int(width)
	_arg3 = C.int(height)

	_cret = C.gdk_window_create_similar_surface(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(window)
	runtime.KeepAlive(content)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// AcceptFocus determines whether or not the desktop environment shuld be hinted
// that the window does not want to receive input focus.
//
// The function returns the following values:
//
//    - ok: whether or not the window should receive input focus.
//
func (window *Window) AcceptFocus() bool {
	var _arg0 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_accept_focus(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackgroundPattern gets the pattern used to clear the background on window.
//
// Deprecated: Don't use this function.
//
// The function returns the following values:
//
//    - pattern (optional) to use for the background or NULL if there is no
//      background.
//
func (window *Window) BackgroundPattern() *cairo.Pattern {
	var _arg0 *C.GdkWindow       // out
	var _cret *C.cairo_pattern_t // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_background_pattern(_arg0)
	runtime.KeepAlive(window)

	var _pattern *cairo.Pattern // out

	if _cret != nil {
		{
			_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
			_pattern = (*cairo.Pattern)(unsafe.Pointer(_pp))
		}
		C.cairo_pattern_reference(_cret)
		runtime.SetFinalizer(_pattern, func(v *cairo.Pattern) {
			C.cairo_pattern_destroy((*C.cairo_pattern_t)(unsafe.Pointer(v.Native())))
		})
	}

	return _pattern
}

// Composited determines whether window is composited.
//
// See gdk_window_set_composited().
//
// Deprecated: Compositing is an outdated technology that only ever worked on
// X11.
//
// The function returns the following values:
//
//    - ok: TRUE if the window is composited.
//
func (window *Window) Composited() bool {
	var _arg0 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_composited(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EffectiveParent obtains the parent of window, as known to GDK. Works like
// gdk_window_get_parent() for normal windows, but returns the window’s embedder
// for offscreen windows.
//
// See also: gdk_offscreen_window_get_embedder().
//
// The function returns the following values:
//
//    - ret: effective parent of window.
//
func (window *Window) EffectiveParent() Windower {
	var _arg0 *C.GdkWindow // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_effective_parent(_arg0)
	runtime.KeepAlive(window)

	var _ret Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_ret = rv
	}

	return _ret
}

// EffectiveToplevel gets the toplevel window that’s an ancestor of window.
//
// Works like gdk_window_get_toplevel(), but treats an offscreen window's
// embedder as its parent, using gdk_window_get_effective_parent().
//
// See also: gdk_offscreen_window_get_embedder().
//
// The function returns the following values:
//
//    - ret: effective toplevel window containing window.
//
func (window *Window) EffectiveToplevel() Windower {
	var _arg0 *C.GdkWindow // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_effective_toplevel(_arg0)
	runtime.KeepAlive(window)

	var _ret Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_ret = rv
	}

	return _ret
}

// FocusOnMap determines whether or not the desktop environment should be hinted
// that the window does not want to receive input focus when it is mapped.
//
// The function returns the following values:
//
//    - ok: whether or not the window wants to receive input focus when it is
//      mapped.
//
func (window *Window) FocusOnMap() bool {
	var _arg0 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_focus_on_map(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModalHint determines whether or not the window manager is hinted that window
// has modal behaviour.
//
// The function returns the following values:
//
//    - ok: whether or not the window has the modal hint set.
//
func (window *Window) ModalHint() bool {
	var _arg0 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_get_modal_hint(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasNative checks whether the window has a native window or not. Note that you
// can use gdk_window_ensure_native() if a native window is needed.
//
// The function returns the following values:
//
//    - ok: TRUE if the window has a native window, FALSE otherwise.
//
func (window *Window) HasNative() bool {
	var _arg0 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_has_native(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsInputOnly determines whether or not the window is an input only window.
//
// The function returns the following values:
//
//    - ok: TRUE if window is input only.
//
func (window *Window) IsInputOnly() bool {
	var _arg0 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_is_input_only(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsShaped determines whether or not the window is shaped.
//
// The function returns the following values:
//
//    - ok: TRUE if window is shaped.
//
func (window *Window) IsShaped() bool {
	var _arg0 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gdk_window_is_shaped(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gdk3_Keymap_ConnectDirectionChanged(gpointer, guintptr);
// extern void _gotk4_gdk3_Keymap_ConnectKeysChanged(gpointer, guintptr);
// extern void _gotk4_gdk3_Keymap_ConnectStateChanged(gpointer, guintptr);
import "C"

// GTypeKeymap returns the GType for the type Keymap.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeKeymap() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "Keymap").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalKeymap)
	return gtype
}

// KeyvalConvertCase obtains the upper- and lower-case versions of the keyval
// symbol. Examples of keyvals are K_KEY_a, K_KEY_Enter, K_KEY_F1, etc.
//
// The function takes the following parameters:
//
//    - symbol: keyval.
//
// The function returns the following values:
//
//    - lower: return location for lowercase version of symbol.
//    - upper: return location for uppercase version of symbol.
//
func KeyvalConvertCase(symbol uint32) (lower, upper uint32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(symbol)

	girepository.MustFind("Gdk", "keyval_convert_case").Invoke(_args[:], _outs[:])

	runtime.KeepAlive(symbol)

	var _lower uint32 // out
	var _upper uint32 // out

	_lower = *(*uint32)(unsafe.Pointer(_outs[0]))
	_upper = *(*uint32)(unsafe.Pointer(_outs[1]))

	return _lower, _upper
}

// KeyvalFromName converts a key name to a key value.
//
// The names are the same as those in the gdk/gdkkeysyms.h header file but
// without the leading “GDK_KEY_”.
//
// The function takes the following parameters:
//
//    - keyvalName: key name.
//
// The function returns the following values:
//
//    - guint: corresponding key value, or GDK_KEY_VoidSymbol if the key name is
//      not a valid key.
//
func KeyvalFromName(keyvalName string) uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(keyvalName)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gdk", "keyval_from_name").Invoke(_args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyvalName)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// KeyvalIsLower returns TRUE if the given key value is in lower case.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - ok: TRUE if keyval is in lower case, or if keyval is not subject to case
//      conversion.
//
func KeyvalIsLower(keyval uint32) bool {
	var _args [1]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(keyval)

	_gret := girepository.MustFind("Gdk", "keyval_is_lower").Invoke(_args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalIsUpper returns TRUE if the given key value is in upper case.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - ok: TRUE if keyval is in upper case, or if keyval is not subject to case
//      conversion.
//
func KeyvalIsUpper(keyval uint32) bool {
	var _args [1]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(keyval)

	_gret := girepository.MustFind("Gdk", "keyval_is_upper").Invoke(_args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalName converts a key value into a symbolic name.
//
// The names are the same as those in the gdk/gdkkeysyms.h header file but
// without the leading “GDK_KEY_”.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the name of the key, or NULL if keyval
//      is not a valid key. The string should not be modified.
//
func KeyvalName(keyval uint32) string {
	var _args [1]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(keyval)

	_gret := girepository.MustFind("Gdk", "keyval_name").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _utf8 string // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// KeyvalToLower converts a key value to lower case, if applicable.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - guint: lower case form of keyval, or keyval itself if it is already in
//      lower case or it is not subject to case conversion.
//
func KeyvalToLower(keyval uint32) uint32 {
	var _args [1]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(keyval)

	_gret := girepository.MustFind("Gdk", "keyval_to_lower").Invoke(_args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// KeyvalToUnicode: convert from a GDK key symbol to the corresponding ISO10646
// (Unicode) character.
//
// The function takes the following parameters:
//
//    - keyval: GDK key symbol.
//
// The function returns the following values:
//
//    - guint32: corresponding unicode character, or 0 if there is no
//      corresponding character.
//
func KeyvalToUnicode(keyval uint32) uint32 {
	var _args [1]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(keyval)

	_gret := girepository.MustFind("Gdk", "keyval_to_unicode").Invoke(_args[:], nil)
	_cret = *(*C.guint32)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _guint32 uint32 // out

	_guint32 = uint32(*(*C.guint32)(unsafe.Pointer(&_cret)))

	return _guint32
}

// KeyvalToUpper converts a key value to upper case, if applicable.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - guint: upper case form of keyval, or keyval itself if it is already in
//      upper case or it is not subject to case conversion.
//
func KeyvalToUpper(keyval uint32) uint32 {
	var _args [1]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(keyval)

	_gret := girepository.MustFind("Gdk", "keyval_to_upper").Invoke(_args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// UnicodeToKeyval: convert from a ISO10646 character to a key symbol.
//
// The function takes the following parameters:
//
//    - wc: ISO10646 encoded character.
//
// The function returns the following values:
//
//    - guint: corresponding GDK key symbol, if one exists. or, if there is no
//      corresponding symbol, wc | 0x01000000.
//
func UnicodeToKeyval(wc uint32) uint32 {
	var _args [1]girepository.Argument

	*(*C.guint32)(unsafe.Pointer(&_args[0])) = C.guint32(wc)

	_gret := girepository.MustFind("Gdk", "unicode_to_keyval").Invoke(_args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(wc)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Keymap defines the translation from keyboard state (including a hardware key,
// a modifier mask, and active keyboard group) to a keyval. This translation has
// two phases. The first phase is to determine the effective keyboard group and
// level for the keyboard state; the second phase is to look up the
// keycode/group/level triplet in the keymap and see what keyval it corresponds
// to.
type Keymap struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Keymap)(nil)
)

func wrapKeymap(obj *coreglib.Object) *Keymap {
	return &Keymap{
		Object: obj,
	}
}

func marshalKeymap(p uintptr) (interface{}, error) {
	return wrapKeymap(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gdk3_Keymap_ConnectDirectionChanged
func _gotk4_gdk3_Keymap_ConnectDirectionChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectDirectionChanged signal gets emitted when the direction of the keymap
// changes.
func (keymap *Keymap) ConnectDirectionChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(keymap, "direction-changed", false, unsafe.Pointer(C._gotk4_gdk3_Keymap_ConnectDirectionChanged), f)
}

//export _gotk4_gdk3_Keymap_ConnectKeysChanged
func _gotk4_gdk3_Keymap_ConnectKeysChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectKeysChanged signal is emitted when the mapping represented by keymap
// changes.
func (keymap *Keymap) ConnectKeysChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(keymap, "keys-changed", false, unsafe.Pointer(C._gotk4_gdk3_Keymap_ConnectKeysChanged), f)
}

//export _gotk4_gdk3_Keymap_ConnectStateChanged
func _gotk4_gdk3_Keymap_ConnectStateChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectStateChanged signal is emitted when the state of the keyboard changes,
// e.g when Caps Lock is turned on or off. See gdk_keymap_get_caps_lock_state().
func (keymap *Keymap) ConnectStateChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(keymap, "state-changed", false, unsafe.Pointer(C._gotk4_gdk3_Keymap_ConnectStateChanged), f)
}

// CapsLockState returns whether the Caps Lock modifer is locked.
//
// The function returns the following values:
//
//    - ok: TRUE if Caps Lock is on.
//
func (keymap *Keymap) CapsLockState() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_caps_lock_state", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// EntriesForKeycode returns the keyvals bound to hardware_keycode. The Nth
// KeymapKey in keys is bound to the Nth keyval in keyvals. Free the returned
// arrays with g_free(). When a keycode is pressed by the user, the keyval from
// this list of entries is selected by considering the effective keyboard group
// and level. See gdk_keymap_translate_keyboard_state().
//
// The function takes the following parameters:
//
//    - hardwareKeycode: keycode.
//
// The function returns the following values:
//
//    - keys (optional): return location for array of KeymapKey, or NULL.
//    - keyvals (optional): return location for array of keyvals, or NULL.
//    - ok: TRUE if there were any entries.
//
func (keymap *Keymap) EntriesForKeycode(hardwareKeycode uint32) ([]KeymapKey, []uint32, bool) {
	var _args [2]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(hardwareKeycode)

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_entries_for_keycode", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)
	runtime.KeepAlive(hardwareKeycode)

	var _keys []KeymapKey // out
	var _keyvals []uint32 // out
	var _ok bool          // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		defer C.free(unsafe.Pointer(_outs[0]))
		{
			src := unsafe.Slice((**C.void)(_outs[0]), _outs[2])
			_keys = make([]KeymapKey, _outs[2])
			for i := 0; i < int(_outs[2]); i++ {
				_keys[i] = *(*KeymapKey)(gextras.NewStructNative(unsafe.Pointer(src[i])))
				runtime.SetFinalizer(
					gextras.StructIntern(unsafe.Pointer(&_keys[i])),
					func(intern *struct{ C unsafe.Pointer }) {
						C.free(intern.C)
					},
				)
			}
		}
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		defer C.free(unsafe.Pointer(_outs[1]))
		{
			src := unsafe.Slice((**C.void)(_outs[1]), _outs[2])
			_keyvals = make([]uint32, _outs[2])
			for i := 0; i < int(_outs[2]); i++ {
				_keyvals[i] = *(*uint32)(unsafe.Pointer(src[i]))
			}
		}
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _keys, _keyvals, _ok
}

// EntriesForKeyval obtains a list of keycode/group/level combinations that will
// generate keyval. Groups and levels are two kinds of keyboard mode; in
// general, the level determines whether the top or bottom symbol on a key is
// used, and the group determines whether the left or right symbol is used. On
// US keyboards, the shift key changes the keyboard level, and there are no
// groups. A group switch key might convert a keyboard between Hebrew to English
// modes, for example. EventKey contains a group field that indicates the active
// keyboard group. The level is computed from the modifier mask. The returned
// array should be freed with g_free().
//
// The function takes the following parameters:
//
//    - keyval: keyval, such as GDK_KEY_a, GDK_KEY_Up, GDK_KEY_Return, etc.
//
// The function returns the following values:
//
//    - keys: return location for an array of KeymapKey.
//    - ok: TRUE if keys were found and returned.
//
func (keymap *Keymap) EntriesForKeyval(keyval uint32) ([]KeymapKey, bool) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(keyval)

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_entries_for_keyval", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)
	runtime.KeepAlive(keyval)

	var _keys []KeymapKey // out
	var _ok bool          // out

	defer C.free(unsafe.Pointer(_outs[0]))
	{
		src := unsafe.Slice((**C.void)(_outs[0]), _outs[1])
		_keys = make([]KeymapKey, _outs[1])
		for i := 0; i < int(_outs[1]); i++ {
			_keys[i] = *(*KeymapKey)(gextras.NewStructNative(unsafe.Pointer(src[i])))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(&_keys[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.free(intern.C)
				},
			)
		}
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _keys, _ok
}

// ModifierState returns the current modifier state.
//
// The function returns the following values:
//
//    - guint: current modifier state.
//
func (keymap *Keymap) ModifierState() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_modifier_state", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// NumLockState returns whether the Num Lock modifer is locked.
//
// The function returns the following values:
//
//    - ok: TRUE if Num Lock is on.
//
func (keymap *Keymap) NumLockState() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_num_lock_state", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ScrollLockState returns whether the Scroll Lock modifer is locked.
//
// The function returns the following values:
//
//    - ok: TRUE if Scroll Lock is on.
//
func (keymap *Keymap) ScrollLockState() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_scroll_lock_state", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// HaveBidiLayouts determines if keyboard layouts for both right-to-left and
// left-to-right languages are in use.
//
// The function returns the following values:
//
//    - ok: TRUE if there are layouts in both directions, FALSE otherwise.
//
func (keymap *Keymap) HaveBidiLayouts() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("have_bidi_layouts", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// LookupKey looks up the keyval mapped to a keycode/group/level triplet. If no
// keyval is bound to key, returns 0. For normal user input, you want to use
// gdk_keymap_translate_keyboard_state() instead of this function, since the
// effective group/level may not be the same as the current keyboard state.
//
// The function takes the following parameters:
//
//    - key with keycode, group, and level initialized.
//
// The function returns the following values:
//
//    - guint: keyval, or 0 if none was mapped to the given key.
//
func (keymap *Keymap) LookupKey(key *KeymapKey) uint32 {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(key)))

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("lookup_key", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)
	runtime.KeepAlive(key)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// KeymapGetDefault returns the Keymap attached to the default display.
//
// Deprecated: Use gdk_keymap_get_for_display() instead.
//
// The function returns the following values:
//
//    - keymap attached to the default display.
//
func KeymapGetDefault() *Keymap {
	_gret := girepository.MustFind("Gdk", "get_default").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _keymap *Keymap // out

	_keymap = wrapKeymap(coreglib.Take(unsafe.Pointer(_cret)))

	return _keymap
}

// KeymapGetForDisplay returns the Keymap attached to display.
//
// The function takes the following parameters:
//
//    - display: Display.
//
// The function returns the following values:
//
//    - keymap attached to display.
//
func KeymapGetForDisplay(display *Display) *Keymap {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "get_for_display").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _keymap *Keymap // out

	_keymap = wrapKeymap(coreglib.Take(unsafe.Pointer(_cret)))

	return _keymap
}

// KeymapKey is a hardware key that can be mapped to a keyval.
//
// An instance of this type is always passed by reference.
type KeymapKey struct {
	*keymapKey
}

// keymapKey is the struct that's finalized.
type keymapKey struct {
	native unsafe.Pointer
}

// NewKeymapKey creates a new KeymapKey instance from the given
// fields.
func NewKeymapKey(keycode uint32, group, level int32) KeymapKey {
	var f0 C.guint // out
	f0 = C.guint(keycode)
	var f1 C.gint // out
	f1 = C.gint(group)
	var f2 C.gint // out
	f2 = C.gint(level)

	v := C.GdkKeymapKey{
		keycode: f0,
		group:   f1,
		level:   f2,
	}

	return *(*KeymapKey)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Keycode: hardware keycode. This is an identifying number for a physical key.
func (k *KeymapKey) Keycode() uint32 {
	offset := girepository.MustFind("Gdk", "KeymapKey").StructFieldOffset("keycode")
	valptr := unsafe.Add(unsafe.Pointer(k), offset)
	var v uint32 // out
	v = uint32(*(*C.guint)(unsafe.Pointer(&valptr)))
	return v
}

// Group indicates movement in a horizontal direction. Usually groups are used
// for two different languages. In group 0, a key might have two English
// characters, and in group 1 it might have two Hebrew characters. The Hebrew
// characters will be printed on the key next to the English characters.
func (k *KeymapKey) Group() int32 {
	offset := girepository.MustFind("Gdk", "KeymapKey").StructFieldOffset("group")
	valptr := unsafe.Add(unsafe.Pointer(k), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

// Level indicates which symbol on the key will be used, in a vertical
// direction. So on a standard US keyboard, the key with the number “1” on it
// also has the exclamation point ("!") character on it. The level indicates
// whether to use the “1” or the “!” symbol. The letter keys are considered to
// have a lowercase letter at level 0, and an uppercase letter at level 1,
// though only the uppercase letter is printed.
func (k *KeymapKey) Level() int32 {
	offset := girepository.MustFind("Gdk", "KeymapKey").StructFieldOffset("level")
	valptr := unsafe.Add(unsafe.Pointer(k), offset)
	var v int32 // out
	v = int32(*(*C.gint)(unsafe.Pointer(&valptr)))
	return v
}

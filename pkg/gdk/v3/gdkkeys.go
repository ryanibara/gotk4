// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gdk3_Keymap_ConnectDirectionChanged(gpointer, guintptr);
// extern void _gotk4_gdk3_Keymap_ConnectKeysChanged(gpointer, guintptr);
// extern void _gotk4_gdk3_Keymap_ConnectStateChanged(gpointer, guintptr);
import "C"

// glib.Type values for gdkkeys.go.
var GTypeKeymap = coreglib.Type(C.gdk_keymap_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeKeymap, F: marshalKeymap},
	})
}

// KeyvalFromName converts a key name to a key value.
//
// The names are the same as those in the gdk/gdkkeysyms.h header file but
// without the leading “GDK_KEY_”.
//
// The function takes the following parameters:
//
//    - keyvalName: key name.
//
// The function returns the following values:
//
//    - guint: corresponding key value, or GDK_KEY_VoidSymbol if the key name is
//      not a valid key.
//
func KeyvalFromName(keyvalName string) uint {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.guint // in

	_arg0 = (*C.void)(unsafe.Pointer(C.CString(keyvalName)))
	defer C.free(unsafe.Pointer(_arg0))
	*(*string)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "keyval_from_name").Invoke(args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyvalName)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeyvalIsLower returns TRUE if the given key value is in lower case.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - ok: TRUE if keyval is in lower case, or if keyval is not subject to case
//      conversion.
//
func KeyvalIsLower(keyval uint) bool {
	var args [1]girepository.Argument
	var _arg0 C.guint    // out
	var _cret C.gboolean // in

	_arg0 = C.guint(keyval)
	*(*uint)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "keyval_is_lower").Invoke(args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalIsUpper returns TRUE if the given key value is in upper case.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - ok: TRUE if keyval is in upper case, or if keyval is not subject to case
//      conversion.
//
func KeyvalIsUpper(keyval uint) bool {
	var args [1]girepository.Argument
	var _arg0 C.guint    // out
	var _cret C.gboolean // in

	_arg0 = C.guint(keyval)
	*(*uint)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "keyval_is_upper").Invoke(args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeyvalName converts a key value into a symbolic name.
//
// The names are the same as those in the gdk/gdkkeysyms.h header file but
// without the leading “GDK_KEY_”.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - utf8 (optional): string containing the name of the key, or NULL if keyval
//      is not a valid key. The string should not be modified.
//
func KeyvalName(keyval uint) string {
	var args [1]girepository.Argument
	var _arg0 C.guint // out
	var _cret *C.void // in

	_arg0 = C.guint(keyval)
	*(*uint)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "keyval_name").Invoke(args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// KeyvalToLower converts a key value to lower case, if applicable.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - guint: lower case form of keyval, or keyval itself if it is already in
//      lower case or it is not subject to case conversion.
//
func KeyvalToLower(keyval uint) uint {
	var args [1]girepository.Argument
	var _arg0 C.guint // out
	var _cret C.guint // in

	_arg0 = C.guint(keyval)
	*(*uint)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "keyval_to_lower").Invoke(args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeyvalToUnicode: convert from a GDK key symbol to the corresponding ISO10646
// (Unicode) character.
//
// The function takes the following parameters:
//
//    - keyval: GDK key symbol.
//
// The function returns the following values:
//
//    - guint32: corresponding unicode character, or 0 if there is no
//      corresponding character.
//
func KeyvalToUnicode(keyval uint) uint32 {
	var args [1]girepository.Argument
	var _arg0 C.guint   // out
	var _cret C.guint32 // in

	_arg0 = C.guint(keyval)
	*(*uint)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "keyval_to_unicode").Invoke(args[:], nil)
	_cret = *(*C.guint32)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// KeyvalToUpper converts a key value to upper case, if applicable.
//
// The function takes the following parameters:
//
//    - keyval: key value.
//
// The function returns the following values:
//
//    - guint: upper case form of keyval, or keyval itself if it is already in
//      upper case or it is not subject to case conversion.
//
func KeyvalToUpper(keyval uint) uint {
	var args [1]girepository.Argument
	var _arg0 C.guint // out
	var _cret C.guint // in

	_arg0 = C.guint(keyval)
	*(*uint)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "keyval_to_upper").Invoke(args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keyval)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// UnicodeToKeyval: convert from a ISO10646 character to a key symbol.
//
// The function takes the following parameters:
//
//    - wc: ISO10646 encoded character.
//
// The function returns the following values:
//
//    - guint: corresponding GDK key symbol, if one exists. or, if there is no
//      corresponding symbol, wc | 0x01000000.
//
func UnicodeToKeyval(wc uint32) uint {
	var args [1]girepository.Argument
	var _arg0 C.guint32 // out
	var _cret C.guint   // in

	_arg0 = C.guint32(wc)
	*(*uint32)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "unicode_to_keyval").Invoke(args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(wc)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Keymap defines the translation from keyboard state (including a hardware key,
// a modifier mask, and active keyboard group) to a keyval. This translation has
// two phases. The first phase is to determine the effective keyboard group and
// level for the keyboard state; the second phase is to look up the
// keycode/group/level triplet in the keymap and see what keyval it corresponds
// to.
type Keymap struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Keymap)(nil)
)

func wrapKeymap(obj *coreglib.Object) *Keymap {
	return &Keymap{
		Object: obj,
	}
}

func marshalKeymap(p uintptr) (interface{}, error) {
	return wrapKeymap(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gdk3_Keymap_ConnectDirectionChanged
func _gotk4_gdk3_Keymap_ConnectDirectionChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectDirectionChanged signal gets emitted when the direction of the keymap
// changes.
func (keymap *Keymap) ConnectDirectionChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(keymap, "direction-changed", false, unsafe.Pointer(C._gotk4_gdk3_Keymap_ConnectDirectionChanged), f)
}

//export _gotk4_gdk3_Keymap_ConnectKeysChanged
func _gotk4_gdk3_Keymap_ConnectKeysChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectKeysChanged signal is emitted when the mapping represented by keymap
// changes.
func (keymap *Keymap) ConnectKeysChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(keymap, "keys-changed", false, unsafe.Pointer(C._gotk4_gdk3_Keymap_ConnectKeysChanged), f)
}

//export _gotk4_gdk3_Keymap_ConnectStateChanged
func _gotk4_gdk3_Keymap_ConnectStateChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectStateChanged signal is emitted when the state of the keyboard changes,
// e.g when Caps Lock is turned on or off. See gdk_keymap_get_caps_lock_state().
func (keymap *Keymap) ConnectStateChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(keymap, "state-changed", false, unsafe.Pointer(C._gotk4_gdk3_Keymap_ConnectStateChanged), f)
}

// CapsLockState returns whether the Caps Lock modifer is locked.
//
// The function returns the following values:
//
//    - ok: TRUE if Caps Lock is on.
//
func (keymap *Keymap) CapsLockState() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	*(**Keymap)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_caps_lock_state", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ModifierState returns the current modifier state.
//
// The function returns the following values:
//
//    - guint: current modifier state.
//
func (keymap *Keymap) ModifierState() uint {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.guint // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	*(**Keymap)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_modifier_state", args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NumLockState returns whether the Num Lock modifer is locked.
//
// The function returns the following values:
//
//    - ok: TRUE if Num Lock is on.
//
func (keymap *Keymap) NumLockState() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	*(**Keymap)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_num_lock_state", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollLockState returns whether the Scroll Lock modifer is locked.
//
// The function returns the following values:
//
//    - ok: TRUE if Scroll Lock is on.
//
func (keymap *Keymap) ScrollLockState() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	*(**Keymap)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("get_scroll_lock_state", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HaveBidiLayouts determines if keyboard layouts for both right-to-left and
// left-to-right languages are in use.
//
// The function returns the following values:
//
//    - ok: TRUE if there are layouts in both directions, FALSE otherwise.
//
func (keymap *Keymap) HaveBidiLayouts() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	*(**Keymap)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("have_bidi_layouts", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupKey looks up the keyval mapped to a keycode/group/level triplet. If no
// keyval is bound to key, returns 0. For normal user input, you want to use
// gdk_keymap_translate_keyboard_state() instead of this function, since the
// effective group/level may not be the same as the current keyboard state.
//
// The function takes the following parameters:
//
//    - key with keycode, group, and level initialized.
//
// The function returns the following values:
//
//    - guint: keyval, or 0 if none was mapped to the given key.
//
func (keymap *Keymap) LookupKey(key *KeymapKey) uint {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret C.guint // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(keymap).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(key)))
	*(**Keymap)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gdk", "Keymap").InvokeMethod("lookup_key", args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(keymap)
	runtime.KeepAlive(key)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// KeymapGetDefault returns the Keymap attached to the default display.
//
// Deprecated: Use gdk_keymap_get_for_display() instead.
//
// The function returns the following values:
//
//    - keymap attached to the default display.
//
func KeymapGetDefault() *Keymap {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gdk", "get_default").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _keymap *Keymap // out

	_keymap = wrapKeymap(coreglib.Take(unsafe.Pointer(_cret)))

	return _keymap
}

// KeymapGetForDisplay returns the Keymap attached to display.
//
// The function takes the following parameters:
//
//    - display: Display.
//
// The function returns the following values:
//
//    - keymap attached to display.
//
func KeymapGetForDisplay(display *Display) *Keymap {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(**Display)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "get_for_display").Invoke(args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _keymap *Keymap // out

	_keymap = wrapKeymap(coreglib.Take(unsafe.Pointer(_cret)))

	return _keymap
}

// KeymapKey is a hardware key that can be mapped to a keyval.
//
// An instance of this type is always passed by reference.
type KeymapKey struct {
	*keymapKey
}

// keymapKey is the struct that's finalized.
type keymapKey struct {
	native *C.GdkKeymapKey
}

// NewKeymapKey creates a new KeymapKey instance from the given
// fields.
func NewKeymapKey(keycode uint, group, level int) KeymapKey {
	var f0 C.guint // out
	f0 = C.guint(keycode)
	var f1 C.gint // out
	f1 = C.gint(group)
	var f2 C.gint // out
	f2 = C.gint(level)

	v := C.GdkKeymapKey{
		keycode: f0,
		group:   f1,
		level:   f2,
	}

	return *(*KeymapKey)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Keycode: hardware keycode. This is an identifying number for a physical key.
func (k *KeymapKey) Keycode() uint {
	var v uint // out
	v = uint(k.native.keycode)
	return v
}

// Group indicates movement in a horizontal direction. Usually groups are used
// for two different languages. In group 0, a key might have two English
// characters, and in group 1 it might have two Hebrew characters. The Hebrew
// characters will be printed on the key next to the English characters.
func (k *KeymapKey) Group() int {
	var v int // out
	v = int(k.native.group)
	return v
}

// Level indicates which symbol on the key will be used, in a vertical
// direction. So on a standard US keyboard, the key with the number “1” on it
// also has the exclamation point ("!") character on it. The level indicates
// whether to use the “1” or the “!” symbol. The letter keys are considered to
// have a lowercase letter at level 0, and an uppercase letter at level 1,
// though only the uppercase letter is printed.
func (k *KeymapKey) Level() int {
	var v int // out
	v = int(k.native.level)
	return v
}

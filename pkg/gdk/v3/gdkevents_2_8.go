// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
import "C"

// EventGrabBroken: generated when a pointer or keyboard grab is broken. On X11,
// this happens when the grab window becomes unviewable (i.e. it or one of its
// ancestors is unmapped), or if the same application grabs the pointer or
// keyboard again. Note that implicit grabs (which are initiated by button
// presses) can also cause EventGrabBroken events.
//
// An instance of this type is always passed by reference.
type EventGrabBroken struct {
	*eventGrabBroken
}

// eventGrabBroken is the struct that's finalized.
type eventGrabBroken struct {
	native *C.GdkEventGrabBroken
}

// Type: type of the event (GDK_GRAB_BROKEN).
func (e *EventGrabBroken) Type() EventType {
	valptr := &e.native._type
	var _v EventType // out
	_v = EventType(*valptr)
	return _v
}

// Window: window which received the event, i.e. the window that previously
// owned the grab.
func (e *EventGrabBroken) Window() Windower {
	valptr := &e.native.window
	var _v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_v = rv
	}
	return _v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventGrabBroken) SendEvent() int8 {
	valptr := &e.native.send_event
	var _v int8 // out
	_v = int8(*valptr)
	return _v
}

// Keyboard: TRUE if a keyboard grab was broken, FALSE if a pointer grab was
// broken.
func (e *EventGrabBroken) Keyboard() bool {
	valptr := &e.native.keyboard
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// Implicit: TRUE if the broken grab was implicit.
func (e *EventGrabBroken) Implicit() bool {
	valptr := &e.native.implicit
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// GrabWindow: if this event is caused by another grab in the same application,
// grab_window contains the new grab window. Otherwise grab_window is NULL.
func (e *EventGrabBroken) GrabWindow() Windower {
	valptr := &e.native.grab_window
	var _v Windower // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_v = rv
	}
	return _v
}

// SendEvent: TRUE if the event was sent explicitly.
func (e *EventGrabBroken) SetSendEvent(sendEvent int8) {
	valptr := &e.native.send_event
	*valptr = C.gint8(sendEvent)
}

// Keyboard: TRUE if a keyboard grab was broken, FALSE if a pointer grab was
// broken.
func (e *EventGrabBroken) SetKeyboard(keyboard bool) {
	valptr := &e.native.keyboard
	if keyboard {
		*valptr = C.TRUE
	}
}

// Implicit: TRUE if the broken grab was implicit.
func (e *EventGrabBroken) SetImplicit(implicit bool) {
	valptr := &e.native.implicit
	if implicit {
		*valptr = C.TRUE
	}
}

// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
import "C"

// AssociatedDevice returns the associated device to device, if device is of
// type GDK_DEVICE_TYPE_MASTER, it will return the paired pointer or keyboard.
//
// If device is of type GDK_DEVICE_TYPE_SLAVE, it will return the master device
// to which device is attached to.
//
// If device is of type GDK_DEVICE_TYPE_FLOATING, NULL will be returned, as
// there is no associated device.
//
// The function returns the following values:
//
//    - ret (optional): associated device, or NULL.
//
func (device *Device) AssociatedDevice() Devicer {
	var _arg0 *C.GdkDevice // out
	var _cret *C.GdkDevice // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_associated_device(_arg0)
	runtime.KeepAlive(device)

	var _ret Devicer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			_ret = rv
		}
	}

	return _ret
}

// DeviceType returns the device type for device.
//
// The function returns the following values:
//
//    - deviceType for device.
//
func (device *Device) DeviceType() DeviceType {
	var _arg0 *C.GdkDevice    // out
	var _cret C.GdkDeviceType // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_device_type(_arg0)
	runtime.KeepAlive(device)

	var _deviceType DeviceType // out

	_deviceType = DeviceType(_cret)

	return _deviceType
}

// Display returns the Display to which device pertains.
//
// The function returns the following values:
//
//    - display This memory is owned by GTK+, and must not be freed or unreffed.
//
func (device *Device) Display() *Display {
	var _arg0 *C.GdkDevice  // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_display(_arg0)
	runtime.KeepAlive(device)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// NAxes returns the number of axes the device currently has.
//
// The function returns the following values:
//
//    - gint: number of axes.
//
func (device *Device) NAxes() int {
	var _arg0 *C.GdkDevice // out
	var _cret C.gint       // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_n_axes(_arg0)
	runtime.KeepAlive(device)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Position gets the current location of device. As a slave device coordinates
// are those of its master pointer, This function may not be called on devices
// of type GDK_DEVICE_TYPE_SLAVE, unless there is an ongoing grab on them, see
// gdk_device_grab().
//
// The function returns the following values:
//
//    - screen (optional): location to store the Screen the device is on, or
//      NULL.
//    - x (optional): location to store root window X coordinate of device, or
//      NULL.
//    - y (optional): location to store root window Y coordinate of device, or
//      NULL.
//
func (device *Device) Position() (screen *Screen, x, y int) {
	var _arg0 *C.GdkDevice // out
	var _arg1 *C.GdkScreen // in
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	C.gdk_device_get_position(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(device)

	var _screen *Screen // out
	var _x int          // out
	var _y int          // out

	if _arg1 != nil {
		_screen = wrapScreen(coreglib.Take(unsafe.Pointer(_arg1)))
	}
	_x = int(_arg2)
	_y = int(_arg3)

	return _screen, _x, _y
}

// WindowAtPosition obtains the window underneath device, returning the location
// of the device in win_x and win_y. Returns NULL if the window tree under
// device is not known to GDK (for example, belongs to another application).
//
// As a slave device coordinates are those of its master pointer, This function
// may not be called on devices of type GDK_DEVICE_TYPE_SLAVE, unless there is
// an ongoing grab on them, see gdk_device_grab().
//
// The function returns the following values:
//
//    - winX (optional): return location for the X coordinate of the device
//      location, relative to the window origin, or NULL.
//    - winY (optional): return location for the Y coordinate of the device
//      location, relative to the window origin, or NULL.
//    - window (optional) under the device position, or NULL.
//
func (device *Device) WindowAtPosition() (winX, winY int, window Windower) {
	var _arg0 *C.GdkDevice // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_window_at_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(device)

	var _winX int        // out
	var _winY int        // out
	var _window Windower // out

	_winX = int(_arg1)
	_winY = int(_arg2)
	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _winX, _winY, _window
}

// WindowAtPositionDouble obtains the window underneath device, returning the
// location of the device in win_x and win_y in double precision. Returns NULL
// if the window tree under device is not known to GDK (for example, belongs to
// another application).
//
// As a slave device coordinates are those of its master pointer, This function
// may not be called on devices of type GDK_DEVICE_TYPE_SLAVE, unless there is
// an ongoing grab on them, see gdk_device_grab().
//
// The function returns the following values:
//
//    - winX (optional): return location for the X coordinate of the device
//      location, relative to the window origin, or NULL.
//    - winY (optional): return location for the Y coordinate of the device
//      location, relative to the window origin, or NULL.
//    - window (optional) under the device position, or NULL.
//
func (device *Device) WindowAtPositionDouble() (winX, winY float64, window Windower) {
	var _arg0 *C.GdkDevice // out
	var _arg1 C.gdouble    // in
	var _arg2 C.gdouble    // in
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_get_window_at_position_double(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(device)

	var _winX float64    // out
	var _winY float64    // out
	var _window Windower // out

	_winX = float64(_arg1)
	_winY = float64(_arg2)
	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _winX, _winY, _window
}

// Grab grabs the device so that all events coming from this device are passed
// to this application until the device is ungrabbed with gdk_device_ungrab(),
// or the window becomes unviewable. This overrides any previous grab on the
// device by this client.
//
// Note that device and window need to be on the same display.
//
// Device grabs are used for operations which need complete control over the
// given device events (either pointer or keyboard). For example in GTK+ this is
// used for Drag and Drop operations, popup menus and such.
//
// Note that if the event mask of an X window has selected both button press and
// button release events, then a button press event will cause an automatic
// pointer grab until the button is released. X does this automatically since
// most applications expect to receive button press and release events in pairs.
// It is equivalent to a pointer grab on the window with owner_events set to
// TRUE.
//
// If you set up anything at the time you take the grab that needs to be cleaned
// up when the grab ends, you should handle the EventGrabBroken events that are
// emitted when the grab ends unvoluntarily.
//
// Deprecated: Use gdk_seat_grab() instead.
//
// The function takes the following parameters:
//
//    - window which will own the grab (the grab window).
//    - grabOwnership specifies the grab ownership.
//    - ownerEvents: if FALSE then all device events are reported with respect to
//      window and are only reported if selected by event_mask. If TRUE then
//      pointer events for this application are reported as normal, but pointer
//      events outside this application are reported with respect to window and
//      only if selected by event_mask. In either mode, unreported events are
//      discarded.
//    - eventMask specifies the event mask, which is used in accordance with
//      owner_events.
//    - cursor (optional) to display while the grab is active if the device is a
//      pointer. If this is NULL then the normal cursors are used for window and
//      its descendants, and the cursor for window is used elsewhere.
//    - time_: timestamp of the event which led to this pointer grab. This
//      usually comes from the Event struct, though GDK_CURRENT_TIME can be used
//      if the time isnâ€™t known.
//
// The function returns the following values:
//
//    - grabStatus: GDK_GRAB_SUCCESS if the grab was successful.
//
func (device *Device) Grab(window Windower, grabOwnership GrabOwnership, ownerEvents bool, eventMask EventMask, cursor Cursorrer, time_ uint32) GrabStatus {
	var _arg0 *C.GdkDevice       // out
	var _arg1 *C.GdkWindow       // out
	var _arg2 C.GdkGrabOwnership // out
	var _arg3 C.gboolean         // out
	var _arg4 C.GdkEventMask     // out
	var _arg5 *C.GdkCursor       // out
	var _arg6 C.guint32          // out
	var _cret C.GdkGrabStatus    // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg2 = C.GdkGrabOwnership(grabOwnership)
	if ownerEvents {
		_arg3 = C.TRUE
	}
	_arg4 = C.GdkEventMask(eventMask)
	if cursor != nil {
		_arg5 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))
	}
	_arg6 = C.guint32(time_)

	_cret = C.gdk_device_grab(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(device)
	runtime.KeepAlive(window)
	runtime.KeepAlive(grabOwnership)
	runtime.KeepAlive(ownerEvents)
	runtime.KeepAlive(eventMask)
	runtime.KeepAlive(cursor)
	runtime.KeepAlive(time_)

	var _grabStatus GrabStatus // out

	_grabStatus = GrabStatus(_cret)

	return _grabStatus
}

// Ungrab: release any grab on device.
//
// Deprecated: Use gdk_seat_ungrab() instead.
//
// The function takes the following parameters:
//
//    - time_: timestap (e.g. GDK_CURRENT_TIME).
//
func (device *Device) Ungrab(time_ uint32) {
	var _arg0 *C.GdkDevice // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = C.guint32(time_)

	C.gdk_device_ungrab(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(time_)
}

// Warp warps device in display to the point x,y on the screen screen, unless
// the device is confined to a window by a grab, in which case it will be moved
// as far as allowed by the grab. Warping the pointer creates events as if the
// user had moved the mouse instantaneously to the destination.
//
// Note that the pointer should normally be under the control of the user. This
// function was added to cover some rare use cases like keyboard navigation
// support for the color picker in the ColorSelectionDialog.
//
// The function takes the following parameters:
//
//    - screen to warp device to.
//    - x: x coordinate of the destination.
//    - y: y coordinate of the destination.
//
func (device *Device) Warp(screen *Screen, x, y int) {
	var _arg0 *C.GdkDevice // out
	var _arg1 *C.GdkScreen // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	_arg2 = C.gint(x)
	_arg3 = C.gint(y)

	C.gdk_device_warp(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(device)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
import "C"

// Flush flushes any requests queued for the windowing system; this happens
// automatically when the main loop blocks waiting for new events, but if your
// application is drawing without returning control to the main loop, you may
// need to call this function explicitly. A common case where this function
// needs to be called is when an application is executing drawing commands from
// a thread other than the thread where the main loop is running.
//
// This is most useful for X11. On windowing systems where requests are handled
// synchronously, this function will do nothing.
func (display *Display) Flush() {
	var _arg0 *C.GdkDisplay // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_flush(_arg0)
	runtime.KeepAlive(display)
}

// DefaultCursorSize returns the default size to use for cursors on display.
//
// The function returns the following values:
//
//    - guint: default cursor size.
//
func (display *Display) DefaultCursorSize() uint {
	var _arg0 *C.GdkDisplay // out
	var _cret C.guint       // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_default_cursor_size(_arg0)
	runtime.KeepAlive(display)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// DefaultGroup returns the default group leader window for all toplevel windows
// on display. This window is implicitly created by GDK. See
// gdk_window_set_group().
//
// The function returns the following values:
//
//    - window: default group leader window for display.
//
func (display *Display) DefaultGroup() Windower {
	var _arg0 *C.GdkDisplay // out
	var _cret *C.GdkWindow  // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_get_default_group(_arg0)
	runtime.KeepAlive(display)

	var _window Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}

	return _window
}

// MaximalCursorSize gets the maximal size to use for cursors on display.
//
// The function returns the following values:
//
//    - width: return location for the maximal cursor width.
//    - height: return location for the maximal cursor height.
//
func (display *Display) MaximalCursorSize() (width, height uint) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.guint       // in
	var _arg2 C.guint       // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gdk_display_get_maximal_cursor_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(display)

	var _width uint  // out
	var _height uint // out

	_width = uint(_arg1)
	_height = uint(_arg2)

	return _width, _height
}

// SetDoubleClickDistance sets the double click distance (two clicks within this
// distance count as a double click and result in a K_2BUTTON_PRESS event). See
// also gdk_display_set_double_click_time(). Applications should not set this,
// it is a global user-configured setting.
//
// The function takes the following parameters:
//
//    - distance in pixels.
//
func (display *Display) SetDoubleClickDistance(distance uint) {
	var _arg0 *C.GdkDisplay // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg1 = C.guint(distance)

	C.gdk_display_set_double_click_distance(_arg0, _arg1)
	runtime.KeepAlive(display)
	runtime.KeepAlive(distance)
}

// SupportsCursorAlpha returns TRUE if cursors can use an 8bit alpha channel on
// display. Otherwise, cursors are restricted to bilevel alpha (i.e. a mask).
//
// The function returns the following values:
//
//    - ok: whether cursors can have alpha channels.
//
func (display *Display) SupportsCursorAlpha() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_supports_cursor_alpha(_arg0)
	runtime.KeepAlive(display)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SupportsCursorColor returns TRUE if multicolored cursors are supported on
// display. Otherwise, cursors have only a forground and a background color.
//
// The function returns the following values:
//
//    - ok: whether cursors can have multiple colors.
//
func (display *Display) SupportsCursorColor() bool {
	var _arg0 *C.GdkDisplay // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gdk_display_supports_cursor_color(_arg0)
	runtime.KeepAlive(display)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

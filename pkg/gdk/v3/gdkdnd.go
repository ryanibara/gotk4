// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_drag_cancel_reason_get_type()), F: marshalDragCancelReason},
		{T: externglib.Type(C.gdk_drag_protocol_get_type()), F: marshalDragProtocol},
		{T: externglib.Type(C.gdk_drag_action_get_type()), F: marshalDragAction},
	})
}

// DragCancelReason: used in DragContext to the reason of a cancelled DND
// operation.
type DragCancelReason C.gint

const (
	// DragCancelNoTarget: there is no suitable drop target.
	DragCancelNoTarget DragCancelReason = iota
	// DragCancelUserCancelled: drag cancelled by the user.
	DragCancelUserCancelled
	// DragCancelError: unspecified error.
	DragCancelError
)

func marshalDragCancelReason(p uintptr) (interface{}, error) {
	return DragCancelReason(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DragCancelReason.
func (d DragCancelReason) String() string {
	switch d {
	case DragCancelNoTarget:
		return "NoTarget"
	case DragCancelUserCancelled:
		return "UserCancelled"
	case DragCancelError:
		return "Error"
	default:
		return fmt.Sprintf("DragCancelReason(%d)", d)
	}
}

// DragProtocol: used in DragContext to indicate the protocol according to which
// DND is done.
type DragProtocol C.gint

const (
	// DragProtoNone: no protocol.
	DragProtoNone DragProtocol = iota
	// DragProtoMotif: motif DND protocol. No longer supported.
	DragProtoMotif
	// DragProtoXdnd: xdnd protocol.
	DragProtoXdnd
	// DragProtoRootwin: extension to the Xdnd protocol for unclaimed root
	// window drops.
	DragProtoRootwin
	// DragProtoWin32Dropfiles: simple WM_DROPFILES protocol.
	DragProtoWin32Dropfiles
	// DragProtoOle2: complex OLE2 DND protocol (not implemented).
	DragProtoOle2
	// DragProtoLocal: intra-application DND.
	DragProtoLocal
	// DragProtoWayland: wayland DND protocol.
	DragProtoWayland
)

func marshalDragProtocol(p uintptr) (interface{}, error) {
	return DragProtocol(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DragProtocol.
func (d DragProtocol) String() string {
	switch d {
	case DragProtoNone:
		return "None"
	case DragProtoMotif:
		return "Motif"
	case DragProtoXdnd:
		return "Xdnd"
	case DragProtoRootwin:
		return "Rootwin"
	case DragProtoWin32Dropfiles:
		return "Win32Dropfiles"
	case DragProtoOle2:
		return "Ole2"
	case DragProtoLocal:
		return "Local"
	case DragProtoWayland:
		return "Wayland"
	default:
		return fmt.Sprintf("DragProtocol(%d)", d)
	}
}

// DragAction: used in DragContext to indicate what the destination should do
// with the dropped data.
type DragAction C.guint

const (
	// ActionDefault means nothing, and should not be used.
	ActionDefault DragAction = 0b1
	// ActionCopy: copy the data.
	ActionCopy DragAction = 0b10
	// ActionMove: move the data, i.e. first copy it, then delete it from the
	// source using the DELETE target of the X selection protocol.
	ActionMove DragAction = 0b100
	// ActionLink: add a link to the data. Note that this is only useful if
	// source and destination agree on what it means.
	ActionLink DragAction = 0b1000
	// ActionPrivate: special action which tells the source that the destination
	// will do something that the source doesnâ€™t understand.
	ActionPrivate DragAction = 0b10000
	// ActionAsk: ask the user what to do with the data.
	ActionAsk DragAction = 0b100000
)

func marshalDragAction(p uintptr) (interface{}, error) {
	return DragAction(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DragAction.
func (d DragAction) String() string {
	if d == 0 {
		return "DragAction(0)"
	}

	var builder strings.Builder
	builder.Grow(70)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case ActionDefault:
			builder.WriteString("Default|")
		case ActionCopy:
			builder.WriteString("Copy|")
		case ActionMove:
			builder.WriteString("Move|")
		case ActionLink:
			builder.WriteString("Link|")
		case ActionPrivate:
			builder.WriteString("Private|")
		case ActionAsk:
			builder.WriteString("Ask|")
		default:
			builder.WriteString(fmt.Sprintf("DragAction(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DragAction) Has(other DragAction) bool {
	return (d & other) == other
}

// DragAbort aborts a drag without dropping.
//
// This function is called by the drag source.
//
// This function does not need to be called in managed drag and drop operations.
// See gdk_drag_context_manage_dnd() for more information.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - time_: timestamp for this operation.
//
func DragAbort(context *DragContext, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = C.guint32(time_)

	C.gdk_drag_abort(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(time_)
}

// DragDrop drops on the current destination.
//
// This function is called by the drag source.
//
// This function does not need to be called in managed drag and drop operations.
// See gdk_drag_context_manage_dnd() for more information.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - time_: timestamp for this operation.
//
func DragDrop(context *DragContext, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = C.guint32(time_)

	C.gdk_drag_drop(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(time_)
}

// DragDropDone: inform GDK if the drop ended successfully. Passing FALSE for
// success may trigger a drag cancellation animation.
//
// This function is called by the drag source, and should be the last call
// before dropping the reference to the context.
//
// The DragContext will only take the first gdk_drag_drop_done() call as
// effective, if this function is called multiple times, all subsequent calls
// will be ignored.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - success: whether the drag was ultimatively successful.
//
func DragDropDone(context *DragContext, success bool) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gboolean        // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	if success {
		_arg2 = C.TRUE
	}

	C.gdk_drag_drop_done(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(success)
}

// DragDropSucceeded returns whether the dropped data has been successfully
// transferred. This function is intended to be used while handling a
// GDK_DROP_FINISHED event, its return value is meaningless at other times.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//
// The function returns the following values:
//
//    - ok: TRUE if the drop was successful.
//
func DragDropSucceeded(context *DragContext) bool {
	var _arg1 *C.GdkDragContext // out
	var _cret C.gboolean        // in

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_drop_succeeded(_arg1)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragFindWindowForScreen finds the destination window and DND protocol to use
// at the given pointer position.
//
// This function is called by the drag source to obtain the dest_window and
// protocol parameters for gdk_drag_motion().
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - dragWindow: window which may be at the pointer position, but should be
//      ignored, since it is put up by the drag source as an icon.
//    - screen where the destination window is sought.
//    - xRoot: x position of the pointer in root coordinates.
//    - yRoot: y position of the pointer in root coordinates.
//
// The function returns the following values:
//
//    - destWindow: location to store the destination window in.
//    - protocol: location to store the DND protocol in.
//
func DragFindWindowForScreen(context *DragContext, dragWindow Windower, screen *Screen, xRoot, yRoot int) (Windower, DragProtocol) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.GdkWindow      // out
	var _arg3 *C.GdkScreen      // out
	var _arg4 C.gint            // out
	var _arg5 C.gint            // out
	var _arg6 *C.GdkWindow      // in
	var _arg7 C.GdkDragProtocol // in

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GdkWindow)(unsafe.Pointer(dragWindow.Native()))
	_arg3 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
	_arg4 = C.gint(xRoot)
	_arg5 = C.gint(yRoot)

	C.gdk_drag_find_window_for_screen(_arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, &_arg7)
	runtime.KeepAlive(context)
	runtime.KeepAlive(dragWindow)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(xRoot)
	runtime.KeepAlive(yRoot)

	var _destWindow Windower   // out
	var _protocol DragProtocol // out

	{
		objptr := unsafe.Pointer(_arg6)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_destWindow = rv
	}
	_protocol = DragProtocol(_arg7)

	return _destWindow, _protocol
}

// DragMotion updates the drag context when the pointer moves or the set of
// actions changes.
//
// This function is called by the drag source.
//
// This function does not need to be called in managed drag and drop operations.
// See gdk_drag_context_manage_dnd() for more information.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - destWindow: new destination window, obtained by gdk_drag_find_window().
//    - protocol: DND protocol in use, obtained by gdk_drag_find_window().
//    - xRoot: x position of the pointer in root coordinates.
//    - yRoot: y position of the pointer in root coordinates.
//    - suggestedAction: suggested action.
//    - possibleActions: possible actions.
//    - time_: timestamp for this operation.
//
// The function returns the following values:
//
func DragMotion(context *DragContext, destWindow Windower, protocol DragProtocol, xRoot, yRoot int, suggestedAction, possibleActions DragAction, time_ uint32) bool {
	var _arg1 *C.GdkDragContext // out
	var _arg2 *C.GdkWindow      // out
	var _arg3 C.GdkDragProtocol // out
	var _arg4 C.gint            // out
	var _arg5 C.gint            // out
	var _arg6 C.GdkDragAction   // out
	var _arg7 C.GdkDragAction   // out
	var _arg8 C.guint32         // out
	var _cret C.gboolean        // in

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.GdkWindow)(unsafe.Pointer(destWindow.Native()))
	_arg3 = C.GdkDragProtocol(protocol)
	_arg4 = C.gint(xRoot)
	_arg5 = C.gint(yRoot)
	_arg6 = C.GdkDragAction(suggestedAction)
	_arg7 = C.GdkDragAction(possibleActions)
	_arg8 = C.guint32(time_)

	_cret = C.gdk_drag_motion(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(context)
	runtime.KeepAlive(destWindow)
	runtime.KeepAlive(protocol)
	runtime.KeepAlive(xRoot)
	runtime.KeepAlive(yRoot)
	runtime.KeepAlive(suggestedAction)
	runtime.KeepAlive(possibleActions)
	runtime.KeepAlive(time_)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragStatus selects one of the actions offered by the drag source.
//
// This function is called by the drag destination in response to
// gdk_drag_motion() called by the drag source.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - action: selected action which will be taken when a drop happens, or 0 to
//      indicate that a drop will not be accepted.
//    - time_: timestamp for this operation.
//
func DragStatus(context *DragContext, action DragAction, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.GdkDragAction   // out
	var _arg3 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg2 = C.GdkDragAction(action)
	_arg3 = C.guint32(time_)

	C.gdk_drag_status(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(action)
	runtime.KeepAlive(time_)
}

// DropFinish ends the drag operation after a drop.
//
// This function is called by the drag destination.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - success: TRUE if the data was successfully received.
//    - time_: timestamp for this operation.
//
func DropFinish(context *DragContext, success bool, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gboolean        // out
	var _arg3 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	if success {
		_arg2 = C.TRUE
	}
	_arg3 = C.guint32(time_)

	C.gdk_drop_finish(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(success)
	runtime.KeepAlive(time_)
}

// DropReply accepts or rejects a drop.
//
// This function is called by the drag destination in response to a drop
// initiated by the drag source.
//
// The function takes the following parameters:
//
//    - context: DragContext.
//    - accepted: TRUE if the drop is accepted.
//    - time_: timestamp for this operation.
//
func DropReply(context *DragContext, accepted bool, time_ uint32) {
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gboolean        // out
	var _arg3 C.guint32         // out

	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	if accepted {
		_arg2 = C.TRUE
	}
	_arg3 = C.guint32(time_)

	C.gdk_drop_reply(_arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(accepted)
	runtime.KeepAlive(time_)
}

// Actions determines the bitmask of actions proposed by the source if
// gdk_drag_context_get_suggested_action() returns GDK_ACTION_ASK.
//
// The function returns the following values:
//
//    - dragAction: DragAction flags.
//
func (context *DragContext) Actions() DragAction {
	var _arg0 *C.GdkDragContext // out
	var _cret C.GdkDragAction   // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_context_get_actions(_arg0)
	runtime.KeepAlive(context)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

// DestWindow returns the destination window for the DND operation.
//
// The function returns the following values:
//
//    - window: Window.
//
func (context *DragContext) DestWindow() Windower {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkWindow      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_context_get_dest_window(_arg0)
	runtime.KeepAlive(context)

	var _window Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}

	return _window
}

// Device returns the Device associated to the drag context.
//
// The function returns the following values:
//
//    - device associated to context.
//
func (context *DragContext) Device() Devicer {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkDevice      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_context_get_device(_arg0)
	runtime.KeepAlive(context)

	var _device Devicer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Devicer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Devicer)
			return ok
		})
		rv, ok := casted.(Devicer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
		}
		_device = rv
	}

	return _device
}

// DragWindow returns the window on which the drag icon should be rendered
// during the drag operation. Note that the window may not be available until
// the drag operation has begun. GDK will move the window in accordance with the
// ongoing drag operation. The window is owned by context and will be destroyed
// when the drag operation is over.
//
// The function returns the following values:
//
//    - window (optional): drag window, or NULL.
//
func (context *DragContext) DragWindow() Windower {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkWindow      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_context_get_drag_window(_arg0)
	runtime.KeepAlive(context)

	var _window Windower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _window
}

// Protocol returns the drag protocol that is used by this context.
//
// The function returns the following values:
//
//    - dragProtocol: drag protocol.
//
func (context *DragContext) Protocol() DragProtocol {
	var _arg0 *C.GdkDragContext // out
	var _cret C.GdkDragProtocol // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_context_get_protocol(_arg0)
	runtime.KeepAlive(context)

	var _dragProtocol DragProtocol // out

	_dragProtocol = DragProtocol(_cret)

	return _dragProtocol
}

// SelectedAction determines the action chosen by the drag destination.
//
// The function returns the following values:
//
//    - dragAction: DragAction value.
//
func (context *DragContext) SelectedAction() DragAction {
	var _arg0 *C.GdkDragContext // out
	var _cret C.GdkDragAction   // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_context_get_selected_action(_arg0)
	runtime.KeepAlive(context)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

// SourceWindow returns the Window where the DND operation started.
//
// The function returns the following values:
//
//    - window: Window.
//
func (context *DragContext) SourceWindow() Windower {
	var _arg0 *C.GdkDragContext // out
	var _cret *C.GdkWindow      // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_context_get_source_window(_arg0)
	runtime.KeepAlive(context)

	var _window Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}

	return _window
}

// SuggestedAction determines the suggested drag action of the context.
//
// The function returns the following values:
//
//    - dragAction: DragAction value.
//
func (context *DragContext) SuggestedAction() DragAction {
	var _arg0 *C.GdkDragContext // out
	var _cret C.GdkDragAction   // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))

	_cret = C.gdk_drag_context_get_suggested_action(_arg0)
	runtime.KeepAlive(context)

	var _dragAction DragAction // out

	_dragAction = DragAction(_cret)

	return _dragAction
}

// ManageDND requests the drag and drop operation to be managed by context. When
// a drag and drop operation becomes managed, the DragContext will internally
// handle all input and source-side EventDND events as required by the windowing
// system.
//
// Once the drag and drop operation is managed, the drag context will emit the
// following signals:
//
// - The DragContext::action-changed signal whenever the final action to be
// performed by the drag and drop operation changes.
//
// - The DragContext::drop-performed signal after the user performs the drag and
// drop gesture (typically by releasing the mouse button).
//
// - The DragContext::dnd-finished signal after the drag and drop operation
// concludes (after all Selection transfers happen).
//
// - The DragContext::cancel signal if the drag and drop operation is finished
// but doesn't happen over an accepting destination, or is cancelled through
// other means.
//
// The function takes the following parameters:
//
//    - ipcWindow: window to use for IPC messaging/events.
//    - actions supported by the drag source.
//
// The function returns the following values:
//
//    - ok if the drag and drop operation is managed.
//
func (context *DragContext) ManageDND(ipcWindow Windower, actions DragAction) bool {
	var _arg0 *C.GdkDragContext // out
	var _arg1 *C.GdkWindow      // out
	var _arg2 C.GdkDragAction   // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(ipcWindow.Native()))
	_arg2 = C.GdkDragAction(actions)

	_cret = C.gdk_drag_context_manage_dnd(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(ipcWindow)
	runtime.KeepAlive(actions)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDevice associates a Device to context, so all Drag and Drop events for
// context are emitted as if they came from this device.
//
// The function takes the following parameters:
//
//    - device: Device.
//
func (context *DragContext) SetDevice(device Devicer) {
	var _arg0 *C.GdkDragContext // out
	var _arg1 *C.GdkDevice      // out

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

	C.gdk_drag_context_set_device(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(device)
}

// SetHotspot sets the position of the drag window that will be kept under the
// cursor hotspot. Initially, the hotspot is at the top left corner of the drag
// window.
//
// The function takes the following parameters:
//
//    - hotX: x coordinate of the drag window hotspot.
//    - hotY: y coordinate of the drag window hotspot.
//
func (context *DragContext) SetHotspot(hotX, hotY int) {
	var _arg0 *C.GdkDragContext // out
	var _arg1 C.gint            // out
	var _arg2 C.gint            // out

	_arg0 = (*C.GdkDragContext)(unsafe.Pointer(context.Native()))
	_arg1 = C.gint(hotX)
	_arg2 = C.gint(hotY)

	C.gdk_drag_context_set_hotspot(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

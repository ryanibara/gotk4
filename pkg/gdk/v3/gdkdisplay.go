// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gdk3_Display_ConnectClosed(gpointer, gboolean, guintptr);
// extern void _gotk4_gdk3_Display_ConnectMonitorAdded(gpointer, void*, guintptr);
// extern void _gotk4_gdk3_Display_ConnectMonitorRemoved(gpointer, void*, guintptr);
// extern void _gotk4_gdk3_Display_ConnectOpened(gpointer, guintptr);
// extern void _gotk4_gdk3_Display_ConnectSeatAdded(gpointer, void*, guintptr);
// extern void _gotk4_gdk3_Display_ConnectSeatRemoved(gpointer, void*, guintptr);
import "C"

// GTypeDisplay returns the GType for the type Display.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeDisplay() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gdk", "Display").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalDisplay)
	return gtype
}

// Display objects purpose are two fold:
//
// - To manage and provide information about input devices (pointers and
// keyboards)
//
// - To manage and provide information about the available Screens
//
// GdkDisplay objects are the GDK representation of an X Display, which can be
// described as a workstation consisting of a keyboard, a pointing device (such
// as a mouse) and one or more screens. It is used to open and keep track of
// various GdkScreen objects currently instantiated by the application. It is
// also used to access the keyboard(s) and mouse pointer(s) of the display.
//
// Most of the input device handling has been factored out into the separate
// DeviceManager object. Every display has a device manager, which you can
// obtain using gdk_display_get_device_manager().
type Display struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Display)(nil)
)

func wrapDisplay(obj *coreglib.Object) *Display {
	return &Display{
		Object: obj,
	}
}

func marshalDisplay(p uintptr) (interface{}, error) {
	return wrapDisplay(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gdk3_Display_ConnectClosed
func _gotk4_gdk3_Display_ConnectClosed(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(isError bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(isError bool))
	}

	var _isError bool // out

	if arg1 != 0 {
		_isError = true
	}

	f(_isError)
}

// ConnectClosed signal is emitted when the connection to the windowing system
// for display is closed.
func (display *Display) ConnectClosed(f func(isError bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "closed", false, unsafe.Pointer(C._gotk4_gdk3_Display_ConnectClosed), f)
}

//export _gotk4_gdk3_Display_ConnectMonitorAdded
func _gotk4_gdk3_Display_ConnectMonitorAdded(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(monitor *Monitor)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(monitor *Monitor))
	}

	var _monitor *Monitor // out

	_monitor = wrapMonitor(coreglib.Take(unsafe.Pointer(arg1)))

	f(_monitor)
}

// ConnectMonitorAdded signal is emitted whenever a monitor is added.
func (display *Display) ConnectMonitorAdded(f func(monitor *Monitor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "monitor-added", false, unsafe.Pointer(C._gotk4_gdk3_Display_ConnectMonitorAdded), f)
}

//export _gotk4_gdk3_Display_ConnectMonitorRemoved
func _gotk4_gdk3_Display_ConnectMonitorRemoved(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(monitor *Monitor)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(monitor *Monitor))
	}

	var _monitor *Monitor // out

	_monitor = wrapMonitor(coreglib.Take(unsafe.Pointer(arg1)))

	f(_monitor)
}

// ConnectMonitorRemoved signal is emitted whenever a monitor is removed.
func (display *Display) ConnectMonitorRemoved(f func(monitor *Monitor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "monitor-removed", false, unsafe.Pointer(C._gotk4_gdk3_Display_ConnectMonitorRemoved), f)
}

//export _gotk4_gdk3_Display_ConnectOpened
func _gotk4_gdk3_Display_ConnectOpened(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectOpened signal is emitted when the connection to the windowing system
// for display is opened.
func (display *Display) ConnectOpened(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "opened", false, unsafe.Pointer(C._gotk4_gdk3_Display_ConnectOpened), f)
}

//export _gotk4_gdk3_Display_ConnectSeatAdded
func _gotk4_gdk3_Display_ConnectSeatAdded(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(seat Seater)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(seat Seater))
	}

	var _seat Seater // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Seater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Seater)
			return ok
		})
		rv, ok := casted.(Seater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
		}
		_seat = rv
	}

	f(_seat)
}

// ConnectSeatAdded signal is emitted whenever a new seat is made known to the
// windowing system.
func (display *Display) ConnectSeatAdded(f func(seat Seater)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "seat-added", false, unsafe.Pointer(C._gotk4_gdk3_Display_ConnectSeatAdded), f)
}

//export _gotk4_gdk3_Display_ConnectSeatRemoved
func _gotk4_gdk3_Display_ConnectSeatRemoved(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(seat Seater)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(seat Seater))
	}

	var _seat Seater // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Seater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Seater)
			return ok
		})
		rv, ok := casted.(Seater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
		}
		_seat = rv
	}

	f(_seat)
}

// ConnectSeatRemoved signal is emitted whenever a seat is removed by the
// windowing system.
func (display *Display) ConnectSeatRemoved(f func(seat Seater)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(display, "seat-removed", false, unsafe.Pointer(C._gotk4_gdk3_Display_ConnectSeatRemoved), f)
}

// Beep emits a short beep on display.
func (display *Display) Beep() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	girepository.MustFind("Gdk", "Display").InvokeMethod("beep", _args[:], nil)

	runtime.KeepAlive(display)
}

// Close closes the connection to the windowing system for the given display,
// and cleans up associated resources.
func (display *Display) Close() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	girepository.MustFind("Gdk", "Display").InvokeMethod("close", _args[:], nil)

	runtime.KeepAlive(display)
}

// DeviceIsGrabbed returns TRUE if there is an ongoing grab on device for
// display.
//
// The function takes the following parameters:
//
//    - device: Device.
//
// The function returns the following values:
//
//    - ok: TRUE if there is a grab in effect for device.
//
func (display *Display) DeviceIsGrabbed(device Devicer) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("device_is_grabbed", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)
	runtime.KeepAlive(device)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Flush flushes any requests queued for the windowing system; this happens
// automatically when the main loop blocks waiting for new events, but if your
// application is drawing without returning control to the main loop, you may
// need to call this function explicitly. A common case where this function
// needs to be called is when an application is executing drawing commands from
// a thread other than the thread where the main loop is running.
//
// This is most useful for X11. On windowing systems where requests are handled
// synchronously, this function will do nothing.
func (display *Display) Flush() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	girepository.MustFind("Gdk", "Display").InvokeMethod("flush", _args[:], nil)

	runtime.KeepAlive(display)
}

// AppLaunchContext returns a AppLaunchContext suitable for launching
// applications on the given display.
//
// The function returns the following values:
//
//    - appLaunchContext: new AppLaunchContext for display. Free with
//      g_object_unref() when done.
//
func (display *Display) AppLaunchContext() *AppLaunchContext {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_app_launch_context", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _appLaunchContext *AppLaunchContext // out

	_appLaunchContext = wrapAppLaunchContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _appLaunchContext
}

// DefaultCursorSize returns the default size to use for cursors on display.
//
// The function returns the following values:
//
//    - guint: default cursor size.
//
func (display *Display) DefaultCursorSize() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_default_cursor_size", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// DefaultGroup returns the default group leader window for all toplevel windows
// on display. This window is implicitly created by GDK. See
// gdk_window_set_group().
//
// The function returns the following values:
//
//    - window: default group leader window for display.
//
func (display *Display) DefaultGroup() Windower {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_default_group", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _window Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}

	return _window
}

// DefaultScreen: get the default Screen for display.
//
// The function returns the following values:
//
//    - screen: default Screen object for display.
//
func (display *Display) DefaultScreen() *Screen {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_default_screen", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _screen *Screen // out

	_screen = wrapScreen(coreglib.Take(unsafe.Pointer(_cret)))

	return _screen
}

// DefaultSeat returns the default Seat for this display.
//
// The function returns the following values:
//
//    - seat: default seat.
//
func (display *Display) DefaultSeat() Seater {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_default_seat", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _seat Seater // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Seater is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Seater)
			return ok
		})
		rv, ok := casted.(Seater)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
		}
		_seat = rv
	}

	return _seat
}

// DeviceManager returns the DeviceManager associated to display.
//
// Deprecated: Use gdk_display_get_default_seat() and Seat operations.
//
// The function returns the following values:
//
//    - deviceManager (optional) or NULL. This memory is owned by GDK and must
//      not be freed or unreferenced.
//
func (display *Display) DeviceManager() DeviceManagerer {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_device_manager", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _deviceManager DeviceManagerer // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(DeviceManagerer)
				return ok
			})
			rv, ok := casted.(DeviceManagerer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.DeviceManagerer")
			}
			_deviceManager = rv
		}
	}

	return _deviceManager
}

// Event gets the next Event to be processed for display, fetching events from
// the windowing system if necessary.
//
// The function returns the following values:
//
//    - event (optional): next Event to be processed, or NULL if no events are
//      pending. The returned Event should be freed with gdk_event_free().
//
func (display *Display) Event() *Event {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_event", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _event *Event // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			v := (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
			_event = v
		}
	}

	return _event
}

// MaximalCursorSize gets the maximal size to use for cursors on display.
//
// The function returns the following values:
//
//    - width: return location for the maximal cursor width.
//    - height: return location for the maximal cursor height.
//
func (display *Display) MaximalCursorSize() (width, height uint32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	girepository.MustFind("Gdk", "Display").InvokeMethod("get_maximal_cursor_size", _args[:], _outs[:])

	runtime.KeepAlive(display)

	var _width uint32  // out
	var _height uint32 // out

	_width = *(*uint32)(unsafe.Pointer(_outs[0]))
	_height = *(*uint32)(unsafe.Pointer(_outs[1]))

	return _width, _height
}

// Monitor gets a monitor associated with this display.
//
// The function takes the following parameters:
//
//    - monitorNum: number of the monitor.
//
// The function returns the following values:
//
//    - monitor (optional) or NULL if monitor_num is not a valid monitor number.
//
func (display *Display) Monitor(monitorNum int32) *Monitor {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(monitorNum)

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_monitor", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)
	runtime.KeepAlive(monitorNum)

	var _monitor *Monitor // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_monitor = wrapMonitor(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _monitor
}

// MonitorAtPoint gets the monitor in which the point (x, y) is located, or a
// nearby monitor if the point is not in any monitor.
//
// The function takes the following parameters:
//
//    - x coordinate of the point.
//    - y coordinate of the point.
//
// The function returns the following values:
//
//    - monitor containing the point.
//
func (display *Display) MonitorAtPoint(x, y int32) *Monitor {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(x)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(y)

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_monitor_at_point", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _monitor *Monitor // out

	_monitor = wrapMonitor(coreglib.Take(unsafe.Pointer(_cret)))

	return _monitor
}

// MonitorAtWindow gets the monitor in which the largest area of window resides,
// or a monitor close to window if it is outside of all monitors.
//
// The function takes the following parameters:
//
//    - window: Window.
//
// The function returns the following values:
//
//    - monitor with the largest overlap with window.
//
func (display *Display) MonitorAtWindow(window Windower) *Monitor {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_monitor_at_window", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)
	runtime.KeepAlive(window)

	var _monitor *Monitor // out

	_monitor = wrapMonitor(coreglib.Take(unsafe.Pointer(_cret)))

	return _monitor
}

// NMonitors gets the number of monitors that belong to display.
//
// The returned number is valid until the next emission of the
// Display::monitor-added or Display::monitor-removed signal.
//
// The function returns the following values:
//
//    - gint: number of monitors.
//
func (display *Display) NMonitors() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_n_monitors", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// NScreens gets the number of screen managed by the display.
//
// Deprecated: The number of screens is always 1.
//
// The function returns the following values:
//
//    - gint: number of screens.
//
func (display *Display) NScreens() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_n_screens", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Name gets the name of the display.
//
// The function returns the following values:
//
//    - utf8: string representing the display name. This string is owned by GDK
//      and should not be modified or freed.
//
func (display *Display) Name() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_name", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Pointer gets the current location of the pointer and the current modifier
// mask for a given display.
//
// Deprecated: Use gdk_device_get_position() instead.
//
// The function returns the following values:
//
//    - screen (optional): location to store the screen that the cursor is on, or
//      NULL.
//    - x (optional): location to store root window X coordinate of pointer, or
//      NULL.
//    - y (optional): location to store root window Y coordinate of pointer, or
//      NULL.
//    - mask (optional): location to store current modifier mask, or NULL.
//
func (display *Display) Pointer() (screen *Screen, x, y int32, mask ModifierType) {
	var _args [1]girepository.Argument
	var _outs [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	girepository.MustFind("Gdk", "Display").InvokeMethod("get_pointer", _args[:], _outs[:])

	runtime.KeepAlive(display)

	var _screen *Screen    // out
	var _x int32           // out
	var _y int32           // out
	var _mask ModifierType // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_screen = wrapScreen(coreglib.Take(unsafe.Pointer(_outs[0])))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_x = *(*int32)(unsafe.Pointer(_outs[1]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[2])) != nil {
		_y = *(*int32)(unsafe.Pointer(_outs[2]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[3])) != nil {
		_mask = *(*ModifierType)(unsafe.Pointer(_outs[3]))
	}

	return _screen, _x, _y, _mask
}

// PrimaryMonitor gets the primary monitor for the display.
//
// The primary monitor is considered the monitor where the “main desktop” lives.
// While normal application windows typically allow the window manager to place
// the windows, specialized desktop applications such as panels should place
// themselves on the primary monitor.
//
// The function returns the following values:
//
//    - monitor (optional): primary monitor, or NULL if no primary monitor is
//      configured by the user.
//
func (display *Display) PrimaryMonitor() *Monitor {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_primary_monitor", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _monitor *Monitor // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_monitor = wrapMonitor(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _monitor
}

// Screen returns a screen object for one of the screens of the display.
//
// Deprecated: There is only one screen; use gdk_display_get_default_screen() to
// get it.
//
// The function takes the following parameters:
//
//    - screenNum: screen number.
//
// The function returns the following values:
//
//    - screen: Screen object.
//
func (display *Display) Screen(screenNum int32) *Screen {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(screenNum)

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_screen", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)
	runtime.KeepAlive(screenNum)

	var _screen *Screen // out

	_screen = wrapScreen(coreglib.Take(unsafe.Pointer(_cret)))

	return _screen
}

// WindowAtPointer obtains the window underneath the mouse pointer, returning
// the location of the pointer in that window in win_x, win_y for screen.
// Returns NULL if the window under the mouse pointer is not known to GDK (for
// example, belongs to another application).
//
// Deprecated: Use gdk_device_get_window_at_position() instead.
//
// The function returns the following values:
//
//    - winX (optional): return location for x coordinate of the pointer location
//      relative to the window origin, or NULL.
//    - winY (optional): return location for y coordinate of the pointer location
//      relative & to the window origin, or NULL.
//    - window (optional) under the mouse pointer, or NULL.
//
func (display *Display) WindowAtPointer() (winX, winY int32, window Windower) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("get_window_at_pointer", _args[:], _outs[:])
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _winX int32      // out
	var _winY int32      // out
	var _window Windower // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_winX = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_winY = *(*int32)(unsafe.Pointer(_outs[1]))
	}
	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _winX, _winY, _window
}

// HasPending returns whether the display has events that are waiting to be
// processed.
//
// The function returns the following values:
//
//    - ok: TRUE if there are events ready to be processed.
//
func (display *Display) HasPending() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("has_pending", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsClosed finds out if the display has been closed.
//
// The function returns the following values:
//
//    - ok: TRUE if the display is closed.
//
func (display *Display) IsClosed() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("is_closed", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// KeyboardUngrab: release any keyboard grab
//
// Deprecated: Use gdk_device_ungrab(), together with gdk_device_grab() instead.
//
// The function takes the following parameters:
//
//    - time_: timestap (e.g K_CURRENT_TIME).
//
func (display *Display) KeyboardUngrab(time_ uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(*C.guint32)(unsafe.Pointer(&_args[1])) = C.guint32(time_)

	girepository.MustFind("Gdk", "Display").InvokeMethod("keyboard_ungrab", _args[:], nil)

	runtime.KeepAlive(display)
	runtime.KeepAlive(time_)
}

// ListDevices returns the list of available input devices attached to display.
// The list is statically allocated and should not be freed.
//
// Deprecated: Use gdk_device_manager_list_devices() instead.
//
// The function returns the following values:
//
//    - list: a list of Device.
//
func (display *Display) ListDevices() []Devicer {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("list_devices", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _list []Devicer // out

	_list = make([]Devicer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Devicer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gdk.Devicer is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Devicer)
				return ok
			})
			rv, ok := casted.(Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// ListSeats returns the list of seats known to display.
//
// The function returns the following values:
//
//    - list: the list of seats known to the Display.
//
func (display *Display) ListSeats() []Seater {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("list_seats", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _list []Seater // out

	_list = make([]Seater, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Seater // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gdk.Seater is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Seater)
				return ok
			})
			rv, ok := casted.(Seater)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Seater")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// NotifyStartupComplete indicates to the GUI environment that the application
// has finished loading, using a given identifier.
//
// GTK+ will call this function automatically for Window with custom
// startup-notification identifier unless
// gtk_window_set_auto_startup_notification() is called to disable that feature.
//
// The function takes the following parameters:
//
//    - startupId: startup-notification identifier, for which notification
//      process should be completed.
//
func (display *Display) NotifyStartupComplete(startupId string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gdk", "Display").InvokeMethod("notify_startup_complete", _args[:], nil)

	runtime.KeepAlive(display)
	runtime.KeepAlive(startupId)
}

// PeekEvent gets a copy of the first Event in the display’s event queue,
// without removing the event from the queue. (Note that this function will not
// get more events from the windowing system. It only checks the events that
// have already been moved to the GDK event queue.).
//
// The function returns the following values:
//
//    - event (optional): copy of the first Event on the event queue, or NULL if
//      no events are in the queue. The returned Event should be freed with
//      gdk_event_free().
//
func (display *Display) PeekEvent() *Event {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("peek_event", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _event *Event // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			v := (*Event)(gextras.NewStructNative(unsafe.Pointer(_cret)))
			_event = v
		}
	}

	return _event
}

// PointerIsGrabbed: test if the pointer is grabbed.
//
// Deprecated: Use gdk_display_device_is_grabbed() instead.
//
// The function returns the following values:
//
//    - ok: TRUE if an active X pointer grab is in effect.
//
func (display *Display) PointerIsGrabbed() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("pointer_is_grabbed", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// PointerUngrab: release any pointer grab.
//
// Deprecated: Use gdk_device_ungrab(), together with gdk_device_grab() instead.
//
// The function takes the following parameters:
//
//    - time_: timestap (e.g. GDK_CURRENT_TIME).
//
func (display *Display) PointerUngrab(time_ uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(*C.guint32)(unsafe.Pointer(&_args[1])) = C.guint32(time_)

	girepository.MustFind("Gdk", "Display").InvokeMethod("pointer_ungrab", _args[:], nil)

	runtime.KeepAlive(display)
	runtime.KeepAlive(time_)
}

// PutEvent appends a copy of the given event onto the front of the event queue
// for display.
//
// The function takes the following parameters:
//
//    - event: Event.
//
func (display *Display) PutEvent(event *Event) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(event)))

	girepository.MustFind("Gdk", "Display").InvokeMethod("put_event", _args[:], nil)

	runtime.KeepAlive(display)
	runtime.KeepAlive(event)
}

// SetDoubleClickDistance sets the double click distance (two clicks within this
// distance count as a double click and result in a K_2BUTTON_PRESS event). See
// also gdk_display_set_double_click_time(). Applications should not set this,
// it is a global user-configured setting.
//
// The function takes the following parameters:
//
//    - distance in pixels.
//
func (display *Display) SetDoubleClickDistance(distance uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(distance)

	girepository.MustFind("Gdk", "Display").InvokeMethod("set_double_click_distance", _args[:], nil)

	runtime.KeepAlive(display)
	runtime.KeepAlive(distance)
}

// SetDoubleClickTime sets the double click time (two clicks within this time
// interval count as a double click and result in a K_2BUTTON_PRESS event).
// Applications should not set this, it is a global user-configured setting.
//
// The function takes the following parameters:
//
//    - msec: double click time in milliseconds (thousandths of a second).
//
func (display *Display) SetDoubleClickTime(msec uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(msec)

	girepository.MustFind("Gdk", "Display").InvokeMethod("set_double_click_time", _args[:], nil)

	runtime.KeepAlive(display)
	runtime.KeepAlive(msec)
}

// SupportsClipboardPersistence returns whether the speicifed display supports
// clipboard persistance; i.e. if it’s possible to store the clipboard data
// after an application has quit. On X11 this checks if a clipboard daemon is
// running.
//
// The function returns the following values:
//
//    - ok: TRUE if the display supports clipboard persistance.
//
func (display *Display) SupportsClipboardPersistence() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("supports_clipboard_persistence", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SupportsComposite returns TRUE if gdk_window_set_composited() can be used to
// redirect drawing on the window using compositing.
//
// Currently this only works on X11 with XComposite and XDamage extensions
// available.
//
// Deprecated: Compositing is an outdated technology that only ever worked on
// X11.
//
// The function returns the following values:
//
//    - ok: TRUE if windows may be composited.
//
func (display *Display) SupportsComposite() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("supports_composite", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SupportsCursorAlpha returns TRUE if cursors can use an 8bit alpha channel on
// display. Otherwise, cursors are restricted to bilevel alpha (i.e. a mask).
//
// The function returns the following values:
//
//    - ok: whether cursors can have alpha channels.
//
func (display *Display) SupportsCursorAlpha() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("supports_cursor_alpha", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SupportsCursorColor returns TRUE if multicolored cursors are supported on
// display. Otherwise, cursors have only a forground and a background color.
//
// The function returns the following values:
//
//    - ok: whether cursors can have multiple colors.
//
func (display *Display) SupportsCursorColor() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("supports_cursor_color", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SupportsInputShapes returns TRUE if gdk_window_input_shape_combine_mask() can
// be used to modify the input shape of windows on display.
//
// The function returns the following values:
//
//    - ok: TRUE if windows with modified input shape are supported.
//
func (display *Display) SupportsInputShapes() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("supports_input_shapes", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SupportsSelectionNotification returns whether EventOwnerChange events will be
// sent when the owner of a selection changes.
//
// The function returns the following values:
//
//    - ok: whether EventOwnerChange events will be sent.
//
func (display *Display) SupportsSelectionNotification() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("supports_selection_notification", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SupportsShapes returns TRUE if gdk_window_shape_combine_mask() can be used to
// create shaped windows on display.
//
// The function returns the following values:
//
//    - ok: TRUE if shaped windows are supported.
//
func (display *Display) SupportsShapes() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_gret := girepository.MustFind("Gdk", "Display").InvokeMethod("supports_shapes", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(display)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Sync flushes any requests queued for the windowing system and waits until all
// requests have been handled. This is often used for making sure that the
// display is synchronized with the current state of the program. Calling
// gdk_display_sync() before gdk_error_trap_pop() makes sure that any errors
// generated from earlier requests are handled before the error trap is removed.
//
// This is most useful for X11. On windowing systems where requests are handled
// synchronously, this function will do nothing.
func (display *Display) Sync() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	girepository.MustFind("Gdk", "Display").InvokeMethod("sync", _args[:], nil)

	runtime.KeepAlive(display)
}

// WarpPointer warps the pointer of display to the point x,y on the screen
// screen, unless the pointer is confined to a window by a grab, in which case
// it will be moved as far as allowed by the grab. Warping the pointer creates
// events as if the user had moved the mouse instantaneously to the destination.
//
// Note that the pointer should normally be under the control of the user. This
// function was added to cover some rare use cases like keyboard navigation
// support for the color picker in the ColorSelectionDialog.
//
// Deprecated: Use gdk_device_warp() instead.
//
// The function takes the following parameters:
//
//    - screen of display to warp the pointer to.
//    - x coordinate of the destination.
//    - y coordinate of the destination.
//
func (display *Display) WarpPointer(screen *Screen, x, y int32) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(x)
	*(*C.gint)(unsafe.Pointer(&_args[3])) = C.gint(y)

	girepository.MustFind("Gdk", "Display").InvokeMethod("warp_pointer", _args[:], nil)

	runtime.KeepAlive(display)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// DisplayGetDefault gets the default Display. This is a convenience function
// for: gdk_display_manager_get_default_display (gdk_display_manager_get ()).
//
// The function returns the following values:
//
//    - display (optional) or NULL if there is no default display.
//
func DisplayGetDefault() *Display {
	_gret := girepository.MustFind("Gdk", "get_default").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _display *Display // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// DisplayOpen opens a display.
//
// The function takes the following parameters:
//
//    - displayName: name of the display to open.
//
// The function returns the following values:
//
//    - display (optional) or NULL if the display could not be opened.
//
func DisplayOpen(displayName string) *Display {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gdk", "open").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(displayName)

	var _display *Display // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// DisplayOpenDefaultLibgtkOnly opens the default display specified by command
// line arguments or environment variables, sets it as the default display, and
// returns it. gdk_parse_args() must have been called first. If the default
// display has previously been set, simply returns that. An internal function
// that should not be used by applications.
//
// Deprecated: This symbol was never meant to be used outside of GTK+.
//
// The function returns the following values:
//
//    - display (optional): default display, if it could be opened, otherwise
//      NULL.
//
func DisplayOpenDefaultLibgtkOnly() *Display {
	_gret := girepository.MustFind("Gdk", "open_default_libgtk_only").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _display *Display // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

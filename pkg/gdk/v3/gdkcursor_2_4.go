// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
import "C"

// NewCursorFromPixbuf creates a new cursor from a pixbuf.
//
// Not all GDK backends support RGBA cursors. If they are not supported, a
// monochrome approximation will be displayed. The functions
// gdk_display_supports_cursor_alpha() and gdk_display_supports_cursor_color()
// can be used to determine whether RGBA cursors are supported;
// gdk_display_get_default_cursor_size() and
// gdk_display_get_maximal_cursor_size() give information about cursor sizes.
//
// If x or y are -1, the pixbuf must have options named “x_hot” and “y_hot”,
// resp., containing integer values between 0 and the width resp. height of the
// pixbuf. (Since: 3.0)
//
// On the X backend, support for RGBA cursors requires a sufficently new version
// of the X Render extension.
//
// The function takes the following parameters:
//
//    - display for which the cursor will be created.
//    - pixbuf containing the cursor image.
//    - x: horizontal offset of the “hotspot” of the cursor.
//    - y: vertical offset of the “hotspot” of the cursor.
//
// The function returns the following values:
//
//    - cursor: new Cursor.
//
func NewCursorFromPixbuf(display *Display, pixbuf *gdkpixbuf.Pixbuf, x, y int) *Cursor {
	var _arg1 *C.GdkDisplay // out
	var _arg2 *C.GdkPixbuf  // out
	var _arg3 C.gint        // out
	var _arg4 C.gint        // out
	var _cret *C.GdkCursor  // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	_arg3 = C.gint(x)
	_arg4 = C.gint(y)

	_cret = C.gdk_cursor_new_from_pixbuf(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(display)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _cursor *Cursor // out

	_cursor = wrapCursor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cursor
}

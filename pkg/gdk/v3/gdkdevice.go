// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk/gdk.h>
// #include <glib-object.h>
// extern void _gotk4_gdk3_Device_ConnectToolChanged(gpointer, GdkDeviceTool*, guintptr);
// extern void _gotk4_gdk3_Device_ConnectChanged(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeDeviceType  = coreglib.Type(C.gdk_device_type_get_type())
	GTypeInputMode   = coreglib.Type(C.gdk_input_mode_get_type())
	GTypeInputSource = coreglib.Type(C.gdk_input_source_get_type())
	GTypeDevice      = coreglib.Type(C.gdk_device_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeDeviceType, F: marshalDeviceType},
		coreglib.TypeMarshaler{T: GTypeInputMode, F: marshalInputMode},
		coreglib.TypeMarshaler{T: GTypeInputSource, F: marshalInputSource},
		coreglib.TypeMarshaler{T: GTypeDevice, F: marshalDevice},
	})
}

const MAX_TIMECOORD_AXES = 128

// DeviceType indicates the device type. See
// [above][GdkDeviceManager.description] for more information about the meaning
// of these device types.
type DeviceType C.gint

const (
	// DeviceTypeMaster: device is a master (or virtual) device. There will be
	// an associated focus indicator on the screen.
	DeviceTypeMaster DeviceType = iota
	// DeviceTypeSlave: device is a slave (or physical) device.
	DeviceTypeSlave
	// DeviceTypeFloating: device is a physical device, currently not attached
	// to any virtual device.
	DeviceTypeFloating
)

func marshalDeviceType(p uintptr) (interface{}, error) {
	return DeviceType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DeviceType.
func (d DeviceType) String() string {
	switch d {
	case DeviceTypeMaster:
		return "Master"
	case DeviceTypeSlave:
		return "Slave"
	case DeviceTypeFloating:
		return "Floating"
	default:
		return fmt.Sprintf("DeviceType(%d)", d)
	}
}

// InputMode: enumeration that describes the mode of an input device.
type InputMode C.gint

const (
	// ModeDisabled: device is disabled and will not report any events.
	ModeDisabled InputMode = iota
	// ModeScreen: device is enabled. The device’s coordinate space maps to the
	// entire screen.
	ModeScreen
	// ModeWindow: device is enabled. The device’s coordinate space is mapped to
	// a single window. The manner in which this window is chosen is undefined,
	// but it will typically be the same way in which the focus window for key
	// events is determined.
	ModeWindow
)

func marshalInputMode(p uintptr) (interface{}, error) {
	return InputMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for InputMode.
func (i InputMode) String() string {
	switch i {
	case ModeDisabled:
		return "Disabled"
	case ModeScreen:
		return "Screen"
	case ModeWindow:
		return "Window"
	default:
		return fmt.Sprintf("InputMode(%d)", i)
	}
}

// InputSource: enumeration describing the type of an input device in general
// terms.
type InputSource C.gint

const (
	// SourceMouse: device is a mouse. (This will be reported for the core
	// pointer, even if it is something else, such as a trackball.).
	SourceMouse InputSource = iota
	// SourcePen: device is a stylus of a graphics tablet or similar device.
	SourcePen
	// SourceEraser: device is an eraser. Typically, this would be the other end
	// of a stylus on a graphics tablet.
	SourceEraser
	// SourceCursor: device is a graphics tablet “puck” or similar device.
	SourceCursor
	// SourceKeyboard: device is a keyboard.
	SourceKeyboard
	// SourceTouchscreen: device is a direct-input touch device, such as a
	// touchscreen or tablet. This device type has been added in 3.4.
	SourceTouchscreen
	// SourceTouchpad: device is an indirect touch device, such as a touchpad.
	// This device type has been added in 3.4.
	SourceTouchpad
	// SourceTrackpoint: device is a trackpoint. This device type has been added
	// in 3.22.
	SourceTrackpoint
	// SourceTabletPad: device is a "pad", a collection of buttons, rings and
	// strips found in drawing tablets. This device type has been added in 3.22.
	SourceTabletPad
)

func marshalInputSource(p uintptr) (interface{}, error) {
	return InputSource(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for InputSource.
func (i InputSource) String() string {
	switch i {
	case SourceMouse:
		return "Mouse"
	case SourcePen:
		return "Pen"
	case SourceEraser:
		return "Eraser"
	case SourceCursor:
		return "Cursor"
	case SourceKeyboard:
		return "Keyboard"
	case SourceTouchscreen:
		return "Touchscreen"
	case SourceTouchpad:
		return "Touchpad"
	case SourceTrackpoint:
		return "Trackpoint"
	case SourceTabletPad:
		return "TabletPad"
	default:
		return fmt.Sprintf("InputSource(%d)", i)
	}
}

// Device object represents a single input device, such as a keyboard, a mouse,
// a touchpad, etc.
//
// See the DeviceManager documentation for more information about the various
// kinds of master and slave devices, and their relationships.
type Device struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Device)(nil)
)

// Devicer describes types inherited from class Device.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Devicer interface {
	coreglib.Objector
	baseDevice() *Device
}

var _ Devicer = (*Device)(nil)

func wrapDevice(obj *coreglib.Object) *Device {
	return &Device{
		Object: obj,
	}
}

func marshalDevice(p uintptr) (interface{}, error) {
	return wrapDevice(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (device *Device) baseDevice() *Device {
	return device
}

// BaseDevice returns the underlying base object.
func BaseDevice(obj Devicer) *Device {
	return obj.baseDevice()
}

// ConnectChanged signal is emitted either when the Device has changed the
// number of either axes or keys. For example In X this will normally happen
// when the slave device routing events through the master device changes (for
// example, user switches from the USB mouse to a tablet), in that case the
// master device will change to reflect the new slave device axes and keys.
func (device *Device) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(device, "changed", false, unsafe.Pointer(C._gotk4_gdk3_Device_ConnectChanged), f)
}

// ConnectToolChanged signal is emitted on pen/eraser Devices whenever tools
// enter or leave proximity.
func (device *Device) ConnectToolChanged(f func(tool *DeviceTool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(device, "tool-changed", false, unsafe.Pointer(C._gotk4_gdk3_Device_ConnectToolChanged), f)
}

// ListSlaveDevices: if the device if of type GDK_DEVICE_TYPE_MASTER, it will
// return the list of slave devices attached to it, otherwise it will return
// NULL.
//
// The function returns the following values:
//
//    - list (optional): the list of slave devices, or NULL. The list must be
//      freed with g_list_free(), the contents of the list are owned by GTK+ and
//      should not be freed.
//
func (device *Device) ListSlaveDevices() []Devicer {
	var _arg0 *C.GdkDevice // out
	var _cret *C.GList     // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_list_slave_devices(_arg0)
	runtime.KeepAlive(device)

	var _list []Devicer // out

	if _cret != nil {
		_list = make([]Devicer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
		gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
			src := (*C.GdkDevice)(v)
			var dst Devicer // out
			{
				objptr := unsafe.Pointer(src)
				if objptr == nil {
					panic("object of type gdk.Devicer is nil")
				}

				object := coreglib.Take(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(Devicer)
					return ok
				})
				rv, ok := casted.(Devicer)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
				}
				dst = rv
			}
			_list = append(_list, dst)
		})
	}

	return _list
}

// SetAxisUse specifies how an axis of a device is used.
//
// The function takes the following parameters:
//
//    - index_: index of the axis.
//    - use specifies how the axis is used.
//
func (device *Device) SetAxisUse(index_ uint, use AxisUse) {
	var _arg0 *C.GdkDevice // out
	var _arg1 C.guint      // out
	var _arg2 C.GdkAxisUse // out

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = C.guint(index_)
	_arg2 = C.GdkAxisUse(use)

	C.gdk_device_set_axis_use(_arg0, _arg1, _arg2)
	runtime.KeepAlive(device)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(use)
}

// SetKey specifies the X key event to generate when a macro button of a device
// is pressed.
//
// The function takes the following parameters:
//
//    - index_: index of the macro button to set.
//    - keyval to generate.
//    - modifiers to set.
//
func (device *Device) SetKey(index_, keyval uint, modifiers ModifierType) {
	var _arg0 *C.GdkDevice      // out
	var _arg1 C.guint           // out
	var _arg2 C.guint           // out
	var _arg3 C.GdkModifierType // out

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = C.guint(index_)
	_arg2 = C.guint(keyval)
	_arg3 = C.GdkModifierType(modifiers)

	C.gdk_device_set_key(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(device)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(modifiers)
}

// SetMode sets a the mode of an input device. The mode controls if the device
// is active and whether the device’s range is mapped to the entire screen or to
// a single window.
//
// Note: This is only meaningful for floating devices, master devices (and
// slaves connected to these) drive the pointer cursor, which is not limited by
// the input mode.
//
// The function takes the following parameters:
//
//    - mode: input mode.
//
// The function returns the following values:
//
//    - ok: TRUE if the mode was successfully changed.
//
func (device *Device) SetMode(mode InputMode) bool {
	var _arg0 *C.GdkDevice   // out
	var _arg1 C.GdkInputMode // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg1 = C.GdkInputMode(mode)

	_cret = C.gdk_device_set_mode(_arg0, _arg1)
	runtime.KeepAlive(device)
	runtime.KeepAlive(mode)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceGrabInfoLibgtkOnly determines information about the current keyboard
// grab. This is not public API and must not be used by applications.
//
// Deprecated: The symbol was never meant to be used outside of GTK+.
//
// The function takes the following parameters:
//
//    - display for which to get the grab information.
//    - device to get the grab information from.
//
// The function returns the following values:
//
//    - grabWindow: location to store current grab window.
//    - ownerEvents: location to store boolean indicating whether the
//      owner_events flag to gdk_keyboard_grab() or gdk_pointer_grab() was TRUE.
//    - ok: TRUE if this application currently has the keyboard grabbed.
//
func DeviceGrabInfoLibgtkOnly(display *Display, device Devicer) (grabWindow Windower, ownerEvents, ok bool) {
	var _arg1 *C.GdkDisplay // out
	var _arg2 *C.GdkDevice  // out
	var _arg3 *C.GdkWindow  // in
	var _arg4 C.gboolean    // in
	var _cret C.gboolean    // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg2 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gdk_device_grab_info_libgtk_only(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(display)
	runtime.KeepAlive(device)

	var _grabWindow Windower // out
	var _ownerEvents bool    // out
	var _ok bool             // out

	{
		objptr := unsafe.Pointer(_arg3)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_grabWindow = rv
	}
	if _arg4 != 0 {
		_ownerEvents = true
	}
	if _cret != 0 {
		_ok = true
	}

	return _grabWindow, _ownerEvents, _ok
}

// TimeCoord stores a single event in a motion history.
//
// An instance of this type is always passed by reference.
type TimeCoord struct {
	*timeCoord
}

// timeCoord is the struct that's finalized.
type timeCoord struct {
	native *C.GdkTimeCoord
}

// Time: timestamp for this event.
func (t *TimeCoord) Time() uint32 {
	valptr := &t.native.time
	var _v uint32 // out
	_v = uint32(*valptr)
	return _v
}

// Axes values of the device’s axes.
func (t *TimeCoord) Axes() [128]float64 {
	valptr := &t.native.axes
	var _v [128]float64 // out
	_v = *(*[128]float64)(unsafe.Pointer(&*valptr))
	return _v
}

// Time: timestamp for this event.
func (t *TimeCoord) SetTime(time uint32) {
	valptr := &t.native.time
	*valptr = C.guint32(time)
}

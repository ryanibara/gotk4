// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern GdkWindow* _gotk4_gdk3_Window_ConnectPickEmbeddedChild(gpointer, gdouble, gdouble, guintptr);
// extern cairo_surface_t* _gotk4_gdk3_WindowClass_create_surface(GdkWindow*, gint, gint);
// extern cairo_surface_t* _gotk4_gdk3_Window_ConnectCreateSurface(gpointer, gint, gint, guintptr);
// extern void _gotk4_gdk3_WindowClass_from_embedder(GdkWindow*, gdouble, gdouble, gdouble*, gdouble*);
// extern void _gotk4_gdk3_WindowClass_to_embedder(GdkWindow*, gdouble, gdouble, gdouble*, gdouble*);
import "C"

// glib.Type values for gdkwindow.go.
var (
	GTypeFullscreenMode       = coreglib.Type(C.gdk_fullscreen_mode_get_type())
	GTypeGravity              = coreglib.Type(C.gdk_gravity_get_type())
	GTypeWindowEdge           = coreglib.Type(C.gdk_window_edge_get_type())
	GTypeWindowType           = coreglib.Type(C.gdk_window_type_get_type())
	GTypeWindowWindowClass    = coreglib.Type(C.gdk_window_window_class_get_type())
	GTypeAnchorHints          = coreglib.Type(C.gdk_anchor_hints_get_type())
	GTypeWMDecoration         = coreglib.Type(C.gdk_wm_decoration_get_type())
	GTypeWMFunction           = coreglib.Type(C.gdk_wm_function_get_type())
	GTypeWindowAttributesType = coreglib.Type(C.gdk_window_attributes_type_get_type())
	GTypeWindowHints          = coreglib.Type(C.gdk_window_hints_get_type())
	GTypeWindow               = coreglib.Type(C.gdk_window_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeFullscreenMode, F: marshalFullscreenMode},
		{T: GTypeGravity, F: marshalGravity},
		{T: GTypeWindowEdge, F: marshalWindowEdge},
		{T: GTypeWindowType, F: marshalWindowType},
		{T: GTypeWindowWindowClass, F: marshalWindowWindowClass},
		{T: GTypeAnchorHints, F: marshalAnchorHints},
		{T: GTypeWMDecoration, F: marshalWMDecoration},
		{T: GTypeWMFunction, F: marshalWMFunction},
		{T: GTypeWindowAttributesType, F: marshalWindowAttributesType},
		{T: GTypeWindowHints, F: marshalWindowHints},
		{T: GTypeWindow, F: marshalWindow},
	})
}

// FullscreenMode indicates which monitor (in a multi-head setup) a window
// should span over when in fullscreen mode.
type FullscreenMode C.gint

const (
	// FullscreenOnCurrentMonitor: fullscreen on current monitor only.
	FullscreenOnCurrentMonitor FullscreenMode = iota
	// FullscreenOnAllMonitors: span across all monitors when fullscreen.
	FullscreenOnAllMonitors
)

func marshalFullscreenMode(p uintptr) (interface{}, error) {
	return FullscreenMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FullscreenMode.
func (f FullscreenMode) String() string {
	switch f {
	case FullscreenOnCurrentMonitor:
		return "CurrentMonitor"
	case FullscreenOnAllMonitors:
		return "AllMonitors"
	default:
		return fmt.Sprintf("FullscreenMode(%d)", f)
	}
}

// Gravity defines the reference point of a window and the meaning of
// coordinates passed to gtk_window_move(). See gtk_window_move() and the
// "implementation notes" section of the Extended Window Manager Hints
// (http://www.freedesktop.org/Standards/wm-spec) specification for more
// details.
type Gravity C.gint

const (
	// GravityNorthWest: reference point is at the top left corner.
	GravityNorthWest Gravity = 1
	// GravityNorth: reference point is in the middle of the top edge.
	GravityNorth Gravity = 2
	// GravityNorthEast: reference point is at the top right corner.
	GravityNorthEast Gravity = 3
	// GravityWest: reference point is at the middle of the left edge.
	GravityWest Gravity = 4
	// GravityCenter: reference point is at the center of the window.
	GravityCenter Gravity = 5
	// GravityEast: reference point is at the middle of the right edge.
	GravityEast Gravity = 6
	// GravitySouthWest: reference point is at the lower left corner.
	GravitySouthWest Gravity = 7
	// GravitySouth: reference point is at the middle of the lower edge.
	GravitySouth Gravity = 8
	// GravitySouthEast: reference point is at the lower right corner.
	GravitySouthEast Gravity = 9
	// GravityStatic: reference point is at the top left corner of the window
	// itself, ignoring window manager decorations.
	GravityStatic Gravity = 10
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Gravity.
func (g Gravity) String() string {
	switch g {
	case GravityNorthWest:
		return "NorthWest"
	case GravityNorth:
		return "North"
	case GravityNorthEast:
		return "NorthEast"
	case GravityWest:
		return "West"
	case GravityCenter:
		return "Center"
	case GravityEast:
		return "East"
	case GravitySouthWest:
		return "SouthWest"
	case GravitySouth:
		return "South"
	case GravitySouthEast:
		return "SouthEast"
	case GravityStatic:
		return "Static"
	default:
		return fmt.Sprintf("Gravity(%d)", g)
	}
}

// WindowEdge determines a window edge or corner.
type WindowEdge C.gint

const (
	// WindowEdgeNorthWest: top left corner.
	WindowEdgeNorthWest WindowEdge = iota
	// WindowEdgeNorth: top edge.
	WindowEdgeNorth
	// WindowEdgeNorthEast: top right corner.
	WindowEdgeNorthEast
	// WindowEdgeWest: left edge.
	WindowEdgeWest
	// WindowEdgeEast: right edge.
	WindowEdgeEast
	// WindowEdgeSouthWest: lower left corner.
	WindowEdgeSouthWest
	// WindowEdgeSouth: lower edge.
	WindowEdgeSouth
	// WindowEdgeSouthEast: lower right corner.
	WindowEdgeSouthEast
)

func marshalWindowEdge(p uintptr) (interface{}, error) {
	return WindowEdge(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowEdge.
func (w WindowEdge) String() string {
	switch w {
	case WindowEdgeNorthWest:
		return "NorthWest"
	case WindowEdgeNorth:
		return "North"
	case WindowEdgeNorthEast:
		return "NorthEast"
	case WindowEdgeWest:
		return "West"
	case WindowEdgeEast:
		return "East"
	case WindowEdgeSouthWest:
		return "SouthWest"
	case WindowEdgeSouth:
		return "South"
	case WindowEdgeSouthEast:
		return "SouthEast"
	default:
		return fmt.Sprintf("WindowEdge(%d)", w)
	}
}

// WindowType describes the kind of window.
type WindowType C.gint

const (
	// WindowRoot: root window; this window has no parent, covers the entire
	// screen, and is created by the window system.
	WindowRoot WindowType = iota
	// WindowToplevel: toplevel window (used to implement Window).
	WindowToplevel
	// WindowChild: child window (used to implement e.g. Entry).
	WindowChild
	// WindowTemp: override redirect temporary window (used to implement Menu).
	WindowTemp
	// WindowForeign: foreign window (see gdk_window_foreign_new()).
	WindowForeign
	// WindowOffscreen: offscreen window (see [Offscreen
	// Windows][OFFSCREEN-WINDOWS]). Since 2.18.
	WindowOffscreen
	// WindowSubsurface: subsurface-based window; This window is visually tied
	// to a toplevel, and is moved/stacked with it. Currently this window type
	// is only implemented in Wayland. Since 3.14.
	WindowSubsurface
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowType.
func (w WindowType) String() string {
	switch w {
	case WindowRoot:
		return "Root"
	case WindowToplevel:
		return "Toplevel"
	case WindowChild:
		return "Child"
	case WindowTemp:
		return "Temp"
	case WindowForeign:
		return "Foreign"
	case WindowOffscreen:
		return "Offscreen"
	case WindowSubsurface:
		return "Subsurface"
	default:
		return fmt.Sprintf("WindowType(%d)", w)
	}
}

// WindowWindowClass: GDK_INPUT_OUTPUT windows are the standard kind of window
// you might expect. Such windows receive events and are also displayed on
// screen. GDK_INPUT_ONLY windows are invisible; they are usually placed above
// other windows in order to trap or filter the events. You can’t draw on
// GDK_INPUT_ONLY windows.
type WindowWindowClass C.gint

const (
	// InputOutput: window for graphics and events.
	InputOutput WindowWindowClass = iota
	// InputOnly: window for events only.
	InputOnly
)

func marshalWindowWindowClass(p uintptr) (interface{}, error) {
	return WindowWindowClass(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowWindowClass.
func (w WindowWindowClass) String() string {
	switch w {
	case InputOutput:
		return "InputOutput"
	case InputOnly:
		return "InputOnly"
	default:
		return fmt.Sprintf("WindowWindowClass(%d)", w)
	}
}

// AnchorHints: positioning hints for aligning a window relative to a rectangle.
//
// These hints determine how the window should be positioned in the case that
// the window would fall off-screen if placed in its ideal position.
//
// For example, GDK_ANCHOR_FLIP_X will replace GDK_GRAVITY_NORTH_WEST with
// GDK_GRAVITY_NORTH_EAST and vice versa if the window extends beyond the left
// or right edges of the monitor.
//
// If GDK_ANCHOR_SLIDE_X is set, the window can be shifted horizontally to fit
// on-screen. If GDK_ANCHOR_RESIZE_X is set, the window can be shrunken
// horizontally to fit.
//
// In general, when multiple flags are set, flipping should take precedence over
// sliding, which should take precedence over resizing.
type AnchorHints C.guint

const (
	// AnchorFlipX: allow flipping anchors horizontally.
	AnchorFlipX AnchorHints = 0b1
	// AnchorFlipY: allow flipping anchors vertically.
	AnchorFlipY AnchorHints = 0b10
	// AnchorSlideX: allow sliding window horizontally.
	AnchorSlideX AnchorHints = 0b100
	// AnchorSlideY: allow sliding window vertically.
	AnchorSlideY AnchorHints = 0b1000
	// AnchorResizeX: allow resizing window horizontally.
	AnchorResizeX AnchorHints = 0b10000
	// AnchorResizeY: allow resizing window vertically.
	AnchorResizeY AnchorHints = 0b100000
	// AnchorFlip: allow flipping anchors on both axes.
	AnchorFlip AnchorHints = 0b11
	// AnchorSlide: allow sliding window on both axes.
	AnchorSlide AnchorHints = 0b1100
	// AnchorResize: allow resizing window on both axes.
	AnchorResize AnchorHints = 0b110000
)

func marshalAnchorHints(p uintptr) (interface{}, error) {
	return AnchorHints(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AnchorHints.
func (a AnchorHints) String() string {
	if a == 0 {
		return "AnchorHints(0)"
	}

	var builder strings.Builder
	builder.Grow(113)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AnchorFlipX:
			builder.WriteString("FlipX|")
		case AnchorFlipY:
			builder.WriteString("FlipY|")
		case AnchorSlideX:
			builder.WriteString("SlideX|")
		case AnchorSlideY:
			builder.WriteString("SlideY|")
		case AnchorResizeX:
			builder.WriteString("ResizeX|")
		case AnchorResizeY:
			builder.WriteString("ResizeY|")
		case AnchorFlip:
			builder.WriteString("Flip|")
		case AnchorSlide:
			builder.WriteString("Slide|")
		case AnchorResize:
			builder.WriteString("Resize|")
		default:
			builder.WriteString(fmt.Sprintf("AnchorHints(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AnchorHints) Has(other AnchorHints) bool {
	return (a & other) == other
}

// WMDecoration: these are hints originally defined by the Motif toolkit. The
// window manager can use them when determining how to decorate the window. The
// hint must be set before mapping the window.
type WMDecoration C.guint

const (
	// DecorAll: all decorations should be applied.
	DecorAll WMDecoration = 0b1
	// DecorBorder: frame should be drawn around the window.
	DecorBorder WMDecoration = 0b10
	// DecorResizeh: frame should have resize handles.
	DecorResizeh WMDecoration = 0b100
	// DecorTitle: titlebar should be placed above the window.
	DecorTitle WMDecoration = 0b1000
	// DecorMenu: button for opening a menu should be included.
	DecorMenu WMDecoration = 0b10000
	// DecorMinimize: minimize button should be included.
	DecorMinimize WMDecoration = 0b100000
	// DecorMaximize: maximize button should be included.
	DecorMaximize WMDecoration = 0b1000000
)

func marshalWMDecoration(p uintptr) (interface{}, error) {
	return WMDecoration(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WMDecoration.
func (w WMDecoration) String() string {
	if w == 0 {
		return "WMDecoration(0)"
	}

	var builder strings.Builder
	builder.Grow(82)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case DecorAll:
			builder.WriteString("All|")
		case DecorBorder:
			builder.WriteString("Border|")
		case DecorResizeh:
			builder.WriteString("Resizeh|")
		case DecorTitle:
			builder.WriteString("Title|")
		case DecorMenu:
			builder.WriteString("Menu|")
		case DecorMinimize:
			builder.WriteString("Minimize|")
		case DecorMaximize:
			builder.WriteString("Maximize|")
		default:
			builder.WriteString(fmt.Sprintf("WMDecoration(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WMDecoration) Has(other WMDecoration) bool {
	return (w & other) == other
}

// WMFunction: these are hints originally defined by the Motif toolkit. The
// window manager can use them when determining the functions to offer for the
// window. The hint must be set before mapping the window.
type WMFunction C.guint

const (
	// FuncAll: all functions should be offered.
	FuncAll WMFunction = 0b1
	// FuncResize: window should be resizable.
	FuncResize WMFunction = 0b10
	// FuncMove: window should be movable.
	FuncMove WMFunction = 0b100
	// FuncMinimize: window should be minimizable.
	FuncMinimize WMFunction = 0b1000
	// FuncMaximize: window should be maximizable.
	FuncMaximize WMFunction = 0b10000
	// FuncClose: window should be closable.
	FuncClose WMFunction = 0b100000
)

func marshalWMFunction(p uintptr) (interface{}, error) {
	return WMFunction(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WMFunction.
func (w WMFunction) String() string {
	if w == 0 {
		return "WMFunction(0)"
	}

	var builder strings.Builder
	builder.Grow(63)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case FuncAll:
			builder.WriteString("All|")
		case FuncResize:
			builder.WriteString("Resize|")
		case FuncMove:
			builder.WriteString("Move|")
		case FuncMinimize:
			builder.WriteString("Minimize|")
		case FuncMaximize:
			builder.WriteString("Maximize|")
		case FuncClose:
			builder.WriteString("Close|")
		default:
			builder.WriteString(fmt.Sprintf("WMFunction(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WMFunction) Has(other WMFunction) bool {
	return (w & other) == other
}

// WindowAttributesType: used to indicate which fields in the WindowAttr struct
// should be honored. For example, if you filled in the “cursor” and “x” fields
// of WindowAttr, pass “GDK_WA_X | GDK_WA_CURSOR” to gdk_window_new(). Fields in
// WindowAttr not covered by a bit in this enum are required; for example, the
// width/height, wclass, and window_type fields are required, they have no
// corresponding flag in WindowAttributesType.
type WindowAttributesType C.guint

const (
	// WaTitle: honor the title field.
	WaTitle WindowAttributesType = 0b10
	// WaX: honor the X coordinate field.
	WaX WindowAttributesType = 0b100
	// WaY: honor the Y coordinate field.
	WaY WindowAttributesType = 0b1000
	// WaCursor: honor the cursor field.
	WaCursor WindowAttributesType = 0b10000
	// WaVisual: honor the visual field.
	WaVisual WindowAttributesType = 0b100000
	// WaWmclass: honor the wmclass_class and wmclass_name fields.
	WaWmclass WindowAttributesType = 0b1000000
	// WaNoredir: honor the override_redirect field.
	WaNoredir WindowAttributesType = 0b10000000
	// WaTypeHint: honor the type_hint field.
	WaTypeHint WindowAttributesType = 0b100000000
)

func marshalWindowAttributesType(p uintptr) (interface{}, error) {
	return WindowAttributesType(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WindowAttributesType.
func (w WindowAttributesType) String() string {
	if w == 0 {
		return "WindowAttributesType(0)"
	}

	var builder strings.Builder
	builder.Grow(64)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case WaTitle:
			builder.WriteString("Title|")
		case WaX:
			builder.WriteString("X|")
		case WaY:
			builder.WriteString("Y|")
		case WaCursor:
			builder.WriteString("Cursor|")
		case WaVisual:
			builder.WriteString("Visual|")
		case WaWmclass:
			builder.WriteString("Wmclass|")
		case WaNoredir:
			builder.WriteString("Noredir|")
		case WaTypeHint:
			builder.WriteString("TypeHint|")
		default:
			builder.WriteString(fmt.Sprintf("WindowAttributesType(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WindowAttributesType) Has(other WindowAttributesType) bool {
	return (w & other) == other
}

// WindowHints: used to indicate which fields of a Geometry struct should be
// paid attention to. Also, the presence/absence of GDK_HINT_POS,
// GDK_HINT_USER_POS, and GDK_HINT_USER_SIZE is significant, though they don't
// directly refer to Geometry fields. GDK_HINT_USER_POS will be set
// automatically by Window if you call gtk_window_move(). GDK_HINT_USER_POS and
// GDK_HINT_USER_SIZE should be set if the user specified a size/position using
// a --geometry command-line argument; gtk_window_parse_geometry() automatically
// sets these flags.
type WindowHints C.guint

const (
	// HintPos indicates that the program has positioned the window.
	HintPos WindowHints = 0b1
	// HintMinSize: min size fields are set.
	HintMinSize WindowHints = 0b10
	// HintMaxSize: max size fields are set.
	HintMaxSize WindowHints = 0b100
	// HintBaseSize: base size fields are set.
	HintBaseSize WindowHints = 0b1000
	// HintAspect: aspect ratio fields are set.
	HintAspect WindowHints = 0b10000
	// HintResizeInc: resize increment fields are set.
	HintResizeInc WindowHints = 0b100000
	// HintWinGravity: window gravity field is set.
	HintWinGravity WindowHints = 0b1000000
	// HintUserPos indicates that the window’s position was explicitly set by
	// the user.
	HintUserPos WindowHints = 0b10000000
	// HintUserSize indicates that the window’s size was explicitly set by the
	// user.
	HintUserSize WindowHints = 0b100000000
)

func marshalWindowHints(p uintptr) (interface{}, error) {
	return WindowHints(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for WindowHints.
func (w WindowHints) String() string {
	if w == 0 {
		return "WindowHints(0)"
	}

	var builder strings.Builder
	builder.Grow(109)

	for w != 0 {
		next := w & (w - 1)
		bit := w - next

		switch bit {
		case HintPos:
			builder.WriteString("Pos|")
		case HintMinSize:
			builder.WriteString("MinSize|")
		case HintMaxSize:
			builder.WriteString("MaxSize|")
		case HintBaseSize:
			builder.WriteString("BaseSize|")
		case HintAspect:
			builder.WriteString("Aspect|")
		case HintResizeInc:
			builder.WriteString("ResizeInc|")
		case HintWinGravity:
			builder.WriteString("WinGravity|")
		case HintUserPos:
			builder.WriteString("UserPos|")
		case HintUserSize:
			builder.WriteString("UserSize|")
		default:
			builder.WriteString(fmt.Sprintf("WindowHints(0b%b)|", bit))
		}

		w = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if w contains other.
func (w WindowHints) Has(other WindowHints) bool {
	return (w & other) == other
}

// WindowChildFunc: function of this type is passed to
// gdk_window_invalidate_maybe_recurse(). It gets called for each child of the
// window to determine whether to recursively invalidate it or now.
type WindowChildFunc func(window Windower) (ok bool)

//export _gotk4_gdk3_WindowChildFunc
func _gotk4_gdk3_WindowChildFunc(arg1 *C.GdkWindow, arg2 C.gpointer) (cret C.gboolean) {
	var fn WindowChildFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(WindowChildFunc)
	}

	var _window Windower // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}

	ok := fn(_window)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// GetDefaultRootWindow obtains the root window (parent all other windows are
// inside) for the default display and screen.
//
// The function returns the following values:
//
//    - window: default root window.
//
func GetDefaultRootWindow() Windower {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gdk", "get_default_root_window").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _window Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}

	return _window
}

// OffscreenWindowGetEmbedder gets the window that window is embedded in.
//
// The function takes the following parameters:
//
//    - window: Window.
//
// The function returns the following values:
//
//    - ret (optional): embedding Window, or NULL if window is not an mbedded
//      offscreen window.
//
func OffscreenWindowGetEmbedder(window Windower) Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*Windower)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "offscreen_window_get_embedder").Invoke(args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ret Windower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_ret = rv
		}
	}

	return _ret
}

// OffscreenWindowGetSurface gets the offscreen surface that an offscreen window
// renders into. If you need to keep this around over window resizes, you need
// to add a reference to it.
//
// The function takes the following parameters:
//
//    - window: Window.
//
// The function returns the following values:
//
//    - surface (optional): offscreen surface, or NULL if not offscreen.
//
func OffscreenWindowGetSurface(window Windower) *cairo.Surface {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*Windower)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "offscreen_window_get_surface").Invoke(args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _surface *cairo.Surface // out

	if _cret != nil {
		_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
		C.cairo_surface_reference(_cret)
		runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
			C.cairo_surface_destroy((*C.void)(unsafe.Pointer(v.Native())))
		})
	}

	return _surface
}

// OffscreenWindowSetEmbedder sets window to be embedded in embedder.
//
// To fully embed an offscreen window, in addition to calling this function, it
// is also necessary to handle the Window::pick-embedded-child signal on the
// embedder and the Window::to-embedder and Window::from-embedder signals on
// window.
//
// The function takes the following parameters:
//
//    - window: Window.
//    - embedder that window gets embedded in.
//
func OffscreenWindowSetEmbedder(window, embedder Windower) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(embedder).Native()))
	*(*Windower)(unsafe.Pointer(&args[0])) = _arg0
	*(*Windower)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "offscreen_window_set_embedder").Invoke(args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(embedder)
}

// WindowOverrider contains methods that are overridable.
type WindowOverrider interface {
	// The function takes the following parameters:
	//
	//    - width
	//    - height
	//
	// The function returns the following values:
	//
	CreateSurface(width, height int32) *cairo.Surface
	// The function takes the following parameters:
	//
	//    - embedderX
	//    - embedderY
	//    - offscreenX
	//    - offscreenY
	//
	FromEmbedder(embedderX, embedderY float64, offscreenX, offscreenY *float64)
	// The function takes the following parameters:
	//
	//    - offscreenX
	//    - offscreenY
	//    - embedderX
	//    - embedderY
	//
	ToEmbedder(offscreenX, offscreenY float64, embedderX, embedderY *float64)
}

type Window struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Window)(nil)
)

// Windower describes types inherited from class Window.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Windower interface {
	coreglib.Objector
	baseWindow() *Window
}

var _ Windower = (*Window)(nil)

func classInitWindower(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GdkWindowClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GdkWindowClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface {
		CreateSurface(width, height int32) *cairo.Surface
	}); ok {
		pclass.create_surface = (*[0]byte)(C._gotk4_gdk3_WindowClass_create_surface)
	}

	if _, ok := goval.(interface {
		FromEmbedder(embedderX, embedderY float64, offscreenX, offscreenY *float64)
	}); ok {
		pclass.from_embedder = (*[0]byte)(C._gotk4_gdk3_WindowClass_from_embedder)
	}

	if _, ok := goval.(interface {
		ToEmbedder(offscreenX, offscreenY float64, embedderX, embedderY *float64)
	}); ok {
		pclass.to_embedder = (*[0]byte)(C._gotk4_gdk3_WindowClass_to_embedder)
	}
}

//export _gotk4_gdk3_WindowClass_create_surface
func _gotk4_gdk3_WindowClass_create_surface(arg0 *C.GdkWindow, arg1 C.gint, arg2 C.gint) (cret *C.cairo_surface_t) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		CreateSurface(width, height int32) *cairo.Surface
	})

	var _width int32  // out
	var _height int32 // out

	_width = int32(arg1)
	_height = int32(arg2)

	surface := iface.CreateSurface(_width, _height)

	cret = (*C.void)(unsafe.Pointer(surface.Native()))

	return cret
}

//export _gotk4_gdk3_WindowClass_from_embedder
func _gotk4_gdk3_WindowClass_from_embedder(arg0 *C.GdkWindow, arg1 C.gdouble, arg2 C.gdouble, arg3 *C.gdouble, arg4 *C.gdouble) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		FromEmbedder(embedderX, embedderY float64, offscreenX, offscreenY *float64)
	})

	var _embedderX float64   // out
	var _embedderY float64   // out
	var _offscreenX *float64 // out
	var _offscreenY *float64 // out

	_embedderX = float64(arg1)
	_embedderY = float64(arg2)
	_offscreenX = (*float64)(unsafe.Pointer(arg3))
	_offscreenY = (*float64)(unsafe.Pointer(arg4))

	iface.FromEmbedder(_embedderX, _embedderY, _offscreenX, _offscreenY)
}

//export _gotk4_gdk3_WindowClass_to_embedder
func _gotk4_gdk3_WindowClass_to_embedder(arg0 *C.GdkWindow, arg1 C.gdouble, arg2 C.gdouble, arg3 *C.gdouble, arg4 *C.gdouble) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ToEmbedder(offscreenX, offscreenY float64, embedderX, embedderY *float64)
	})

	var _offscreenX float64 // out
	var _offscreenY float64 // out
	var _embedderX *float64 // out
	var _embedderY *float64 // out

	_offscreenX = float64(arg1)
	_offscreenY = float64(arg2)
	_embedderX = (*float64)(unsafe.Pointer(arg3))
	_embedderY = (*float64)(unsafe.Pointer(arg4))

	iface.ToEmbedder(_offscreenX, _offscreenY, _embedderX, _embedderY)
}

func wrapWindow(obj *coreglib.Object) *Window {
	return &Window{
		Object: obj,
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	return wrapWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (window *Window) baseWindow() *Window {
	return window
}

// BaseWindow returns the underlying base object.
func BaseWindow(obj Windower) *Window {
	return obj.baseWindow()
}

//export _gotk4_gdk3_Window_ConnectCreateSurface
func _gotk4_gdk3_Window_ConnectCreateSurface(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.guintptr) (cret *C.cairo_surface_t) {
	var f func(width, height int32) (surface *cairo.Surface)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(width, height int32) (surface *cairo.Surface))
	}

	var _width int32  // out
	var _height int32 // out

	_width = int32(arg1)
	_height = int32(arg2)

	surface := f(_width, _height)

	cret = (*C.void)(unsafe.Pointer(surface.Native()))

	return cret
}

// ConnectCreateSurface signal is emitted when an offscreen window needs its
// surface (re)created, which happens either when the window is first drawn to,
// or when the window is being resized. The first signal handler that returns a
// non-NULL surface will stop any further signal emission, and its surface will
// be used.
//
// Note that it is not possible to access the window's previous surface from
// within any callback of this signal. Calling
// gdk_offscreen_window_get_surface() will lead to a crash.
func (window *Window) ConnectCreateSurface(f func(width, height int32) (surface *cairo.Surface)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "create-surface", false, unsafe.Pointer(C._gotk4_gdk3_Window_ConnectCreateSurface), f)
}

//export _gotk4_gdk3_Window_ConnectPickEmbeddedChild
func _gotk4_gdk3_Window_ConnectPickEmbeddedChild(arg0 C.gpointer, arg1 C.gdouble, arg2 C.gdouble, arg3 C.guintptr) (cret *C.GdkWindow) {
	var f func(x, y float64) (window Windower)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y float64) (window Windower))
	}

	var _x float64 // out
	var _y float64 // out

	_x = float64(arg1)
	_y = float64(arg2)

	window := f(_x, _y)

	if window != nil {
		cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	}

	return cret
}

// ConnectPickEmbeddedChild signal is emitted to find an embedded child at the
// given position.
func (window *Window) ConnectPickEmbeddedChild(f func(x, y float64) (window Windower)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "pick-embedded-child", false, unsafe.Pointer(C._gotk4_gdk3_Window_ConnectPickEmbeddedChild), f)
}

// NewWindow creates a new Window using the attributes from attributes. See
// WindowAttr and WindowAttributesType for more details. Note: to use this on
// displays other than the default display, parent must be specified.
//
// The function takes the following parameters:
//
//    - parent (optional) or NULL to create the window as a child of the default
//      root window for the default display.
//    - attributes of the new window.
//    - attributesMask: mask indicating which fields in attributes are valid.
//
// The function returns the following values:
//
//    - window: new Window.
//
func NewWindow(parent Windower, attributes *WindowAttr, attributesMask WindowAttributesType) *Window {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _cret *C.void // in

	if parent != nil {
		_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(attributes)))
	_arg2 = C.gint(attributesMask)
	*(*Windower)(unsafe.Pointer(&args[0])) = _arg0
	*(**WindowAttr)(unsafe.Pointer(&args[1])) = _arg1
	*(*WindowAttributesType)(unsafe.Pointer(&args[2])) = _arg2

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("new_Window", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(parent)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(attributesMask)

	var _window *Window // out

	_window = wrapWindow(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _window
}

// Beep emits a short beep associated to window in the appropriate display, if
// supported. Otherwise, emits a short beep on the display just as
// gdk_display_beep().
func (window *Window) Beep() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("beep", args[:], nil)

	runtime.KeepAlive(window)
}

// BeginDrawFrame indicates that you are beginning the process of redrawing
// region on window, and provides you with a DrawingContext.
//
// If window is a top level Window, backed by a native window implementation, a
// backing store (offscreen buffer) large enough to contain region will be
// created. The backing store will be initialized with the background color or
// background surface for window. Then, all drawing operations performed on
// window will be diverted to the backing store. When you call
// gdk_window_end_frame(), the contents of the backing store will be copied to
// window, making it visible on screen. Only the part of window contained in
// region will be modified; that is, drawing operations are clipped to region.
//
// The net result of all this is to remove flicker, because the user sees the
// finished product appear all at once when you call
// gdk_window_end_draw_frame(). If you draw to window directly without calling
// gdk_window_begin_draw_frame(), the user may see flicker as individual drawing
// operations are performed in sequence.
//
// When using GTK+, the widget system automatically places calls to
// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() around
// emissions of the GtkWidget::draw signal. That is, if you’re drawing the
// contents of the widget yourself, you can assume that the widget has a cleared
// background, is already set as the clip region, and already has a backing
// store. Therefore in most cases, application code in GTK does not need to call
// gdk_window_begin_draw_frame() explicitly.
//
// The function takes the following parameters:
//
//    - region: cairo region.
//
// The function returns the following values:
//
//    - drawingContext context that should be used to draw the contents of the
//      window; the returned context is owned by GDK.
//
func (window *Window) BeginDrawFrame(region *cairo.Region) *DrawingContext {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(region.Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("begin_draw_frame", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)
	runtime.KeepAlive(region)

	var _drawingContext *DrawingContext // out

	_drawingContext = wrapDrawingContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _drawingContext
}

// BeginMoveDrag begins a window move operation (for a toplevel window).
//
// This function assumes that the drag is controlled by the client pointer
// device, use gdk_window_begin_move_drag_for_device() to begin a drag with a
// different device.
//
// The function takes the following parameters:
//
//    - button being used to drag, or 0 for a keyboard-initiated drag.
//    - rootX: root window X coordinate of mouse click that began the drag.
//    - rootY: root window Y coordinate of mouse click that began the drag.
//    - timestamp of mouse click that began the drag.
//
func (window *Window) BeginMoveDrag(button, rootX, rootY int32, timestamp uint32) {
	var args [5]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.gint    // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _arg4 C.guint32 // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(button)
	_arg2 = C.gint(rootX)
	_arg3 = C.gint(rootY)
	_arg4 = C.guint32(timestamp)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3
	*(*int32)(unsafe.Pointer(&args[4])) = _arg4

	girepository.MustFind("Gdk", "Window").InvokeMethod("begin_move_drag", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(button)
	runtime.KeepAlive(rootX)
	runtime.KeepAlive(rootY)
	runtime.KeepAlive(timestamp)
}

// BeginMoveDragForDevice begins a window move operation (for a toplevel
// window). You might use this function to implement a “window move grip,” for
// example. The function works best with window managers that support the
// Extended Window Manager Hints (http://www.freedesktop.org/Standards/wm-spec)
// but has a fallback implementation for other window managers.
//
// The function takes the following parameters:
//
//    - device used for the operation.
//    - button being used to drag, or 0 for a keyboard-initiated drag.
//    - rootX: root window X coordinate of mouse click that began the drag.
//    - rootY: root window Y coordinate of mouse click that began the drag.
//    - timestamp of mouse click that began the drag.
//
func (window *Window) BeginMoveDragForDevice(device Devicer, button, rootX, rootY int32, timestamp uint32) {
	var args [6]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 *C.void   // out
	var _arg2 C.gint    // out
	var _arg3 C.gint    // out
	var _arg4 C.gint    // out
	var _arg5 C.guint32 // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = C.gint(button)
	_arg3 = C.gint(rootX)
	_arg4 = C.gint(rootY)
	_arg5 = C.guint32(timestamp)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*Devicer)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3
	*(*int32)(unsafe.Pointer(&args[4])) = _arg4
	*(*int32)(unsafe.Pointer(&args[5])) = _arg5

	girepository.MustFind("Gdk", "Window").InvokeMethod("begin_move_drag_for_device", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(device)
	runtime.KeepAlive(button)
	runtime.KeepAlive(rootX)
	runtime.KeepAlive(rootY)
	runtime.KeepAlive(timestamp)
}

// BeginPaintRect: convenience wrapper around gdk_window_begin_paint_region()
// which creates a rectangular region for you. See
// gdk_window_begin_paint_region() for details.
//
// Deprecated: Use gdk_window_begin_draw_frame() instead.
//
// The function takes the following parameters:
//
//    - rectangle you intend to draw to.
//
func (window *Window) BeginPaintRect(rectangle *Rectangle) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(rectangle)))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("begin_paint_rect", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(rectangle)
}

// BeginPaintRegion indicates that you are beginning the process of redrawing
// region. A backing store (offscreen buffer) large enough to contain region
// will be created. The backing store will be initialized with the background
// color or background surface for window. Then, all drawing operations
// performed on window will be diverted to the backing store. When you call
// gdk_window_end_paint(), the backing store will be copied to window, making it
// visible onscreen. Only the part of window contained in region will be
// modified; that is, drawing operations are clipped to region.
//
// The net result of all this is to remove flicker, because the user sees the
// finished product appear all at once when you call gdk_window_end_paint(). If
// you draw to window directly without calling gdk_window_begin_paint_region(),
// the user may see flicker as individual drawing operations are performed in
// sequence. The clipping and background-initializing features of
// gdk_window_begin_paint_region() are conveniences for the programmer, so you
// can avoid doing that work yourself.
//
// When using GTK+, the widget system automatically places calls to
// gdk_window_begin_paint_region() and gdk_window_end_paint() around emissions
// of the expose_event signal. That is, if you’re writing an expose event
// handler, you can assume that the exposed area in EventExpose has already been
// cleared to the window background, is already set as the clip region, and
// already has a backing store. Therefore in most cases, application code need
// not call gdk_window_begin_paint_region(). (You can disable the automatic
// calls around expose events on a widget-by-widget basis by calling
// gtk_widget_set_double_buffered().)
//
// If you call this function multiple times before calling the matching
// gdk_window_end_paint(), the backing stores are pushed onto a stack.
// gdk_window_end_paint() copies the topmost backing store onscreen, subtracts
// the topmost region from all other regions in the stack, and pops the stack.
// All drawing operations affect only the topmost backing store in the stack.
// One matching call to gdk_window_end_paint() is required for each call to
// gdk_window_begin_paint_region().
//
// Deprecated: Use gdk_window_begin_draw_frame() instead.
//
// The function takes the following parameters:
//
//    - region you intend to draw to.
//
func (window *Window) BeginPaintRegion(region *cairo.Region) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(region.Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("begin_paint_region", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(region)
}

// ConfigureFinished does nothing, present only for compatiblity.
//
// Deprecated: this function is no longer needed.
func (window *Window) ConfigureFinished() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("configure_finished", args[:], nil)

	runtime.KeepAlive(window)
}

// CreateGLContext creates a new GLContext matching the framebuffer format to
// the visual of the Window. The context is disconnected from any particular
// window or surface.
//
// If the creation of the GLContext failed, error will be set.
//
// Before using the returned GLContext, you will need to call
// gdk_gl_context_make_current() or gdk_gl_context_realize().
//
// The function returns the following values:
//
//    - glContext: newly created GLContext, or NULL on error.
//
func (window *Window) CreateGLContext() (GLContexter, error) {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in
	var _cerr *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("create_gl_context", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _glContext GLContexter // out
	var _goerr error           // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.GLContexter is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(GLContexter)
			return ok
		})
		rv, ok := casted.(GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
		}
		_glContext = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _glContext, _goerr
}

// Deiconify: attempt to deiconify (unminimize) window. On X11 the window
// manager may choose to ignore the request to deiconify. When using GTK+, use
// gtk_window_deiconify() instead of the Window variant. Or better yet, you
// probably want to use gtk_window_present_with_time(), which raises the window,
// focuses it, unminimizes it, and puts it on the current desktop.
func (window *Window) Deiconify() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("deiconify", args[:], nil)

	runtime.KeepAlive(window)
}

// Destroy destroys the window system resources associated with window and
// decrements window's reference count. The window system resources for all
// children of window are also destroyed, but the children’s reference counts
// are not decremented.
//
// Note that a window will not be destroyed automatically when its reference
// count reaches zero. You must call this function yourself before that happens.
func (window *Window) Destroy() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("destroy", args[:], nil)

	runtime.KeepAlive(window)
}

// EnableSynchronizedConfigure does nothing, present only for compatiblity.
//
// Deprecated: this function is no longer needed.
func (window *Window) EnableSynchronizedConfigure() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("enable_synchronized_configure", args[:], nil)

	runtime.KeepAlive(window)
}

// EndDrawFrame indicates that the drawing of the contents of window started
// with gdk_window_begin_frame() has been completed.
//
// This function will take care of destroying the DrawingContext.
//
// It is an error to call this function without a matching
// gdk_window_begin_frame() first.
//
// The function takes the following parameters:
//
//    - context created by gdk_window_begin_draw_frame().
//
func (window *Window) EndDrawFrame(context *DrawingContext) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("end_draw_frame", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(context)
}

// EndPaint indicates that the backing store created by the most recent call to
// gdk_window_begin_paint_region() should be copied onscreen and deleted,
// leaving the next-most-recent backing store or no backing store at all as the
// active paint region. See gdk_window_begin_paint_region() for full details.
//
// It is an error to call this function without a matching
// gdk_window_begin_paint_region() first.
func (window *Window) EndPaint() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("end_paint", args[:], nil)

	runtime.KeepAlive(window)
}

// EnsureNative tries to ensure that there is a window-system native window for
// this GdkWindow. This may fail in some situations, returning FALSE.
//
// Offscreen window and children of them can never have native windows.
//
// Some backends may not support native child windows.
//
// The function returns the following values:
//
//    - ok: TRUE if the window has a native window, FALSE otherwise.
//
func (window *Window) EnsureNative() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("ensure_native", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Flush: this function does nothing.
//
// Deprecated: since version 3.14.
func (window *Window) Flush() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("flush", args[:], nil)

	runtime.KeepAlive(window)
}

// Focus sets keyboard focus to window. In most cases,
// gtk_window_present_with_time() should be used on a Window, rather than
// calling this function.
//
// The function takes the following parameters:
//
//    - timestamp of the event triggering the window focus.
//
func (window *Window) Focus(timestamp uint32) {
	var args [2]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.guint32 // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.guint32(timestamp)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("focus", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(timestamp)
}

// FreezeToplevelUpdatesLibgtkOnly: temporarily freezes a window and all its
// descendants such that it won't receive expose events. The window will begin
// receiving expose events again when
// gdk_window_thaw_toplevel_updates_libgtk_only() is called. If
// gdk_window_freeze_toplevel_updates_libgtk_only() has been called more than
// once, gdk_window_thaw_toplevel_updates_libgtk_only() must be called an equal
// number of times to begin processing exposes.
//
// This function is not part of the GDK public API and is only for use by GTK+.
//
// Deprecated: This symbol was never meant to be used outside of GTK+.
func (window *Window) FreezeToplevelUpdatesLibgtkOnly() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("freeze_toplevel_updates_libgtk_only", args[:], nil)

	runtime.KeepAlive(window)
}

// FreezeUpdates: temporarily freezes a window such that it won’t receive expose
// events. The window will begin receiving expose events again when
// gdk_window_thaw_updates() is called. If gdk_window_freeze_updates() has been
// called more than once, gdk_window_thaw_updates() must be called an equal
// number of times to begin processing exposes.
func (window *Window) FreezeUpdates() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("freeze_updates", args[:], nil)

	runtime.KeepAlive(window)
}

// Fullscreen moves the window into fullscreen mode. This means the window
// covers the entire screen and is above any panels or task bars.
//
// If the window was already fullscreen, then this function does nothing.
//
// On X11, asks the window manager to put window in a fullscreen state, if the
// window manager supports this operation. Not all window managers support this,
// and some deliberately ignore it or don’t have a concept of “fullscreen”; so
// you can’t rely on the fullscreenification actually happening. But it will
// happen with most standard window managers, and GDK makes a best effort to get
// it to happen.
func (window *Window) Fullscreen() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("fullscreen", args[:], nil)

	runtime.KeepAlive(window)
}

// FullscreenOnMonitor moves the window into fullscreen mode on the given
// monitor. This means the window covers the entire screen and is above any
// panels or task bars.
//
// If the window was already fullscreen, then this function does nothing.
//
// The function takes the following parameters:
//
//    - monitor: which monitor to display fullscreen on.
//
func (window *Window) FullscreenOnMonitor(monitor int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(monitor)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("fullscreen_on_monitor", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(monitor)
}

// GeometryChanged: this function informs GDK that the geometry of an embedded
// offscreen window has changed. This is necessary for GDK to keep track of
// which offscreen window the pointer is in.
func (window *Window) GeometryChanged() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("geometry_changed", args[:], nil)

	runtime.KeepAlive(window)
}

// AcceptFocus determines whether or not the desktop environment shuld be hinted
// that the window does not want to receive input focus.
//
// The function returns the following values:
//
//    - ok: whether or not the window should receive input focus.
//
func (window *Window) AcceptFocus() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_accept_focus", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackgroundPattern gets the pattern used to clear the background on window.
//
// Deprecated: Don't use this function.
//
// The function returns the following values:
//
//    - pattern (optional) to use for the background or NULL if there is no
//      background.
//
func (window *Window) BackgroundPattern() *cairo.Pattern {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_background_pattern", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _pattern *cairo.Pattern // out

	if _cret != nil {
		{
			_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
			_pattern = (*cairo.Pattern)(unsafe.Pointer(_pp))
		}
		C.cairo_pattern_reference(_cret)
		runtime.SetFinalizer(_pattern, func(v *cairo.Pattern) {
			C.cairo_pattern_destroy((*C.void)(unsafe.Pointer(v.Native())))
		})
	}

	return _pattern
}

// Children gets the list of children of window known to GDK. This function only
// returns children created via GDK, so for example it’s useless when used with
// the root window; it only returns windows an application created itself.
//
// The returned list must be freed, but the elements in the list need not be.
//
// The function returns the following values:
//
//    - list: list of child windows inside window.
//
func (window *Window) Children() []Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_children", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _list []Windower // out

	_list = make([]Windower, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Windower // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gdk.Windower is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// ClipRegion computes the region of a window that potentially can be written to
// by drawing primitives. This region may not take into account other factors
// such as if the window is obscured by other windows, but no area outside of
// this region will be affected by drawing primitives.
//
// The function returns the following values:
//
//    - region This must be freed with cairo_region_destroy() when you are done.
//
func (window *Window) ClipRegion() *cairo.Region {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_clip_region", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _region *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
		_region = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	runtime.SetFinalizer(_region, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _region
}

// Composited determines whether window is composited.
//
// See gdk_window_set_composited().
//
// Deprecated: Compositing is an outdated technology that only ever worked on
// X11.
//
// The function returns the following values:
//
//    - ok: TRUE if the window is composited.
//
func (window *Window) Composited() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_composited", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Cursor retrieves a Cursor pointer for the cursor currently set on the
// specified Window, or NULL. If the return value is NULL then there is no
// custom cursor set on the specified window, and it is using the cursor for its
// parent window.
//
// The function returns the following values:
//
//    - cursor (optional) or NULL. The returned object is owned by the Window and
//      should not be unreferenced directly. Use gdk_window_set_cursor() to unset
//      the cursor of the window.
//
func (window *Window) Cursor() Cursorrer {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_cursor", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _cursor Cursorrer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Cursorrer)
				return ok
			})
			rv, ok := casted.(Cursorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Cursorrer")
			}
			_cursor = rv
		}
	}

	return _cursor
}

// DeviceCursor retrieves a Cursor pointer for the device currently set on the
// specified Window, or NULL. If the return value is NULL then there is no
// custom cursor set on the specified window, and it is using the cursor for its
// parent window.
//
// The function takes the following parameters:
//
//    - device: master, pointer Device.
//
// The function returns the following values:
//
//    - cursor (optional) or NULL. The returned object is owned by the Window and
//      should not be unreferenced directly. Use gdk_window_set_cursor() to unset
//      the cursor of the window.
//
func (window *Window) DeviceCursor(device Devicer) Cursorrer {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_device_cursor", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)
	runtime.KeepAlive(device)

	var _cursor Cursorrer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Cursorrer)
				return ok
			})
			rv, ok := casted.(Cursorrer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Cursorrer")
			}
			_cursor = rv
		}
	}

	return _cursor
}

// Display gets the Display associated with a Window.
//
// The function returns the following values:
//
//    - display associated with window.
//
func (window *Window) Display() *Display {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_display", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _display *Display // out

	_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))

	return _display
}

// EffectiveParent obtains the parent of window, as known to GDK. Works like
// gdk_window_get_parent() for normal windows, but returns the window’s embedder
// for offscreen windows.
//
// See also: gdk_offscreen_window_get_embedder().
//
// The function returns the following values:
//
//    - ret: effective parent of window.
//
func (window *Window) EffectiveParent() Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_effective_parent", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ret Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_ret = rv
	}

	return _ret
}

// EffectiveToplevel gets the toplevel window that’s an ancestor of window.
//
// Works like gdk_window_get_toplevel(), but treats an offscreen window's
// embedder as its parent, using gdk_window_get_effective_parent().
//
// See also: gdk_offscreen_window_get_embedder().
//
// The function returns the following values:
//
//    - ret: effective toplevel window containing window.
//
func (window *Window) EffectiveToplevel() Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_effective_toplevel", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ret Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_ret = rv
	}

	return _ret
}

// EventCompression: get the current event compression setting for this window.
//
// The function returns the following values:
//
//    - ok: TRUE if motion events will be compressed.
//
func (window *Window) EventCompression() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_event_compression", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FocusOnMap determines whether or not the desktop environment should be hinted
// that the window does not want to receive input focus when it is mapped.
//
// The function returns the following values:
//
//    - ok: whether or not the window wants to receive input focus when it is
//      mapped.
//
func (window *Window) FocusOnMap() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_focus_on_map", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FrameClock gets the frame clock for the window. The frame clock for a window
// never changes unless the window is reparented to a new toplevel window.
//
// The function returns the following values:
//
//    - frameClock: frame clock.
//
func (window *Window) FrameClock() FrameClocker {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_frame_clock", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _frameClock FrameClocker // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.FrameClocker is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(FrameClocker)
			return ok
		})
		rv, ok := casted.(FrameClocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.FrameClocker")
		}
		_frameClock = rv
	}

	return _frameClock
}

// Group returns the group leader window for window. See gdk_window_set_group().
//
// The function returns the following values:
//
//    - ret: group leader window for window.
//
func (window *Window) Group() Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_group", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ret Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_ret = rv
	}

	return _ret
}

// Height returns the height of the given window.
//
// On the X11 platform the returned size is the size reported in the
// most-recently-processed configure event, rather than the current size on the
// X server.
//
// The function returns the following values:
//
//    - gint: height of window.
//
func (window *Window) Height() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_height", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// ModalHint determines whether or not the window manager is hinted that window
// has modal behaviour.
//
// The function returns the following values:
//
//    - ok: whether or not the window has the modal hint set.
//
func (window *Window) ModalHint() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_modal_hint", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Parent obtains the parent of window, as known to GDK. Does not query the X
// server; thus this returns the parent as passed to gdk_window_new(), not the
// actual parent. This should never matter unless you’re using Xlib calls mixed
// with GDK calls on the X11 platform. It may also matter for toplevel windows,
// because the window manager may choose to reparent them.
//
// Note that you should use gdk_window_get_effective_parent() when writing
// generic code that walks up a window hierarchy, because
// gdk_window_get_parent() will most likely not do what you expect if there are
// offscreen windows in the hierarchy.
//
// The function returns the following values:
//
//    - ret: parent of window.
//
func (window *Window) Parent() Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_parent", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ret Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_ret = rv
	}

	return _ret
}

// PassThrough returns whether input to the window is passed through to the
// window below.
//
// See gdk_window_set_pass_through() for details.
//
// The function returns the following values:
//
func (window *Window) PassThrough() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_pass_through", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScaleFactor returns the internal scale factor that maps from window
// coordiantes to the actual device pixels. On traditional systems this is 1,
// but on very high density outputs this can be a higher value (often 2).
//
// A higher value means that drawing is automatically scaled up to a higher
// resolution, so any code doing drawing will automatically look nicer. However,
// if you are supplying pixel-based data the scale value can be used to
// determine whether to use a pixel resource with higher resolution data.
//
// The scale of a window may change during runtime, if this happens a configure
// event will be sent to the toplevel window.
//
// The function returns the following values:
//
//    - gint: scale factor.
//
func (window *Window) ScaleFactor() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_scale_factor", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Screen gets the Screen associated with a Window.
//
// The function returns the following values:
//
//    - screen associated with window.
//
func (window *Window) Screen() *Screen {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_screen", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _screen *Screen // out

	_screen = wrapScreen(coreglib.Take(unsafe.Pointer(_cret)))

	return _screen
}

// SupportMultidevice returns TRUE if the window is aware of the existence of
// multiple devices.
//
// The function returns the following values:
//
//    - ok: TRUE if the window handles multidevice features.
//
func (window *Window) SupportMultidevice() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_support_multidevice", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Toplevel gets the toplevel window that’s an ancestor of window.
//
// Any window type but GDK_WINDOW_CHILD is considered a toplevel window, as is a
// GDK_WINDOW_CHILD window that has a root window as parent.
//
// Note that you should use gdk_window_get_effective_toplevel() when you want to
// get to a window’s toplevel as seen on screen, because
// gdk_window_get_toplevel() will most likely not do what you expect if there
// are offscreen windows in the hierarchy.
//
// The function returns the following values:
//
//    - ret: toplevel window containing window.
//
func (window *Window) Toplevel() Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_toplevel", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ret Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Windower)
			return ok
		})
		rv, ok := casted.(Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_ret = rv
	}

	return _ret
}

// UpdateArea transfers ownership of the update area from window to the caller
// of the function. That is, after calling this function, window will no longer
// have an invalid/dirty region; the update area is removed from window and
// handed to you. If a window has no update area, gdk_window_get_update_area()
// returns NULL. You are responsible for calling cairo_region_destroy() on the
// returned region if it’s non-NULL.
//
// The function returns the following values:
//
//    - region: update area for window.
//
func (window *Window) UpdateArea() *cairo.Region {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_update_area", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _region *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
		_region = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	runtime.SetFinalizer(_region, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _region
}

// VisibleRegion computes the region of the window that is potentially visible.
// This does not necessarily take into account if the window is obscured by
// other windows, but no area outside of this region is visible.
//
// The function returns the following values:
//
//    - region This must be freed with cairo_region_destroy() when you are done.
//
func (window *Window) VisibleRegion() *cairo.Region {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_visible_region", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _region *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
		_region = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	runtime.SetFinalizer(_region, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _region
}

// Visual gets the Visual describing the pixel format of window.
//
// The function returns the following values:
//
//    - visual: Visual.
//
func (window *Window) Visual() *Visual {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_visual", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _visual *Visual // out

	_visual = wrapVisual(coreglib.Take(unsafe.Pointer(_cret)))

	return _visual
}

// Width returns the width of the given window.
//
// On the X11 platform the returned size is the size reported in the
// most-recently-processed configure event, rather than the current size on the
// X server.
//
// The function returns the following values:
//
//    - gint: width of window.
//
func (window *Window) Width() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("get_width", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// HasNative checks whether the window has a native window or not. Note that you
// can use gdk_window_ensure_native() if a native window is needed.
//
// The function returns the following values:
//
//    - ok: TRUE if the window has a native window, FALSE otherwise.
//
func (window *Window) HasNative() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("has_native", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide: for toplevel windows, withdraws them, so they will no longer be known
// to the window manager; for all windows, unmaps them, so they won’t be
// displayed. Normally done automatically as part of gtk_widget_hide().
func (window *Window) Hide() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("hide", args[:], nil)

	runtime.KeepAlive(window)
}

// Iconify asks to iconify (minimize) window. The window manager may choose to
// ignore the request, but normally will honor it. Using gtk_window_iconify() is
// preferred, if you have a Window widget.
//
// This function only makes sense when window is a toplevel window.
func (window *Window) Iconify() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("iconify", args[:], nil)

	runtime.KeepAlive(window)
}

// InputShapeCombineRegion: like gdk_window_shape_combine_region(), but the
// shape applies only to event handling. Mouse events which happen while the
// pointer position corresponds to an unset bit in the mask will be passed on
// the window below window.
//
// An input shape is typically used with RGBA windows. The alpha channel of the
// window defines which pixels are invisible and allows for nicely antialiased
// borders, and the input shape controls where the window is “clickable”.
//
// On the X11 platform, this requires version 1.1 of the shape extension.
//
// On the Win32 platform, this functionality is not present and the function
// does nothing.
//
// The function takes the following parameters:
//
//    - shapeRegion: region of window to be non-transparent.
//    - offsetX: x position of shape_region in window coordinates.
//    - offsetY: y position of shape_region in window coordinates.
//
func (window *Window) InputShapeCombineRegion(shapeRegion *cairo.Region, offsetX, offsetY int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(shapeRegion.Native()))
	_arg2 = C.gint(offsetX)
	_arg3 = C.gint(offsetY)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(**cairo.Region)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gdk", "Window").InvokeMethod("input_shape_combine_region", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(shapeRegion)
	runtime.KeepAlive(offsetX)
	runtime.KeepAlive(offsetY)
}

// InvalidateRect: convenience wrapper around gdk_window_invalidate_region()
// which invalidates a rectangular region. See gdk_window_invalidate_region()
// for details.
//
// The function takes the following parameters:
//
//    - rect (optional): rectangle to invalidate or NULL to invalidate the whole
//      window.
//    - invalidateChildren: whether to also invalidate child windows.
//
func (window *Window) InvalidateRect(rect *Rectangle, invalidateChildren bool) {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if rect != nil {
		_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(rect)))
	}
	if invalidateChildren {
		_arg2 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(**Rectangle)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gdk", "Window").InvokeMethod("invalidate_rect", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(rect)
	runtime.KeepAlive(invalidateChildren)
}

// InvalidateRegion adds region to the update area for window. The update area
// is the region that needs to be redrawn, or “dirty region.” The call
// gdk_window_process_updates() sends one or more expose events to the window,
// which together cover the entire update area. An application would normally
// redraw the contents of window in response to those expose events.
//
// GDK will call gdk_window_process_all_updates() on your behalf whenever your
// program returns to the main loop and becomes idle, so normally there’s no
// need to do that manually, you just need to invalidate regions that you know
// should be redrawn.
//
// The invalidate_children parameter controls whether the region of each child
// window that intersects region will also be invalidated. If FALSE, then the
// update area for child windows will remain unaffected. See
// gdk_window_invalidate_maybe_recurse if you need fine grained control over
// which children are invalidated.
//
// The function takes the following parameters:
//
//    - region: #cairo_region_t.
//    - invalidateChildren: TRUE to also invalidate child windows.
//
func (window *Window) InvalidateRegion(region *cairo.Region, invalidateChildren bool) {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(region.Native()))
	if invalidateChildren {
		_arg2 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(**cairo.Region)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gdk", "Window").InvokeMethod("invalidate_region", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(region)
	runtime.KeepAlive(invalidateChildren)
}

// IsDestroyed: check to see if a window is destroyed..
//
// The function returns the following values:
//
//    - ok: TRUE if the window is destroyed.
//
func (window *Window) IsDestroyed() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("is_destroyed", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsInputOnly determines whether or not the window is an input only window.
//
// The function returns the following values:
//
//    - ok: TRUE if window is input only.
//
func (window *Window) IsInputOnly() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("is_input_only", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsShaped determines whether or not the window is shaped.
//
// The function returns the following values:
//
//    - ok: TRUE if window is shaped.
//
func (window *Window) IsShaped() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("is_shaped", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsViewable: check if the window and all ancestors of the window are mapped.
// (This is not necessarily "viewable" in the X sense, since we only check as
// far as we have GDK window parents, not to the root window.).
//
// The function returns the following values:
//
//    - ok: TRUE if the window is viewable.
//
func (window *Window) IsViewable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("is_viewable", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVisible checks whether the window has been mapped (with gdk_window_show()
// or gdk_window_show_unraised()).
//
// The function returns the following values:
//
//    - ok: TRUE if the window is mapped.
//
func (window *Window) IsVisible() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("is_visible", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Lower lowers window to the bottom of the Z-order (stacking order), so that
// other windows with the same parent window appear above window. This is true
// whether or not the other windows are visible.
//
// If window is a toplevel, the window manager may choose to deny the request to
// move the window in the Z-order, gdk_window_lower() only requests the restack,
// does not guarantee it.
//
// Note that gdk_window_show() raises the window again, so don’t call this
// function before gdk_window_show(). (Try gdk_window_show_unraised().).
func (window *Window) Lower() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("lower", args[:], nil)

	runtime.KeepAlive(window)
}

// MarkPaintFromClip: if you call this during a paint (e.g. between
// gdk_window_begin_paint_region() and gdk_window_end_paint() then GDK will mark
// the current clip region of the window as being drawn. This is required when
// mixing GL rendering via gdk_cairo_draw_from_gl() and cairo rendering, as
// otherwise GDK has no way of knowing when something paints over the GL-drawn
// regions.
//
// This is typically called automatically by GTK+ and you don't need to care
// about this.
//
// The function takes the following parameters:
//
//    - cr: #cairo_t.
//
func (window *Window) MarkPaintFromClip(cr *cairo.Context) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(cr.Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("mark_paint_from_clip", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(cr)
}

// Maximize maximizes the window. If the window was already maximized, then this
// function does nothing.
//
// On X11, asks the window manager to maximize window, if the window manager
// supports this operation. Not all window managers support this, and some
// deliberately ignore it or don’t have a concept of “maximized”; so you can’t
// rely on the maximization actually happening. But it will happen with most
// standard window managers, and GDK makes a best effort to get it to happen.
//
// On Windows, reliably maximizes the window.
func (window *Window) Maximize() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("maximize", args[:], nil)

	runtime.KeepAlive(window)
}

// MergeChildInputShapes merges the input shape masks for any child windows into
// the input shape mask for window. i.e. the union of all input masks for window
// and its children will become the new input mask for window. See
// gdk_window_input_shape_combine_region().
//
// This function is distinct from gdk_window_set_child_input_shapes() because it
// includes window’s input shape mask in the set of shapes to be merged.
func (window *Window) MergeChildInputShapes() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("merge_child_input_shapes", args[:], nil)

	runtime.KeepAlive(window)
}

// MergeChildShapes merges the shape masks for any child windows into the shape
// mask for window. i.e. the union of all masks for window and its children will
// become the new mask for window. See gdk_window_shape_combine_region().
//
// This function is distinct from gdk_window_set_child_shapes() because it
// includes window’s shape mask in the set of shapes to be merged.
func (window *Window) MergeChildShapes() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("merge_child_shapes", args[:], nil)

	runtime.KeepAlive(window)
}

// Move repositions a window relative to its parent window. For toplevel
// windows, window managers may ignore or modify the move; you should probably
// use gtk_window_move() on a Window widget anyway, instead of using GDK
// functions. For child windows, the move will reliably succeed.
//
// If you’re also planning to resize the window, use gdk_window_move_resize() to
// both move and resize simultaneously, for a nicer visual effect.
//
// The function takes the following parameters:
//
//    - x: x coordinate relative to window’s parent.
//    - y: y coordinate relative to window’s parent.
//
func (window *Window) Move(x, y int32) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gdk", "Window").InvokeMethod("move", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// MoveRegion: move the part of window indicated by region by dy pixels in the Y
// direction and dx pixels in the X direction. The portions of region that not
// covered by the new position of region are invalidated.
//
// Child windows are not moved.
//
// The function takes the following parameters:
//
//    - region to move.
//    - dx: amount to move in the X direction.
//    - dy: amount to move in the Y direction.
//
func (window *Window) MoveRegion(region *cairo.Region, dx, dy int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(region.Native()))
	_arg2 = C.gint(dx)
	_arg3 = C.gint(dy)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(**cairo.Region)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gdk", "Window").InvokeMethod("move_region", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(region)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
}

// MoveResize: equivalent to calling gdk_window_move() and gdk_window_resize(),
// except that both operations are performed at once, avoiding strange visual
// effects. (i.e. the user may be able to see the window first move, then
// resize, if you don’t use gdk_window_move_resize().).
//
// The function takes the following parameters:
//
//    - x: new X position relative to window’s parent.
//    - y: new Y position relative to window’s parent.
//    - width: new width.
//    - height: new height.
//
func (window *Window) MoveResize(x, y, width, height int32) {
	var args [5]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out
	var _arg4 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.gint(width)
	_arg4 = C.gint(height)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3
	*(*int32)(unsafe.Pointer(&args[4])) = _arg4

	girepository.MustFind("Gdk", "Window").InvokeMethod("move_resize", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// PeekChildren: like gdk_window_get_children(), but does not copy the list of
// children, so the list does not need to be freed.
//
// The function returns the following values:
//
//    - list: a reference to the list of child windows in window.
//
func (window *Window) PeekChildren() []Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("peek_children", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _list []Windower // out

	_list = make([]Windower, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Windower // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gdk.Windower is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Windower)
				return ok
			})
			rv, ok := casted.(Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// ProcessUpdates sends one or more expose events to window. The areas in each
// expose event will cover the entire update area for the window (see
// gdk_window_invalidate_region() for details). Normally GDK calls
// gdk_window_process_all_updates() on your behalf, so there’s no need to call
// this function unless you want to force expose events to be delivered
// immediately and synchronously (vs. the usual case, where GDK delivers them in
// an idle handler). Occasionally this is useful to produce nicer scrolling
// behavior, for example.
//
// Deprecated: since version 3.22.
//
// The function takes the following parameters:
//
//    - updateChildren: whether to also process updates for child windows.
//
func (window *Window) ProcessUpdates(updateChildren bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if updateChildren {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("process_updates", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(updateChildren)
}

// Raise raises window to the top of the Z-order (stacking order), so that other
// windows with the same parent window appear below window. This is true whether
// or not the windows are visible.
//
// If window is a toplevel, the window manager may choose to deny the request to
// move the window in the Z-order, gdk_window_raise() only requests the restack,
// does not guarantee it.
func (window *Window) Raise() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("raise", args[:], nil)

	runtime.KeepAlive(window)
}

// RegisterDND registers a window as a potential drop destination.
func (window *Window) RegisterDND() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("register_dnd", args[:], nil)

	runtime.KeepAlive(window)
}

// Reparent reparents window into the given new_parent. The window being
// reparented will be unmapped as a side effect.
//
// The function takes the following parameters:
//
//    - newParent: new parent to move window into.
//    - x: x location inside the new parent.
//    - y: y location inside the new parent.
//
func (window *Window) Reparent(newParent Windower, x, y int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(newParent).Native()))
	_arg2 = C.gint(x)
	_arg3 = C.gint(y)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*Windower)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gdk", "Window").InvokeMethod("reparent", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(newParent)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// Resize resizes window; for toplevel windows, asks the window manager to
// resize the window. The window manager may not allow the resize. When using
// GTK+, use gtk_window_resize() instead of this low-level GDK function.
//
// Windows may not be resized below 1x1.
//
// If you’re also planning to move the window, use gdk_window_move_resize() to
// both move and resize simultaneously, for a nicer visual effect.
//
// The function takes the following parameters:
//
//    - width: new width of the window.
//    - height: new height of the window.
//
func (window *Window) Resize(width, height int32) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gdk", "Window").InvokeMethod("resize", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// Restack changes the position of window in the Z-order (stacking order), so
// that it is above sibling (if above is TRUE) or below sibling (if above is
// FALSE).
//
// If sibling is NULL, then this either raises (if above is TRUE) or lowers the
// window.
//
// If window is a toplevel, the window manager may choose to deny the request to
// move the window in the Z-order, gdk_window_restack() only requests the
// restack, does not guarantee it.
//
// The function takes the following parameters:
//
//    - sibling (optional) that is a sibling of window, or NULL.
//    - above: boolean.
//
func (window *Window) Restack(sibling Windower, above bool) {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if sibling != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))
	}
	if above {
		_arg2 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*Windower)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gdk", "Window").InvokeMethod("restack", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(sibling)
	runtime.KeepAlive(above)
}

// Scroll the contents of window, both pixels and children, by the given amount.
// window itself does not move. Portions of the window that the scroll operation
// brings in from offscreen areas are invalidated. The invalidated region may be
// bigger than what would strictly be necessary.
//
// For X11, a minimum area will be invalidated if the window has no subwindows,
// or if the edges of the window’s parent do not extend beyond the edges of the
// window. In other cases, a multi-step process is used to scroll the window
// which may produce temporary visual artifacts and unnecessary invalidations.
//
// The function takes the following parameters:
//
//    - dx: amount to scroll in the X direction.
//    - dy: amount to scroll in the Y direction.
//
func (window *Window) Scroll(dx, dy int32) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(dx)
	_arg2 = C.gint(dy)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gdk", "Window").InvokeMethod("scroll", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
}

// SetAcceptFocus: setting accept_focus to FALSE hints the desktop environment
// that the window doesn’t want to receive input focus.
//
// On X, it is the responsibility of the window manager to interpret this hint.
// ICCCM-compliant window manager usually respect it.
//
// The function takes the following parameters:
//
//    - acceptFocus: TRUE if the window should receive input focus.
//
func (window *Window) SetAcceptFocus(acceptFocus bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if acceptFocus {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_accept_focus", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(acceptFocus)
}

// SetBackground sets the background color of window.
//
// However, when using GTK+, influence the background of a widget using a style
// class or CSS — if you’re an application — or with
// gtk_style_context_set_background() — if you're implementing a custom widget.
//
// Deprecated: Don't use this function.
//
// The function takes the following parameters:
//
//    - color: Color.
//
func (window *Window) SetBackground(color *Color) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_background", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(color)
}

// SetBackgroundPattern sets the background of window.
//
// A background of NULL means that the window won't have any background. On the
// X11 backend it's also possible to inherit the background from the parent
// window using gdk_x11_get_parent_relative_pattern().
//
// The windowing system will normally fill a window with its background when the
// window is obscured then exposed.
//
// Deprecated: Don't use this function.
//
// The function takes the following parameters:
//
//    - pattern (optional) to use, or NULL.
//
func (window *Window) SetBackgroundPattern(pattern *cairo.Pattern) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if pattern != nil {
		_arg1 = (*C.void)(unsafe.Pointer(pattern.Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_background_pattern", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(pattern)
}

// SetBackgroundRGBA sets the background color of window.
//
// See also gdk_window_set_background_pattern().
//
// Deprecated: Don't use this function.
//
// The function takes the following parameters:
//
//    - rgba: RGBA color.
//
func (window *Window) SetBackgroundRGBA(rgba *RGBA) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(rgba)))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_background_rgba", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(rgba)
}

// SetChildInputShapes sets the input shape mask of window to the union of input
// shape masks for all children of window, ignoring the input shape mask of
// window itself. Contrast with gdk_window_merge_child_input_shapes() which
// includes the input shape mask of window in the masks to be merged.
func (window *Window) SetChildInputShapes() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_child_input_shapes", args[:], nil)

	runtime.KeepAlive(window)
}

// SetChildShapes sets the shape mask of window to the union of shape masks for
// all children of window, ignoring the shape mask of window itself. Contrast
// with gdk_window_merge_child_shapes() which includes the shape mask of window
// in the masks to be merged.
func (window *Window) SetChildShapes() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_child_shapes", args[:], nil)

	runtime.KeepAlive(window)
}

// SetComposited sets a Window as composited, or unsets it. Composited windows
// do not automatically have their contents drawn to the screen. Drawing is
// redirected to an offscreen buffer and an expose event is emitted on the
// parent of the composited window. It is the responsibility of the parent’s
// expose handler to manually merge the off-screen content onto the screen in
// whatever way it sees fit.
//
// It only makes sense for child windows to be composited; see
// gdk_window_set_opacity() if you need translucent toplevel windows.
//
// An additional effect of this call is that the area of this window is no
// longer clipped from regions marked for invalidation on its parent. Draws done
// on the parent window are also no longer clipped by the child.
//
// This call is only supported on some systems (currently, only X11 with new
// enough Xcomposite and Xdamage extensions). You must call
// gdk_display_supports_composite() to check if setting a window as composited
// is supported before attempting to do so.
//
// Deprecated: Compositing is an outdated technology that only ever worked on
// X11.
//
// The function takes the following parameters:
//
//    - composited: TRUE to set the window as composited.
//
func (window *Window) SetComposited(composited bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if composited {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_composited", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(composited)
}

// SetCursor sets the default mouse pointer for a Window.
//
// Note that cursor must be for the same display as window.
//
// Use gdk_cursor_new_for_display() or gdk_cursor_new_from_pixbuf() to create
// the cursor. To make the cursor invisible, use GDK_BLANK_CURSOR. Passing NULL
// for the cursor argument to gdk_window_set_cursor() means that window will use
// the cursor of its parent window. Most windows should use this default.
//
// The function takes the following parameters:
//
//    - cursor (optional): cursor.
//
func (window *Window) SetCursor(cursor Cursorrer) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if cursor != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_cursor", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(cursor)
}

// SetDeviceCursor sets a specific Cursor for a given device when it gets inside
// window. Use gdk_cursor_new_for_display() or gdk_cursor_new_from_pixbuf() to
// create the cursor. To make the cursor invisible, use GDK_BLANK_CURSOR.
// Passing NULL for the cursor argument to gdk_window_set_cursor() means that
// window will use the cursor of its parent window. Most windows should use this
// default.
//
// The function takes the following parameters:
//
//    - device: master, pointer Device.
//    - cursor: Cursor.
//
func (window *Window) SetDeviceCursor(device Devicer, cursor Cursorrer) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*Devicer)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_device_cursor", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(device)
	runtime.KeepAlive(cursor)
}

// SetEventCompression determines whether or not extra unprocessed motion events
// in the event queue can be discarded. If TRUE only the most recent event will
// be delivered.
//
// Some types of applications, e.g. paint programs, need to see all motion
// events and will benefit from turning off event compression.
//
// By default, event compression is enabled.
//
// The function takes the following parameters:
//
//    - eventCompression: TRUE if motion events should be compressed.
//
func (window *Window) SetEventCompression(eventCompression bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if eventCompression {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_event_compression", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(eventCompression)
}

// SetFocusOnMap: setting focus_on_map to FALSE hints the desktop environment
// that the window doesn’t want to receive input focus when it is mapped.
// focus_on_map should be turned off for windows that aren’t triggered
// interactively (such as popups from network activity).
//
// On X, it is the responsibility of the window manager to interpret this hint.
// Window managers following the freedesktop.org window manager extension
// specification should respect it.
//
// The function takes the following parameters:
//
//    - focusOnMap: TRUE if the window should receive input focus when mapped.
//
func (window *Window) SetFocusOnMap(focusOnMap bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if focusOnMap {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_focus_on_map", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(focusOnMap)
}

// SetGroup sets the group leader window for window. By default, GDK sets the
// group leader for all toplevel windows to a global window implicitly created
// by GDK. With this function you can override this default.
//
// The group leader window allows the window manager to distinguish all windows
// that belong to a single application. It may for example allow users to
// minimize/unminimize all windows belonging to an application at once. You
// should only set a non-default group window if your application pretends to be
// multiple applications.
//
// The function takes the following parameters:
//
//    - leader (optional): group leader window, or NULL to restore the default
//      group leader window.
//
func (window *Window) SetGroup(leader Windower) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if leader != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(leader).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_group", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(leader)
}

// SetIconList sets a list of icons for the window. One of these will be used to
// represent the window when it has been iconified. The icon is usually shown in
// an icon box or some sort of task bar. Which icon size is shown depends on the
// window manager. The window manager can scale the icon but setting several
// size icons can give better image quality since the window manager may only
// need to scale the icon by a small amount or not at all.
//
// Note that some platforms don't support window icons.
//
// The function takes the following parameters:
//
//    - pixbufs: A list of pixbufs, of different sizes.
//
func (window *Window) SetIconList(pixbufs []*gdkpixbuf.Pixbuf) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	for i := len(pixbufs) - 1; i >= 0; i-- {
		src := pixbufs[i]
		var dst *C.void // out
		dst = (*C.void)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_icon_list", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(pixbufs)
}

// SetIconName windows may have a name used while minimized, distinct from the
// name they display in their titlebar. Most of the time this is a bad idea from
// a user interface standpoint. But you can set such a name with this function,
// if you like.
//
// After calling this with a non-NULL name, calls to gdk_window_set_title() will
// not update the icon title.
//
// Using NULL for name unsets the icon title; further calls to
// gdk_window_set_title() will again update the icon title as well.
//
// Note that some platforms don't support window icons.
//
// The function takes the following parameters:
//
//    - name (optional) of window while iconified (minimized).
//
func (window *Window) SetIconName(name string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if name != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_icon_name", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(name)
}

// SetKeepAbove: set if window must be kept above other windows. If the window
// was already above, then this function does nothing.
//
// On X11, asks the window manager to keep window above, if the window manager
// supports this operation. Not all window managers support this, and some
// deliberately ignore it or don’t have a concept of “keep above”; so you can’t
// rely on the window being kept above. But it will happen with most standard
// window managers, and GDK makes a best effort to get it to happen.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window above other windows.
//
func (window *Window) SetKeepAbove(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_keep_above", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetKeepBelow: set if window must be kept below other windows. If the window
// was already below, then this function does nothing.
//
// On X11, asks the window manager to keep window below, if the window manager
// supports this operation. Not all window managers support this, and some
// deliberately ignore it or don’t have a concept of “keep below”; so you can’t
// rely on the window being kept below. But it will happen with most standard
// window managers, and GDK makes a best effort to get it to happen.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window below other windows.
//
func (window *Window) SetKeepBelow(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_keep_below", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetModalHint: application can use this hint to tell the window manager that a
// certain window has modal behaviour. The window manager can use this
// information to handle modal windows in a special way.
//
// You should only use this on windows for which you have previously called
// gdk_window_set_transient_for().
//
// The function takes the following parameters:
//
//    - modal: TRUE if the window is modal, FALSE otherwise.
//
func (window *Window) SetModalHint(modal bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if modal {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_modal_hint", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(modal)
}

// SetOpacity: set window to render as partially transparent, with opacity 0
// being fully transparent and 1 fully opaque. (Values of the opacity parameter
// are clamped to the [0,1] range.)
//
// For toplevel windows this depends on support from the windowing system that
// may not always be there. For instance, On X11, this works only on X screens
// with a compositing manager running. On Wayland, there is no per-window
// opacity value that the compositor would apply. Instead, use
// gdk_window_set_opaque_region (window, NULL) to tell the compositor that the
// entire window is (potentially) non-opaque, and draw your content with alpha,
// or use gtk_widget_set_opacity() to set an overall opacity for your widgets.
//
// For child windows this function only works for non-native windows.
//
// For setting up per-pixel alpha topelevels, see gdk_screen_get_rgba_visual(),
// and for non-toplevels, see gdk_window_set_composited().
//
// Support for non-toplevel windows was added in 3.8.
//
// The function takes the following parameters:
//
//    - opacity: opacity.
//
func (window *Window) SetOpacity(opacity float64) {
	var args [2]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.gdouble // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gdouble(opacity)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_opacity", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(opacity)
}

// SetOpaqueRegion: for optimisation purposes, compositing window managers may
// like to not draw obscured regions of windows, or turn off blending during for
// these regions. With RGB windows with no transparency, this is just the shape
// of the window, but with ARGB32 windows, the compositor does not know what
// regions of the window are transparent or not.
//
// This function only works for toplevel windows.
//
// GTK+ will update this property automatically if the window background is
// opaque, as we know where the opaque regions are. If your window background is
// not opaque, please update this property in your Widget::style-updated
// handler.
//
// The function takes the following parameters:
//
//    - region (optional): region, or NULL.
//
func (window *Window) SetOpaqueRegion(region *cairo.Region) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if region != nil {
		_arg1 = (*C.void)(unsafe.Pointer(region.Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_opaque_region", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(region)
}

// SetOverrideRedirect: override redirect window is not under the control of the
// window manager. This means it won’t have a titlebar, won’t be minimizable,
// etc. - it will be entirely under the control of the application. The window
// manager can’t see the override redirect window at all.
//
// Override redirect should only be used for short-lived temporary windows, such
// as popup menus. Menu uses an override redirect window in its implementation,
// for example.
//
// The function takes the following parameters:
//
//    - overrideRedirect: TRUE if window should be override redirect.
//
func (window *Window) SetOverrideRedirect(overrideRedirect bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if overrideRedirect {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_override_redirect", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(overrideRedirect)
}

// SetPassThrough sets whether input to the window is passed through to the
// window below.
//
// The default value of this is FALSE, which means that pointer events that
// happen inside the window are send first to the window, but if the event is
// not selected by the event mask then the event is sent to the parent window,
// and so on up the hierarchy.
//
// If pass_through is TRUE then such pointer events happen as if the window
// wasn't there at all, and thus will be sent first to any windows below window.
// This is useful if the window is used in a transparent fashion. In the
// terminology of the web this would be called "pointer-events: none".
//
// Note that a window with pass_through TRUE can still have a subwindow without
// pass through, so you can get events on a subset of a window. And in that
// cases you would get the in-between related events such as the pointer
// enter/leave events on its way to the destination window.
//
// The function takes the following parameters:
//
//    - passThrough: boolean.
//
func (window *Window) SetPassThrough(passThrough bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if passThrough {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_pass_through", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(passThrough)
}

// SetRole: when using GTK+, typically you should use gtk_window_set_role()
// instead of this low-level function.
//
// The window manager and session manager use a window’s role to distinguish it
// from other kinds of window in the same application. When an application is
// restarted after being saved in a previous session, all windows with the same
// title and role are treated as interchangeable. So if you have two windows
// with the same title that should be distinguished for session management
// purposes, you should set the role on those windows. It doesn’t matter what
// string you use for the role, as long as you have a different role for each
// non-interchangeable kind of window.
//
// The function takes the following parameters:
//
//    - role: string indicating its role.
//
func (window *Window) SetRole(role string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(role)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_role", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(role)
}

// SetShadowWidth: newer GTK+ windows using client-side decorations use extra
// geometry around their frames for effects like shadows and invisible borders.
// Window managers that want to maximize windows or snap to edges need to know
// where the extents of the actual frame lie, so that users don’t feel like
// windows are snapping against random invisible edges.
//
// Note that this property is automatically updated by GTK+, so this function
// should only be used by applications which do not use GTK+ to create toplevel
// windows.
//
// The function takes the following parameters:
//
//    - left extent.
//    - right extent.
//    - top extent.
//    - bottom extent.
//
func (window *Window) SetShadowWidth(left, right, top, bottom int32) {
	var args [5]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out
	var _arg4 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.gint(left)
	_arg2 = C.gint(right)
	_arg3 = C.gint(top)
	_arg4 = C.gint(bottom)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3
	*(*int32)(unsafe.Pointer(&args[4])) = _arg4

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_shadow_width", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(left)
	runtime.KeepAlive(right)
	runtime.KeepAlive(top)
	runtime.KeepAlive(bottom)
}

// SetSkipPagerHint toggles whether a window should appear in a pager (workspace
// switcher, or other desktop utility program that displays a small thumbnail
// representation of the windows on the desktop). If a window’s semantic type as
// specified with gdk_window_set_type_hint() already fully describes the window,
// this function should not be called in addition, instead you should allow the
// window to be treated according to standard policy for its semantic type.
//
// The function takes the following parameters:
//
//    - skipsPager: TRUE to skip the pager.
//
func (window *Window) SetSkipPagerHint(skipsPager bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if skipsPager {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_skip_pager_hint", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(skipsPager)
}

// SetSkipTaskbarHint toggles whether a window should appear in a task list or
// window list. If a window’s semantic type as specified with
// gdk_window_set_type_hint() already fully describes the window, this function
// should not be called in addition, instead you should allow the window to be
// treated according to standard policy for its semantic type.
//
// The function takes the following parameters:
//
//    - skipsTaskbar: TRUE to skip the taskbar.
//
func (window *Window) SetSkipTaskbarHint(skipsTaskbar bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if skipsTaskbar {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_skip_taskbar_hint", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(skipsTaskbar)
}

// SetStartupID: when using GTK+, typically you should use
// gtk_window_set_startup_id() instead of this low-level function.
//
// The function takes the following parameters:
//
//    - startupId: string with startup-notification identifier.
//
func (window *Window) SetStartupID(startupId string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_startup_id", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(startupId)
}

// SetStaticGravities: used to set the bit gravity of the given window to
// static, and flag it so all children get static subwindow gravity. This is
// used if you are implementing scary features that involve deep knowledge of
// the windowing system. Don’t worry about it.
//
// Deprecated: static gravities haven't worked on anything but X11 for a long
// time.
//
// The function takes the following parameters:
//
//    - useStatic: TRUE to turn on static gravity.
//
// The function returns the following values:
//
//    - ok: FALSE.
//
func (window *Window) SetStaticGravities(useStatic bool) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if useStatic {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("set_static_gravities", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)
	runtime.KeepAlive(useStatic)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSupportMultidevice: this function will enable multidevice features in
// window.
//
// Multidevice aware windows will need to handle properly multiple, per device
// enter/leave events, device grabs and grab ownerships.
//
// The function takes the following parameters:
//
//    - supportMultidevice: TRUE to enable multidevice support in window.
//
func (window *Window) SetSupportMultidevice(supportMultidevice bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if supportMultidevice {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_support_multidevice", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(supportMultidevice)
}

// SetTitle sets the title of a toplevel window, to be displayed in the
// titlebar. If you haven’t explicitly set the icon name for the window (using
// gdk_window_set_icon_name()), the icon name will be set to title as well.
// title must be in UTF-8 encoding (as with all user-readable strings in
// GDK/GTK+). title may not be NULL.
//
// The function takes the following parameters:
//
//    - title of window.
//
func (window *Window) SetTitle(title string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_title", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(title)
}

// SetTransientFor indicates to the window manager that window is a transient
// dialog associated with the application window parent. This allows the window
// manager to do things like center window on parent and keep window above
// parent.
//
// See gtk_window_set_transient_for() if you’re using Window or Dialog.
//
// The function takes the following parameters:
//
//    - parent: another toplevel Window.
//
func (window *Window) SetTransientFor(parent Windower) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_transient_for", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(parent)
}

// SetUrgencyHint toggles whether a window needs the user's urgent attention.
//
// The function takes the following parameters:
//
//    - urgent: TRUE if the window is urgent.
//
func (window *Window) SetUrgencyHint(urgent bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if urgent {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "Window").InvokeMethod("set_urgency_hint", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(urgent)
}

// ShapeCombineRegion makes pixels in window outside shape_region be
// transparent, so that the window may be nonrectangular.
//
// If shape_region is NULL, the shape will be unset, so the whole window will be
// opaque again. offset_x and offset_y are ignored if shape_region is NULL.
//
// On the X11 platform, this uses an X server extension which is widely
// available on most common platforms, but not available on very old X servers,
// and occasionally the implementation will be buggy. On servers without the
// shape extension, this function will do nothing.
//
// This function works on both toplevel and child windows.
//
// The function takes the following parameters:
//
//    - shapeRegion (optional): region of window to be non-transparent.
//    - offsetX: x position of shape_region in window coordinates.
//    - offsetY: y position of shape_region in window coordinates.
//
func (window *Window) ShapeCombineRegion(shapeRegion *cairo.Region, offsetX, offsetY int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if shapeRegion != nil {
		_arg1 = (*C.void)(unsafe.Pointer(shapeRegion.Native()))
	}
	_arg2 = C.gint(offsetX)
	_arg3 = C.gint(offsetY)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(**cairo.Region)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gdk", "Window").InvokeMethod("shape_combine_region", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(shapeRegion)
	runtime.KeepAlive(offsetX)
	runtime.KeepAlive(offsetY)
}

// Show: like gdk_window_show_unraised(), but also raises the window to the top
// of the window stack (moves the window to the front of the Z-order).
//
// This function maps a window so it’s visible onscreen. Its opposite is
// gdk_window_hide().
//
// When implementing a Widget, you should call this function on the widget's
// Window as part of the “map” method.
func (window *Window) Show() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("show", args[:], nil)

	runtime.KeepAlive(window)
}

// ShowUnraised shows a Window onscreen, but does not modify its stacking order.
// In contrast, gdk_window_show() will raise the window to the top of the window
// stack.
//
// On the X11 platform, in Xlib terms, this function calls XMapWindow() (it also
// updates some internal GDK state, which means that you can’t really use
// XMapWindow() directly on a GDK window).
func (window *Window) ShowUnraised() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("show_unraised", args[:], nil)

	runtime.KeepAlive(window)
}

// ShowWindowMenu asks the windowing system to show the window menu. The window
// menu is the menu shown when right-clicking the titlebar on traditional
// windows managed by the window manager. This is useful for windows using
// client-side decorations, activating it with a right-click on the window
// decorations.
//
// The function takes the following parameters:
//
//    - event to show the menu for.
//
// The function returns the following values:
//
//    - ok: TRUE if the window menu was shown and FALSE otherwise.
//
func (window *Window) ShowWindowMenu(event *Event) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(event)))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gdk", "Window").InvokeMethod("show_window_menu", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stick: “Pins” a window such that it’s on all workspaces and does not scroll
// with viewports, for window managers that have scrollable viewports. (When
// using Window, gtk_window_stick() may be more useful.)
//
// On the X11 platform, this function depends on window manager support, so may
// have no effect with many window managers. However, GDK will do the best it
// can to convince the window manager to stick the window. For window managers
// that don’t support this operation, there’s nothing you can do to force it to
// happen.
func (window *Window) Stick() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("stick", args[:], nil)

	runtime.KeepAlive(window)
}

// ThawToplevelUpdatesLibgtkOnly thaws a window frozen with
// gdk_window_freeze_toplevel_updates_libgtk_only().
//
// This function is not part of the GDK public API and is only for use by GTK+.
//
// Deprecated: This symbol was never meant to be used outside of GTK+.
func (window *Window) ThawToplevelUpdatesLibgtkOnly() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("thaw_toplevel_updates_libgtk_only", args[:], nil)

	runtime.KeepAlive(window)
}

// ThawUpdates thaws a window frozen with gdk_window_freeze_updates().
func (window *Window) ThawUpdates() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("thaw_updates", args[:], nil)

	runtime.KeepAlive(window)
}

// Unfullscreen moves the window out of fullscreen mode. If the window was not
// fullscreen, does nothing.
//
// On X11, asks the window manager to move window out of the fullscreen state,
// if the window manager supports this operation. Not all window managers
// support this, and some deliberately ignore it or don’t have a concept of
// “fullscreen”; so you can’t rely on the unfullscreenification actually
// happening. But it will happen with most standard window managers, and GDK
// makes a best effort to get it to happen.
func (window *Window) Unfullscreen() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("unfullscreen", args[:], nil)

	runtime.KeepAlive(window)
}

// Unmaximize unmaximizes the window. If the window wasn’t maximized, then this
// function does nothing.
//
// On X11, asks the window manager to unmaximize window, if the window manager
// supports this operation. Not all window managers support this, and some
// deliberately ignore it or don’t have a concept of “maximized”; so you can’t
// rely on the unmaximization actually happening. But it will happen with most
// standard window managers, and GDK makes a best effort to get it to happen.
//
// On Windows, reliably unmaximizes the window.
func (window *Window) Unmaximize() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("unmaximize", args[:], nil)

	runtime.KeepAlive(window)
}

// Unstick: reverse operation for gdk_window_stick(); see gdk_window_stick(),
// and gtk_window_unstick().
func (window *Window) Unstick() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("unstick", args[:], nil)

	runtime.KeepAlive(window)
}

// Withdraw withdraws a window (unmaps it and asks the window manager to forget
// about it). This function is not really useful as gdk_window_hide()
// automatically withdraws toplevel windows before hiding them.
func (window *Window) Withdraw() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "Window").InvokeMethod("withdraw", args[:], nil)

	runtime.KeepAlive(window)
}

// WindowProcessAllUpdates calls gdk_window_process_updates() for all windows
// (see Window) in the application.
//
// Deprecated: since version 3.22.
func WindowProcessAllUpdates() {
	girepository.MustFind("Gdk", "process_all_updates").Invoke(nil, nil)
}

// WindowSetDebugUpdates: with update debugging enabled, calls to
// gdk_window_invalidate_region() clear the invalidated region of the screen to
// a noticeable color, and GDK pauses for a short time before sending exposes to
// windows during gdk_window_process_updates(). The net effect is that you can
// see the invalid region for each window and watch redraws as they occur. This
// allows you to diagnose inefficiencies in your application.
//
// In essence, because the GDK rendering model prevents all flicker, if you are
// redrawing the same region 400 times you may never notice, aside from noticing
// a speed problem. Enabling update debugging causes GTK to flicker slowly and
// noticeably, so you can see exactly what’s being redrawn when, in what order.
//
// The --gtk-debug=updates command line option passed to GTK+ programs enables
// this debug option at application startup time. That's usually more useful
// than calling gdk_window_set_debug_updates() yourself, though you might want
// to use this function to enable updates sometime after application startup
// time.
//
// Deprecated: since version 3.22.
//
// The function takes the following parameters:
//
//    - setting: TRUE to turn on update debugging.
//
func WindowSetDebugUpdates(setting bool) {
	var args [1]girepository.Argument
	var _arg0 C.gboolean // out

	if setting {
		_arg0 = C.TRUE
	}
	*(*bool)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "set_debug_updates").Invoke(args[:], nil)

	runtime.KeepAlive(setting)
}

// Geometry struct gives the window manager information about a window’s
// geometry constraints. Normally you would set these on the GTK+ level using
// gtk_window_set_geometry_hints(). Window then sets the hints on the Window it
// creates.
//
// gdk_window_set_geometry_hints() expects the hints to be fully valid already
// and simply passes them to the window manager; in contrast,
// gtk_window_set_geometry_hints() performs some interpretation. For example,
// Window will apply the hints to the geometry widget instead of the toplevel
// window, if you set a geometry widget. Also, the
// min_width/min_height/max_width/max_height fields may be set to -1, and Window
// will substitute the size request of the window or geometry widget. If the
// minimum size hint is not provided, Window will use its requisition as the
// minimum size. If the minimum size is provided and a geometry widget is set,
// Window will take the minimum size as the minimum size of the geometry widget
// rather than the entire window. The base size is treated similarly.
//
// The canonical use-case for gtk_window_set_geometry_hints() is to get a
// terminal widget to resize properly. Here, the terminal text area should be
// the geometry widget; Window will then automatically set the base size to the
// size of other widgets in the terminal window, such as the menubar and
// scrollbar. Then, the width_inc and height_inc fields should be set to the
// size of one character in the terminal. Finally, the base size should be set
// to the size of one character. The net effect is that the minimum size of the
// terminal will have a 1x1 character terminal area, and only terminal sizes on
// the “character grid” will be allowed.
//
// Here’s an example of how the terminal example would be implemented, assuming
// a terminal area widget called “terminal” and a toplevel window “toplevel”:
//
//    	GdkGeometry hints;
//
//    	hints.base_width = terminal->char_width;
//            hints.base_height = terminal->char_height;
//            hints.min_width = terminal->char_width;
//            hints.min_height = terminal->char_height;
//            hints.width_inc = terminal->char_width;
//            hints.height_inc = terminal->char_height;
//
//     gtk_window_set_geometry_hints (GTK_WINDOW (toplevel),
//                                    GTK_WIDGET (terminal),
//                                    &hints,
//                                    GDK_HINT_RESIZE_INC |
//                                    GDK_HINT_MIN_SIZE |
//                                    GDK_HINT_BASE_SIZE);
//
// The other useful fields are the min_aspect and max_aspect fields; these
// contain a width/height ratio as a floating point number. If a geometry widget
// is set, the aspect applies to the geometry widget rather than the entire
// window. The most common use of these hints is probably to set min_aspect and
// max_aspect to the same value, thus forcing the window to keep a constant
// aspect ratio.
//
// An instance of this type is always passed by reference.
type Geometry struct {
	*geometry
}

// geometry is the struct that's finalized.
type geometry struct {
	native *C.GdkGeometry
}

// WindowAttr attributes to use for a newly-created window.
//
// An instance of this type is always passed by reference.
type WindowAttr struct {
	*windowAttr
}

// windowAttr is the struct that's finalized.
type windowAttr struct {
	native *C.GdkWindowAttr
}

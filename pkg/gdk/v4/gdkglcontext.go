// Code generated by girgen. DO NOT EDIT.

package gdk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gdkglcontext.go.
var GTypeGLContext = coreglib.Type(C.gdk_gl_context_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeGLContext, F: marshalGLContext},
	})
}

// GLContext: GdkGLContext is an object representing a platform-specific OpenGL
// draw context.
//
// GdkGLContexts are created for a surface using gdk.Surface.CreateGLContext(),
// and the context will match the the characteristics of the surface.
//
// A GdkGLContext is not tied to any particular normal framebuffer. For
// instance, it cannot draw to the surface back buffer. The GDK repaint system
// is in full control of the painting to that. Instead, you can create render
// buffers or textures and use cairo_draw_from_gl in the draw function of your
// widget to draw them. Then GDK will handle the integration of your rendering
// with that of other widgets.
//
// Support for GdkGLContext is platform-specific and context creation can fail,
// returning NULL context.
//
// A GdkGLContext has to be made "current" in order to start using it, otherwise
// any OpenGL call will be ignored.
//
//
// Creating a new OpenGL context
//
// In order to create a new GdkGLContext instance you need a GdkSurface, which
// you typically get during the realize call of a widget.
//
// A GdkGLContext is not realized until either gdk.GLContext.MakeCurrent() or
// gdk.GLContext.Realize() is called. It is possible to specify details of the
// GL context like the OpenGL version to be used, or whether the GL context
// should have extra state validation enabled after calling
// gdk.Surface.CreateGLContext() by calling gdk.GLContext.Realize(). If the
// realization fails you have the option to change the settings of the
// GdkGLContext and try again.
//
//
// Using a GdkGLContext
//
// You will need to make the GdkGLContext the current context before issuing
// OpenGL calls; the system sends OpenGL commands to whichever context is
// current. It is possible to have multiple contexts, so you always need to
// ensure that the one which you want to draw with is the current one before
// issuing commands:
//
//    gdk_gl_context_make_current (context);
//
//
// You can now perform your drawing using OpenGL commands.
//
// You can check which GdkGLContext is the current one by using
// gdk.GLContext().GetCurrent; you can also unset any GdkGLContext that is
// currently set by calling gdk.GLContext().ClearCurrent.
type GLContext struct {
	_ [0]func() // equal guard
	DrawContext
}

var (
	_ DrawContexter = (*GLContext)(nil)
)

// GLContexter describes types inherited from class GLContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type GLContexter interface {
	coreglib.Objector
	baseGLContext() *GLContext
}

var _ GLContexter = (*GLContext)(nil)

func wrapGLContext(obj *coreglib.Object) *GLContext {
	return &GLContext{
		DrawContext: DrawContext{
			Object: obj,
		},
	}
}

func marshalGLContext(p uintptr) (interface{}, error) {
	return wrapGLContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (context *GLContext) baseGLContext() *GLContext {
	return context
}

// BaseGLContext returns the underlying base object.
func BaseGLContext(obj GLContexter) *GLContext {
	return obj.baseGLContext()
}

// DebugEnabled retrieves whether the context is doing extra validations and
// runtime checking.
//
// See gdk.GLContext.SetDebugEnabled().
//
// The function returns the following values:
//
//    - ok: TRUE if debugging is enabled.
//
func (context *GLContext) DebugEnabled() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "GLContext").InvokeMethod("get_debug_enabled", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Display retrieves the display the context is created for.
//
// The function returns the following values:
//
//    - display (optional): GdkDisplay or NULL.
//
func (context *GLContext) Display() *Display {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "GLContext").InvokeMethod("get_display", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _display *Display // out

	if _cret != nil {
		_display = wrapDisplay(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _display
}

// ForwardCompatible retrieves whether the context is forward-compatible.
//
// See gdk.GLContext.SetForwardCompatible().
//
// The function returns the following values:
//
//    - ok: TRUE if the context should be forward-compatible.
//
func (context *GLContext) ForwardCompatible() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "GLContext").InvokeMethod("get_forward_compatible", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SharedContext retrieves the GdkGLContext that this context share data with.
//
// The function returns the following values:
//
//    - glContext (optional): GdkGLContext or NULL.
//
func (context *GLContext) SharedContext() GLContexter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "GLContext").InvokeMethod("get_shared_context", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// Surface retrieves the surface used by the context.
//
// The function returns the following values:
//
//    - surface (optional): GdkSurface or NULL.
//
func (context *GLContext) Surface() Surfacer {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "GLContext").InvokeMethod("get_surface", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _surface Surfacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Surfacer)
				return ok
			})
			rv, ok := casted.(Surfacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
			}
			_surface = rv
		}
	}

	return _surface
}

// UseES checks whether the context is using an OpenGL or OpenGL ES profile.
//
// The function returns the following values:
//
//    - ok: TRUE if the GdkGLContext is using an OpenGL ES profile.
//
func (context *GLContext) UseES() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "GLContext").InvokeMethod("get_use_es", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLegacy: whether the GdkGLContext is in legacy mode or not.
//
// The GdkGLContext must be realized before calling this function.
//
// When realizing a GL context, GDK will try to use the OpenGL 3.2 core profile;
// this profile removes all the OpenGL API that was deprecated prior to the 3.2
// version of the specification. If the realization is successful, this function
// will return FALSE.
//
// If the underlying OpenGL implementation does not support core profiles, GDK
// will fall back to a pre-3.2 compatibility profile, and this function will
// return TRUE.
//
// You can use the value returned by this function to decide which kind of
// OpenGL API to use, or whether to do extension discovery, or what kind of
// shader programs to load.
//
// The function returns the following values:
//
//    - ok: TRUE if the GL context is in legacy mode.
//
func (context *GLContext) IsLegacy() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gdk", "GLContext").InvokeMethod("is_legacy", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MakeCurrent makes the context the current one.
func (context *GLContext) MakeCurrent() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "GLContext").InvokeMethod("make_current", args[:], nil)

	runtime.KeepAlive(context)
}

// Realize realizes the given GdkGLContext.
//
// It is safe to call this function on a realized GdkGLContext.
func (context *GLContext) Realize() error {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cerr *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**GLContext)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gdk", "GLContext").InvokeMethod("realize", args[:], nil)

	runtime.KeepAlive(context)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetDebugEnabled sets whether the GdkGLContext should perform extra
// validations and runtime checking.
//
// This is useful during development, but has additional overhead.
//
// The GdkGLContext must not be realized or made current prior to calling this
// function.
//
// The function takes the following parameters:
//
//    - enabled: whether to enable debugging in the context.
//
func (context *GLContext) SetDebugEnabled(enabled bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if enabled {
		_arg1 = C.TRUE
	}
	*(**GLContext)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "GLContext").InvokeMethod("set_debug_enabled", args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(enabled)
}

// SetForwardCompatible sets whether the GdkGLContext should be
// forward-compatible.
//
// Forward-compatible contexts must not support OpenGL functionality that has
// been marked as deprecated in the requested version; non-forward compatible
// contexts, on the other hand, must support both deprecated and non deprecated
// functionality.
//
// The GdkGLContext must not be realized or made current prior to calling this
// function.
//
// The function takes the following parameters:
//
//    - compatible: whether the context should be forward-compatible.
//
func (context *GLContext) SetForwardCompatible(compatible bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if compatible {
		_arg1 = C.TRUE
	}
	*(**GLContext)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gdk", "GLContext").InvokeMethod("set_forward_compatible", args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(compatible)
}

// GLContextClearCurrent clears the current GdkGLContext.
//
// Any OpenGL call after this function returns will be ignored until
// gdk.GLContext.MakeCurrent() is called.
func GLContextClearCurrent() {
	girepository.MustFind("Gdk", "clear_current").Invoke(nil, nil)
}

// GLContextGetCurrent retrieves the current GdkGLContext.
//
// The function returns the following values:
//
//    - glContext (optional): current GdkGLContext, or NULL.
//
func GLContextGetCurrent() GLContexter {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gdk", "get_current").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _glContext GLContexter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(GLContexter)
				return ok
			})
			rv, ok := casted.(GLContexter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
			}
			_glContext = rv
		}
	}

	return _glContext
}

// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <glib.h>
// extern gboolean _gotk4_glib2_SourceFunc(gpointer);
// extern void callbackDelete(gpointer);
import "C"

// GType values.
var (
	GTypeMainContext = coreglib.Type(C.g_main_context_get_type())
	GTypeMainLoop    = coreglib.Type(C.g_main_loop_get_type())
	GTypeSource      = coreglib.Type(C.g_source_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMainContext, F: marshalMainContext},
		coreglib.TypeMarshaler{T: GTypeMainLoop, F: marshalMainLoop},
		coreglib.TypeMarshaler{T: GTypeSource, F: marshalSource},
	})
}

// PRIORITY_DEFAULT: use this for default priority event sources.
//
// In GLib this priority is used when adding timeout functions with
// g_timeout_add(). In GDK this priority is used for events from the X server.
const PRIORITY_DEFAULT = 0

// PRIORITY_DEFAULT_IDLE: use this for default priority idle functions.
//
// In GLib this priority is used when adding idle functions with g_idle_add().
const PRIORITY_DEFAULT_IDLE = 200

// PRIORITY_HIGH: use this for high priority event sources.
//
// It is not used within GLib or GTK+.
const PRIORITY_HIGH = -100

// PRIORITY_HIGH_IDLE: use this for high priority idle functions.
//
// GTK+ uses PRIORITY_HIGH_IDLE + 10 for resizing operations, and
// PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is done to ensure
// that any pending resizes are processed before any pending redraws, so that
// widgets are not redrawn twice unnecessarily.).
const PRIORITY_HIGH_IDLE = 100

// PRIORITY_LOW: use this for very low priority background tasks.
//
// It is not used within GLib or GTK+.
const PRIORITY_LOW = 300

// SOURCE_CONTINUE: use this macro as the return value of a Func to leave the
// #GSource in the main loop.
const SOURCE_CONTINUE = true

// SOURCE_REMOVE: use this macro as the return value of a Func to remove the
// #GSource from the main loop.
const SOURCE_REMOVE = false

// SourceFunc specifies the type of function passed to g_timeout_add(),
// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
//
// When calling g_source_set_callback(), you may need to cast a function of a
// different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
// incompatible function types.
type SourceFunc func() (ok bool)

//export _gotk4_glib2_SourceFunc
func _gotk4_glib2_SourceFunc(arg1 C.gpointer) (cret C.gboolean) {
	var fn SourceFunc
	{
		v := gbox.Get(uintptr(arg1))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(SourceFunc)
	}

	ok := fn()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// GetCurrentTime: equivalent to the UNIX gettimeofday() function, but portable.
//
// You may find g_get_real_time() to be more convenient.
//
// Deprecated: Val is not year-2038-safe. Use g_get_real_time() instead.
//
// The function takes the following parameters:
//
//    - result structure in which to store current time.
//
func GetCurrentTime(result *TimeVal) {
	var _arg1 *C.GTimeVal // out

	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(result)))

	C.g_get_current_time(_arg1)
	runtime.KeepAlive(result)
}

// GetMonotonicTime queries the system monotonic time.
//
// The monotonic clock will always increase and doesn't suffer discontinuities
// when the user (or NTP) changes the system time. It may or may not continue to
// tick during times where the machine is suspended.
//
// We try to use the clock that corresponds as closely as possible to the
// passage of time as measured by system calls such as poll() but it may not
// always be possible to do this.
//
// The function returns the following values:
//
//    - gint64: monotonic time, in microseconds.
//
func GetMonotonicTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_monotonic_time()

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// GetRealTime queries the system wall-clock time.
//
// This call is functionally equivalent to g_get_current_time() except that the
// return value is often more convenient than dealing with a Val.
//
// You should only use this call if you are actually interested in the real
// wall-clock time. g_get_monotonic_time() is probably more useful for measuring
// intervals.
//
// The function returns the following values:
//
//    - gint64: number of microseconds since January 1, 1970 UTC.
//
func GetRealTime() int64 {
	var _cret C.gint64 // in

	_cret = C.g_get_real_time()

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// IdleRemoveByData removes the idle function with the given data.
//
// The function takes the following parameters:
//
//    - data (optional) for the idle source's callback.
//
// The function returns the following values:
//
//    - ok: TRUE if an idle source was found and removed.
//
func IdleRemoveByData(data unsafe.Pointer) bool {
	var _arg1 C.gpointer // out
	var _cret C.gboolean // in

	_arg1 = (C.gpointer)(unsafe.Pointer(data))

	_cret = C.g_idle_remove_by_data(_arg1)
	runtime.KeepAlive(data)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewIdleSource creates a new idle source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed. Note that the
// default priority for idle sources is G_PRIORITY_DEFAULT_IDLE, as compared to
// other sources which have a default priority of G_PRIORITY_DEFAULT.
//
// The function returns the following values:
//
//    - source: newly-created idle source.
//
func NewIdleSource() *Source {
	var _cret *C.GSource // in

	_cret = C.g_idle_source_new()

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_destroy((*C.GSource)(intern.C))
		},
	)

	return _source
}

// MainCurrentSource returns the currently firing source for this thread.
//
// The function returns the following values:
//
//    - source (optional): currently firing source or NULL.
//
func MainCurrentSource() *Source {
	var _cret *C.GSource // in

	_cret = C.g_main_current_source()

	var _source *Source // out

	if _cret != nil {
		_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_source_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_source)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_source_destroy((*C.GSource)(intern.C))
			},
		)
	}

	return _source
}

// MainDepth returns the depth of the stack of calls to
// g_main_context_dispatch() on any Context in the current thread. That is, when
// called from the toplevel, it gives 0. When called from within a callback from
// g_main_context_iteration() (or g_main_loop_run(), etc.) it returns 1. When
// called from within a callback to a recursive call to
// g_main_context_iteration(), it returns 2. And so forth.
//
// This function is useful in a situation like the following: Imagine an
// extremely simple "garbage collected" system.
//
//    gpointer
//    allocate_memory (gsize size)
//    {
//      FreeListBlock *block = g_new (FreeListBlock, 1);
//      block->mem = g_malloc (size);
//      block->depth = g_main_depth ();
//      free_list = g_list_prepend (free_list, block);
//      return block->mem;
//    }
//
//    void
//    free_allocated_memory (void)
//    {
//      GList *l;
//
//      int depth = g_main_depth ();
//      for (l = free_list; l; );
//        {
//          GList *next = l->next;
//          FreeListBlock *block = l->data;
//          if (block->depth > depth)
//            {
//              g_free (block->mem);
//              g_free (block);
//              free_list = g_list_delete_link (free_list, l);
//            }
//
//          l = next;
//        }
//      }
//
// There is a temptation to use g_main_depth() to solve problems with
// reentrancy. For instance, while waiting for data to be received from the
// network in response to a menu item, the menu item might be selected again. It
// might seem that one could make the menu item's callback return immediately
// and do nothing if g_main_depth() returns a value greater than 1. However,
// this should be avoided since the user then sees selecting the menu item do
// nothing. Furthermore, you'll find yourself adding these checks all over your
// code, since there are doubtless many, many things that the user could do.
// Instead, you can use the following techniques:
//
// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent the user from
// interacting with elements while the main loop is recursing.
//
// 2. Avoid main loop recursion in situations where you can't handle arbitrary
// callbacks. Instead, structure your code so that you simply return to the main
// loop and then get called again when there is more work to do.
//
// The function returns the following values:
//
//    - gint: main loop recursion level in the current thread.
//
func MainDepth() int {
	var _cret C.gint // in

	_cret = C.g_main_depth()

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NewTimeoutSource creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
//
// The function takes the following parameters:
//
//    - interval: timeout interval in milliseconds.
//
// The function returns the following values:
//
//    - source: newly-created timeout source.
//
func NewTimeoutSource(interval uint) *Source {
	var _arg1 C.guint    // out
	var _cret *C.GSource // in

	_arg1 = C.guint(interval)

	_cret = C.g_timeout_source_new(_arg1)
	runtime.KeepAlive(interval)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_destroy((*C.GSource)(intern.C))
		},
	)

	return _source
}

// TimeoutSourceNewSeconds creates a new timeout source.
//
// The source will not initially be associated with any Context and must be
// added to one with g_source_attach() before it will be executed.
//
// The scheduling granularity/accuracy of this timeout source will be in
// seconds.
//
// The interval given is in terms of monotonic time, not wall clock time. See
// g_get_monotonic_time().
//
// The function takes the following parameters:
//
//    - interval: timeout interval in seconds.
//
// The function returns the following values:
//
//    - source: newly-created timeout source.
//
func TimeoutSourceNewSeconds(interval uint) *Source {
	var _arg1 C.guint    // out
	var _cret *C.GSource // in

	_arg1 = C.guint(interval)

	_cret = C.g_timeout_source_new_seconds(_arg1)
	runtime.KeepAlive(interval)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_destroy((*C.GSource)(intern.C))
		},
	)

	return _source
}

// MainContext: GMainContext struct is an opaque data type representing a set of
// sources to be handled in a main loop.
//
// An instance of this type is always passed by reference.
type MainContext struct {
	*mainContext
}

// mainContext is the struct that's finalized.
type mainContext struct {
	native *C.GMainContext
}

func marshalMainContext(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MainContext{&mainContext{(*C.GMainContext)(b)}}, nil
}

// NewMainContext constructs a struct MainContext.
func NewMainContext() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_new()

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _mainContext
}

// Acquire tries to become the owner of the specified context. If some other
// thread is the owner of the context, returns FALSE immediately. Ownership is
// properly recursive: the owner can require ownership again and will release
// ownership when g_main_context_release() is called as many times as
// g_main_context_acquire().
//
// You must be the owner of a context before you can call
// g_main_context_prepare(), g_main_context_query(), g_main_context_check(),
// g_main_context_dispatch().
//
// The function returns the following values:
//
//    - ok: TRUE if the operation succeeded, and this thread is now the owner of
//      context.
//
func (context *MainContext) Acquire() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.g_main_context_acquire(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Dispatch dispatches all pending sources.
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
func (context *MainContext) Dispatch() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.g_main_context_dispatch(_arg0)
	runtime.KeepAlive(context)
}

// FindSourceByFuncsUserData finds a source with the given source functions and
// user data. If multiple sources exist with the same source function and user
// data, the first one found will be returned.
//
// The function takes the following parameters:
//
//    - funcs passed to g_source_new().
//    - userData (optional): user data from the callback.
//
// The function returns the following values:
//
//    - source: source, if one was found, otherwise NULL.
//
func (context *MainContext) FindSourceByFuncsUserData(funcs *SourceFuncs, userData unsafe.Pointer) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 *C.GSourceFuncs // out
	var _arg2 C.gpointer      // out
	var _cret *C.GSource      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg1 = (*C.GSourceFuncs)(gextras.StructNative(unsafe.Pointer(funcs)))
	_arg2 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_main_context_find_source_by_funcs_user_data(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(funcs)
	runtime.KeepAlive(userData)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_destroy((*C.GSource)(intern.C))
		},
	)

	return _source
}

// FindSourceByID finds a #GSource given a pair of context and ID.
//
// It is a programmer error to attempt to look up a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
//
// The function takes the following parameters:
//
//    - sourceId: source ID, as returned by g_source_get_id().
//
// The function returns the following values:
//
//    - source: #GSource.
//
func (context *MainContext) FindSourceByID(sourceId uint) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 C.guint         // out
	var _cret *C.GSource      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg1 = C.guint(sourceId)

	_cret = C.g_main_context_find_source_by_id(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(sourceId)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_destroy((*C.GSource)(intern.C))
		},
	)

	return _source
}

// FindSourceByUserData finds a source with the given user data for the
// callback. If multiple sources exist with the same user data, the first one
// found will be returned.
//
// The function takes the following parameters:
//
//    - userData (optional): user_data for the callback.
//
// The function returns the following values:
//
//    - source: source, if one was found, otherwise NULL.
//
func (context *MainContext) FindSourceByUserData(userData unsafe.Pointer) *Source {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gpointer      // out
	var _cret *C.GSource      // in

	_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	_arg1 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_main_context_find_source_by_user_data(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(userData)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_source_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_destroy((*C.GSource)(intern.C))
		},
	)

	return _source
}

// InvokeFull invokes a function in such a way that context is owned during the
// invocation of function.
//
// This function is the same as g_main_context_invoke() except that it lets you
// specify the priority in case function ends up being scheduled as an idle and
// also lets you give a Notify for data.
//
// notify should not assume that it is called from any particular thread or with
// any particular context acquired.
//
// The function takes the following parameters:
//
//    - priority at which to run function.
//    - function to call.
//
func (context *MainContext) InvokeFull(priority int, function SourceFunc) {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // out
	var _arg2 C.GSourceFunc   // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	_arg1 = C.gint(priority)
	_arg2 = (*[0]byte)(C._gotk4_glib2_SourceFunc)
	_arg3 = C.gpointer(gbox.Assign(function))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.g_main_context_invoke_full(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(priority)
	runtime.KeepAlive(function)
}

// IsOwner determines whether this thread holds the (recursive) ownership of
// this Context. This is useful to know before waiting on another thread that
// may be blocking to get ownership of context.
//
// The function returns the following values:
//
//    - ok: TRUE if current thread is owner of context.
//
func (context *MainContext) IsOwner() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.g_main_context_is_owner(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iteration runs a single iteration for the given main loop. This involves
// checking to see if any event sources are ready to be processed, then if no
// events sources are ready and may_block is TRUE, waiting for a source to
// become ready, then dispatching the highest priority events sources that are
// ready. Otherwise, if may_block is FALSE sources are not waited to become
// ready, only those highest priority events sources will be dispatched (if
// any), that are ready at this given moment without further waiting.
//
// Note that even when may_block is TRUE, it is still possible for
// g_main_context_iteration() to return FALSE, since the wait may be interrupted
// for other reasons than an event source becoming ready.
//
// The function takes the following parameters:
//
//    - mayBlock: whether the call may block.
//
// The function returns the following values:
//
//    - ok: TRUE if events were dispatched.
//
func (context *MainContext) Iteration(mayBlock bool) bool {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gboolean      // out
	var _cret C.gboolean      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	if mayBlock {
		_arg1 = C.TRUE
	}

	_cret = C.g_main_context_iteration(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(mayBlock)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pending checks if any sources have pending events for the given context.
//
// The function returns the following values:
//
//    - ok: TRUE if events are pending.
//
func (context *MainContext) Pending() bool {
	var _arg0 *C.GMainContext // out
	var _cret C.gboolean      // in

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	_cret = C.g_main_context_pending(_arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopThreadDefault pops context off the thread-default context stack (verifying
// that it was on the top of the stack).
func (context *MainContext) PopThreadDefault() {
	var _arg0 *C.GMainContext // out

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	C.g_main_context_pop_thread_default(_arg0)
	runtime.KeepAlive(context)
}

// Prepare prepares to poll sources within a main loop. The resulting
// information for polling is determined by calling g_main_context_query ().
//
// You must have successfully acquired the context with g_main_context_acquire()
// before you may call this function.
//
// The function returns the following values:
//
//    - priority (optional): location to store priority of highest priority
//      source already ready.
//    - ok: TRUE if some source is ready to be dispatched prior to polling.
//
func (context *MainContext) Prepare() (int, bool) {
	var _arg0 *C.GMainContext // out
	var _arg1 C.gint          // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))

	_cret = C.g_main_context_prepare(_arg0, &_arg1)
	runtime.KeepAlive(context)

	var _priority int // out
	var _ok bool      // out

	_priority = int(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _priority, _ok
}

// PushThreadDefault acquires context and sets it as the thread-default context
// for the current thread. This will cause certain asynchronous operations (such
// as most [gio][gio]-based I/O) which are started in this thread to run under
// context and deliver their results to its main loop, rather than running under
// the global default context in the main thread. Note that calling this
// function changes the context returned by g_main_context_get_thread_default(),
// not the one returned by g_main_context_default(), so it does not affect the
// context used by functions like g_idle_add().
//
// Normally you would call this function shortly after creating a new thread,
// passing it a Context which will be run by a Loop in that thread, to set a new
// default context for all async operations in that thread. In this case you may
// not need to ever call g_main_context_pop_thread_default(), assuming you want
// the new Context to be the default for the whole lifecycle of the thread.
//
// If you don't have control over how the new thread was created (e.g. in the
// new thread isn't newly created, or if the thread life cycle is managed by a
// Pool), it is always suggested to wrap the logic that needs to use the new
// Context inside a g_main_context_push_thread_default() /
// g_main_context_pop_thread_default() pair, otherwise threads that are re-used
// will end up never explicitly releasing the Context reference they hold.
//
// In some cases you may want to schedule a single operation in a non-default
// context, or temporarily use a non-default context in the main thread. In that
// case, you can wrap the call to the asynchronous operation inside a
// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
// pair, but it is up to you to ensure that no other asynchronous operations
// accidentally get started while the non-default context is active.
//
// Beware that libraries that predate this function may not correctly handle
// being used from a thread with a thread-default context. Eg, see
// g_file_supports_thread_contexts().
func (context *MainContext) PushThreadDefault() {
	var _arg0 *C.GMainContext // out

	if context != nil {
		_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	C.g_main_context_push_thread_default(_arg0)
	runtime.KeepAlive(context)
}

// Release releases ownership of a context previously acquired by this thread
// with g_main_context_acquire(). If the context was acquired multiple times,
// the ownership will be released only when g_main_context_release() is called
// as many times as it was acquired.
func (context *MainContext) Release() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.g_main_context_release(_arg0)
	runtime.KeepAlive(context)
}

// Wakeup: if context is currently blocking in g_main_context_iteration()
// waiting for a source to become ready, cause it to stop blocking and return.
// Otherwise, cause the next invocation of g_main_context_iteration() to return
// without blocking.
//
// This API is useful for low-level control over Context; for example,
// integrating it with main loop implementations such as Loop.
//
// Another related use for this function is when implementing a main loop with a
// termination condition, computed from multiple threads:
//
//      perform_work();
//
//      if (g_atomic_int_dec_and_test (&tasks_remaining))
//        g_main_context_wakeup (NULL);.
func (context *MainContext) Wakeup() {
	var _arg0 *C.GMainContext // out

	_arg0 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))

	C.g_main_context_wakeup(_arg0)
	runtime.KeepAlive(context)
}

// MainContextDefault returns the global default main context. This is the main
// context used for main loop functions when a main loop is not explicitly
// specified, and corresponds to the "main" main loop. See also
// g_main_context_get_thread_default().
//
// The function returns the following values:
//
//    - mainContext: global default main context.
//
func MainContextDefault() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_default()

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _mainContext
}

// MainContextGetThreadDefault gets the thread-default Context for this thread.
// Asynchronous operations that want to be able to be run in contexts other than
// the default one should call this method or
// g_main_context_ref_thread_default() to get a Context to add their #GSources
// to. (Note that even in single-threaded programs applications may sometimes
// want to temporarily push a non-default context, so it is not safe to assume
// that this will always return NULL if you are running in the default thread.)
//
// If you need to hold a reference on the context, use
// g_main_context_ref_thread_default() instead.
//
// The function returns the following values:
//
//    - mainContext (optional): thread-default Context, or NULL if the
//      thread-default context is the global default context.
//
func MainContextGetThreadDefault() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_get_thread_default()

	var _mainContext *MainContext // out

	if _cret != nil {
		_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_main_context_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_mainContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _mainContext
}

// MainContextRefThreadDefault gets the thread-default Context for this thread,
// as with g_main_context_get_thread_default(), but also adds a reference to it
// with g_main_context_ref(). In addition, unlike
// g_main_context_get_thread_default(), if the thread-default context is the
// global default context, this will return that Context (with a ref added to
// it) rather than returning NULL.
//
// The function returns the following values:
//
//    - mainContext: thread-default Context. Unref with g_main_context_unref()
//      when you are done with it.
//
func MainContextRefThreadDefault() *MainContext {
	var _cret *C.GMainContext // in

	_cret = C.g_main_context_ref_thread_default()

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _mainContext
}

// MainLoop: GMainLoop struct is an opaque data type representing the main event
// loop of a GLib or GTK+ application.
//
// An instance of this type is always passed by reference.
type MainLoop struct {
	*mainLoop
}

// mainLoop is the struct that's finalized.
type mainLoop struct {
	native *C.GMainLoop
}

func marshalMainLoop(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MainLoop{&mainLoop{(*C.GMainLoop)(b)}}, nil
}

// NewMainLoop constructs a struct MainLoop.
func NewMainLoop(context *MainContext, isRunning bool) *MainLoop {
	var _arg1 *C.GMainContext // out
	var _arg2 C.gboolean      // out
	var _cret *C.GMainLoop    // in

	if context != nil {
		_arg1 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}
	if isRunning {
		_arg2 = C.TRUE
	}

	_cret = C.g_main_loop_new(_arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(isRunning)

	var _mainLoop *MainLoop // out

	_mainLoop = (*MainLoop)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainLoop)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _mainLoop
}

// Context returns the Context of loop.
//
// The function returns the following values:
//
//    - mainContext of loop.
//
func (loop *MainLoop) Context() *MainContext {
	var _arg0 *C.GMainLoop    // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GMainLoop)(gextras.StructNative(unsafe.Pointer(loop)))

	_cret = C.g_main_loop_get_context(_arg0)
	runtime.KeepAlive(loop)

	var _mainContext *MainContext // out

	_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_main_context_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mainContext)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _mainContext
}

// IsRunning checks to see if the main loop is currently being run via
// g_main_loop_run().
//
// The function returns the following values:
//
//    - ok: TRUE if the mainloop is currently being run.
//
func (loop *MainLoop) IsRunning() bool {
	var _arg0 *C.GMainLoop // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GMainLoop)(gextras.StructNative(unsafe.Pointer(loop)))

	_cret = C.g_main_loop_is_running(_arg0)
	runtime.KeepAlive(loop)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Quit stops a Loop from running. Any calls to g_main_loop_run() for the loop
// will return.
//
// Note that sources that have already been dispatched when g_main_loop_quit()
// is called will still be executed.
func (loop *MainLoop) Quit() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(gextras.StructNative(unsafe.Pointer(loop)))

	C.g_main_loop_quit(_arg0)
	runtime.KeepAlive(loop)
}

// Run runs a main loop until g_main_loop_quit() is called on the loop. If this
// is called for the thread of the loop's Context, it will process events from
// the loop, otherwise it will simply wait.
func (loop *MainLoop) Run() {
	var _arg0 *C.GMainLoop // out

	_arg0 = (*C.GMainLoop)(gextras.StructNative(unsafe.Pointer(loop)))

	C.g_main_loop_run(_arg0)
	runtime.KeepAlive(loop)
}

// Source: GSource struct is an opaque data type representing an event source.
//
// An instance of this type is always passed by reference.
type Source struct {
	*source
}

// source is the struct that's finalized.
type source struct {
	native *C.GSource
}

func marshalSource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Source{&source{(*C.GSource)(b)}}, nil
}

// NewSource constructs a struct Source.
func NewSource(sourceFuncs *SourceFuncs, structSize uint) *Source {
	var _arg1 *C.GSourceFuncs // out
	var _arg2 C.guint         // out
	var _cret *C.GSource      // in

	_arg1 = (*C.GSourceFuncs)(gextras.StructNative(unsafe.Pointer(sourceFuncs)))
	_arg2 = C.guint(structSize)

	_cret = C.g_source_new(_arg1, _arg2)
	runtime.KeepAlive(sourceFuncs)
	runtime.KeepAlive(structSize)

	var _source *Source // out

	_source = (*Source)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_source)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_source_destroy((*C.GSource)(intern.C))
		},
	)

	return _source
}

// AddChildSource adds child_source to source as a "polled" source; when source
// is added to a Context, child_source will be automatically added with the same
// priority, when child_source is triggered, it will cause source to dispatch
// (in addition to calling its own callback), and when source is destroyed, it
// will destroy child_source as well. (source will also still be dispatched if
// its own prepare/check functions indicate that it is ready.)
//
// If you don't need child_source to do anything on its own when it triggers,
// you can call g_source_set_dummy_callback() on it to set a callback that does
// nothing (except return TRUE if appropriate).
//
// source will hold a reference on child_source while child_source is attached
// to it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// The function takes the following parameters:
//
//    - childSource: second #GSource that source should "poll".
//
func (source *Source) AddChildSource(childSource *Source) {
	var _arg0 *C.GSource // out
	var _arg1 *C.GSource // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(childSource)))

	C.g_source_add_child_source(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(childSource)
}

// Attach adds a #GSource to a context so that it will be executed within that
// context. Remove it by calling g_source_destroy().
//
// This function is safe to call from any thread, regardless of which thread the
// context is running in.
//
// The function takes the following parameters:
//
//    - context (optional) (if NULL, the default context will be used).
//
// The function returns the following values:
//
//    - guint: ID (greater than 0) for the source within the Context.
//
func (source *Source) Attach(context *MainContext) uint {
	var _arg0 *C.GSource      // out
	var _arg1 *C.GMainContext // out
	var _cret C.guint         // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	if context != nil {
		_arg1 = (*C.GMainContext)(gextras.StructNative(unsafe.Pointer(context)))
	}

	_cret = C.g_source_attach(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(context)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Destroy removes a source from its Context, if any, and mark it as destroyed.
// The source cannot be subsequently added to another context. It is safe to
// call this on sources which have already been removed from their context.
//
// This does not unref the #GSource: if you still hold a reference, use
// g_source_unref() to drop it.
//
// This function is safe to call from any thread, regardless of which thread the
// Context is running in.
func (source *Source) Destroy() {
	var _arg0 *C.GSource // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	C.g_source_destroy(_arg0)
	runtime.KeepAlive(source)
}

// CanRecurse checks whether a source is allowed to be called recursively. see
// g_source_set_can_recurse().
//
// The function returns the following values:
//
//    - ok: whether recursion is allowed.
//
func (source *Source) CanRecurse() bool {
	var _arg0 *C.GSource // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_can_recurse(_arg0)
	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Context gets the Context with which the source is associated.
//
// You can call this on a source that has been destroyed, provided that the
// Context it was attached to still exists (in which case it will return that
// Context). In particular, you can always call this function on the source
// returned from g_main_current_source(). But calling this function on a source
// whose Context has been destroyed is an error.
//
// The function returns the following values:
//
//    - mainContext (optional) with which the source is associated, or NULL if
//      the context has not yet been added to a source.
//
func (source *Source) Context() *MainContext {
	var _arg0 *C.GSource      // out
	var _cret *C.GMainContext // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_context(_arg0)
	runtime.KeepAlive(source)

	var _mainContext *MainContext // out

	if _cret != nil {
		_mainContext = (*MainContext)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_main_context_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_mainContext)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _mainContext
}

// CurrentTime: this function ignores source and is otherwise the same as
// g_get_current_time().
//
// Deprecated: use g_source_get_time() instead.
//
// The function takes the following parameters:
//
//    - timeval structure in which to store current time.
//
func (source *Source) CurrentTime(timeval *TimeVal) {
	var _arg0 *C.GSource  // out
	var _arg1 *C.GTimeVal // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GTimeVal)(gextras.StructNative(unsafe.Pointer(timeval)))

	C.g_source_get_current_time(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(timeval)
}

// ID returns the numeric ID for a particular source. The ID of a source is a
// positive integer which is unique within a particular main loop context. The
// reverse mapping from ID to source is done by
// g_main_context_find_source_by_id().
//
// You can only call this function while the source is associated to a Context
// instance; calling this function before g_source_attach() or after
// g_source_destroy() yields undefined behavior. The ID returned is unique
// within the Context instance passed to g_source_attach().
//
// The function returns the following values:
//
//    - guint: ID (greater than 0) for the source.
//
func (source *Source) ID() uint {
	var _arg0 *C.GSource // out
	var _cret C.guint    // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_id(_arg0)
	runtime.KeepAlive(source)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Name gets a name for the source, used in debugging and profiling. The name
// may be LL if it has never been set with g_source_set_name().
//
// The function returns the following values:
//
//    - utf8 (optional): name of the source.
//
func (source *Source) Name() string {
	var _arg0 *C.GSource // out
	var _cret *C.char    // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_name(_arg0)
	runtime.KeepAlive(source)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Priority gets the priority of a source.
//
// The function returns the following values:
//
//    - gint: priority of the source.
//
func (source *Source) Priority() int {
	var _arg0 *C.GSource // out
	var _cret C.gint     // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_priority(_arg0)
	runtime.KeepAlive(source)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ReadyTime gets the "ready time" of source, as set by
// g_source_set_ready_time().
//
// Any time before the current monotonic time (including 0) is an indication
// that the source will fire immediately.
//
// The function returns the following values:
//
//    - gint64: monotonic ready time, -1 for "never".
//
func (source *Source) ReadyTime() int64 {
	var _arg0 *C.GSource // out
	var _cret C.gint64   // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_ready_time(_arg0)
	runtime.KeepAlive(source)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Time gets the time to be used when checking this source. The advantage of
// calling this function over calling g_get_monotonic_time() directly is that
// when checking multiple sources, GLib can cache a single value instead of
// having to repeatedly get the system monotonic time.
//
// The time here is the system monotonic time, if available, or some other
// reasonable alternative otherwise. See g_get_monotonic_time().
//
// The function returns the following values:
//
//    - gint64: monotonic time in microseconds.
//
func (source *Source) Time() int64 {
	var _arg0 *C.GSource // out
	var _cret C.gint64   // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_get_time(_arg0)
	runtime.KeepAlive(source)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// IsDestroyed returns whether source has been destroyed.
//
// This is important when you operate upon your objects from within idle
// handlers, but may have freed the object before the dispatch of your idle
// handler.
//
//    static gboolean
//    idle_callback (gpointer data)
//    {
//      SomeWidget *self = data;
//
//      g_mutex_lock (&self->idle_id_mutex);
//      if (!g_source_is_destroyed (g_main_current_source ()))
//        {
//          // do stuff with self
//        }
//      g_mutex_unlock (&self->idle_id_mutex);
//
//      return FALSE;
//    }
//
// Calls to this function from a thread other than the one acquired by the
// Context the #GSource is attached to are typically redundant, as the source
// could be destroyed immediately after this function returns. However, once a
// source is destroyed it cannot be un-destroyed, so this function can be used
// for opportunistic checks from any thread.
//
// The function returns the following values:
//
//    - ok: TRUE if the source has been destroyed.
//
func (source *Source) IsDestroyed() bool {
	var _arg0 *C.GSource // out
	var _cret C.gboolean // in

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.g_source_is_destroyed(_arg0)
	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveChildSource detaches child_source from source and destroys it.
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// The function takes the following parameters:
//
//    - childSource previously passed to g_source_add_child_source().
//
func (source *Source) RemoveChildSource(childSource *Source) {
	var _arg0 *C.GSource // out
	var _arg1 *C.GSource // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(childSource)))

	C.g_source_remove_child_source(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(childSource)
}

// SetCallback sets the callback function for a source. The callback for a
// source is called from the source's dispatch function.
//
// The exact type of func depends on the type of source; ie. you should not
// count on func being called with data as its first parameter. Cast func with
// G_SOURCE_FUNC() to avoid warnings about incompatible function types.
//
// See [memory management of sources][mainloop-memory-management] for details on
// how to handle memory management of data.
//
// Typically, you won't use this function. Instead use functions specific to the
// type of source you are using, such as g_idle_add() or g_timeout_add().
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
//
// The function takes the following parameters:
//
//    - fn: callback function.
//
func (source *Source) SetCallback(fn SourceFunc) {
	var _arg0 *C.GSource    // out
	var _arg1 C.GSourceFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*[0]byte)(C._gotk4_glib2_SourceFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.g_source_set_callback(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(source)
	runtime.KeepAlive(fn)
}

// SetCallbackIndirect sets the callback function storing the data as a
// refcounted callback "object". This is used internally. Note that calling
// g_source_set_callback_indirect() assumes an initial reference count on
// callback_data, and thus callback_funcs->unref will eventually be called once
// more than callback_funcs->ref.
//
// It is safe to call this function multiple times on a source which has already
// been attached to a context. The changes will take effect for the next time
// the source is dispatched after this call returns.
//
// The function takes the following parameters:
//
//    - callbackData (optional): pointer to callback data "object".
//    - callbackFuncs functions for reference counting callback_data and getting
//      the callback and data.
//
func (source *Source) SetCallbackIndirect(callbackData unsafe.Pointer, callbackFuncs *SourceCallbackFuncs) {
	var _arg0 *C.GSource              // out
	var _arg1 C.gpointer              // out
	var _arg2 *C.GSourceCallbackFuncs // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (C.gpointer)(unsafe.Pointer(callbackData))
	_arg2 = (*C.GSourceCallbackFuncs)(gextras.StructNative(unsafe.Pointer(callbackFuncs)))

	C.g_source_set_callback_indirect(_arg0, _arg1, _arg2)
	runtime.KeepAlive(source)
	runtime.KeepAlive(callbackData)
	runtime.KeepAlive(callbackFuncs)
}

// SetCanRecurse sets whether a source can be called recursively. If can_recurse
// is TRUE, then while the source is being dispatched then this source will be
// processed normally. Otherwise, all processing of this source is blocked until
// the dispatch function returns.
//
// The function takes the following parameters:
//
//    - canRecurse: whether recursion is allowed for this source.
//
func (source *Source) SetCanRecurse(canRecurse bool) {
	var _arg0 *C.GSource // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	if canRecurse {
		_arg1 = C.TRUE
	}

	C.g_source_set_can_recurse(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(canRecurse)
}

// SetFuncs sets the source functions (can be used to override default
// implementations) of an unattached source.
//
// The function takes the following parameters:
//
//    - funcs: new Funcs.
//
func (source *Source) SetFuncs(funcs *SourceFuncs) {
	var _arg0 *C.GSource      // out
	var _arg1 *C.GSourceFuncs // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GSourceFuncs)(gextras.StructNative(unsafe.Pointer(funcs)))

	C.g_source_set_funcs(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(funcs)
}

// SetName sets a name for the source, used in debugging and profiling. The name
// defaults to LL.
//
// The source name should describe in a human-readable way what the source does.
// For example, "X11 event queue" or "GTK+ repaint idle handler" or whatever it
// is.
//
// It is permitted to call this function multiple times, but is not recommended
// due to the potential performance impact. For example, one could change the
// name in the "check" function of a Funcs to include details like the event
// type in the source name.
//
// Use caution if changing the name while another thread may be accessing it
// with g_source_get_name(); that function does not copy the value, and changing
// the value will free it while the other thread may be attempting to use it.
//
// The function takes the following parameters:
//
//    - name: debug name for the source.
//
func (source *Source) SetName(name string) {
	var _arg0 *C.GSource // out
	var _arg1 *C.char    // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_source_set_name(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(name)
}

// SetPriority sets the priority of a source. While the main loop is being run,
// a source will be dispatched if it is ready to be dispatched and no sources at
// a higher (numerically smaller) priority are ready to be dispatched.
//
// A child source always has the same priority as its parent. It is not
// permitted to change the priority of a source once it has been added as a
// child of another source.
//
// The function takes the following parameters:
//
//    - priority: new priority.
//
func (source *Source) SetPriority(priority int) {
	var _arg0 *C.GSource // out
	var _arg1 C.gint     // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = C.gint(priority)

	C.g_source_set_priority(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(priority)
}

// SetReadyTime sets a #GSource to be dispatched when the given monotonic time
// is reached (or passed). If the monotonic time is in the past (as it always
// will be if ready_time is 0) then the source will be dispatched immediately.
//
// If ready_time is -1 then the source is never woken up on the basis of the
// passage of time.
//
// Dispatching the source does not reset the ready time. You should do so
// yourself, from the source dispatch function.
//
// Note that if you have a pair of sources where the ready time of one suggests
// that it will be delivered first but the priority for the other suggests that
// it would be delivered first, and the ready time for both sources is reached
// during the same main context iteration, then the order of dispatch is
// undefined.
//
// It is a no-op to call this function on a #GSource which has already been
// destroyed with g_source_destroy().
//
// This API is only intended to be used by implementations of #GSource. Do not
// call this API on a #GSource that you did not create.
//
// The function takes the following parameters:
//
//    - readyTime: monotonic time at which the source will be ready, 0 for
//      "immediately", -1 for "never".
//
func (source *Source) SetReadyTime(readyTime int64) {
	var _arg0 *C.GSource // out
	var _arg1 C.gint64   // out

	_arg0 = (*C.GSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = C.gint64(readyTime)

	C.g_source_set_ready_time(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(readyTime)
}

// SourceRemoveByFuncsUserData removes a source from the default main loop
// context given the source functions and user data. If multiple sources exist
// with the same source functions and user data, only one will be destroyed.
//
// The function takes the following parameters:
//
//    - funcs passed to g_source_new().
//    - userData (optional): user data for the callback.
//
// The function returns the following values:
//
//    - ok: TRUE if a source was found and removed.
//
func SourceRemoveByFuncsUserData(funcs *SourceFuncs, userData unsafe.Pointer) bool {
	var _arg1 *C.GSourceFuncs // out
	var _arg2 C.gpointer      // out
	var _cret C.gboolean      // in

	_arg1 = (*C.GSourceFuncs)(gextras.StructNative(unsafe.Pointer(funcs)))
	_arg2 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_source_remove_by_funcs_user_data(_arg1, _arg2)
	runtime.KeepAlive(funcs)
	runtime.KeepAlive(userData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SourceRemoveByUserData removes a source from the default main loop context
// given the user data for the callback. If multiple sources exist with the same
// user data, only one will be destroyed.
//
// The function takes the following parameters:
//
//    - userData (optional): user_data for the callback.
//
// The function returns the following values:
//
//    - ok: TRUE if a source was found and removed.
//
func SourceRemoveByUserData(userData unsafe.Pointer) bool {
	var _arg1 C.gpointer // out
	var _cret C.gboolean // in

	_arg1 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_source_remove_by_user_data(_arg1)
	runtime.KeepAlive(userData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SourceSetNameByID sets the name of a source using its ID.
//
// This is a convenience utility to set source names from the return value of
// g_idle_add(), g_timeout_add(), etc.
//
// It is a programmer error to attempt to set the name of a non-existent source.
//
// More specifically: source IDs can be reissued after a source has been
// destroyed and therefore it is never valid to use this function with a source
// ID which may have already been removed. An example is when scheduling an idle
// to run in another thread with g_idle_add(): the idle may already have run and
// been removed by the time this function is called on its (now invalid) source
// ID. This source ID may have been reissued, leading to the operation being
// performed against the wrong source.
//
// The function takes the following parameters:
//
//    - tag: #GSource ID.
//    - name: debug name for the source.
//
func SourceSetNameByID(tag uint, name string) {
	var _arg1 C.guint // out
	var _arg2 *C.char // out

	_arg1 = C.guint(tag)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_source_set_name_by_id(_arg1, _arg2)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(name)
}

// SourceCallbackFuncs: GSourceCallbackFuncs struct contains functions for
// managing callback objects.
//
// An instance of this type is always passed by reference.
type SourceCallbackFuncs struct {
	*sourceCallbackFuncs
}

// sourceCallbackFuncs is the struct that's finalized.
type sourceCallbackFuncs struct {
	native *C.GSourceCallbackFuncs
}

// SourceFuncs: GSourceFuncs struct contains a table of functions used to handle
// event sources in a generic manner.
//
// For idle sources, the prepare and check functions always return TRUE to
// indicate that the source is always ready to be processed. The prepare
// function also returns a timeout value of 0 to ensure that the poll() call
// doesn't block (since that would be time wasted which could have been spent
// running the idle function).
//
// For timeout sources, the prepare and check functions both return TRUE if the
// timeout interval has expired. The prepare function also returns a timeout
// value to ensure that the poll() call doesn't block too long and miss the next
// timeout.
//
// For file descriptor sources, the prepare function typically returns FALSE,
// since it must wait until poll() has been called before it knows whether any
// events need to be processed. It sets the returned timeout to -1 to indicate
// that it doesn't mind how long the poll() call blocks. In the check function,
// it tests the results of the poll() call to see if the required condition has
// been met, and returns TRUE if so.
//
// An instance of this type is always passed by reference.
type SourceFuncs struct {
	*sourceFuncs
}

// sourceFuncs is the struct that's finalized.
type sourceFuncs struct {
	native *C.GSourceFuncs
}

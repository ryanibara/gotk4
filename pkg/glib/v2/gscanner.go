// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"runtime"
	"runtime/cgo"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// CSET_A_2_Z: set of uppercase ASCII alphabet characters. Used for specifying
// valid identifier characters in Config.
const CSET_A_2_Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

// CSET_DIGITS: set of ASCII digits. Used for specifying valid identifier
// characters in Config.
const CSET_DIGITS = "0123456789"

// CSET_a_2_z: set of lowercase ASCII alphabet characters. Used for specifying
// valid identifier characters in Config.
const CSET_a_2_z = "abcdefghijklmnopqrstuvwxyz"

// ErrorType: possible errors, used in the v_error field of Value, when the
// token is a G_TOKEN_ERROR.
type ErrorType C.gint

const (
	// ErrUnknown: unknown error.
	ErrUnknown ErrorType = iota
	// ErrUnexpEOF: unexpected end of file.
	ErrUnexpEOF
	// ErrUnexpEOFInString: unterminated string constant.
	ErrUnexpEOFInString
	// ErrUnexpEOFInComment: unterminated comment.
	ErrUnexpEOFInComment
	// ErrNonDigitInConst: non-digit character in a number.
	ErrNonDigitInConst
	// ErrDigitRadix: digit beyond radix in a number.
	ErrDigitRadix
	// ErrFloatRadix: non-decimal floating point number.
	ErrFloatRadix
	// ErrFloatMalformed: malformed floating point number.
	ErrFloatMalformed
)

// String returns the name in string for ErrorType.
func (e ErrorType) String() string {
	switch e {
	case ErrUnknown:
		return "Unknown"
	case ErrUnexpEOF:
		return "UnexpEOF"
	case ErrUnexpEOFInString:
		return "UnexpEOFInString"
	case ErrUnexpEOFInComment:
		return "UnexpEOFInComment"
	case ErrNonDigitInConst:
		return "NonDigitInConst"
	case ErrDigitRadix:
		return "DigitRadix"
	case ErrFloatRadix:
		return "FloatRadix"
	case ErrFloatMalformed:
		return "FloatMalformed"
	default:
		return fmt.Sprintf("ErrorType(%d)", e)
	}
}

// TokenType: possible types of token returned from each
// g_scanner_get_next_token() call.
type TokenType C.gint

const (
	// TokenEOF: end of the file.
	TokenEOF TokenType = 0
	// TokenLeftParen: '(' character.
	TokenLeftParen TokenType = 40
	// TokenRightParen: ')' character.
	TokenRightParen TokenType = 41
	// TokenLeftCurly: '{' character.
	TokenLeftCurly TokenType = 123
	// TokenRightCurly: '}' character.
	TokenRightCurly TokenType = 125
	// TokenLeftBrace: '[' character.
	TokenLeftBrace TokenType = 91
	// TokenRightBrace: ']' character.
	TokenRightBrace TokenType = 93
	// TokenEqualSign: '=' character.
	TokenEqualSign TokenType = 61
	// TokenComma: ',' character.
	TokenComma TokenType = 44
	// TokenNone: not a token.
	TokenNone TokenType = 256
	// TokenError: error occurred.
	TokenError TokenType = 257
	// TokenChar: character.
	TokenChar TokenType = 258
	// TokenBinary: binary integer.
	TokenBinary TokenType = 259
	// TokenOctal: octal integer.
	TokenOctal TokenType = 260
	// TokenInt: integer.
	TokenInt TokenType = 261
	// TokenHex: hex integer.
	TokenHex TokenType = 262
	// TokenFloat: floating point number.
	TokenFloat TokenType = 263
	// TokenString: string.
	TokenString TokenType = 264
	// TokenSymbol: symbol.
	TokenSymbol TokenType = 265
	// TokenIdentifier: identifier.
	TokenIdentifier TokenType = 266
	// TokenIdentifierNull: null identifier.
	TokenIdentifierNull TokenType = 267
	// TokenCommentSingle: one line comment.
	TokenCommentSingle TokenType = 268
	// TokenCommentMulti: multi line comment.
	TokenCommentMulti TokenType = 269
)

// String returns the name in string for TokenType.
func (t TokenType) String() string {
	switch t {
	case TokenEOF:
		return "EOF"
	case TokenLeftParen:
		return "LeftParen"
	case TokenRightParen:
		return "RightParen"
	case TokenLeftCurly:
		return "LeftCurly"
	case TokenRightCurly:
		return "RightCurly"
	case TokenLeftBrace:
		return "LeftBrace"
	case TokenRightBrace:
		return "RightBrace"
	case TokenEqualSign:
		return "EqualSign"
	case TokenComma:
		return "Comma"
	case TokenNone:
		return "None"
	case TokenError:
		return "Error"
	case TokenChar:
		return "Char"
	case TokenBinary:
		return "Binary"
	case TokenOctal:
		return "Octal"
	case TokenInt:
		return "Int"
	case TokenHex:
		return "Hex"
	case TokenFloat:
		return "Float"
	case TokenString:
		return "String"
	case TokenSymbol:
		return "Symbol"
	case TokenIdentifier:
		return "Identifier"
	case TokenIdentifierNull:
		return "IdentifierNull"
	case TokenCommentSingle:
		return "CommentSingle"
	case TokenCommentMulti:
		return "CommentMulti"
	default:
		return fmt.Sprintf("TokenType(%d)", t)
	}
}

// Scanner: data structure representing a lexical scanner.
//
// You should set input_name after creating the scanner, since it is used by the
// default message handler when displaying warnings and errors. If you are
// scanning a file, the filename would be a good choice.
//
// The user_data and max_parse_errors fields are not used. If you need to
// associate extra data with the scanner you can place them here.
//
// If you want to use your own message handler you can set the msg_handler
// field. The type of the message handler function is declared by MsgFunc.
//
// An instance of this type is always passed by reference.
type Scanner struct {
	*scanner
}

// scanner is the struct that's finalized.
type scanner struct {
	native *C.GScanner
}

// CurLine returns the current line in the input stream (counting from 1). This
// is the line of the last token parsed via g_scanner_get_next_token().
//
// The function returns the following values:
//
//    - guint: current line.
//
func (scanner *Scanner) CurLine() uint {
	var _arg0 *C.GScanner // out
	var _cret C.guint     // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_cur_line(_arg0)
	runtime.KeepAlive(scanner)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CurPosition returns the current position in the current line (counting from
// 0). This is the position of the last token parsed via
// g_scanner_get_next_token().
//
// The function returns the following values:
//
//    - guint: current position on the line.
//
func (scanner *Scanner) CurPosition() uint {
	var _arg0 *C.GScanner // out
	var _cret C.guint     // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_cur_position(_arg0)
	runtime.KeepAlive(scanner)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CurToken gets the current token type. This is simply the token field in the
// #GScanner structure.
//
// The function returns the following values:
//
//    - tokenType: current token type.
//
func (scanner *Scanner) CurToken() TokenType {
	var _arg0 *C.GScanner  // out
	var _cret C.GTokenType // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_cur_token(_arg0)
	runtime.KeepAlive(scanner)

	var _tokenType TokenType // out

	_tokenType = TokenType(_cret)

	return _tokenType
}

// Destroy frees all memory used by the #GScanner.
func (scanner *Scanner) Destroy() {
	var _arg0 *C.GScanner // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	C.g_scanner_destroy(_arg0)
	runtime.KeepAlive(scanner)
}

// EOF returns TRUE if the scanner has reached the end of the file or text
// buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the scanner has reached the end of the file or text buffer.
//
func (scanner *Scanner) EOF() bool {
	var _arg0 *C.GScanner // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_eof(_arg0)
	runtime.KeepAlive(scanner)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextToken parses the next token just like g_scanner_peek_next_token() and
// also removes it from the input stream. The token data is placed in the token,
// value, line, and position fields of the #GScanner structure.
//
// The function returns the following values:
//
//    - tokenType: type of the token.
//
func (scanner *Scanner) NextToken() TokenType {
	var _arg0 *C.GScanner  // out
	var _cret C.GTokenType // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_get_next_token(_arg0)
	runtime.KeepAlive(scanner)

	var _tokenType TokenType // out

	_tokenType = TokenType(_cret)

	return _tokenType
}

// InputFile prepares to scan a file.
//
// The function takes the following parameters:
//
//    - inputFd: file descriptor.
//
func (scanner *Scanner) InputFile(inputFd int) {
	var _arg0 *C.GScanner // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.gint(inputFd)

	C.g_scanner_input_file(_arg0, _arg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(inputFd)
}

// InputText prepares to scan a text buffer.
//
// The function takes the following parameters:
//
//    - text buffer to scan.
//    - textLen: length of the text buffer.
//
func (scanner *Scanner) InputText(text string, textLen uint) {
	var _arg0 *C.GScanner // out
	var _arg1 *C.gchar    // out
	var _arg2 C.guint     // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.guint(textLen)

	C.g_scanner_input_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(text)
	runtime.KeepAlive(textLen)
}

// LookupSymbol looks up a symbol in the current scope and return its value. If
// the symbol is not bound in the current scope, NULL is returned.
//
// The function takes the following parameters:
//
//    - symbol to look up.
//
// The function returns the following values:
//
//    - gpointer (optional): value of symbol in the current scope, or NULL if
//      symbol is not bound in the current scope.
//
func (scanner *Scanner) LookupSymbol(symbol string) cgo.Handle {
	var _arg0 *C.GScanner // out
	var _arg1 *C.gchar    // out
	var _cret C.gpointer  // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_scanner_lookup_symbol(_arg0, _arg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(symbol)

	var _gpointer cgo.Handle // out

	_gpointer = (cgo.Handle)(unsafe.Pointer(_cret))

	return _gpointer
}

// PeekNextToken parses the next token, without removing it from the input
// stream. The token data is placed in the next_token, next_value, next_line,
// and next_position fields of the #GScanner structure.
//
// Note that, while the token is not removed from the input stream (i.e. the
// next call to g_scanner_get_next_token() will return the same token), it will
// not be reevaluated. This can lead to surprising results when changing scope
// or the scanner configuration after peeking the next token. Getting the next
// token after switching the scope or configuration will return whatever was
// peeked before, regardless of any symbols that may have been added or removed
// in the new scope.
//
// The function returns the following values:
//
//    - tokenType: type of the token.
//
func (scanner *Scanner) PeekNextToken() TokenType {
	var _arg0 *C.GScanner  // out
	var _cret C.GTokenType // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	_cret = C.g_scanner_peek_next_token(_arg0)
	runtime.KeepAlive(scanner)

	var _tokenType TokenType // out

	_tokenType = TokenType(_cret)

	return _tokenType
}

// ScopeAddSymbol adds a symbol to the given scope.
//
// The function takes the following parameters:
//
//    - scopeId: scope id.
//    - symbol to add.
//    - value (optional) of the symbol.
//
func (scanner *Scanner) ScopeAddSymbol(scopeId uint, symbol string, value cgo.Handle) {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _arg2 *C.gchar    // out
	var _arg3 C.gpointer  // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (C.gpointer)(unsafe.Pointer(value))

	C.g_scanner_scope_add_symbol(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(symbol)
	runtime.KeepAlive(value)
}

// ScopeLookupSymbol looks up a symbol in a scope and return its value. If the
// symbol is not bound in the scope, NULL is returned.
//
// The function takes the following parameters:
//
//    - scopeId: scope id.
//    - symbol to look up.
//
// The function returns the following values:
//
//    - gpointer (optional): value of symbol in the given scope, or NULL if
//      symbol is not bound in the given scope.
//
func (scanner *Scanner) ScopeLookupSymbol(scopeId uint, symbol string) cgo.Handle {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _arg2 *C.gchar    // out
	var _cret C.gpointer  // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_scanner_scope_lookup_symbol(_arg0, _arg1, _arg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(symbol)

	var _gpointer cgo.Handle // out

	_gpointer = (cgo.Handle)(unsafe.Pointer(_cret))

	return _gpointer
}

// ScopeRemoveSymbol removes a symbol from a scope.
//
// The function takes the following parameters:
//
//    - scopeId: scope id.
//    - symbol to remove.
//
func (scanner *Scanner) ScopeRemoveSymbol(scopeId uint, symbol string) {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _arg2 *C.gchar    // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(symbol)))
	defer C.free(unsafe.Pointer(_arg2))

	C.g_scanner_scope_remove_symbol(_arg0, _arg1, _arg2)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)
	runtime.KeepAlive(symbol)
}

// SetScope sets the current scope.
//
// The function takes the following parameters:
//
//    - scopeId: new scope id.
//
// The function returns the following values:
//
//    - guint: old scope id.
//
func (scanner *Scanner) SetScope(scopeId uint) uint {
	var _arg0 *C.GScanner // out
	var _arg1 C.guint     // out
	var _cret C.guint     // in

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.guint(scopeId)

	_cret = C.g_scanner_set_scope(_arg0, _arg1)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(scopeId)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SyncFileOffset rewinds the filedescriptor to the current buffer position and
// blows the file read ahead buffer. This is useful for third party uses of the
// scanners filedescriptor, which hooks onto the current scanning position.
func (scanner *Scanner) SyncFileOffset() {
	var _arg0 *C.GScanner // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))

	C.g_scanner_sync_file_offset(_arg0)
	runtime.KeepAlive(scanner)
}

// UnexpToken outputs a message through the scanner's msg_handler, resulting
// from an unexpected token in the input stream. Note that you should not call
// g_scanner_peek_next_token() followed by g_scanner_unexp_token() without an
// intermediate call to g_scanner_get_next_token(), as g_scanner_unexp_token()
// evaluates the scanner's current token (not the peeked token) to construct
// part of the message.
//
// The function takes the following parameters:
//
//    - expectedToken: expected token.
//    - identifierSpec: string describing how the scanner's user refers to
//      identifiers (NULL defaults to "identifier"). This is used if
//      expected_token is G_TOKEN_IDENTIFIER or G_TOKEN_IDENTIFIER_NULL.
//    - symbolSpec: string describing how the scanner's user refers to symbols
//      (NULL defaults to "symbol"). This is used if expected_token is
//      G_TOKEN_SYMBOL or any token value greater than G_TOKEN_LAST.
//    - symbolName: name of the symbol, if the scanner's current token is a
//      symbol.
//    - message string to output at the end of the warning/error, or NULL.
//    - isError: if TRUE it is output as an error. If FALSE it is output as a
//      warning.
//
func (scanner *Scanner) UnexpToken(expectedToken TokenType, identifierSpec string, symbolSpec string, symbolName string, message string, isError int) {
	var _arg0 *C.GScanner  // out
	var _arg1 C.GTokenType // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // out
	var _arg4 *C.gchar     // out
	var _arg5 *C.gchar     // out
	var _arg6 C.gint       // out

	_arg0 = (*C.GScanner)(gextras.StructNative(unsafe.Pointer(scanner)))
	_arg1 = C.GTokenType(expectedToken)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(identifierSpec)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(symbolSpec)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(symbolName)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(message)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = C.gint(isError)

	C.g_scanner_unexp_token(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(scanner)
	runtime.KeepAlive(expectedToken)
	runtime.KeepAlive(identifierSpec)
	runtime.KeepAlive(symbolSpec)
	runtime.KeepAlive(symbolName)
	runtime.KeepAlive(message)
	runtime.KeepAlive(isError)
}

// ScannerConfig specifies the #GScanner parser configuration. Most settings can
// be changed during the parsing phase and will affect the lexical parsing of
// the next unpeeked token.
//
// An instance of this type is always passed by reference.
type ScannerConfig struct {
	*scannerConfig
}

// scannerConfig is the struct that's finalized.
type scannerConfig struct {
	native *C.GScannerConfig
}

// CsetSkipCharacters specifies which characters should be skipped by the
// scanner (the default is the whitespace characters: space, tab,
// carriage-return and line-feed).
func (s *ScannerConfig) CsetSkipCharacters() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(s.native.cset_skip_characters)))
	return v
}

// CsetIdentifierFirst specifies the characters which can start identifiers (the
// default is CSET_a_2_z, "_", and CSET_A_2_Z).
func (s *ScannerConfig) CsetIdentifierFirst() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(s.native.cset_identifier_first)))
	return v
}

// CsetIdentifierNth specifies the characters which can be used in identifiers,
// after the first character (the default is CSET_a_2_z, "_0123456789",
// CSET_A_2_Z, CSET_LATINS, CSET_LATINC).
func (s *ScannerConfig) CsetIdentifierNth() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(s.native.cset_identifier_nth)))
	return v
}

// CpairCommentSingle specifies the characters at the start and end of
// single-line comments. The default is "#\n" which means that single-line
// comments start with a '#' and continue until a '\n' (end of line).
func (s *ScannerConfig) CpairCommentSingle() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(s.native.cpair_comment_single)))
	return v
}

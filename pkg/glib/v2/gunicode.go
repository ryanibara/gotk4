// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib.h>
import "C"

// UNICHAR_MAX_DECOMPOSITION_LENGTH: maximum length (in codepoints) of a
// compatibility or canonical decomposition of a single Unicode character.
//
// This is as defined by Unicode 6.1.
const UNICHAR_MAX_DECOMPOSITION_LENGTH = 18

// NormalizeMode defines how a Unicode string is transformed in a canonical
// form, standardizing such issues as whether a character with an accent is
// represented as a base character and combining accent or as a single
// precomposed character. Unicode strings should generally be normalized before
// comparing them.
type NormalizeMode C.gint

const (
	// NormalizeDefault: standardize differences that do not affect the text
	// content, such as the above-mentioned accent representation.
	NormalizeDefault NormalizeMode = 0
	// NormalizeNFD: another name for G_NORMALIZE_DEFAULT.
	NormalizeNFD NormalizeMode = 0
	// NormalizeDefaultCompose: like G_NORMALIZE_DEFAULT, but with composed
	// forms rather than a maximally decomposed form.
	NormalizeDefaultCompose NormalizeMode = 1
	// NormalizeNFC: another name for G_NORMALIZE_DEFAULT_COMPOSE.
	NormalizeNFC NormalizeMode = 1
	// NormalizeAll: beyond G_NORMALIZE_DEFAULT also standardize the
	// "compatibility" characters in Unicode, such as SUPERSCRIPT THREE to the
	// standard forms (in this case DIGIT THREE). Formatting information may be
	// lost but for most text operations such characters should be considered
	// the same.
	NormalizeAll NormalizeMode = 2
	// NormalizeNFKD: another name for G_NORMALIZE_ALL.
	NormalizeNFKD NormalizeMode = 2
	// NormalizeAllCompose: like G_NORMALIZE_ALL, but with composed forms rather
	// than a maximally decomposed form.
	NormalizeAllCompose NormalizeMode = 3
	// NormalizeNFKC: another name for G_NORMALIZE_ALL_COMPOSE.
	NormalizeNFKC NormalizeMode = 3
)

// String returns the name in string for NormalizeMode.
func (n NormalizeMode) String() string {
	switch n {
	case NormalizeDefault:
		return "Default"
	case NormalizeDefaultCompose:
		return "DefaultCompose"
	case NormalizeAll:
		return "All"
	case NormalizeAllCompose:
		return "AllCompose"
	default:
		return fmt.Sprintf("NormalizeMode(%d)", n)
	}
}

// UnicodeBreakType: these are the possible line break classifications.
//
// Since new unicode versions may add new types here, applications should be
// ready to handle unknown values. They may be regarded as
// G_UNICODE_BREAK_UNKNOWN.
//
// See Unicode Line Breaking Algorithm
// (http://www.unicode.org/unicode/reports/tr14/).
type UnicodeBreakType C.gint

const (
	// UnicodeBreakMandatory: mandatory Break (BK).
	UnicodeBreakMandatory UnicodeBreakType = iota
	// UnicodeBreakCarriageReturn: carriage Return (CR).
	UnicodeBreakCarriageReturn
	// UnicodeBreakLineFeed: line Feed (LF).
	UnicodeBreakLineFeed
	// UnicodeBreakCombiningMark: attached Characters and Combining Marks (CM).
	UnicodeBreakCombiningMark
	// UnicodeBreakSurrogate surrogates (SG).
	UnicodeBreakSurrogate
	// UnicodeBreakZeroWidthSpace: zero Width Space (ZW).
	UnicodeBreakZeroWidthSpace
	// UnicodeBreakInseparable: inseparable (IN).
	UnicodeBreakInseparable
	// UnicodeBreakNonBreakingGlue: non-breaking ("Glue") (GL).
	UnicodeBreakNonBreakingGlue
	// UnicodeBreakContingent: contingent Break Opportunity (CB).
	UnicodeBreakContingent
	// UnicodeBreakSpace: space (SP).
	UnicodeBreakSpace
	// UnicodeBreakAfter: break Opportunity After (BA).
	UnicodeBreakAfter
	// UnicodeBreakBefore: break Opportunity Before (BB).
	UnicodeBreakBefore
	// UnicodeBreakBeforeAndAfter: break Opportunity Before and After (B2).
	UnicodeBreakBeforeAndAfter
	// UnicodeBreakHyphen: hyphen (HY).
	UnicodeBreakHyphen
	// UnicodeBreakNonStarter: nonstarter (NS).
	UnicodeBreakNonStarter
	// UnicodeBreakOpenPunctuation: opening Punctuation (OP).
	UnicodeBreakOpenPunctuation
	// UnicodeBreakClosePunctuation: closing Punctuation (CL).
	UnicodeBreakClosePunctuation
	// UnicodeBreakQuotation ambiguous Quotation (QU).
	UnicodeBreakQuotation
	// UnicodeBreakExclamation: exclamation/Interrogation (EX).
	UnicodeBreakExclamation
	// UnicodeBreakIdeographic: ideographic (ID).
	UnicodeBreakIdeographic
	// UnicodeBreakNumeric: numeric (NU).
	UnicodeBreakNumeric
	// UnicodeBreakInfixSeparator: infix Separator (Numeric) (IS).
	UnicodeBreakInfixSeparator
	// UnicodeBreakSymbol symbols Allowing Break After (SY).
	UnicodeBreakSymbol
	// UnicodeBreakAlphabetic: ordinary Alphabetic and Symbol Characters (AL).
	UnicodeBreakAlphabetic
	// UnicodeBreakPrefix: prefix (Numeric) (PR).
	UnicodeBreakPrefix
	// UnicodeBreakPostfix: postfix (Numeric) (PO).
	UnicodeBreakPostfix
	// UnicodeBreakComplexContext: complex Content Dependent (South East Asian)
	// (SA).
	UnicodeBreakComplexContext
	// UnicodeBreakAmbiguous ambiguous (Alphabetic or Ideographic) (AI).
	UnicodeBreakAmbiguous
	// UnicodeBreakUnknown: unknown (XX).
	UnicodeBreakUnknown
	// UnicodeBreakNextLine: next Line (NL).
	UnicodeBreakNextLine
	// UnicodeBreakWordJoiner: word Joiner (WJ).
	UnicodeBreakWordJoiner
	// UnicodeBreakHangulLJamo: hangul L Jamo (JL).
	UnicodeBreakHangulLJamo
	// UnicodeBreakHangulVJamo: hangul V Jamo (JV).
	UnicodeBreakHangulVJamo
	// UnicodeBreakHangulTJamo: hangul T Jamo (JT).
	UnicodeBreakHangulTJamo
	// UnicodeBreakHangulLvSyllable: hangul LV Syllable (H2).
	UnicodeBreakHangulLvSyllable
	// UnicodeBreakHangulLvtSyllable: hangul LVT Syllable (H3).
	UnicodeBreakHangulLvtSyllable
	// UnicodeBreakCloseParanthesis: closing Parenthesis (CP). Since 2.28.
	UnicodeBreakCloseParanthesis
	// UnicodeBreakConditionalJapaneseStarter: conditional Japanese Starter
	// (CJ). Since: 2.32.
	UnicodeBreakConditionalJapaneseStarter
	// UnicodeBreakHebrewLetter: hebrew Letter (HL). Since: 2.32.
	UnicodeBreakHebrewLetter
	// UnicodeBreakRegionalIndicator: regional Indicator (RI). Since: 2.36.
	UnicodeBreakRegionalIndicator
	// UnicodeBreakEmojiBase: emoji Base (EB). Since: 2.50.
	UnicodeBreakEmojiBase
	// UnicodeBreakEmojiModifier: emoji Modifier (EM). Since: 2.50.
	UnicodeBreakEmojiModifier
	// UnicodeBreakZeroWidthJoiner: zero Width Joiner (ZWJ). Since: 2.50.
	UnicodeBreakZeroWidthJoiner
)

// String returns the name in string for UnicodeBreakType.
func (u UnicodeBreakType) String() string {
	switch u {
	case UnicodeBreakMandatory:
		return "Mandatory"
	case UnicodeBreakCarriageReturn:
		return "CarriageReturn"
	case UnicodeBreakLineFeed:
		return "LineFeed"
	case UnicodeBreakCombiningMark:
		return "CombiningMark"
	case UnicodeBreakSurrogate:
		return "Surrogate"
	case UnicodeBreakZeroWidthSpace:
		return "ZeroWidthSpace"
	case UnicodeBreakInseparable:
		return "Inseparable"
	case UnicodeBreakNonBreakingGlue:
		return "NonBreakingGlue"
	case UnicodeBreakContingent:
		return "Contingent"
	case UnicodeBreakSpace:
		return "Space"
	case UnicodeBreakAfter:
		return "After"
	case UnicodeBreakBefore:
		return "Before"
	case UnicodeBreakBeforeAndAfter:
		return "BeforeAndAfter"
	case UnicodeBreakHyphen:
		return "Hyphen"
	case UnicodeBreakNonStarter:
		return "NonStarter"
	case UnicodeBreakOpenPunctuation:
		return "OpenPunctuation"
	case UnicodeBreakClosePunctuation:
		return "ClosePunctuation"
	case UnicodeBreakQuotation:
		return "Quotation"
	case UnicodeBreakExclamation:
		return "Exclamation"
	case UnicodeBreakIdeographic:
		return "Ideographic"
	case UnicodeBreakNumeric:
		return "Numeric"
	case UnicodeBreakInfixSeparator:
		return "InfixSeparator"
	case UnicodeBreakSymbol:
		return "Symbol"
	case UnicodeBreakAlphabetic:
		return "Alphabetic"
	case UnicodeBreakPrefix:
		return "Prefix"
	case UnicodeBreakPostfix:
		return "Postfix"
	case UnicodeBreakComplexContext:
		return "ComplexContext"
	case UnicodeBreakAmbiguous:
		return "Ambiguous"
	case UnicodeBreakUnknown:
		return "Unknown"
	case UnicodeBreakNextLine:
		return "NextLine"
	case UnicodeBreakWordJoiner:
		return "WordJoiner"
	case UnicodeBreakHangulLJamo:
		return "HangulLJamo"
	case UnicodeBreakHangulVJamo:
		return "HangulVJamo"
	case UnicodeBreakHangulTJamo:
		return "HangulTJamo"
	case UnicodeBreakHangulLvSyllable:
		return "HangulLvSyllable"
	case UnicodeBreakHangulLvtSyllable:
		return "HangulLvtSyllable"
	case UnicodeBreakCloseParanthesis:
		return "CloseParanthesis"
	case UnicodeBreakConditionalJapaneseStarter:
		return "ConditionalJapaneseStarter"
	case UnicodeBreakHebrewLetter:
		return "HebrewLetter"
	case UnicodeBreakRegionalIndicator:
		return "RegionalIndicator"
	case UnicodeBreakEmojiBase:
		return "EmojiBase"
	case UnicodeBreakEmojiModifier:
		return "EmojiModifier"
	case UnicodeBreakZeroWidthJoiner:
		return "ZeroWidthJoiner"
	default:
		return fmt.Sprintf("UnicodeBreakType(%d)", u)
	}
}

// UnicodeScript enumeration identifies different writing systems. The values
// correspond to the names as defined in the Unicode standard. The enumeration
// has been added in GLib 2.14, and is interchangeable with Script.
//
// Note that new types may be added in the future. Applications should be ready
// to handle unknown values. See Unicode Standard Annex #24: Script names
// (http://www.unicode.org/reports/tr24/).
type UnicodeScript C.gint

const (
	// UnicodeScriptInvalidCode: value never returned from
	// g_unichar_get_script().
	UnicodeScriptInvalidCode UnicodeScript = -1
	// UnicodeScriptCommon: character used by multiple different scripts.
	UnicodeScriptCommon UnicodeScript = 0
	// UnicodeScriptInherited: mark glyph that takes its script from the base
	// glyph to which it is attached.
	UnicodeScriptInherited UnicodeScript = 1
	// UnicodeScriptArabic: arabic.
	UnicodeScriptArabic UnicodeScript = 2
	// UnicodeScriptArmenian: armenian.
	UnicodeScriptArmenian UnicodeScript = 3
	// UnicodeScriptBengali: bengali.
	UnicodeScriptBengali UnicodeScript = 4
	// UnicodeScriptBopomofo: bopomofo.
	UnicodeScriptBopomofo UnicodeScript = 5
	// UnicodeScriptCherokee: cherokee.
	UnicodeScriptCherokee UnicodeScript = 6
	// UnicodeScriptCoptic: coptic.
	UnicodeScriptCoptic UnicodeScript = 7
	// UnicodeScriptCyrillic: cyrillic.
	UnicodeScriptCyrillic UnicodeScript = 8
	// UnicodeScriptDeseret: deseret.
	UnicodeScriptDeseret UnicodeScript = 9
	// UnicodeScriptDevanagari: devanagari.
	UnicodeScriptDevanagari UnicodeScript = 10
	// UnicodeScriptEthiopic: ethiopic.
	UnicodeScriptEthiopic UnicodeScript = 11
	// UnicodeScriptGeorgian: georgian.
	UnicodeScriptGeorgian UnicodeScript = 12
	// UnicodeScriptGothic: gothic.
	UnicodeScriptGothic UnicodeScript = 13
	// UnicodeScriptGreek: greek.
	UnicodeScriptGreek UnicodeScript = 14
	// UnicodeScriptGujarati: gujarati.
	UnicodeScriptGujarati UnicodeScript = 15
	// UnicodeScriptGurmukhi: gurmukhi.
	UnicodeScriptGurmukhi UnicodeScript = 16
	// UnicodeScriptHan: han.
	UnicodeScriptHan UnicodeScript = 17
	// UnicodeScriptHangul: hangul.
	UnicodeScriptHangul UnicodeScript = 18
	// UnicodeScriptHebrew: hebrew.
	UnicodeScriptHebrew UnicodeScript = 19
	// UnicodeScriptHiragana: hiragana.
	UnicodeScriptHiragana UnicodeScript = 20
	// UnicodeScriptKannada: kannada.
	UnicodeScriptKannada UnicodeScript = 21
	// UnicodeScriptKatakana: katakana.
	UnicodeScriptKatakana UnicodeScript = 22
	// UnicodeScriptKhmer: khmer.
	UnicodeScriptKhmer UnicodeScript = 23
	// UnicodeScriptLao: lao.
	UnicodeScriptLao UnicodeScript = 24
	// UnicodeScriptLatin: latin.
	UnicodeScriptLatin UnicodeScript = 25
	// UnicodeScriptMalayalam: malayalam.
	UnicodeScriptMalayalam UnicodeScript = 26
	// UnicodeScriptMongolian: mongolian.
	UnicodeScriptMongolian UnicodeScript = 27
	// UnicodeScriptMyanmar: myanmar.
	UnicodeScriptMyanmar UnicodeScript = 28
	// UnicodeScriptOgham: ogham.
	UnicodeScriptOgham UnicodeScript = 29
	// UnicodeScriptOldItalic: old Italic.
	UnicodeScriptOldItalic UnicodeScript = 30
	// UnicodeScriptOriya: oriya.
	UnicodeScriptOriya UnicodeScript = 31
	// UnicodeScriptRunic: runic.
	UnicodeScriptRunic UnicodeScript = 32
	// UnicodeScriptSinhala: sinhala.
	UnicodeScriptSinhala UnicodeScript = 33
	// UnicodeScriptSyriac: syriac.
	UnicodeScriptSyriac UnicodeScript = 34
	// UnicodeScriptTamil: tamil.
	UnicodeScriptTamil UnicodeScript = 35
	// UnicodeScriptTelugu: telugu.
	UnicodeScriptTelugu UnicodeScript = 36
	// UnicodeScriptThaana: thaana.
	UnicodeScriptThaana UnicodeScript = 37
	// UnicodeScriptThai: thai.
	UnicodeScriptThai UnicodeScript = 38
	// UnicodeScriptTibetan: tibetan.
	UnicodeScriptTibetan UnicodeScript = 39
	// UnicodeScriptCanadianAboriginal: canadian Aboriginal.
	UnicodeScriptCanadianAboriginal UnicodeScript = 40
	// UnicodeScriptYi: yi.
	UnicodeScriptYi UnicodeScript = 41
	// UnicodeScriptTagalog: tagalog.
	UnicodeScriptTagalog UnicodeScript = 42
	// UnicodeScriptHanunoo: hanunoo.
	UnicodeScriptHanunoo UnicodeScript = 43
	// UnicodeScriptBuhid: buhid.
	UnicodeScriptBuhid UnicodeScript = 44
	// UnicodeScriptTagbanwa: tagbanwa.
	UnicodeScriptTagbanwa UnicodeScript = 45
	// UnicodeScriptBraille: braille.
	UnicodeScriptBraille UnicodeScript = 46
	// UnicodeScriptCypriot: cypriot.
	UnicodeScriptCypriot UnicodeScript = 47
	// UnicodeScriptLimbu: limbu.
	UnicodeScriptLimbu UnicodeScript = 48
	// UnicodeScriptOsmanya: osmanya.
	UnicodeScriptOsmanya UnicodeScript = 49
	// UnicodeScriptShavian: shavian.
	UnicodeScriptShavian UnicodeScript = 50
	// UnicodeScriptLinearB: linear B.
	UnicodeScriptLinearB UnicodeScript = 51
	// UnicodeScriptTaiLe: tai Le.
	UnicodeScriptTaiLe UnicodeScript = 52
	// UnicodeScriptUgaritic: ugaritic.
	UnicodeScriptUgaritic UnicodeScript = 53
	// UnicodeScriptNewTaiLue: new Tai Lue.
	UnicodeScriptNewTaiLue UnicodeScript = 54
	// UnicodeScriptBuginese: buginese.
	UnicodeScriptBuginese UnicodeScript = 55
	// UnicodeScriptGlagolitic: glagolitic.
	UnicodeScriptGlagolitic UnicodeScript = 56
	// UnicodeScriptTifinagh: tifinagh.
	UnicodeScriptTifinagh UnicodeScript = 57
	// UnicodeScriptSylotiNagri: syloti Nagri.
	UnicodeScriptSylotiNagri UnicodeScript = 58
	// UnicodeScriptOldPersian: old Persian.
	UnicodeScriptOldPersian UnicodeScript = 59
	// UnicodeScriptKharoshthi: kharoshthi.
	UnicodeScriptKharoshthi UnicodeScript = 60
	// UnicodeScriptUnknown: unassigned code point.
	UnicodeScriptUnknown UnicodeScript = 61
	// UnicodeScriptBalinese: balinese.
	UnicodeScriptBalinese UnicodeScript = 62
	// UnicodeScriptCuneiform: cuneiform.
	UnicodeScriptCuneiform UnicodeScript = 63
	// UnicodeScriptPhoenician: phoenician.
	UnicodeScriptPhoenician UnicodeScript = 64
	// UnicodeScriptPhagsPa: phags-pa.
	UnicodeScriptPhagsPa UnicodeScript = 65
	// UnicodeScriptNko: n'Ko.
	UnicodeScriptNko UnicodeScript = 66
	// UnicodeScriptKayahLi: kayah Li. Since 2.16.3.
	UnicodeScriptKayahLi UnicodeScript = 67
	// UnicodeScriptLepcha: lepcha. Since 2.16.3.
	UnicodeScriptLepcha UnicodeScript = 68
	// UnicodeScriptRejang: rejang. Since 2.16.3.
	UnicodeScriptRejang UnicodeScript = 69
	// UnicodeScriptSundanese: sundanese. Since 2.16.3.
	UnicodeScriptSundanese UnicodeScript = 70
	// UnicodeScriptSaurashtra: saurashtra. Since 2.16.3.
	UnicodeScriptSaurashtra UnicodeScript = 71
	// UnicodeScriptCham: cham. Since 2.16.3.
	UnicodeScriptCham UnicodeScript = 72
	// UnicodeScriptOlChiki: ol Chiki. Since 2.16.3.
	UnicodeScriptOlChiki UnicodeScript = 73
	// UnicodeScriptVai: vai. Since 2.16.3.
	UnicodeScriptVai UnicodeScript = 74
	// UnicodeScriptCarian: carian. Since 2.16.3.
	UnicodeScriptCarian UnicodeScript = 75
	// UnicodeScriptLycian: lycian. Since 2.16.3.
	UnicodeScriptLycian UnicodeScript = 76
	// UnicodeScriptLydian: lydian. Since 2.16.3.
	UnicodeScriptLydian UnicodeScript = 77
	// UnicodeScriptAvestan: avestan. Since 2.26.
	UnicodeScriptAvestan UnicodeScript = 78
	// UnicodeScriptBamum: bamum. Since 2.26.
	UnicodeScriptBamum UnicodeScript = 79
	// UnicodeScriptEgyptianHieroglyphs: egyptian Hieroglpyhs. Since 2.26.
	UnicodeScriptEgyptianHieroglyphs UnicodeScript = 80
	// UnicodeScriptImperialAramaic: imperial Aramaic. Since 2.26.
	UnicodeScriptImperialAramaic UnicodeScript = 81
	// UnicodeScriptInscriptionalPahlavi: inscriptional Pahlavi. Since 2.26.
	UnicodeScriptInscriptionalPahlavi UnicodeScript = 82
	// UnicodeScriptInscriptionalParthian: inscriptional Parthian. Since 2.26.
	UnicodeScriptInscriptionalParthian UnicodeScript = 83
	// UnicodeScriptJavanese: javanese. Since 2.26.
	UnicodeScriptJavanese UnicodeScript = 84
	// UnicodeScriptKaithi: kaithi. Since 2.26.
	UnicodeScriptKaithi UnicodeScript = 85
	// UnicodeScriptLisu: lisu. Since 2.26.
	UnicodeScriptLisu UnicodeScript = 86
	// UnicodeScriptMeeteiMayek: meetei Mayek. Since 2.26.
	UnicodeScriptMeeteiMayek UnicodeScript = 87
	// UnicodeScriptOldSouthArabian: old South Arabian. Since 2.26.
	UnicodeScriptOldSouthArabian UnicodeScript = 88
	// UnicodeScriptOldTurkic: old Turkic. Since 2.28.
	UnicodeScriptOldTurkic UnicodeScript = 89
	// UnicodeScriptSamaritan: samaritan. Since 2.26.
	UnicodeScriptSamaritan UnicodeScript = 90
	// UnicodeScriptTaiTham: tai Tham. Since 2.26.
	UnicodeScriptTaiTham UnicodeScript = 91
	// UnicodeScriptTaiViet: tai Viet. Since 2.26.
	UnicodeScriptTaiViet UnicodeScript = 92
	// UnicodeScriptBatak: batak. Since 2.28.
	UnicodeScriptBatak UnicodeScript = 93
	// UnicodeScriptBrahmi: brahmi. Since 2.28.
	UnicodeScriptBrahmi UnicodeScript = 94
	// UnicodeScriptMandaic: mandaic. Since 2.28.
	UnicodeScriptMandaic UnicodeScript = 95
	// UnicodeScriptChakma: chakma. Since: 2.32.
	UnicodeScriptChakma UnicodeScript = 96
	// UnicodeScriptMeroiticCursive: meroitic Cursive. Since: 2.32.
	UnicodeScriptMeroiticCursive UnicodeScript = 97
	// UnicodeScriptMeroiticHieroglyphs: meroitic Hieroglyphs. Since: 2.32.
	UnicodeScriptMeroiticHieroglyphs UnicodeScript = 98
	// UnicodeScriptMiao: miao. Since: 2.32.
	UnicodeScriptMiao UnicodeScript = 99
	// UnicodeScriptSharada: sharada. Since: 2.32.
	UnicodeScriptSharada UnicodeScript = 100
	// UnicodeScriptSoraSompeng: sora Sompeng. Since: 2.32.
	UnicodeScriptSoraSompeng UnicodeScript = 101
	// UnicodeScriptTakri: takri. Since: 2.32.
	UnicodeScriptTakri UnicodeScript = 102
	// UnicodeScriptBassaVah: bassa. Since: 2.42.
	UnicodeScriptBassaVah UnicodeScript = 103
	// UnicodeScriptCaucasianAlbanian: caucasian Albanian. Since: 2.42.
	UnicodeScriptCaucasianAlbanian UnicodeScript = 104
	// UnicodeScriptDuployan: duployan. Since: 2.42.
	UnicodeScriptDuployan UnicodeScript = 105
	// UnicodeScriptElbasan: elbasan. Since: 2.42.
	UnicodeScriptElbasan UnicodeScript = 106
	// UnicodeScriptGrantha: grantha. Since: 2.42.
	UnicodeScriptGrantha UnicodeScript = 107
	// UnicodeScriptKhojki: kjohki. Since: 2.42.
	UnicodeScriptKhojki UnicodeScript = 108
	// UnicodeScriptKhudawadi: khudawadi, Sindhi. Since: 2.42.
	UnicodeScriptKhudawadi UnicodeScript = 109
	// UnicodeScriptLinearA: linear A. Since: 2.42.
	UnicodeScriptLinearA UnicodeScript = 110
	// UnicodeScriptMahajani: mahajani. Since: 2.42.
	UnicodeScriptMahajani UnicodeScript = 111
	// UnicodeScriptManichaean: manichaean. Since: 2.42.
	UnicodeScriptManichaean UnicodeScript = 112
	// UnicodeScriptMendeKikakui: mende Kikakui. Since: 2.42.
	UnicodeScriptMendeKikakui UnicodeScript = 113
	// UnicodeScriptModi: modi. Since: 2.42.
	UnicodeScriptModi UnicodeScript = 114
	// UnicodeScriptMro: mro. Since: 2.42.
	UnicodeScriptMro UnicodeScript = 115
	// UnicodeScriptNabataean: nabataean. Since: 2.42.
	UnicodeScriptNabataean UnicodeScript = 116
	// UnicodeScriptOldNorthArabian: old North Arabian. Since: 2.42.
	UnicodeScriptOldNorthArabian UnicodeScript = 117
	// UnicodeScriptOldPermic: old Permic. Since: 2.42.
	UnicodeScriptOldPermic UnicodeScript = 118
	// UnicodeScriptPahawhHmong: pahawh Hmong. Since: 2.42.
	UnicodeScriptPahawhHmong UnicodeScript = 119
	// UnicodeScriptPalmyrene: palmyrene. Since: 2.42.
	UnicodeScriptPalmyrene UnicodeScript = 120
	// UnicodeScriptPauCinHau: pau Cin Hau. Since: 2.42.
	UnicodeScriptPauCinHau UnicodeScript = 121
	// UnicodeScriptPsalterPahlavi: psalter Pahlavi. Since: 2.42.
	UnicodeScriptPsalterPahlavi UnicodeScript = 122
	// UnicodeScriptSiddham: siddham. Since: 2.42.
	UnicodeScriptSiddham UnicodeScript = 123
	// UnicodeScriptTirhuta: tirhuta. Since: 2.42.
	UnicodeScriptTirhuta UnicodeScript = 124
	// UnicodeScriptWarangCiti: warang Citi. Since: 2.42.
	UnicodeScriptWarangCiti UnicodeScript = 125
	// UnicodeScriptAhom: ahom. Since: 2.48.
	UnicodeScriptAhom UnicodeScript = 126
	// UnicodeScriptAnatolianHieroglyphs: anatolian Hieroglyphs. Since: 2.48.
	UnicodeScriptAnatolianHieroglyphs UnicodeScript = 127
	// UnicodeScriptHatran: hatran. Since: 2.48.
	UnicodeScriptHatran UnicodeScript = 128
	// UnicodeScriptMultani: multani. Since: 2.48.
	UnicodeScriptMultani UnicodeScript = 129
	// UnicodeScriptOldHungarian: old Hungarian. Since: 2.48.
	UnicodeScriptOldHungarian UnicodeScript = 130
	// UnicodeScriptSignwriting: signwriting. Since: 2.48.
	UnicodeScriptSignwriting UnicodeScript = 131
	// UnicodeScriptAdlam: adlam. Since: 2.50.
	UnicodeScriptAdlam UnicodeScript = 132
	// UnicodeScriptBhaiksuki: bhaiksuki. Since: 2.50.
	UnicodeScriptBhaiksuki UnicodeScript = 133
	// UnicodeScriptMarchen: marchen. Since: 2.50.
	UnicodeScriptMarchen UnicodeScript = 134
	// UnicodeScriptNewa: newa. Since: 2.50.
	UnicodeScriptNewa UnicodeScript = 135
	// UnicodeScriptOsage: osage. Since: 2.50.
	UnicodeScriptOsage UnicodeScript = 136
	// UnicodeScriptTangut: tangut. Since: 2.50.
	UnicodeScriptTangut UnicodeScript = 137
	// UnicodeScriptMasaramGondi: masaram Gondi. Since: 2.54.
	UnicodeScriptMasaramGondi UnicodeScript = 138
	// UnicodeScriptNushu: nushu. Since: 2.54.
	UnicodeScriptNushu UnicodeScript = 139
	// UnicodeScriptSoyombo: soyombo. Since: 2.54.
	UnicodeScriptSoyombo UnicodeScript = 140
	// UnicodeScriptZanabazarSquare: zanabazar Square. Since: 2.54.
	UnicodeScriptZanabazarSquare UnicodeScript = 141
	// UnicodeScriptDogra: dogra. Since: 2.58.
	UnicodeScriptDogra UnicodeScript = 142
	// UnicodeScriptGunjalaGondi: gunjala Gondi. Since: 2.58.
	UnicodeScriptGunjalaGondi UnicodeScript = 143
	// UnicodeScriptHanifiRohingya: hanifi Rohingya. Since: 2.58.
	UnicodeScriptHanifiRohingya UnicodeScript = 144
	// UnicodeScriptMakasar: makasar. Since: 2.58.
	UnicodeScriptMakasar UnicodeScript = 145
	// UnicodeScriptMedefaidrin: medefaidrin. Since: 2.58.
	UnicodeScriptMedefaidrin UnicodeScript = 146
	// UnicodeScriptOldSogdian: old Sogdian. Since: 2.58.
	UnicodeScriptOldSogdian UnicodeScript = 147
	// UnicodeScriptSogdian: sogdian. Since: 2.58.
	UnicodeScriptSogdian UnicodeScript = 148
	// UnicodeScriptElymaic: elym. Since: 2.62.
	UnicodeScriptElymaic UnicodeScript = 149
	// UnicodeScriptNandinagari: nand. Since: 2.62.
	UnicodeScriptNandinagari UnicodeScript = 150
	// UnicodeScriptNyiakengPuachueHmong: rohg. Since: 2.62.
	UnicodeScriptNyiakengPuachueHmong UnicodeScript = 151
	// UnicodeScriptWancho: wcho. Since: 2.62.
	UnicodeScriptWancho UnicodeScript = 152
	// UnicodeScriptChorasmian: chorasmian. Since: 2.66.
	UnicodeScriptChorasmian UnicodeScript = 153
	// UnicodeScriptDivesAkuru dives Akuru. Since: 2.66.
	UnicodeScriptDivesAkuru UnicodeScript = 154
	// UnicodeScriptKhitanSmallScript: khitan small script. Since: 2.66.
	UnicodeScriptKhitanSmallScript UnicodeScript = 155
	// UnicodeScriptYezidi: yezidi. Since: 2.66.
	UnicodeScriptYezidi UnicodeScript = 156
)

// String returns the name in string for UnicodeScript.
func (u UnicodeScript) String() string {
	switch u {
	case UnicodeScriptInvalidCode:
		return "InvalidCode"
	case UnicodeScriptCommon:
		return "Common"
	case UnicodeScriptInherited:
		return "Inherited"
	case UnicodeScriptArabic:
		return "Arabic"
	case UnicodeScriptArmenian:
		return "Armenian"
	case UnicodeScriptBengali:
		return "Bengali"
	case UnicodeScriptBopomofo:
		return "Bopomofo"
	case UnicodeScriptCherokee:
		return "Cherokee"
	case UnicodeScriptCoptic:
		return "Coptic"
	case UnicodeScriptCyrillic:
		return "Cyrillic"
	case UnicodeScriptDeseret:
		return "Deseret"
	case UnicodeScriptDevanagari:
		return "Devanagari"
	case UnicodeScriptEthiopic:
		return "Ethiopic"
	case UnicodeScriptGeorgian:
		return "Georgian"
	case UnicodeScriptGothic:
		return "Gothic"
	case UnicodeScriptGreek:
		return "Greek"
	case UnicodeScriptGujarati:
		return "Gujarati"
	case UnicodeScriptGurmukhi:
		return "Gurmukhi"
	case UnicodeScriptHan:
		return "Han"
	case UnicodeScriptHangul:
		return "Hangul"
	case UnicodeScriptHebrew:
		return "Hebrew"
	case UnicodeScriptHiragana:
		return "Hiragana"
	case UnicodeScriptKannada:
		return "Kannada"
	case UnicodeScriptKatakana:
		return "Katakana"
	case UnicodeScriptKhmer:
		return "Khmer"
	case UnicodeScriptLao:
		return "Lao"
	case UnicodeScriptLatin:
		return "Latin"
	case UnicodeScriptMalayalam:
		return "Malayalam"
	case UnicodeScriptMongolian:
		return "Mongolian"
	case UnicodeScriptMyanmar:
		return "Myanmar"
	case UnicodeScriptOgham:
		return "Ogham"
	case UnicodeScriptOldItalic:
		return "OldItalic"
	case UnicodeScriptOriya:
		return "Oriya"
	case UnicodeScriptRunic:
		return "Runic"
	case UnicodeScriptSinhala:
		return "Sinhala"
	case UnicodeScriptSyriac:
		return "Syriac"
	case UnicodeScriptTamil:
		return "Tamil"
	case UnicodeScriptTelugu:
		return "Telugu"
	case UnicodeScriptThaana:
		return "Thaana"
	case UnicodeScriptThai:
		return "Thai"
	case UnicodeScriptTibetan:
		return "Tibetan"
	case UnicodeScriptCanadianAboriginal:
		return "CanadianAboriginal"
	case UnicodeScriptYi:
		return "Yi"
	case UnicodeScriptTagalog:
		return "Tagalog"
	case UnicodeScriptHanunoo:
		return "Hanunoo"
	case UnicodeScriptBuhid:
		return "Buhid"
	case UnicodeScriptTagbanwa:
		return "Tagbanwa"
	case UnicodeScriptBraille:
		return "Braille"
	case UnicodeScriptCypriot:
		return "Cypriot"
	case UnicodeScriptLimbu:
		return "Limbu"
	case UnicodeScriptOsmanya:
		return "Osmanya"
	case UnicodeScriptShavian:
		return "Shavian"
	case UnicodeScriptLinearB:
		return "LinearB"
	case UnicodeScriptTaiLe:
		return "TaiLe"
	case UnicodeScriptUgaritic:
		return "Ugaritic"
	case UnicodeScriptNewTaiLue:
		return "NewTaiLue"
	case UnicodeScriptBuginese:
		return "Buginese"
	case UnicodeScriptGlagolitic:
		return "Glagolitic"
	case UnicodeScriptTifinagh:
		return "Tifinagh"
	case UnicodeScriptSylotiNagri:
		return "SylotiNagri"
	case UnicodeScriptOldPersian:
		return "OldPersian"
	case UnicodeScriptKharoshthi:
		return "Kharoshthi"
	case UnicodeScriptUnknown:
		return "Unknown"
	case UnicodeScriptBalinese:
		return "Balinese"
	case UnicodeScriptCuneiform:
		return "Cuneiform"
	case UnicodeScriptPhoenician:
		return "Phoenician"
	case UnicodeScriptPhagsPa:
		return "PhagsPa"
	case UnicodeScriptNko:
		return "Nko"
	case UnicodeScriptKayahLi:
		return "KayahLi"
	case UnicodeScriptLepcha:
		return "Lepcha"
	case UnicodeScriptRejang:
		return "Rejang"
	case UnicodeScriptSundanese:
		return "Sundanese"
	case UnicodeScriptSaurashtra:
		return "Saurashtra"
	case UnicodeScriptCham:
		return "Cham"
	case UnicodeScriptOlChiki:
		return "OlChiki"
	case UnicodeScriptVai:
		return "Vai"
	case UnicodeScriptCarian:
		return "Carian"
	case UnicodeScriptLycian:
		return "Lycian"
	case UnicodeScriptLydian:
		return "Lydian"
	case UnicodeScriptAvestan:
		return "Avestan"
	case UnicodeScriptBamum:
		return "Bamum"
	case UnicodeScriptEgyptianHieroglyphs:
		return "EgyptianHieroglyphs"
	case UnicodeScriptImperialAramaic:
		return "ImperialAramaic"
	case UnicodeScriptInscriptionalPahlavi:
		return "InscriptionalPahlavi"
	case UnicodeScriptInscriptionalParthian:
		return "InscriptionalParthian"
	case UnicodeScriptJavanese:
		return "Javanese"
	case UnicodeScriptKaithi:
		return "Kaithi"
	case UnicodeScriptLisu:
		return "Lisu"
	case UnicodeScriptMeeteiMayek:
		return "MeeteiMayek"
	case UnicodeScriptOldSouthArabian:
		return "OldSouthArabian"
	case UnicodeScriptOldTurkic:
		return "OldTurkic"
	case UnicodeScriptSamaritan:
		return "Samaritan"
	case UnicodeScriptTaiTham:
		return "TaiTham"
	case UnicodeScriptTaiViet:
		return "TaiViet"
	case UnicodeScriptBatak:
		return "Batak"
	case UnicodeScriptBrahmi:
		return "Brahmi"
	case UnicodeScriptMandaic:
		return "Mandaic"
	case UnicodeScriptChakma:
		return "Chakma"
	case UnicodeScriptMeroiticCursive:
		return "MeroiticCursive"
	case UnicodeScriptMeroiticHieroglyphs:
		return "MeroiticHieroglyphs"
	case UnicodeScriptMiao:
		return "Miao"
	case UnicodeScriptSharada:
		return "Sharada"
	case UnicodeScriptSoraSompeng:
		return "SoraSompeng"
	case UnicodeScriptTakri:
		return "Takri"
	case UnicodeScriptBassaVah:
		return "BassaVah"
	case UnicodeScriptCaucasianAlbanian:
		return "CaucasianAlbanian"
	case UnicodeScriptDuployan:
		return "Duployan"
	case UnicodeScriptElbasan:
		return "Elbasan"
	case UnicodeScriptGrantha:
		return "Grantha"
	case UnicodeScriptKhojki:
		return "Khojki"
	case UnicodeScriptKhudawadi:
		return "Khudawadi"
	case UnicodeScriptLinearA:
		return "LinearA"
	case UnicodeScriptMahajani:
		return "Mahajani"
	case UnicodeScriptManichaean:
		return "Manichaean"
	case UnicodeScriptMendeKikakui:
		return "MendeKikakui"
	case UnicodeScriptModi:
		return "Modi"
	case UnicodeScriptMro:
		return "Mro"
	case UnicodeScriptNabataean:
		return "Nabataean"
	case UnicodeScriptOldNorthArabian:
		return "OldNorthArabian"
	case UnicodeScriptOldPermic:
		return "OldPermic"
	case UnicodeScriptPahawhHmong:
		return "PahawhHmong"
	case UnicodeScriptPalmyrene:
		return "Palmyrene"
	case UnicodeScriptPauCinHau:
		return "PauCinHau"
	case UnicodeScriptPsalterPahlavi:
		return "PsalterPahlavi"
	case UnicodeScriptSiddham:
		return "Siddham"
	case UnicodeScriptTirhuta:
		return "Tirhuta"
	case UnicodeScriptWarangCiti:
		return "WarangCiti"
	case UnicodeScriptAhom:
		return "Ahom"
	case UnicodeScriptAnatolianHieroglyphs:
		return "AnatolianHieroglyphs"
	case UnicodeScriptHatran:
		return "Hatran"
	case UnicodeScriptMultani:
		return "Multani"
	case UnicodeScriptOldHungarian:
		return "OldHungarian"
	case UnicodeScriptSignwriting:
		return "Signwriting"
	case UnicodeScriptAdlam:
		return "Adlam"
	case UnicodeScriptBhaiksuki:
		return "Bhaiksuki"
	case UnicodeScriptMarchen:
		return "Marchen"
	case UnicodeScriptNewa:
		return "Newa"
	case UnicodeScriptOsage:
		return "Osage"
	case UnicodeScriptTangut:
		return "Tangut"
	case UnicodeScriptMasaramGondi:
		return "MasaramGondi"
	case UnicodeScriptNushu:
		return "Nushu"
	case UnicodeScriptSoyombo:
		return "Soyombo"
	case UnicodeScriptZanabazarSquare:
		return "ZanabazarSquare"
	case UnicodeScriptDogra:
		return "Dogra"
	case UnicodeScriptGunjalaGondi:
		return "GunjalaGondi"
	case UnicodeScriptHanifiRohingya:
		return "HanifiRohingya"
	case UnicodeScriptMakasar:
		return "Makasar"
	case UnicodeScriptMedefaidrin:
		return "Medefaidrin"
	case UnicodeScriptOldSogdian:
		return "OldSogdian"
	case UnicodeScriptSogdian:
		return "Sogdian"
	case UnicodeScriptElymaic:
		return "Elymaic"
	case UnicodeScriptNandinagari:
		return "Nandinagari"
	case UnicodeScriptNyiakengPuachueHmong:
		return "NyiakengPuachueHmong"
	case UnicodeScriptWancho:
		return "Wancho"
	case UnicodeScriptChorasmian:
		return "Chorasmian"
	case UnicodeScriptDivesAkuru:
		return "DivesAkuru"
	case UnicodeScriptKhitanSmallScript:
		return "KhitanSmallScript"
	case UnicodeScriptYezidi:
		return "Yezidi"
	default:
		return fmt.Sprintf("UnicodeScript(%d)", u)
	}
}

// UnicodeType: these are the possible character classifications from the
// Unicode specification. See Unicode Character Database
// (http://www.unicode.org/reports/tr44/Category_Values).
type UnicodeType C.gint

const (
	// UnicodeControl: general category "Other, Control" (Cc).
	UnicodeControl UnicodeType = iota
	// UnicodeFormat: general category "Other, Format" (Cf).
	UnicodeFormat
	// UnicodeUnassigned: general category "Other, Not Assigned" (Cn).
	UnicodeUnassigned
	// UnicodePrivateUse: general category "Other, Private Use" (Co).
	UnicodePrivateUse
	// UnicodeSurrogate: general category "Other, Surrogate" (Cs).
	UnicodeSurrogate
	// UnicodeLowercaseLetter: general category "Letter, Lowercase" (Ll).
	UnicodeLowercaseLetter
	// UnicodeModifierLetter: general category "Letter, Modifier" (Lm).
	UnicodeModifierLetter
	// UnicodeOtherLetter: general category "Letter, Other" (Lo).
	UnicodeOtherLetter
	// UnicodeTitlecaseLetter: general category "Letter, Titlecase" (Lt).
	UnicodeTitlecaseLetter
	// UnicodeUppercaseLetter: general category "Letter, Uppercase" (Lu).
	UnicodeUppercaseLetter
	// UnicodeSpacingMark: general category "Mark, Spacing" (Mc).
	UnicodeSpacingMark
	// UnicodeEnclosingMark: general category "Mark, Enclosing" (Me).
	UnicodeEnclosingMark
	// UnicodeNonSpacingMark: general category "Mark, Nonspacing" (Mn).
	UnicodeNonSpacingMark
	// UnicodeDecimalNumber: general category "Number, Decimal Digit" (Nd).
	UnicodeDecimalNumber
	// UnicodeLetterNumber: general category "Number, Letter" (Nl).
	UnicodeLetterNumber
	// UnicodeOtherNumber: general category "Number, Other" (No).
	UnicodeOtherNumber
	// UnicodeConnectPunctuation: general category "Punctuation, Connector"
	// (Pc).
	UnicodeConnectPunctuation
	// UnicodeDashPunctuation: general category "Punctuation, Dash" (Pd).
	UnicodeDashPunctuation
	// UnicodeClosePunctuation: general category "Punctuation, Close" (Pe).
	UnicodeClosePunctuation
	// UnicodeFinalPunctuation: general category "Punctuation, Final quote"
	// (Pf).
	UnicodeFinalPunctuation
	// UnicodeInitialPunctuation: general category "Punctuation, Initial quote"
	// (Pi).
	UnicodeInitialPunctuation
	// UnicodeOtherPunctuation: general category "Punctuation, Other" (Po).
	UnicodeOtherPunctuation
	// UnicodeOpenPunctuation: general category "Punctuation, Open" (Ps).
	UnicodeOpenPunctuation
	// UnicodeCurrencySymbol: general category "Symbol, Currency" (Sc).
	UnicodeCurrencySymbol
	// UnicodeModifierSymbol: general category "Symbol, Modifier" (Sk).
	UnicodeModifierSymbol
	// UnicodeMathSymbol: general category "Symbol, Math" (Sm).
	UnicodeMathSymbol
	// UnicodeOtherSymbol: general category "Symbol, Other" (So).
	UnicodeOtherSymbol
	// UnicodeLineSeparator: general category "Separator, Line" (Zl).
	UnicodeLineSeparator
	// UnicodeParagraphSeparator: general category "Separator, Paragraph" (Zp).
	UnicodeParagraphSeparator
	// UnicodeSpaceSeparator: general category "Separator, Space" (Zs).
	UnicodeSpaceSeparator
)

// String returns the name in string for UnicodeType.
func (u UnicodeType) String() string {
	switch u {
	case UnicodeControl:
		return "Control"
	case UnicodeFormat:
		return "Format"
	case UnicodeUnassigned:
		return "Unassigned"
	case UnicodePrivateUse:
		return "PrivateUse"
	case UnicodeSurrogate:
		return "Surrogate"
	case UnicodeLowercaseLetter:
		return "LowercaseLetter"
	case UnicodeModifierLetter:
		return "ModifierLetter"
	case UnicodeOtherLetter:
		return "OtherLetter"
	case UnicodeTitlecaseLetter:
		return "TitlecaseLetter"
	case UnicodeUppercaseLetter:
		return "UppercaseLetter"
	case UnicodeSpacingMark:
		return "SpacingMark"
	case UnicodeEnclosingMark:
		return "EnclosingMark"
	case UnicodeNonSpacingMark:
		return "NonSpacingMark"
	case UnicodeDecimalNumber:
		return "DecimalNumber"
	case UnicodeLetterNumber:
		return "LetterNumber"
	case UnicodeOtherNumber:
		return "OtherNumber"
	case UnicodeConnectPunctuation:
		return "ConnectPunctuation"
	case UnicodeDashPunctuation:
		return "DashPunctuation"
	case UnicodeClosePunctuation:
		return "ClosePunctuation"
	case UnicodeFinalPunctuation:
		return "FinalPunctuation"
	case UnicodeInitialPunctuation:
		return "InitialPunctuation"
	case UnicodeOtherPunctuation:
		return "OtherPunctuation"
	case UnicodeOpenPunctuation:
		return "OpenPunctuation"
	case UnicodeCurrencySymbol:
		return "CurrencySymbol"
	case UnicodeModifierSymbol:
		return "ModifierSymbol"
	case UnicodeMathSymbol:
		return "MathSymbol"
	case UnicodeOtherSymbol:
		return "OtherSymbol"
	case UnicodeLineSeparator:
		return "LineSeparator"
	case UnicodeParagraphSeparator:
		return "ParagraphSeparator"
	case UnicodeSpaceSeparator:
		return "SpaceSeparator"
	default:
		return fmt.Sprintf("UnicodeType(%d)", u)
	}
}

// UCS4ToUTF16: convert a string from UCS-4 to UTF-16. A 0 character will be
// added to the result after the converted text.
//
// The function takes the following parameters:
//
//    - str: UCS-4 encoded string.
//    - len: maximum length (number of characters) of str to use. If len < 0,
//    then the string is nul-terminated.
//
func UCS4ToUTF16(str *uint32, len int32) (itemsRead int32, itemsWritten int32, guint16 *uint16, goerr error) {
	var _arg1 *C.gunichar  // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar2 // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar)(unsafe.Pointer(str))
	_arg2 = C.glong(len)

	_cret = C.g_ucs4_to_utf16(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _guint16 *uint16    // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_guint16 = (*uint16)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _guint16, _goerr
}

// UCS4ToUTF8: convert a string from a 32-bit fixed width representation as
// UCS-4. to UTF-8. The result will be terminated with a 0 byte.
//
// The function takes the following parameters:
//
//    - str: UCS-4 encoded string.
//    - len: maximum length (number of characters) of str to use. If len < 0,
//    then the string is nul-terminated.
//
func UCS4ToUTF8(str *uint32, len int32) (itemsRead int32, itemsWritten int32, utf8 string, goerr error) {
	var _arg1 *C.gunichar // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _arg4 C.glong     // in
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gunichar)(unsafe.Pointer(str))
	_arg2 = C.glong(len)

	_cret = C.g_ucs4_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _utf8 string        // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _utf8, _goerr
}

// UnicharBreakType determines the break type of c. c should be a Unicode
// character (to derive a character from UTF-8 encoded text, use
// g_utf8_get_char()). The break type is used to find word and line breaks
// ("text boundaries"), Pango implements the Unicode boundary resolution
// algorithms and normally you would use a function such as pango_break()
// instead of caring about break types yourself.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharBreakType(c uint32) UnicodeBreakType {
	var _arg1 C.gunichar          // out
	var _cret C.GUnicodeBreakType // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_break_type(_arg1)
	runtime.KeepAlive(c)

	var _unicodeBreakType UnicodeBreakType // out

	_unicodeBreakType = UnicodeBreakType(_cret)

	return _unicodeBreakType
}

// UnicharCombiningClass determines the canonical combining class of a Unicode
// character.
//
// The function takes the following parameters:
//
//    - uc: unicode character.
//
func UnicharCombiningClass(uc uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(uc)

	_cret = C.g_unichar_combining_class(_arg1)
	runtime.KeepAlive(uc)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicharCompose performs a single composition step of the Unicode canonical
// composition algorithm.
//
// This function includes algorithmic Hangul Jamo composition, but it is not
// exactly the inverse of g_unichar_decompose(). No composition can have either
// of a or b equal to zero. To be precise, this function composes if and only if
// there exists a Primary Composite P which is canonically equivalent to the
// sequence <a,b>. See the Unicode Standard for the definition of Primary
// Composite.
//
// If a and b do not compose a new character, ch is set to zero.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//    - a: unicode character.
//    - b: unicode character.
//
func UnicharCompose(a, b uint32) (uint32, bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // out
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(a)
	_arg2 = C.gunichar(b)

	_cret = C.g_unichar_compose(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _ch uint32 // out
	var _ok bool   // out

	_ch = uint32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _ch, _ok
}

// UnicharDecompose performs a single decomposition step of the Unicode
// canonical decomposition algorithm.
//
// This function does not include compatibility decompositions. It does,
// however, include algorithmic Hangul Jamo decomposition, as well as
// 'singleton' decompositions which replace a character by a single other
// character. In the case of singletons *b will be set to zero.
//
// If ch is not decomposable, *a is set to ch and *b is set to zero.
//
// Note that the way Unicode decomposition pairs are defined, it is guaranteed
// that b would not decompose further, but a may itself decompose. To get the
// full canonical decomposition for ch, one would need to recursively call this
// function on a. Or use g_unichar_fully_decompose().
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//
func UnicharDecompose(ch uint32) (a uint32, b uint32, ok bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // in
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_decompose(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(ch)

	var _a uint32 // out
	var _b uint32 // out
	var _ok bool  // out

	_a = uint32(_arg2)
	_b = uint32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _a, _b, _ok
}

// UnicharDigitValue determines the numeric value of a character as a decimal
// digit.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharDigitValue(c uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_digit_value(_arg1)
	runtime.KeepAlive(c)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicharFullyDecompose computes the canonical or compatibility decomposition
// of a Unicode character. For compatibility decomposition, pass TRUE for
// compat; for canonical decomposition pass FALSE for compat.
//
// The decomposed sequence is placed in result. Only up to result_len characters
// are written into result. The length of the full decomposition (irrespective
// of result_len) is returned by the function. For canonical decomposition,
// currently all decompositions are of length at most 4, but this may change in
// the future (very unlikely though). At any rate, Unicode does guarantee that a
// buffer of length 18 is always enough for both compatibility and canonical
// decompositions, so that is the size recommended. This is provided as
// G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//    - compat: whether perform canonical or compatibility decomposition.
//    - resultLen: length of result.
//
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (uint32, uint) {
	var _arg1 C.gunichar // out
	var _arg2 C.gboolean // out
	var _arg3 C.gunichar // in
	var _arg4 C.gsize    // out
	var _cret C.gsize    // in

	_arg1 = C.gunichar(ch)
	if compat {
		_arg2 = C.TRUE
	}
	_arg4 = C.gsize(resultLen)

	_cret = C.g_unichar_fully_decompose(_arg1, _arg2, &_arg3, _arg4)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(compat)
	runtime.KeepAlive(resultLen)

	var _result uint32 // out
	var _gsize uint    // out

	_result = uint32(_arg3)
	_gsize = uint(_cret)

	return _result, _gsize
}

// UnicharGetMirrorChar: in Unicode, some characters are "mirrored". This means
// that their images are mirrored horizontally in text that is laid out from
// right to left. For instance, "(" would become its mirror image, ")", in
// right-to-left text.
//
// If ch has the Unicode mirrored property and there is another unicode
// character that typically has a glyph that is the mirror image of ch's glyph
// and mirrored_ch is set, it puts that character in the address pointed to by
// mirrored_ch. Otherwise the original character is put.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//    - mirroredCh: location to store the mirrored character.
//
func UnicharGetMirrorChar(ch uint32, mirroredCh *uint32) bool {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gunichar // out
	var _cret C.gboolean  // in

	_arg1 = C.gunichar(ch)
	_arg2 = (*C.gunichar)(unsafe.Pointer(mirroredCh))

	_cret = C.g_unichar_get_mirror_char(_arg1, _arg2)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(mirroredCh)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharGetScript looks up the Script for a particular character (as defined
// by Unicode Standard Annex \#24). No check is made for ch being a valid
// Unicode character; if you pass in invalid character, the result is undefined.
//
// This function is equivalent to pango_script_for_unichar() and the two are
// interchangeable.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//
func UnicharGetScript(ch uint32) UnicodeScript {
	var _arg1 C.gunichar       // out
	var _cret C.GUnicodeScript // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_get_script(_arg1)
	runtime.KeepAlive(ch)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicharIsalnum determines whether a character is alphanumeric. Given some
// UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsalnum(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isalnum(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsalpha determines whether a character is alphabetic (i.e. a letter).
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsalpha(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isalpha(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIscntrl determines whether a character is a control character. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIscntrl(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iscntrl(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdefined determines if a given character is assigned in the Unicode
// standard.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsdefined(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isdefined(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsdigit determines whether a character is numeric (i.e. a digit). This
// covers ASCII 0-9 and also digits in other languages/scripts. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsdigit(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isdigit(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsgraph determines whether a character is printable and not a space
// (returns FALSE for control characters, format characters, and spaces).
// g_unichar_isprint() is similar, but returns TRUE for spaces. Given some UTF-8
// text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsgraph(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isgraph(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIslower determines whether a character is a lowercase letter. Given
// some UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIslower(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_islower(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsmark determines whether a character is a mark (non-spacing mark,
// combining mark, or enclosing mark in Unicode speak). Given some UTF-8 text,
// obtain a character value with g_utf8_get_char().
//
// Note: in most cases where isalpha characters are allowed, ismark characters
// should be allowed to as they are essential for writing most European
// languages as well as many non-Latin scripts.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsmark(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_ismark(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsprint determines whether a character is printable. Unlike
// g_unichar_isgraph(), returns TRUE for spaces. Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsprint(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isprint(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIspunct determines whether a character is punctuation or a symbol.
// Given some UTF-8 text, obtain a character value with g_utf8_get_char().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIspunct(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_ispunct(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsspace determines whether a character is a space, tab, or line
// separator (newline, carriage return, etc.). Given some UTF-8 text, obtain a
// character value with g_utf8_get_char().
//
// (Note: don't use this to do word breaking; you have to use Pango or
// equivalent to get word breaking right, the algorithm is fairly complex.).
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsspace(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isspace(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIstitle determines if a character is titlecase. Some characters in
// Unicode which are composites, such as the DZ digraph have three case variants
// instead of just two. The titlecase form is used at the beginning of a word
// where only the first letter is capitalized. The titlecase form of the DZ
// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIstitle(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_istitle(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsupper determines if a character is uppercase.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsupper(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isupper(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswide determines if a character is typically rendered in a
// double-width cell.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIswide(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iswide(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIswideCjk determines if a character is typically rendered in a
// double-width cell under legacy East Asian locales. If a character is wide
// according to g_unichar_iswide(), then it is also reported wide with this
// function, but the converse is not necessarily true. See the Unicode Standard
// Annex #11 (http://www.unicode.org/reports/tr11/) for details.
//
// If a character passes the g_unichar_iswide() test then it will also pass this
// test, but not the other way around. Note that some characters may pass both
// this test and g_unichar_iszerowidth().
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIswideCjk(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iswide_cjk(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIsxdigit determines if a character is a hexadecimal digit.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIsxdigit(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_isxdigit(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharIszerowidth determines if a given character typically takes zero width
// when rendered. The return value is TRUE for all non-spacing and enclosing
// marks (e.g., combining accents), format characters, zero-width space, but not
// U+00AD SOFT HYPHEN.
//
// A typical use of this function is with one of g_unichar_iswide() or
// g_unichar_iswide_cjk() to determine the number of cells a string occupies
// when displayed on a grid display (terminals). However, note that not all
// terminals support zero-width rendering of zero-width marks.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharIszerowidth(c uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_iszerowidth(_arg1)
	runtime.KeepAlive(c)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharToLower converts a character to lower case.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharToLower(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_tolower(_arg1)
	runtime.KeepAlive(c)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharToTitle converts a character to the titlecase.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharToTitle(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_totitle(_arg1)
	runtime.KeepAlive(c)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharToUpper converts a character to uppercase.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharToUpper(c uint32) uint32 {
	var _arg1 C.gunichar // out
	var _cret C.gunichar // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_toupper(_arg1)
	runtime.KeepAlive(c)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UnicharType classifies a Unicode character by type.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharType(c uint32) UnicodeType {
	var _arg1 C.gunichar     // out
	var _cret C.GUnicodeType // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_type(_arg1)
	runtime.KeepAlive(c)

	var _unicodeType UnicodeType // out

	_unicodeType = UnicodeType(_cret)

	return _unicodeType
}

// UnicharValidate checks whether ch is a valid Unicode character. Some possible
// integer values of ch will not be valid. 0 is considered a valid character,
// though it's normally a string terminator.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//
func UnicharValidate(ch uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_validate(_arg1)
	runtime.KeepAlive(ch)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnicharXDigitValue determines the numeric value of a character as a
// hexadecimal digit.
//
// The function takes the following parameters:
//
//    - c: unicode character.
//
func UnicharXDigitValue(c uint32) int {
	var _arg1 C.gunichar // out
	var _cret C.gint     // in

	_arg1 = C.gunichar(c)

	_cret = C.g_unichar_xdigit_value(_arg1)
	runtime.KeepAlive(c)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UnicodeCanonicalDecomposition computes the canonical decomposition of a
// Unicode character.
//
// Deprecated: Use the more flexible g_unichar_fully_decompose() instead.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//    - resultLen: location to store the length of the return value.
//
func UnicodeCanonicalDecomposition(ch uint32, resultLen *uint) *uint32 {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gsize    // out
	var _cret *C.gunichar // in

	_arg1 = C.gunichar(ch)
	_arg2 = (*C.gsize)(unsafe.Pointer(resultLen))

	_cret = C.g_unicode_canonical_decomposition(_arg1, _arg2)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(resultLen)

	var _gunichar *uint32 // out

	_gunichar = (*uint32)(unsafe.Pointer(_cret))

	return _gunichar
}

// UnicodeCanonicalOrdering computes the canonical ordering of a string
// in-place. This rearranges decomposed characters in the string according to
// their combining classes. See the Unicode manual for more information.
//
// The function takes the following parameters:
//
//    - str: UCS-4 encoded string.
//    - len: maximum length of string to use.
//
func UnicodeCanonicalOrdering(str *uint32, len uint) {
	var _arg1 *C.gunichar // out
	var _arg2 C.gsize     // out

	_arg1 = (*C.gunichar)(unsafe.Pointer(str))
	_arg2 = C.gsize(len)

	C.g_unicode_canonical_ordering(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)
}

// UnicodeScriptFromISO15924 looks up the Unicode script for iso15924. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. This function accepts four letter codes encoded as a guint32 in a
// big-endian fashion. That is, the code expected for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
//
// The function takes the following parameters:
//
//    - iso15924: unicode script.
//
func UnicodeScriptFromISO15924(iso15924 uint32) UnicodeScript {
	var _arg1 C.guint32        // out
	var _cret C.GUnicodeScript // in

	_arg1 = C.guint32(iso15924)

	_cret = C.g_unicode_script_from_iso15924(_arg1)
	runtime.KeepAlive(iso15924)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicodeScriptToISO15924 looks up the ISO 15924 code for script. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. The four letter codes are encoded as a guint32 by this function in a
// big-endian fashion. That is, the code returned for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
//
// The function takes the following parameters:
//
//    - script: unicode script.
//
func UnicodeScriptToISO15924(script UnicodeScript) uint32 {
	var _arg1 C.GUnicodeScript // out
	var _cret C.guint32        // in

	_arg1 = C.GUnicodeScript(script)

	_cret = C.g_unicode_script_to_iso15924(_arg1)
	runtime.KeepAlive(script)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// UTF16ToUCS4: convert a string from UTF-16 to UCS-4. The result will be
// nul-terminated.
//
// The function takes the following parameters:
//
//    - str: UTF-16 encoded string.
//    - len: maximum length (number of #gunichar2) of str to use. If len < 0,
//    then the string is nul-terminated.
//
func UTF16ToUCS4(str *uint16, len int32) (itemsRead int32, itemsWritten int32, gunichar *uint32, goerr error) {
	var _arg1 *C.gunichar2 // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar  // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar2)(unsafe.Pointer(str))
	_arg2 = C.glong(len)

	_cret = C.g_utf16_to_ucs4(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _gunichar *uint32   // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _gunichar, _goerr
}

// UTF16ToUTF8: convert a string from UTF-16 to UTF-8. The result will be
// terminated with a 0 byte.
//
// Note that the input is expected to be already in native endianness, an
// initial byte-order-mark character is not handled specially. g_convert() can
// be used to convert a byte buffer of UTF-16 data of ambiguous endianness.
//
// Further note that this function does not validate the result string; it may
// e.g. include embedded NUL characters. The only validation done by this
// function is to ensure that the input can be correctly interpreted as UTF-16,
// i.e. it doesn't contain unpaired surrogates or partial character sequences.
//
// The function takes the following parameters:
//
//    - str: UTF-16 encoded string.
//    - len: maximum length (number of #gunichar2) of str to use. If len < 0,
//    then the string is nul-terminated.
//
func UTF16ToUTF8(str *uint16, len int32) (itemsRead int32, itemsWritten int32, utf8 string, goerr error) {
	var _arg1 *C.gunichar2 // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gchar     // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gunichar2)(unsafe.Pointer(str))
	_arg2 = C.glong(len)

	_cret = C.g_utf16_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _utf8 string        // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _utf8, _goerr
}

// UTF8Casefold converts a string into a form that is independent of case. The
// result will not correspond to any particular case, but can be compared for
// equality or ordered with the results of calling g_utf8_casefold() on other
// strings.
//
// Note that calling g_utf8_casefold() followed by g_utf8_collate() is only an
// approximation to the correct linguistic case insensitive ordering, though it
// is a fairly good one. Getting this exactly right would require a more
// sophisticated collation function that takes case sensitivity into account.
// GLib does not currently provide such a function.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: length of str, in bytes, or -1 if str is nul-terminated.
//
func UTF8Casefold(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_casefold(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Collate compares two strings for ordering using the linguistically
// correct rules for the [current locale][setlocale]. When sorting a large
// number of strings, it will be significantly faster to obtain collation keys
// with g_utf8_collate_key() and compare the keys with strcmp() when sorting
// instead of sorting the original strings.
//
// The function takes the following parameters:
//
//    - str1: UTF-8 encoded string.
//    - str2: UTF-8 encoded string.
//
func UTF8Collate(str1, str2 string) int {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.gint   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str1)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str2)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_collate(_arg1, _arg2)
	runtime.KeepAlive(str1)
	runtime.KeepAlive(str2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// UTF8CollateKey converts a string into a collation key that can be compared
// with other collation keys produced by the same function using strcmp().
//
// The results of comparing the collation keys of two strings with strcmp() will
// always be the same as comparing the two original keys with g_utf8_collate().
//
// Note that this function depends on the [current locale][setlocale].
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: length of str, in bytes, or -1 if str is nul-terminated.
//
func UTF8CollateKey(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_collate_key(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8CollateKeyForFilename converts a string into a collation key that can be
// compared with other collation keys produced by the same function using
// strcmp().
//
// In order to sort filenames correctly, this function treats the dot '.' as a
// special case. Most dictionary orderings seem to consider it insignificant,
// thus producing the ordering "event.c" "eventgenerator.c" "event.h" instead of
// "event.c" "event.h" "eventgenerator.c". Also, we would like to treat numbers
// intelligently so that "file1" "file10" "file5" is sorted as "file1" "file5"
// "file10".
//
// Note that this function depends on the [current locale][setlocale].
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: length of str, in bytes, or -1 if str is nul-terminated.
//
func UTF8CollateKeyForFilename(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_collate_key_for_filename(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8FindNextChar finds the start of the next UTF-8 character in the string
// after p.
//
// p does not have to be at the beginning of a UTF-8 character. No check is made
// to see if the character found is actually valid other than it starts with an
// appropriate byte.
//
// If end is NULL, the return value will never be NULL: if the end of the string
// is reached, a pointer to the terminating nul byte is returned. If end is
// non-NULL, the return value will be NULL if the end of the string is reached.
//
// The function takes the following parameters:
//
//    - p: pointer to a position within a UTF-8 encoded string.
//    - end: pointer to the byte following the end of the string, or NULL to
//    indicate that the string is nul-terminated.
//
func UTF8FindNextChar(p, end string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))
	if end != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(end)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_utf8_find_next_char(_arg1, _arg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(end)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UTF8FindPrevChar: given a position p with a UTF-8 encoded string str, find
// the start of the previous UTF-8 character starting before p. Returns NULL if
// no UTF-8 characters are present in str before p.
//
// p does not have to be at the beginning of a UTF-8 character. No check is made
// to see if the character found is actually valid other than it starts with an
// appropriate byte.
//
// The function takes the following parameters:
//
//    - str: pointer to the beginning of a UTF-8 encoded string.
//    - p: pointer to some position within str.
//
func UTF8FindPrevChar(str, p string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_find_prev_char(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(p)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UTF8GetChar converts a sequence of bytes encoded as UTF-8 to a Unicode
// character.
//
// If p does not point to a valid UTF-8 encoded character, results are
// undefined. If you are not sure that the bytes are complete valid Unicode
// characters, you should use g_utf8_get_char_validated() instead.
//
// The function takes the following parameters:
//
//    - p: pointer to Unicode character encoded as UTF-8.
//
func UTF8GetChar(p string) uint32 {
	var _arg1 *C.gchar   // out
	var _cret C.gunichar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_get_char(_arg1)
	runtime.KeepAlive(p)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UTF8GetCharValidated: convert a sequence of bytes encoded as UTF-8 to a
// Unicode character. This function checks for incomplete characters, for
// invalid characters such as characters that are out of the range of Unicode,
// and for overlong encodings of valid characters.
//
// Note that g_utf8_get_char_validated() returns (gunichar)-2 if max_len is
// positive and any of the bytes in the first UTF-8 character sequence are nul.
//
// The function takes the following parameters:
//
//    - p: pointer to Unicode character encoded as UTF-8.
//    - maxLen: maximum number of bytes to read, or -1 if p is nul-terminated.
//
func UTF8GetCharValidated(p string, maxLen int) uint32 {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _cret C.gunichar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(maxLen)

	_cret = C.g_utf8_get_char_validated(_arg1, _arg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(maxLen)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// UTF8MakeValid: if the provided string is valid UTF-8, return a copy of it. If
// not, return a copy in which bytes that could not be interpreted as valid
// Unicode are replaced with the Unicode replacement character (U+FFFD).
//
// For example, this is an appropriate function to use if you have received a
// string that was incorrectly declared to be UTF-8, and you need a valid UTF-8
// version of it that can be logged or displayed to the user, with the
// assumption that it is close enough to ASCII or UTF-8 to be mostly readable
// as-is.
//
// The function takes the following parameters:
//
//    - str: string to coerce into UTF-8.
//    - len: maximum length of str to use, in bytes. If len < 0, then the
//    string is nul-terminated.
//
func UTF8MakeValid(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_make_valid(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Normalize converts a string into canonical form, standardizing such
// issues as whether a character with an accent is represented as a base
// character and combining accent or as a single precomposed character. The
// string has to be valid UTF-8, otherwise NULL is returned. You should
// generally call g_utf8_normalize() before comparing two Unicode strings.
//
// The normalization mode G_NORMALIZE_DEFAULT only standardizes differences that
// do not affect the text content, such as the above-mentioned accent
// representation. G_NORMALIZE_ALL also standardizes the "compatibility"
// characters in Unicode, such as SUPERSCRIPT THREE to the standard forms (in
// this case DIGIT THREE). Formatting information may be lost but for most text
// operations such characters should be considered the same.
//
// G_NORMALIZE_DEFAULT_COMPOSE and G_NORMALIZE_ALL_COMPOSE are like
// G_NORMALIZE_DEFAULT and G_NORMALIZE_ALL, but returned a result with composed
// forms rather than a maximally decomposed form. This is often useful if you
// intend to convert the string to a legacy encoding or pass it to a system with
// less capable Unicode handling.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: length of str, in bytes, or -1 if str is nul-terminated.
//    - mode: type of normalization to perform.
//
func UTF8Normalize(str string, len int, mode NormalizeMode) string {
	var _arg1 *C.gchar         // out
	var _arg2 C.gssize         // out
	var _arg3 C.GNormalizeMode // out
	var _cret *C.gchar         // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = C.GNormalizeMode(mode)

	_cret = C.g_utf8_normalize(_arg1, _arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)
	runtime.KeepAlive(mode)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// UTF8OffsetToPointer converts from an integer character offset to a pointer to
// a position within the string.
//
// Since 2.10, this function allows to pass a negative offset to step backwards.
// It is usually worth stepping backwards from the end instead of forwards if
// offset is in the last fourth of the string, since moving forward is about 3
// times faster than moving backward.
//
// Note that this function doesn't abort when reaching the end of str. Therefore
// you should be sure that offset is within string boundaries before calling
// that function. Call g_utf8_strlen() when unsure. This limitation exists as
// this function is called frequently during text rendering and therefore has to
// be as fast as possible.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - offset: character offset within str.
//
func UTF8OffsetToPointer(str string, offset int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(offset)

	_cret = C.g_utf8_offset_to_pointer(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(offset)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UTF8PointerToOffset converts from a pointer to position within a string to an
// integer character offset.
//
// Since 2.10, this function allows pos to be before str, and returns a negative
// offset in this case.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - pos: pointer to a position within str.
//
func UTF8PointerToOffset(str, pos string) int32 {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret C.glong  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(pos)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.g_utf8_pointer_to_offset(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(pos)

	var _glong int32 // out

	_glong = int32(_cret)

	return _glong
}

// UTF8PrevChar finds the previous UTF-8 character in the string before p.
//
// p does not have to be at the beginning of a UTF-8 character. No check is made
// to see if the character found is actually valid other than it starts with an
// appropriate byte. If p might be the first character of the string, you must
// use g_utf8_find_prev_char() instead.
//
// The function takes the following parameters:
//
//    - p: pointer to a position within a UTF-8 encoded string.
//
func UTF8PrevChar(p string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_utf8_prev_char(_arg1)
	runtime.KeepAlive(p)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UTF8Strchr finds the leftmost occurrence of the given Unicode character in a
// UTF-8 encoded string, while limiting the search to len bytes. If len is -1,
// allow unbounded search.
//
// The function takes the following parameters:
//
//    - p: nul-terminated UTF-8 encoded string.
//    - len: maximum length of p.
//    - c: unicode character.
//
func UTF8Strchr(p string, len int, c uint32) string {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _arg3 C.gunichar // out
	var _cret *C.gchar   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = C.gunichar(c)

	_cret = C.g_utf8_strchr(_arg1, _arg2, _arg3)
	runtime.KeepAlive(p)
	runtime.KeepAlive(len)
	runtime.KeepAlive(c)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UTF8Strdown converts all Unicode characters in the string that have a case to
// lowercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string changing.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: length of str, in bytes, or -1 if str is nul-terminated.
//
func UTF8Strdown(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_strdown(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strlen computes the length of the string in characters, not including the
// terminating nul character. If the max'th byte falls in the middle of a
// character, the last (partial) character is not counted.
//
// The function takes the following parameters:
//
//    - p: pointer to the start of a UTF-8 encoded string.
//    - max: maximum number of bytes to examine. If max is less than 0, then
//    the string is assumed to be nul-terminated. If max is 0, p will not be
//    examined and may be NULL. If max is greater than 0, up to max bytes are
//    examined.
//
func UTF8Strlen(p string, max int) int32 {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret C.glong  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(max)

	_cret = C.g_utf8_strlen(_arg1, _arg2)
	runtime.KeepAlive(p)
	runtime.KeepAlive(max)

	var _glong int32 // out

	_glong = int32(_cret)

	return _glong
}

// UTF8Strncpy: like the standard C strncpy() function, but copies a given
// number of characters instead of a given number of bytes. The src string must
// be valid UTF-8 encoded text. (Use g_utf8_validate() on all text before trying
// to use UTF-8 utility functions with it.)
//
// Note you must ensure dest is at least 4 * n to fit the largest possible UTF-8
// characters.
//
// The function takes the following parameters:
//
//    - dest: buffer to fill with characters from src.
//    - src: UTF-8 encoded string.
//    - n: character count.
//
func UTF8Strncpy(dest, src string, n uint) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gsize  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(dest)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(src)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gsize(n)

	_cret = C.g_utf8_strncpy(_arg1, _arg2, _arg3)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(src)
	runtime.KeepAlive(n)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UTF8Strrchr: find the rightmost occurrence of the given Unicode character in
// a UTF-8 encoded string, while limiting the search to len bytes. If len is -1,
// allow unbounded search.
//
// The function takes the following parameters:
//
//    - p: nul-terminated UTF-8 encoded string.
//    - len: maximum length of p.
//    - c: unicode character.
//
func UTF8Strrchr(p string, len int, c uint32) string {
	var _arg1 *C.gchar   // out
	var _arg2 C.gssize   // out
	var _arg3 C.gunichar // out
	var _cret *C.gchar   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(p)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)
	_arg3 = C.gunichar(c)

	_cret = C.g_utf8_strrchr(_arg1, _arg2, _arg3)
	runtime.KeepAlive(p)
	runtime.KeepAlive(len)
	runtime.KeepAlive(c)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UTF8Strreverse reverses a UTF-8 string. str must be valid UTF-8 encoded text.
// (Use g_utf8_validate() on all text before trying to use UTF-8 utility
// functions with it.)
//
// This function is intended for programmatic uses of reversed strings. It pays
// no attention to decomposed characters, combining marks, byte order marks,
// directional indicators (LRM, LRO, etc) and similar characters which might
// need special handling when reversing a string for display purposes.
//
// Note that unlike g_strreverse(), this function returns newly-allocated
// memory, which should be freed with g_free() when no longer needed.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: maximum length of str to use, in bytes. If len < 0, then the
//    string is nul-terminated.
//
func UTF8Strreverse(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_strreverse(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Strup converts all Unicode characters in the string that have a case to
// uppercase. The exact manner that this is done depends on the current locale,
// and may result in the number of characters in the string increasing. (For
// instance, the German ess-zet will be changed to SS.).
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: length of str, in bytes, or -1 if str is nul-terminated.
//
func UTF8Strup(str string, len int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_utf8_strup(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8Substring copies a substring out of a UTF-8 encoded string. The substring
// will contain end_pos - start_pos characters.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - startPos: character offset within str.
//    - endPos: another character offset within str.
//
func UTF8Substring(str string, startPos, endPos int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _arg3 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(startPos)
	_arg3 = C.glong(endPos)

	_cret = C.g_utf8_substring(_arg1, _arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UTF8ToUCS4: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4. A trailing 0 character will be added to the string
// after the converted text.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: maximum length of str to use, in bytes. If len < 0, then the
//    string is nul-terminated.
//
func UTF8ToUCS4(str string, len int32) (itemsRead int32, itemsWritten int32, gunichar *uint32, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _arg4 C.glong     // in
	var _cret *C.gunichar // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(len)

	_cret = C.g_utf8_to_ucs4(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _gunichar *uint32   // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _gunichar, _goerr
}

// UTF8ToUCS4Fast: convert a string from UTF-8 to a 32-bit fixed width
// representation as UCS-4, assuming valid UTF-8 input. This function is roughly
// twice as fast as g_utf8_to_ucs4() but does no error checking on the input. A
// trailing 0 character will be added to the string after the converted text.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: maximum length of str to use, in bytes. If len < 0, then the
//    string is nul-terminated.
//
func UTF8ToUCS4Fast(str string, len int32) (int32, *uint32) {
	var _arg1 *C.gchar    // out
	var _arg2 C.glong     // out
	var _arg3 C.glong     // in
	var _cret *C.gunichar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(len)

	_cret = C.g_utf8_to_ucs4_fast(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _itemsWritten int32 // out
	var _gunichar *uint32   // out

	_itemsWritten = int32(_arg3)
	_gunichar = (*uint32)(unsafe.Pointer(_cret))

	return _itemsWritten, _gunichar
}

// UTF8ToUTF16: convert a string from UTF-8 to UTF-16. A 0 character will be
// added to the result after the converted text.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - len: maximum length (number of bytes) of str to use. If len < 0, then
//    the string is nul-terminated.
//
func UTF8ToUTF16(str string, len int32) (itemsRead int32, itemsWritten int32, guint16 *uint16, goerr error) {
	var _arg1 *C.gchar     // out
	var _arg2 C.glong      // out
	var _arg3 C.glong      // in
	var _arg4 C.glong      // in
	var _cret *C.gunichar2 // in
	var _cerr *C.GError    // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(len)

	_cret = C.g_utf8_to_utf16(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _itemsRead int32    // out
	var _itemsWritten int32 // out
	var _guint16 *uint16    // out
	var _goerr error        // out

	_itemsRead = int32(_arg3)
	_itemsWritten = int32(_arg4)
	_guint16 = (*uint16)(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _itemsRead, _itemsWritten, _guint16, _goerr
}

// UTF8Validate validates UTF-8 encoded text. str is the text to validate; if
// str is nul-terminated, then max_len can be -1, otherwise max_len should be
// the number of bytes to validate. If end is non-NULL, then the end of the
// valid range will be stored there (i.e. the start of the first invalid
// character if some bytes were invalid, or the end of the text being validated
// otherwise).
//
// Note that g_utf8_validate() returns FALSE if max_len is positive and any of
// the max_len bytes are nul.
//
// Returns TRUE if all of str was valid. Many GLib and GTK+ routines require
// valid UTF-8 as input; so data read from a file or the network should be
// checked with g_utf8_validate() before doing anything else with it.
//
// The function takes the following parameters:
//
//    - str: pointer to character data.
//
func UTF8Validate(str string) (string, bool) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg2 = (C.gssize)(len(str))
	if str == "" {
		_arg1 = (*C.gchar)(gextras.ZeroString)
	} else {
		_arg1 = (*C.gchar)(unsafe.Pointer((*reflect.StringHeader)(unsafe.Pointer(&str)).Data))
	}

	_cret = C.g_utf8_validate(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(str)

	var _end string // out
	var _ok bool    // out

	if _arg3 != nil {
		_end = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}

// UTF8ValidateLen validates UTF-8 encoded text.
//
// As with g_utf8_validate(), but max_len must be set, and hence this function
// will always return FALSE if any of the bytes of str are nul.
//
// The function takes the following parameters:
//
//    - str: pointer to character data.
//
func UTF8ValidateLen(str string) (string, bool) {
	var _arg1 *C.gchar // out
	var _arg2 C.gsize
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg2 = (C.gsize)(len(str))
	if str == "" {
		_arg1 = (*C.gchar)(gextras.ZeroString)
	} else {
		_arg1 = (*C.gchar)(unsafe.Pointer((*reflect.StringHeader)(unsafe.Pointer(&str)).Data))
	}

	_cret = C.g_utf8_validate_len(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(str)

	var _end string // out
	var _ok bool    // out

	if _arg3 != nil {
		_end = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	}
	if _cret != 0 {
		_ok = true
	}

	return _end, _ok
}

// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: glib-2.0 gobject-introspection-1.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <glib.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.g_uri_get_type()), F: marshalURI},
	})
}

// URI_RESERVED_CHARS_GENERIC_DELIMITERS: generic delimiters characters as
// defined in RFC 3986 (https://tools.ietf.org/html/rfc3986). Includes :/?#[]@.
const URI_RESERVED_CHARS_GENERIC_DELIMITERS = ":/?#[]@"

// URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: subcomponent delimiter characters
// as defined in RFC 3986 (https://tools.ietf.org/html/rfc3986). Includes
// !$&'()*+,;=.
const URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = "!$&'()*+,;="

// URIError: error codes returned by #GUri methods.
type URIError C.gint

const (
	// URIErrorFailed: generic error if no more specific error is available. See
	// the error message for details.
	URIErrorFailed URIError = iota
	// URIErrorBadScheme: scheme of a URI could not be parsed.
	URIErrorBadScheme
	// URIErrorBadUser: user/userinfo of a URI could not be parsed.
	URIErrorBadUser
	// URIErrorBadPassword: password of a URI could not be parsed.
	URIErrorBadPassword
	// URIErrorBadAuthParams: authentication parameters of a URI could not be
	// parsed.
	URIErrorBadAuthParams
	// URIErrorBadHost: host of a URI could not be parsed.
	URIErrorBadHost
	// URIErrorBadPort: port of a URI could not be parsed.
	URIErrorBadPort
	// URIErrorBadPath: path of a URI could not be parsed.
	URIErrorBadPath
	// URIErrorBadQuery: query of a URI could not be parsed.
	URIErrorBadQuery
	// URIErrorBadFragment: fragment of a URI could not be parsed.
	URIErrorBadFragment
)

// String returns the name in string for URIError.
func (u URIError) String() string {
	switch u {
	case URIErrorFailed:
		return "Failed"
	case URIErrorBadScheme:
		return "BadScheme"
	case URIErrorBadUser:
		return "BadUser"
	case URIErrorBadPassword:
		return "BadPassword"
	case URIErrorBadAuthParams:
		return "BadAuthParams"
	case URIErrorBadHost:
		return "BadHost"
	case URIErrorBadPort:
		return "BadPort"
	case URIErrorBadPath:
		return "BadPath"
	case URIErrorBadQuery:
		return "BadQuery"
	case URIErrorBadFragment:
		return "BadFragment"
	default:
		return fmt.Sprintf("URIError(%d)", u)
	}
}

// URIFlags flags that describe a URI.
//
// When parsing a URI, if you need to choose different flags based on the type
// of URI, you can use g_uri_peek_scheme() on the URI string to check the scheme
// first, and use that to decide what flags to parse it with.
type URIFlags C.guint

const (
	// URIFlagsNone: no flags set.
	URIFlagsNone URIFlags = 0b0
	// URIFlagsParseRelaxed: parse the URI more relaxedly than the RFC 3986
	// (https://tools.ietf.org/html/rfc3986) grammar specifies, fixing up or
	// ignoring common mistakes in URIs coming from external sources. This is
	// also needed for some obscure URI schemes where ; separates the host from
	// the path. Donâ€™t use this flag unless you need to.
	URIFlagsParseRelaxed URIFlags = 0b1
	// URIFlagsHasPassword: userinfo field may contain a password, which will be
	// separated from the username by :.
	URIFlagsHasPassword URIFlags = 0b10
	// URIFlagsHasAuthParams: userinfo may contain additional
	// authentication-related parameters, which will be separated from the
	// username and/or password by ;.
	URIFlagsHasAuthParams URIFlags = 0b100
	// URIFlagsEncoded: when parsing a URI, this indicates that %-encoded
	// characters in the userinfo, path, query, and fragment fields should not
	// be decoded. (And likewise the host field if G_URI_FLAGS_NON_DNS is also
	// set.) When building a URI, it indicates that you have already %-encoded
	// the components, and so #GUri should not do any encoding itself.
	URIFlagsEncoded URIFlags = 0b1000
	// URIFlagsNonDns: host component should not be assumed to be a DNS hostname
	// or IP address (for example, for smb URIs with NetBIOS hostnames).
	URIFlagsNonDns URIFlags = 0b10000
	// URIFlagsEncodedQuery: same as G_URI_FLAGS_ENCODED, for the query field
	// only.
	URIFlagsEncodedQuery URIFlags = 0b100000
	// URIFlagsEncodedPath: same as G_URI_FLAGS_ENCODED, for the path only.
	URIFlagsEncodedPath URIFlags = 0b1000000
	// URIFlagsEncodedFragment: same as G_URI_FLAGS_ENCODED, for the fragment
	// only.
	URIFlagsEncodedFragment URIFlags = 0b10000000
	// URIFlagsSchemeNormalize: scheme-based normalization will be applied. For
	// example, when parsing an HTTP URI changing omitted path to / and omitted
	// port to 80; and when building a URI, changing empty path to / and default
	// port 80). This only supports a subset of known schemes. (Since: 2.68).
	URIFlagsSchemeNormalize URIFlags = 0b100000000
)

// String returns the names in string for URIFlags.
func (u URIFlags) String() string {
	if u == 0 {
		return "URIFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(195)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case URIFlagsNone:
			builder.WriteString("None|")
		case URIFlagsParseRelaxed:
			builder.WriteString("ParseRelaxed|")
		case URIFlagsHasPassword:
			builder.WriteString("HasPassword|")
		case URIFlagsHasAuthParams:
			builder.WriteString("HasAuthParams|")
		case URIFlagsEncoded:
			builder.WriteString("Encoded|")
		case URIFlagsNonDns:
			builder.WriteString("NonDns|")
		case URIFlagsEncodedQuery:
			builder.WriteString("EncodedQuery|")
		case URIFlagsEncodedPath:
			builder.WriteString("EncodedPath|")
		case URIFlagsEncodedFragment:
			builder.WriteString("EncodedFragment|")
		case URIFlagsSchemeNormalize:
			builder.WriteString("SchemeNormalize|")
		default:
			builder.WriteString(fmt.Sprintf("URIFlags(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u URIFlags) Has(other URIFlags) bool {
	return (u & other) == other
}

// URIHideFlags flags describing what parts of the URI to hide in
// g_uri_to_string_partial(). Note that G_URI_HIDE_PASSWORD and
// G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with the
// corresponding flags.
type URIHideFlags C.guint

const (
	// URIHideNone: no flags set.
	URIHideNone URIHideFlags = 0b0
	// URIHideUserinfo: hide the userinfo.
	URIHideUserinfo URIHideFlags = 0b1
	// URIHidePassword: hide the password.
	URIHidePassword URIHideFlags = 0b10
	// URIHideAuthParams: hide the auth_params.
	URIHideAuthParams URIHideFlags = 0b100
	// URIHideQuery: hide the query.
	URIHideQuery URIHideFlags = 0b1000
	// URIHideFragment: hide the fragment.
	URIHideFragment URIHideFlags = 0b10000
)

// String returns the names in string for URIHideFlags.
func (u URIHideFlags) String() string {
	if u == 0 {
		return "URIHideFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(90)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case URIHideNone:
			builder.WriteString("None|")
		case URIHideUserinfo:
			builder.WriteString("Userinfo|")
		case URIHidePassword:
			builder.WriteString("Password|")
		case URIHideAuthParams:
			builder.WriteString("AuthParams|")
		case URIHideQuery:
			builder.WriteString("Query|")
		case URIHideFragment:
			builder.WriteString("Fragment|")
		default:
			builder.WriteString(fmt.Sprintf("URIHideFlags(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u URIHideFlags) Has(other URIHideFlags) bool {
	return (u & other) == other
}

// URIParamsFlags flags modifying the way parameters are handled by
// g_uri_parse_params() and ParamsIter.
type URIParamsFlags C.guint

const (
	// URIParamsNone: no flags set.
	URIParamsNone URIParamsFlags = 0b0
	// URIParamsCaseInsensitive: parameter names are case insensitive.
	URIParamsCaseInsensitive URIParamsFlags = 0b1
	// URIParamsWwwForm: replace + with space character. Only useful for URLs on
	// the web, using the https or http schemas.
	URIParamsWwwForm URIParamsFlags = 0b10
	// URIParamsParseRelaxed: see G_URI_FLAGS_PARSE_RELAXED.
	URIParamsParseRelaxed URIParamsFlags = 0b100
)

// String returns the names in string for URIParamsFlags.
func (u URIParamsFlags) String() string {
	if u == 0 {
		return "URIParamsFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(77)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case URIParamsNone:
			builder.WriteString("None|")
		case URIParamsCaseInsensitive:
			builder.WriteString("CaseInsensitive|")
		case URIParamsWwwForm:
			builder.WriteString("WwwForm|")
		case URIParamsParseRelaxed:
			builder.WriteString("ParseRelaxed|")
		default:
			builder.WriteString(fmt.Sprintf("URIParamsFlags(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u URIParamsFlags) Has(other URIParamsFlags) bool {
	return (u & other) == other
}

// URI type and related functions can be used to parse URIs into their
// components, and build valid URIs from individual components.
//
// Note that #GUri scope is to help manipulate URIs in various applications,
// following RFC 3986 (https://tools.ietf.org/html/rfc3986). In particular, it
// doesn't intend to cover web browser needs, and doesn't implement the WHATWG
// URL (https://url.spec.whatwg.org/) standard. No APIs are provided to help
// prevent homograph attacks
// (https://en.wikipedia.org/wiki/IDN_homograph_attack), so #GUri is not
// suitable for formatting URIs for display to the user for making
// security-sensitive decisions.
//
//
// Relative and absolute URIs
//
// As defined in RFC 3986 (https://tools.ietf.org/html/rfc3986#section-4), the
// hierarchical nature of URIs means that they can either be â€˜relative
// referencesâ€™ (sometimes referred to as â€˜relative URIsâ€™) or â€˜URIsâ€™ (for
// clarity, â€˜URIsâ€™ are referred to in this documentation as â€˜absolute URIsâ€™ â€”
// although in constrast to RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-4.3), fragment identifiers are
// always allowed).
//
// Relative references have one or more components of the URI missing. In
// particular, they have no scheme. Any other component, such as hostname,
// query, etc. may be missing, apart from a path, which has to be specified (but
// may be empty). The path may be relative, starting with ./ rather than /.
//
// For example, a valid relative reference is ./path?query, /?query#fragment or
// //example.com.
//
// Absolute URIs have a scheme specified. Any other components of the URI which
// are missing are specified as explicitly unset in the URI, rather than being
// resolved relative to a base URI using g_uri_parse_relative().
//
// For example, a valid absolute URI is file:///home/bob or
// https://search.com?query=string.
//
// A #GUri instance is always an absolute URI. A string may be an absolute URI
// or a relative reference; see the documentation for individual functions as to
// what forms they accept.
//
//
// Parsing URIs
//
// The most minimalist APIs for parsing URIs are g_uri_split() and
// g_uri_split_with_user(). These split a URI into its component parts, and
// return the parts; the difference between the two is that g_uri_split() treats
// the â€˜userinfoâ€™ component of the URI as a single element, while
// g_uri_split_with_user() can (depending on the Flags you pass) treat it as
// containing a username, password, and authentication parameters.
// Alternatively, g_uri_split_network() can be used when you are only interested
// in the components that are needed to initiate a network connection to the
// service (scheme, host, and port).
//
// g_uri_parse() is similar to g_uri_split(), but instead of returning
// individual strings, it returns a #GUri structure (and it requires that the
// URI be an absolute URI).
//
// g_uri_resolve_relative() and g_uri_parse_relative() allow you to resolve a
// relative URI relative to a base URI. g_uri_resolve_relative() takes two
// strings and returns a string, and g_uri_parse_relative() takes a #GUri and a
// string and returns a #GUri.
//
// All of the parsing functions take a Flags argument describing exactly how to
// parse the URI; see the documentation for that type for more details on the
// specific flags that you can pass. If you need to choose different flags based
// on the type of URI, you can use g_uri_peek_scheme() on the URI string to
// check the scheme first, and use that to decide what flags to parse it with.
//
// For example, you might want to use G_URI_PARAMS_WWW_FORM when parsing the
// params for a web URI, so compare the result of g_uri_peek_scheme() against
// http and https.
//
//
// Building URIs
//
// g_uri_join() and g_uri_join_with_user() can be used to construct valid URI
// strings from a set of component strings. They are the inverse of
// g_uri_split() and g_uri_split_with_user().
//
// Similarly, g_uri_build() and g_uri_build_with_user() can be used to construct
// a #GUri from a set of component strings.
//
// As with the parsing functions, the building functions take a Flags argument.
// In particular, it is important to keep in mind whether the URI components you
// are using are already %-encoded. If so, you must pass the G_URI_FLAGS_ENCODED
// flag.
//
// file:// URIs
//
// Note that Windows and Unix both define special rules for parsing file:// URIs
// (involving non-UTF-8 character sets on Unix, and the interpretation of path
// separators on Windows). #GUri does not implement these rules. Use
// g_filename_from_uri() and g_filename_to_uri() if you want to properly convert
// between file:// URIs and local filenames.
//
//
// URI Equality
//
// Note that there is no g_uri_equal () function, because comparing URIs
// usefully requires scheme-specific knowledge that #GUri does not have. #GUri
// can help with normalization if you use the various encoded Flags as well as
// G_URI_FLAGS_SCHEME_NORMALIZE however it is not comprehensive. For example,
// data:,foo and data:;base64,Zm9v resolve to the same thing according to the
// data: URI specification which GLib does not handle.
//
// An instance of this type is always passed by reference.
type URI struct {
	*urI
}

// urI is the struct that's finalized.
type urI struct {
	native *C.GUri
}

func marshalURI(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &URI{&urI{(*C.GUri)(b)}}, nil
}

// AuthParams gets uri's authentication parameters, which may contain
// %-encoding, depending on the flags with which uri was created. (If uri was
// not created with G_URI_FLAGS_HAS_AUTH_PARAMS then this will be NULL.)
//
// Depending on the URI scheme, g_uri_parse_params() may be useful for further
// parsing this information.
func (uri *URI) AuthParams() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_auth_params(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Flags gets uri's flags set upon construction.
func (uri *URI) Flags() URIFlags {
	var _arg0 *C.GUri     // out
	var _cret C.GUriFlags // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_flags(_arg0)
	runtime.KeepAlive(uri)

	var _uriFlags URIFlags // out

	_uriFlags = URIFlags(_cret)

	return _uriFlags
}

// Fragment gets uri's fragment, which may contain %-encoding, depending on the
// flags with which uri was created.
func (uri *URI) Fragment() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_fragment(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Host gets uri's host. This will never have %-encoded characters, unless it is
// non-UTF-8 (which can only be the case if uri was created with
// G_URI_FLAGS_NON_DNS).
//
// If uri contained an IPv6 address literal, this value will be just that
// address, without the brackets around it that are necessary in the string form
// of the URI. Note that in this case there may also be a scope ID attached to
// the address. Eg, fe80::1234em1 (or fe80::123425em1 if the string is still
// encoded).
func (uri *URI) Host() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_host(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Password gets uri's password, which may contain %-encoding, depending on the
// flags with which uri was created. (If uri was not created with
// G_URI_FLAGS_HAS_PASSWORD then this will be NULL.).
func (uri *URI) Password() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_password(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Path gets uri's path, which may contain %-encoding, depending on the flags
// with which uri was created.
func (uri *URI) Path() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_path(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Port gets uri's port.
func (uri *URI) Port() int {
	var _arg0 *C.GUri // out
	var _cret C.gint  // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_port(_arg0)
	runtime.KeepAlive(uri)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Query gets uri's query, which may contain %-encoding, depending on the flags
// with which uri was created.
//
// For queries consisting of a series of name=value parameters, ParamsIter or
// g_uri_parse_params() may be useful.
func (uri *URI) Query() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_query(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Scheme gets uri's scheme. Note that this will always be all-lowercase,
// regardless of the string or strings that uri was created from.
func (uri *URI) Scheme() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_scheme(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// User gets the â€˜usernameâ€™ component of uri's userinfo, which may contain
// %-encoding, depending on the flags with which uri was created. If uri was not
// created with G_URI_FLAGS_HAS_PASSWORD or G_URI_FLAGS_HAS_AUTH_PARAMS, this is
// the same as g_uri_get_userinfo().
func (uri *URI) User() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_user(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Userinfo gets uri's userinfo, which may contain %-encoding, depending on the
// flags with which uri was created.
func (uri *URI) Userinfo() string {
	var _arg0 *C.GUri  // out
	var _cret *C.gchar // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_get_userinfo(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ParseRelative parses uri_ref according to flags and, if it is a [relative
// URI][relative-absolute-uris], resolves it relative to base_uri. If the result
// is not a valid absolute URI, it will be discarded, and an error returned.
func (baseUri *URI) ParseRelative(uriRef string, flags URIFlags) (*URI, error) {
	var _arg0 *C.GUri     // out
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _cret *C.GUri     // in
	var _cerr *C.GError   // in

	if baseUri != nil {
		_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(baseUri)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	_cret = C.g_uri_parse_relative(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(baseUri)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var _uri *URI    // out
	var _goerr error // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _uri, _goerr
}

// String returns a string representing uri.
//
// This is not guaranteed to return a string which is identical to the string
// that uri was parsed from. However, if the source URI was syntactically
// correct (according to RFC 3986), and it was parsed with G_URI_FLAGS_ENCODED,
// then g_uri_to_string() is guaranteed to return a string which is at least
// semantically equivalent to the source URI (according to RFC 3986).
//
// If uri might contain sensitive details, such as authentication parameters, or
// private data in its query string, and the returned string is going to be
// logged, then consider using g_uri_to_string_partial() to redact parts.
func (uri *URI) String() string {
	var _arg0 *C.GUri // out
	var _cret *C.char // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))

	_cret = C.g_uri_to_string(_arg0)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToStringPartial returns a string representing uri, subject to the options in
// flags. See g_uri_to_string() and HideFlags for more details.
func (uri *URI) ToStringPartial(flags URIHideFlags) string {
	var _arg0 *C.GUri         // out
	var _arg1 C.GUriHideFlags // out
	var _cret *C.char         // in

	_arg0 = (*C.GUri)(gextras.StructNative(unsafe.Pointer(uri)))
	_arg1 = C.GUriHideFlags(flags)

	_cret = C.g_uri_to_string_partial(_arg0, _arg1)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIBuild creates a new #GUri from the given components according to flags.
//
// See also g_uri_build_with_user(), which allows specifying the components of
// the "userinfo" separately.
//
// The function takes the following parameters:
//
//    - flags describing how to build the #GUri.
//    - scheme: URI scheme.
//    - userinfo component, or NULL.
//    - host component, or NULL.
//    - port: port, or -1.
//    - path component.
//    - query component, or NULL.
//    - fragment: fragment, or NULL.
//
func URIBuild(flags URIFlags, scheme, userinfo, host string, port int, path, query, fragment string) *URI {
	var _arg1 C.GUriFlags // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out
	var _arg5 C.gint      // out
	var _arg6 *C.gchar    // out
	var _arg7 *C.gchar    // out
	var _arg8 *C.gchar    // out
	var _cret *C.GUri     // in

	_arg1 = C.GUriFlags(flags)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg2))
	if userinfo != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if host != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = C.gint(port)
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg6))
	if query != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg7))
	}
	if fragment != "" {
		_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg8))
	}

	_cret = C.g_uri_build(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _uri
}

// URIBuildWithUser creates a new #GUri from the given components according to
// flags (G_URI_FLAGS_HAS_PASSWORD is added unconditionally). The flags must be
// coherent with the passed values, in particular use %-encoded values with
// G_URI_FLAGS_ENCODED.
//
// In contrast to g_uri_build(), this allows specifying the components of the
// â€˜userinfoâ€™ field separately. Note that user must be non-NULL if either
// password or auth_params is non-NULL.
//
// The function takes the following parameters:
//
//    - flags describing how to build the #GUri.
//    - scheme: URI scheme.
//    - user component of the userinfo, or NULL.
//    - password component of the userinfo, or NULL.
//    - authParams: auth params of the userinfo, or NULL.
//    - host component, or NULL.
//    - port: port, or -1.
//    - path component.
//    - query component, or NULL.
//    - fragment: fragment, or NULL.
//
func URIBuildWithUser(flags URIFlags, scheme, user, password, authParams, host string, port int, path, query, fragment string) *URI {
	var _arg1 C.GUriFlags // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out
	var _arg5 *C.gchar    // out
	var _arg6 *C.gchar    // out
	var _arg7 C.gint      // out
	var _arg8 *C.gchar    // out
	var _arg9 *C.gchar    // out
	var _arg10 *C.gchar   // out
	var _cret *C.GUri     // in

	_arg1 = C.GUriFlags(flags)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
	defer C.free(unsafe.Pointer(_arg2))
	if user != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(user)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if password != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if authParams != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(authParams)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if host != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	_arg7 = C.gint(port)
	_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg8))
	if query != "" {
		_arg9 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg9))
	}
	if fragment != "" {
		_arg10 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg10))
	}

	_cret = C.g_uri_build_with_user(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(authParams)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _uri *URI // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _uri
}

// URIEscapeBytes escapes arbitrary data for use in a URI.
//
// Normally all characters that are not â€˜unreservedâ€™ (i.e. ASCII alphanumerical
// characters plus dash, dot, underscore and tilde) are escaped. But if you
// specify characters in reserved_chars_allowed they are not escaped. This is
// useful for the â€˜reservedâ€™ characters in the URI specification, since those
// are allowed unescaped in some portions of a URI.
//
// Though technically incorrect, this will also allow escaping nul bytes as 00.
//
// The function takes the following parameters:
//
//    - unescaped input data.
//    - reservedCharsAllowed: string of reserved characters that are allowed to
//    be used, or NULL.
//
func URIEscapeBytes(unescaped []byte, reservedCharsAllowed string) string {
	var _arg1 *C.guint8 // out
	var _arg2 C.gsize
	var _arg3 *C.char // out
	var _cret *C.char // in

	_arg2 = (C.gsize)(len(unescaped))
	if len(unescaped) > 0 {
		_arg1 = (*C.guint8)(unsafe.Pointer(&unescaped[0]))
	}
	if reservedCharsAllowed != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_uri_escape_bytes(_arg1, _arg2, _arg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIEscapeString escapes a string for use in a URI.
//
// Normally all characters that are not "unreserved" (i.e. ASCII alphanumerical
// characters plus dash, dot, underscore and tilde) are escaped. But if you
// specify characters in reserved_chars_allowed they are not escaped. This is
// useful for the "reserved" characters in the URI specification, since those
// are allowed unescaped in some portions of a URI.
//
// The function takes the following parameters:
//
//    - unescaped input string.
//    - reservedCharsAllowed: string of reserved characters that are allowed to
//    be used, or NULL.
//    - allowUtf8: TRUE if the result can include UTF-8 characters.
//
func URIEscapeString(unescaped, reservedCharsAllowed string, allowUtf8 bool) string {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // out
	var _arg3 C.gboolean // out
	var _cret *C.char    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(unescaped)))
	defer C.free(unsafe.Pointer(_arg1))
	if reservedCharsAllowed != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if allowUtf8 {
		_arg3 = C.TRUE
	}

	_cret = C.g_uri_escape_string(_arg1, _arg2, _arg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)
	runtime.KeepAlive(allowUtf8)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIIsValid parses uri_string according to flags, to determine whether it is a
// valid [absolute URI][relative-absolute-uris], i.e. it does not need to be
// resolved relative to another URI using g_uri_parse_relative().
//
// If itâ€™s not a valid URI, an error is returned explaining how itâ€™s invalid.
//
// See g_uri_split(), and the definition of Flags, for more information on the
// effect of flags.
//
// The function takes the following parameters:
//
//    - uriString: string containing an absolute URI.
//    - flags for parsing uri_string.
//
func URIIsValid(uriString string, flags URIFlags) error {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	C.g_uri_is_valid(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// URIJoin joins the given components together according to flags to create an
// absolute URI string. path may not be NULL (though it may be the empty
// string).
//
// When host is present, path must either be empty or begin with a slash (/)
// character. When host is not present, path cannot begin with two slash
// characters (//). See RFC 3986, section 3
// (https://tools.ietf.org/html/rfc3986#section-3).
//
// See also g_uri_join_with_user(), which allows specifying the components of
// the â€˜userinfoâ€™ separately.
//
// G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in flags.
//
// The function takes the following parameters:
//
//    - flags describing how to build the URI string.
//    - scheme: URI scheme, or NULL.
//    - userinfo component, or NULL.
//    - host component, or NULL.
//    - port: port, or -1.
//    - path component.
//    - query component, or NULL.
//    - fragment: fragment, or NULL.
//
func URIJoin(flags URIFlags, scheme, userinfo, host string, port int, path, query, fragment string) string {
	var _arg1 C.GUriFlags // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out
	var _arg5 C.gint      // out
	var _arg6 *C.gchar    // out
	var _arg7 *C.gchar    // out
	var _arg8 *C.gchar    // out
	var _cret *C.gchar    // in

	_arg1 = C.GUriFlags(flags)
	if scheme != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if userinfo != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(userinfo)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if host != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = C.gint(port)
	_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg6))
	if query != "" {
		_arg7 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg7))
	}
	if fragment != "" {
		_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg8))
	}

	_cret = C.g_uri_join(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(userinfo)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIJoinWithUser joins the given components together according to flags to
// create an absolute URI string. path may not be NULL (though it may be the
// empty string).
//
// In contrast to g_uri_join(), this allows specifying the components of the
// â€˜userinfoâ€™ separately. It otherwise behaves the same.
//
// G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS are ignored if set
// in flags.
//
// The function takes the following parameters:
//
//    - flags describing how to build the URI string.
//    - scheme: URI scheme, or NULL.
//    - user component of the userinfo, or NULL.
//    - password component of the userinfo, or NULL.
//    - authParams: auth params of the userinfo, or NULL.
//    - host component, or NULL.
//    - port: port, or -1.
//    - path component.
//    - query component, or NULL.
//    - fragment: fragment, or NULL.
//
func URIJoinWithUser(flags URIFlags, scheme, user, password, authParams, host string, port int, path, query, fragment string) string {
	var _arg1 C.GUriFlags // out
	var _arg2 *C.gchar    // out
	var _arg3 *C.gchar    // out
	var _arg4 *C.gchar    // out
	var _arg5 *C.gchar    // out
	var _arg6 *C.gchar    // out
	var _arg7 C.gint      // out
	var _arg8 *C.gchar    // out
	var _arg9 *C.gchar    // out
	var _arg10 *C.gchar   // out
	var _cret *C.gchar    // in

	_arg1 = C.GUriFlags(flags)
	if scheme != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(scheme)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if user != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(user)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if password != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(password)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if authParams != "" {
		_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(authParams)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if host != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(host)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	_arg7 = C.gint(port)
	_arg8 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg8))
	if query != "" {
		_arg9 = (*C.gchar)(unsafe.Pointer(C.CString(query)))
		defer C.free(unsafe.Pointer(_arg9))
	}
	if fragment != "" {
		_arg10 = (*C.gchar)(unsafe.Pointer(C.CString(fragment)))
		defer C.free(unsafe.Pointer(_arg10))
	}

	_cret = C.g_uri_join_with_user(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(scheme)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(authParams)
	runtime.KeepAlive(host)
	runtime.KeepAlive(port)
	runtime.KeepAlive(path)
	runtime.KeepAlive(query)
	runtime.KeepAlive(fragment)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIParse parses uri_string according to flags. If the result is not a valid
// [absolute URI][relative-absolute-uris], it will be discarded, and an error
// returned.
//
// The function takes the following parameters:
//
//    - uriString: string representing an absolute URI.
//    - flags describing how to parse uri_string.
//
func URIParse(uriString string, flags URIFlags) (*URI, error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _cret *C.GUri     // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	_cret = C.g_uri_parse(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var _uri *URI    // out
	var _goerr error // out

	_uri = (*URI)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_uri)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _uri, _goerr
}

// URIParseParams: many URI schemes include one or more attribute/value pairs as
// part of the URI value. This method can be used to parse them into a hash
// table. When an attribute has multiple occurrences, the last value is the
// final returned value. If you need to handle repeated attributes differently,
// use ParamsIter.
//
// The params string is assumed to still be %-encoded, but the returned values
// will be fully decoded. (Thus it is possible that the returned values may
// contain = or separators, if the value was encoded in the input.) Invalid
// %-encoding is treated as with the G_URI_FLAGS_PARSE_RELAXED rules for
// g_uri_parse(). (However, if params is the path or query string from a #GUri
// that was parsed without G_URI_FLAGS_PARSE_RELAXED and G_URI_FLAGS_ENCODED,
// then you already know that it does not contain any invalid encoding.)
//
// G_URI_PARAMS_WWW_FORM is handled as documented for g_uri_params_iter_init().
//
// If G_URI_PARAMS_CASE_INSENSITIVE is passed to flags, attributes will be
// compared case-insensitively, so a params string attr=123&Attr=456 will only
// return a single attributeâ€“value pair, Attr=456. Case will be preserved in the
// returned attributes.
//
// If params cannot be parsed (for example, it contains two separators
// characters in a row), then error is set and NULL is returned.
//
// The function takes the following parameters:
//
//    - params: %-encoded string containing attribute=value parameters.
//    - length of params, or -1 if it is nul-terminated.
//    - separators: separator byte character set between parameters. (usually
//    &, but sometimes ; or both &;). Note that this function works on bytes
//    not characters, so it can't be used to delimit UTF-8 strings for anything
//    but ASCII characters. You may pass an empty set, in which case no
//    splitting will occur.
//    - flags to modify the way the parameters are handled.
//
func URIParseParams(params string, length int, separators string, flags URIParamsFlags) (map[string]string, error) {
	var _arg1 *C.gchar          // out
	var _arg2 C.gssize          // out
	var _arg3 *C.gchar          // out
	var _arg4 C.GUriParamsFlags // out
	var _cret *C.GHashTable     // in
	var _cerr *C.GError         // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(params)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(separators)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.GUriParamsFlags(flags)

	_cret = C.g_uri_parse_params(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(params)
	runtime.KeepAlive(length)
	runtime.KeepAlive(separators)
	runtime.KeepAlive(flags)

	var _hashTable map[string]string // out
	var _goerr error                 // out

	_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.gchar)(v)
		var kdst string // out
		var vdst string // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		defer C.free(unsafe.Pointer(ksrc))
		vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
		defer C.free(unsafe.Pointer(vsrc))
		_hashTable[kdst] = vdst
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _hashTable, _goerr
}

// URIParseScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include file, https, svn+ssh, etc.
//
// The function takes the following parameters:
//
//    - uri: valid URI.
//
func URIParseScheme(uri string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_uri_parse_scheme(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIPeekScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include file, https, svn+ssh, etc.
//
// Unlike g_uri_parse_scheme(), the returned scheme is normalized to
// all-lowercase and does not need to be freed.
//
// The function takes the following parameters:
//
//    - uri: valid URI.
//
func URIPeekScheme(uri string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_uri_peek_scheme(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// URIResolveRelative parses uri_ref according to flags and, if it is a
// [relative URI][relative-absolute-uris], resolves it relative to
// base_uri_string. If the result is not a valid absolute URI, it will be
// discarded, and an error returned.
//
// (If base_uri_string is NULL, this just returns uri_ref, or NULL if uri_ref is
// invalid or not absolute.).
//
// The function takes the following parameters:
//
//    - baseUriString: string representing a base URI.
//    - uriRef: string representing a relative or absolute URI.
//    - flags describing how to parse uri_ref.
//
func URIResolveRelative(baseUriString, uriRef string, flags URIFlags) (string, error) {
	var _arg1 *C.gchar    // out
	var _arg2 *C.gchar    // out
	var _arg3 C.GUriFlags // out
	var _cret *C.gchar    // in
	var _cerr *C.GError   // in

	if baseUriString != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(baseUriString)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GUriFlags(flags)

	_cret = C.g_uri_resolve_relative(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(baseUriString)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// URISplit parses uri_ref (which can be an [absolute or relative
// URI][relative-absolute-uris]) according to flags, and returns the pieces. Any
// component that doesn't appear in uri_ref will be returned as NULL (but note
// that all URIs always have a path component, though it may be the empty
// string).
//
// If flags contains G_URI_FLAGS_ENCODED, then %-encoded characters in uri_ref
// will remain encoded in the output strings. (If not, then all such characters
// will be decoded.) Note that decoding will only work if the URI components are
// ASCII or UTF-8, so you will need to use G_URI_FLAGS_ENCODED if they are not.
//
// Note that the G_URI_FLAGS_HAS_PASSWORD and G_URI_FLAGS_HAS_AUTH_PARAMS flags
// are ignored by g_uri_split(), since it always returns only the full userinfo;
// use g_uri_split_with_user() if you want it split up.
//
// The function takes the following parameters:
//
//    - uriRef: string containing a relative or absolute URI.
//    - flags for parsing uri_ref.
//
func URISplit(uriRef string, flags URIFlags) (scheme string, userinfo string, host string, port int, path string, query string, fragment string, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _arg3 *C.gchar    // in
	var _arg4 *C.gchar    // in
	var _arg5 *C.gchar    // in
	var _arg6 C.gint      // in
	var _arg7 *C.gchar    // in
	var _arg8 *C.gchar    // in
	var _arg9 *C.gchar    // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	C.g_uri_split(_arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7, &_arg8, &_arg9, &_cerr)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var _scheme string   // out
	var _userinfo string // out
	var _host string     // out
	var _port int        // out
	var _path string     // out
	var _query string    // out
	var _fragment string // out
	var _goerr error     // out

	if _arg3 != nil {
		_scheme = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _arg4 != nil {
		_userinfo = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _arg5 != nil {
		_host = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	_port = int(_arg6)
	if _arg7 != nil {
		_path = C.GoString((*C.gchar)(unsafe.Pointer(_arg7)))
		defer C.free(unsafe.Pointer(_arg7))
	}
	if _arg8 != nil {
		_query = C.GoString((*C.gchar)(unsafe.Pointer(_arg8)))
		defer C.free(unsafe.Pointer(_arg8))
	}
	if _arg9 != nil {
		_fragment = C.GoString((*C.gchar)(unsafe.Pointer(_arg9)))
		defer C.free(unsafe.Pointer(_arg9))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _scheme, _userinfo, _host, _port, _path, _query, _fragment, _goerr
}

// URISplitNetwork parses uri_string (which must be an [absolute
// URI][relative-absolute-uris]) according to flags, and returns the pieces
// relevant to connecting to a host. See the documentation for g_uri_split() for
// more details; this is mostly a wrapper around that function with simpler
// arguments. However, it will return an error if uri_string is a relative URI,
// or does not contain a hostname component.
//
// The function takes the following parameters:
//
//    - uriString: string containing an absolute URI.
//    - flags for parsing uri_string.
//
func URISplitNetwork(uriString string, flags URIFlags) (scheme string, host string, port int, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _arg3 *C.gchar    // in
	var _arg4 *C.gchar    // in
	var _arg5 C.gint      // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriString)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	C.g_uri_split_network(_arg1, _arg2, &_arg3, &_arg4, &_arg5, &_cerr)
	runtime.KeepAlive(uriString)
	runtime.KeepAlive(flags)

	var _scheme string // out
	var _host string   // out
	var _port int      // out
	var _goerr error   // out

	if _arg3 != nil {
		_scheme = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _arg4 != nil {
		_host = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_port = int(_arg5)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _scheme, _host, _port, _goerr
}

// URISplitWithUser parses uri_ref (which can be an [absolute or relative
// URI][relative-absolute-uris]) according to flags, and returns the pieces. Any
// component that doesn't appear in uri_ref will be returned as NULL (but note
// that all URIs always have a path component, though it may be the empty
// string).
//
// See g_uri_split(), and the definition of Flags, for more information on the
// effect of flags. Note that password will only be parsed out if flags contains
// G_URI_FLAGS_HAS_PASSWORD, and auth_params will only be parsed out if flags
// contains G_URI_FLAGS_HAS_AUTH_PARAMS.
//
// The function takes the following parameters:
//
//    - uriRef: string containing a relative or absolute URI.
//    - flags for parsing uri_ref.
//
func URISplitWithUser(uriRef string, flags URIFlags) (scheme string, user string, password string, authParams string, host string, port int, path string, query string, fragment string, goerr error) {
	var _arg1 *C.gchar    // out
	var _arg2 C.GUriFlags // out
	var _arg3 *C.gchar    // in
	var _arg4 *C.gchar    // in
	var _arg5 *C.gchar    // in
	var _arg6 *C.gchar    // in
	var _arg7 *C.gchar    // in
	var _arg8 C.gint      // in
	var _arg9 *C.gchar    // in
	var _arg10 *C.gchar   // in
	var _arg11 *C.gchar   // in
	var _cerr *C.GError   // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uriRef)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GUriFlags(flags)

	C.g_uri_split_with_user(_arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6, &_arg7, &_arg8, &_arg9, &_arg10, &_arg11, &_cerr)
	runtime.KeepAlive(uriRef)
	runtime.KeepAlive(flags)

	var _scheme string     // out
	var _user string       // out
	var _password string   // out
	var _authParams string // out
	var _host string       // out
	var _port int          // out
	var _path string       // out
	var _query string      // out
	var _fragment string   // out
	var _goerr error       // out

	if _arg3 != nil {
		_scheme = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _arg4 != nil {
		_user = C.GoString((*C.gchar)(unsafe.Pointer(_arg4)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if _arg5 != nil {
		_password = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if _arg6 != nil {
		_authParams = C.GoString((*C.gchar)(unsafe.Pointer(_arg6)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	if _arg7 != nil {
		_host = C.GoString((*C.gchar)(unsafe.Pointer(_arg7)))
		defer C.free(unsafe.Pointer(_arg7))
	}
	_port = int(_arg8)
	if _arg9 != nil {
		_path = C.GoString((*C.gchar)(unsafe.Pointer(_arg9)))
		defer C.free(unsafe.Pointer(_arg9))
	}
	if _arg10 != nil {
		_query = C.GoString((*C.gchar)(unsafe.Pointer(_arg10)))
		defer C.free(unsafe.Pointer(_arg10))
	}
	if _arg11 != nil {
		_fragment = C.GoString((*C.gchar)(unsafe.Pointer(_arg11)))
		defer C.free(unsafe.Pointer(_arg11))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _scheme, _user, _password, _authParams, _host, _port, _path, _query, _fragment, _goerr
}

// URIUnescapeBytes unescapes a segment of an escaped string as binary data.
//
// Note that in contrast to g_uri_unescape_string(), this does allow nul bytes
// to appear in the output.
//
// If any of the characters in illegal_characters appears as an escaped
// character in escaped_string, then that is an error and NULL will be returned.
// This is useful if you want to avoid for instance having a slash being
// expanded in an escaped path element, which might confuse pathname handling.
//
// The function takes the following parameters:
//
//    - escapedString: URI-escaped string.
//    - length (in bytes) of escaped_string to escape, or -1 if it is
//    nul-terminated.
//    - illegalCharacters: string of illegal characters not to be allowed, or
//    NULL.
//
func URIUnescapeBytes(escapedString string, length int, illegalCharacters string) (*Bytes, error) {
	var _arg1 *C.char   // out
	var _arg2 C.gssize  // out
	var _arg3 *C.char   // out
	var _cret *C.GBytes // in
	var _cerr *C.GError // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	if illegalCharacters != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_uri_unescape_bytes(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(length)
	runtime.KeepAlive(illegalCharacters)

	var _bytes *Bytes // out
	var _goerr error  // out

	_bytes = (*Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// URIUnescapeSegment unescapes a segment of an escaped string.
//
// If any of the characters in illegal_characters or the NUL character appears
// as an escaped character in escaped_string, then that is an error and NULL
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
//
// Note: NUL byte is not accepted in the output, in contrast to
// g_uri_unescape_bytes().
//
// The function takes the following parameters:
//
//    - escapedString: string, may be NULL.
//    - escapedStringEnd: pointer to end of escaped_string, may be NULL.
//    - illegalCharacters: optional string of illegal characters not to be
//    allowed, may be NULL.
//
func URIUnescapeSegment(escapedString, escapedStringEnd, illegalCharacters string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _arg3 *C.char // out
	var _cret *C.char // in

	if escapedString != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if escapedStringEnd != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(escapedStringEnd)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if illegalCharacters != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_uri_unescape_segment(_arg1, _arg2, _arg3)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(escapedStringEnd)
	runtime.KeepAlive(illegalCharacters)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIUnescapeString unescapes a whole escaped string.
//
// If any of the characters in illegal_characters or the NUL character appears
// as an escaped character in escaped_string, then that is an error and NULL
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
//
// The function takes the following parameters:
//
//    - escapedString: escaped string to be unescaped.
//    - illegalCharacters: string of illegal characters not to be allowed, or
//    NULL.
//
func URIUnescapeString(escapedString, illegalCharacters string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
	defer C.free(unsafe.Pointer(_arg1))
	if illegalCharacters != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_uri_unescape_string(_arg1, _arg2)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(illegalCharacters)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIParamsIter: many URI schemes include one or more attribute/value pairs as
// part of the URI value. For example scheme://server/path?query=string&is=there
// has two attributes â€“ query=string and is=there â€“ in its query part.
//
// A ParamsIter structure represents an iterator that can be used to iterate
// over the attribute/value pairs of a URI query string. ParamsIter structures
// are typically allocated on the stack and then initialized with
// g_uri_params_iter_init(). See the documentation for g_uri_params_iter_init()
// for a usage example.
//
// An instance of this type is always passed by reference.
type URIParamsIter struct {
	*uriParamsIter
}

// uriParamsIter is the struct that's finalized.
type uriParamsIter struct {
	native *C.GUriParamsIter
}

// Init initializes an attribute/value pair iterator.
//
// The iterator keeps pointers to the params and separators arguments, those
// variables must thus outlive the iterator and not be modified during the
// iteration.
//
// If G_URI_PARAMS_WWW_FORM is passed in flags, + characters in the param string
// will be replaced with spaces in the output. For example, foo=bar+baz will
// give attribute foo with value bar baz. This is commonly used on the web (the
// https and http schemes only), but is deprecated in favour of the equivalent
// of encoding spaces as 20.
//
// Unlike with g_uri_parse_params(), G_URI_PARAMS_CASE_INSENSITIVE has no effect
// if passed to flags for g_uri_params_iter_init(). The caller is responsible
// for doing their own case-insensitive comparisons.
//
//    GUriParamsIter iter;
//    GError *error = NULL;
//    gchar *unowned_attr, *unowned_value;
//
//    g_uri_params_iter_init (&iter, "foo=bar&baz=bar&Foo=frob&baz=bar2", -1, "&", G_URI_PARAMS_NONE);
//    while (g_uri_params_iter_next (&iter, &unowned_attr, &unowned_value, &error))
//      {
//        g_autofree gchar *attr = g_steal_pointer (&unowned_attr);
//        g_autofree gchar *value = g_steal_pointer (&unowned_value);
//        // do something with attr and value; this code will be called 4 times
//        // for the params string in this example: once with attr=foo and value=bar,
//        // then with baz/bar, then Foo/frob, then baz/bar2.
//      }
//    if (error)
//      // handle parsing error.
func (iter *URIParamsIter) Init(params string, length int, separators string, flags URIParamsFlags) {
	var _arg0 *C.GUriParamsIter // out
	var _arg1 *C.gchar          // out
	var _arg2 C.gssize          // out
	var _arg3 *C.gchar          // out
	var _arg4 C.GUriParamsFlags // out

	_arg0 = (*C.GUriParamsIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(params)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(separators)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.GUriParamsFlags(flags)

	C.g_uri_params_iter_init(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(params)
	runtime.KeepAlive(length)
	runtime.KeepAlive(separators)
	runtime.KeepAlive(flags)
}

// Next advances iter and retrieves the next attribute/value. FALSE is returned
// if an error has occurred (in which case error is set), or if the end of the
// iteration is reached (in which case attribute and value are set to NULL and
// the iterator becomes invalid). If TRUE is returned, g_uri_params_iter_next()
// may be called again to receive another attribute/value pair.
//
// Note that the same attribute may be returned multiple times, since URIs allow
// repeated attributes.
func (iter *URIParamsIter) Next() (attribute string, value string, goerr error) {
	var _arg0 *C.GUriParamsIter // out
	var _arg1 *C.gchar          // in
	var _arg2 *C.gchar          // in
	var _cerr *C.GError         // in

	_arg0 = (*C.GUriParamsIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.g_uri_params_iter_next(_arg0, &_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(iter)

	var _attribute string // out
	var _value string     // out
	var _goerr error      // out

	if _arg1 != nil {
		_attribute = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if _arg2 != nil {
		_value = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _attribute, _value, _goerr
}

// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// URI_RESERVED_CHARS_GENERIC_DELIMITERS: generic delimiters characters as
// defined in RFC 3986 (https://tools.ietf.org/html/rfc3986). Includes :/?#[]@.
const URI_RESERVED_CHARS_GENERIC_DELIMITERS = ":/?#[]@"

// URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: subcomponent delimiter characters
// as defined in RFC 3986 (https://tools.ietf.org/html/rfc3986). Includes
// !$&'()*+,;=.
const URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = "!$&'()*+,;="

// URIEscapeString escapes a string for use in a URI.
//
// Normally all characters that are not "unreserved" (i.e. ASCII alphanumerical
// characters plus dash, dot, underscore and tilde) are escaped. But if you
// specify characters in reserved_chars_allowed they are not escaped. This is
// useful for the "reserved" characters in the URI specification, since those
// are allowed unescaped in some portions of a URI.
//
// The function takes the following parameters:
//
//    - unescaped input string.
//    - reservedCharsAllowed (optional): string of reserved characters that are
//      allowed to be used, or NULL.
//    - allowUtf8: TRUE if the result can include UTF-8 characters.
//
// The function returns the following values:
//
//    - utf8: escaped version of unescaped. The returned string should be freed
//      when no longer needed.
//
func URIEscapeString(unescaped, reservedCharsAllowed string, allowUtf8 bool) string {
	var _arg1 *C.char    // out
	var _arg2 *C.char    // out
	var _arg3 C.gboolean // out
	var _cret *C.char    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(unescaped)))
	defer C.free(unsafe.Pointer(_arg1))
	if reservedCharsAllowed != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(reservedCharsAllowed)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if allowUtf8 {
		_arg3 = C.TRUE
	}

	_cret = C.g_uri_escape_string(_arg1, _arg2, _arg3)
	runtime.KeepAlive(unescaped)
	runtime.KeepAlive(reservedCharsAllowed)
	runtime.KeepAlive(allowUtf8)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URIParseScheme gets the scheme portion of a URI string. RFC 3986
// (https://tools.ietf.org/html/rfc3986#section-3) decodes the scheme as:
//
//    URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
//
// Common schemes include file, https, svn+ssh, etc.
//
// The function takes the following parameters:
//
//    - uri: valid URI.
//
// The function returns the following values:
//
//    - utf8 (optional): ‘scheme’ component of the URI, or NULL on error. The
//      returned string should be freed when no longer needed.
//
func URIParseScheme(uri string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_uri_parse_scheme(_arg1)
	runtime.KeepAlive(uri)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIUnescapeSegment unescapes a segment of an escaped string.
//
// If any of the characters in illegal_characters or the NUL character appears
// as an escaped character in escaped_string, then that is an error and NULL
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
//
// Note: NUL byte is not accepted in the output, in contrast to
// g_uri_unescape_bytes().
//
// The function takes the following parameters:
//
//    - escapedString (optional): string, may be NULL.
//    - escapedStringEnd (optional): pointer to end of escaped_string, may be
//      NULL.
//    - illegalCharacters (optional): optional string of illegal characters not
//      to be allowed, may be NULL.
//
// The function returns the following values:
//
//    - utf8 (optional): unescaped version of escaped_string, or NULL on error.
//      The returned string should be freed when no longer needed. As a special
//      case if NULL is given for escaped_string, this function will return NULL.
//
func URIUnescapeSegment(escapedString, escapedStringEnd, illegalCharacters string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _arg3 *C.char // out
	var _cret *C.char // in

	if escapedString != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if escapedStringEnd != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(escapedStringEnd)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if illegalCharacters != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.g_uri_unescape_segment(_arg1, _arg2, _arg3)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(escapedStringEnd)
	runtime.KeepAlive(illegalCharacters)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIUnescapeString unescapes a whole escaped string.
//
// If any of the characters in illegal_characters or the NUL character appears
// as an escaped character in escaped_string, then that is an error and NULL
// will be returned. This is useful if you want to avoid for instance having a
// slash being expanded in an escaped path element, which might confuse pathname
// handling.
//
// The function takes the following parameters:
//
//    - escapedString: escaped string to be unescaped.
//    - illegalCharacters (optional): string of illegal characters not to be
//      allowed, or NULL.
//
// The function returns the following values:
//
//    - utf8 (optional): unescaped version of escaped_string. The returned string
//      should be freed when no longer needed.
//
func URIUnescapeString(escapedString, illegalCharacters string) string {
	var _arg1 *C.char // out
	var _arg2 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(escapedString)))
	defer C.free(unsafe.Pointer(_arg1))
	if illegalCharacters != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(illegalCharacters)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_uri_unescape_string(_arg1, _arg2)
	runtime.KeepAlive(escapedString)
	runtime.KeepAlive(illegalCharacters)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

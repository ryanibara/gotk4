// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// FileSetContentsFlags flags to pass to g_file_set_contents_full() to affect
// its safety and performance.
type FileSetContentsFlags C.guint

const (
	// FileSetContentsNone: no guarantees about file consistency or durability.
	// The most dangerous setting, which is slightly faster than other settings.
	FileSetContentsNone FileSetContentsFlags = 0b0
	// FileSetContentsConsistent: guarantee file consistency: after a crash,
	// either the old version of the file or the new version of the file will be
	// available, but not a mixture. On Unix systems this equates to an fsync()
	// on the file and use of an atomic rename() of the new version of the file
	// over the old.
	FileSetContentsConsistent FileSetContentsFlags = 0b1
	// FileSetContentsDurable: guarantee file durability: after a crash, the
	// new version of the file will be available. On Unix systems this equates
	// to an fsync() on the file (if G_FILE_SET_CONTENTS_CONSISTENT is unset),
	// or the effects of G_FILE_SET_CONTENTS_CONSISTENT plus an fsync() on the
	// directory containing the file after calling rename().
	FileSetContentsDurable FileSetContentsFlags = 0b10
	// FileSetContentsOnlyExisting: only apply consistency and durability
	// guarantees if the file already exists. This may speed up file operations
	// if the file doesn’t currently exist, but may result in a corrupted
	// version of the new file if the system crashes while writing it.
	FileSetContentsOnlyExisting FileSetContentsFlags = 0b100
)

// String returns the names in string for FileSetContentsFlags.
func (f FileSetContentsFlags) String() string {
	if f == 0 {
		return "FileSetContentsFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(96)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FileSetContentsNone:
			builder.WriteString("None|")
		case FileSetContentsConsistent:
			builder.WriteString("Consistent|")
		case FileSetContentsDurable:
			builder.WriteString("Durable|")
		case FileSetContentsOnlyExisting:
			builder.WriteString("OnlyExisting|")
		default:
			builder.WriteString(fmt.Sprintf("FileSetContentsFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FileSetContentsFlags) Has(other FileSetContentsFlags) bool {
	return (f & other) == other
}

// FileSetContentsFull writes all of contents to a file named filename,
// with good error checking. If a file called filename already exists it will be
// overwritten.
//
// flags control the properties of the write operation: whether it’s atomic,
// and what the tradeoff is between returning quickly or being resilient to
// system crashes.
//
// As this function performs file I/O, it is recommended to not call it
// anywhere where blocking would cause problems, such as in the main loop of
// a graphical application. In particular, if flags has any value other than
// G_FILE_SET_CONTENTS_NONE then this function may call fsync().
//
// If G_FILE_SET_CONTENTS_CONSISTENT is set in flags, the operation is atomic in
// the sense that it is first written to a temporary file which is then renamed
// to the final name.
//
// Notes:
//
// - On UNIX, if filename already exists hard links to filename will break.
// Also since the file is recreated, existing permissions, access control lists,
// metadata etc. may be lost. If filename is a symbolic link, the link itself
// will be replaced, not the linked file.
//
// - On UNIX, if filename already exists and is non-empty, and if the
// system supports it (via a journalling filesystem or equivalent),
// and if G_FILE_SET_CONTENTS_CONSISTENT is set in flags, the fsync() call (or
// equivalent) will be used to ensure atomic replacement: filename will contain
// either its old contents or contents, even in the face of system power loss,
// the disk being unsafely removed, etc.
//
// - On UNIX, if filename does not already exist or is empty,
// there is a possibility that system power loss etc. after calling this
// function will leave filename empty or full of NUL bytes, depending
// on the underlying filesystem, unless G_FILE_SET_CONTENTS_DURABLE and
// G_FILE_SET_CONTENTS_CONSISTENT are set in flags.
//
// - On Windows renaming a file will not remove an existing file with the new
// name, so on Windows there is a race condition between the existing file being
// removed and the temporary file being renamed.
//
// - On Windows there is no way to remove a file that is open to some process,
// or mapped into memory. Thus, this function will fail if filename already
// exists and is open.
//
// If the call was successful, it returns TRUE. If the call was not successful,
// it returns FALSE and sets error. The error domain is FILE_ERROR. Possible
// error codes are those in the Error enumeration.
//
// Note that the name for the temporary file is constructed by appending up to 7
// characters to filename.
//
// If the file didn’t exist before and is created, it will be given the
// permissions from mode. Otherwise, the permissions of the existing file may be
// changed to mode depending on flags, or they may remain unchanged.
//
// The function takes the following parameters:
//
//   - filename: name of a file to write contents to, in the GLib file name
//     encoding.
//   - contents: string to write to the file.
//   - flags controlling the safety vs speed of the operation.
//   - mode: file mode, as passed to open(); typically this will be 0666.
//
func FileSetContentsFull(filename, contents string, flags FileSetContentsFlags, mode int) error {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _arg3 C.gssize
	var _arg4 C.GFileSetContentsFlags // out
	var _arg5 C.int                   // out
	var _cerr *C.GError               // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (C.gssize)(len(contents))
	_arg2 = (*C.gchar)(C.calloc(C.size_t((len(contents) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(contents)), contents)
	defer C.free(unsafe.Pointer(_arg2))
	_arg4 = C.GFileSetContentsFlags(flags)
	_arg5 = C.int(mode)

	C.g_file_set_contents_full(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(contents)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(mode)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

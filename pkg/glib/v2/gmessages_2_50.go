// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// LogWriterOutput: return values from WriterFuncs to indicate whether the given
// log entry was successfully handled by the writer, or whether there was an
// error in handling it (and hence a fallback writer should be used).
//
// If a WriterFunc ignores a log entry, it should return G_LOG_WRITER_HANDLED.
type LogWriterOutput C.gint

const (
	// LogWriterHandled: log writer has handled the log entry.
	LogWriterHandled LogWriterOutput = 1
	// LogWriterUnhandled: log writer could not handle the log entry.
	LogWriterUnhandled LogWriterOutput = 0
)

// String returns the name in string for LogWriterOutput.
func (l LogWriterOutput) String() string {
	switch l {
	case LogWriterHandled:
		return "Handled"
	case LogWriterUnhandled:
		return "Unhandled"
	default:
		return fmt.Sprintf("LogWriterOutput(%d)", l)
	}
}

// LogWriterFunc: writer function for log entries. A log entry is a collection
// of one or more Fields, using the standard [field names from journal
// specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).
// See g_log_structured() for more information.
//
// Writer functions must ignore fields which they do not recognise, unless they
// can write arbitrary binary output, as field values may be arbitrary binary.
//
// log_level is guaranteed to be included in fields as the PRIORITY field,
// but is provided separately for convenience of deciding whether or where to
// output the log entry.
//
// Writer functions should return G_LOG_WRITER_HANDLED if they handled the log
// message successfully or if they deliberately ignored it. If there was an
// error handling the message (for example, if the writer function is meant
// to send messages to a remote logging server and there is a network error),
// it should return G_LOG_WRITER_UNHANDLED. This allows writer functions to be
// chained and fall back to simpler handlers in case of failure.
type LogWriterFunc func(logLevel LogLevelFlags, fields []LogField) (logWriterOutput LogWriterOutput)

// LogStructuredArray: log a message with structured data. The message
// will be passed through to the log writer set by the application using
// g_log_set_writer_func(). If the message is fatal (i.e. its log level is
// G_LOG_LEVEL_ERROR), the program will be aborted at the end of this function.
//
// See g_log_structured() for more documentation.
//
// This assumes that log_level is already present in fields (typically as the
// PRIORITY field).
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from LevelFlags, or a user-defined level.
//   - fields: key–value pairs of structured data to add to the log message.
//
func LogStructuredArray(logLevel LogLevelFlags, fields []LogField) {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}

	C.g_log_structured_array(_arg1, _arg2, _arg3)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
}

// LogVariant: log a message with structured data, accepting the data within
// a #GVariant. This version is especially useful for use in other languages,
// via introspection.
//
// The only mandatory item in the fields dictionary is the "MESSAGE" which must
// contain the text shown to the user.
//
// The values in the fields dictionary are likely to be of type String
// (VARIANT_TYPE_STRING). Array of bytes (VARIANT_TYPE_BYTESTRING) is also
// supported. In this case the message is handled as binary and will be
// forwarded to the log writer as such. The size of the array should not
// be higher than G_MAXSSIZE. Otherwise it will be truncated to this size.
// For other types g_variant_print() will be used to convert the value into a
// string.
//
// For more details on its usage and about the parameters, see
// g_log_structured().
//
// The function takes the following parameters:
//
//   - logDomain (optional): log domain, usually G_LOG_DOMAIN.
//   - logLevel: log level, either from LevelFlags, or a user-defined level.
//   - fields: dictionary (#GVariant of the type G_VARIANT_TYPE_VARDICT)
//     containing the key-value pairs of message data.
//
func LogVariant(logDomain string, logLevel LogLevelFlags, fields *Variant) {
	var _arg1 *C.gchar         // out
	var _arg2 C.GLogLevelFlags // out
	var _arg3 *C.GVariant      // out

	if logDomain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(logDomain)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GLogLevelFlags(logLevel)
	_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(fields)))

	C.g_log_variant(_arg1, _arg2, _arg3)
	runtime.KeepAlive(logDomain)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
}

// LogWriterDefault: format a structured log message and output it to the
// default log destination for the platform. On Linux, this is typically
// the systemd journal, falling back to stdout or stderr if running from the
// terminal or if output is being redirected to a file.
//
// Support for other platform-specific logging mechanisms may be added in
// future. Distributors of GLib may modify this function to impose their own
// (documented) platform-specific log writing policies.
//
// This is suitable for use as a WriterFunc, and is the default writer used if
// no other is set using g_log_set_writer_func().
//
// As with g_log_default_handler(), this function drops debug and informational
// messages unless their log domain (or all) is listed in the space-separated
// G_MESSAGES_DEBUG environment variable.
//
// g_log_writer_default() uses the mask set by g_log_set_always_fatal() to
// determine which messages are fatal. When using a custom writer func instead
// it is up to the writer function to determine which log messages are fatal.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from LevelFlags, or a user-defined level.
//   - fields: key–value pairs of structured data forming the log message.
//   - userData (optional): user data passed to g_log_set_writer_func().
//
// The function returns the following values:
//
//   - logWriterOutput: G_LOG_WRITER_HANDLED on success, G_LOG_WRITER_UNHANDLED
//     otherwise.
//
func LogWriterDefault(logLevel LogLevelFlags, fields []LogField, userData unsafe.Pointer) LogWriterOutput {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gpointer         // out
	var _cret C.GLogWriterOutput // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_log_writer_default(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(userData)

	var _logWriterOutput LogWriterOutput // out

	_logWriterOutput = LogWriterOutput(_cret)

	return _logWriterOutput
}

// LogWriterFormatFields: format a structured log message as a string suitable
// for outputting to the terminal (or elsewhere). This will include the
// values of all fields it knows how to interpret, which includes MESSAGE and
// GLIB_DOMAIN (see the documentation for g_log_structured()). It does not
// include values from unknown fields.
//
// The returned string does **not** have a trailing new-line character. It is
// encoded in the character set of the current locale, which is not necessarily
// UTF-8.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from LevelFlags, or a user-defined level.
//   - fields: key–value pairs of structured data forming the log message.
//   - useColor: TRUE to use ANSI color escape sequences when formatting the
//     message, FALSE to not.
//
// The function returns the following values:
//
//   - utf8: string containing the formatted log message, in the character set
//     of the current locale.
//
func LogWriterFormatFields(logLevel LogLevelFlags, fields []LogField, useColor bool) string {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gboolean // out
	var _cret *C.gchar   // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	if useColor {
		_arg4 = C.TRUE
	}

	_cret = C.g_log_writer_format_fields(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(useColor)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// LogWriterIsJournald: check whether the given output_fd file descriptor is
// a connection to the systemd journal, or something else (like a log file or
// stdout or stderr).
//
// Invalid file descriptors are accepted and return FALSE, which allows for the
// following construct without needing any additional error handling:
//
//    is_journald = g_log_writer_is_journald (fileno (stderr));.
//
// The function takes the following parameters:
//
//   - outputFd: output file descriptor to check.
//
// The function returns the following values:
//
//   - ok: TRUE if output_fd points to the journal, FALSE otherwise.
//
func LogWriterIsJournald(outputFd int) bool {
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg1 = C.gint(outputFd)

	_cret = C.g_log_writer_is_journald(_arg1)
	runtime.KeepAlive(outputFd)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogWriterJournald: format a structured log message and send it to the systemd
// journal as a set of key–value pairs. All fields are sent to the journal,
// but if a field has length zero (indicating program-specific data) then only
// its key will be sent.
//
// This is suitable for use as a WriterFunc.
//
// If GLib has been compiled without systemd support, this function is still
// defined, but will always return G_LOG_WRITER_UNHANDLED.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from LevelFlags, or a user-defined level.
//   - fields: key–value pairs of structured data forming the log message.
//   - userData (optional): user data passed to g_log_set_writer_func().
//
// The function returns the following values:
//
//   - logWriterOutput: G_LOG_WRITER_HANDLED on success, G_LOG_WRITER_UNHANDLED
//     otherwise.
//
func LogWriterJournald(logLevel LogLevelFlags, fields []LogField, userData unsafe.Pointer) LogWriterOutput {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gpointer         // out
	var _cret C.GLogWriterOutput // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_log_writer_journald(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(userData)

	var _logWriterOutput LogWriterOutput // out

	_logWriterOutput = LogWriterOutput(_cret)

	return _logWriterOutput
}

// LogWriterStandardStreams: format a structured log message and print it to
// either stdout or stderr, depending on its log level. G_LOG_LEVEL_INFO and
// G_LOG_LEVEL_DEBUG messages are sent to stdout, or to stderr if requested
// by g_log_writer_default_set_use_stderr(); all other log levels are sent to
// stderr. Only fields which are understood by this function are included in the
// formatted string which is printed.
//
// If the output stream supports ANSI color escape sequences, they will be used
// in the output.
//
// A trailing new-line character is added to the log message when it is printed.
//
// This is suitable for use as a WriterFunc.
//
// The function takes the following parameters:
//
//   - logLevel: log level, either from LevelFlags, or a user-defined level.
//   - fields: key–value pairs of structured data forming the log message.
//   - userData (optional): user data passed to g_log_set_writer_func().
//
// The function returns the following values:
//
//   - logWriterOutput: G_LOG_WRITER_HANDLED on success, G_LOG_WRITER_UNHANDLED
//     otherwise.
//
func LogWriterStandardStreams(logLevel LogLevelFlags, fields []LogField, userData unsafe.Pointer) LogWriterOutput {
	var _arg1 C.GLogLevelFlags // out
	var _arg2 *C.GLogField     // out
	var _arg3 C.gsize
	var _arg4 C.gpointer         // out
	var _cret C.GLogWriterOutput // in

	_arg1 = C.GLogLevelFlags(logLevel)
	_arg3 = (C.gsize)(len(fields))
	_arg2 = (*C.GLogField)(C.calloc(C.size_t(len(fields)), C.size_t(C.sizeof_GLogField)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GLogField)(_arg2), len(fields))
		for i := range fields {
			out[i] = *(*C.GLogField)(gextras.StructNative(unsafe.Pointer((&fields[i]))))
		}
	}
	_arg4 = (C.gpointer)(unsafe.Pointer(userData))

	_cret = C.g_log_writer_standard_streams(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(logLevel)
	runtime.KeepAlive(fields)
	runtime.KeepAlive(userData)

	var _logWriterOutput LogWriterOutput // out

	_logWriterOutput = LogWriterOutput(_cret)

	return _logWriterOutput
}

// LogWriterSupportsColor: check whether the given output_fd file descriptor
// supports ANSI color escape sequences. If so, they can safely be used when
// formatting log messages.
//
// The function takes the following parameters:
//
//   - outputFd: output file descriptor to check.
//
// The function returns the following values:
//
//   - ok: TRUE if ANSI color escapes are supported, FALSE otherwise.
//
func LogWriterSupportsColor(outputFd int) bool {
	var _arg1 C.gint     // out
	var _cret C.gboolean // in

	_arg1 = C.gint(outputFd)

	_cret = C.g_log_writer_supports_color(_arg1)
	runtime.KeepAlive(outputFd)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogField: structure representing a single field in a structured log entry.
// See g_log_structured() for details.
//
// Log fields may contain arbitrary values, including binary with embedded nul
// bytes. If the field contains a string, the string must be UTF-8 encoded and
// have a trailing nul byte. Otherwise, length must be set to a non-negative
// value.
//
// An instance of this type is always passed by reference.
type LogField struct {
	*logField
}

// logField is the struct that's finalized.
type logField struct {
	native *C.GLogField
}

// Key: field name (UTF-8 string).
func (l *LogField) Key() string {
	valptr := &l.native.key
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

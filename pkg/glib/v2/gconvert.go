// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// ConvertError: error codes returned by character set conversion routines.
type ConvertError C.gint

const (
	// ConvertErrorNoConversion: conversion between the requested character sets
	// is not supported.
	ConvertErrorNoConversion ConvertError = iota
	// ConvertErrorIllegalSequence: invalid byte sequence in conversion input;
	// or the character sequence could not be represented in the target
	// character set.
	ConvertErrorIllegalSequence
	// ConvertErrorFailed: conversion failed for some reason.
	ConvertErrorFailed
	// ConvertErrorPartialInput: partial character sequence at end of input.
	ConvertErrorPartialInput
	// ConvertErrorBadURI: URI is invalid.
	ConvertErrorBadURI
	// ConvertErrorNotAbsolutePath: pathname is not an absolute path.
	ConvertErrorNotAbsolutePath
	// ConvertErrorNoMemory: no memory available. Since: 2.40.
	ConvertErrorNoMemory
	// ConvertErrorEmbeddedNUL: embedded NUL character is present in conversion
	// output where a NUL-terminated string is expected. Since: 2.56.
	ConvertErrorEmbeddedNUL
)

// String returns the name in string for ConvertError.
func (c ConvertError) String() string {
	switch c {
	case ConvertErrorNoConversion:
		return "NoConversion"
	case ConvertErrorIllegalSequence:
		return "IllegalSequence"
	case ConvertErrorFailed:
		return "Failed"
	case ConvertErrorPartialInput:
		return "PartialInput"
	case ConvertErrorBadURI:
		return "BadURI"
	case ConvertErrorNotAbsolutePath:
		return "NotAbsolutePath"
	case ConvertErrorNoMemory:
		return "NoMemory"
	case ConvertErrorEmbeddedNUL:
		return "EmbeddedNUL"
	default:
		return fmt.Sprintf("ConvertError(%d)", c)
	}
}

// Convert converts a string from one character set to another.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that bytes_read can return information about partial characters, the
// g_convert_... functions are not generally suitable for streaming. If the
// underlying converter maintains internal state, then this won't be preserved
// across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.)
//
// Using extensions such as "//TRANSLIT" may not work (or may not work well) on
// many platforms. Consider using g_str_to_ascii() instead.
//
// The function takes the following parameters:
//
//    - str: the string to convert.
//    - toCodeset: name of character set into which to convert str.
//    - fromCodeset: character set of str.
//
// The function returns the following values:
//
//    - bytesRead (optional): location to store the number of bytes in the input
//      string that were successfully converted, or NULL. Even if the conversion
//      was successful, this may be less than len if there were partial
//      characters at the end of the input. If the error
//      CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the byte
//      offset after the last valid input sequence.
//    - guint8s: If the conversion was successful, a newly allocated buffer
//      containing the converted string, which must be freed with g_free().
//      Otherwise NULL and error will be set.
//
func Convert(str, toCodeset, fromCodeset string) (uint, []byte, error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 *C.gchar  // out
	var _arg4 *C.gchar  // out
	var _arg5 C.gsize   // in
	var _cret *C.gchar  // in
	var _arg6 C.gsize   // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(toCodeset)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(fromCodeset)))
	defer C.free(unsafe.Pointer(_arg4))

	_cret = C.g_convert(_arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(toCodeset)
	runtime.KeepAlive(fromCodeset)

	var _bytesRead uint // out
	var _guint8s []byte // out
	var _goerr error    // out

	_bytesRead = uint(_arg5)
	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg6)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg6))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _guint8s, _goerr
}

// ConvertWithFallback converts a string from one character set to another,
// possibly including fallback sequences for characters not representable in the
// output. Note that it is not guaranteed that the specification for the
// fallback sequences in fallback will be honored. Some systems may do an
// approximate conversion from from_codeset to to_codeset in their iconv()
// functions, in which case GLib will simply return that approximate conversion.
//
// Note that you should use g_iconv() for streaming conversions. Despite the
// fact that bytes_read can return information about partial characters, the
// g_convert_... functions are not generally suitable for streaming. If the
// underlying converter maintains internal state, then this won't be preserved
// across successive calls to g_convert(), g_convert_with_iconv() or
// g_convert_with_fallback(). (An example of this is the GNU C converter for
// CP1255 which does not emit a base character until it knows that the next
// character is not a mark that could combine with the base character.).
//
// The function takes the following parameters:
//
//    - str: the string to convert.
//    - toCodeset: name of character set into which to convert str.
//    - fromCodeset: character set of str.
//    - fallback: UTF-8 string to use in place of characters not present in the
//      target encoding. (The string must be representable in the target
//      encoding). If NULL, characters not in the target encoding will be
//      represented as Unicode escapes \uxxxx or \Uxxxxyyyy.
//
// The function returns the following values:
//
//    - bytesRead (optional): location to store the number of bytes in the input
//      string that were successfully converted, or NULL. Even if the conversion
//      was successful, this may be less than len if there were partial
//      characters at the end of the input.
//    - guint8s: If the conversion was successful, a newly allocated buffer
//      containing the converted string, which must be freed with g_free().
//      Otherwise NULL and error will be set.
//
func ConvertWithFallback(str, toCodeset, fromCodeset, fallback string) (uint, []byte, error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 *C.gchar  // out
	var _arg4 *C.gchar  // out
	var _arg5 *C.gchar  // out
	var _arg6 C.gsize   // in
	var _cret *C.gchar  // in
	var _arg7 C.gsize   // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(str))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(str) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(str)), str)
	defer C.free(unsafe.Pointer(_arg1))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(toCodeset)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(fromCodeset)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.gchar)(unsafe.Pointer(C.CString(fallback)))
	defer C.free(unsafe.Pointer(_arg5))

	_cret = C.g_convert_with_fallback(_arg1, _arg2, _arg3, _arg4, _arg5, &_arg6, &_arg7, &_cerr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(toCodeset)
	runtime.KeepAlive(fromCodeset)
	runtime.KeepAlive(fallback)

	var _bytesRead uint // out
	var _guint8s []byte // out
	var _goerr error    // out

	_bytesRead = uint(_arg6)
	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg7)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg7))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _guint8s, _goerr
}

// FilenameFromURI converts an escaped ASCII-encoded URI to a local filename in
// the encoding used for filenames.
//
// The function takes the following parameters:
//
//    - uri describing a filename (escaped, encoded in ASCII).
//
// The function returns the following values:
//
//    - hostname (optional): location to store hostname for the URI. If there is
//      no hostname in the URI, NULL will be stored in this location.
//    - filename: newly-allocated string holding the resulting filename, or NULL
//      on an error.
//
func FilenameFromURI(uri string) (hostname, filename string, goerr error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_filename_from_uri(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(uri)

	var _hostname string // out
	var _filename string // out
	var _goerr error     // out

	if _arg2 != nil {
		_hostname = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _hostname, _filename, _goerr
}

// FilenameFromUTF8 converts a string from UTF-8 to the encoding GLib uses for
// filenames. Note that on Windows GLib uses UTF-8 for filenames; on other
// platforms, this function indirectly depends on the [current
// locale][setlocale].
//
// The input string shall not contain nul characters even if the len argument is
// positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is not UTF-8 and
// the conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns NULL.
//
// The function takes the following parameters:
//
//    - utf8String: UTF-8 encoded string.
//    - len: length of the string, or -1 if the string is nul-terminated.
//
// The function returns the following values:
//
//    - bytesRead (optional): location to store the number of bytes in the input
//      string that were successfully converted, or NULL. Even if the conversion
//      was successful, this may be less than len if there were partial
//      characters at the end of the input. If the error
//      G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//      byte offset after the last valid input sequence.
//    - bytesWritten (optional): number of bytes stored in the output buffer (not
//      including the terminating nul).
//    - filename: The converted string, or NULL on an error.
//
func FilenameFromUTF8(utf8String string, len int) (bytesRead, bytesWritten uint, filename string, goerr error) {
	var _arg1 *C.gchar  // out
	var _arg2 C.gssize  // out
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(utf8String)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_filename_from_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(utf8String)
	runtime.KeepAlive(len)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _filename string   // out
	var _goerr error       // out

	_bytesRead = uint(_arg3)
	_bytesWritten = uint(_arg4)
	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _bytesWritten, _filename, _goerr
}

// FilenameToURI converts an absolute filename to an escaped ASCII-encoded URI,
// with the path component following Section 3.3. of RFC 2396.
//
// The function takes the following parameters:
//
//    - filename: absolute filename specified in the GLib file name encoding,
//      which is the on-disk file name bytes on Unix, and UTF-8 on Windows.
//    - hostname (optional): UTF-8 encoded hostname, or NULL for none.
//
// The function returns the following values:
//
//    - utf8: newly-allocated string holding the resulting URI, or NULL on an
//      error.
//
func FilenameToURI(filename, hostname string) (string, error) {
	var _arg1 *C.gchar  // out
	var _arg2 *C.gchar  // out
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	if hostname != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(hostname)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_filename_to_uri(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(hostname)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// FilenameToUTF8 converts a string which is in the encoding used by GLib for
// filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8 for
// filenames; on other platforms, this function indirectly depends on the
// [current locale][setlocale].
//
// The input string shall not contain nul characters even if the len argument is
// positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the source encoding is not UTF-8 and the
// conversion output contains a nul character, the error
// G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns NULL. Use
// g_convert() to produce output that may contain embedded nul characters.
//
// The function takes the following parameters:
//
//    - opsysstring: string in the encoding for filenames.
//    - len: length of the string, or -1 if the string is nul-terminated (Note
//      that some encodings may allow nul bytes to occur inside strings. In that
//      case, using -1 for the len parameter is unsafe).
//
// The function returns the following values:
//
//    - bytesRead (optional): location to store the number of bytes in the input
//      string that were successfully converted, or NULL. Even if the conversion
//      was successful, this may be less than len if there were partial
//      characters at the end of the input. If the error
//      G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//      byte offset after the last valid input sequence.
//    - bytesWritten (optional): number of bytes stored in the output buffer (not
//      including the terminating nul).
//    - utf8: converted string, or NULL on an error.
//
func FilenameToUTF8(opsysstring string, len int) (bytesRead, bytesWritten uint, utf8 string, goerr error) {
	var _arg1 *C.gchar  // out
	var _arg2 C.gssize  // out
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(opsysstring)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_filename_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(opsysstring)
	runtime.KeepAlive(len)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _utf8 string       // out
	var _goerr error       // out

	_bytesRead = uint(_arg3)
	_bytesWritten = uint(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _bytesWritten, _utf8, _goerr
}

// LocaleFromUTF8 converts a string from UTF-8 to the encoding used for strings
// by the C runtime (usually the same as that used by the operating system) in
// the [current locale][setlocale]. On Windows this means the system codepage.
//
// The input string shall not contain nul characters even if the len argument is
// positive. A nul character found inside the string will result in error
// G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert input that may
// contain embedded nul characters.
//
// The function takes the following parameters:
//
//    - utf8String: UTF-8 encoded string.
//    - len: length of the string, or -1 if the string is nul-terminated.
//
// The function returns the following values:
//
//    - bytesRead (optional): location to store the number of bytes in the input
//      string that were successfully converted, or NULL. Even if the conversion
//      was successful, this may be less than len if there were partial
//      characters at the end of the input. If the error
//      G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//      byte offset after the last valid input sequence.
//    - guint8s: A newly-allocated buffer containing the converted string, or
//      NULL on an error, and error will be set.
//
func LocaleFromUTF8(utf8String string, len int) (uint, []byte, error) {
	var _arg1 *C.gchar  // out
	var _arg2 C.gssize  // out
	var _arg3 C.gsize   // in
	var _cret *C.gchar  // in
	var _arg4 C.gsize   // in
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(utf8String)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(len)

	_cret = C.g_locale_from_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(utf8String)
	runtime.KeepAlive(len)

	var _bytesRead uint // out
	var _guint8s []byte // out
	var _goerr error    // out

	_bytesRead = uint(_arg3)
	defer C.free(unsafe.Pointer(_cret))
	_guint8s = make([]byte, _arg4)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg4))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _guint8s, _goerr
}

// LocaleToUTF8 converts a string which is in the encoding used for strings by
// the C runtime (usually the same as that used by the operating system) in the
// [current locale][setlocale] into a UTF-8 string.
//
// If the source encoding is not UTF-8 and the conversion output contains a nul
// character, the error G_CONVERT_ERROR_EMBEDDED_NUL is set and the function
// returns NULL. If the source encoding is UTF-8, an embedded nul character is
// treated with the G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward
// compatibility with earlier versions of this library. Use g_convert() to
// produce output that may contain embedded nul characters.
//
// The function takes the following parameters:
//
//    - opsysstring: string in the encoding of the current locale. On Windows
//      this means the system codepage.
//
// The function returns the following values:
//
//    - bytesRead (optional): location to store the number of bytes in the input
//      string that were successfully converted, or NULL. Even if the conversion
//      was successful, this may be less than len if there were partial
//      characters at the end of the input. If the error
//      G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value stored will be the
//      byte offset after the last valid input sequence.
//    - bytesWritten (optional): number of bytes stored in the output buffer (not
//      including the terminating nul).
//    - utf8: converted string, or NULL on an error.
//
func LocaleToUTF8(opsysstring string) (bytesRead, bytesWritten uint, utf8 string, goerr error) {
	var _arg1 *C.gchar // out
	var _arg2 C.gssize
	var _arg3 C.gsize   // in
	var _arg4 C.gsize   // in
	var _cret *C.gchar  // in
	var _cerr *C.GError // in

	_arg2 = (C.gssize)(len(opsysstring))
	_arg1 = (*C.gchar)(C.calloc(C.size_t((len(opsysstring) + 1)), C.size_t(C.sizeof_gchar)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(opsysstring)), opsysstring)
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_locale_to_utf8(_arg1, _arg2, &_arg3, &_arg4, &_cerr)
	runtime.KeepAlive(opsysstring)

	var _bytesRead uint    // out
	var _bytesWritten uint // out
	var _utf8 string       // out
	var _goerr error       // out

	_bytesRead = uint(_arg3)
	_bytesWritten = uint(_arg4)
	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytesRead, _bytesWritten, _utf8, _goerr
}

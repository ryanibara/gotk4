// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <glib.h>
// extern void callbackDelete(gpointer);
import "C"

// Array contains the public fields of a GArray.
//
// An instance of this type is always passed by reference.
type Array struct {
	*array
}

// array is the struct that's finalized.
type array struct {
	native *C.GArray
}

// Data: pointer to the element data. The data may be moved as elements are
// added to the #GArray.
func (a *Array) Data() string {
	valptr := &a.native.data
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Len: number of elements in the #GArray not including the possible terminating
// zero element.
func (a *Array) Len() uint {
	valptr := &a.native.len
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Len: number of elements in the #GArray not including the possible terminating
// zero element.
func (a *Array) SetLen(len uint) {
	valptr := &a.native.len
	*valptr = C.guint(len)
}

// ByteArray contains the public fields of a GByteArray.
//
// An instance of this type is always passed by reference.
type ByteArray struct {
	*byteArray
}

// byteArray is the struct that's finalized.
type byteArray struct {
	native *C.GByteArray
}

// Data: pointer to the element data. The data may be moved as elements are
// added to the Array.
func (b *ByteArray) Data() *byte {
	valptr := &b.native.data
	var _v *byte // out
	_v = (*byte)(unsafe.Pointer(*valptr))
	return _v
}

// Len: number of elements in the Array.
func (b *ByteArray) Len() uint {
	valptr := &b.native.len
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Len: number of elements in the Array.
func (b *ByteArray) SetLen(len uint) {
	valptr := &b.native.len
	*valptr = C.guint(len)
}

// PtrArray contains the public fields of a pointer array.
//
// An instance of this type is always passed by reference.
type PtrArray struct {
	*ptrArray
}

// ptrArray is the struct that's finalized.
type ptrArray struct {
	native *C.GPtrArray
}

// Pdata points to the array of pointers, which may be moved when the array
// grows.
func (p *PtrArray) Pdata() *unsafe.Pointer {
	valptr := &p.native.pdata
	var _v *unsafe.Pointer // out
	_v = (*unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Len: number of pointers in the array.
func (p *PtrArray) Len() uint {
	valptr := &p.native.len
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Len: number of pointers in the array.
func (p *PtrArray) SetLen(len uint) {
	valptr := &p.native.len
	*valptr = C.guint(len)
}

// NewBytesWithGo is similar to NewBytes, except the given Go byte slice
// is not copied, but will be kept alive for the lifetime of the GBytes.
// Note that the user must NOT modify data.
//
// Refer to g_bytes_new_with_free_func() for more information.
func NewBytesWithGo(data []byte) *Bytes {
	byteID := gbox.Assign(data)

	v := C.g_bytes_new_with_free_func(
		C.gconstpointer(unsafe.Pointer(&data[0])),
		C.gsize(len(data)),
		C.GDestroyNotify((*[0]byte)(C.callbackDelete)),
		C.gpointer(byteID),
	)

	_bytes := (*Bytes)(gextras.NewStructNative(unsafe.Pointer(v)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Use calls f with Bytes' internal byte slice without making a copy. f
// must NOT move the byte slice to outside of the closure, since the
// slice's internal array buffer may be freed after.
func (b *Bytes) Use(f func([]byte)) {
	var ptr C.gconstpointer // in
	var len C.gsize         // in

	ptr = C.g_bytes_get_data(
		(*C.GBytes)(gextras.StructNative(unsafe.Pointer(b))),
		&len,
	)

	var buf []byte

	h := (*reflect.SliceHeader)(unsafe.Pointer(&buf))
	h.Data = uintptr(ptr)
	h.Len = int(len)
	h.Cap = int(len)

	f(buf)
	runtime.KeepAlive(b)
}

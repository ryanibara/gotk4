// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// HashTableStealExtended looks up a key in the Table, stealing the original key
// and the associated value and returning TRUE if the key was found. If the key
// was not found, FALSE is returned.
//
// If found, the stolen key and value are removed from the hash table without
// calling the key and value destroy functions, and ownership is transferred to
// the caller of this method; as with g_hash_table_steal().
//
// You can pass NULL for lookup_key, provided the hash and equal functions of
// hash_table are NULL-safe.
//
// The function takes the following parameters:
//
//    - hashTable: Table.
//    - lookupKey (optional): key to look up.
//
// The function returns the following values:
//
//    - stolenKey (optional): return location for the original key.
//    - stolenValue (optional): return location for the value associated with the
//      key.
//    - ok: TRUE if the key was found in the Table.
//
func HashTableStealExtended(hashTable map[unsafe.Pointer]unsafe.Pointer, lookupKey unsafe.Pointer) (stolenKey, stolenValue unsafe.Pointer, ok bool) {
	var _arg1 *C.GHashTable   // out
	var _arg2 C.gconstpointer // out
	var _arg3 C.gpointer      // in
	var _arg4 C.gpointer      // in
	var _cret C.gboolean      // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst *C.gpointer // out
		var vdst *C.gpointer // out
		kdst = (*C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (*C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gconstpointer)(unsafe.Pointer(lookupKey))

	_cret = C.g_hash_table_steal_extended(_arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(lookupKey)

	var _stolenKey unsafe.Pointer   // out
	var _stolenValue unsafe.Pointer // out
	var _ok bool                    // out

	_stolenKey = (unsafe.Pointer)(unsafe.Pointer(_arg3))
	_stolenValue = (unsafe.Pointer)(unsafe.Pointer(_arg4))
	if _cret != 0 {
		_ok = true
	}

	return _stolenKey, _stolenValue, _ok
}

// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// VariantTypeStringScan: scan for a single complete and valid GVariant type
// string in string. The memory pointed to by limit (or bytes beyond it) is
// never accessed.
//
// If a valid type string is found, endptr is updated to point to the first
// character past the end of the string that was found and TRUE is returned.
//
// If there is no valid type string starting at string, or if the type string
// does not end before limit then FALSE is returned.
//
// For the simple case of checking if a string is a valid type string, see
// g_variant_type_string_is_valid().
//
// The function takes the following parameters:
//
//    - str: pointer to any string.
//    - limit (optional): end of string, or NULL.
//
// The function returns the following values:
//
//    - endptr (optional): location to store the end pointer, or NULL.
//    - ok: TRUE if a valid type string was found.
//
func VariantTypeStringScan(str, limit string) (string, bool) {
	var _arg1 *C.gchar   // out
	var _arg2 *C.gchar   // out
	var _arg3 *C.gchar   // in
	var _cret C.gboolean // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	if limit != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(limit)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_variant_type_string_scan(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(limit)

	var _endptr string // out
	var _ok bool       // out

	if _arg3 != nil {
		_endptr = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if _cret != 0 {
		_ok = true
	}

	return _endptr, _ok
}

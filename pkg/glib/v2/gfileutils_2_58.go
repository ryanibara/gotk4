// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// CanonicalizeFilename gets the canonical file name from filename. All triple
// slashes are turned into single slashes, and all .. and .s resolved against
// relative_to.
//
// Symlinks are not followed, and the returned path is guaranteed to be
// absolute.
//
// If filename is an absolute path, relative_to is ignored. Otherwise,
// relative_to will be prepended to filename to make it absolute. relative_to
// must be an absolute path, or NULL. If relative_to is NULL, it'll fallback to
// g_get_current_dir().
//
// This function never fails, and will canonicalize file paths even if they
// don't exist.
//
// No file system I/O is done.
//
// The function takes the following parameters:
//
//    - filename: name of the file.
//    - relativeTo (optional): relative directory, or NULL to use the current
//      working directory.
//
// The function returns the following values:
//
//    - ret: newly allocated string with the canonical file path.
//
func CanonicalizeFilename(filename, relativeTo string) string {
	var _arg1 *C.gchar // out
	var _arg2 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	if relativeTo != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(relativeTo)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.g_canonicalize_filename(_arg1, _arg2)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(relativeTo)

	var _ret string // out

	_ret = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _ret
}

// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// FormatSizeFlags flags to modify the format of the string returned by
// g_format_size_full().
type FormatSizeFlags C.guint

const (
	// FormatSizeDefault: behave the same as g_format_size().
	FormatSizeDefault FormatSizeFlags = 0b0
	// FormatSizeLongFormat: include the exact number of bytes as part of the
	// returned string. For example, "45.6 kB (45,612 bytes)".
	FormatSizeLongFormat FormatSizeFlags = 0b1
	// FormatSizeIecUnits: use IEC (base 1024) units with "KiB"-style suffixes.
	// IEC units should only be used for reporting things with a strong "power
	// of 2" basis, like RAM sizes or RAID stripe sizes. Network and storage
	// sizes should be reported in the normal SI units.
	FormatSizeIecUnits FormatSizeFlags = 0b10
	// FormatSizeBits: set the size as a quantity in bits, rather than bytes,
	// and return units in bits. For example, ‘Mb’ rather than ‘MB’.
	FormatSizeBits FormatSizeFlags = 0b100
)

// String returns the names in string for FormatSizeFlags.
func (f FormatSizeFlags) String() string {
	if f == 0 {
		return "FormatSizeFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(72)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FormatSizeDefault:
			builder.WriteString("Default|")
		case FormatSizeLongFormat:
			builder.WriteString("LongFormat|")
		case FormatSizeIecUnits:
			builder.WriteString("IecUnits|")
		case FormatSizeBits:
			builder.WriteString("Bits|")
		default:
			builder.WriteString(fmt.Sprintf("FormatSizeFlags(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FormatSizeFlags) Has(other FormatSizeFlags) bool {
	return (f & other) == other
}

// BitNthLSF: find the position of the first bit set in mask, searching from
// (but not including) nth_bit upwards. Bits are numbered from 0 (least
// significant) to sizeof(#gulong) * 8 - 1 (31 or 63, usually). To start
// searching from the 0th bit, set nth_bit to -1.
//
// The function takes the following parameters:
//
//    - mask containing flags.
//    - nthBit: index of the bit to start the search from.
//
// The function returns the following values:
//
//    - gint: index of the first bit set which is higher than nth_bit, or -1 if
//      no higher bits are set.
//
func BitNthLSF(mask uint32, nthBit int) int {
	var _arg1 C.gulong // out
	var _arg2 C.gint   // out
	var _cret C.gint   // in

	_arg1 = C.gulong(mask)
	_arg2 = C.gint(nthBit)

	_cret = C.g_bit_nth_lsf(_arg1, _arg2)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(nthBit)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// BitNthMSF: find the position of the first bit set in mask, searching from
// (but not including) nth_bit downwards. Bits are numbered from 0 (least
// significant) to sizeof(#gulong) * 8 - 1 (31 or 63, usually). To start
// searching from the last bit, set nth_bit to -1 or GLIB_SIZEOF_LONG * 8.
//
// The function takes the following parameters:
//
//    - mask containing flags.
//    - nthBit: index of the bit to start the search from.
//
// The function returns the following values:
//
//    - gint: index of the first bit set which is lower than nth_bit, or -1 if no
//      lower bits are set.
//
func BitNthMSF(mask uint32, nthBit int) int {
	var _arg1 C.gulong // out
	var _arg2 C.gint   // out
	var _cret C.gint   // in

	_arg1 = C.gulong(mask)
	_arg2 = C.gint(nthBit)

	_cret = C.g_bit_nth_msf(_arg1, _arg2)
	runtime.KeepAlive(mask)
	runtime.KeepAlive(nthBit)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// BitStorage gets the number of bits used to hold number, e.g. if number is 4,
// 3 bits are needed.
//
// The function takes the following parameters:
//
//    - number: #guint.
//
// The function returns the following values:
//
//    - guint: number of bits used to hold number.
//
func BitStorage(number uint32) uint {
	var _arg1 C.gulong // out
	var _cret C.guint  // in

	_arg1 = C.gulong(number)

	_cret = C.g_bit_storage(_arg1)
	runtime.KeepAlive(number)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// FindProgramInPath locates the first executable named program in the user's
// path, in the same way that execvp() would locate it. Returns an allocated
// string with the absolute path name, or NULL if the program is not found in
// the path. If program is already an absolute path, returns a copy of program
// if program exists and is executable, and NULL otherwise. On Windows, if
// program does not have a file type suffix, tries with the suffixes .exe, .cmd,
// .bat and .com, and the suffixes in the PATHEXT environment variable.
//
// On Windows, it looks for the file in the same way as CreateProcess() would.
// This means first in the directory where the executing program was loaded
// from, then in the current directory, then in the Windows 32-bit system
// directory, then in the Windows directory, and finally in the directories in
// the PATH environment variable. If the program is found, the return value
// contains the full name including the type suffix.
//
// The function takes the following parameters:
//
//    - program name in the GLib file name encoding.
//
// The function returns the following values:
//
//    - filename (optional): newly-allocated string with the absolute path, or
//      NULL.
//
func FindProgramInPath(program string) string {
	var _arg1 *C.gchar // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(program)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_find_program_in_path(_arg1)
	runtime.KeepAlive(program)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _filename
}

// GetHomeDir gets the current user's home directory.
//
// As with most UNIX tools, this function will return the value of the HOME
// environment variable if it is set to an existing absolute path name, falling
// back to the passwd file in the case that it is unset.
//
// If the path given in HOME is non-absolute, does not exist, or is not a
// directory, the result is undefined.
//
// Before version 2.36 this function would ignore the HOME environment variable,
// taking the value from the passwd database instead. This was changed to
// increase the compatibility of GLib with other programs (and the XDG basedir
// specification) and to increase testability of programs based on GLib (by
// making it easier to run them from test frameworks).
//
// If your program has a strong requirement for either the new or the old
// behaviour (and if you don't wish to increase your GLib dependency to ensure
// that the new behaviour is in effect) then you should either directly check
// the HOME environment variable yourself or unset it before calling any
// functions in GLib.
//
// The function returns the following values:
//
//    - filename: current user's home directory.
//
func GetHomeDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_home_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetPrgname gets the name of the program. This name should not be localized,
// in contrast to g_get_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK+ it is set in gdk_init(), which is
// called by gtk_init() and the Application::startup handler. The program name
// is found by taking the last component of argv[0].
//
// The function returns the following values:
//
//    - utf8 (optional): name of the program, or NULL if it has not been set yet.
//      The returned string belongs to GLib and must not be modified or freed.
//
func GetPrgname() string {
	var _cret *C.gchar // in

	_cret = C.g_get_prgname()

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// GetRealName gets the real name of the user. This usually comes from the
// user's entry in the passwd file. The encoding of the returned string is
// system-defined. (On Windows, it is, however, always UTF-8.) If the real user
// name cannot be determined, the string "Unknown" is returned.
//
// The function returns the following values:
//
//    - filename user's real name.
//
func GetRealName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_real_name()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetTmpDir gets the directory to use for temporary files.
//
// On UNIX, this is taken from the TMPDIR environment variable. If the variable
// is not set, P_tmpdir is used, as defined by the system C library. Failing
// that, a hard-coded default of "/tmp" is returned.
//
// On Windows, the TEMP environment variable is used, with the root directory of
// the Windows installation (eg: "C:\") used as a default.
//
// The encoding of the returned string is system-defined. On Windows, it is
// always UTF-8. The return value is never NULL or the empty string.
//
// The function returns the following values:
//
//    - filename: directory to use for temporary files.
//
func GetTmpDir() string {
	var _cret *C.gchar // in

	_cret = C.g_get_tmp_dir()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// GetUserName gets the user name of the current user. The encoding of the
// returned string is system-defined. On UNIX, it might be the preferred file
// name encoding, or something else, and there is no guarantee that it is even
// consistent on a machine. On Windows, it is always UTF-8.
//
// The function returns the following values:
//
//    - filename: user name of the current user.
//
func GetUserName() string {
	var _cret *C.gchar // in

	_cret = C.g_get_user_name()

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// ParseDebugString parses a string containing debugging options into a guint
// containing bit flags. This is used within GDK and GTK+ to parse the debug
// options passed on the command line or through environment variables.
//
// If string is equal to "all", all flags are set. Any flags specified along
// with "all" in string are inverted; thus, "all,foo,bar" or "foo,bar,all" sets
// all flags except those corresponding to "foo" and "bar".
//
// If string is equal to "help", all the available keys in keys are printed out
// to standard error.
//
// The function takes the following parameters:
//
//    - str (optional): list of debug options separated by colons, spaces, or
//      commas, or NULL.
//    - keys: pointer to an array of Key which associate strings with bit flags.
//
// The function returns the following values:
//
//    - guint: combined set of bit flags.
//
func ParseDebugString(str string, keys []DebugKey) uint {
	var _arg1 *C.gchar     // out
	var _arg2 *C.GDebugKey // out
	var _arg3 C.guint
	var _cret C.guint // in

	if str != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg3 = (C.guint)(len(keys))
	_arg2 = (*C.GDebugKey)(C.calloc(C.size_t(len(keys)), C.size_t(C.sizeof_GDebugKey)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GDebugKey)(_arg2), len(keys))
		for i := range keys {
			out[i] = *(*C.GDebugKey)(gextras.StructNative(unsafe.Pointer((&keys[i]))))
		}
	}

	_cret = C.g_parse_debug_string(_arg1, _arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(keys)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetPrgname sets the name of the program. This name should not be localized,
// in contrast to g_set_application_name().
//
// If you are using #GApplication the program name is set in
// g_application_run(). In case of GDK or GTK+ it is set in gdk_init(), which is
// called by gtk_init() and the Application::startup handler. The program name
// is found by taking the last component of argv[0].
//
// Note that for thread-safety reasons this function can only be called once.
//
// The function takes the following parameters:
//
//    - prgname: name of the program.
//
func SetPrgname(prgname string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(prgname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_set_prgname(_arg1)
	runtime.KeepAlive(prgname)
}

// DebugKey associates a string with a bit flag. Used in g_parse_debug_string().
//
// An instance of this type is always passed by reference.
type DebugKey struct {
	*debugKey
}

// debugKey is the struct that's finalized.
type debugKey struct {
	native *C.GDebugKey
}

// Key: string.
func (d *DebugKey) Key() string {
	valptr := &d.native.key
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Value: flag.
func (d *DebugKey) Value() uint {
	valptr := &d.native.value
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Value: flag.
func (d *DebugKey) SetValue(value uint) {
	valptr := &d.native.value
	*valptr = C.guint(value)
}

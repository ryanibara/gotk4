// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// UnicharCompose performs a single composition step of the Unicode canonical
// composition algorithm.
//
// This function includes algorithmic Hangul Jamo composition, but it is not
// exactly the inverse of g_unichar_decompose(). No composition can have either
// of a or b equal to zero. To be precise, this function composes if and only if
// there exists a Primary Composite P which is canonically equivalent to the
// sequence <a,b>. See the Unicode Standard for the definition of Primary
// Composite.
//
// If a and b do not compose a new character, ch is set to zero.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//    - a: unicode character.
//    - b: unicode character.
//
// The function returns the following values:
//
//    - ch: return location for the composed character.
//    - ok: TRUE if the characters could be composed.
//
func UnicharCompose(a, b uint32) (uint32, bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // out
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(a)
	_arg2 = C.gunichar(b)

	_cret = C.g_unichar_compose(_arg1, _arg2, &_arg3)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _ch uint32 // out
	var _ok bool   // out

	_ch = uint32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _ch, _ok
}

// UnicharDecompose performs a single decomposition step of the Unicode
// canonical decomposition algorithm.
//
// This function does not include compatibility decompositions. It does,
// however, include algorithmic Hangul Jamo decomposition, as well as
// 'singleton' decompositions which replace a character by a single other
// character. In the case of singletons *b will be set to zero.
//
// If ch is not decomposable, *a is set to ch and *b is set to zero.
//
// Note that the way Unicode decomposition pairs are defined, it is guaranteed
// that b would not decompose further, but a may itself decompose. To get the
// full canonical decomposition for ch, one would need to recursively call this
// function on a. Or use g_unichar_fully_decompose().
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//
// The function returns the following values:
//
//    - a: return location for the first component of ch.
//    - b: return location for the second component of ch.
//    - ok: TRUE if the character could be decomposed.
//
func UnicharDecompose(ch uint32) (a, b uint32, ok bool) {
	var _arg1 C.gunichar // out
	var _arg2 C.gunichar // in
	var _arg3 C.gunichar // in
	var _cret C.gboolean // in

	_arg1 = C.gunichar(ch)

	_cret = C.g_unichar_decompose(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(ch)

	var _a uint32 // out
	var _b uint32 // out
	var _ok bool  // out

	_a = uint32(_arg2)
	_b = uint32(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _a, _b, _ok
}

// UnicharFullyDecompose computes the canonical or compatibility decomposition
// of a Unicode character. For compatibility decomposition, pass TRUE for
// compat; for canonical decomposition pass FALSE for compat.
//
// The decomposed sequence is placed in result. Only up to result_len characters
// are written into result. The length of the full decomposition (irrespective
// of result_len) is returned by the function. For canonical decomposition,
// currently all decompositions are of length at most 4, but this may change in
// the future (very unlikely though). At any rate, Unicode does guarantee that a
// buffer of length 18 is always enough for both compatibility and canonical
// decompositions, so that is the size recommended. This is provided as
// G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
//
// See UAX#15 (http://unicode.org/reports/tr15/) for details.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//    - compat: whether perform canonical or compatibility decomposition.
//    - resultLen: length of result.
//
// The function returns the following values:
//
//    - result (optional): location to store decomposed result, or NULL.
//    - gsize: length of the full decomposition.
//
func UnicharFullyDecompose(ch uint32, compat bool, resultLen uint) (uint32, uint) {
	var _arg1 C.gunichar // out
	var _arg2 C.gboolean // out
	var _arg3 C.gunichar // in
	var _arg4 C.gsize    // out
	var _cret C.gsize    // in

	_arg1 = C.gunichar(ch)
	if compat {
		_arg2 = C.TRUE
	}
	_arg4 = C.gsize(resultLen)

	_cret = C.g_unichar_fully_decompose(_arg1, _arg2, &_arg3, _arg4)
	runtime.KeepAlive(ch)
	runtime.KeepAlive(compat)
	runtime.KeepAlive(resultLen)

	var _result uint32 // out
	var _gsize uint    // out

	_result = uint32(_arg3)
	_gsize = uint(_cret)

	return _result, _gsize
}

// UnicodeScriptFromISO15924 looks up the Unicode script for iso15924. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. This function accepts four letter codes encoded as a guint32 in a
// big-endian fashion. That is, the code expected for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
//
// The function takes the following parameters:
//
//    - iso15924: unicode script.
//
// The function returns the following values:
//
//    - unicodeScript: unicode script for iso15924, or of
//      G_UNICODE_SCRIPT_INVALID_CODE if iso15924 is zero and
//      G_UNICODE_SCRIPT_UNKNOWN if iso15924 is unknown.
//
func UnicodeScriptFromISO15924(iso15924 uint32) UnicodeScript {
	var _arg1 C.guint32        // out
	var _cret C.GUnicodeScript // in

	_arg1 = C.guint32(iso15924)

	_cret = C.g_unicode_script_from_iso15924(_arg1)
	runtime.KeepAlive(iso15924)

	var _unicodeScript UnicodeScript // out

	_unicodeScript = UnicodeScript(_cret)

	return _unicodeScript
}

// UnicodeScriptToISO15924 looks up the ISO 15924 code for script. ISO 15924
// assigns four-letter codes to scripts. For example, the code for Arabic is
// 'Arab'. The four letter codes are encoded as a guint32 by this function in a
// big-endian fashion. That is, the code returned for Arabic is 0x41726162 (0x41
// is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).
//
// See Codes for the representation of names of scripts
// (http://unicode.org/iso15924/codelists.html) for details.
//
// The function takes the following parameters:
//
//    - script: unicode script.
//
// The function returns the following values:
//
//    - guint32: ISO 15924 code for script, encoded as an integer, of zero if
//      script is G_UNICODE_SCRIPT_INVALID_CODE or ISO 15924 code 'Zzzz' (script
//      code for UNKNOWN) if script is not understood.
//
func UnicodeScriptToISO15924(script UnicodeScript) uint32 {
	var _arg1 C.GUnicodeScript // out
	var _cret C.guint32        // in

	_arg1 = C.GUnicodeScript(script)

	_cret = C.g_unicode_script_to_iso15924(_arg1)
	runtime.KeepAlive(script)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// UTF8Substring copies a substring out of a UTF-8 encoded string. The substring
// will contain end_pos - start_pos characters.
//
// The function takes the following parameters:
//
//    - str: UTF-8 encoded string.
//    - startPos: character offset within str.
//    - endPos: another character offset within str.
//
// The function returns the following values:
//
//    - utf8: newly allocated copy of the requested substring. Free with g_free()
//      when no longer needed.
//
func UTF8Substring(str string, startPos, endPos int32) string {
	var _arg1 *C.gchar // out
	var _arg2 C.glong  // out
	var _arg3 C.glong  // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.glong(startPos)
	_arg3 = C.glong(endPos)

	_cret = C.g_utf8_substring(_arg1, _arg2, _arg3)
	runtime.KeepAlive(str)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

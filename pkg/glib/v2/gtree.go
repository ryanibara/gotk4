// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <glib.h>
import "C"

// GTypeTree returns the GType for the type Tree.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTree() coreglib.Type {
	gtype := coreglib.Type(C.g_tree_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalTree)
	return gtype
}

// Tree struct is an opaque data structure representing a [balanced binary
// tree][glib-Balanced-Binary-Trees]. It should be accessed only by using the
// following functions.
//
// An instance of this type is always passed by reference.
type Tree struct {
	*tree
}

// tree is the struct that's finalized.
type tree struct {
	native *C.GTree
}

func marshalTree(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Tree{&tree{(*C.GTree)(b)}}, nil
}

// Destroy removes all keys and values from the #GTree and decreases its
// reference count by one. If keys and/or values are dynamically allocated, you
// should either free them first or create the #GTree using g_tree_new_full().
// In the latter case the destroy functions you supplied will be called on all
// keys and values before destroying the #GTree.
func (tree *Tree) Destroy() {
	var _arg0 *C.GTree // out

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))

	C.g_tree_destroy(_arg0)
	runtime.KeepAlive(tree)
}

// Height gets the height of a #GTree.
//
// If the #GTree contains no nodes, the height is 0. If the #GTree contains only
// one root node the height is 1. If the root node has children the height is 2,
// etc.
//
// The function returns the following values:
//
//    - gint: height of tree.
//
func (tree *Tree) Height() int {
	var _arg0 *C.GTree // out
	var _cret C.gint   // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))

	_cret = C.g_tree_height(_arg0)
	runtime.KeepAlive(tree)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Insert inserts a key/value pair into a #GTree.
//
// Inserts a new key and value into a #GTree as g_tree_insert_node() does, only
// this function does not return the inserted or set node.
//
// The function takes the following parameters:
//
//    - key (optional) to insert.
//    - value (optional) corresponding to the key.
//
func (tree *Tree) Insert(key unsafe.Pointer, value unsafe.Pointer) {
	var _arg0 *C.GTree   // out
	var _arg1 C.gpointer // out
	var _arg2 C.gpointer // out

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gpointer)(unsafe.Pointer(key))
	_arg2 = (C.gpointer)(unsafe.Pointer(value))

	C.g_tree_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// Lookup gets the value corresponding to the given key. Since a #GTree is
// automatically balanced as key/value pairs are added, key lookup is O(log n)
// (where n is the number of key/value pairs in the tree).
//
// The function takes the following parameters:
//
//    - key (optional) to look up.
//
// The function returns the following values:
//
//    - gpointer (optional): value corresponding to the key, or NULL if the key
//      was not found.
//
func (tree *Tree) Lookup(key unsafe.Pointer) unsafe.Pointer {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gpointer      // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_tree_lookup(_arg0, _arg1)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)

	var _gpointer unsafe.Pointer // out

	_gpointer = (unsafe.Pointer)(unsafe.Pointer(_cret))

	return _gpointer
}

// LookupExtended looks up a key in the #GTree, returning the original key and
// the associated value. This is useful if you need to free the memory allocated
// for the original key, for example before calling g_tree_remove().
//
// The function takes the following parameters:
//
//    - lookupKey (optional): key to look up.
//
// The function returns the following values:
//
//    - origKey (optional) returns the original key.
//    - value (optional) returns the value associated with the key.
//    - ok: TRUE if the key was found in the #GTree.
//
func (tree *Tree) LookupExtended(lookupKey unsafe.Pointer) (origKey unsafe.Pointer, value unsafe.Pointer, ok bool) {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _arg2 C.gpointer      // in
	var _arg3 C.gpointer      // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(lookupKey))

	_cret = C.g_tree_lookup_extended(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(lookupKey)

	var _origKey unsafe.Pointer // out
	var _value unsafe.Pointer   // out
	var _ok bool                // out

	_origKey = (unsafe.Pointer)(unsafe.Pointer(_arg2))
	_value = (unsafe.Pointer)(unsafe.Pointer(_arg3))
	if _cret != 0 {
		_ok = true
	}

	return _origKey, _value, _ok
}

// Nnodes gets the number of nodes in a #GTree.
//
// The function returns the following values:
//
//    - gint: number of nodes in tree.
//
func (tree *Tree) Nnodes() int {
	var _arg0 *C.GTree // out
	var _cret C.gint   // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))

	_cret = C.g_tree_nnodes(_arg0)
	runtime.KeepAlive(tree)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Remove removes a key/value pair from a #GTree.
//
// If the #GTree was created using g_tree_new_full(), the key and value are
// freed using the supplied destroy functions, otherwise you have to make sure
// that any dynamically allocated values are freed yourself. If the key does not
// exist in the #GTree, the function does nothing.
//
// The cost of maintaining a balanced tree while removing a key/value result in
// a O(n log(n)) operation where most of the other operations are O(log(n)).
//
// The function takes the following parameters:
//
//    - key (optional) to remove.
//
// The function returns the following values:
//
//    - ok: TRUE if the key was found (prior to 2.8, this function returned
//      nothing).
//
func (tree *Tree) Remove(key unsafe.Pointer) bool {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_tree_remove(_arg0, _arg1)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Replace inserts a new key and value into a #GTree as g_tree_replace_node()
// does, only this function does not return the inserted or set node.
//
// The function takes the following parameters:
//
//    - key (optional) to insert.
//    - value (optional) corresponding to the key.
//
func (tree *Tree) Replace(key unsafe.Pointer, value unsafe.Pointer) {
	var _arg0 *C.GTree   // out
	var _arg1 C.gpointer // out
	var _arg2 C.gpointer // out

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gpointer)(unsafe.Pointer(key))
	_arg2 = (C.gpointer)(unsafe.Pointer(value))

	C.g_tree_replace(_arg0, _arg1, _arg2)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// Steal removes a key and its associated value from a #GTree without calling
// the key and value destroy functions.
//
// If the key does not exist in the #GTree, the function does nothing.
//
// The function takes the following parameters:
//
//    - key (optional) to remove.
//
// The function returns the following values:
//
//    - ok: TRUE if the key was found (prior to 2.8, this function returned
//      nothing).
//
func (tree *Tree) Steal(key unsafe.Pointer) bool {
	var _arg0 *C.GTree        // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GTree)(gextras.StructNative(unsafe.Pointer(tree)))
	_arg1 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_tree_steal(_arg0, _arg1)
	runtime.KeepAlive(tree)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

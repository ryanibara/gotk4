// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <glib.h>
import "C"

// GType values.
var (
	GTypeMatchInfo = coreglib.Type(C.g_match_info_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMatchInfo, F: marshalMatchInfo},
	})
}

// MatchInfo is an opaque struct used to return information about matches.
//
// An instance of this type is always passed by reference.
type MatchInfo struct {
	*matchInfo
}

// matchInfo is the struct that's finalized.
type matchInfo struct {
	native *C.GMatchInfo
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MatchInfo{&matchInfo{(*C.GMatchInfo)(b)}}, nil
}

// ExpandReferences returns a new string containing the text in string_to_expand
// with references and escape sequences expanded. References refer to the
// last match done with string against regex and have the same syntax used by
// g_regex_replace().
//
// The string_to_expand must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// match_info may be NULL in which case string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether string_to_expand contains references.
//
// The function takes the following parameters:
//
//   - stringToExpand: string to expand.
//
// The function returns the following values:
//
//   - utf8 (optional): expanded string, or NULL if an error occurred.
//
func (matchInfo *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in
	var _cerr *C.GError     // in

	if matchInfo != nil {
		_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(stringToExpand)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_expand_references(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(stringToExpand)

	var _utf8 string // out
	var _goerr error // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// Fetch retrieves the text matching the match_num'th capturing parentheses.
// 0 is the full text of the match, 1 is the first paren set, 2 the second,
// and so on.
//
// If match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
//
// The function takes the following parameters:
//
//   - matchNum: number of the sub expression.
//
// The function returns the following values:
//
//   - utf8 (optional): matched substring, or NULL if an error occurred.
//     You have to free the string yourself.
//
func (matchInfo *MatchInfo) Fetch(matchNum int) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch(_arg0, _arg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function,
// so you cannot call this function after freeing the string.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of gchar * pointers. It must be freed using
//     g_strfreev(). If the previous match failed NULL is returned.
//
func (matchInfo *MatchInfo) FetchAll() []string {
	var _arg0 *C.GMatchInfo // out
	var _cret **C.gchar     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_fetch_all(_arg0)
	runtime.KeepAlive(matchInfo)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// FetchNamed retrieves the text matching the capturing parentheses named name.
//
// If name is a valid sub pattern name but it didn't match anything (e.g.
// sub pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
//
// The function takes the following parameters:
//
//   - name of the subexpression.
//
// The function returns the following values:
//
//   - utf8 (optional): matched substring, or NULL if an error occurred.
//     You have to free the string yourself.
//
func (matchInfo *MatchInfo) FetchNamed(name string) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named(_arg0, _arg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named name.
//
// If name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then start_pos and end_pos
// are set to -1 and TRUE is returned.
//
// The function takes the following parameters:
//
//   - name of the subexpression.
//
// The function returns the following values:
//
//   - startPos (optional): pointer to location where to store the start
//     position, or NULL.
//   - endPos (optional): pointer to location where to store the end position,
//     or NULL.
//   - ok: TRUE if the position was fetched, FALSE otherwise. If the position
//     cannot be fetched, start_pos and end_pos are left unchanged.
//
func (matchInfo *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// FetchPos retrieves the position in bytes of the match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set,
// 2 the second, and so on.
//
// If match_num is a valid sub pattern but it didn't match anything (e.g.
// sub pattern 1, matching "b" against "(a)?b") then start_pos and end_pos are
// set to -1 and TRUE is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
//
// The function takes the following parameters:
//
//   - matchNum: number of the sub expression.
//
// The function returns the following values:
//
//   - startPos (optional): pointer to location where to store the start
//     position, or NULL.
//   - endPos (optional): pointer to location where to store the end position,
//     or NULL.
//   - ok: TRUE if the position was fetched, FALSE otherwise. If the position
//     cannot be fetched, start_pos and end_pos are left unchanged.
//
func (matchInfo *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
//
// The function returns the following values:
//
//   - gint: number of matched substrings, or -1 if an error occurred.
//
func (matchInfo *MatchInfo) MatchCount() int {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gint        // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_match_count(_arg0)
	runtime.KeepAlive(matchInfo)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Regex returns #GRegex object used in match_info. It belongs to Glib and
// must not be freed. Use g_regex_ref() if you need to keep it after you free
// match_info object.
//
// The function returns the following values:
//
//   - regex object used in match_info.
//
func (matchInfo *MatchInfo) Regex() *Regex {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GRegex     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_regex(_arg0)
	runtime.KeepAlive(matchInfo)

	var _regex *Regex // out

	_regex = (*Regex)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_regex)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_regex_unref((*C.GRegex)(intern.C))
		},
	)

	return _regex
}

// String returns the string searched with match_info. This is the string passed
// to g_regex_match() or g_regex_replace() so you may not free it before calling
// this function.
//
// The function returns the following values:
//
//   - utf8: string searched with match_info.
//
func (matchInfo *MatchInfo) String() string {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_string(_arg0)
	runtime.KeepAlive(matchInfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches
// as far as it goes, but is too short to match the entire pattern, FALSE is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to
// type in data for a field with specific formatting requirements.
// An example might be a date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD flags. When they
// are used, the return code for g_regex_match() or g_regex_match_full() is,
// as usual, TRUE for a complete match, FALSE otherwise. But, when these
// functions return FALSE, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD
// is that when a partial match is encountered with REGEX_MATCH_PARTIAL_SOFT,
// matching continues to search for a possible complete match, while with
// REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD are set, the latter
// takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
//
// The function returns the following values:
//
//   - ok: TRUE if the match was partial, FALSE otherwise.
//
func (matchInfo *MatchInfo) IsPartialMatch() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_is_partial_match(_arg0)
	runtime.KeepAlive(matchInfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches returns whether the previous match operation succeeded.
//
// The function returns the following values:
//
//   - ok: TRUE if the previous match operation succeeded, FALSE otherwise.
//
func (matchInfo *MatchInfo) Matches() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_matches(_arg0)
	runtime.KeepAlive(matchInfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (matchInfo *MatchInfo) Next() error {
	var _arg0 *C.GMatchInfo // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	C.g_match_info_next(_arg0, &_cerr)
	runtime.KeepAlive(matchInfo)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

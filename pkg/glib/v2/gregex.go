// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <glib.h>
import "C"

// glib.Type values for gregex.go.
var (
	GTypeMatchInfo = externglib.Type(C.g_match_info_get_type())
	GTypeRegex     = externglib.Type(C.g_regex_get_type())
)

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeMatchInfo, F: marshalMatchInfo},
		{T: GTypeRegex, F: marshalRegex},
	})
}

// RegexError: error codes returned by regular expressions functions.
type RegexError C.gint

const (
	// RegexErrorCompile: compilation of the regular expression failed.
	RegexErrorCompile RegexError = 0
	// RegexErrorOptimize: optimization of the regular expression failed.
	RegexErrorOptimize RegexError = 1
	// RegexErrorReplace: replacement failed due to an ill-formed replacement
	// string.
	RegexErrorReplace RegexError = 2
	// RegexErrorMatch: match process failed.
	RegexErrorMatch RegexError = 3
	// RegexErrorInternal: internal error of the regular expression engine.
	// Since 2.16.
	RegexErrorInternal RegexError = 4
	// RegexErrorStrayBackslash: "\\" at end of pattern. Since 2.16.
	RegexErrorStrayBackslash RegexError = 101
	// RegexErrorMissingControlChar: "\\c" at end of pattern. Since 2.16.
	RegexErrorMissingControlChar RegexError = 102
	// RegexErrorUnrecognizedEscape: unrecognized character follows "\\". Since
	// 2.16.
	RegexErrorUnrecognizedEscape RegexError = 103
	// RegexErrorQuantifiersOutOfOrder numbers out of order in "{}" quantifier.
	// Since 2.16.
	RegexErrorQuantifiersOutOfOrder RegexError = 104
	// RegexErrorQuantifierTooBig: number too big in "{}" quantifier. Since
	// 2.16.
	RegexErrorQuantifierTooBig RegexError = 105
	// RegexErrorUnterminatedCharacterClass: missing terminating "]" for
	// character class. Since 2.16.
	RegexErrorUnterminatedCharacterClass RegexError = 106
	// RegexErrorInvalidEscapeInCharacterClass: invalid escape sequence in
	// character class. Since 2.16.
	RegexErrorInvalidEscapeInCharacterClass RegexError = 107
	// RegexErrorRangeOutOfOrder: range out of order in character class. Since
	// 2.16.
	RegexErrorRangeOutOfOrder RegexError = 108
	// RegexErrorNothingToRepeat: nothing to repeat. Since 2.16.
	RegexErrorNothingToRepeat RegexError = 109
	// RegexErrorUnrecognizedCharacter: unrecognized character after "(?", "(?<"
	// or "(?P". Since 2.16.
	RegexErrorUnrecognizedCharacter RegexError = 112
	// RegexErrorPosixNamedClassOutsideClass: POSIX named classes are supported
	// only within a class. Since 2.16.
	RegexErrorPosixNamedClassOutsideClass RegexError = 113
	// RegexErrorUnmatchedParenthesis: missing terminating ")" or ")" without
	// opening "(". Since 2.16.
	RegexErrorUnmatchedParenthesis RegexError = 114
	// RegexErrorInexistentSubpatternReference: reference to non-existent
	// subpattern. Since 2.16.
	RegexErrorInexistentSubpatternReference RegexError = 115
	// RegexErrorUnterminatedComment: missing terminating ")" after comment.
	// Since 2.16.
	RegexErrorUnterminatedComment RegexError = 118
	// RegexErrorExpressionTooLarge: regular expression too large. Since 2.16.
	RegexErrorExpressionTooLarge RegexError = 120
	// RegexErrorMemoryError: failed to get memory. Since 2.16.
	RegexErrorMemoryError RegexError = 121
	// RegexErrorVariableLengthLookbehind: lookbehind assertion is not fixed
	// length. Since 2.16.
	RegexErrorVariableLengthLookbehind RegexError = 125
	// RegexErrorMalformedCondition: malformed number or name after "(?(". Since
	// 2.16.
	RegexErrorMalformedCondition RegexError = 126
	// RegexErrorTooManyConditionalBranches: conditional group contains more
	// than two branches. Since 2.16.
	RegexErrorTooManyConditionalBranches RegexError = 127
	// RegexErrorAssertionExpected: assertion expected after "(?(". Since 2.16.
	RegexErrorAssertionExpected RegexError = 128
	// RegexErrorUnknownPosixClassName: unknown POSIX class name. Since 2.16.
	RegexErrorUnknownPosixClassName RegexError = 130
	// RegexErrorPosixCollatingElementsNotSupported: POSIX collating elements
	// are not supported. Since 2.16.
	RegexErrorPosixCollatingElementsNotSupported RegexError = 131
	// RegexErrorHexCodeTooLarge: character value in "\\x{...}" sequence is too
	// large. Since 2.16.
	RegexErrorHexCodeTooLarge RegexError = 134
	// RegexErrorInvalidCondition: invalid condition "(?(0)". Since 2.16.
	RegexErrorInvalidCondition RegexError = 135
	// RegexErrorSingleByteMatchInLookbehind: \\C not allowed in lookbehind
	// assertion. Since 2.16.
	RegexErrorSingleByteMatchInLookbehind RegexError = 136
	// RegexErrorInfiniteLoop: recursive call could loop indefinitely. Since
	// 2.16.
	RegexErrorInfiniteLoop RegexError = 140
	// RegexErrorMissingSubpatternNameTerminator: missing terminator in
	// subpattern name. Since 2.16.
	RegexErrorMissingSubpatternNameTerminator RegexError = 142
	// RegexErrorDuplicateSubpatternName: two named subpatterns have the same
	// name. Since 2.16.
	RegexErrorDuplicateSubpatternName RegexError = 143
	// RegexErrorMalformedProperty: malformed "\\P" or "\\p" sequence. Since
	// 2.16.
	RegexErrorMalformedProperty RegexError = 146
	// RegexErrorUnknownProperty: unknown property name after "\\P" or "\\p".
	// Since 2.16.
	RegexErrorUnknownProperty RegexError = 147
	// RegexErrorSubpatternNameTooLong: subpattern name is too long (maximum 32
	// characters). Since 2.16.
	RegexErrorSubpatternNameTooLong RegexError = 148
	// RegexErrorTooManySubpatterns: too many named subpatterns (maximum
	// 10,000). Since 2.16.
	RegexErrorTooManySubpatterns RegexError = 149
	// RegexErrorInvalidOctalValue: octal value is greater than "\\377". Since
	// 2.16.
	RegexErrorInvalidOctalValue RegexError = 151
	// RegexErrorTooManyBranchesInDefine: "DEFINE" group contains more than one
	// branch. Since 2.16.
	RegexErrorTooManyBranchesInDefine RegexError = 154
	// RegexErrorDefineRepetion: repeating a "DEFINE" group is not allowed. This
	// error is never raised. Since: 2.16 Deprecated: 2.34.
	RegexErrorDefineRepetion RegexError = 155
	// RegexErrorInconsistentNewlineOptions: inconsistent newline options. Since
	// 2.16.
	RegexErrorInconsistentNewlineOptions RegexError = 156
	// RegexErrorMissingBackReference: "\\g" is not followed by a braced,
	// angle-bracketed, or quoted name or number, or by a plain number. Since:
	// 2.16.
	RegexErrorMissingBackReference RegexError = 157
	// RegexErrorInvalidRelativeReference: relative reference must not be zero.
	// Since: 2.34.
	RegexErrorInvalidRelativeReference RegexError = 158
	// RegexErrorBacktrackingControlVerbArgumentForbidden: backtracing control
	// verb used does not allow an argument. Since: 2.34.
	RegexErrorBacktrackingControlVerbArgumentForbidden RegexError = 159
	// RegexErrorUnknownBacktrackingControlVerb: unknown backtracing control
	// verb. Since: 2.34.
	RegexErrorUnknownBacktrackingControlVerb RegexError = 160
	// RegexErrorNumberTooBig: number is too big in escape sequence. Since:
	// 2.34.
	RegexErrorNumberTooBig RegexError = 161
	// RegexErrorMissingSubpatternName: missing subpattern name. Since: 2.34.
	RegexErrorMissingSubpatternName RegexError = 162
	// RegexErrorMissingDigit: missing digit. Since 2.34.
	RegexErrorMissingDigit RegexError = 163
	// RegexErrorInvalidDataCharacter: in JavaScript compatibility mode, "[" is
	// an invalid data character. Since: 2.34.
	RegexErrorInvalidDataCharacter RegexError = 164
	// RegexErrorExtraSubpatternName: different names for subpatterns of the
	// same number are not allowed. Since: 2.34.
	RegexErrorExtraSubpatternName RegexError = 165
	// RegexErrorBacktrackingControlVerbArgumentRequired: backtracing control
	// verb requires an argument. Since: 2.34.
	RegexErrorBacktrackingControlVerbArgumentRequired RegexError = 166
	// RegexErrorInvalidControlChar: "\\c" must be followed by an ASCII
	// character. Since: 2.34.
	RegexErrorInvalidControlChar RegexError = 168
	// RegexErrorMissingName: "\\k" is not followed by a braced,
	// angle-bracketed, or quoted name. Since: 2.34.
	RegexErrorMissingName RegexError = 169
	// RegexErrorNotSupportedInClass: "\\N" is not supported in a class. Since:
	// 2.34.
	RegexErrorNotSupportedInClass RegexError = 171
	// RegexErrorTooManyForwardReferences: too many forward references. Since:
	// 2.34.
	RegexErrorTooManyForwardReferences RegexError = 172
	// RegexErrorNameTooLong: name is too long in "(*MARK)", "(*PRUNE)",
	// "(*SKIP)", or "(*THEN)". Since: 2.34.
	RegexErrorNameTooLong RegexError = 175
	// RegexErrorCharacterValueTooLarge: character value in the \\u sequence is
	// too large. Since: 2.34.
	RegexErrorCharacterValueTooLarge RegexError = 176
)

// String returns the name in string for RegexError.
func (r RegexError) String() string {
	switch r {
	case RegexErrorCompile:
		return "Compile"
	case RegexErrorOptimize:
		return "Optimize"
	case RegexErrorReplace:
		return "Replace"
	case RegexErrorMatch:
		return "Match"
	case RegexErrorInternal:
		return "Internal"
	case RegexErrorStrayBackslash:
		return "StrayBackslash"
	case RegexErrorMissingControlChar:
		return "MissingControlChar"
	case RegexErrorUnrecognizedEscape:
		return "UnrecognizedEscape"
	case RegexErrorQuantifiersOutOfOrder:
		return "QuantifiersOutOfOrder"
	case RegexErrorQuantifierTooBig:
		return "QuantifierTooBig"
	case RegexErrorUnterminatedCharacterClass:
		return "UnterminatedCharacterClass"
	case RegexErrorInvalidEscapeInCharacterClass:
		return "InvalidEscapeInCharacterClass"
	case RegexErrorRangeOutOfOrder:
		return "RangeOutOfOrder"
	case RegexErrorNothingToRepeat:
		return "NothingToRepeat"
	case RegexErrorUnrecognizedCharacter:
		return "UnrecognizedCharacter"
	case RegexErrorPosixNamedClassOutsideClass:
		return "PosixNamedClassOutsideClass"
	case RegexErrorUnmatchedParenthesis:
		return "UnmatchedParenthesis"
	case RegexErrorInexistentSubpatternReference:
		return "InexistentSubpatternReference"
	case RegexErrorUnterminatedComment:
		return "UnterminatedComment"
	case RegexErrorExpressionTooLarge:
		return "ExpressionTooLarge"
	case RegexErrorMemoryError:
		return "MemoryError"
	case RegexErrorVariableLengthLookbehind:
		return "VariableLengthLookbehind"
	case RegexErrorMalformedCondition:
		return "MalformedCondition"
	case RegexErrorTooManyConditionalBranches:
		return "TooManyConditionalBranches"
	case RegexErrorAssertionExpected:
		return "AssertionExpected"
	case RegexErrorUnknownPosixClassName:
		return "UnknownPosixClassName"
	case RegexErrorPosixCollatingElementsNotSupported:
		return "PosixCollatingElementsNotSupported"
	case RegexErrorHexCodeTooLarge:
		return "HexCodeTooLarge"
	case RegexErrorInvalidCondition:
		return "InvalidCondition"
	case RegexErrorSingleByteMatchInLookbehind:
		return "SingleByteMatchInLookbehind"
	case RegexErrorInfiniteLoop:
		return "InfiniteLoop"
	case RegexErrorMissingSubpatternNameTerminator:
		return "MissingSubpatternNameTerminator"
	case RegexErrorDuplicateSubpatternName:
		return "DuplicateSubpatternName"
	case RegexErrorMalformedProperty:
		return "MalformedProperty"
	case RegexErrorUnknownProperty:
		return "UnknownProperty"
	case RegexErrorSubpatternNameTooLong:
		return "SubpatternNameTooLong"
	case RegexErrorTooManySubpatterns:
		return "TooManySubpatterns"
	case RegexErrorInvalidOctalValue:
		return "InvalidOctalValue"
	case RegexErrorTooManyBranchesInDefine:
		return "TooManyBranchesInDefine"
	case RegexErrorDefineRepetion:
		return "DefineRepetion"
	case RegexErrorInconsistentNewlineOptions:
		return "InconsistentNewlineOptions"
	case RegexErrorMissingBackReference:
		return "MissingBackReference"
	case RegexErrorInvalidRelativeReference:
		return "InvalidRelativeReference"
	case RegexErrorBacktrackingControlVerbArgumentForbidden:
		return "BacktrackingControlVerbArgumentForbidden"
	case RegexErrorUnknownBacktrackingControlVerb:
		return "UnknownBacktrackingControlVerb"
	case RegexErrorNumberTooBig:
		return "NumberTooBig"
	case RegexErrorMissingSubpatternName:
		return "MissingSubpatternName"
	case RegexErrorMissingDigit:
		return "MissingDigit"
	case RegexErrorInvalidDataCharacter:
		return "InvalidDataCharacter"
	case RegexErrorExtraSubpatternName:
		return "ExtraSubpatternName"
	case RegexErrorBacktrackingControlVerbArgumentRequired:
		return "BacktrackingControlVerbArgumentRequired"
	case RegexErrorInvalidControlChar:
		return "InvalidControlChar"
	case RegexErrorMissingName:
		return "MissingName"
	case RegexErrorNotSupportedInClass:
		return "NotSupportedInClass"
	case RegexErrorTooManyForwardReferences:
		return "TooManyForwardReferences"
	case RegexErrorNameTooLong:
		return "NameTooLong"
	case RegexErrorCharacterValueTooLarge:
		return "CharacterValueTooLarge"
	default:
		return fmt.Sprintf("RegexError(%d)", r)
	}
}

// RegexCompileFlags flags specifying compile-time options.
type RegexCompileFlags C.guint

const (
	// RegexCaseless letters in the pattern match both upper- and lowercase
	// letters. This option can be changed within a pattern by a "(?i)" option
	// setting.
	RegexCaseless RegexCompileFlags = 0b1
	// RegexMultiline: by default, GRegex treats the strings as consisting of a
	// single line of characters (even if it actually contains newlines). The
	// "start of line" metacharacter ("^") matches only at the start of the
	// string, while the "end of line" metacharacter ("$") matches only at the
	// end of the string, or before a terminating newline (unless
	// REGEX_DOLLAR_ENDONLY is set). When REGEX_MULTILINE is set, the "start of
	// line" and "end of line" constructs match immediately following or
	// immediately before any newline in the string, respectively, as well as at
	// the very start and end. This can be changed within a pattern by a "(?m)"
	// option setting.
	RegexMultiline RegexCompileFlags = 0b10
	// RegexDotall: dot metacharacter (".") in the pattern matches all
	// characters, including newlines. Without it, newlines are excluded. This
	// option can be changed within a pattern by a ("?s") option setting.
	RegexDotall RegexCompileFlags = 0b100
	// RegexExtended: whitespace data characters in the pattern are totally
	// ignored except when escaped or inside a character class. Whitespace does
	// not include the VT character (code 11). In addition, characters between
	// an unescaped "#" outside a character class and the next newline
	// character, inclusive, are also ignored. This can be changed within a
	// pattern by a "(?x)" option setting.
	RegexExtended RegexCompileFlags = 0b1000
	// RegexAnchored: pattern is forced to be "anchored", that is, it is
	// constrained to match only at the first matching point in the string that
	// is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexAnchored RegexCompileFlags = 0b10000
	// RegexDollarEndonly: dollar metacharacter ("$") in the pattern matches
	// only at the end of the string. Without this option, a dollar also matches
	// immediately before the final character if it is a newline (but not before
	// any other newlines). This option is ignored if REGEX_MULTILINE is set.
	RegexDollarEndonly RegexCompileFlags = 0b100000
	// RegexUngreedy inverts the "greediness" of the quantifiers so that they
	// are not greedy by default, but become greedy if followed by "?". It can
	// also be set by a "(?U)" option setting within the pattern.
	RegexUngreedy RegexCompileFlags = 0b1000000000
	// RegexRaw: usually strings must be valid UTF-8 strings, using this flag
	// they are considered as a raw sequence of bytes.
	RegexRaw RegexCompileFlags = 0b100000000000
	// RegexNoAutoCapture disables the use of numbered capturing parentheses in
	// the pattern. Any opening parenthesis that is not followed by "?" behaves
	// as if it were followed by "?:" but named parentheses can still be used
	// for capturing (and they acquire numbers in the usual way).
	RegexNoAutoCapture RegexCompileFlags = 0b1000000000000
	// RegexOptimize: optimize the regular expression. If the pattern will be
	// used many times, then it may be worth the effort to optimize it to
	// improve the speed of matches.
	RegexOptimize RegexCompileFlags = 0b10000000000000
	// RegexFirstline limits an unanchored pattern to match before (or at) the
	// first newline. Since: 2.34.
	RegexFirstline RegexCompileFlags = 0b1000000000000000000
	// RegexDupnames names used to identify capturing subpatterns need not be
	// unique. This can be helpful for certain types of pattern when it is known
	// that only one instance of the named subpattern can ever be matched.
	RegexDupnames RegexCompileFlags = 0b10000000000000000000
	// RegexNewlineCr: usually any newline character or character sequence is
	// recognized. If this option is set, the only recognized newline character
	// is '\r'.
	RegexNewlineCr RegexCompileFlags = 0b100000000000000000000
	// RegexNewlineLf: usually any newline character or character sequence is
	// recognized. If this option is set, the only recognized newline character
	// is '\n'.
	RegexNewlineLf RegexCompileFlags = 0b1000000000000000000000
	// RegexNewlineCrlf: usually any newline character or character sequence is
	// recognized. If this option is set, the only recognized newline character
	// sequence is '\r\n'.
	RegexNewlineCrlf RegexCompileFlags = 0b1100000000000000000000
	// RegexNewlineAnycrlf: usually any newline character or character sequence
	// is recognized. If this option is set, the only recognized newline
	// character sequences are '\r', '\n', and '\r\n'. Since: 2.34.
	RegexNewlineAnycrlf RegexCompileFlags = 0b10100000000000000000000
	// RegexBsrAnycrlf: usually any newline character or character sequence is
	// recognised. If this option is set, then "\R" only recognizes the newline
	// characters '\r', '\n' and '\r\n'. Since: 2.34.
	RegexBsrAnycrlf RegexCompileFlags = 0b100000000000000000000000
	// RegexJavascriptCompat changes behaviour so that it is compatible with
	// JavaScript rather than PCRE. Since: 2.34.
	RegexJavascriptCompat RegexCompileFlags = 0b10000000000000000000000000
)

// String returns the names in string for RegexCompileFlags.
func (r RegexCompileFlags) String() string {
	if r == 0 {
		return "RegexCompileFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RegexCaseless:
			builder.WriteString("Caseless|")
		case RegexMultiline:
			builder.WriteString("Multiline|")
		case RegexDotall:
			builder.WriteString("Dotall|")
		case RegexExtended:
			builder.WriteString("Extended|")
		case RegexAnchored:
			builder.WriteString("Anchored|")
		case RegexDollarEndonly:
			builder.WriteString("DollarEndonly|")
		case RegexUngreedy:
			builder.WriteString("Ungreedy|")
		case RegexRaw:
			builder.WriteString("Raw|")
		case RegexNoAutoCapture:
			builder.WriteString("NoAutoCapture|")
		case RegexOptimize:
			builder.WriteString("Optimize|")
		case RegexFirstline:
			builder.WriteString("Firstline|")
		case RegexDupnames:
			builder.WriteString("Dupnames|")
		case RegexNewlineCr:
			builder.WriteString("NewlineCr|")
		case RegexNewlineLf:
			builder.WriteString("NewlineLf|")
		case RegexNewlineCrlf:
			builder.WriteString("NewlineCrlf|")
		case RegexNewlineAnycrlf:
			builder.WriteString("NewlineAnycrlf|")
		case RegexBsrAnycrlf:
			builder.WriteString("BsrAnycrlf|")
		case RegexJavascriptCompat:
			builder.WriteString("JavascriptCompat|")
		default:
			builder.WriteString(fmt.Sprintf("RegexCompileFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RegexCompileFlags) Has(other RegexCompileFlags) bool {
	return (r & other) == other
}

// RegexMatchFlags flags specifying match-time options.
type RegexMatchFlags C.guint

const (
	// RegexMatchAnchored: pattern is forced to be "anchored", that is, it is
	// constrained to match only at the first matching point in the string that
	// is being searched. This effect can also be achieved by appropriate
	// constructs in the pattern itself such as the "^" metacharacter.
	RegexMatchAnchored RegexMatchFlags = 0b10000
	// RegexMatchNotbol specifies that first character of the string is not the
	// beginning of a line, so the circumflex metacharacter should not match
	// before it. Setting this without REGEX_MULTILINE (at compile time) causes
	// circumflex never to match. This option affects only the behaviour of the
	// circumflex metacharacter, it does not affect "\A".
	RegexMatchNotbol RegexMatchFlags = 0b10000000
	// RegexMatchNoteol specifies that the end of the subject string is not the
	// end of a line, so the dollar metacharacter should not match it nor
	// (except in multiline mode) a newline immediately before it. Setting this
	// without REGEX_MULTILINE (at compile time) causes dollar never to match.
	// This option affects only the behaviour of the dollar metacharacter, it
	// does not affect "\Z" or "\z".
	RegexMatchNoteol RegexMatchFlags = 0b100000000
	// RegexMatchNotempty: empty string is not considered to be a valid match if
	// this option is set. If there are alternatives in the pattern, they are
	// tried. If all the alternatives match the empty string, the entire match
	// fails. For example, if the pattern "a?b?" is applied to a string not
	// beginning with "a" or "b", it matches the empty string at the start of
	// the string. With this flag set, this match is not valid, so GRegex
	// searches further into the string for occurrences of "a" or "b".
	RegexMatchNotempty RegexMatchFlags = 0b10000000000
	// RegexMatchPartial turns on the partial matching feature, for more
	// documentation on partial matching see g_match_info_is_partial_match().
	RegexMatchPartial RegexMatchFlags = 0b1000000000000000
	// RegexMatchNewlineCr overrides the newline definition set when creating a
	// new #GRegex, setting the '\r' character as line terminator.
	RegexMatchNewlineCr RegexMatchFlags = 0b100000000000000000000
	// RegexMatchNewlineLf overrides the newline definition set when creating a
	// new #GRegex, setting the '\n' character as line terminator.
	RegexMatchNewlineLf RegexMatchFlags = 0b1000000000000000000000
	// RegexMatchNewlineCrlf overrides the newline definition set when creating
	// a new #GRegex, setting the '\r\n' characters sequence as line terminator.
	RegexMatchNewlineCrlf RegexMatchFlags = 0b1100000000000000000000
	// RegexMatchNewlineAny overrides the newline definition set when creating a
	// new #GRegex, any Unicode newline sequence is recognised as a newline.
	// These are '\r', '\n' and '\rn', and the single characters U+000B LINE
	// TABULATION, U+000C FORM FEED (FF), U+0085 NEXT LINE (NEL), U+2028 LINE
	// SEPARATOR and U+2029 PARAGRAPH SEPARATOR.
	RegexMatchNewlineAny RegexMatchFlags = 0b10000000000000000000000
	// RegexMatchNewlineAnycrlf overrides the newline definition set when
	// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence is
	// recognized as a newline. Since: 2.34.
	RegexMatchNewlineAnycrlf RegexMatchFlags = 0b10100000000000000000000
	// RegexMatchBsrAnycrlf overrides the newline definition for "\R" set when
	// creating a new #GRegex; only '\r', '\n', or '\r\n' character sequences
	// are recognized as a newline by "\R". Since: 2.34.
	RegexMatchBsrAnycrlf RegexMatchFlags = 0b100000000000000000000000
	// RegexMatchBsrAny overrides the newline definition for "\R" set when
	// creating a new #GRegex; any Unicode newline character or character
	// sequence are recognized as a newline by "\R". These are '\r', '\n' and
	// '\rn', and the single characters U+000B LINE TABULATION, U+000C FORM FEED
	// (FF), U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and U+2029 PARAGRAPH
	// SEPARATOR. Since: 2.34.
	RegexMatchBsrAny RegexMatchFlags = 0b1000000000000000000000000
	// RegexMatchPartialSoft alias for REGEX_MATCH_PARTIAL. Since: 2.34.
	RegexMatchPartialSoft RegexMatchFlags = 0b1000000000000000
	// RegexMatchPartialHard turns on the partial matching feature. In contrast
	// to to REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial
	// match is found, without continuing to search for a possible complete
	// match. See g_match_info_is_partial_match() for more information. Since:
	// 2.34.
	RegexMatchPartialHard RegexMatchFlags = 0b1000000000000000000000000000
	// RegexMatchNotemptyAtstart: like REGEX_MATCH_NOTEMPTY, but only applied to
	// the start of the matched string. For anchored patterns this can only
	// happen for pattern containing "\K". Since: 2.34.
	RegexMatchNotemptyAtstart RegexMatchFlags = 0b10000000000000000000000000000
)

// String returns the names in string for RegexMatchFlags.
func (r RegexMatchFlags) String() string {
	if r == 0 {
		return "RegexMatchFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for r != 0 {
		next := r & (r - 1)
		bit := r - next

		switch bit {
		case RegexMatchAnchored:
			builder.WriteString("Anchored|")
		case RegexMatchNotbol:
			builder.WriteString("Notbol|")
		case RegexMatchNoteol:
			builder.WriteString("Noteol|")
		case RegexMatchNotempty:
			builder.WriteString("Notempty|")
		case RegexMatchPartial:
			builder.WriteString("Partial|")
		case RegexMatchNewlineCr:
			builder.WriteString("NewlineCr|")
		case RegexMatchNewlineLf:
			builder.WriteString("NewlineLf|")
		case RegexMatchNewlineCrlf:
			builder.WriteString("NewlineCrlf|")
		case RegexMatchNewlineAny:
			builder.WriteString("NewlineAny|")
		case RegexMatchNewlineAnycrlf:
			builder.WriteString("NewlineAnycrlf|")
		case RegexMatchBsrAnycrlf:
			builder.WriteString("BsrAnycrlf|")
		case RegexMatchBsrAny:
			builder.WriteString("BsrAny|")
		case RegexMatchPartialHard:
			builder.WriteString("PartialHard|")
		case RegexMatchNotemptyAtstart:
			builder.WriteString("NotemptyAtstart|")
		default:
			builder.WriteString(fmt.Sprintf("RegexMatchFlags(0b%b)|", bit))
		}

		r = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if r contains other.
func (r RegexMatchFlags) Has(other RegexMatchFlags) bool {
	return (r & other) == other
}

// MatchInfo is an opaque struct used to return information about matches.
//
// An instance of this type is always passed by reference.
type MatchInfo struct {
	*matchInfo
}

// matchInfo is the struct that's finalized.
type matchInfo struct {
	native *C.GMatchInfo
}

func marshalMatchInfo(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &MatchInfo{&matchInfo{(*C.GMatchInfo)(b)}}, nil
}

// ExpandReferences returns a new string containing the text in string_to_expand
// with references and escape sequences expanded. References refer to the last
// match done with string against regex and have the same syntax used by
// g_regex_replace().
//
// The string_to_expand must be UTF-8 encoded even if REGEX_RAW was passed to
// g_regex_new().
//
// The backreferences are extracted from the string passed to the match
// function, so you cannot call this function after freeing the string.
//
// match_info may be NULL in which case string_to_expand must not contain
// references. For instance "foo\n" does not refer to an actual pattern and '\n'
// merely will be replaced with \n character, while to expand "\0" (whole match)
// one needs the result of a match. Use g_regex_check_replacement() to find out
// whether string_to_expand contains references.
//
// The function takes the following parameters:
//
//    - stringToExpand: string to expand.
//
// The function returns the following values:
//
//    - utf8 (optional): expanded string, or NULL if an error occurred.
//
func (matchInfo *MatchInfo) ExpandReferences(stringToExpand string) (string, error) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in
	var _cerr *C.GError     // in

	if matchInfo != nil {
		_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(stringToExpand)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_expand_references(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(stringToExpand)

	var _utf8 string // out
	var _goerr error // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// Fetch retrieves the text matching the match_num'th capturing parentheses. 0
// is the full text of the match, 1 is the first paren set, 2 the second, and so
// on.
//
// If match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then an empty string is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not
// that of a set of parentheses but that of a matched substring. Substrings are
// matched in reverse order of length, so 0 is the longest match.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
//
// The function takes the following parameters:
//
//    - matchNum: number of the sub expression.
//
// The function returns the following values:
//
//    - utf8 (optional): matched substring, or NULL if an error occurred. You
//      have to free the string yourself.
//
func (matchInfo *MatchInfo) Fetch(matchNum int) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch(_arg0, _arg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// FetchAll bundles up pointers to each of the matching substrings from a match
// and stores them in an array of gchar pointers. The first element in the
// returned array is the match number 0, i.e. the entire matched text.
//
// If a sub pattern didn't match anything (e.g. sub pattern 1, matching "b"
// against "(a)?b") then an empty string is inserted.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are
// not that matched by sets of parentheses but that of the matched substring.
// Substrings are matched in reverse order of length, so the first one is the
// longest match.
//
// The strings are fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated array of gchar * pointers. It must be freed using
//      g_strfreev(). If the previous match failed NULL is returned.
//
func (matchInfo *MatchInfo) FetchAll() []string {
	var _arg0 *C.GMatchInfo // out
	var _cret **C.gchar     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_fetch_all(_arg0)
	runtime.KeepAlive(matchInfo)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// FetchNamed retrieves the text matching the capturing parentheses named name.
//
// If name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then an empty string is
// returned.
//
// The string is fetched from the string passed to the match function, so you
// cannot call this function after freeing the string.
//
// The function takes the following parameters:
//
//    - name of the subexpression.
//
// The function returns the following values:
//
//    - utf8 (optional): matched substring, or NULL if an error occurred. You
//      have to free the string yourself.
//
func (matchInfo *MatchInfo) FetchNamed(name string) string {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named(_arg0, _arg1)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// FetchNamedPos retrieves the position in bytes of the capturing parentheses
// named name.
//
// If name is a valid sub pattern name but it didn't match anything (e.g. sub
// pattern "X", matching "b" against "(?P<X>a)?b") then start_pos and end_pos
// are set to -1 and TRUE is returned.
//
// The function takes the following parameters:
//
//    - name of the subexpression.
//
// The function returns the following values:
//
//    - startPos (optional): pointer to location where to store the start
//      position, or NULL.
//    - endPos (optional): pointer to location where to store the end position,
//      or NULL.
//    - ok: TRUE if the position was fetched, FALSE otherwise. If the position
//      cannot be fetched, start_pos and end_pos are left unchanged.
//
func (matchInfo *MatchInfo) FetchNamedPos(name string) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_match_info_fetch_named_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(name)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// FetchPos retrieves the position in bytes of the match_num'th capturing
// parentheses. 0 is the full text of the match, 1 is the first paren set, 2 the
// second, and so on.
//
// If match_num is a valid sub pattern but it didn't match anything (e.g. sub
// pattern 1, matching "b" against "(a)?b") then start_pos and end_pos are set
// to -1 and TRUE is returned.
//
// If the match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved position is
// not that of a set of parentheses but that of a matched substring. Substrings
// are matched in reverse order of length, so 0 is the longest match.
//
// The function takes the following parameters:
//
//    - matchNum: number of the sub expression.
//
// The function returns the following values:
//
//    - startPos (optional): pointer to location where to store the start
//      position, or NULL.
//    - endPos (optional): pointer to location where to store the end position,
//      or NULL.
//    - ok: TRUE if the position was fetched, FALSE otherwise. If the position
//      cannot be fetched, start_pos and end_pos are left unchanged.
//
func (matchInfo *MatchInfo) FetchPos(matchNum int) (startPos int, endPos int, ok bool) {
	var _arg0 *C.GMatchInfo // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // in
	var _arg3 C.gint        // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))
	_arg1 = C.gint(matchNum)

	_cret = C.g_match_info_fetch_pos(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(matchInfo)
	runtime.KeepAlive(matchNum)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg2)
	_endPos = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// MatchCount retrieves the number of matched substrings (including substring 0,
// that is the whole matched text), so 1 is returned if the pattern has no
// substrings in it and 0 is returned if the match failed.
//
// If the last match was obtained using the DFA algorithm, that is using
// g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not
// that of the number of capturing parentheses but that of the number of matched
// substrings.
//
// The function returns the following values:
//
//    - gint: number of matched substrings, or -1 if an error occurred.
//
func (matchInfo *MatchInfo) MatchCount() int {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gint        // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_match_count(_arg0)
	runtime.KeepAlive(matchInfo)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Regex returns #GRegex object used in match_info. It belongs to Glib and must
// not be freed. Use g_regex_ref() if you need to keep it after you free
// match_info object.
//
// The function returns the following values:
//
//    - regex object used in match_info.
//
func (matchInfo *MatchInfo) Regex() *Regex {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.GRegex     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_regex(_arg0)
	runtime.KeepAlive(matchInfo)

	var _regex *Regex // out

	_regex = (*Regex)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_regex)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_regex_unref((*C.GRegex)(intern.C))
		},
	)

	return _regex
}

// String returns the string searched with match_info. This is the string passed
// to g_regex_match() or g_regex_replace() so you may not free it before calling
// this function.
//
// The function returns the following values:
//
//    - utf8: string searched with match_info.
//
func (matchInfo *MatchInfo) String() string {
	var _arg0 *C.GMatchInfo // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_get_string(_arg0)
	runtime.KeepAlive(matchInfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsPartialMatch: usually if the string passed to g_regex_match*() matches as
// far as it goes, but is too short to match the entire pattern, FALSE is
// returned. There are circumstances where it might be helpful to distinguish
// this case from other cases in which there is no match.
//
// Consider, for example, an application where a human is required to type in
// data for a field with specific formatting requirements. An example might be a
// date in the form ddmmmyy, defined by the pattern
// "^\d?\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\d\d$". If the
// application sees the user’s keystrokes one by one, and can check that what
// has been typed so far is potentially valid, it is able to raise an error as
// soon as a mistake is made.
//
// GRegex supports the concept of partial matching by means of the
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD flags. When they are
// used, the return code for g_regex_match() or g_regex_match_full() is, as
// usual, TRUE for a complete match, FALSE otherwise. But, when these functions
// return FALSE, you can check if the match was partial calling
// g_match_info_is_partial_match().
//
// The difference between REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD
// is that when a partial match is encountered with REGEX_MATCH_PARTIAL_SOFT,
// matching continues to search for a possible complete match, while with
// REGEX_MATCH_PARTIAL_HARD matching stops at the partial match. When both
// REGEX_MATCH_PARTIAL_SOFT and REGEX_MATCH_PARTIAL_HARD are set, the latter
// takes precedence.
//
// There were formerly some restrictions on the pattern for partial matching.
// The restrictions no longer apply.
//
// See pcrepartial(3) for more information on partial matching.
//
// The function returns the following values:
//
//    - ok: TRUE if the match was partial, FALSE otherwise.
//
func (matchInfo *MatchInfo) IsPartialMatch() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_is_partial_match(_arg0)
	runtime.KeepAlive(matchInfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches returns whether the previous match operation succeeded.
//
// The function returns the following values:
//
//    - ok: TRUE if the previous match operation succeeded, FALSE otherwise.
//
func (matchInfo *MatchInfo) Matches() bool {
	var _arg0 *C.GMatchInfo // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	_cret = C.g_match_info_matches(_arg0)
	runtime.KeepAlive(matchInfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next scans for the next match using the same parameters of the previous call
// to g_regex_match_full() or g_regex_match() that returned match_info.
//
// The match is done on the string passed to the match function, so you cannot
// free it before calling this function.
func (matchInfo *MatchInfo) Next() error {
	var _arg0 *C.GMatchInfo // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GMatchInfo)(gextras.StructNative(unsafe.Pointer(matchInfo)))

	C.g_match_info_next(_arg0, &_cerr)
	runtime.KeepAlive(matchInfo)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Regex: g_regex_*() functions implement regular expression pattern matching
// using syntax and semantics similar to Perl regular expression.
//
// Some functions accept a start_position argument, setting it differs from just
// passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of
// a pattern that begins with any kind of lookbehind assertion. For example,
// consider the pattern "\Biss\B" which finds occurrences of "iss" in the middle
// of words. ("\B" matches only if the current position in the subject is not a
// word boundary.) When applied to the string "Mississipi" from the fourth byte,
// namely "issipi", it does not match, because "\B" is always false at the start
// of the subject, which is deemed to be a word boundary. However, if the entire
// string is passed , but with start_position set to 4, it finds the second
// occurrence of "iss" because it is able to look behind the starting point to
// discover that it is preceded by a letter.
//
// Note that, unless you set the REGEX_RAW flag, all the strings passed to these
// functions must be encoded in UTF-8. The lengths and the positions inside the
// strings are in bytes and not in characters, so, for instance, "\xc3\xa0"
// (i.e. "à") is two bytes long but it is treated as a single character. If you
// set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is
// treated as a character, so "\xc3\xa0" is two bytes and two characters long.
//
// When matching a pattern, "\n" matches only against a "\n" character in the
// string, and "\r" matches only a "\r" character. To match any newline sequence
// use "\R". This particular group matches either the two-character sequence CR
// + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"),
// VT vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage
// return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028),
// or PS (paragraph separator, U+2029).
//
// The behaviour of the dot, circumflex, and dollar metacharacters are affected
// by newline characters, the default is to recognize any newline character (the
// same characters recognized by "\R"). This can be changed with
// REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options,
// and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR,
// REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These
// settings are also relevant when compiling a pattern if REGEX_EXTENDED is set,
// and an unescaped "#" outside a character class is encountered. This indicates
// a comment that lasts until after the next newline.
//
// When setting the G_REGEX_JAVASCRIPT_COMPAT flag, pattern syntax and pattern
// matching is changed to be compatible with the way that regular expressions
// work in JavaScript. More precisely, a lonely ']' character in the pattern is
// a syntax error; the '\x' escape only allows 0 to 2 hexadecimal digits, and
// you must use the '\u' escape sequence with 4 hex digits to specify a unicode
// codepoint instead of '\x' or 'x{....}'. If '\x' or '\u' are not followed by
// the specified number of hex digits, they match 'x' and 'u' literally; also
// '\U' always matches 'U' instead of being an error in the pattern. Finally,
// pattern matching is modified so that back references to an unset subpattern
// group produces a match with the empty string instead of an error. See
// pcreapi(3) for more information.
//
// Creating and manipulating the same #GRegex structure from different threads
// is not a problem as #GRegex does not modify its internal state between
// creation and destruction, on the other hand Info is not threadsafe.
//
// The regular expressions low-level functionalities are obtained through the
// excellent PCRE (http://www.pcre.org/) library written by Philip Hazel.
//
// An instance of this type is always passed by reference.
type Regex struct {
	*regex
}

// regex is the struct that's finalized.
type regex struct {
	native *C.GRegex
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Regex{&regex{(*C.GRegex)(b)}}, nil
}

// NewRegex constructs a struct Regex.
func NewRegex(pattern string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) (*Regex, error) {
	var _arg1 *C.gchar             // out
	var _arg2 C.GRegexCompileFlags // out
	var _arg3 C.GRegexMatchFlags   // out
	var _cret *C.GRegex            // in
	var _cerr *C.GError            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexCompileFlags(compileOptions)
	_arg3 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_new(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var _regex *Regex // out
	var _goerr error  // out

	if _cret != nil {
		_regex = (*Regex)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_regex)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_regex_unref((*C.GRegex)(intern.C))
			},
		)
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _regex, _goerr
}

// CaptureCount returns the number of capturing subpatterns in the pattern.
//
// The function returns the following values:
//
//    - gint: number of capturing subpatterns.
//
func (regex *Regex) CaptureCount() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_capture_count(_arg0)
	runtime.KeepAlive(regex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CompileFlags returns the compile options that regex was created with.
//
// Depending on the version of PCRE that is used, this may or may not include
// flags set by option expressions such as (?i) found at the top-level within
// the compiled pattern.
//
// The function returns the following values:
//
//    - regexCompileFlags flags from CompileFlags.
//
func (regex *Regex) CompileFlags() RegexCompileFlags {
	var _arg0 *C.GRegex            // out
	var _cret C.GRegexCompileFlags // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_compile_flags(_arg0)
	runtime.KeepAlive(regex)

	var _regexCompileFlags RegexCompileFlags // out

	_regexCompileFlags = RegexCompileFlags(_cret)

	return _regexCompileFlags
}

// HasCrOrLf checks whether the pattern contains explicit CR or LF references.
//
// The function returns the following values:
//
//    - ok: TRUE if the pattern contains explicit CR or LF references.
//
func (regex *Regex) HasCrOrLf() bool {
	var _arg0 *C.GRegex  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_has_cr_or_lf(_arg0)
	runtime.KeepAlive(regex)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchFlags returns the match options that regex was created with.
//
// The function returns the following values:
//
//    - regexMatchFlags flags from MatchFlags.
//
func (regex *Regex) MatchFlags() RegexMatchFlags {
	var _arg0 *C.GRegex          // out
	var _cret C.GRegexMatchFlags // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_match_flags(_arg0)
	runtime.KeepAlive(regex)

	var _regexMatchFlags RegexMatchFlags // out

	_regexMatchFlags = RegexMatchFlags(_cret)

	return _regexMatchFlags
}

// MaxBackref returns the number of the highest back reference in the pattern,
// or 0 if the pattern does not contain back references.
//
// The function returns the following values:
//
//    - gint: number of the highest back reference.
//
func (regex *Regex) MaxBackref() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_max_backref(_arg0)
	runtime.KeepAlive(regex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MaxLookbehind gets the number of characters in the longest lookbehind
// assertion in the pattern. This information is useful when doing multi-segment
// matching using the partial matching facilities.
//
// The function returns the following values:
//
//    - gint: number of characters in the longest lookbehind assertion.
//
func (regex *Regex) MaxLookbehind() int {
	var _arg0 *C.GRegex // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_max_lookbehind(_arg0)
	runtime.KeepAlive(regex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Pattern gets the pattern string associated with regex, i.e. a copy of the
// string passed to g_regex_new().
//
// The function returns the following values:
//
//    - utf8: pattern of regex.
//
func (regex *Regex) Pattern() string {
	var _arg0 *C.GRegex // out
	var _cret *C.gchar  // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))

	_cret = C.g_regex_get_pattern(_arg0)
	runtime.KeepAlive(regex)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// StringNumber retrieves the number of the subexpression named name.
//
// The function takes the following parameters:
//
//    - name of the subexpression.
//
// The function returns the following values:
//
//    - gint: number of the subexpression or -1 if name does not exists.
//
func (regex *Regex) StringNumber(name string) int {
	var _arg0 *C.GRegex // out
	var _arg1 *C.gchar  // out
	var _cret C.gint    // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.g_regex_get_string_number(_arg0, _arg1)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(name)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Match scans for a match in string for the pattern in regex. The match_options
// are combined with the match options specified when the regex structure was
// created, letting you have more flexibility in reusing #GRegex structures.
//
// Unless G_REGEX_RAW is specified in the options, string must be valid UTF-8.
//
// A Info structure, used to get information on the match, is stored in
// match_info if not NULL. Note that if match_info is not NULL then it is
// created even if the function returns FALSE, i.e. you must free it regardless
// if regular expression actually matched.
//
// To retrieve all the non-overlapping matches of the pattern in string you can
// use g_match_info_next().
//
//    static void
//    print_uppercase_words (const gchar *string)
//    {
//      // Print all uppercase-only words.
//      GRegex *regex;
//      GMatchInfo *match_info;
//
//      regex = g_regex_new ("[A-Z]+", 0, 0, NULL);
//      g_regex_match (regex, string, 0, &match_info);
//      while (g_match_info_matches (match_info))
//        {
//          gchar *word = g_match_info_fetch (match_info, 0);
//          g_print ("Found: s\n", word);
//          g_free (word);
//          g_match_info_next (match_info, NULL);
//        }
//      g_match_info_free (match_info);
//      g_regex_unref (regex);
//    }
//
// string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying string then
// the behaviour is undefined.
//
// The function takes the following parameters:
//
//    - str: string to scan for matches.
//    - matchOptions: match options.
//
// The function returns the following values:
//
//    - matchInfo (optional): pointer to location where to store the Info, or
//      NULL if you do not need it.
//    - ok: TRUE is the string matched, FALSE otherwise.
//
func (regex *Regex) Match(str string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _arg3 *C.GMatchInfo      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var _matchInfo *MatchInfo // out
	var _ok bool              // out

	if _arg3 != nil {
		_matchInfo = (*MatchInfo)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_matchInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_match_info_unref((*C.GMatchInfo)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// MatchAll: using the standard algorithm for regular expression matching only
// the longest match in the string is retrieved. This function uses a different
// algorithm so it can retrieve all the possible matches. For more documentation
// see g_regex_match_all_full().
//
// A Info structure, used to get information on the match, is stored in
// match_info if not NULL. Note that if match_info is not NULL then it is
// created even if the function returns FALSE, i.e. you must free it regardless
// if regular expression actually matched.
//
// string is not copied and is used in Info internally. If you use any Info
// method (except g_match_info_free()) after freeing or modifying string then
// the behaviour is undefined.
//
// The function takes the following parameters:
//
//    - str: string to scan for matches.
//    - matchOptions: match options.
//
// The function returns the following values:
//
//    - matchInfo (optional): pointer to location where to store the Info, or
//      NULL if you do not need it.
//    - ok: TRUE is the string matched, FALSE otherwise.
//
func (regex *Regex) MatchAll(str string, matchOptions RegexMatchFlags) (*MatchInfo, bool) {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _arg3 *C.GMatchInfo      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match_all(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var _matchInfo *MatchInfo // out
	var _ok bool              // out

	if _arg3 != nil {
		_matchInfo = (*MatchInfo)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_matchInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_match_info_unref((*C.GMatchInfo)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _matchInfo, _ok
}

// Split breaks the string on the pattern, and returns an array of the tokens.
// If the pattern contains capturing parentheses, then the text for each of the
// substrings will also be returned. If the pattern does not match anywhere in
// the string, then the whole string is returned as the first token.
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits string into separate characters
// wherever it matches the empty string between characters. For example
// splitting "ab c" using as a separator "\s*", you will get "a", "b" and "c".
//
// The function takes the following parameters:
//
//    - str: string to split with the pattern.
//    - matchOptions: match time option flags.
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated gchar ** array. Free it using g_strfreev().
//
func (regex *Regex) Split(str string, matchOptions RegexMatchFlags) []string {
	var _arg0 *C.GRegex          // out
	var _arg1 *C.gchar           // out
	var _arg2 C.GRegexMatchFlags // out
	var _cret **C.gchar          // in

	_arg0 = (*C.GRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_split(_arg0, _arg1, _arg2)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(str)
	runtime.KeepAlive(matchOptions)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// RegexCheckReplacement checks whether replacement is a valid replacement
// string (see g_regex_replace()), i.e. that all escape sequences in it are
// valid.
//
// If has_references is not NULL then replacement is checked for pattern
// references. For instance, replacement text 'foo\n' does not contain
// references and may be evaluated without information about actual match, but
// '\0\1' (whole match followed by first subpattern) requires valid Info object.
//
// The function takes the following parameters:
//
//    - replacement string.
//
// The function returns the following values:
//
//    - hasReferences (optional): location to store information about references
//      in replacement or NULL.
//
func RegexCheckReplacement(replacement string) (bool, error) {
	var _arg1 *C.gchar   // out
	var _arg2 C.gboolean // in
	var _cerr *C.GError  // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(_arg1))

	C.g_regex_check_replacement(_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(replacement)

	var _hasReferences bool // out
	var _goerr error        // out

	if _arg2 != 0 {
		_hasReferences = true
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _hasReferences, _goerr
}

// RegexEscapeNUL escapes the nul characters in string to "\x00". It can be used
// to compile a regex with embedded nul characters.
//
// For completeness, length can be -1 for a nul-terminated string. In this case
// the output string will be of course equal to string.
//
// The function takes the following parameters:
//
//    - str: string to escape.
//    - length of string.
//
// The function returns the following values:
//
//    - utf8: newly-allocated escaped string.
//
func RegexEscapeNUL(str string, length int) string {
	var _arg1 *C.gchar // out
	var _arg2 C.gint   // out
	var _cret *C.gchar // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(length)

	_cret = C.g_regex_escape_nul(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RegexMatchSimple scans for a match in string for pattern.
//
// This function is equivalent to g_regex_match() but it does not require to
// compile the pattern with g_regex_new(), avoiding some lines of code when you
// need just to do a match without extracting substrings, capture counts, and so
// on.
//
// If this function is to be called on the same pattern more than once, it's
// more efficient to compile the pattern once with g_regex_new() and then use
// g_regex_match().
//
// The function takes the following parameters:
//
//    - pattern: regular expression.
//    - str: string to scan for matches.
//    - compileOptions: compile options for the regular expression, or 0.
//    - matchOptions: match options, or 0.
//
// The function returns the following values:
//
//    - ok: TRUE if the string matched, FALSE otherwise.
//
func RegexMatchSimple(pattern, str string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) bool {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _arg3 C.GRegexCompileFlags // out
	var _arg4 C.GRegexMatchFlags   // out
	var _cret C.gboolean           // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GRegexCompileFlags(compileOptions)
	_arg4 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_match_simple(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RegexSplitSimple breaks the string on the pattern, and returns an array of
// the tokens. If the pattern contains capturing parentheses, then the text for
// each of the substrings will also be returned. If the pattern does not match
// anywhere in the string, then the whole string is returned as the first token.
//
// This function is equivalent to g_regex_split() but it does not require to
// compile the pattern with g_regex_new(), avoiding some lines of code when you
// need just to do a split without extracting substrings, capture counts, and so
// on.
//
// If this function is to be called on the same pattern more than once, it's
// more efficient to compile the pattern once with g_regex_new() and then use
// g_regex_split().
//
// As a special case, the result of splitting the empty string "" is an empty
// vector, not a vector containing a single string. The reason for this special
// case is that being able to represent an empty vector is typically more useful
// than consistent handling of empty elements. If you do need to represent empty
// elements, you'll need to check for the empty string before calling this
// function.
//
// A pattern that can match empty strings splits string into separate characters
// wherever it matches the empty string between characters. For example
// splitting "ab c" using as a separator "\s*", you will get "a", "b" and "c".
//
// The function takes the following parameters:
//
//    - pattern: regular expression.
//    - str: string to scan for matches.
//    - compileOptions: compile options for the regular expression, or 0.
//    - matchOptions: match options, or 0.
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated array of strings. Free it using g_strfreev().
//
func RegexSplitSimple(pattern, str string, compileOptions RegexCompileFlags, matchOptions RegexMatchFlags) []string {
	var _arg1 *C.gchar             // out
	var _arg2 *C.gchar             // out
	var _arg3 C.GRegexCompileFlags // out
	var _arg4 C.GRegexMatchFlags   // out
	var _cret **C.gchar            // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GRegexCompileFlags(compileOptions)
	_arg4 = C.GRegexMatchFlags(matchOptions)

	_cret = C.g_regex_split_simple(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(str)
	runtime.KeepAlive(compileOptions)
	runtime.KeepAlive(matchOptions)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

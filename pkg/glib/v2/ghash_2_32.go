// Code generated by girgen. DO NOT EDIT.

package glib

import (
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
// #include <glib.h>
import "C"

// HashTableAdd: this is a convenience function for using a Table as a set.
// It is equivalent to calling g_hash_table_replace() with key as both the key
// and the value.
//
// In particular, this means that if key already exists in the hash table,
// then the old copy of key in the hash table is freed and key replaces it in
// the table.
//
// When a hash table only ever contains keys that have themselves as the
// corresponding value it is able to be stored more efficiently. See the
// discussion in the section description.
//
// Starting from GLib 2.40, this function returns a boolean value to indicate
// whether the newly added value was already in the hash table or not.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - key (optional) to insert.
//
// The function returns the following values:
//
//   - ok: TRUE if the key did not exist yet.
//
func HashTableAdd(hashTable map[unsafe.Pointer]unsafe.Pointer, key unsafe.Pointer) bool {
	var _arg1 *C.GHashTable // out
	var _arg2 C.gpointer    // out
	var _cret C.gboolean    // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst *C.gpointer // out
		var vdst *C.gpointer // out
		kdst = (*C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (*C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gpointer)(unsafe.Pointer(key))

	_cret = C.g_hash_table_add(_arg1, _arg2)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HashTableContains checks if key is in hash_table.
//
// The function takes the following parameters:
//
//   - hashTable: Table.
//   - key (optional) to check.
//
// The function returns the following values:
//
//   - ok: TRUE if key is in hash_table, FALSE otherwise.
//
func HashTableContains(hashTable map[unsafe.Pointer]unsafe.Pointer, key unsafe.Pointer) bool {
	var _arg1 *C.GHashTable   // out
	var _arg2 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg1 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range hashTable {
		var kdst *C.gpointer // out
		var vdst *C.gpointer // out
		kdst = (*C.gpointer)(unsafe.Pointer(ksrc))
		vdst = (*C.gpointer)(unsafe.Pointer(vsrc))
		C.g_hash_table_insert(_arg1, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg1)
	_arg2 = (C.gconstpointer)(unsafe.Pointer(key))

	_cret = C.g_hash_table_contains(_arg1, _arg2)
	runtime.KeepAlive(hashTable)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

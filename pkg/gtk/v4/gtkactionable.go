// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_ActionableInterface_set_action_name(void*, void*);
// extern void _gotk4_gtk4_ActionableInterface_set_action_target_value(void*, void*);
// extern void* _gotk4_gtk4_ActionableInterface_get_action_name(void*);
// extern void* _gotk4_gtk4_ActionableInterface_get_action_target_value(void*);
import "C"

// GTypeActionable returns the GType for the type Actionable.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeActionable() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "Actionable").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalActionable)
	return gtype
}

// ActionableOverrider contains methods that are overridable.
type ActionableOverrider interface {
	// ActionName gets the action name for actionable.
	//
	// The function returns the following values:
	//
	//    - utf8 (optional): action name, or NULL if none is set.
	//
	ActionName() string
	// ActionTargetValue gets the current target value of actionable.
	//
	// The function returns the following values:
	//
	//    - variant (optional): current target value.
	//
	ActionTargetValue() *glib.Variant
	// SetActionName specifies the name of the action with which this widget
	// should be associated.
	//
	// If action_name is NULL then the widget will be unassociated from any
	// previous action.
	//
	// Usually this function is used when the widget is located (or will be
	// located) within the hierarchy of a GtkApplicationWindow.
	//
	// Names are of the form “win.save” or “app.quit” for actions on the
	// containing GtkApplicationWindow or its associated GtkApplication,
	// respectively. This is the same form used for actions in the GMenu
	// associated with the window.
	//
	// The function takes the following parameters:
	//
	//    - actionName (optional): action name, or NULL.
	//
	SetActionName(actionName string)
	// SetActionTargetValue sets the target value of an actionable widget.
	//
	// If target_value is NULL then the target value is unset.
	//
	// The target value has two purposes. First, it is used as the parameter to
	// activation of the action associated with the GtkActionable widget.
	// Second, it is used to determine if the widget should be rendered as
	// “active” — the widget is active if the state is equal to the given
	// target.
	//
	// Consider the example of associating a set of buttons with a GAction with
	// string state in a typical “radio button” situation. Each button will be
	// associated with the same action, but with a different target value for
	// that action. Clicking on a particular button will activate the action
	// with the target of that button, which will typically cause the action’s
	// state to change to that value. Since the action’s state is now equal to
	// the target value of the button, the button will now be rendered as active
	// (and the other buttons, with different targets, rendered inactive).
	//
	// The function takes the following parameters:
	//
	//    - targetValue (optional) to set as the target value, or NULL.
	//
	SetActionTargetValue(targetValue *glib.Variant)
}

// Actionable: GtkActionable interface provides a convenient way of asscociating
// widgets with actions.
//
// It primarily consists of two properties: gtk.Actionable:action-name and
// gtk.Actionable:action-target. There are also some convenience APIs for
// setting these properties.
//
// The action will be looked up in action groups that are found among the
// widgets ancestors. Most commonly, these will be the actions with the “win.”
// or “app.” prefix that are associated with the GtkApplicationWindow or
// GtkApplication, but other action groups that are added with
// gtk.Widget.InsertActionGroup() will be consulted as well.
//
// Actionable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Actionable struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Actionable)(nil)
)

// Actionabler describes Actionable's interface methods.
type Actionabler interface {
	coreglib.Objector

	// ActionName gets the action name for actionable.
	ActionName() string
	// ActionTargetValue gets the current target value of actionable.
	ActionTargetValue() *glib.Variant
	// SetActionName specifies the name of the action with which this widget
	// should be associated.
	SetActionName(actionName string)
	// SetActionTargetValue sets the target value of an actionable widget.
	SetActionTargetValue(targetValue *glib.Variant)
	// SetDetailedActionName sets the action-name and associated string target
	// value of an actionable widget.
	SetDetailedActionName(detailedActionName string)
}

var _ Actionabler = (*Actionable)(nil)

func ifaceInitActionabler(gifacePtr, data C.gpointer) {
	iface := girepository.MustFind("Gtk", "ActionableInterface")
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_action_name"))) = unsafe.Pointer(C._gotk4_gtk4_ActionableInterface_get_action_name)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_action_target_value"))) = unsafe.Pointer(C._gotk4_gtk4_ActionableInterface_get_action_target_value)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("set_action_name"))) = unsafe.Pointer(C._gotk4_gtk4_ActionableInterface_set_action_name)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("set_action_target_value"))) = unsafe.Pointer(C._gotk4_gtk4_ActionableInterface_set_action_target_value)
}

//export _gotk4_gtk4_ActionableInterface_get_action_name
func _gotk4_gtk4_ActionableInterface_get_action_name(arg0 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(ActionableOverrider)

	utf8 := iface.ActionName()

	if utf8 != "" {
		cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))
		defer C.free(unsafe.Pointer(cret))
	}

	return cret
}

//export _gotk4_gtk4_ActionableInterface_get_action_target_value
func _gotk4_gtk4_ActionableInterface_get_action_target_value(arg0 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(ActionableOverrider)

	variant := iface.ActionTargetValue()

	if variant != nil {
		cret = (*C.void)(gextras.StructNative(unsafe.Pointer(variant)))
	}

	return cret
}

//export _gotk4_gtk4_ActionableInterface_set_action_name
func _gotk4_gtk4_ActionableInterface_set_action_name(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(ActionableOverrider)

	var _actionName string // out

	if arg1 != nil {
		_actionName = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	}

	iface.SetActionName(_actionName)
}

//export _gotk4_gtk4_ActionableInterface_set_action_target_value
func _gotk4_gtk4_ActionableInterface_set_action_target_value(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(ActionableOverrider)

	var _targetValue *glib.Variant // out

	if arg1 != nil {
		_targetValue = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		C.g_variant_ref(arg1)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_targetValue)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	iface.SetActionTargetValue(_targetValue)
}

func wrapActionable(obj *coreglib.Object) *Actionable {
	return &Actionable{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalActionable(p uintptr) (interface{}, error) {
	return wrapActionable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ActionName gets the action name for actionable.
//
// The function returns the following values:
//
//    - utf8 (optional): action name, or NULL if none is set.
//
func (actionable *Actionable) ActionName() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))

	_info := girepository.MustFind("Gtk", "Actionable")
	_gret := _info.InvokeIfaceMethod("get_action_name", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(actionable)

	var _utf8 string // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ActionTargetValue gets the current target value of actionable.
//
// The function returns the following values:
//
//    - variant (optional): current target value.
//
func (actionable *Actionable) ActionTargetValue() *glib.Variant {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))

	_info := girepository.MustFind("Gtk", "Actionable")
	_gret := _info.InvokeIfaceMethod("get_action_target_value", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(actionable)

	var _variant *glib.Variant // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_variant_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _variant
}

// SetActionName specifies the name of the action with which this widget should
// be associated.
//
// If action_name is NULL then the widget will be unassociated from any previous
// action.
//
// Usually this function is used when the widget is located (or will be located)
// within the hierarchy of a GtkApplicationWindow.
//
// Names are of the form “win.save” or “app.quit” for actions on the containing
// GtkApplicationWindow or its associated GtkApplication, respectively. This is
// the same form used for actions in the GMenu associated with the window.
//
// The function takes the following parameters:
//
//    - actionName (optional): action name, or NULL.
//
func (actionable *Actionable) SetActionName(actionName string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))
	if actionName != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(actionName)))
		defer C.free(unsafe.Pointer(_args[1]))
	}

	_info := girepository.MustFind("Gtk", "Actionable")
	_info.InvokeIfaceMethod("set_action_name", _args[:], nil)

	runtime.KeepAlive(actionable)
	runtime.KeepAlive(actionName)
}

// SetActionTargetValue sets the target value of an actionable widget.
//
// If target_value is NULL then the target value is unset.
//
// The target value has two purposes. First, it is used as the parameter to
// activation of the action associated with the GtkActionable widget. Second, it
// is used to determine if the widget should be rendered as “active” — the
// widget is active if the state is equal to the given target.
//
// Consider the example of associating a set of buttons with a GAction with
// string state in a typical “radio button” situation. Each button will be
// associated with the same action, but with a different target value for that
// action. Clicking on a particular button will activate the action with the
// target of that button, which will typically cause the action’s state to
// change to that value. Since the action’s state is now equal to the target
// value of the button, the button will now be rendered as active (and the other
// buttons, with different targets, rendered inactive).
//
// The function takes the following parameters:
//
//    - targetValue (optional) to set as the target value, or NULL.
//
func (actionable *Actionable) SetActionTargetValue(targetValue *glib.Variant) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))
	if targetValue != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(targetValue)))
	}

	_info := girepository.MustFind("Gtk", "Actionable")
	_info.InvokeIfaceMethod("set_action_target_value", _args[:], nil)

	runtime.KeepAlive(actionable)
	runtime.KeepAlive(targetValue)
}

// SetDetailedActionName sets the action-name and associated string target value
// of an actionable widget.
//
// detailed_action_name is a string in the format accepted by
// g_action_parse_detailed_name().
//
// The function takes the following parameters:
//
//    - detailedActionName: detailed action name.
//
func (actionable *Actionable) SetDetailedActionName(detailedActionName string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(detailedActionName)))
	defer C.free(unsafe.Pointer(_args[1]))

	_info := girepository.MustFind("Gtk", "Actionable")
	_info.InvokeIfaceMethod("set_detailed_action_name", _args[:], nil)

	runtime.KeepAlive(actionable)
	runtime.KeepAlive(detailedActionName)
}

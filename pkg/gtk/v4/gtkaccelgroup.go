// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// AcceleratorParse parses a string representing an accelerator.
//
// The format looks like “<Control>a” or “<Shift><Alt>F1”.
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk.KeyvalFromName(). For character keys the name is not the symbol, but the
// lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
//
// If the parse fails, accelerator_key and accelerator_mods will be set to 0
// (zero).
//
// The function takes the following parameters:
//
//    - accelerator: string representing an accelerator.
//
// The function returns the following values:
//
//    - acceleratorKey (optional): return location for accelerator keyval, or
//      NULL.
//    - acceleratorMods (optional): return location for accelerator modifier
//      mask, NULL.
//    - ok
//
func AcceleratorParse(accelerator string) (uint32, gdk.ModifierType, bool) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gtk", "accelerator_parse")
	_gret := _info.InvokeFunction(_args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accelerator)

	var _acceleratorKey uint32            // out
	var _acceleratorMods gdk.ModifierType // out
	var _ok bool                          // out

	_acceleratorKey = uint32(*(*C.guint)(unsafe.Pointer(&_outs[0])))
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_acceleratorMods = *(*gdk.ModifierType)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[1]))))
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _acceleratorKey, _acceleratorMods, _ok
}

// AcceleratorParseWithKeycode parses a string representing an accelerator.
//
// This is similar to gtk.AcceleratorParse() but handles keycodes as well. This
// is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If accelerator_codes is given and the result stored in it is non-NULL, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no accelerator_codes is given,
// the parse will fail.
//
// If the parse fails, accelerator_key, accelerator_mods and accelerator_codes
// will be set to 0 (zero).
//
// The function takes the following parameters:
//
//    - accelerator: string representing an accelerator.
//    - display (optional) to look up accelerator_codes in.
//
// The function returns the following values:
//
//    - acceleratorKey (optional): return location for accelerator keyval, or
//      NULL.
//    - acceleratorCodes (optional): return location for accelerator keycodes, or
//      NULL.
//    - acceleratorMods (optional): return location for accelerator modifier
//      mask, NULL.
//    - ok: TRUE if parsing succeeded.
//
func AcceleratorParseWithKeycode(accelerator string, display *gdk.Display) (uint32, []uint32, gdk.ModifierType, bool) {
	var _args [2]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.char)(unsafe.Pointer(&_args[0])) = (*C.char)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[0]))))
	if display != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	}

	_info := girepository.MustFind("Gtk", "accelerator_parse_with_keycode")
	_gret := _info.InvokeFunction(_args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accelerator)
	runtime.KeepAlive(display)

	var _acceleratorKey uint32            // out
	var _acceleratorCodes []uint32        // out
	var _acceleratorMods gdk.ModifierType // out
	var _ok bool                          // out

	_acceleratorKey = uint32(*(*C.guint)(unsafe.Pointer(&_outs[0])))
	if *(**C.guint)(unsafe.Pointer(&_outs[1])) != nil {
		defer C.free(unsafe.Pointer(*(**C.guint)(unsafe.Pointer(&_outs[1]))))
		{
			var i int
			var z C.guint
			for p := *(**C.guint)(unsafe.Pointer(&_outs[1])); *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(*(**C.guint)(unsafe.Pointer(&_outs[1])), i)
			_acceleratorCodes = make([]uint32, i)
			for i := range src {
				_acceleratorCodes[i] = uint32(*(*C.guint)(unsafe.Pointer(&src[i])))
			}
		}
	}
	if *(**C.void)(unsafe.Pointer(&_outs[2])) != nil {
		_acceleratorMods = *(*gdk.ModifierType)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[2]))))
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _acceleratorKey, _acceleratorCodes, _acceleratorMods, _ok
}

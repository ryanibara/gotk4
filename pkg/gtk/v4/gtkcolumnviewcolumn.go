// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeColumnViewColumn returns the GType for the type ColumnViewColumn.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeColumnViewColumn() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "ColumnViewColumn").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalColumnViewColumn)
	return gtype
}

// ColumnViewColumn: GtkColumnViewColumn represents the columns being added to
// GtkColumnView.
//
// The main ingredient for a GtkColumnViewColumn is the GtkListItemFactory that
// tells the columnview how to create cells for this column from items in the
// model.
//
// Columns have a title, and can optionally have a header menu set with
// gtk.ColumnViewColumn.SetHeaderMenu().
//
// A sorter can be associated with a column using
// gtk.ColumnViewColumn.SetSorter(), to let users influence sorting by clicking
// on the column header.
type ColumnViewColumn struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ColumnViewColumn)(nil)
)

func wrapColumnViewColumn(obj *coreglib.Object) *ColumnViewColumn {
	return &ColumnViewColumn{
		Object: obj,
	}
}

func marshalColumnViewColumn(p uintptr) (interface{}, error) {
	return wrapColumnViewColumn(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewColumnViewColumn creates a new GtkColumnViewColumn that uses the given
// factory for mapping items to widgets.
//
// You most likely want to call gtk.ColumnView.AppendColumn() next.
//
// The function takes ownership of the argument, so you can write code like:
//
//    column = gtk_column_view_column_new (_("Name"),
//      gtk_builder_list_item_factory_new_from_resource ("/name.ui"));.
//
// The function takes the following parameters:
//
//    - title (optional): title to use for this column.
//    - factory (optional) to populate items with.
//
// The function returns the following values:
//
//    - columnViewColumn: new GtkColumnViewColumn using the given factory.
//
func NewColumnViewColumn(title string, factory *ListItemFactory) *ColumnViewColumn {
	var _args [2]girepository.Argument

	if title != "" {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_args[0]))
	}
	if factory != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(factory).Native()))
	}

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("new_ColumnViewColumn", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(title)
	runtime.KeepAlive(factory)

	var _columnViewColumn *ColumnViewColumn // out

	_columnViewColumn = wrapColumnViewColumn(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _columnViewColumn
}

// ColumnView gets the column view that's currently displaying this column.
//
// If self has not been added to a column view yet, NULL is returned.
//
// The function returns the following values:
//
//    - columnView (optional): column view displaying self.
//
func (self *ColumnViewColumn) ColumnView() *ColumnView {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_column_view", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _columnView *ColumnView // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_columnView = wrapColumnView(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _columnView
}

// Expand returns whether this column should expand.
//
// The function returns the following values:
//
//    - ok: TRUE if this column expands.
//
func (self *ColumnViewColumn) Expand() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_expand", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Factory gets the factory that's currently used to populate list items for
// this column.
//
// The function returns the following values:
//
//    - listItemFactory (optional): factory in use.
//
func (self *ColumnViewColumn) Factory() *ListItemFactory {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_factory", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _listItemFactory *ListItemFactory // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_listItemFactory = wrapListItemFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listItemFactory
}

// FixedWidth gets the fixed width of the column.
//
// The function returns the following values:
//
//    - gint: fixed with of the column.
//
func (self *ColumnViewColumn) FixedWidth() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_fixed_width", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// HeaderMenu gets the menu model that is used to create the context menu for
// the column header.
//
// The function returns the following values:
//
//    - menuModel (optional) or NULL.
//
func (self *ColumnViewColumn) HeaderMenu() gio.MenuModeller {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_header_menu", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _menuModel gio.MenuModeller // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// Resizable returns whether this column is resizable.
//
// The function returns the following values:
//
//    - ok: TRUE if this column is resizable.
//
func (self *ColumnViewColumn) Resizable() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_resizable", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Sorter returns the sorter that is associated with the column.
//
// The function returns the following values:
//
//    - sorter (optional): GtkSorter of self.
//
func (self *ColumnViewColumn) Sorter() *Sorter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_sorter", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _sorter *Sorter // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_sorter = wrapSorter(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sorter
}

// Title returns the title set with gtk_column_view_column_set_title().
//
// The function returns the following values:
//
//    - utf8 (optional) column's title.
//
func (self *ColumnViewColumn) Title() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_title", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _utf8 string // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Visible returns whether this column is visible.
//
// The function returns the following values:
//
//    - ok: TRUE if this column is visible.
//
func (self *ColumnViewColumn) Visible() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("get_visible", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SetExpand sets the column to take available extra space.
//
// The extra space is shared equally amongst all columns that have the expand
// set to TRUE.
//
// The function takes the following parameters:
//
//    - expand: TRUE if this column should expand to fill available sace.
//
func (self *ColumnViewColumn) SetExpand(expand bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expand {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("set_expand", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(expand)
}

// SetFactory sets the GtkListItemFactory to use for populating list items for
// this column.
//
// The function takes the following parameters:
//
//    - factory (optional) to use or NULL for none.
//
func (self *ColumnViewColumn) SetFactory(factory *ListItemFactory) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if factory != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	}

	girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("set_factory", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetFixedWidth: if fixed_width is not -1, sets the fixed width of column;
// otherwise unsets it.
//
// Setting a fixed width overrides the automatically calculated width.
// Interactive resizing also sets the “fixed-width” property.
//
// The function takes the following parameters:
//
//    - fixedWidth: new fixed width, or -1.
//
func (self *ColumnViewColumn) SetFixedWidth(fixedWidth int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(fixedWidth)

	girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("set_fixed_width", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(fixedWidth)
}

// SetHeaderMenu sets the menu model that is used to create the context menu for
// the column header.
//
// The function takes the following parameters:
//
//    - menu (optional): GMenuModel, or NULL.
//
func (self *ColumnViewColumn) SetHeaderMenu(menu gio.MenuModeller) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if menu != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	}

	girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("set_header_menu", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(menu)
}

// SetResizable sets whether this column should be resizable by dragging.
//
// The function takes the following parameters:
//
//    - resizable: whether this column should be resizable.
//
func (self *ColumnViewColumn) SetResizable(resizable bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if resizable {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("set_resizable", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(resizable)
}

// SetSorter associates a sorter with the column.
//
// If sorter is NULL, the column will not let users change the sorting by
// clicking on its header.
//
// This sorter can be made active by clicking on the column header, or by
// calling gtk.ColumnView.SortByColumn().
//
// See gtk.ColumnView.GetSorter() for the necessary steps for setting up
// customizable sorting for gtk.ColumnView.
//
// The function takes the following parameters:
//
//    - sorter (optional): GtkSorter to associate with column.
//
func (self *ColumnViewColumn) SetSorter(sorter *Sorter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if sorter != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(sorter).Native()))
	}

	girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("set_sorter", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(sorter)
}

// SetTitle sets the title of this column.
//
// The title is displayed in the header of a GtkColumnView for this column and
// is therefore user-facing text that should be translated.
//
// The function takes the following parameters:
//
//    - title (optional): title to use for this column.
//
func (self *ColumnViewColumn) SetTitle(title string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if title != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_args[1]))
	}

	girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("set_title", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(title)
}

// SetVisible sets whether this column should be visible in views.
//
// The function takes the following parameters:
//
//    - visible: whether this column should be visible.
//
func (self *ColumnViewColumn) SetVisible(visible bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if visible {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "ColumnViewColumn").InvokeMethod("set_visible", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(visible)
}

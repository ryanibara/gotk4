// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk4_CellRendererClass_editing_canceled(void*);
// extern void _gotk4_gtk4_CellRendererClass_editing_started(void*, void*, void*);
// extern void _gotk4_gtk4_CellRendererClass_get_preferred_height(void*, void*, void*, void*);
// extern void _gotk4_gtk4_CellRendererClass_get_preferred_height_for_width(void*, void*, int, void*, void*);
// extern void _gotk4_gtk4_CellRendererClass_get_preferred_width(void*, void*, void*, void*);
// extern void _gotk4_gtk4_CellRendererClass_get_preferred_width_for_height(void*, void*, int, void*, void*);
// extern void _gotk4_gtk4_CellRenderer_ConnectEditingCanceled(gpointer, guintptr);
// extern void _gotk4_gtk4_CellRenderer_ConnectEditingStarted(gpointer, void*, void*, guintptr);
import "C"

// GTypeCellRendererMode returns the GType for the type CellRendererMode.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeCellRendererMode() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "CellRendererMode").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalCellRendererMode)
	return gtype
}

// GTypeCellRendererState returns the GType for the type CellRendererState.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeCellRendererState() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "CellRendererState").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalCellRendererState)
	return gtype
}

// GTypeCellRenderer returns the GType for the type CellRenderer.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeCellRenderer() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "CellRenderer").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalCellRenderer)
	return gtype
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode C.gint

const (
	// CellRendererModeInert: cell is just for display and cannot be interacted
	// with. Note that this doesn’t mean that eg. the row being drawn can’t be
	// selected -- just that a particular element of it cannot be individually
	// modified.
	CellRendererModeInert CellRendererMode = iota
	// CellRendererModeActivatable: cell can be clicked.
	CellRendererModeActivatable
	// CellRendererModeEditable: cell can be edited or otherwise modified.
	CellRendererModeEditable
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CellRendererMode.
func (c CellRendererMode) String() string {
	switch c {
	case CellRendererModeInert:
		return "Inert"
	case CellRendererModeActivatable:
		return "Activatable"
	case CellRendererModeEditable:
		return "Editable"
	default:
		return fmt.Sprintf("CellRendererMode(%d)", c)
	}
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState C.guint

const (
	// CellRendererSelected: cell is currently selected, and probably has a
	// selection colored background to render to.
	CellRendererSelected CellRendererState = 0b1
	// CellRendererPrelit: mouse is hovering over the cell.
	CellRendererPrelit CellRendererState = 0b10
	// CellRendererInsensitive: cell is drawn in an insensitive manner.
	CellRendererInsensitive CellRendererState = 0b100
	// CellRendererSorted: cell is in a sorted row.
	CellRendererSorted CellRendererState = 0b1000
	// CellRendererFocused: cell is in the focus row.
	CellRendererFocused CellRendererState = 0b10000
	// CellRendererExpandable: cell is in a row that can be expanded.
	CellRendererExpandable CellRendererState = 0b100000
	// CellRendererExpanded: cell is in a row that is expanded.
	CellRendererExpanded CellRendererState = 0b1000000
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for CellRendererState.
func (c CellRendererState) String() string {
	if c == 0 {
		return "CellRendererState(0)"
	}

	var builder strings.Builder
	builder.Grow(146)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CellRendererSelected:
			builder.WriteString("Selected|")
		case CellRendererPrelit:
			builder.WriteString("Prelit|")
		case CellRendererInsensitive:
			builder.WriteString("Insensitive|")
		case CellRendererSorted:
			builder.WriteString("Sorted|")
		case CellRendererFocused:
			builder.WriteString("Focused|")
		case CellRendererExpandable:
			builder.WriteString("Expandable|")
		case CellRendererExpanded:
			builder.WriteString("Expanded|")
		default:
			builder.WriteString(fmt.Sprintf("CellRendererState(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c CellRendererState) Has(other CellRendererState) bool {
	return (c & other) == other
}

// CellRendererOverrider contains methods that are overridable.
type CellRendererOverrider interface {
	EditingCanceled()
	// The function takes the following parameters:
	//
	//    - editable
	//    - path
	//
	EditingStarted(editable CellEditabler, path string)
	// PreferredHeight retrieves a renderer’s natural size when rendered to
	// widget.
	//
	// The function takes the following parameters:
	//
	//    - widget this cell will be rendering to.
	//
	// The function returns the following values:
	//
	//    - minimumSize (optional): location to store the minimum size, or NULL.
	//    - naturalSize (optional): location to store the natural size, or NULL.
	//
	PreferredHeight(widget Widgetter) (minimumSize, naturalSize int32)
	// PreferredHeightForWidth retrieves a cell renderers’s minimum and natural
	// height if it were rendered to widget with the specified width.
	//
	// The function takes the following parameters:
	//
	//    - widget this cell will be rendering to.
	//    - width: size which is available for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location for storing the minimum size, or
	//      NULL.
	//    - naturalHeight (optional): location for storing the preferred size, or
	//      NULL.
	//
	PreferredHeightForWidth(widget Widgetter, width int32) (minimumHeight, naturalHeight int32)
	// PreferredWidth retrieves a renderer’s natural size when rendered to
	// widget.
	//
	// The function takes the following parameters:
	//
	//    - widget this cell will be rendering to.
	//
	// The function returns the following values:
	//
	//    - minimumSize (optional): location to store the minimum size, or NULL.
	//    - naturalSize (optional): location to store the natural size, or NULL.
	//
	PreferredWidth(widget Widgetter) (minimumSize, naturalSize int32)
	// PreferredWidthForHeight retrieves a cell renderers’s minimum and natural
	// width if it were rendered to widget with the specified height.
	//
	// The function takes the following parameters:
	//
	//    - widget this cell will be rendering to.
	//    - height: size which is available for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location for storing the minimum size, or
	//      NULL.
	//    - naturalWidth (optional): location for storing the preferred size, or
	//      NULL.
	//
	PreferredWidthForHeight(widget Widgetter, height int32) (minimumWidth, naturalWidth int32)
}

// CellRenderer: object for rendering a single cell
//
// The CellRenderer is a base class of a set of objects used for rendering a
// cell to a #cairo_t. These objects are used primarily by the TreeView widget,
// though they aren’t tied to them in any specific way. It is worth noting that
// CellRenderer is not a Widget and cannot be treated as such.
//
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isn’t expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_preferred_size(). Finally, the cell is rendered in the
// correct location using gtk_cell_renderer_snapshot().
//
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, it’s important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be “activatable” like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be “editable” like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
//
// Many properties of CellRenderer and its subclasses have a corresponding “set”
// property, e.g. “cell-background-set” corresponds to “cell-background”. These
// “set” properties reflect whether a property has been set or not. You should
// not set them independently.
type CellRenderer struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned
}

var ()

// CellRendererer describes types inherited from class CellRenderer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type CellRendererer interface {
	coreglib.Objector
	baseCellRenderer() *CellRenderer
}

var _ CellRendererer = (*CellRenderer)(nil)

func classInitCellRendererer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "CellRendererClass")

	if _, ok := goval.(interface{ EditingCanceled() }); ok {
		o := pclass.StructFieldOffset("editing_canceled")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_CellRendererClass_editing_canceled)
	}

	if _, ok := goval.(interface {
		EditingStarted(editable CellEditabler, path string)
	}); ok {
		o := pclass.StructFieldOffset("editing_started")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_CellRendererClass_editing_started)
	}

	if _, ok := goval.(interface {
		PreferredHeight(widget Widgetter) (minimumSize, naturalSize int32)
	}); ok {
		o := pclass.StructFieldOffset("get_preferred_height")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_CellRendererClass_get_preferred_height)
	}

	if _, ok := goval.(interface {
		PreferredHeightForWidth(widget Widgetter, width int32) (minimumHeight, naturalHeight int32)
	}); ok {
		o := pclass.StructFieldOffset("get_preferred_height_for_width")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_CellRendererClass_get_preferred_height_for_width)
	}

	if _, ok := goval.(interface {
		PreferredWidth(widget Widgetter) (minimumSize, naturalSize int32)
	}); ok {
		o := pclass.StructFieldOffset("get_preferred_width")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_CellRendererClass_get_preferred_width)
	}

	if _, ok := goval.(interface {
		PreferredWidthForHeight(widget Widgetter, height int32) (minimumWidth, naturalWidth int32)
	}); ok {
		o := pclass.StructFieldOffset("get_preferred_width_for_height")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_CellRendererClass_get_preferred_width_for_height)
	}
}

//export _gotk4_gtk4_CellRendererClass_editing_canceled
func _gotk4_gtk4_CellRendererClass_editing_canceled(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ EditingCanceled() })

	iface.EditingCanceled()
}

//export _gotk4_gtk4_CellRendererClass_editing_started
func _gotk4_gtk4_CellRendererClass_editing_started(arg0 *C.void, arg1 *C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		EditingStarted(editable CellEditabler, path string)
	})

	var _editable CellEditabler // out
	var _path string            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	iface.EditingStarted(_editable, _path)
}

//export _gotk4_gtk4_CellRendererClass_get_preferred_height
func _gotk4_gtk4_CellRendererClass_get_preferred_height(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeight(widget Widgetter) (minimumSize, naturalSize int32)
	})

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := iface.PreferredHeight(_widget)

	*arg2 = (*C.void)(unsafe.Pointer(minimumSize))
	*arg3 = (*C.void)(unsafe.Pointer(naturalSize))
}

//export _gotk4_gtk4_CellRendererClass_get_preferred_height_for_width
func _gotk4_gtk4_CellRendererClass_get_preferred_height_for_width(arg0 *C.void, arg1 *C.void, arg2 C.int, arg3 *C.void, arg4 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeightForWidth(widget Widgetter, width int32) (minimumHeight, naturalHeight int32)
	})

	var _widget Widgetter // out
	var _width int32      // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int32(arg2)

	minimumHeight, naturalHeight := iface.PreferredHeightForWidth(_widget, _width)

	*arg3 = (*C.void)(unsafe.Pointer(minimumHeight))
	*arg4 = (*C.void)(unsafe.Pointer(naturalHeight))
}

//export _gotk4_gtk4_CellRendererClass_get_preferred_width
func _gotk4_gtk4_CellRendererClass_get_preferred_width(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredWidth(widget Widgetter) (minimumSize, naturalSize int32)
	})

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := iface.PreferredWidth(_widget)

	*arg2 = (*C.void)(unsafe.Pointer(minimumSize))
	*arg3 = (*C.void)(unsafe.Pointer(naturalSize))
}

//export _gotk4_gtk4_CellRendererClass_get_preferred_width_for_height
func _gotk4_gtk4_CellRendererClass_get_preferred_width_for_height(arg0 *C.void, arg1 *C.void, arg2 C.int, arg3 *C.void, arg4 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredWidthForHeight(widget Widgetter, height int32) (minimumWidth, naturalWidth int32)
	})

	var _widget Widgetter // out
	var _height int32     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int32(arg2)

	minimumWidth, naturalWidth := iface.PreferredWidthForHeight(_widget, _height)

	*arg3 = (*C.void)(unsafe.Pointer(minimumWidth))
	*arg4 = (*C.void)(unsafe.Pointer(naturalWidth))
}

func wrapCellRenderer(obj *coreglib.Object) *CellRenderer {
	return &CellRenderer{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
	}
}

func marshalCellRenderer(p uintptr) (interface{}, error) {
	return wrapCellRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (cell *CellRenderer) baseCellRenderer() *CellRenderer {
	return cell
}

// BaseCellRenderer returns the underlying base object.
func BaseCellRenderer(obj CellRendererer) *CellRenderer {
	return obj.baseCellRenderer()
}

//export _gotk4_gtk4_CellRenderer_ConnectEditingCanceled
func _gotk4_gtk4_CellRenderer_ConnectEditingCanceled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectEditingCanceled: this signal gets emitted when the user cancels the
// process of editing a cell. For example, an editable cell renderer could be
// written to cancel editing when the user presses Escape.
//
// See also: gtk_cell_renderer_stop_editing().
func (cell *CellRenderer) ConnectEditingCanceled(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cell, "editing-canceled", false, unsafe.Pointer(C._gotk4_gtk4_CellRenderer_ConnectEditingCanceled), f)
}

//export _gotk4_gtk4_CellRenderer_ConnectEditingStarted
func _gotk4_gtk4_CellRenderer_ConnectEditingStarted(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 C.guintptr) {
	var f func(editable CellEditabler, path string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(editable CellEditabler, path string))
	}

	var _editable CellEditabler // out
	var _path string            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_editable, _path)
}

// ConnectEditingStarted: this signal gets emitted when a cell starts to be
// edited. The intended use of this signal is to do special setup on editable,
// e.g. adding a EntryCompletion or setting up additional columns in a ComboBox.
//
// See gtk_cell_editable_start_editing() for information on the lifecycle of the
// editable and a way to do setup that doesn’t depend on the renderer.
//
// Note that GTK doesn't guarantee that cell renderers will continue to use the
// same kind of widget for editing in future releases, therefore you should
// check the type of editable before doing any specific setup, as in the
// following example:
//
//    static void
//    text_editing_started (GtkCellRenderer *cell,
//                          GtkCellEditable *editable,
//                          const char      *path,
//                          gpointer         data)
//    {
//      if (GTK_IS_ENTRY (editable))
//        {
//          GtkEntry *entry = GTK_ENTRY (editable);
//
//          // ... create a GtkEntryCompletion
//
//          gtk_entry_set_completion (entry, completion);
//        }
//    }.
func (cell *CellRenderer) ConnectEditingStarted(f func(editable CellEditabler, path string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cell, "editing-started", false, unsafe.Pointer(C._gotk4_gtk4_CellRenderer_ConnectEditingStarted), f)
}

// Alignment fills in xalign and yalign with the appropriate values of cell.
//
// The function returns the following values:
//
//    - xalign (optional): location to fill in with the x alignment of the cell,
//      or NULL.
//    - yalign (optional): location to fill in with the y alignment of the cell,
//      or NULL.
//
func (cell *CellRenderer) Alignment() (xalign, yalign float32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_alignment", _args[:], _outs[:])

	runtime.KeepAlive(cell)

	var _xalign float32 // out
	var _yalign float32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_xalign = *(*float32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_yalign = *(*float32)(unsafe.Pointer(_outs[1]))
	}

	return _xalign, _yalign
}

// FixedSize fills in width and height with the appropriate size of cell.
//
// The function returns the following values:
//
//    - width (optional): location to fill in with the fixed width of the cell,
//      or NULL.
//    - height (optional): location to fill in with the fixed height of the cell,
//      or NULL.
//
func (cell *CellRenderer) FixedSize() (width, height int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_fixed_size", _args[:], _outs[:])

	runtime.KeepAlive(cell)

	var _width int32  // out
	var _height int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_width = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_height = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _width, _height
}

// IsExpanded checks whether the given CellRenderer is expanded.
//
// The function returns the following values:
//
//    - ok: TRUE if the cell renderer is expanded.
//
func (cell *CellRenderer) IsExpanded() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_gret := girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_is_expanded", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(cell)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsExpander checks whether the given CellRenderer is an expander.
//
// The function returns the following values:
//
//    - ok: TRUE if cell is an expander, and FALSE otherwise.
//
func (cell *CellRenderer) IsExpander() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_gret := girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_is_expander", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(cell)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Padding fills in xpad and ypad with the appropriate values of cell.
//
// The function returns the following values:
//
//    - xpad (optional): location to fill in with the x padding of the cell, or
//      NULL.
//    - ypad (optional): location to fill in with the y padding of the cell, or
//      NULL.
//
func (cell *CellRenderer) Padding() (xpad, ypad int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_padding", _args[:], _outs[:])

	runtime.KeepAlive(cell)

	var _xpad int32 // out
	var _ypad int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_xpad = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_ypad = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _xpad, _ypad
}

// PreferredHeight retrieves a renderer’s natural size when rendered to widget.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//
// The function returns the following values:
//
//    - minimumSize (optional): location to store the minimum size, or NULL.
//    - naturalSize (optional): location to store the natural size, or NULL.
//
func (cell *CellRenderer) PreferredHeight(widget Widgetter) (minimumSize, naturalSize int32) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_height", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize int32 // out
	var _naturalSize int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_minimumSize = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_naturalSize = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _minimumSize, _naturalSize
}

// PreferredHeightForWidth retrieves a cell renderers’s minimum and natural
// height if it were rendered to widget with the specified width.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//    - width: size which is available for allocation.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location for storing the minimum size, or NULL.
//    - naturalHeight (optional): location for storing the preferred size, or
//      NULL.
//
func (cell *CellRenderer) PreferredHeightForWidth(widget Widgetter, width int32) (minimumHeight, naturalHeight int32) {
	var _args [3]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(width)

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_height_for_width", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int32 // out
	var _naturalHeight int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_minimumHeight = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_naturalHeight = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _minimumHeight, _naturalHeight
}

// PreferredSize retrieves the minimum and natural size of a cell taking into
// account the widget’s preference for height-for-width management.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//
// The function returns the following values:
//
//    - minimumSize (optional): location for storing the minimum size, or NULL.
//    - naturalSize (optional): location for storing the natural size, or NULL.
//
func (cell *CellRenderer) PreferredSize(widget Widgetter) (minimumSize, naturalSize *Requisition) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_size", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize *Requisition // out
	var _naturalSize *Requisition // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_minimumSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_naturalSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_outs[1])))
	}

	return _minimumSize, _naturalSize
}

// PreferredWidth retrieves a renderer’s natural size when rendered to widget.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//
// The function returns the following values:
//
//    - minimumSize (optional): location to store the minimum size, or NULL.
//    - naturalSize (optional): location to store the natural size, or NULL.
//
func (cell *CellRenderer) PreferredWidth(widget Widgetter) (minimumSize, naturalSize int32) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_width", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize int32 // out
	var _naturalSize int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_minimumSize = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_naturalSize = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _minimumSize, _naturalSize
}

// PreferredWidthForHeight retrieves a cell renderers’s minimum and natural
// width if it were rendered to widget with the specified height.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//    - height: size which is available for allocation.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location for storing the minimum size, or NULL.
//    - naturalWidth (optional): location for storing the preferred size, or
//      NULL.
//
func (cell *CellRenderer) PreferredWidthForHeight(widget Widgetter, height int32) (minimumWidth, naturalWidth int32) {
	var _args [3]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(height)

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_width_for_height", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int32 // out
	var _naturalWidth int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_minimumWidth = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_naturalWidth = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _minimumWidth, _naturalWidth
}

// Sensitive returns the cell renderer’s sensitivity.
//
// The function returns the following values:
//
//    - ok: TRUE if the cell renderer is sensitive.
//
func (cell *CellRenderer) Sensitive() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_gret := girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_sensitive", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(cell)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Visible returns the cell renderer’s visibility.
//
// The function returns the following values:
//
//    - ok: TRUE if the cell renderer is visible.
//
func (cell *CellRenderer) Visible() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_gret := girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_visible", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(cell)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsActivatable checks whether the cell renderer can do something when
// activated.
//
// The function returns the following values:
//
//    - ok: TRUE if the cell renderer can do anything when activated.
//
func (cell *CellRenderer) IsActivatable() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_gret := girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("is_activatable", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(cell)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SetAlignment sets the renderer’s alignment within its available space.
//
// The function takes the following parameters:
//
//    - xalign: x alignment of the cell renderer.
//    - yalign: y alignment of the cell renderer.
//
func (cell *CellRenderer) SetAlignment(xalign, yalign float32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(xalign)
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(yalign)

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_alignment", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
}

// SetFixedSize sets the renderer size to be explicit, independent of the
// properties set.
//
// The function takes the following parameters:
//
//    - width of the cell renderer, or -1.
//    - height of the cell renderer, or -1.
//
func (cell *CellRenderer) SetFixedSize(width, height int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(width)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(height)

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_fixed_size", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetIsExpanded sets whether the given CellRenderer is expanded.
//
// The function takes the following parameters:
//
//    - isExpanded: whether cell should be expanded.
//
func (cell *CellRenderer) SetIsExpanded(isExpanded bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if isExpanded {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_is_expanded", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(isExpanded)
}

// SetIsExpander sets whether the given CellRenderer is an expander.
//
// The function takes the following parameters:
//
//    - isExpander: whether cell is an expander.
//
func (cell *CellRenderer) SetIsExpander(isExpander bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if isExpander {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_is_expander", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(isExpander)
}

// SetPadding sets the renderer’s padding.
//
// The function takes the following parameters:
//
//    - xpad: x padding of the cell renderer.
//    - ypad: y padding of the cell renderer.
//
func (cell *CellRenderer) SetPadding(xpad, ypad int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(xpad)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(ypad)

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_padding", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(xpad)
	runtime.KeepAlive(ypad)
}

// SetSensitive sets the cell renderer’s sensitivity.
//
// The function takes the following parameters:
//
//    - sensitive: sensitivity of the cell.
//
func (cell *CellRenderer) SetSensitive(sensitive bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if sensitive {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_sensitive", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(sensitive)
}

// SetVisible sets the cell renderer’s visibility.
//
// The function takes the following parameters:
//
//    - visible: visibility of the cell.
//
func (cell *CellRenderer) SetVisible(visible bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if visible {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_visible", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(visible)
}

// StopEditing informs the cell renderer that the editing is stopped. If
// canceled is TRUE, the cell renderer will emit the
// CellRenderer::editing-canceled signal.
//
// This function should be called by cell renderer implementations in response
// to the CellEditable::editing-done signal of CellEditable.
//
// The function takes the following parameters:
//
//    - canceled: TRUE if the editing has been canceled.
//
func (cell *CellRenderer) StopEditing(canceled bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if canceled {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("stop_editing", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(canceled)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gtk4_TextViewClass_backspace(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_copy_clipboard(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_cut_clipboard(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_insert_at_cursor(GtkTextView*, char*);
// extern void _gotk4_gtk4_TextViewClass_insert_emoji(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_paste_clipboard(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_set_anchor(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_toggle_overwrite(GtkTextView*);
// extern void _gotk4_gtk4_TextView_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectInsertAtCursor(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectPreeditChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectSelectAll(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectSetAnchor(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectToggleCursorVisible(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectToggleOverwrite(gpointer, guintptr);
import "C"

// glib.Type values for gtktextview.go.
var (
	GTypeTextExtendSelection = coreglib.Type(C.gtk_text_extend_selection_get_type())
	GTypeTextViewLayer       = coreglib.Type(C.gtk_text_view_layer_get_type())
	GTypeTextWindowType      = coreglib.Type(C.gtk_text_window_type_get_type())
	GTypeTextView            = coreglib.Type(C.gtk_text_view_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeTextExtendSelection, F: marshalTextExtendSelection},
		{T: GTypeTextViewLayer, F: marshalTextViewLayer},
		{T: GTypeTextWindowType, F: marshalTextWindowType},
		{T: GTypeTextView, F: marshalTextView},
	})
}

// TEXT_VIEW_PRIORITY_VALIDATE: priority at which the text view validates
// onscreen lines in an idle job in the background.
const TEXT_VIEW_PRIORITY_VALIDATE = 125

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection C.gint

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = iota
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextExtendSelection.
func (t TextExtendSelection) String() string {
	switch t {
	case TextExtendSelectionWord:
		return "Word"
	case TextExtendSelectionLine:
		return "Line"
	default:
		return fmt.Sprintf("TextExtendSelection(%d)", t)
	}
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer C.gint

const (
	// TextViewLayerBelowText: layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = iota
	// TextViewLayerAboveText: layer rendered above the text.
	TextViewLayerAboveText
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextViewLayer.
func (t TextViewLayer) String() string {
	switch t {
	case TextViewLayerBelowText:
		return "BelowText"
	case TextViewLayerAboveText:
		return "AboveText"
	default:
		return fmt.Sprintf("TextViewLayer(%d)", t)
	}
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType C.gint

const (
	// TextWindowWidget: window that floats over scrolling areas.
	TextWindowWidget TextWindowType = 1
	// TextWindowText: scrollable text window.
	TextWindowText TextWindowType = 2
	// TextWindowLeft: left side border window.
	TextWindowLeft TextWindowType = 3
	// TextWindowRight: right side border window.
	TextWindowRight TextWindowType = 4
	// TextWindowTop: top border window.
	TextWindowTop TextWindowType = 5
	// TextWindowBottom: bottom border window.
	TextWindowBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextWindowType.
func (t TextWindowType) String() string {
	switch t {
	case TextWindowWidget:
		return "Widget"
	case TextWindowText:
		return "Text"
	case TextWindowLeft:
		return "Left"
	case TextWindowRight:
		return "Right"
	case TextWindowTop:
		return "Top"
	case TextWindowBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("TextWindowType(%d)", t)
	}
}

// TextViewOverrider contains methods that are overridable.
type TextViewOverrider interface {
	Backspace()
	CopyClipboard()
	CutClipboard()
	// The function takes the following parameters:
	//
	InsertAtCursor(str string)
	InsertEmoji()
	PasteClipboard()
	SetAnchor()
	ToggleOverwrite()
}

// TextView: widget that displays the contents of a gtk.TextBuffer.
//
// !An example GtkTextview (multiline-text.png)
//
// You may wish to begin by reading the conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
//
//
// Accessibility
//
// GtkTextView uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type TextView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Scrollable
}

var (
	_ Widgetter         = (*TextView)(nil)
	_ coreglib.Objector = (*TextView)(nil)
)

func classInitTextViewer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkTextViewClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkTextViewClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ Backspace() }); ok {
		pclass.backspace = (*[0]byte)(C._gotk4_gtk4_TextViewClass_backspace)
	}

	if _, ok := goval.(interface{ CopyClipboard() }); ok {
		pclass.copy_clipboard = (*[0]byte)(C._gotk4_gtk4_TextViewClass_copy_clipboard)
	}

	if _, ok := goval.(interface{ CutClipboard() }); ok {
		pclass.cut_clipboard = (*[0]byte)(C._gotk4_gtk4_TextViewClass_cut_clipboard)
	}

	if _, ok := goval.(interface{ InsertAtCursor(str string) }); ok {
		pclass.insert_at_cursor = (*[0]byte)(C._gotk4_gtk4_TextViewClass_insert_at_cursor)
	}

	if _, ok := goval.(interface{ InsertEmoji() }); ok {
		pclass.insert_emoji = (*[0]byte)(C._gotk4_gtk4_TextViewClass_insert_emoji)
	}

	if _, ok := goval.(interface{ PasteClipboard() }); ok {
		pclass.paste_clipboard = (*[0]byte)(C._gotk4_gtk4_TextViewClass_paste_clipboard)
	}

	if _, ok := goval.(interface{ SetAnchor() }); ok {
		pclass.set_anchor = (*[0]byte)(C._gotk4_gtk4_TextViewClass_set_anchor)
	}

	if _, ok := goval.(interface{ ToggleOverwrite() }); ok {
		pclass.toggle_overwrite = (*[0]byte)(C._gotk4_gtk4_TextViewClass_toggle_overwrite)
	}
}

//export _gotk4_gtk4_TextViewClass_backspace
func _gotk4_gtk4_TextViewClass_backspace(arg0 *C.GtkTextView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Backspace() })

	iface.Backspace()
}

//export _gotk4_gtk4_TextViewClass_copy_clipboard
func _gotk4_gtk4_TextViewClass_copy_clipboard(arg0 *C.GtkTextView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CopyClipboard() })

	iface.CopyClipboard()
}

//export _gotk4_gtk4_TextViewClass_cut_clipboard
func _gotk4_gtk4_TextViewClass_cut_clipboard(arg0 *C.GtkTextView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CutClipboard() })

	iface.CutClipboard()
}

//export _gotk4_gtk4_TextViewClass_insert_at_cursor
func _gotk4_gtk4_TextViewClass_insert_at_cursor(arg0 *C.GtkTextView, arg1 *C.char) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ InsertAtCursor(str string) })

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	iface.InsertAtCursor(_str)
}

//export _gotk4_gtk4_TextViewClass_insert_emoji
func _gotk4_gtk4_TextViewClass_insert_emoji(arg0 *C.GtkTextView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ InsertEmoji() })

	iface.InsertEmoji()
}

//export _gotk4_gtk4_TextViewClass_paste_clipboard
func _gotk4_gtk4_TextViewClass_paste_clipboard(arg0 *C.GtkTextView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ PasteClipboard() })

	iface.PasteClipboard()
}

//export _gotk4_gtk4_TextViewClass_set_anchor
func _gotk4_gtk4_TextViewClass_set_anchor(arg0 *C.GtkTextView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SetAnchor() })

	iface.SetAnchor()
}

//export _gotk4_gtk4_TextViewClass_toggle_overwrite
func _gotk4_gtk4_TextViewClass_toggle_overwrite(arg0 *C.GtkTextView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ToggleOverwrite() })

	iface.ToggleOverwrite()
}

func wrapTextView(obj *coreglib.Object) *TextView {
	return &TextView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalTextView(p uintptr) (interface{}, error) {
	return wrapTextView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_TextView_ConnectBackspace
func _gotk4_gtk4_TextView_ConnectBackspace(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectBackspace gets emitted when the user asks for it.
//
// The ::backspace signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Backspace</kbd> and
// <kbd>Shift</kbd>-<kbd>Backspace</kbd>.
func (textView *TextView) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "backspace", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectBackspace), f)
}

//export _gotk4_gtk4_TextView_ConnectCopyClipboard
func _gotk4_gtk4_TextView_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCopyClipboard gets emitted to copy the selection to the clipboard.
//
// The ::copy-clipboard signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>c</kbd> and
// <kbd>Ctrl</kbd>-<kbd>Insert</kbd>.
func (textView *TextView) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectCopyClipboard), f)
}

//export _gotk4_gtk4_TextView_ConnectCutClipboard
func _gotk4_gtk4_TextView_ConnectCutClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCutClipboard gets emitted to cut the selection to the clipboard.
//
// The ::cut-clipboard signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>x</kbd> and
// <kbd>Shift</kbd>-<kbd>Delete</kbd>.
func (textView *TextView) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectCutClipboard), f)
}

//export _gotk4_gtk4_TextView_ConnectInsertAtCursor
func _gotk4_gtk4_TextView_ConnectInsertAtCursor(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(str string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(str string))
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_str)
}

// ConnectInsertAtCursor gets emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// The ::insert-at-cursor signal is a keybinding signal
// (class.SignalAction.html).
//
// This signal has no default bindings.
func (textView *TextView) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectInsertAtCursor), f)
}

//export _gotk4_gtk4_TextView_ConnectInsertEmoji
func _gotk4_gtk4_TextView_ConnectInsertEmoji(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectInsertEmoji gets emitted to present the Emoji chooser for the
// text_view.
//
// The ::insert-emoji signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>.</kbd> and
// <kbd>Ctrl</kbd>-<kbd>;</kbd>.
func (textView *TextView) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectInsertEmoji), f)
}

//export _gotk4_gtk4_TextView_ConnectPasteClipboard
func _gotk4_gtk4_TextView_ConnectPasteClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectPasteClipboard gets emitted to paste the contents of the clipboard
// into the text view.
//
// The ::paste-clipboard signal is a keybinding signal
// (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>v</kbd> and
// <kbd>Shift</kbd>-<kbd>Insert</kbd>.
func (textView *TextView) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectPasteClipboard), f)
}

//export _gotk4_gtk4_TextView_ConnectPreeditChanged
func _gotk4_gtk4_TextView_ConnectPreeditChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(preedit string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(preedit string))
	}

	var _preedit string // out

	_preedit = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_preedit)
}

// ConnectPreeditChanged is emitted when preedit text of the active IM changes.
//
// If an input method is used, the typed text will not immediately be committed
// to the buffer. So if you are interested in the text, connect to this signal.
//
// This signal is only emitted if the text at the given position is actually
// editable.
func (textView *TextView) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectPreeditChanged), f)
}

//export _gotk4_gtk4_TextView_ConnectSelectAll
func _gotk4_gtk4_TextView_ConnectSelectAll(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(sel bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sel bool))
	}

	var _sel bool // out

	if arg1 != 0 {
		_sel = true
	}

	f(_sel)
}

// ConnectSelectAll gets emitted to select or unselect the complete contents of
// the text view.
//
// The ::select-all signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>a</kbd> and
// <kbd>Ctrl</kbd>-<kbd>/</kbd> for selecting and
// <kbd>Shift</kbd>-<kbd>Ctrl</kbd>-<kbd>a</kbd> and
// <kbd>Ctrl</kbd>-<kbd>\</kbd> for unselecting.
func (textView *TextView) ConnectSelectAll(f func(sel bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectSelectAll), f)
}

//export _gotk4_gtk4_TextView_ConnectSetAnchor
func _gotk4_gtk4_TextView_ConnectSetAnchor(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectSetAnchor gets emitted when the user initiates settings the "anchor"
// mark.
//
// The ::set-anchor signal is a keybinding signal (class.SignalAction.html)
// which gets emitted when the user initiates setting the "anchor" mark. The
// "anchor" mark gets placed at the same position as the "insert" mark.
//
// This signal has no default bindings.
func (textView *TextView) ConnectSetAnchor(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "set-anchor", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectSetAnchor), f)
}

//export _gotk4_gtk4_TextView_ConnectToggleCursorVisible
func _gotk4_gtk4_TextView_ConnectToggleCursorVisible(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectToggleCursorVisible gets emitted to toggle the cursor-visible
// property.
//
// The ::toggle-cursor-visible signal is a keybinding signal
// (class.SignalAction.html).
//
// The default binding for this signal is <kbd>F7</kbd>.
func (textView *TextView) ConnectToggleCursorVisible(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "toggle-cursor-visible", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectToggleCursorVisible), f)
}

//export _gotk4_gtk4_TextView_ConnectToggleOverwrite
func _gotk4_gtk4_TextView_ConnectToggleOverwrite(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectToggleOverwrite gets emitted to toggle the overwrite mode of the text
// view.
//
// The ::toggle-overwrite signal is a keybinding signal
// (class.SignalAction.html).
//
// The default binding for this signal is <kbd>Insert</kbd>.
func (textView *TextView) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectToggleOverwrite), f)
}

// NewTextView creates a new GtkTextView.
//
// If you don’t call gtk.TextView.SetBuffer() before using the text view, an
// empty default buffer will be created for you. Get the buffer with
// gtk.TextView.GetBuffer(). If you want to specify your own buffer, consider
// gtk.TextView.NewWithBuffer.
//
// The function returns the following values:
//
//    - textView: new GtkTextView.
//
func NewTextView() *TextView {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("new_TextView", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _textView *TextView // out

	_textView = wrapTextView(coreglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// NewTextViewWithBuffer creates a new GtkTextView widget displaying the buffer
// buffer.
//
// One buffer can be shared among many widgets. buffer may be NULL to create a
// default buffer, in which case this function is equivalent to
// gtk.TextView.New. The text view adds its own reference count to the buffer;
// it does not take over an existing reference.
//
// The function takes the following parameters:
//
//    - buffer: GtkTextBuffer.
//
// The function returns the following values:
//
//    - textView: new GtkTextView.
//
func NewTextViewWithBuffer(buffer *TextBuffer) *TextView {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("new_TextView_with_buffer", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _textView *TextView // out

	_textView = wrapTextView(coreglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// AddChildAtAnchor adds a child widget in the text buffer, at the given anchor.
//
// The function takes the following parameters:
//
//    - child: GtkWidget.
//    - anchor: GtkTextChildAnchor in the GtkTextBuffer for text_view.
//
func (textView *TextView) AddChildAtAnchor(child Widgetter, anchor *TextChildAnchor) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1
	*(*Widgetter)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextView").InvokeMethod("add_child_at_anchor", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(anchor)
}

// AddOverlay adds child at a fixed coordinate in the GtkTextView's text window.
//
// The xpos and ypos must be in buffer coordinates (see
// gtk.TextView.GetIterLocation() to convert to buffer coordinates).
//
// child will scroll with the text view.
//
// If instead you want a widget that will not move with the GtkTextView contents
// see Overlay.
//
// The function takes the following parameters:
//
//    - child: Widget.
//    - xpos: x position of child in window coordinates.
//    - ypos: y position of child in window coordinates.
//
func (textView *TextView) AddOverlay(child Widgetter, xpos, ypos int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.int   // out
	var _arg3 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(xpos)
	_arg3 = C.int(ypos)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1
	*(*Widgetter)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextView").InvokeMethod("add_overlay", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(xpos)
	runtime.KeepAlive(ypos)
}

// BackwardDisplayLine moves the given iter backward by one display (wrapped)
// line.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
//
// The function takes the following parameters:
//
//    - iter: GtkTextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter was moved and is not on the end iterator.
//
func (textView *TextView) BackwardDisplayLine(iter *TextIter) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("backward_display_line", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardDisplayLineStart moves the given iter backward to the next display
// line start.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
//
// The function takes the following parameters:
//
//    - iter: GtkTextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter was moved and is not on the end iterator.
//
func (textView *TextView) BackwardDisplayLineStart(iter *TextIter) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("backward_display_line_start", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardDisplayLine moves the given iter forward by one display (wrapped)
// line.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
//
// The function takes the following parameters:
//
//    - iter: GtkTextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter was moved and is not on the end iterator.
//
func (textView *TextView) ForwardDisplayLine(iter *TextIter) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("forward_display_line", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardDisplayLineEnd moves the given iter forward to the next display line
// end.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
//
// The function takes the following parameters:
//
//    - iter: GtkTextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter was moved and is not on the end iterator.
//
func (textView *TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("forward_display_line_end", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
//
// See gtk.TextView.SetAcceptsTab().
//
// The function returns the following values:
//
//    - ok: TRUE if pressing the Tab key inserts a tab character, FALSE if
//      pressing the Tab key moves the keyboard focus.
//
func (textView *TextView) AcceptsTab() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_accepts_tab", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BottomMargin gets the bottom margin for text in the text_view.
//
// The function returns the following values:
//
//    - gint: bottom margin in pixels.
//
func (textView *TextView) BottomMargin() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_bottom_margin", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Buffer returns the GtkTextBuffer being displayed by this text view.
//
// The reference count on the buffer is not incremented; the caller of this
// function won’t own a new reference.
//
// The function returns the following values:
//
//    - textBuffer: GtkTextBuffer.
//
func (textView *TextView) Buffer() *TextBuffer {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_buffer", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _textBuffer
}

// CursorVisible: find out whether the cursor should be displayed.
//
// The function returns the following values:
//
//    - ok: whether the insertion mark is visible.
//
func (textView *TextView) CursorVisible() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_cursor_visible", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Editable returns the default editability of the GtkTextView.
//
// Tags in the buffer may override this setting for some ranges of text.
//
// The function returns the following values:
//
//    - ok: whether text is editable by default.
//
func (textView *TextView) Editable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_editable", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExtraMenu gets the menu model that gets added to the context menu or NULL if
// none has been set.
//
// The function returns the following values:
//
//    - menuModel: menu model.
//
func (textView *TextView) ExtraMenu() gio.MenuModeller {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_extra_menu", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _menuModel gio.MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.MenuModeller)
			return ok
		})
		rv, ok := casted.(gio.MenuModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// Indent gets the default indentation of paragraphs in text_view.
//
// Tags in the view’s buffer may override the default. The indentation may be
// negative.
//
// The function returns the following values:
//
//    - gint: number of pixels of indentation.
//
func (textView *TextView) Indent() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_indent", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// LeftMargin gets the default left margin size of paragraphs in the text_view.
//
// Tags in the buffer may override the default.
//
// The function returns the following values:
//
//    - gint: left margin in pixels.
//
func (textView *TextView) LeftMargin() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_left_margin", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Monospace gets whether the GtkTextView uses monospace styling.
//
// The function returns the following values:
//
//    - ok: TRUE if monospace fonts are desired.
//
func (textView *TextView) Monospace() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_monospace", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Overwrite returns whether the GtkTextView is in overwrite mode or not.
//
// The function returns the following values:
//
//    - ok: whether text_view is in overwrite mode or not.
//
func (textView *TextView) Overwrite() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_overwrite", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PixelsAboveLines gets the default number of pixels to put above paragraphs.
//
// Adding this function with gtk.TextView.GetPixelsBelowLines() is equal to the
// line space between each paragraph.
//
// The function returns the following values:
//
//    - gint: default number of pixels above paragraphs.
//
func (textView *TextView) PixelsAboveLines() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_pixels_above_lines", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// PixelsBelowLines gets the default number of pixels to put below paragraphs.
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk.TextView.GetPixelsAboveLines().
//
// The function returns the following values:
//
//    - gint: default number of blank pixels below paragraphs.
//
func (textView *TextView) PixelsBelowLines() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_pixels_below_lines", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// PixelsInsideWrap gets the default number of pixels to put between wrapped
// lines inside a paragraph.
//
// The function returns the following values:
//
//    - gint: default number of pixels of blank space between wrapped lines.
//
func (textView *TextView) PixelsInsideWrap() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_pixels_inside_wrap", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// RightMargin gets the default right margin for text in text_view.
//
// Tags in the buffer may override the default.
//
// The function returns the following values:
//
//    - gint: right margin in pixels.
//
func (textView *TextView) RightMargin() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_right_margin", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Tabs gets the default tabs for text_view.
//
// Tags in the buffer may override the defaults. The returned array will be NULL
// if “standard” (8-space) tabs are used. Free the return value with
// pango.TabArray.Free().
//
// The function returns the following values:
//
//    - tabArray (optional): copy of default tab array, or NULL if standard tabs
//      are used; must be freed with pango.TabArray.Free().
//
func (textView *TextView) Tabs() *pango.TabArray {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_tabs", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _tabArray *pango.TabArray // out

	if _cret != nil {
		_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tabArray)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
			},
		)
	}

	return _tabArray
}

// TopMargin gets the top margin for text in the text_view.
//
// The function returns the following values:
//
//    - gint: top margin in pixels.
//
func (textView *TextView) TopMargin() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("get_top_margin", args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// IMContextFilterKeypress: allow the GtkTextView input method to internally
// handle key press and release events.
//
// If this function returns TRUE, then no further processing should be done for
// this key event. See gtk.IMContext.FilterKeypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the GtkTextView.
//
//    static gboolean
//    gtk_foo_bar_key_press_event (GtkWidget *widget,
//                                 GdkEvent  *event)
//    {
//      guint keyval;
//
//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
//
//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//        {
//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//            return TRUE;
//        }
//
//      // Do some stuff
//
//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//    }.
//
// The function takes the following parameters:
//
//    - event: key event.
//
// The function returns the following values:
//
//    - ok: TRUE if the input method handled the key event.
//
func (textView *TextView) IMContextFilterKeypress(event gdk.Eventer) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("im_context_filter_keypress", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMarkOnscreen moves a mark within the buffer so that it's located within
// the currently-visible text area.
//
// The function takes the following parameters:
//
//    - mark: GtkTextMark.
//
// The function returns the following values:
//
//    - ok: TRUE if the mark moved (wasn’t already onscreen).
//
func (textView *TextView) MoveMarkOnscreen(mark *TextMark) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("move_mark_onscreen", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveOverlay updates the position of a child.
//
// See gtk.TextView.AddOverlay().
//
// The function takes the following parameters:
//
//    - child: widget already added with gtk.TextView.AddOverlay().
//    - xpos: new X position in buffer coordinates.
//    - ypos: new Y position in buffer coordinates.
//
func (textView *TextView) MoveOverlay(child Widgetter, xpos, ypos int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.int   // out
	var _arg3 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(xpos)
	_arg3 = C.int(ypos)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1
	*(*Widgetter)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextView").InvokeMethod("move_overlay", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(xpos)
	runtime.KeepAlive(ypos)
}

// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position.
//
// If count is positive, then the new strong cursor position will be count
// positions to the right of the old cursor position. If count is negative then
// the new strong cursor position will be count positions to the left of the old
// cursor position.
//
// In the presence of bi-directional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and there
// may be jumps when the cursor is moved off of the end of a run.
//
// The function takes the following parameters:
//
//    - iter: GtkTextIter.
//    - count: number of characters to move (negative moves left, positive moves
//      right).
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not on the end iterator.
//
func (textView *TextView) MoveVisually(iter *TextIter, count int32) bool {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.int      // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.int(count)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("move_visually", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceCursorOnscreen moves the cursor to the currently visible region of the
// buffer.
//
// The function returns the following values:
//
//    - ok: TRUE if the cursor had to be moved.
//
func (textView *TextView) PlaceCursorOnscreen() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("place_cursor_onscreen", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes a child widget from text_view.
//
// The function takes the following parameters:
//
//    - child to remove.
//
func (textView *TextView) Remove(child Widgetter) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("remove", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
}

// ResetCursorBlink ensures that the cursor is shown.
//
// This also resets the time that it will stay blinking (or visible, in case
// blinking is disabled).
//
// This function should be called in response to user input (e.g. from derived
// classes that override the textview's event handlers).
func (textView *TextView) ResetCursorBlink() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TextView").InvokeMethod("reset_cursor_blink", args[:], nil)

	runtime.KeepAlive(textView)
}

// ResetIMContext: reset the input method context of the text view if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (textView *TextView) ResetIMContext() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	*(**TextView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TextView").InvokeMethod("reset_im_context", args[:], nil)

	runtime.KeepAlive(textView)
}

// ScrollMarkOnscreen scrolls text_view the minimum distance such that mark is
// contained within the visible area of the widget.
//
// The function takes the following parameters:
//
//    - mark in the buffer for text_view.
//
func (textView *TextView) ScrollMarkOnscreen(mark *TextMark) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("scroll_mark_onscreen", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)
}

// ScrollToIter scrolls text_view so that iter is on the screen in the position
// indicated by xalign and yalign.
//
// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5
// means center. If use_align is FALSE, the text scrolls the minimal distance to
// get the mark onscreen, possibly not scrolling at all. The effective screen
// for purposes of this function is reduced by a margin of size within_margin.
//
// Note that this function uses the currently-computed height of the lines in
// the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using gtk.TextView.ScrollToMark()
// which saves a point to be scrolled to after line validation.
//
// The function takes the following parameters:
//
//    - iter: GtkTextIter.
//    - withinMargin: margin as a [0.0,0.5) fraction of screen size.
//    - useAlign: whether to use alignment arguments (if FALSE, just get the mark
//      onscreen).
//    - xalign: horizontal alignment of mark within visible area.
//    - yalign: vertical alignment of mark within visible area.
//
// The function returns the following values:
//
//    - ok: TRUE if scrolling occurred.
//
func (textView *TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign, yalign float64) bool {
	var args [6]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.double   // out
	var _arg3 C.gboolean // out
	var _arg4 C.double   // out
	var _arg5 C.double   // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.double(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.double(xalign)
	_arg5 = C.double(yalign)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(*float64)(unsafe.Pointer(&args[3])) = _arg3
	*(*bool)(unsafe.Pointer(&args[4])) = _arg4
	*(*float64)(unsafe.Pointer(&args[5])) = _arg5

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("scroll_to_iter", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(withinMargin)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToMark scrolls text_view so that mark is on the screen in the position
// indicated by xalign and yalign.
//
// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5
// means center. If use_align is FALSE, the text scrolls the minimal distance to
// get the mark onscreen, possibly not scrolling at all. The effective screen
// for purposes of this function is reduced by a margin of size within_margin.
//
// The function takes the following parameters:
//
//    - mark: GtkTextMark.
//    - withinMargin: margin as a [0.0,0.5) fraction of screen size.
//    - useAlign: whether to use alignment arguments (if FALSE, just get the mark
//      onscreen).
//    - xalign: horizontal alignment of mark within visible area.
//    - yalign: vertical alignment of mark within visible area.
//
func (textView *TextView) ScrollToMark(mark *TextMark, withinMargin float64, useAlign bool, xalign, yalign float64) {
	var args [6]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.double   // out
	var _arg3 C.gboolean // out
	var _arg4 C.double   // out
	var _arg5 C.double   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = C.double(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.double(xalign)
	_arg5 = C.double(yalign)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextMark)(unsafe.Pointer(&args[2])) = _arg2
	*(*float64)(unsafe.Pointer(&args[3])) = _arg3
	*(*bool)(unsafe.Pointer(&args[4])) = _arg4
	*(*float64)(unsafe.Pointer(&args[5])) = _arg5

	girepository.MustFind("Gtk", "TextView").InvokeMethod("scroll_to_mark", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(withinMargin)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
}

// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed.
//
// If accepts_tab is TRUE, a tab character is inserted. If accepts_tab is FALSE
// the keyboard focus is moved to the next widget in the focus chain.
//
// The function takes the following parameters:
//
//    - acceptsTab: TRUE if pressing the Tab key should insert a tab character,
//      FALSE, if pressing the Tab key should move the keyboard focus.
//
func (textView *TextView) SetAcceptsTab(acceptsTab bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if acceptsTab {
		_arg1 = C.TRUE
	}
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_accepts_tab", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(acceptsTab)
}

// SetBottomMargin sets the bottom margin for text in text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//    - bottomMargin: bottom margin in pixels.
//
func (textView *TextView) SetBottomMargin(bottomMargin int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(bottomMargin)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_bottom_margin", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(bottomMargin)
}

// SetBuffer sets buffer as the buffer being displayed by text_view.
//
// The previous buffer displayed by the text view is unreferenced, and a
// reference is added to buffer. If you owned a reference to buffer before
// passing it to this function, you must remove that reference yourself;
// GtkTextView will not “adopt” it.
//
// The function takes the following parameters:
//
//    - buffer (optional): GtkTextBuffer.
//
func (textView *TextView) SetBuffer(buffer *TextBuffer) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if buffer != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	}
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_buffer", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(buffer)
}

// SetCursorVisible toggles whether the insertion point should be displayed.
//
// A buffer with no editable text probably shouldn’t have a visible cursor, so
// you may want to turn the cursor off.
//
// Note that this property may be overridden by the
// gtksettings:gtk-keynav-use-caret setting.
//
// The function takes the following parameters:
//
//    - setting: whether to show the insertion cursor.
//
func (textView *TextView) SetCursorVisible(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_cursor_visible", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(setting)
}

// SetEditable sets the default editability of the GtkTextView.
//
// You can override this default setting with tags in the buffer, using the
// “editable” attribute of tags.
//
// The function takes the following parameters:
//
//    - setting: whether it’s editable.
//
func (textView *TextView) SetEditable(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_editable", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(setting)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// text_view.
//
// You can pass NULL to remove a previously set extra menu.
//
// The function takes the following parameters:
//
//    - model (optional): GMenuModel.
//
func (textView *TextView) SetExtraMenu(model gio.MenuModeller) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if model != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_extra_menu", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(model)
}

// SetIndent sets the default indentation for paragraphs in text_view.
//
// Tags in the buffer may override the default.
//
// The function takes the following parameters:
//
//    - indent: indentation in pixels.
//
func (textView *TextView) SetIndent(indent int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(indent)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_indent", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(indent)
}

// SetLeftMargin sets the default left margin for text in text_view.
//
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//    - leftMargin: left margin in pixels.
//
func (textView *TextView) SetLeftMargin(leftMargin int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(leftMargin)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_left_margin", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(leftMargin)
}

// SetMonospace sets whether the GtkTextView should display text in monospace
// styling.
//
// The function takes the following parameters:
//
//    - monospace: TRUE to request monospace styling.
//
func (textView *TextView) SetMonospace(monospace bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if monospace {
		_arg1 = C.TRUE
	}
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_monospace", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(monospace)
}

// SetOverwrite changes the GtkTextView overwrite mode.
//
// The function takes the following parameters:
//
//    - overwrite: TRUE to turn on overwrite mode, FALSE to turn it off.
//
func (textView *TextView) SetOverwrite(overwrite bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if overwrite {
		_arg1 = C.TRUE
	}
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_overwrite", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(overwrite)
}

// SetPixelsAboveLines sets the default number of blank pixels above paragraphs
// in text_view.
//
// Tags in the buffer for text_view may override the defaults.
//
// The function takes the following parameters:
//
//    - pixelsAboveLines pixels above paragraphs.
//
func (textView *TextView) SetPixelsAboveLines(pixelsAboveLines int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(pixelsAboveLines)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_pixels_above_lines", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsAboveLines)
}

// SetPixelsBelowLines sets the default number of pixels of blank space to put
// below paragraphs in text_view.
//
// May be overridden by tags applied to text_view’s buffer.
//
// The function takes the following parameters:
//
//    - pixelsBelowLines pixels below paragraphs.
//
func (textView *TextView) SetPixelsBelowLines(pixelsBelowLines int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(pixelsBelowLines)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_pixels_below_lines", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsBelowLines)
}

// SetPixelsInsideWrap sets the default number of pixels of blank space to leave
// between display/wrapped lines within a paragraph.
//
// May be overridden by tags in text_view’s buffer.
//
// The function takes the following parameters:
//
//    - pixelsInsideWrap: default number of pixels between wrapped lines.
//
func (textView *TextView) SetPixelsInsideWrap(pixelsInsideWrap int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(pixelsInsideWrap)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_pixels_inside_wrap", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsInsideWrap)
}

// SetRightMargin sets the default right margin for text in the text view.
//
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//    - rightMargin: right margin in pixels.
//
func (textView *TextView) SetRightMargin(rightMargin int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(rightMargin)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_right_margin", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(rightMargin)
}

// SetTabs sets the default tab stops for paragraphs in text_view.
//
// Tags in the buffer may override the default.
//
// The function takes the following parameters:
//
//    - tabs as a TabArray.
//
func (textView *TextView) SetTabs(tabs *pango.TabArray) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(tabs)))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_tabs", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(tabs)
}

// SetTopMargin sets the top margin for text in text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//    - topMargin: top margin in pixels.
//
func (textView *TextView) SetTopMargin(topMargin int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(topMargin)
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextView").InvokeMethod("set_top_margin", args[:], nil)

	runtime.KeepAlive(textView)
	runtime.KeepAlive(topMargin)
}

// StartsDisplayLine determines whether iter is at the start of a display line.
//
// See gtk.TextView.ForwardDisplayLine() for an explanation of display lines vs.
// paragraphs.
//
// The function takes the following parameters:
//
//    - iter: GtkTextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter begins a wrapped line.
//
func (textView *TextView) StartsDisplayLine(iter *TextIter) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**TextView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextView").InvokeMethod("starts_display_line", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

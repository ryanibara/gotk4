// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
		{T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
		{T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
		{T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextViewer},
	})
}

// TEXT_VIEW_PRIORITY_VALIDATE: priority at which the text view validates
// onscreen lines in an idle job in the background.
const TEXT_VIEW_PRIORITY_VALIDATE = 125

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection int

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = iota
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TextExtendSelection.
func (t TextExtendSelection) String() string {
	switch t {
	case TextExtendSelectionWord:
		return "Word"
	case TextExtendSelectionLine:
		return "Line"
	default:
		return fmt.Sprintf("TextExtendSelection(%d)", t)
	}
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer int

const (
	// TextViewLayerBelowText: layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = iota
	// TextViewLayerAboveText: layer rendered above the text.
	TextViewLayerAboveText
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TextViewLayer.
func (t TextViewLayer) String() string {
	switch t {
	case TextViewLayerBelowText:
		return "BelowText"
	case TextViewLayerAboveText:
		return "AboveText"
	default:
		return fmt.Sprintf("TextViewLayer(%d)", t)
	}
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType int

const (
	// TextWindowWidget: window that floats over scrolling areas.
	TextWindowWidget TextWindowType = 1
	// TextWindowText: scrollable text window.
	TextWindowText TextWindowType = 2
	// TextWindowLeft: left side border window.
	TextWindowLeft TextWindowType = 3
	// TextWindowRight: right side border window.
	TextWindowRight TextWindowType = 4
	// TextWindowTop: top border window.
	TextWindowTop TextWindowType = 5
	// TextWindowBottom: bottom border window.
	TextWindowBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TextWindowType.
func (t TextWindowType) String() string {
	switch t {
	case TextWindowWidget:
		return "Widget"
	case TextWindowText:
		return "Text"
	case TextWindowLeft:
		return "Left"
	case TextWindowRight:
		return "Right"
	case TextWindowTop:
		return "Top"
	case TextWindowBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("TextWindowType(%d)", t)
	}
}

// TextViewOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TextViewOverrider interface {
	Backspace()
	CopyClipboard()
	CutClipboard()
	DeleteFromCursor(typ DeleteType, count int)
	ExtendSelection(granularity TextExtendSelection, location *TextIter, start *TextIter, end *TextIter) bool
	InsertAtCursor(str string)
	InsertEmoji()
	MoveCursor(step MovementStep, count int, extendSelection bool)
	PasteClipboard()
	SetAnchor()
	SnapshotLayer(layer TextViewLayer, snapshot *Snapshot)
	ToggleOverwrite()
}

// TextView: widget that displays the contents of a gtk.TextBuffer.
//
// !An example GtkTextview (multiline-text.png)
//
// You may wish to begin by reading the conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
//
//
// Accessibility
//
// GtkTextView uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type TextView struct {
	Widget

	Scrollable
	*externglib.Object
}

func wrapTextView(obj *externglib.Object) *TextView {
	return &TextView{
		Widget: Widget{
			InitiallyUnowned: externglib.InitiallyUnowned{
				Object: obj,
			},
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
			Object: obj,
		},
		Scrollable: Scrollable{
			Object: obj,
		},
		Object: obj,
	}
}

func marshalTextViewer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTextView(obj), nil
}

// NewTextView creates a new GtkTextView.
//
// If you don’t call gtk.TextView.SetBuffer() before using the text view, an
// empty default buffer will be created for you. Get the buffer with
// gtk.TextView.GetBuffer(). If you want to specify your own buffer, consider
// gtk.TextView.NewWithBuffer.
func NewTextView() *TextView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_view_new()

	var _textView *TextView // out

	_textView = wrapTextView(externglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// NewTextViewWithBuffer creates a new GtkTextView widget displaying the buffer
// buffer.
//
// One buffer can be shared among many widgets. buffer may be NULL to create a
// default buffer, in which case this function is equivalent to
// gtk.TextView.New. The text view adds its own reference count to the buffer;
// it does not take over an existing reference.
func NewTextViewWithBuffer(buffer *TextBuffer) *TextView {
	var _arg1 *C.GtkTextBuffer // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_view_new_with_buffer(_arg1)
	runtime.KeepAlive(buffer)

	var _textView *TextView // out

	_textView = wrapTextView(externglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// AddChildAtAnchor adds a child widget in the text buffer, at the given anchor.
func (textView *TextView) AddChildAtAnchor(child Widgetter, anchor *TextChildAnchor) {
	var _arg0 *C.GtkTextView        // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(anchor)
}

// AddOverlay adds child at a fixed coordinate in the GtkTextView's text window.
//
// The xpos and ypos must be in buffer coordinates (see
// gtk.TextView.GetIterLocation() to convert to buffer coordinates).
//
// child will scroll with the text view.
//
// If instead you want a widget that will not move with the GtkTextView contents
// see Overlay.
func (textView *TextView) AddOverlay(child Widgetter, xpos int, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.int(xpos)
	_arg3 = C.int(ypos)

	C.gtk_text_view_add_overlay(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(xpos)
	runtime.KeepAlive(ypos)
}

// BackwardDisplayLine moves the given iter backward by one display (wrapped)
// line.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
func (textView *TextView) BackwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardDisplayLineStart moves the given iter backward to the next display
// line start.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
func (textView *TextView) BackwardDisplayLineStart(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferToWindowCoords converts buffer coordinates to window coordinates.
func (textView *TextView) BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = C.int(bufferX)
	_arg3 = C.int(bufferY)

	C.gtk_text_view_buffer_to_window_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)
	runtime.KeepAlive(bufferX)
	runtime.KeepAlive(bufferY)

	var _windowX int // out
	var _windowY int // out

	_windowX = int(_arg4)
	_windowY = int(_arg5)

	return _windowX, _windowY
}

// ForwardDisplayLine moves the given iter forward by one display (wrapped)
// line.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
func (textView *TextView) ForwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardDisplayLineEnd moves the given iter forward to the next display line
// end.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
func (textView *TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
//
// See gtk.TextView.SetAcceptsTab().
func (textView *TextView) AcceptsTab() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_accepts_tab(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BottomMargin gets the bottom margin for text in the text_view.
func (textView *TextView) BottomMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_bottom_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Buffer returns the GtkTextBuffer being displayed by this text view.
//
// The reference count on the buffer is not incremented; the caller of this
// function won’t own a new reference.
func (textView *TextView) Buffer() *TextBuffer {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_buffer(_arg0)
	runtime.KeepAlive(textView)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(externglib.Take(unsafe.Pointer(_cret)))

	return _textBuffer
}

// CursorLocations: determine the positions of the strong and weak cursors if
// the insertion point is at iter.
//
// The position of each cursor is stored as a zero-width rectangle. The strong
// cursor location is the location where characters of the directionality equal
// to the base direction of the paragraph are inserted. The weak cursor location
// is the location where characters of the directionality opposite to the base
// direction of the paragraph are inserted.
//
// If iter is NULL, the actual cursor position is used.
//
// Note that if iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations will
// be adjusted to account for the preedit cursor’s offset within the preedit
// sequence.
//
// The rectangle position is in buffer coordinates; use
// gtk.TextView.BufferToWindowCoords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (textView *TextView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in
	var _arg3 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if iter != nil {
		_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	C.gtk_text_view_get_cursor_locations(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _strong gdk.Rectangle // out
	var _weak gdk.Rectangle   // out

	_strong = *(*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_weak = *(*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _strong, _weak
}

// CursorVisible: find out whether the cursor should be displayed.
func (textView *TextView) CursorVisible() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_cursor_visible(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Editable returns the default editability of the GtkTextView.
//
// Tags in the buffer may override this setting for some ranges of text.
func (textView *TextView) Editable() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_editable(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExtraMenu gets the menu model that gets added to the context menu or NULL if
// none has been set.
func (textView *TextView) ExtraMenu() gio.MenuModeller {
	var _arg0 *C.GtkTextView // out
	var _cret *C.GMenuModel  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_extra_menu(_arg0)
	runtime.KeepAlive(textView)

	var _menuModel gio.MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(gio.MenuModeller)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// Gutter gets a GtkWidget that has previously been set as gutter.
//
// See gtk.TextView.SetGutter().
//
// win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
func (textView *TextView) Gutter(win TextWindowType) Widgetter {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.GtkTextWindowType(win)

	_cret = C.gtk_text_view_get_gutter(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(Widgetter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Indent gets the default indentation of paragraphs in text_view.
//
// Tags in the view’s buffer may override the default. The indentation may be
// negative.
func (textView *TextView) Indent() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_indent(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InputHints gets the input-hints of the GtkTextView.
func (textView *TextView) InputHints() InputHints {
	var _arg0 *C.GtkTextView  // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_input_hints(_arg0)
	runtime.KeepAlive(textView)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose gets the input-purpose of the GtkTextView.
func (textView *TextView) InputPurpose() InputPurpose {
	var _arg0 *C.GtkTextView    // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_input_purpose(_arg0)
	runtime.KeepAlive(textView)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// IterAtLocation retrieves the iterator at buffer coordinates x and y.
//
// Buffer coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you have
// to convert those to buffer coordinates with
// gtk.TextView.WindowToBufferCoords().
func (textView *TextView) IterAtLocation(x int, y int) (TextIter, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // out
	var _arg3 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg2 = C.int(x)
	_arg3 = C.int(y)

	_cret = C.gtk_text_view_get_iter_at_location(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _iter TextIter // out
	var _ok bool       // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates x and y.
//
// Buffer coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you have
// to convert those to buffer coordinates with
// gtk.TextView.WindowToBufferCoords().
//
// Note that this is different from gtk.TextView.GetIterAtLocation(), which
// returns cursor locations, i.e. positions between characters.
func (textView *TextView) IterAtPosition(x int, y int) (TextIter, int, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // in
	var _arg3 C.int          // out
	var _arg4 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	_cret = C.gtk_text_view_get_iter_at_position(_arg0, &_arg1, &_arg2, _arg3, _arg4)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _iter TextIter // out
	var _trailing int  // out
	var _ok bool       // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_trailing = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _trailing, _ok
}

// IterLocation gets a rectangle which roughly contains the character at iter.
//
// The rectangle position is in buffer coordinates; use
// gtk.TextView.BufferToWindowCoords() to convert these coordinates to
// coordinates for one of the windows in the text view.
func (textView *TextView) IterLocation(iter *TextIter) gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_text_view_get_iter_location(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _location gdk.Rectangle // out

	_location = *(*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _location
}

// Justification gets the default justification of paragraphs in text_view.
//
// Tags in the buffer may override the default.
func (textView *TextView) Justification() Justification {
	var _arg0 *C.GtkTextView     // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_justification(_arg0)
	runtime.KeepAlive(textView)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

// LeftMargin gets the default left margin size of paragraphs in the text_view.
//
// Tags in the buffer may override the default.
func (textView *TextView) LeftMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_left_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineAtY gets the GtkTextIter at the start of the line containing the
// coordinate y.
//
// y is in buffer coordinates, convert from window coordinates with
// gtk.TextView.WindowToBufferCoords(). If non-NULL, line_top will be filled
// with the coordinate of the top edge of the line.
func (textView *TextView) LineAtY(y int) (TextIter, int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // out
	var _arg3 C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg2 = C.int(y)

	C.gtk_text_view_get_line_at_y(_arg0, &_arg1, _arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(y)

	var _targetIter TextIter // out
	var _lineTop int         // out

	_targetIter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_lineTop = int(_arg3)

	return _targetIter, _lineTop
}

// LineYrange gets the y coordinate of the top of the line containing iter, and
// the height of the line.
//
// The coordinate is a buffer coordinate; convert to window coordinates with
// gtk.TextView.BufferToWindowCoords().
func (textView *TextView) LineYrange(iter *TextIter) (y int, height int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.int          // in
	var _arg3 C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _y int      // out
	var _height int // out

	_y = int(_arg2)
	_height = int(_arg3)

	return _y, _height
}

// Monospace gets whether the GtkTextView uses monospace styling.
func (textView *TextView) Monospace() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_monospace(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Overwrite returns whether the GtkTextView is in overwrite mode or not.
func (textView *TextView) Overwrite() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_overwrite(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PixelsAboveLines gets the default number of pixels to put above paragraphs.
//
// Adding this function with gtk.TextView.GetPixelsBelowLines() is equal to the
// line space between each paragraph.
func (textView *TextView) PixelsAboveLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelsBelowLines gets the default number of pixels to put below paragraphs.
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk.TextView.GetPixelsAboveLines().
func (textView *TextView) PixelsBelowLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelsInsideWrap gets the default number of pixels to put between wrapped
// lines inside a paragraph.
func (textView *TextView) PixelsInsideWrap() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RightMargin gets the default right margin for text in text_view.
//
// Tags in the buffer may override the default.
func (textView *TextView) RightMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_right_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Tabs gets the default tabs for text_view.
//
// Tags in the buffer may override the defaults. The returned array will be NULL
// if “standard” (8-space) tabs are used. Free the return value with
// pango.TabArray.Free().
func (textView *TextView) Tabs() *pango.TabArray {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_tabs(_arg0)
	runtime.KeepAlive(textView)

	var _tabArray *pango.TabArray // out

	if _cret != nil {
		_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tabArray)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
			},
		)
	}

	return _tabArray
}

// TopMargin gets the top margin for text in the text_view.
func (textView *TextView) TopMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_top_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VisibleRect fills visible_rect with the currently-visible region of the
// buffer, in buffer coordinates.
//
// Convert to window coordinates with gtk.TextView.BufferToWindowCoords().
func (textView *TextView) VisibleRect() gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	C.gtk_text_view_get_visible_rect(_arg0, &_arg1)
	runtime.KeepAlive(textView)

	var _visibleRect gdk.Rectangle // out

	_visibleRect = *(*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _visibleRect
}

// WrapMode gets the line wrapping for the view.
func (textView *TextView) WrapMode() WrapMode {
	var _arg0 *C.GtkTextView // out
	var _cret C.GtkWrapMode  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_get_wrap_mode(_arg0)
	runtime.KeepAlive(textView)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

// IMContextFilterKeypress: allow the GtkTextView input method to internally
// handle key press and release events.
//
// If this function returns TRUE, then no further processing should be done for
// this key event. See gtk.IMContext.FilterKeypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the GtkTextView.
//
//    static gboolean
//    gtk_foo_bar_key_press_event (GtkWidget *widget,
//                                 GdkEvent  *event)
//    {
//      guint keyval;
//
//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
//
//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//        {
//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//            return TRUE;
//        }
//
//      // Do some stuff
//
//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//    }
func (textView *TextView) IMContextFilterKeypress(event gdk.Eventer) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GdkEvent    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

	_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMarkOnscreen moves a mark within the buffer so that it's located within
// the currently-visible text area.
func (textView *TextView) MoveMarkOnscreen(mark *TextMark) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveOverlay updates the position of a child.
//
// See gtk.TextView.AddOverlay().
func (textView *TextView) MoveOverlay(child Widgetter, xpos int, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
	_arg2 = C.int(xpos)
	_arg3 = C.int(ypos)

	C.gtk_text_view_move_overlay(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(xpos)
	runtime.KeepAlive(ypos)
}

// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position.
//
// If count is positive, then the new strong cursor position will be count
// positions to the right of the old cursor position. If count is negative then
// the new strong cursor position will be count positions to the left of the old
// cursor position.
//
// In the presence of bi-directional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and there
// may be jumps when the cursor is moved off of the end of a run.
func (textView *TextView) MoveVisually(iter *TextIter, count int) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.int(count)

	_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceCursorOnscreen moves the cursor to the currently visible region of the
// buffer.
func (textView *TextView) PlaceCursorOnscreen() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes a child widget from text_view.
func (textView *TextView) Remove(child Widgetter) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

	C.gtk_text_view_remove(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
}

// ResetCursorBlink ensures that the cursor is shown.
//
// This also resets the time that it will stay blinking (or visible, in case
// blinking is disabled).
//
// This function should be called in response to user input (e.g. from derived
// classes that override the textview's event handlers).
func (textView *TextView) ResetCursorBlink() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	C.gtk_text_view_reset_cursor_blink(_arg0)
	runtime.KeepAlive(textView)
}

// ResetIMContext: reset the input method context of the text view if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (textView *TextView) ResetIMContext() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))

	C.gtk_text_view_reset_im_context(_arg0)
	runtime.KeepAlive(textView)
}

// ScrollMarkOnscreen scrolls text_view the minimum distance such that mark is
// contained within the visible area of the widget.
func (textView *TextView) ScrollMarkOnscreen(mark *TextMark) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)
}

// ScrollToIter scrolls text_view so that iter is on the screen in the position
// indicated by xalign and yalign.
//
// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5
// means center. If use_align is FALSE, the text scrolls the minimal distance to
// get the mark onscreen, possibly not scrolling at all. The effective screen
// for purposes of this function is reduced by a margin of size within_margin.
//
// Note that this function uses the currently-computed height of the lines in
// the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using gtk.TextView.ScrollToMark()
// which saves a point to be scrolled to after line validation.
func (textView *TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.double       // out
	var _arg3 C.gboolean     // out
	var _arg4 C.double       // out
	var _arg5 C.double       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.double(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.double(xalign)
	_arg5 = C.double(yalign)

	_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(withinMargin)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToMark scrolls text_view so that mark is on the screen in the position
// indicated by xalign and yalign.
//
// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5
// means center. If use_align is FALSE, the text scrolls the minimal distance to
// get the mark onscreen, possibly not scrolling at all. The effective screen
// for purposes of this function is reduced by a margin of size within_margin.
func (textView *TextView) ScrollToMark(mark *TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _arg2 C.double       // out
	var _arg3 C.gboolean     // out
	var _arg4 C.double       // out
	var _arg5 C.double       // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = C.double(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.double(xalign)
	_arg5 = C.double(yalign)

	C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(withinMargin)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
}

// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed.
//
// If accepts_tab is TRUE, a tab character is inserted. If accepts_tab is FALSE
// the keyboard focus is moved to the next widget in the focus chain.
func (textView *TextView) SetAcceptsTab(acceptsTab bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if acceptsTab {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(acceptsTab)
}

// SetBottomMargin sets the bottom margin for text in text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView *TextView) SetBottomMargin(bottomMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.int(bottomMargin)

	C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(bottomMargin)
}

// SetBuffer sets buffer as the buffer being displayed by text_view.
//
// The previous buffer displayed by the text view is unreferenced, and a
// reference is added to buffer. If you owned a reference to buffer before
// passing it to this function, you must remove that reference yourself;
// GtkTextView will not “adopt” it.
func (textView *TextView) SetBuffer(buffer *TextBuffer) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if buffer != nil {
		_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	}

	C.gtk_text_view_set_buffer(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(buffer)
}

// SetCursorVisible toggles whether the insertion point should be displayed.
//
// A buffer with no editable text probably shouldn’t have a visible cursor, so
// you may want to turn the cursor off.
//
// Note that this property may be overridden by the
// gtksettings:gtk-keynav-use-caret setting.
func (textView *TextView) SetCursorVisible(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(setting)
}

// SetEditable sets the default editability of the GtkTextView.
//
// You can override this default setting with tags in the buffer, using the
// “editable” attribute of tags.
func (textView *TextView) SetEditable(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_editable(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(setting)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// text_view.
//
// You can pass NULL to remove a previously set extra menu.
func (textView *TextView) SetExtraMenu(model gio.MenuModeller) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GMenuModel  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
	}

	C.gtk_text_view_set_extra_menu(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(model)
}

// SetGutter places widget into the gutter specified by win.
//
// win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
func (textView *TextView) SetGutter(win TextWindowType, widget Widgetter) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 *C.GtkWidget        // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.GtkTextWindowType(win)
	if widget != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
	}

	C.gtk_text_view_set_gutter(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)
	runtime.KeepAlive(widget)
}

// SetIndent sets the default indentation for paragraphs in text_view.
//
// Tags in the buffer may override the default.
func (textView *TextView) SetIndent(indent int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.int(indent)

	C.gtk_text_view_set_indent(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(indent)
}

// SetInputHints sets the input-hints of the GtkTextView.
//
// The input-hints allow input methods to fine-tune their behaviour.
func (textView *TextView) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkTextView  // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.GtkInputHints(hints)

	C.gtk_text_view_set_input_hints(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(hints)
}

// SetInputPurpose sets the input-purpose of the GtkTextView.
//
// The input-purpose can be used by on-screen keyboards and other input methods
// to adjust their behaviour.
func (textView *TextView) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkTextView    // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.GtkInputPurpose(purpose)

	C.gtk_text_view_set_input_purpose(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(purpose)
}

// SetJustification sets the default justification of text in text_view.
//
// Tags in the view’s buffer may override the default.
func (textView *TextView) SetJustification(justification Justification) {
	var _arg0 *C.GtkTextView     // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.GtkJustification(justification)

	C.gtk_text_view_set_justification(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(justification)
}

// SetLeftMargin sets the default left margin for text in text_view.
//
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView *TextView) SetLeftMargin(leftMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.int(leftMargin)

	C.gtk_text_view_set_left_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(leftMargin)
}

// SetMonospace sets whether the GtkTextView should display text in monospace
// styling.
func (textView *TextView) SetMonospace(monospace bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if monospace {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_monospace(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(monospace)
}

// SetOverwrite changes the GtkTextView overwrite mode.
func (textView *TextView) SetOverwrite(overwrite bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_overwrite(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(overwrite)
}

// SetPixelsAboveLines sets the default number of blank pixels above paragraphs
// in text_view.
//
// Tags in the buffer for text_view may override the defaults.
func (textView *TextView) SetPixelsAboveLines(pixelsAboveLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.int(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsAboveLines)
}

// SetPixelsBelowLines sets the default number of pixels of blank space to put
// below paragraphs in text_view.
//
// May be overridden by tags applied to text_view’s buffer.
func (textView *TextView) SetPixelsBelowLines(pixelsBelowLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.int(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsBelowLines)
}

// SetPixelsInsideWrap sets the default number of pixels of blank space to leave
// between display/wrapped lines within a paragraph.
//
// May be overridden by tags in text_view’s buffer.
func (textView *TextView) SetPixelsInsideWrap(pixelsInsideWrap int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.int(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsInsideWrap)
}

// SetRightMargin sets the default right margin for text in the text view.
//
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView *TextView) SetRightMargin(rightMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.int(rightMargin)

	C.gtk_text_view_set_right_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(rightMargin)
}

// SetTabs sets the default tab stops for paragraphs in text_view.
//
// Tags in the buffer may override the default.
func (textView *TextView) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabs)))

	C.gtk_text_view_set_tabs(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(tabs)
}

// SetTopMargin sets the top margin for text in text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
func (textView *TextView) SetTopMargin(topMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.int(topMargin)

	C.gtk_text_view_set_top_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(topMargin)
}

// SetWrapMode sets the line wrapping for the view.
func (textView *TextView) SetWrapMode(wrapMode WrapMode) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkWrapMode  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.GtkWrapMode(wrapMode)

	C.gtk_text_view_set_wrap_mode(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(wrapMode)
}

// StartsDisplayLine determines whether iter is at the start of a display line.
//
// See gtk.TextView.ForwardDisplayLine() for an explanation of display lines vs.
// paragraphs.
func (textView *TextView) StartsDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WindowToBufferCoords converts coordinates on the window identified by win to
// buffer coordinates.
func (textView *TextView) WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(textView.Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = C.int(windowX)
	_arg3 = C.int(windowY)

	C.gtk_text_view_window_to_buffer_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)
	runtime.KeepAlive(windowX)
	runtime.KeepAlive(windowY)

	var _bufferX int // out
	var _bufferY int // out

	_bufferX = int(_arg4)
	_bufferY = int(_arg5)

	return _bufferX, _bufferY
}

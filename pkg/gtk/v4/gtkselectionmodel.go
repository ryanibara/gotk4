// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern GtkBitset* _gotk4_gtk4_SelectionModelInterface_get_selection_in_range(void*, guint, guint);
// extern gboolean _gotk4_gtk4_SelectionModelInterface_is_selected(void*, guint);
// extern gboolean _gotk4_gtk4_SelectionModelInterface_select_all(void*);
// extern gboolean _gotk4_gtk4_SelectionModelInterface_select_item(void*, guint, gboolean);
// extern gboolean _gotk4_gtk4_SelectionModelInterface_select_range(void*, guint, guint, gboolean);
// extern gboolean _gotk4_gtk4_SelectionModelInterface_set_selection(void*, void*, void*);
// extern gboolean _gotk4_gtk4_SelectionModelInterface_unselect_all(void*);
// extern gboolean _gotk4_gtk4_SelectionModelInterface_unselect_item(void*, guint);
// extern gboolean _gotk4_gtk4_SelectionModelInterface_unselect_range(void*, guint, guint);
// extern void _gotk4_gtk4_SelectionModel_ConnectSelectionChanged(gpointer, guint, guint, guintptr);
import "C"

// GTypeSelectionModel returns the GType for the type SelectionModel.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeSelectionModel() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "SelectionModel").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalSelectionModel)
	return gtype
}

// SelectionModelOverrider contains methods that are overridable.
type SelectionModelOverrider interface {
	// SelectionInRange gets the set of selected items in a range.
	//
	// This function is an optimization for gtk.SelectionModel.GetSelection()
	// when you are only interested in part of the model's selected state. A
	// common use case is in response to the
	// gtk.SelectionModel::selection-changed signal.
	//
	// The function takes the following parameters:
	//
	//    - position: start of the queired range.
	//    - nItems: number of items in the queried range.
	//
	// The function returns the following values:
	//
	//    - bitset: GtkBitset that matches the selection state for the given
	//      range with all other values being undefined. The bitset must not be
	//      modified.
	//
	SelectionInRange(position, nItems uint32) *Bitset
	// IsSelected checks if the given item is selected.
	//
	// The function takes the following parameters:
	//
	//    - position of the item to query.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the item is selected.
	//
	IsSelected(position uint32) bool
	// SelectAll requests to select all items in the model.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if this action was supported and no fallback should be
	//      tried. This does not mean that all items are now selected.
	//
	SelectAll() bool
	// SelectItem requests to select an item in the model.
	//
	// The function takes the following parameters:
	//
	//    - position of the item to select.
	//    - unselectRest: whether previously selected items should be unselected.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if this action was supported and no fallback should be
	//      tried. This does not mean the item was selected.
	//
	SelectItem(position uint32, unselectRest bool) bool
	// SelectRange requests to select a range of items in the model.
	//
	// The function takes the following parameters:
	//
	//    - position: first item to select.
	//    - nItems: number of items to select.
	//    - unselectRest: whether previously selected items should be unselected.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if this action was supported and no fallback should be
	//      tried. This does not mean the range was selected.
	//
	SelectRange(position, nItems uint32, unselectRest bool) bool
	// SetSelection: make selection changes.
	//
	// This is the most advanced selection updating method that allows the most
	// fine-grained control over selection changes. If you can, you should try
	// the simpler versions, as implementations are more likely to implement
	// support for those.
	//
	// Requests that the selection state of all positions set in mask be updated
	// to the respective value in the selected bitmask.
	//
	// In pseudocode, it would look something like this:
	//
	//    for (i = 0; i < n_items; i++)
	//      {
	//        // don't change values not in the mask
	//        if (!gtk_bitset_contains (mask, i))
	//          continue;
	//
	//        if (gtk_bitset_contains (selected, i))
	//          select_item (i);
	//        else
	//          unselect_item (i);
	//      }
	//
	//    gtk_selection_model_selection_changed (model,
	//                                           first_changed_item,
	//                                           n_changed_items);
	//
	//
	// mask and selected must not be modified. They may refer to the same
	// bitset, which would mean that every item in the set should be selected.
	//
	// The function takes the following parameters:
	//
	//    - selected: bitmask specifying if items should be selected or
	//      unselected.
	//    - mask specifying which items should be updated.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if this action was supported and no fallback should be
	//      tried. This does not mean that all items were updated according to
	//      the inputs.
	//
	SetSelection(selected, mask *Bitset) bool
	// UnselectAll requests to unselect all items in the model.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if this action was supported and no fallback should be
	//      tried. This does not mean that all items are now unselected.
	//
	UnselectAll() bool
	// UnselectItem requests to unselect an item in the model.
	//
	// The function takes the following parameters:
	//
	//    - position of the item to unselect.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if this action was supported and no fallback should be
	//      tried. This does not mean the item was unselected.
	//
	UnselectItem(position uint32) bool
	// UnselectRange requests to unselect a range of items in the model.
	//
	// The function takes the following parameters:
	//
	//    - position: first item to unselect.
	//    - nItems: number of items to unselect.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if this action was supported and no fallback should be
	//      tried. This does not mean the range was unselected.
	//
	UnselectRange(position, nItems uint32) bool
}

// SelectionModel: GtkSelectionModel is an interface that add support for
// selection to list models.
//
// This support is then used by widgets using list models to add the ability to
// select and unselect various items.
//
// GTK provides default implementations of the most common selection modes such
// as gtk.SingleSelection, so you will only need to implement this interface if
// you want detailed control about how selections should be handled.
//
// A GtkSelectionModel supports a single boolean per item indicating if an item
// is selected or not. This can be queried via gtk.SelectionModel.IsSelected().
// When the selected state of one or more items changes, the model will emit the
// gtk.SelectionModel::selection-changed signal by calling the
// gtk.SelectionModel.SelectionChanged() function. The positions given in that
// signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the ::items-changed signal
// are selected or not is up to the implementation.
//
// Note that items added via ::items-changed may already be selected and no
// [Gtk.SelectionModel::selection-changed] will be emitted for them. So to track
// which items are selected, it is necessary to listen to both signals.
//
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow
// users to select and unselect items. However, GtkSelectionModels are free to
// only implement them partially or not at all. In that case the widgets will
// not support the unimplemented operations.
//
// When selecting or unselecting is supported by a model, the return values of
// the selection functions do *not* indicate if selection or unselection
// happened. They are only meant to indicate complete failure, like when this
// mode of selecting is not supported by the model.
//
// Selections may happen asynchronously, so the only reliable way to find out
// when an item was selected is to listen to the signals that indicate
// selection.
//
// SelectionModel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type SelectionModel struct {
	_ [0]func() // equal guard
	gio.ListModel
}

var ()

// SelectionModeller describes SelectionModel's interface methods.
type SelectionModeller interface {
	coreglib.Objector

	// Selection gets the set containing all currently selected items in the
	// model.
	Selection() *Bitset
	// SelectionInRange gets the set of selected items in a range.
	SelectionInRange(position, nItems uint32) *Bitset
	// IsSelected checks if the given item is selected.
	IsSelected(position uint32) bool
	// SelectAll requests to select all items in the model.
	SelectAll() bool
	// SelectItem requests to select an item in the model.
	SelectItem(position uint32, unselectRest bool) bool
	// SelectRange requests to select a range of items in the model.
	SelectRange(position, nItems uint32, unselectRest bool) bool
	// SelectionChanged: helper function for implementations of
	// GtkSelectionModel.
	SelectionChanged(position, nItems uint32)
	// SetSelection: make selection changes.
	SetSelection(selected, mask *Bitset) bool
	// UnselectAll requests to unselect all items in the model.
	UnselectAll() bool
	// UnselectItem requests to unselect an item in the model.
	UnselectItem(position uint32) bool
	// UnselectRange requests to unselect a range of items in the model.
	UnselectRange(position, nItems uint32) bool

	// Selection-changed is emitted when the selection state of some of the
	// items in model changes.
	ConnectSelectionChanged(func(position, nItems uint32)) coreglib.SignalHandle
}

var _ SelectionModeller = (*SelectionModel)(nil)

func ifaceInitSelectionModeller(gifacePtr, data C.gpointer) {
	iface := girepository.MustFind("Gtk", "SelectionModelInterface")
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("get_selection_in_range"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_get_selection_in_range)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("is_selected"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_is_selected)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("select_all"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_select_all)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("select_item"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_select_item)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("select_range"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_select_range)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("set_selection"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_set_selection)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("unselect_all"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_unselect_all)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("unselect_item"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_unselect_item)
	*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gifacePtr), pclass.StructFieldOffset("unselect_range"))) = unsafe.Pointer(C._gotk4_gtk4_SelectionModelInterface_unselect_range)
}

//export _gotk4_gtk4_SelectionModelInterface_get_selection_in_range
func _gotk4_gtk4_SelectionModelInterface_get_selection_in_range(arg0 *C.void, arg1 C.guint, arg2 C.guint) (cret *C.GtkBitset) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	var _position uint32 // out
	var _nItems uint32   // out

	_position = uint32(arg1)
	_nItems = uint32(arg2)

	bitset := iface.SelectionInRange(_position, _nItems)

	cret = (*C.void)(gextras.StructNative(unsafe.Pointer(bitset)))

	return cret
}

//export _gotk4_gtk4_SelectionModelInterface_is_selected
func _gotk4_gtk4_SelectionModelInterface_is_selected(arg0 *C.void, arg1 C.guint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	var _position uint32 // out

	_position = uint32(arg1)

	ok := iface.IsSelected(_position)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_SelectionModelInterface_select_all
func _gotk4_gtk4_SelectionModelInterface_select_all(arg0 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	ok := iface.SelectAll()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_SelectionModelInterface_select_item
func _gotk4_gtk4_SelectionModelInterface_select_item(arg0 *C.void, arg1 C.guint, arg2 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	var _position uint32   // out
	var _unselectRest bool // out

	_position = uint32(arg1)
	if arg2 != 0 {
		_unselectRest = true
	}

	ok := iface.SelectItem(_position, _unselectRest)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_SelectionModelInterface_select_range
func _gotk4_gtk4_SelectionModelInterface_select_range(arg0 *C.void, arg1 C.guint, arg2 C.guint, arg3 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	var _position uint32   // out
	var _nItems uint32     // out
	var _unselectRest bool // out

	_position = uint32(arg1)
	_nItems = uint32(arg2)
	if arg3 != 0 {
		_unselectRest = true
	}

	ok := iface.SelectRange(_position, _nItems, _unselectRest)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_SelectionModelInterface_set_selection
func _gotk4_gtk4_SelectionModelInterface_set_selection(arg0 *C.void, arg1 *C.void, arg2 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	var _selected *Bitset // out
	var _mask *Bitset     // out

	_selected = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.gtk_bitset_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_selected)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	_mask = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	C.gtk_bitset_ref(arg2)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_mask)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	ok := iface.SetSelection(_selected, _mask)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_SelectionModelInterface_unselect_all
func _gotk4_gtk4_SelectionModelInterface_unselect_all(arg0 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	ok := iface.UnselectAll()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_SelectionModelInterface_unselect_item
func _gotk4_gtk4_SelectionModelInterface_unselect_item(arg0 *C.void, arg1 C.guint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	var _position uint32 // out

	_position = uint32(arg1)

	ok := iface.UnselectItem(_position)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_SelectionModelInterface_unselect_range
func _gotk4_gtk4_SelectionModelInterface_unselect_range(arg0 *C.void, arg1 C.guint, arg2 C.guint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(SelectionModelOverrider)

	var _position uint32 // out
	var _nItems uint32   // out

	_position = uint32(arg1)
	_nItems = uint32(arg2)

	ok := iface.UnselectRange(_position, _nItems)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapSelectionModel(obj *coreglib.Object) *SelectionModel {
	return &SelectionModel{
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalSelectionModel(p uintptr) (interface{}, error) {
	return wrapSelectionModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_SelectionModel_ConnectSelectionChanged
func _gotk4_gtk4_SelectionModel_ConnectSelectionChanged(arg0 C.gpointer, arg1 C.guint, arg2 C.guint, arg3 C.guintptr) {
	var f func(position, nItems uint32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(position, nItems uint32))
	}

	var _position uint32 // out
	var _nItems uint32   // out

	_position = uint32(arg1)
	_nItems = uint32(arg2)

	f(_position, _nItems)
}

// ConnectSelectionChanged is emitted when the selection state of some of the
// items in model changes.
//
// Note that this signal does not specify the new selection state of the items,
// they need to be queried manually. It is also not necessary for a model to
// change the selection state of any of the items in the selection model, though
// it would be rather useless to emit such a signal.
func (model *SelectionModel) ConnectSelectionChanged(f func(position, nItems uint32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(model, "selection-changed", false, unsafe.Pointer(C._gotk4_gtk4_SelectionModel_ConnectSelectionChanged), f)
}

// Selection gets the set containing all currently selected items in the model.
//
// This function may be slow, so if you are only interested in single item,
// consider using gtk.SelectionModel.IsSelected() or if you are only interested
// in a few, consider gtk.SelectionModel.GetSelectionInRange().
//
// The function returns the following values:
//
//    - bitset: GtkBitset containing all the values currently selected in model.
//      If no items are selected, the bitset is empty. The bitset must not be
//      modified.
//
func (model *SelectionModel) Selection() *Bitset {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)

	var _bitset *Bitset // out

	_bitset = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bitset)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bitset
}

// SelectionInRange gets the set of selected items in a range.
//
// This function is an optimization for gtk.SelectionModel.GetSelection() when
// you are only interested in part of the model's selected state. A common use
// case is in response to the gtk.SelectionModel::selection-changed signal.
//
// The function takes the following parameters:
//
//    - position: start of the queired range.
//    - nItems: number of items in the queried range.
//
// The function returns the following values:
//
//    - bitset: GtkBitset that matches the selection state for the given range
//      with all other values being undefined. The bitset must not be modified.
//
func (model *SelectionModel) SelectionInRange(position, nItems uint32) *Bitset {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(position)
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(nItems)

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)

	var _bitset *Bitset // out

	_bitset = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bitset)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bitset
}

// IsSelected checks if the given item is selected.
//
// The function takes the following parameters:
//
//    - position of the item to query.
//
// The function returns the following values:
//
//    - ok: TRUE if the item is selected.
//
func (model *SelectionModel) IsSelected(position uint32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(position)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(position)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SelectAll requests to select all items in the model.
//
// The function returns the following values:
//
//    - ok: TRUE if this action was supported and no fallback should be tried.
//      This does not mean that all items are now selected.
//
func (model *SelectionModel) SelectAll() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SelectItem requests to select an item in the model.
//
// The function takes the following parameters:
//
//    - position of the item to select.
//    - unselectRest: whether previously selected items should be unselected.
//
// The function returns the following values:
//
//    - ok: TRUE if this action was supported and no fallback should be tried.
//      This does not mean the item was selected.
//
func (model *SelectionModel) SelectItem(position uint32, unselectRest bool) bool {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(position)
	if unselectRest {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(unselectRest)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SelectRange requests to select a range of items in the model.
//
// The function takes the following parameters:
//
//    - position: first item to select.
//    - nItems: number of items to select.
//    - unselectRest: whether previously selected items should be unselected.
//
// The function returns the following values:
//
//    - ok: TRUE if this action was supported and no fallback should be tried.
//      This does not mean the range was selected.
//
func (model *SelectionModel) SelectRange(position, nItems uint32, unselectRest bool) bool {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(position)
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(nItems)
	if unselectRest {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)
	runtime.KeepAlive(unselectRest)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SelectionChanged: helper function for implementations of GtkSelectionModel.
//
// Call this when a the selection changes to emit the
// gtk.SelectionModel::selection-changed signal.
//
// The function takes the following parameters:
//
//    - position: first changed item.
//    - nItems: number of changed items.
//
func (model *SelectionModel) SelectionChanged(position, nItems uint32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(position)
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(nItems)

	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)
}

// SetSelection: make selection changes.
//
// This is the most advanced selection updating method that allows the most
// fine-grained control over selection changes. If you can, you should try the
// simpler versions, as implementations are more likely to implement support for
// those.
//
// Requests that the selection state of all positions set in mask be updated to
// the respective value in the selected bitmask.
//
// In pseudocode, it would look something like this:
//
//    for (i = 0; i < n_items; i++)
//      {
//        // don't change values not in the mask
//        if (!gtk_bitset_contains (mask, i))
//          continue;
//
//        if (gtk_bitset_contains (selected, i))
//          select_item (i);
//        else
//          unselect_item (i);
//      }
//
//    gtk_selection_model_selection_changed (model,
//                                           first_changed_item,
//                                           n_changed_items);
//
//
// mask and selected must not be modified. They may refer to the same bitset,
// which would mean that every item in the set should be selected.
//
// The function takes the following parameters:
//
//    - selected: bitmask specifying if items should be selected or unselected.
//    - mask specifying which items should be updated.
//
// The function returns the following values:
//
//    - ok: TRUE if this action was supported and no fallback should be tried.
//      This does not mean that all items were updated according to the inputs.
//
func (model *SelectionModel) SetSelection(selected, mask *Bitset) bool {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(selected)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(mask)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(selected)
	runtime.KeepAlive(mask)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// UnselectAll requests to unselect all items in the model.
//
// The function returns the following values:
//
//    - ok: TRUE if this action was supported and no fallback should be tried.
//      This does not mean that all items are now unselected.
//
func (model *SelectionModel) UnselectAll() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// UnselectItem requests to unselect an item in the model.
//
// The function takes the following parameters:
//
//    - position of the item to unselect.
//
// The function returns the following values:
//
//    - ok: TRUE if this action was supported and no fallback should be tried.
//      This does not mean the item was unselected.
//
func (model *SelectionModel) UnselectItem(position uint32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(position)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(position)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// UnselectRange requests to unselect a range of items in the model.
//
// The function takes the following parameters:
//
//    - position: first item to unselect.
//    - nItems: number of items to unselect.
//
// The function returns the following values:
//
//    - ok: TRUE if this action was supported and no fallback should be tried.
//      This does not mean the range was unselected.
//
func (model *SelectionModel) UnselectRange(position, nItems uint32) bool {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(position)
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(nItems)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/gsk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gtk4_Widget_ConnectUnrealize(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectUnmap(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectStateFlagsChanged(gpointer, GtkStateFlags, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectShow(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectRealize(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectMoveFocus(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectMap(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectHide(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectDirectionChanged(gpointer, GtkTextDirection, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectDestroy(gpointer, guintptr);
// extern void _gotk4_gtk4_WidgetClass_unroot(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_unrealize(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_unmap(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_system_setting_changed(GtkWidget*, GtkSystemSetting);
// extern void _gotk4_gtk4_WidgetClass_state_flags_changed(GtkWidget*, GtkStateFlags);
// extern void _gotk4_gtk4_WidgetClass_snapshot(GtkWidget*, GtkSnapshot*);
// extern void _gotk4_gtk4_WidgetClass_size_allocate(GtkWidget*, int, int, int);
// extern void _gotk4_gtk4_WidgetClass_show(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_set_focus_child(GtkWidget*, GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_root(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_realize(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_move_focus(GtkWidget*, GtkDirectionType);
// extern void _gotk4_gtk4_WidgetClass_measure(GtkWidget*, GtkOrientation, int, int*, int*, int*, int*);
// extern void _gotk4_gtk4_WidgetClass_map(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_hide(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_direction_changed(GtkWidget*, GtkTextDirection);
// extern gboolean _gotk4_gtk4_Widget_ConnectQueryTooltip(gpointer, gint, gint, gboolean, GtkTooltip*, guintptr);
// extern gboolean _gotk4_gtk4_Widget_ConnectMnemonicActivate(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Widget_ConnectKeynavFailed(gpointer, GtkDirectionType, guintptr);
// extern gboolean _gotk4_gtk4_WidgetClass_query_tooltip(GtkWidget*, int, int, gboolean, GtkTooltip*);
// extern gboolean _gotk4_gtk4_WidgetClass_mnemonic_activate(GtkWidget*, gboolean);
// extern gboolean _gotk4_gtk4_WidgetClass_keynav_failed(GtkWidget*, GtkDirectionType);
// extern gboolean _gotk4_gtk4_WidgetClass_grab_focus(GtkWidget*);
// extern gboolean _gotk4_gtk4_WidgetClass_focus(GtkWidget*, GtkDirectionType);
// extern gboolean _gotk4_gtk4_WidgetClass_contains(GtkWidget*, double, double);
// extern gboolean _gotk4_gtk4_TickCallback(GtkWidget*, GdkFrameClock*, gpointer);
// extern GtkSizeRequestMode _gotk4_gtk4_WidgetClass_get_request_mode(GtkWidget*);
// GtkSizeRequestMode _gotk4_gtk4_Widget_virtual_get_request_mode(void* fnptr, GtkWidget* arg0) {
//   return ((GtkSizeRequestMode (*)(GtkWidget*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_Widget_virtual_contains(void* fnptr, GtkWidget* arg0, double arg1, double arg2) {
//   return ((gboolean (*)(GtkWidget*, double, double))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_Widget_virtual_focus(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   return ((gboolean (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_Widget_virtual_grab_focus(void* fnptr, GtkWidget* arg0) {
//   return ((gboolean (*)(GtkWidget*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_Widget_virtual_keynav_failed(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   return ((gboolean (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_Widget_virtual_mnemonic_activate(void* fnptr, GtkWidget* arg0, gboolean arg1) {
//   return ((gboolean (*)(GtkWidget*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_Widget_virtual_query_tooltip(void* fnptr, GtkWidget* arg0, int arg1, int arg2, gboolean arg3, GtkTooltip* arg4) {
//   return ((gboolean (*)(GtkWidget*, int, int, gboolean, GtkTooltip*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_Widget_virtual_direction_changed(void* fnptr, GtkWidget* arg0, GtkTextDirection arg1) {
//   ((void (*)(GtkWidget*, GtkTextDirection))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_hide(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_map(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_measure(void* fnptr, GtkWidget* arg0, GtkOrientation arg1, int arg2, int* arg3, int* arg4, int* arg5, int* arg6) {
//   ((void (*)(GtkWidget*, GtkOrientation, int, int*, int*, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gtk4_Widget_virtual_move_focus(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   ((void (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_realize(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_root(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_set_focus_child(void* fnptr, GtkWidget* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkWidget*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_show(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_size_allocate(void* fnptr, GtkWidget* arg0, int arg1, int arg2, int arg3) {
//   ((void (*)(GtkWidget*, int, int, int))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_Widget_virtual_snapshot(void* fnptr, GtkWidget* arg0, GtkSnapshot* arg1) {
//   ((void (*)(GtkWidget*, GtkSnapshot*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_state_flags_changed(void* fnptr, GtkWidget* arg0, GtkStateFlags arg1) {
//   ((void (*)(GtkWidget*, GtkStateFlags))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_system_setting_changed(void* fnptr, GtkWidget* arg0, GtkSystemSetting arg1) {
//   ((void (*)(GtkWidget*, GtkSystemSetting))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_unmap(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_unrealize(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_unroot(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeWidget      = coreglib.Type(C.gtk_widget_get_type())
	GTypeRequisition = coreglib.Type(C.gtk_requisition_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWidget, F: marshalWidget},
		coreglib.TypeMarshaler{T: GTypeRequisition, F: marshalRequisition},
	})
}

// Allocation: rectangle representing the area allocated for a widget by its
// parent.
type Allocation = gdk.Rectangle

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func(widget Widgetter, frameClock gdk.FrameClocker) (ok bool)

// WidgetOverrides contains methods that are overridable.
type WidgetOverrides struct {
	// Contains tests if the point at (x, y) is contained in widget.
	//
	// The coordinates for (x, y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of widget's content area.
	//
	// The function takes the following parameters:
	//
	//    - x: x coordinate to test, relative to widget's origin.
	//    - y: y coordinate to test, relative to widget's origin.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if widget contains (x, y).
	//
	Contains func(x, y float64) bool
	// The function takes the following parameters:
	//
	DirectionChanged func(previousDirection TextDirection)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Focus func(direction DirectionType) bool
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Single-child widgets generally propagate the preference of their child,
	// more complex widgets need to request something either in context of their
	// children or in context of their allocation capabilities.
	//
	// The function returns the following values:
	//
	//    - sizeRequestMode: GtkSizeRequestMode preferred by widget.
	//
	RequestMode func() SizeRequestMode
	// GrabFocus causes widget to have the keyboard focus for the GtkWindow it's
	// inside.
	//
	// If widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of widget that is focusable, it will
	// not take focus and FALSE will be returned.
	//
	// Calling gtk.Widget.GrabFocus() on an already focused widget is allowed,
	// should not have an effect, and return TRUE.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if focus is now inside widget.
	//
	GrabFocus func() bool
	// Hide reverses the effects of gtk_widget_show().
	//
	// This is causing the widget to be hidden (invisible to the user).
	Hide func()
	// KeynavFailed emits the ::keynav-failed signal on the widget.
	//
	// This function should be called whenever keyboard navigation within a
	// single widget hits a boundary.
	//
	// The return value of this function should be interpreted in a way similar
	// to the return value of gtk.Widget.ChildFocus(). When TRUE is returned,
	// stay in the widget, the failed keyboard navigation is OK and/or there is
	// nowhere we can/should move the focus to. When FALSE is returned, the
	// caller should continue with keyboard navigation outside the widget, e.g.
	// by calling gtk.Widget.ChildFocus() on the widget’s toplevel.
	//
	// The default gtk.Widget::keynav-failed handler returns FALSE for
	// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
	// DirectionType it returns TRUE.
	//
	// Whenever the default handler returns TRUE, it also calls
	// gtk.Widget.ErrorBell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of gtk.Entry
	// widgets where the user should be able to navigate the entire row with the
	// cursor keys, as e.g. known from user interfaces that require entering
	// license keys.
	//
	// The function takes the following parameters:
	//
	//    - direction of focus movement.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if stopping keyboard navigation is fine, FALSE if the
	//      emitting widget should try to handle the keyboard navigation attempt
	//      in its parent container(s).
	//
	KeynavFailed func(direction DirectionType) bool
	// Map causes a widget to be mapped if it isn’t already.
	//
	// This function is only for use in widget implementations.
	Map func()
	// Measure measures widget in the orientation orientation and for the given
	// for_size.
	//
	// As an example, if orientation is GTK_ORIENTATION_HORIZONTAL and for_size
	// is 300, this functions will compute the minimum and natural width of
	// widget if it is allocated at a height of 300 pixels.
	//
	// See GtkWidget’s geometry management section
	// (class.Widget.html#height-for-width-geometry-management) for a more
	// details on implementing WidgetClass.measure().
	//
	// The function takes the following parameters:
	//
	//    - orientation to measure.
	//    - forSize: size for the opposite of orientation, i.e. if orientation is
	//      GTK_ORIENTATION_HORIZONTAL, this is the height the widget should be
	//      measured with. The GTK_ORIENTATION_VERTICAL case is analogous. This
	//      way, both height-for-width and width-for-height requests can be
	//      implemented. If no size is known, -1 can be passed.
	//
	// The function returns the following values:
	//
	//    - minimum (optional): location to store the minimum size, or NULL.
	//    - natural (optional): location to store the natural size, or NULL.
	//    - minimumBaseline (optional): location to store the baseline position
	//      for the minimum size, or NULL.
	//    - naturalBaseline (optional): location to store the baseline position
	//      for the natural size, or NULL.
	//
	Measure func(orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int)
	// MnemonicActivate emits the GtkWidget::mnemonic-activate signal.
	//
	// The function takes the following parameters:
	//
	//    - groupCycling: TRUE if there are other widgets with the same mnemonic.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the signal has been handled.
	//
	MnemonicActivate func(groupCycling bool) bool
	// The function takes the following parameters:
	//
	MoveFocus func(direction DirectionType)
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - keyboardTooltip
	//    - tooltip
	//
	// The function returns the following values:
	//
	QueryTooltip func(x, y int, keyboardTooltip bool, tooltip *Tooltip) bool
	// Realize creates the GDK resources associated with a widget.
	//
	// Normally realization happens implicitly; if you show a widget and all its
	// parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling this function realizes the widget’s parents in addition
	// to widget itself. If a widget is not yet inside a toplevel window when
	// you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as gtk.Widget::realize.
	Realize func()
	Root    func()
	// SetFocusChild: set child as the current focus child of widget.
	//
	// The previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call gtk.Widget.GrabFocus() on it.
	//
	// The function takes the following parameters:
	//
	//    - child (optional): direct child widget of widget or NULL to unset the
	//      focus child of widget.
	//
	SetFocusChild func(child Widgetter)
	// Show flags a widget to be displayed.
	//
	// Any widget that isn’t shown will not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show func()
	// The function takes the following parameters:
	//
	//    - width
	//    - height
	//    - baseline
	//
	SizeAllocate func(width, height, baseline int)
	// The function takes the following parameters:
	//
	Snapshot func(snapshot *Snapshot)
	// The function takes the following parameters:
	//
	StateFlagsChanged func(previousStateFlags StateFlags)
	// The function takes the following parameters:
	//
	SystemSettingChanged func(settings SystemSetting)
	// Unmap causes a widget to be unmapped if it’s currently mapped.
	//
	// This function is only for use in widget implementations.
	Unmap func()
	// Unrealize causes a widget to be unrealized (frees all GDK resources
	// associated with the widget).
	//
	// This function is only useful in widget implementations.
	Unrealize func()
	Unroot    func()
}

func defaultWidgetOverrides(v *Widget) WidgetOverrides {
	return WidgetOverrides{
		Contains:             v.contains,
		DirectionChanged:     v.directionChanged,
		Focus:                v.focus,
		RequestMode:          v.requestMode,
		GrabFocus:            v.grabFocus,
		Hide:                 v.hide,
		KeynavFailed:         v.keynavFailed,
		Map:                  v._map,
		Measure:              v.measure,
		MnemonicActivate:     v.mnemonicActivate,
		MoveFocus:            v.moveFocus,
		QueryTooltip:         v.queryTooltip,
		Realize:              v.realize,
		Root:                 v.root,
		SetFocusChild:        v.setFocusChild,
		Show:                 v.show,
		SizeAllocate:         v.sizeAllocate,
		Snapshot:             v.snapshot,
		StateFlagsChanged:    v.stateFlagsChanged,
		SystemSettingChanged: v.systemSettingChanged,
		Unmap:                v.unmap,
		Unrealize:            v.unrealize,
		Unroot:               v.unroot,
	}
}

// Widget: base class for all widgets.
//
// GtkWidget is the base class all widgets in GTK derive from. It manages the
// widget lifecycle, layout, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
//
// - gtk.Widget.GetRequestMode()
//
// - gtk.Widget.Measure()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct GtkWidget subclass that supports height-for-width
// or width-for-height geometry management for itself or its child widgets, the
// gtk.Widget.GetRequestMode() virtual function must be implemented as well and
// return the widget's preferred request mode. The default implementation of
// this virtual function returns GTK_SIZE_REQUEST_CONSTANT_SIZE, which means
// that the widget will only ever get -1 passed as the for_size value to its
// gtk.Widget.Measure() implementation.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the gtk.SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode:
//
// First, the default minimum and natural width for each widget in the interface
// will be computed using gtk_widget_measure with an orientation of
// GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred widths
// for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use the
// minimum width to query for the minimum height contextual to that width using
// gtk_widget_measure with an orientation of GTK_ORIENTATION_VERTICAL and a
// for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk.Window.SetDefaultSize()). During the recursive allocation
// process it’s important to note that request cycles will be recursively
// executed while widgets allocate their children. Each widget, once allocated a
// size, will go on to first share the space in one orientation among its
// children and then request each child's height for its target allocated width
// or its width for allocated height, depending. In this way a GtkWidget will
// typically be requested its size a number of times before actually being
// allocated a size. The size a widget is finally allocated can of course differ
// from the size it has requested. For this reason, GtkWidget caches a small
// number of results to avoid re-querying for the same sizes in one allocation
// cycle.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both GtkSizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a gtk.Label that does height-for-width word wrapping will not
// expect to have gtk.Widget.Measure() with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
//    static void
//    foo_widget_measure (GtkWidget      *widget,
//                        GtkOrientation  orientation,
//                        int             for_size,
//                        int            *minimum_size,
//                        int            *natural_size,
//                        int            *minimum_baseline,
//                        int            *natural_baseline)
//    {
//      if (orientation == GTK_ORIENTATION_HORIZONTAL)
//        {
//          // Calculate minimum and natural width
//        }
//      else // VERTICAL
//        {
//          if (i_am_in_height_for_width_mode)
//            {
//              int min_width, dummy;
//
//              // First, get the minimum width of our widget
//              GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//                                                      &min_width, &dummy, &dummy, &dummy);
//
//              // Now use the minimum width to retrieve the minimum and natural height to display
//              // that width.
//              GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//                                                      minimum_size, natural_size, &dummy, &dummy);
//            }
//          else
//            {
//              // ... some widgets do both.
//            }
//        }
//    }
//
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also compute
// width. Or when deciding how to use an allocation, the widget may need to know
// its natural size. In these cases, the widget should be careful to call its
// virtual methods directly, like in the code example above.
//
// It will not work to use the wrapper function gtk.Widget.Measure() inside your
// own gtk.Widget.SizeAllocate() implementation. These return a request adjusted
// by gtk.SizeGroup, the widget's align and expand flags, as well as its CSS
// style.
//
// If a widget used the wrappers inside its virtual method implementations, then
// the adjustments (such as widget margins) would be applied twice. GTK
// therefore does not allow this and will warn if you try to do it.
//
// Of course if you are getting the size request for another widget, such as a
// child widget, you must use gtk_widget_measure; otherwise, you would not
// properly consider widget margins, gtk.SizeGroup, and so forth.
//
// GTK also supports baseline vertical alignment of widgets. This means that
// widgets are positioned such that the typographical baseline of widgets in the
// same row are aligned. This happens if a widget supports baselines, has a
// vertical alignment of GTK_ALIGN_BASELINE, and is inside a widget that
// supports baselines and has a natural “row” that it aligns to the baseline, or
// a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is also done by the
// gtk.Widget.Measure() virtual function. It allows you to report both a minimum
// and natural size.
//
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was GTK_ALIGN_FILL, but the selected baseline can be
// found via gtk_widget_get_allocated_baseline. If the baseline has a value
// other than -1 you need to align the widget such that the baseline appears at
// the position.
//
//
// GtkWidget as GtkBuildable
//
// The GtkWidget implementation of the GtkBuildable interface supports various
// custom elements to specify additional aspects of widgets that are not
// directly expressed as properties.
//
// If the widget uses a gtk.LayoutManager, GtkWidget supports a custom <layout>
// element, used to define layout properties:
//
//    <object class="GtkGrid" id="my_grid">
//      <child>
//        <object class="GtkLabel" id="label1">
//          <property name="label">Description</property>
//          <layout>
//            <property name="column">0</property>
//            <property name="row">0</property>
//            <property name="row-span">1</property>
//            <property name="column-span">1</property>
//          </layout>
//        </object>
//      </child>
//      <child>
//        <object class="GtkEntry" id="description_entry">
//          <layout>
//            <property name="column">1</property>
//            <property name="row">0</property>
//            <property name="row-span">1</property>
//            <property name="column-span">1</property>
//          </layout>
//        </object>
//      </child>
//    </object>
//
//
// GtkWidget allows style information such as style classes to be associated
// with widgets, using the custom <style> element:
//
//    <object class="GtkButton" id="button1">
//      <style>
//        <class name="my-special-button-class"/>
//        <class name="dark-button"/>
//      </style>
//    </object>
//
//
// GtkWidget allows defining accessibility information, such as properties,
// relations, and states, using the custom <accessibility> element:
//
//    <object class="GtkButton" id="button1">
//      <accessibility>
//        <property name="label">Download</property>
//        <relation name="labelled-by">label1</relation>
//      </accessibility>
//    </object>
//
//
//
// Building composite widgets from template XML
//
// GtkWidget exposes some facilities to automate the procedure of creating
// composite widgets using "templates".
//
// To create composite widgets with GtkBuilder XML, one must associate the
// interface description with the widget class at class initialization time
// using gtk.WidgetClass.SetTemplate().
//
// The interface description semantics expected in composite template
// descriptions is slightly different from regular gtk.Builder XML.
//
// Unlike regular interface descriptions, gtk.WidgetClass.SetTemplate() will
// expect a <template> tag as a direct child of the toplevel <interface> tag.
// The <template> tag must specify the “class” attribute which must be the type
// name of the widget. Optionally, the “parent” attribute may be specified to
// specify the direct parent type of the widget type, this is ignored by
// GtkBuilder but required for UI design tools like Glade
// (https://glade.gnome.org/) to introspect what kind of properties and internal
// children exist for a given type when the actual type does not exist.
//
// The XML which is contained inside the <template> tag behaves as if it were
// added to the <object> tag defining the widget itself. You may set properties
// on a widget by inserting <property> tags into the <template> tag, and also
// add <child> tags to add children and extend a widget in the normal way you
// would with <object> tags.
//
// Additionally, <object> tags can also be added before and after the initial
// <template> tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// <template> tag.
//
// An example of a template definition:
//
//    <interface>
//      <template class="FooWidget" parent="GtkBox">
//        <property name="orientation">horizontal</property>
//        <property name="spacing">4</property>
//        <child>
//          <object class="GtkButton" id="hello_button">
//            <property name="label">Hello World</property>
//            <signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/>
//          </object>
//        </child>
//        <child>
//          <object class="GtkButton" id="goodbye_button">
//            <property name="label">Goodbye World</property>
//          </object>
//        </child>
//      </template>
//    </interface>
//
//
// Typically, you'll place the template fragment into a file that is bundled
// with your project, using GResource. In order to load the template, you need
// to call gtk.WidgetClass.SetTemplateFromResource() from the class
// initialization of your GtkWidget type:
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//    }
//
//
// You will also need to call gtk.Widget.InitTemplate() from the instance
// initialization function:
//
//    static void
//    foo_widget_init (FooWidget *self)
//    {
//      // ...
//      gtk_widget_init_template (GTK_WIDGET (self));
//    }
//
//
// You can access widgets defined in the template using the
// gtk_widget_get_template_child function, but you will typically declare a
// pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// gtk.WidgetClass.BindTemplateChildFull() (or one of its wrapper macros
// gtk.WidgetClassBindTemplateChild() and
// gtk.WidgetClassBindTemplateChildPrivate()) with that name, e.g.
//
//    typedef struct {
//      GtkWidget *hello_button;
//      GtkWidget *goodbye_button;
//    } FooWidgetPrivate;
//
//    G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//                                                    FooWidget, hello_button);
//      gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//                                                    FooWidget, goodbye_button);
//    }
//
//    static void
//    foo_widget_init (FooWidget *widget)
//    {
//
//    }
//
//
// You can also use gtk.WidgetClass.BindTemplateCallbackFull() (or is wrapper
// macro gtk.WidgetClassBindTemplateCallback()) to connect a signal callback
// defined in the template with a function visible in the scope of the class,
// e.g.
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }.
type Widget struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned

	*coreglib.Object
	Accessible
	Buildable
	ConstraintTarget
}

var (
	_ coreglib.Objector = (*Widget)(nil)
)

// Widgetter describes types inherited from class Widget.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Widgetter interface {
	coreglib.Objector
	baseWidget() *Widget
}

var _ Widgetter = (*Widget)(nil)

func init() {
	coreglib.RegisterClassInfo[*Widget, *WidgetClass, WidgetOverrides](
		GTypeWidget,
		initWidgetClass,
		wrapWidget,
		defaultWidgetOverrides,
	)
}

func initWidgetClass(gclass unsafe.Pointer, overrides WidgetOverrides, classInitFunc func(*WidgetClass)) {
	pclass := (*C.GtkWidgetClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeWidget))))

	if overrides.Contains != nil {
		pclass.contains = (*[0]byte)(C._gotk4_gtk4_WidgetClass_contains)
	}

	if overrides.DirectionChanged != nil {
		pclass.direction_changed = (*[0]byte)(C._gotk4_gtk4_WidgetClass_direction_changed)
	}

	if overrides.Focus != nil {
		pclass.focus = (*[0]byte)(C._gotk4_gtk4_WidgetClass_focus)
	}

	if overrides.RequestMode != nil {
		pclass.get_request_mode = (*[0]byte)(C._gotk4_gtk4_WidgetClass_get_request_mode)
	}

	if overrides.GrabFocus != nil {
		pclass.grab_focus = (*[0]byte)(C._gotk4_gtk4_WidgetClass_grab_focus)
	}

	if overrides.Hide != nil {
		pclass.hide = (*[0]byte)(C._gotk4_gtk4_WidgetClass_hide)
	}

	if overrides.KeynavFailed != nil {
		pclass.keynav_failed = (*[0]byte)(C._gotk4_gtk4_WidgetClass_keynav_failed)
	}

	if overrides.Map != nil {
		pclass._map = (*[0]byte)(C._gotk4_gtk4_WidgetClass_map)
	}

	if overrides.Measure != nil {
		pclass.measure = (*[0]byte)(C._gotk4_gtk4_WidgetClass_measure)
	}

	if overrides.MnemonicActivate != nil {
		pclass.mnemonic_activate = (*[0]byte)(C._gotk4_gtk4_WidgetClass_mnemonic_activate)
	}

	if overrides.MoveFocus != nil {
		pclass.move_focus = (*[0]byte)(C._gotk4_gtk4_WidgetClass_move_focus)
	}

	if overrides.QueryTooltip != nil {
		pclass.query_tooltip = (*[0]byte)(C._gotk4_gtk4_WidgetClass_query_tooltip)
	}

	if overrides.Realize != nil {
		pclass.realize = (*[0]byte)(C._gotk4_gtk4_WidgetClass_realize)
	}

	if overrides.Root != nil {
		pclass.root = (*[0]byte)(C._gotk4_gtk4_WidgetClass_root)
	}

	if overrides.SetFocusChild != nil {
		pclass.set_focus_child = (*[0]byte)(C._gotk4_gtk4_WidgetClass_set_focus_child)
	}

	if overrides.Show != nil {
		pclass.show = (*[0]byte)(C._gotk4_gtk4_WidgetClass_show)
	}

	if overrides.SizeAllocate != nil {
		pclass.size_allocate = (*[0]byte)(C._gotk4_gtk4_WidgetClass_size_allocate)
	}

	if overrides.Snapshot != nil {
		pclass.snapshot = (*[0]byte)(C._gotk4_gtk4_WidgetClass_snapshot)
	}

	if overrides.StateFlagsChanged != nil {
		pclass.state_flags_changed = (*[0]byte)(C._gotk4_gtk4_WidgetClass_state_flags_changed)
	}

	if overrides.SystemSettingChanged != nil {
		pclass.system_setting_changed = (*[0]byte)(C._gotk4_gtk4_WidgetClass_system_setting_changed)
	}

	if overrides.Unmap != nil {
		pclass.unmap = (*[0]byte)(C._gotk4_gtk4_WidgetClass_unmap)
	}

	if overrides.Unrealize != nil {
		pclass.unrealize = (*[0]byte)(C._gotk4_gtk4_WidgetClass_unrealize)
	}

	if overrides.Unroot != nil {
		pclass.unroot = (*[0]byte)(C._gotk4_gtk4_WidgetClass_unroot)
	}

	if classInitFunc != nil {
		class := (*WidgetClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWidget(obj *coreglib.Object) *Widget {
	return &Widget{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		Accessible: Accessible{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
		ConstraintTarget: ConstraintTarget{
			Object: obj,
		},
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	return wrapWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (widget *Widget) baseWidget() *Widget {
	return widget
}

// BaseWidget returns the underlying base object.
func BaseWidget(obj Widgetter) *Widget {
	return obj.baseWidget()
}

// ConnectDestroy signals that all holders of a reference to the widget should
// release the reference that they hold.
//
// May result in finalization of the widget if all references are released.
//
// This signal is not suitable for saving widget state.
func (widget *Widget) ConnectDestroy(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "destroy", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectDestroy), f)
}

// ConnectDirectionChanged is emitted when the text direction of a widget
// changes.
func (widget *Widget) ConnectDirectionChanged(f func(previousDirection TextDirection)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "direction-changed", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectDirectionChanged), f)
}

// ConnectHide is emitted when widget is hidden.
func (widget *Widget) ConnectHide(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "hide", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectHide), f)
}

// ConnectKeynavFailed is emitted if keyboard navigation fails.
//
// See gtk.Widget.KeynavFailed() for details.
func (widget *Widget) ConnectKeynavFailed(f func(direction DirectionType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "keynav-failed", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectKeynavFailed), f)
}

// ConnectMap is emitted when widget is going to be mapped.
//
// A widget is mapped when the widget is visible (which is controlled with
// gtk.Widget:visible) and all its parents up to the toplevel widget are also
// visible.
//
// The ::map signal can be used to determine whether a widget will be drawn, for
// instance it can resume an animation that was stopped during the emission of
// gtk.Widget::unmap.
func (widget *Widget) ConnectMap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "map", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectMap), f)
}

// ConnectMnemonicActivate is emitted when a widget is activated via a mnemonic.
//
// The default handler for this signal activates widget if group_cycling is
// FALSE, or just makes widget grab focus if group_cycling is TRUE.
func (widget *Widget) ConnectMnemonicActivate(f func(groupCycling bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "mnemonic-activate", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectMnemonicActivate), f)
}

// ConnectMoveFocus is emitted when the focus is moved.
func (widget *Widget) ConnectMoveFocus(f func(direction DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "move-focus", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectMoveFocus), f)
}

// ConnectQueryTooltip is emitted when the widgets tooltip is about to be shown.
//
// This happens when the gtk.Widget:has-tooltip property is TRUE and the hover
// timeout has expired with the cursor hovering "above" widget; or emitted when
// widget got focus in keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether a
// tooltip should be shown for widget. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
func (widget *Widget) ConnectQueryTooltip(f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectQueryTooltip), f)
}

// ConnectRealize is emitted when widget is associated with a GdkSurface.
//
// This means that gtk.Widget.Realize() has been called or the widget has been
// mapped (that is, it is going to be drawn).
func (widget *Widget) ConnectRealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "realize", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectRealize), f)
}

// ConnectShow is emitted when widget is shown.
func (widget *Widget) ConnectShow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "show", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectShow), f)
}

// ConnectStateFlagsChanged is emitted when the widget state changes.
//
// See gtk.Widget.GetStateFlags().
func (widget *Widget) ConnectStateFlagsChanged(f func(flags StateFlags)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "state-flags-changed", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectStateFlagsChanged), f)
}

// ConnectUnmap is emitted when widget is going to be unmapped.
//
// A widget is unmapped when either it or any of its parents up to the toplevel
// widget have been set as hidden.
//
// As ::unmap indicates that a widget will not be shown any longer, it can be
// used to, for example, stop an animation on the widget.
func (widget *Widget) ConnectUnmap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unmap", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectUnmap), f)
}

// ConnectUnrealize is emitted when the GdkSurface associated with widget is
// destroyed.
//
// This means that gtk.Widget.Unrealize() has been called or the widget has been
// unmapped (that is, it is going to be hidden).
func (widget *Widget) ConnectUnrealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unrealize", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectUnrealize), f)
}

// ActionSetEnabled: enable or disable an action installed with
// gtk_widget_class_install_action().
//
// The function takes the following parameters:
//
//    - actionName: action name, such as "clipboard.paste".
//    - enabled: whether the action is now enabled.
//
func (widget *Widget) ActionSetEnabled(actionName string, enabled bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if enabled {
		_arg2 = C.TRUE
	}

	C.gtk_widget_action_set_enabled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(enabled)
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them.
//
// The activation will emit the signal set using
// gtk_widget_class_set_activate_signal() during class initialization.
//
// Activation is what happens when you press Enter on a widget during key
// navigation.
//
// If you wish to handle the activation keybinding yourself, it is recommended
// to use gtk_widget_class_add_shortcut() with an action created with
// gtk_signal_action_new().
//
// If widget isn't activatable, the function returns FALSE.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget was activatable.
//
func (widget *Widget) Activate() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_activate(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateAction looks up the action in the action groups associated with
// widget and its ancestors, and activates it.
//
// If the action is in an action group added with
// gtk.Widget.InsertActionGroup(), the name is expected to be prefixed with the
// prefix that was used when the group was inserted.
//
// The arguments must match the actions expected parameter type, as returned by
// g_action_get_parameter_type().
//
// The function takes the following parameters:
//
//    - name of the action to activate.
//    - args (optional) parameters to use, or NULL.
//
// The function returns the following values:
//
//    - ok: TRUE if the action was activated, FALSE if the action does not exist.
//
func (widget *Widget) ActivateAction(name string, args *glib.Variant) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _arg2 *C.GVariant  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if args != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(args)))
	}

	_cret = C.gtk_widget_activate_action_variant(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
	runtime.KeepAlive(args)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateDefault activates the default.activate action from widget.
func (widget *Widget) ActivateDefault() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_activate_default(_arg0)
	runtime.KeepAlive(widget)
}

// AddController adds controller to widget so that it will receive events.
//
// You will usually want to call this function right after creating any kind of
// gtk.EventController.
//
// The function takes the following parameters:
//
//    - controller that hasn't been added to a widget yet.
//
func (widget *Widget) AddController(controller EventControllerer) {
	var _arg0 *C.GtkWidget          // out
	var _arg1 *C.GtkEventController // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(controller).Native()))

	C.gtk_widget_add_controller(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(controller)
}

// AddCSSClass adds a style class to widget.
//
// After calling this function, the widgets style will match for css_class,
// according to CSS matching rules.
//
// Use gtk.Widget.RemoveCSSClass() to remove the style again.
//
// The function takes the following parameters:
//
//    - cssClass: style class to add to widget, without the leading '.' used for
//      notation of style classes.
//
func (widget *Widget) AddCSSClass(cssClass string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(cssClass)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_add_css_class(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cssClass)
}

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget.
//
// See gtk.Widget.ListMnemonicLabels(). Note the list of mnemonic labels for the
// widget is cleared when the widget is destroyed, so the caller must make sure
// to update its internal state at this point as well, by using a connection to
// the gtk.Widget::destroy signal or a weak notifier.
//
// The function takes the following parameters:
//
//    - label: GtkWidget that acts as a mnemonic label for widget.
//
func (widget *Widget) AddMnemonicLabel(label Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(label).Native()))

	C.gtk_widget_add_mnemonic_label(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(label)
}

// AddTickCallback queues an animation frame update and adds a callback to be
// called before each frame.
//
// Until the tick callback is removed, it will be called frequently (usually at
// the frame rate of the output device or as quickly as the application can be
// repainted, whichever is slower). For this reason, is most suitable for
// handling graphics that change every frame or every few frames. The tick
// callback does not automatically imply a relayout or repaint. If you want a
// repaint or relayout, and aren’t changing widget properties that would trigger
// that (for example, changing the text of a Label), then you will have to call
// gtk.Widget.QueueResize() or gtk.Widget.QueueDraw() yourself.
//
// gdk.FrameClock.GetFrameTime() should generally be used for timing continuous
// animations and gdk.FrameTimings.GetPredictedPresentationTime() if you are
// trying to display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// gdk.FrameClock::update signal of GdkFrameClock, since you don't have to worry
// about when a GdkFrameClock is assigned to a widget.
//
// The function takes the following parameters:
//
//    - callback: function to call for updating animations.
//
// The function returns the following values:
//
//    - guint: id for the connection of this callback. Remove the callback by
//      passing the id returned from this function to
//      gtk.Widget.RemoveTickCallback().
//
func (widget *Widget) AddTickCallback(callback TickCallback) uint {
	var _arg0 *C.GtkWidget      // out
	var _arg1 C.GtkTickCallback // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TickCallback)
	_arg2 = C.gpointer(gbox.Assign(callback))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gtk_widget_add_tick_callback(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(callback)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Allocate: this function is only used by GtkWidget subclasses, to assign a
// size, position and (optionally) baseline to their child widgets.
//
// In this function, the allocation and baseline may be adjusted. The given
// allocation will be forced to be bigger than the widget's minimum size, as
// well as at least 0×0 in size.
//
// For a version that does not take a transform, see gtk.Widget.SizeAllocate().
//
// The function takes the following parameters:
//
//    - width: new width of widget.
//    - height: new height of widget.
//    - baseline: new baseline of widget, or -1.
//    - transform (optional): transformation to be applied to widget.
//
func (widget *Widget) Allocate(width, height, baseline int, transform *gsk.Transform) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out
	var _arg4 *C.GskTransform // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)
	_arg3 = C.int(baseline)
	if transform != nil {
		_arg4 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(transform)))
	}

	C.gtk_widget_allocate(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(baseline)
	runtime.KeepAlive(transform)
}

// ChildFocus: called by widgets as the user moves around the window using
// keyboard shortcuts.
//
// The direction argument indicates what kind of motion is taking place (up,
// down, left, right, tab forward, tab backward).
//
// This function calls the gtk.Widget.Focus() virtual function; widgets can
// override the virtual function in order to implement appropriate focus
// behavior.
//
// The default focus() virtual function for a widget should return TRUE if
// moving in direction left the focus on a focusable location inside that
// widget, and FALSE if moving in direction moved the focus outside the widget.
// When returning TRUE, widgets normallycall gtk.Widget.GrabFocus() to place the
// focus accordingly; when returning FALSE, they don’t modify the current focus
// location.
//
// This function is used by custom widget implementations; if you're writing an
// app, you’d use gtk.Widget.GrabFocus() to move the focus to a particular
// widget.
//
// The function takes the following parameters:
//
//    - direction of focus movement.
//
// The function returns the following values:
//
//    - ok: TRUE if focus ended up inside widget.
//
func (widget *Widget) ChildFocus(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_widget_child_focus(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ComputeBounds computes the bounds for widget in the coordinate space of
// target.
//
// FIXME: Explain what "bounds" are.
//
// If the operation is successful, TRUE is returned. If widget has no bounds or
// the bounds cannot be expressed in target's coordinate space (for example if
// both widgets are in different windows), FALSE is returned and bounds is set
// to the zero rectangle.
//
// It is valid for widget and target to be the same widget.
//
// The function takes the following parameters:
//
//    - target: GtkWidget.
//
// The function returns the following values:
//
//    - outBounds: rectangle taking the bounds.
//    - ok: TRUE if the bounds could be computed.
//
func (widget *Widget) ComputeBounds(target Widgetter) (*graphene.Rect, bool) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 C.graphene_rect_t // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gtk_widget_compute_bounds(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(target)

	var _outBounds *graphene.Rect // out
	var _ok bool                  // out

	_outBounds = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _outBounds, _ok
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible.
//
// Containers should check this, rather than looking at gtk.Widget.GetHExpand()
// or gtk.Widget.GetVExpand().
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly set on
// the widget itself, or, if none has been explicitly set, the widget may expand
// if some of its children do.
//
// The function takes the following parameters:
//
//    - orientation: expand direction.
//
// The function returns the following values:
//
//    - ok: whether widget tree rooted here should be expanded.
//
func (widget *Widget) ComputeExpand(orientation Orientation) bool {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_widget_compute_expand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ComputePoint translates the given point in widget's coordinates to
// coordinates relative to target’s coordinate system.
//
// In order to perform this operation, both widgets must share a common
// ancestor.
//
// The function takes the following parameters:
//
//    - target: GtkWidget to transform into.
//    - point in widget's coordinate system.
//
// The function returns the following values:
//
//    - outPoint: set to the corresponding coordinates in target's coordinate
//      system.
//    - ok: TRUE if the point could be determined, FALSE on failure. In this
//      case, 0 is stored in out_point.
//
func (widget *Widget) ComputePoint(target Widgetter, point *graphene.Point) (*graphene.Point, bool) {
	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.graphene_point_t  // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	_cret = C.gtk_widget_compute_point(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(target)
	runtime.KeepAlive(point)

	var _outPoint *graphene.Point // out
	var _ok bool                  // out

	_outPoint = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	if _cret != 0 {
		_ok = true
	}

	return _outPoint, _ok
}

// ComputeTransform computes a matrix suitable to describe a transformation from
// widget's coordinate system into target's coordinate system.
//
// The function takes the following parameters:
//
//    - target widget that the matrix will transform to.
//
// The function returns the following values:
//
//    - outTransform: location to store the final transformation.
//    - ok: TRUE if the transform could be computed, FALSE otherwise. The
//      transform can not be computed in certain cases, for example when widget
//      and target do not share a common ancestor. In that case out_transform
//      gets set to the identity matrix.
//
func (widget *Widget) ComputeTransform(target Widgetter) (*graphene.Matrix, bool) {
	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.graphene_matrix_t // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gtk_widget_compute_transform(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(target)

	var _outTransform *graphene.Matrix // out
	var _ok bool                       // out

	_outTransform = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _outTransform, _ok
}

// Contains tests if the point at (x, y) is contained in widget.
//
// The coordinates for (x, y) must be in widget coordinates, so (0, 0) is
// assumed to be the top left of widget's content area.
//
// The function takes the following parameters:
//
//    - x: x coordinate to test, relative to widget's origin.
//    - y: y coordinate to test, relative to widget's origin.
//
// The function returns the following values:
//
//    - ok: TRUE if widget contains (x, y).
//
func (widget *Widget) Contains(x, y float64) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(x)
	_arg2 = C.double(y)

	_cret = C.gtk_widget_contains(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreatePangoContext creates a new PangoContext with the appropriate font map,
// font options, font description, and base direction for drawing text for this
// widget.
//
// See also gtk.Widget.GetPangoContext().
//
// The function returns the following values:
//
//    - context: new PangoContext.
//
func (widget *Widget) CreatePangoContext() *pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_create_pango_context(_arg0)
	runtime.KeepAlive(widget)

	var _context *pango.Context // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_context = &pango.Context{
			Object: obj,
		}
	}

	return _context
}

// CreatePangoLayout creates a new PangoLayout with the appropriate font map,
// font description, and base direction for drawing text for this widget.
//
// If you keep a PangoLayout created in this way around, you need to re-create
// it when the widget PangoContext is replaced. This can be tracked by listening
// to changes of the gtk.Widget:root property on the widget.
//
// The function takes the following parameters:
//
//    - text (optional) to set on the layout (can be NULL).
//
// The function returns the following values:
//
//    - layout: new PangoLayout.
//
func (widget *Widget) CreatePangoLayout(text string) *pango.Layout {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.char        // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_widget_create_pango_layout(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(text)

	var _layout *pango.Layout // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// ErrorBell notifies the user about an input-related error on this widget.
//
// If the gtk.Settings:gtk-error-bell setting is TRUE, it calls
// gdk.Surface.Beep(), otherwise it does nothing.
//
// Note that the effect of gdk.Surface.Beep() can be configured in many ways,
// depending on the windowing backend and the desktop environment or window
// manager that is used.
func (widget *Widget) ErrorBell() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_error_bell(_arg0)
	runtime.KeepAlive(widget)
}

// AllocatedBaseline returns the baseline that has currently been allocated to
// widget.
//
// This function is intended to be used when implementing handlers for the
// GtkWidgetClass.snapshot() function, and when allocating child widgets in
// GtkWidgetClass.size_allocate().
//
// The function returns the following values:
//
//    - gint: baseline of the widget, or -1 if none.
//
func (widget *Widget) AllocatedBaseline() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_baseline(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AllocatedHeight returns the height that has currently been allocated to
// widget.
//
// The function returns the following values:
//
//    - gint: height of the widget.
//
func (widget *Widget) AllocatedHeight() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_height(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AllocatedWidth returns the width that has currently been allocated to widget.
//
// The function returns the following values:
//
//    - gint: width of the widget.
//
func (widget *Widget) AllocatedWidth() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_width(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Allocation retrieves the widget’s allocation.
//
// Note, when implementing a layout container: a widget’s allocation will be its
// “adjusted” allocation, that is, the widget’s parent typically calls
// gtk.Widget.SizeAllocate() with an allocation, and that allocation is then
// adjusted (to handle margin and alignment for example) before assignment to
// the widget. gtk.Widget.GetAllocation() returns the adjusted allocation that
// was actually assigned to the widget. The adjusted allocation is guaranteed to
// be completely contained within the gtk.Widget.SizeAllocate() allocation,
// however.
//
// So a layout container is guaranteed that its children stay inside the
// assigned bounds, but not that they have exactly the bounds the container
// assigned.
//
// The function returns the following values:
//
//    - allocation: pointer to a GtkAllocation to copy to.
//
func (widget *Widget) Allocation() *Allocation {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkAllocation // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_allocation(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _allocation
}

// Ancestor gets the first ancestor of widget with type widget_type.
//
// For example, gtk_widget_get_ancestor (widget, GTK_TYPE_BOX) gets the first
// GtkBox that’s an ancestor of widget. No reference will be added to the
// returned widget; it should not be unreferenced.
//
// Note that unlike gtk.Widget.IsAncestor(), this function considers widget to
// be an ancestor of itself.
//
// The function takes the following parameters:
//
//    - widgetType: ancestor type.
//
// The function returns the following values:
//
//    - ret (optional): ancestor widget, or NULL if not found.
//
func (widget *Widget) Ancestor(widgetType coreglib.Type) Widgetter {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GType(widgetType)

	_cret = C.gtk_widget_get_ancestor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(widgetType)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// CanFocus determines whether the input focus can enter widget or any of its
// children.
//
// See gtk.Widget.SetFocusable().
//
// The function returns the following values:
//
//    - ok: TRUE if the input focus can enter widget, FALSE otherwise.
//
func (widget *Widget) CanFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_can_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanTarget queries whether widget can be the target of pointer events.
//
// The function returns the following values:
//
//    - ok: TRUE if widget can receive pointer events.
//
func (widget *Widget) CanTarget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_can_target(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildVisible gets the value set with gtk_widget_set_child_visible().
//
// If you feel a need to use this function, your code probably needs
// reorganization.
//
// This function is only useful for container implementations and should never
// be called by an application.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is mapped with the parent.
//
func (widget *Widget) ChildVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_child_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Clipboard gets the clipboard object for widget.
//
// This is a utility function to get the clipboard object for the GdkDisplay
// that widget is using.
//
// Note that this function always works, even when widget is not realized yet.
//
// The function returns the following values:
//
//    - clipboard: appropriate clipboard object.
//
func (widget *Widget) Clipboard() *gdk.Clipboard {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_clipboard(_arg0)
	runtime.KeepAlive(widget)

	var _clipboard *gdk.Clipboard // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_clipboard = &gdk.Clipboard{
			Object: obj,
		}
	}

	return _clipboard
}

// CSSClasses returns the list of style classes applied to widget.
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated list of css classes currently applied to widget.
//      The returned list can be freed using g_strfreev().
//
func (widget *Widget) CSSClasses() []string {
	var _arg0 *C.GtkWidget // out
	var _cret **C.char     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_css_classes(_arg0)
	runtime.KeepAlive(widget)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// CSSName returns the CSS name that is used for self.
//
// The function returns the following values:
//
//    - utf8: CSS name.
//
func (self *Widget) CSSName() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_widget_get_css_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Cursor queries the cursor set on widget.
//
// See gtk.Widget.SetCursor() for details.
//
// The function returns the following values:
//
//    - cursor (optional): cursor currently in use or NULL to use the default.
//
func (widget *Widget) Cursor() *gdk.Cursor {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkCursor // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_cursor(_arg0)
	runtime.KeepAlive(widget)

	var _cursor *gdk.Cursor // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_cursor = &gdk.Cursor{
				Object: obj,
			}
		}
	}

	return _cursor
}

// Direction gets the reading direction for a particular widget.
//
// See gtk.Widget.SetDirection().
//
// The function returns the following values:
//
//    - textDirection: reading direction for the widget.
//
func (widget *Widget) Direction() TextDirection {
	var _arg0 *C.GtkWidget       // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_direction(_arg0)
	runtime.KeepAlive(widget)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// Display: get the GdkDisplay for the toplevel window associated with this
// widget.
//
// This function can only be called after the widget has been added to a widget
// hierarchy with a GtkWindow at the top.
//
// In general, you should only create display specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
//
// The function returns the following values:
//
//    - display: GdkDisplay for the toplevel for this widget.
//
func (widget *Widget) Display() *gdk.Display {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_display(_arg0)
	runtime.KeepAlive(widget)

	var _display *gdk.Display // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_display = &gdk.Display{
			Object: obj,
		}
	}

	return _display
}

// FirstChild returns the widgets first child.
//
// This API is primarily meant for widget implementations.
//
// The function returns the following values:
//
//    - ret (optional) widget's first child.
//
func (widget *Widget) FirstChild() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_first_child(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// FocusChild returns the current focus child of widget.
//
// The function returns the following values:
//
//    - ret (optional): current focus child of widget, or NULL in case the focus
//      child is unset.
//
func (widget *Widget) FocusChild() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_focus_child(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// FocusOnClick returns whether the widget should grab focus when it is clicked
// with the mouse.
//
// See gtk.Widget.SetFocusOnClick().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget should grab focus when it is clicked with the
//      mouse.
//
func (widget *Widget) FocusOnClick() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_focus_on_click(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Focusable determines whether widget can own the input focus.
//
// See gtk.Widget.SetFocusable().
//
// The function returns the following values:
//
//    - ok: TRUE if widget can own the input focus, FALSE otherwise.
//
func (widget *Widget) Focusable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_focusable(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FontMap gets the font map of widget.
//
// See gtk.Widget.SetFontMap().
//
// The function returns the following values:
//
//    - fontMap (optional): PangoFontMap, or NULL.
//
func (widget *Widget) FontMap() pango.FontMapper {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoFontMap // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_font_map(_arg0)
	runtime.KeepAlive(widget)

	var _fontMap pango.FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontMapper)
				return ok
			})
			rv, ok := casted.(pango.FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// FontOptions returns the cairo_font_options_t used for Pango rendering.
//
// When not set, the defaults font options for the GdkDisplay will be used.
//
// The function returns the following values:
//
//    - fontOptions (optional): cairo_font_options_t or NULL if not set.
//
func (widget *Widget) FontOptions() *cairo.FontOptions {
	var _arg0 *C.GtkWidget            // out
	var _cret *C.cairo_font_options_t // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_font_options(_arg0)
	runtime.KeepAlive(widget)

	var _fontOptions *cairo.FontOptions // out

	if _cret != nil {
		_fontOptions = (*cairo.FontOptions)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _fontOptions
}

// FrameClock obtains the frame clock for a widget.
//
// The frame clock is a global “ticker” that can be used to drive animations and
// repaints. The most common reason to get the frame clock is to call
// gdk.FrameClock.GetFrameTime(), in order to get a time to use for animating.
// For example you might record the start of the animation with an initial value
// from gdk.FrameClock.GetFrameTime(), and then update the animation by calling
// gdk.FrameClock.GetFrameTime() again during each repaint.
//
// gdk.FrameClock.RequestPhase() will result in a new frame on the clock, but
// won’t necessarily repaint any widgets. To repaint a widget, you have to use
// gtk.Widget.QueueDraw() which invalidates the widget (thus scheduling it to
// receive a draw on the next frame). gtk_widget_queue_draw() will also end up
// requesting a frame on the appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
//
// The function returns the following values:
//
//    - frameClock (optional): GdkFrameClock, or NULL if widget is unrealized.
//
func (widget *Widget) FrameClock() gdk.FrameClocker {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GdkFrameClock // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_frame_clock(_arg0)
	runtime.KeepAlive(widget)

	var _frameClock gdk.FrameClocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.FrameClocker)
				return ok
			})
			rv, ok := casted.(gdk.FrameClocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.FrameClocker")
			}
			_frameClock = rv
		}
	}

	return _frameClock
}

// HAlign gets the horizontal alignment of widget.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
//
// The function returns the following values:
//
//    - align: horizontal alignment of widget.
//
func (widget *Widget) HAlign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_halign(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// HasTooltip returns the current value of the has-tooltip property.
//
// The function returns the following values:
//
//    - ok: current value of has-tooltip on widget.
//
func (widget *Widget) HasTooltip() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_has_tooltip(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Height returns the content height of the widget.
//
// This function returns the size passed to its size-allocate implementation,
// which is the size you should be using in GtkWidgetClass.snapshot().
//
// For pointer events, see gtk.Widget.Contains().
//
// The function returns the following values:
//
//    - gint: height of widget.
//
func (widget *Widget) Height() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_height(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// HExpand gets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a GtkWindow, widgets with expand=TRUE generally receive
// the extra space. For example, a list or scrollable area or document in your
// window would often be set to expand.
//
// Containers should use gtk.Widget.ComputeExpand() rather than this function,
// to see whether a widget, or any of its children, has the expand flag set. If
// any child of a widget wants to expand, the parent may ask to expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
//
// The function returns the following values:
//
//    - ok: whether hexpand flag is set.
//
func (widget *Widget) HExpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_hexpand(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HExpandSet gets whether gtk_widget_set_hexpand() has been used to explicitly
// set the expand flag on this widget.
//
// If gtk.Widget:hexpand property is set, then it overrides any computed expand
// value based on child widgets. If hexpand is not set, then the expand value
// depends on whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
//
// The function returns the following values:
//
//    - ok: whether hexpand has been explicitly set.
//
func (widget *Widget) HExpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_hexpand_set(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LastChild returns the widgets last child.
//
// This API is primarily meant for widget implementations.
//
// The function returns the following values:
//
//    - ret (optional) widget's last child.
//
func (widget *Widget) LastChild() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_last_child(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// LayoutManager retrieves the layout manager used by widget
//
// See gtk.Widget.SetLayoutManager().
//
// The function returns the following values:
//
//    - layoutManager (optional): GtkLayoutManager.
//
func (widget *Widget) LayoutManager() LayoutManagerer {
	var _arg0 *C.GtkWidget        // out
	var _cret *C.GtkLayoutManager // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_layout_manager(_arg0)
	runtime.KeepAlive(widget)

	var _layoutManager LayoutManagerer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(LayoutManagerer)
				return ok
			})
			rv, ok := casted.(LayoutManagerer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.LayoutManagerer")
			}
			_layoutManager = rv
		}
	}

	return _layoutManager
}

// Mapped: whether the widget is mapped.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is mapped, FALSE otherwise.
//
func (widget *Widget) Mapped() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_mapped(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MarginBottom gets the bottom margin of widget.
//
// The function returns the following values:
//
//    - gint: bottom margin of widget.
//
func (widget *Widget) MarginBottom() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_bottom(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginEnd gets the end margin of widget.
//
// The function returns the following values:
//
//    - gint: end margin of widget.
//
func (widget *Widget) MarginEnd() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_end(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginStart gets the start margin of widget.
//
// The function returns the following values:
//
//    - gint: start margin of widget.
//
func (widget *Widget) MarginStart() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_start(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginTop gets the top margin of widget.
//
// The function returns the following values:
//
//    - gint: top margin of widget.
//
func (widget *Widget) MarginTop() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_top(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Name retrieves the name of a widget.
//
// See gtk.Widget.SetName() for the significance of widget names.
//
// The function returns the following values:
//
//    - utf8: name of the widget. This string is owned by GTK and should not be
//      modified or freed.
//
func (widget *Widget) Name() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_name(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Native returns the GtkNative widget that contains widget.
//
// This function will return NULL if the widget is not contained inside a widget
// tree with a native ancestor.
//
// GtkNative widgets will return themselves here.
//
// The function returns the following values:
//
//    - native (optional): GtkNative widget of widget, or NULL.
//
func (widget *Widget) Native() *NativeSurface {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkNative // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_native(_arg0)
	runtime.KeepAlive(widget)

	var _native *NativeSurface // out

	if _cret != nil {
		_native = wrapNativeSurface(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _native
}

// NextSibling returns the widgets next sibling.
//
// This API is primarily meant for widget implementations.
//
// The function returns the following values:
//
//    - ret (optional) widget's next sibling.
//
func (widget *Widget) NextSibling() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_next_sibling(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// Opacity the requested opacity for this widget.
//
// See gtk.Widget.SetOpacity().
//
// The function returns the following values:
//
//    - gdouble: requested opacity for this widget.
//
func (widget *Widget) Opacity() float64 {
	var _arg0 *C.GtkWidget // out
	var _cret C.double     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_opacity(_arg0)
	runtime.KeepAlive(widget)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Overflow returns the widgets overflow value.
//
// The function returns the following values:
//
//    - overflow widget's overflow.
//
func (widget *Widget) Overflow() Overflow {
	var _arg0 *C.GtkWidget  // out
	var _cret C.GtkOverflow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_overflow(_arg0)
	runtime.KeepAlive(widget)

	var _overflow Overflow // out

	_overflow = Overflow(_cret)

	return _overflow
}

// PangoContext gets a PangoContext with the appropriate font map, font
// description, and base direction for this widget.
//
// Unlike the context returned by gtk.Widget.CreatePangoContext(), this context
// is owned by the widget (it can be used until the screen for the widget
// changes or the widget is removed from its toplevel), and will be updated to
// match any changes to the widget’s attributes. This can be tracked by
// listening to changes of the gtk.Widget:root property on the widget.
//
// The function returns the following values:
//
//    - context: PangoContext for the widget.
//
func (widget *Widget) PangoContext() *pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_pango_context(_arg0)
	runtime.KeepAlive(widget)

	var _context *pango.Context // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_context = &pango.Context{
			Object: obj,
		}
	}

	return _context
}

// Parent returns the parent widget of widget.
//
// The function returns the following values:
//
//    - ret (optional): parent widget of widget, or NULL.
//
func (widget *Widget) Parent() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_parent(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// PreferredSize retrieves the minimum and natural size of a widget, taking into
// account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do not
// impose any restrictions on the child placement. It can be used to deduce
// toplevel window and menu sizes as well as child widgets in free-form
// containers such as GtkFixed.
//
// Handle with care. Note that the natural height of a height-for-width widget
// will generally be a smaller size than the minimum height, since the required
// height for the natural width is generally smaller than the required height
// for the minimum width.
//
// Use gtk_widget_measure if you want to support baseline alignment.
//
// The function returns the following values:
//
//    - minimumSize (optional): location for storing the minimum size, or NULL.
//    - naturalSize (optional): location for storing the natural size, or NULL.
//
func (widget *Widget) PreferredSize() (minimumSize, naturalSize *Requisition) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in
	var _arg2 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_preferred_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumSize *Requisition // out
	var _naturalSize *Requisition // out

	_minimumSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_naturalSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _minimumSize, _naturalSize
}

// PrevSibling returns the widgets previous sibling.
//
// This API is primarily meant for widget implementations.
//
// The function returns the following values:
//
//    - ret (optional) widget's previous sibling.
//
func (widget *Widget) PrevSibling() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_prev_sibling(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// PrimaryClipboard gets the primary clipboard of widget.
//
// This is a utility function to get the primary clipboard object for the
// GdkDisplay that widget is using.
//
// Note that this function always works, even when widget is not realized yet.
//
// The function returns the following values:
//
//    - clipboard: appropriate clipboard object.
//
func (widget *Widget) PrimaryClipboard() *gdk.Clipboard {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_primary_clipboard(_arg0)
	runtime.KeepAlive(widget)

	var _clipboard *gdk.Clipboard // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_clipboard = &gdk.Clipboard{
			Object: obj,
		}
	}

	return _clipboard
}

// Realized determines whether widget is realized.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is realized, FALSE otherwise.
//
func (widget *Widget) Realized() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_realized(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReceivesDefault determines whether widget is always treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// See gtk.Widget.SetReceivesDefault().
//
// The function returns the following values:
//
//    - ok: TRUE if widget acts as the default widget when focused, FALSE
//      otherwise.
//
func (widget *Widget) ReceivesDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_receives_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
//
// Single-child widgets generally propagate the preference of their child, more
// complex widgets need to request something either in context of their children
// or in context of their allocation capabilities.
//
// The function returns the following values:
//
//    - sizeRequestMode: GtkSizeRequestMode preferred by widget.
//
func (widget *Widget) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_request_mode(_arg0)
	runtime.KeepAlive(widget)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Root returns the GtkRoot widget of widget.
//
// This function will return NULL if the widget is not contained inside a widget
// tree with a root widget.
//
// GtkRoot widgets will return themselves here.
//
// The function returns the following values:
//
//    - root (optional) widget of widget, or NULL.
//
func (widget *Widget) Root() *Root {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkRoot   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_root(_arg0)
	runtime.KeepAlive(widget)

	var _root *Root // out

	if _cret != nil {
		_root = wrapRoot(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _root
}

// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels.
//
// On traditional systems this is 1, on high density outputs, it can be a higher
// value (typically 2).
//
// See gdk.Surface.GetScaleFactor().
//
// The function returns the following values:
//
//    - gint: scale factor for widget.
//
func (widget *Widget) ScaleFactor() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_scale_factor(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Sensitive returns the widget’s sensitivity.
//
// This function returns the value that has been set using
// gtk.Widget.SetSensitive()).
//
// The effective sensitivity of a widget is however determined by both its own
// and its parent widget’s sensitivity. See gtk.Widget.IsSensitive().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is sensitive.
//
func (widget *Widget) Sensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_sensitive(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Settings gets the settings object holding the settings used for this widget.
//
// Note that this function can only be called when the GtkWidget is attached to
// a toplevel, since the settings object is specific to a particular GdkDisplay.
// If you want to monitor the widget for changes in its settings, connect to
// notify::display.
//
// The function returns the following values:
//
//    - settings: relevant Settings object.
//
func (widget *Widget) Settings() *Settings {
	var _arg0 *C.GtkWidget   // out
	var _cret *C.GtkSettings // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_settings(_arg0)
	runtime.KeepAlive(widget)

	var _settings *Settings // out

	_settings = wrapSettings(coreglib.Take(unsafe.Pointer(_cret)))

	return _settings
}

// Size returns the content width or height of the widget.
//
// Which dimension is returned depends on orientation.
//
// This is equivalent to calling gtk.Widget.GetWidth() for
// GTK_ORIENTATION_HORIZONTAL or gtk.Widget.GetHeight() for
// GTK_ORIENTATION_VERTICAL, but can be used when writing
// orientation-independent code, such as when implementing gtk.Orientable
// widgets.
//
// The function takes the following parameters:
//
//    - orientation to query.
//
// The function returns the following values:
//
//    - gint: size of widget in orientation.
//
func (widget *Widget) Size(orientation Orientation) int {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.int            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_widget_get_size(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request().
//
// A value of -1 stored in width or height indicates that that dimension has not
// been set explicitly and the natural requisition of the widget will be used
// instead. See gtk.Widget.SetSizeRequest(). To get the size a widget will
// actually request, call gtk.Widget.Measure() instead of this function.
//
// The function returns the following values:
//
//    - width (optional): return location for width, or NULL.
//    - height (optional): return location for height, or NULL.
//
func (widget *Widget) SizeRequest() (width, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // in
	var _arg2 C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_size_request(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// StateFlags returns the widget state as a flag set.
//
// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE state
// will be returned, that is, also based on parent insensitivity, even if widget
// itself is sensitive.
//
// Also note that if you are looking for a way to obtain the gtk.StateFlags to
// pass to a gtk.StyleContext method, you should look at
// gtk.StyleContext.GetState().
//
// The function returns the following values:
//
//    - stateFlags: state flags for widget.
//
func (widget *Widget) StateFlags() StateFlags {
	var _arg0 *C.GtkWidget    // out
	var _cret C.GtkStateFlags // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_state_flags(_arg0)
	runtime.KeepAlive(widget)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// StyleContext returns the style context associated to widget.
//
// The returned object is guaranteed to be the same for the lifetime of widget.
//
// The function returns the following values:
//
//    - styleContext: GtkStyleContext. This memory is owned by widget and must
//      not be freed.
//
func (widget *Widget) StyleContext() *StyleContext {
	var _arg0 *C.GtkWidget       // out
	var _cret *C.GtkStyleContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_style_context(_arg0)
	runtime.KeepAlive(widget)

	var _styleContext *StyleContext // out

	_styleContext = wrapStyleContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _styleContext
}

// TemplateChild: fetch an object build from the template XML for widget_type in
// this widget instance.
//
// This will only report children which were previously declared with
// gtk.WidgetClass.BindTemplateChildFull() or one of its variants.
//
// This function is only meant to be called for code which is private to the
// widget_type which declared the child and is meant for language bindings which
// cannot easily make use of the GObject structure offsets.
//
// The function takes the following parameters:
//
//    - widgetType to get a template child for.
//    - name: “id” of the child defined in the template XML.
//
// The function returns the following values:
//
//    - object built in the template XML with the id name.
//
func (widget *Widget) TemplateChild(widgetType coreglib.Type, name string) *coreglib.Object {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _arg2 *C.char      // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GType(widgetType)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_get_template_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(widgetType)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// TooltipMarkup gets the contents of the tooltip for widget.
//
// If the tooltip has not been set using gtk.Widget.SetTooltipMarkup(), this
// function returns NULL.
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip text.
//
func (widget *Widget) TooltipMarkup() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_markup(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TooltipText gets the contents of the tooltip for widget.
//
// If the widget's tooltip was set using gtk.Widget.SetTooltipMarkup(), this
// function will return the escaped text.
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip text.
//
func (widget *Widget) TooltipText() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_text(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// VAlign gets the vertical alignment of widget.
//
// The function returns the following values:
//
//    - align: vertical alignment of widget.
//
func (widget *Widget) VAlign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_valign(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// VExpand gets whether the widget would like any available extra vertical
// space.
//
// See gtk.Widget.GetHExpand() for more detail.
//
// The function returns the following values:
//
//    - ok: whether vexpand flag is set.
//
func (widget *Widget) VExpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_vexpand(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VExpandSet gets whether gtk_widget_set_vexpand() has been used to explicitly
// set the expand flag on this widget.
//
// See gtk.Widget.GetHExpandSet() for more detail.
//
// The function returns the following values:
//
//    - ok: whether vexpand has been explicitly set.
//
func (widget *Widget) VExpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_vexpand_set(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visible determines whether the widget is visible.
//
// If you want to take into account whether the widget’s parent is also marked
// as visible, use gtk.Widget.IsVisible() instead.
//
// This function does not check if the widget is obscured in any way.
//
// See gtk.Widget.SetVisible().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is visible.
//
func (widget *Widget) Visible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Width returns the content width of the widget.
//
// This function returns the size passed to its size-allocate implementation,
// which is the size you should be using in GtkWidgetClass.snapshot().
//
// For pointer events, see gtk.Widget.Contains().
//
// The function returns the following values:
//
//    - gint: width of widget.
//
func (widget *Widget) Width() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_width(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// GrabFocus causes widget to have the keyboard focus for the GtkWindow it's
// inside.
//
// If widget is not focusable, or its ::grab_focus implementation cannot
// transfer the focus to a descendant of widget that is focusable, it will not
// take focus and FALSE will be returned.
//
// Calling gtk.Widget.GrabFocus() on an already focused widget is allowed,
// should not have an effect, and return TRUE.
//
// The function returns the following values:
//
//    - ok: TRUE if focus is now inside widget.
//
func (widget *Widget) GrabFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_grab_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasCSSClass returns whether css_class is currently applied to widget.
//
// The function takes the following parameters:
//
//    - cssClass: style class, without the leading '.' used for notation of style
//      classes.
//
// The function returns the following values:
//
//    - ok: TRUE if css_class is currently applied to widget, FALSE otherwise.
//
func (widget *Widget) HasCSSClass(cssClass string) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(cssClass)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_widget_has_css_class(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cssClass)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasDefault determines whether widget is the current default widget within its
// toplevel.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is the current default widget within its toplevel,
//      FALSE otherwise.
//
func (widget *Widget) HasDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasFocus determines if the widget has the global input focus.
//
// See gtk.Widget.IsFocus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget has the global input focus.
//
func (widget *Widget) HasFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus.
//
// This is a convenience function that takes into account whether focus
// indication should currently be shown in the toplevel window of widget. See
// gtk.Window.GetFocusVisible() for more information about focus indication.
//
// To find out if the widget has the global input focus, use
// gtk.Widget.HasFocus().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget should display a “focus rectangle”.
//
func (widget *Widget) HasVisibleFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_visible_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide reverses the effects of gtk_widget_show().
//
// This is causing the widget to be hidden (invisible to the user).
func (widget *Widget) Hide() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_hide(_arg0)
	runtime.KeepAlive(widget)
}

// InDestruction returns whether the widget is currently being destroyed.
//
// This information can sometimes be used to avoid doing unnecessary work.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is being destroyed.
//
func (widget *Widget) InDestruction() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_in_destruction(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InitTemplate creates and initializes child widgets defined in templates.
//
// This function must be called in the instance initializer for any class which
// assigned itself a template using gtk.WidgetClass.SetTemplate().
//
// It is important to call this function in the instance initializer of a
// GtkWidget subclass and not in GObject.constructed() or GObject.constructor()
// for two reasons:
//
//    - derived widgets will assume that the composite widgets
//      defined by its parent classes have been created in their
//      relative instance initializers
//    - when calling g_object_new() on a widget with composite templates,
//      it’s important to build the composite widgets before the construct
//      properties are set. Properties passed to g_object_new() should
//      take precedence over properties set in the private template XML
//
// A good rule of thumb is to call this function as the first thing in an
// instance initialization function.
func (widget *Widget) InitTemplate() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_init_template(_arg0)
	runtime.KeepAlive(widget)
}

// InsertActionGroup inserts group into widget.
//
// Children of widget that implement gtk.Actionable can then be associated with
// actions in group by setting their “action-name” to prefix.action-name.
//
// Note that inheritance is defined for individual actions. I.e. even if you
// insert a group with prefix prefix, actions with the same prefix will still be
// inherited from the parent, unless the group contains an action with the same
// name.
//
// If group is NULL, a previously inserted group for name is removed from
// widget.
//
// The function takes the following parameters:
//
//    - name: prefix for actions in group.
//    - group (optional) or NULL.
//
func (widget *Widget) InsertActionGroup(name string, group gio.ActionGrouper) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.char         // out
	var _arg2 *C.GActionGroup // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if group != nil {
		_arg2 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	}

	C.gtk_widget_insert_action_group(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
	runtime.KeepAlive(group)
}

// InsertAfter inserts widget into the child widget list of parent.
//
// It will be placed after previous_sibling, or at the beginning if
// previous_sibling is NULL.
//
// After calling this function, gtk_widget_get_prev_sibling(widget) will return
// previous_sibling.
//
// If parent is already set as the parent widget of widget, this function can
// also be used to reorder widget in the child widget list of parent.
//
// This API is primarily meant for widget implementations; if you are just using
// a widget, you *must* use its own API for adding children.
//
// The function takes the following parameters:
//
//    - parent GtkWidget to insert widget into.
//    - previousSibling (optional): new previous sibling of widget or NULL.
//
func (widget *Widget) InsertAfter(parent, previousSibling Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	if previousSibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(previousSibling).Native()))
	}

	C.gtk_widget_insert_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(previousSibling)
}

// InsertBefore inserts widget into the child widget list of parent.
//
// It will be placed before next_sibling, or at the end if next_sibling is NULL.
//
// After calling this function, gtk_widget_get_next_sibling(widget) will return
// next_sibling.
//
// If parent is already set as the parent widget of widget, this function can
// also be used to reorder widget in the child widget list of parent.
//
// This API is primarily meant for widget implementations; if you are just using
// a widget, you *must* use its own API for adding children.
//
// The function takes the following parameters:
//
//    - parent GtkWidget to insert widget into.
//    - nextSibling (optional): new next sibling of widget or NULL.
//
func (widget *Widget) InsertBefore(parent, nextSibling Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	if nextSibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(nextSibling).Native()))
	}

	C.gtk_widget_insert_before(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(nextSibling)
}

// IsAncestor determines whether widget is somewhere inside ancestor, possibly
// with intermediate containers.
//
// The function takes the following parameters:
//
//    - ancestor: another GtkWidget.
//
// The function returns the following values:
//
//    - ok: TRUE if ancestor contains widget as a child, grandchild, great
//      grandchild, etc.
//
func (widget *Widget) IsAncestor(ancestor Widgetter) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(ancestor).Native()))

	_cret = C.gtk_widget_is_ancestor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDrawable determines whether widget can be drawn to.
//
// A widget can be drawn if it is mapped and visible.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is drawable, FALSE otherwise.
//
func (widget *Widget) IsDrawable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_drawable(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocus determines if the widget is the focus widget within its toplevel.
//
// This does not mean that the gtk.Widget:has-focus property is necessarily set;
// gtk,widget:has-focus will only be set if the toplevel widget additionally has
// the global input focus.).
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is the focus widget.
//
func (widget *Widget) IsFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSensitive returns the widget’s effective sensitivity.
//
// This means it is sensitive itself and also its parent widget is sensitive.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is effectively sensitive.
//
func (widget *Widget) IsSensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_sensitive(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVisible determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also gtk.Widget.GetVisible() and gtk.Widget.SetVisible().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget and all its parents are visible.
//
func (widget *Widget) IsVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeynavFailed emits the ::keynav-failed signal on the widget.
//
// This function should be called whenever keyboard navigation within a single
// widget hits a boundary.
//
// The return value of this function should be interpreted in a way similar to
// the return value of gtk.Widget.ChildFocus(). When TRUE is returned, stay in
// the widget, the failed keyboard navigation is OK and/or there is nowhere we
// can/should move the focus to. When FALSE is returned, the caller should
// continue with keyboard navigation outside the widget, e.g. by calling
// gtk.Widget.ChildFocus() on the widget’s toplevel.
//
// The default gtk.Widget::keynav-failed handler returns FALSE for
// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
// DirectionType it returns TRUE.
//
// Whenever the default handler returns TRUE, it also calls
// gtk.Widget.ErrorBell() to notify the user of the failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either by
// connecting to it or by overriding it) would be a row of gtk.Entry widgets
// where the user should be able to navigate the entire row with the cursor
// keys, as e.g. known from user interfaces that require entering license keys.
//
// The function takes the following parameters:
//
//    - direction of focus movement.
//
// The function returns the following values:
//
//    - ok: TRUE if stopping keyboard navigation is fine, FALSE if the emitting
//      widget should try to handle the keyboard navigation attempt in its parent
//      container(s).
//
func (widget *Widget) KeynavFailed(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_widget_keynav_failed(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListMnemonicLabels returns the widgets for which this widget is the target of
// a mnemonic.
//
// Typically, these widgets will be labels. See, for example,
// gtk.Label.SetMnemonicWidget().
//
// The widgets in the list are not individually referenced. If you want to
// iterate through the list and perform actions involving callbacks that might
// destroy the widgets, you must call g_list_foreach (result,
// (GFunc)g_object_ref, NULL) first, and then unref all the widgets afterwards.
//
// The function returns the following values:
//
//    - list: list of mnemonic labels; free this list with g_list_free() when you
//      are done with it.
//
func (widget *Widget) ListMnemonicLabels() []Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GList     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_list_mnemonic_labels(_arg0)
	runtime.KeepAlive(widget)

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// Map causes a widget to be mapped if it isn’t already.
//
// This function is only for use in widget implementations.
func (widget *Widget) Map() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_map(_arg0)
	runtime.KeepAlive(widget)
}

// Measure measures widget in the orientation orientation and for the given
// for_size.
//
// As an example, if orientation is GTK_ORIENTATION_HORIZONTAL and for_size is
// 300, this functions will compute the minimum and natural width of widget if
// it is allocated at a height of 300 pixels.
//
// See GtkWidget’s geometry management section
// (class.Widget.html#height-for-width-geometry-management) for a more details
// on implementing WidgetClass.measure().
//
// The function takes the following parameters:
//
//    - orientation to measure.
//    - forSize: size for the opposite of orientation, i.e. if orientation is
//      GTK_ORIENTATION_HORIZONTAL, this is the height the widget should be
//      measured with. The GTK_ORIENTATION_VERTICAL case is analogous. This way,
//      both height-for-width and width-for-height requests can be implemented.
//      If no size is known, -1 can be passed.
//
// The function returns the following values:
//
//    - minimum (optional): location to store the minimum size, or NULL.
//    - natural (optional): location to store the natural size, or NULL.
//    - minimumBaseline (optional): location to store the baseline position for
//      the minimum size, or NULL.
//    - naturalBaseline (optional): location to store the baseline position for
//      the natural size, or NULL.
//
func (widget *Widget) Measure(orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _arg2 C.int            // out
	var _arg3 C.int            // in
	var _arg4 C.int            // in
	var _arg5 C.int            // in
	var _arg6 C.int            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.int(forSize)

	C.gtk_widget_measure(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(forSize)

	var _minimum int         // out
	var _natural int         // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimum = int(_arg3)
	_natural = int(_arg4)
	_minimumBaseline = int(_arg5)
	_naturalBaseline = int(_arg6)

	return _minimum, _natural, _minimumBaseline, _naturalBaseline
}

// MnemonicActivate emits the GtkWidget::mnemonic-activate signal.
//
// The function takes the following parameters:
//
//    - groupCycling: TRUE if there are other widgets with the same mnemonic.
//
// The function returns the following values:
//
//    - ok: TRUE if the signal has been handled.
//
func (widget *Widget) MnemonicActivate(groupCycling bool) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_widget_mnemonic_activate(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(groupCycling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObserveChildren returns a GListModel to track the children of widget.
//
// Calling this function will enable extra internal bookkeeping to track
// children and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of the
// slowdowns.
//
// The function returns the following values:
//
//    - listModel: a GListModel tracking widget's children.
//
func (widget *Widget) ObserveChildren() *gio.ListModel {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GListModel // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_observe_children(_arg0)
	runtime.KeepAlive(widget)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// ObserveControllers returns a GListModel to track the gtk.EventControllers of
// widget.
//
// Calling this function will enable extra internal bookkeeping to track
// controllers and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of the
// slowdowns.
//
// The function returns the following values:
//
//    - listModel: a GListModel tracking widget's controllers.
//
func (widget *Widget) ObserveControllers() *gio.ListModel {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GListModel // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_observe_controllers(_arg0)
	runtime.KeepAlive(widget)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// Pick finds the descendant of widget closest to the screen at the point (x,
// y).
//
// The point must be given in widget coordinates, so (0, 0) is assumed to be the
// top left of widget's content area.
//
// Usually widgets will return NULL if the given coordinate is not contained in
// widget checked via gtk.Widget.Contains(). Otherwise they will recursively try
// to find a child that does not return NULL. Widgets are however free to
// customize their picking algorithm.
//
// This function is used on the toplevel to determine the widget below the mouse
// cursor for purposes of hover highlighting and delivering events.
//
// The function takes the following parameters:
//
//    - x: x coordinate to test, relative to widget's origin.
//    - y: y coordinate to test, relative to widget's origin.
//    - flags flags to influence what is picked.
//
// The function returns the following values:
//
//    - ret (optional): widget descendant at the given coordinate or NULL if
//      none.
//
func (widget *Widget) Pick(x, y float64, flags PickFlags) Widgetter {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out
	var _arg3 C.GtkPickFlags // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(x)
	_arg2 = C.double(y)
	_arg3 = C.GtkPickFlags(flags)

	_cret = C.gtk_widget_pick(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(flags)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// QueueAllocate flags the widget for a rerun of the
// GtkWidgetClass::size_allocate function.
//
// Use this function instead of gtk.Widget.QueueResize() when the widget's size
// request didn't change but it wants to reposition its contents.
//
// An example user of this function is gtk.Widget.SetHAlign().
//
// This function is only for use in widget implementations.
func (widget *Widget) QueueAllocate() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_allocate(_arg0)
	runtime.KeepAlive(widget)
}

// QueueDraw schedules this widget to be redrawn in paint phase of the current
// or the next frame.
//
// This means widget's GtkWidgetClass.snapshot() implementation will be called.
func (widget *Widget) QueueDraw() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_draw(_arg0)
	runtime.KeepAlive(widget)
}

// QueueResize flags a widget to have its size renegotiated.
//
// This should be called when a widget for some reason has a new size request.
// For example, when you change the text in a gtk.Label, the label queues a
// resize to ensure there’s enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from inside
// its implementation of the GtkWidgetClass::size_allocate virtual method. Calls
// to gtk_widget_queue_resize() from inside GtkWidgetClass::size_allocate will
// be silently ignored.
//
// This function is only for use in widget implementations.
func (widget *Widget) QueueResize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_resize(_arg0)
	runtime.KeepAlive(widget)
}

// Realize creates the GDK resources associated with a widget.
//
// Normally realization happens implicitly; if you show a widget and all its
// parent containers, then the widget will be realized and mapped automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling this function realizes the widget’s parents in addition to widget
// itself. If a widget is not yet inside a toplevel window when you realize it,
// bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as gtk.Widget::realize.
func (widget *Widget) Realize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_realize(_arg0)
	runtime.KeepAlive(widget)
}

// RemoveController removes controller from widget, so that it doesn't process
// events anymore.
//
// It should not be used again.
//
// Widgets will remove all event controllers automatically when they are
// destroyed, there is normally no need to call this function.
//
// The function takes the following parameters:
//
//    - controller: EventController.
//
func (widget *Widget) RemoveController(controller EventControllerer) {
	var _arg0 *C.GtkWidget          // out
	var _arg1 *C.GtkEventController // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	C.gtk_widget_remove_controller(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(controller)
}

// RemoveCSSClass removes a style from widget.
//
// After this, the style of widget will stop matching for css_class.
//
// The function takes the following parameters:
//
//    - cssClass: style class to remove from widget, without the leading '.' used
//      for notation of style classes.
//
func (widget *Widget) RemoveCSSClass(cssClass string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(cssClass)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_remove_css_class(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cssClass)
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget.
//
// See gtk.Widget.ListMnemonicLabels(). The widget must have previously been
// added to the list with gtk.Widget.AddMnemonicLabel().
//
// The function takes the following parameters:
//
//    - label: GtkWidget that was previously set as a mnemonic label for widget
//      with gtk.Widget.AddMnemonicLabel().
//
func (widget *Widget) RemoveMnemonicLabel(label Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(label).Native()))

	C.gtk_widget_remove_mnemonic_label(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(label)
}

// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
//
// The function takes the following parameters:
//
//    - id returned by gtk.Widget.AddTickCallback().
//
func (widget *Widget) RemoveTickCallback(id uint) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.guint(id)

	C.gtk_widget_remove_tick_callback(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(id)
}

// SetCanFocus specifies whether the input focus can enter the widget or any of
// its children.
//
// Applications should set can_focus to FALSE to mark a widget as for
// pointer/touch use only.
//
// Note that having can_focus be TRUE is only one of the necessary conditions
// for being focusable. A widget must also be sensitive and focusable and not
// have an ancestor that is marked as not can-focus in order to receive input
// focus.
//
// See gtk.Widget.GrabFocus() for actually setting the input focus on a widget.
//
// The function takes the following parameters:
//
//    - canFocus: whether or not the input focus can enter the widget or any of
//      its children.
//
func (widget *Widget) SetCanFocus(canFocus bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if canFocus {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_focus(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(canFocus)
}

// SetCanTarget sets whether widget can be the target of pointer events.
//
// The function takes the following parameters:
//
//    - canTarget: whether this widget should be able to receive pointer events.
//
func (widget *Widget) SetCanTarget(canTarget bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if canTarget {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_target(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(canTarget)
}

// SetChildVisible sets whether widget should be mapped along with its parent.
//
// The child visibility can be set for widget before it is added to a container
// with gtk.Widget.SetParent(), to avoid mapping children unnecessary before
// immediately unmapping them. However it will be reset to its default state of
// TRUE when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a resize
// on the widget. Most of the time, the size of a widget is computed from all
// visible children, whether or not they are mapped. If this is not the case,
// the container can queue a resize itself.
//
// This function is only useful for container implementations and should never
// be called by an application.
//
// The function takes the following parameters:
//
//    - childVisible: if TRUE, widget should be mapped along with its parent.
//
func (widget *Widget) SetChildVisible(childVisible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if childVisible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_child_visible(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(childVisible)
}

// SetCSSClasses will clear all style classes applied to widget and replace them
// with classes.
//
// The function takes the following parameters:
//
//    - classes: NULL-terminated list of style classes to apply to widget.
//
func (widget *Widget) SetCSSClasses(classes []string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 **C.char     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(classes) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(classes)+1)
			var zero *C.char
			out[len(classes)] = zero
			for i := range classes {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(classes[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_widget_set_css_classes(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(classes)
}

// SetCursor sets the cursor to be shown when pointer devices point towards
// widget.
//
// If the cursor is NULL, widget will use the cursor inherited from the parent
// widget.
//
// The function takes the following parameters:
//
//    - cursor (optional): new cursor or NULL to use the default cursor.
//
func (widget *Widget) SetCursor(cursor *gdk.Cursor) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkCursor // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if cursor != nil {
		_arg1 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))
	}

	C.gtk_widget_set_cursor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cursor)
}

// SetCursorFromName sets a named cursor to be shown when pointer devices point
// towards widget.
//
// This is a utility function that creates a cursor via gdk.Cursor.NewFromName
// and then sets it on widget with gtk.Widget.SetCursor(). See those functions
// for details.
//
// On top of that, this function allows name to be NULL, which will do the same
// as calling gtk.Widget.SetCursor() with a NULL cursor.
//
// The function takes the following parameters:
//
//    - name (optional) of the cursor or NULL to use the default cursor.
//
func (widget *Widget) SetCursorFromName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_cursor_from_name(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
}

// SetDirection sets the reading direction on a particular widget.
//
// This direction controls the primary direction for widgets containing text,
// and also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct localization
// into languages with right-to-left reading directions can be done. Generally,
// applications will let the default reading direction present, except for
// containers where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk.Widget().SetDefaultDirection will be used.
//
// The function takes the following parameters:
//
//    - dir: new direction.
//
func (widget *Widget) SetDirection(dir TextDirection) {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkTextDirection(dir)

	C.gtk_widget_set_direction(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(dir)
}

// SetFocusChild: set child as the current focus child of widget.
//
// The previous focus child will be unset.
//
// This function is only suitable for widget implementations. If you want a
// certain widget to get the input focus, call gtk.Widget.GrabFocus() on it.
//
// The function takes the following parameters:
//
//    - child (optional): direct child widget of widget or NULL to unset the
//      focus child of widget.
//
func (widget *Widget) SetFocusChild(child Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_widget_set_focus_child(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(child)
}

// SetFocusOnClick sets whether the widget should grab focus when it is clicked
// with the mouse.
//
// Making mouse clicks not grab focus is useful in places like toolbars where
// you don’t want the keyboard focus removed from the main area of the
// application.
//
// The function takes the following parameters:
//
//    - focusOnClick: whether the widget should grab focus when clicked with the
//      mouse.
//
func (widget *Widget) SetFocusOnClick(focusOnClick bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if focusOnClick {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_focus_on_click(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(focusOnClick)
}

// SetFocusable specifies whether widget can own the input focus.
//
// Widget implementations should set focusable to TRUE in their init() function
// if they want to receive keyboard input.
//
// Note that having focusable be TRUE is only one of the necessary conditions
// for being focusable. A widget must also be sensitive and can-focus and not
// have an ancestor that is marked as not can-focus in order to receive input
// focus.
//
// See gtk.Widget.GrabFocus() for actually setting the input focus on a widget.
//
// The function takes the following parameters:
//
//    - focusable: whether or not widget can own the input focus.
//
func (widget *Widget) SetFocusable(focusable bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if focusable {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_focusable(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(focusable)
}

// SetFontMap sets the font map to use for Pango rendering.
//
// The font map is the object that is used to look up fonts. Setting a custom
// font map can be useful in special situations, e.g. when you need to add
// application-specific fonts to the set of available fonts.
//
// When not set, the widget will inherit the font map from its parent.
//
// The function takes the following parameters:
//
//    - fontMap (optional): PangoFontMap, or NULL to unset any previously set
//      font map.
//
func (widget *Widget) SetFontMap(fontMap pango.FontMapper) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.PangoFontMap // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if fontMap != nil {
		_arg1 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontMap).Native()))
	}

	C.gtk_widget_set_font_map(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(fontMap)
}

// SetFontOptions sets the cairo_font_options_t used for Pango rendering in this
// widget.
//
// When not set, the default font options for the GdkDisplay will be used.
//
// The function takes the following parameters:
//
//    - options (optional) or NULL to unset any previously set default font
//      options.
//
func (widget *Widget) SetFontOptions(options *cairo.FontOptions) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.cairo_font_options_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if options != nil {
		_arg1 = (*C.cairo_font_options_t)(gextras.StructNative(unsafe.Pointer(options)))
	}

	C.gtk_widget_set_font_options(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(options)
}

// SetHAlign sets the horizontal alignment of widget.
//
// The function takes the following parameters:
//
//    - align: horizontal alignment.
//
func (widget *Widget) SetHAlign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkAlign(align)

	C.gtk_widget_set_halign(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(align)
}

// SetHasTooltip sets the has-tooltip property on widget to has_tooltip.
//
// The function takes the following parameters:
//
//    - hasTooltip: whether or not widget has a tooltip.
//
func (widget *Widget) SetHasTooltip(hasTooltip bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if hasTooltip {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_tooltip(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(hasTooltip)
}

// SetHExpand sets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a GtkWindow, widgets with expand=TRUE generally receive
// the extra space. For example, a list or scrollable area or document in your
// window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget to
// become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk.Widget.ComputeExpand(). A container can decide
// how the expandability of children affects the expansion of the container by
// overriding the compute_expand virtual method on GtkWidget.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because gtk.Widget.SetHExpand() sets the
// hexpand-set property (see gtk.Widget.SetHExpandSet()) which causes the
// widget’s hexpand value to be used, rather than looking at children and widget
// state.
//
// The function takes the following parameters:
//
//    - expand: whether to expand.
//
func (widget *Widget) SetHExpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(expand)
}

// SetHExpandSet sets whether the hexpand flag will be used.
//
// The gtk.Widget:hexpand-set property will be set automatically when you call
// gtk.Widget.SetHExpand() to set hexpand, so the most likely reason to use this
// function would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
//
// The function takes the following parameters:
//
//    - set: value for hexpand-set property.
//
func (widget *Widget) SetHExpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand_set(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(set)
}

// SetLayoutManager sets the layout manager delegate instance that provides an
// implementation for measuring and allocating the children of widget.
//
// The function takes the following parameters:
//
//    - layoutManager (optional): GtkLayoutManager.
//
func (widget *Widget) SetLayoutManager(layoutManager LayoutManagerer) {
	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkLayoutManager // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if layoutManager != nil {
		_arg1 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(layoutManager).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(layoutManager).Native()))
	}

	C.gtk_widget_set_layout_manager(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(layoutManager)
}

// SetMarginBottom sets the bottom margin of widget.
//
// The function takes the following parameters:
//
//    - margin: bottom margin.
//
func (widget *Widget) SetMarginBottom(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(margin)

	C.gtk_widget_set_margin_bottom(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginEnd sets the end margin of widget.
//
// The function takes the following parameters:
//
//    - margin: end margin.
//
func (widget *Widget) SetMarginEnd(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(margin)

	C.gtk_widget_set_margin_end(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginStart sets the start margin of widget.
//
// The function takes the following parameters:
//
//    - margin: start margin.
//
func (widget *Widget) SetMarginStart(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(margin)

	C.gtk_widget_set_margin_start(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginTop sets the top margin of widget.
//
// The function takes the following parameters:
//
//    - margin: top margin.
//
func (widget *Widget) SetMarginTop(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(margin)

	C.gtk_widget_set_margin_top(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetName sets a widgets name.
//
// Setting a name allows you to refer to the widget from a CSS file. You can
// apply a style to widgets with a particular name in the CSS file. See the
// documentation for the CSS syntax (on the same page as the docs for
// gtk.StyleContext.
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these will
// make your widget impossible to match by name. Any combination of alphanumeric
// symbols, dashes and underscores will suffice.
//
// The function takes the following parameters:
//
//    - name for the widget.
//
func (widget *Widget) SetName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_name(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
}

// SetOpacity: request the widget to be rendered partially transparent.
//
// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
//
// Opacity works on both toplevel widgets and child widgets, although there are
// some limitations: For toplevel widgets, applying opacity depends on the
// capabilities of the windowing system. On X11, this has any effect only on X
// displays with a compositing manager, see gdk_display_is_composited(). On
// Windows and Wayland it should always work, although setting a window’s
// opacity after the window has been shown may cause some flicker.
//
// Note that the opacity is inherited through inclusion — if you set a toplevel
// to be partially translucent, all of its content will appear translucent,
// since it is ultimatively rendered on that toplevel. The opacity value itself
// is not inherited by child widgets (since that would make widgets deeper in
// the hierarchy progressively more translucent). As a consequence, gtk.Popovers
// and other gtk.Native widgets with their own surface will use their own
// opacity value, and thus by default appear non-translucent, even if they are
// attached to a toplevel that is translucent.
//
// The function takes the following parameters:
//
//    - opacity: desired opacity, between 0 and 1.
//
func (widget *Widget) SetOpacity(opacity float64) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(opacity)

	C.gtk_widget_set_opacity(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(opacity)
}

// SetOverflow sets how widget treats content that is drawn outside the widget's
// content area.
//
// See the definition of gtk.Overflow for details.
//
// This setting is provided for widget implementations and should not be used by
// application code.
//
// The default value is GTK_OVERFLOW_VISIBLE.
//
// The function takes the following parameters:
//
//    - overflow: desired overflow.
//
func (widget *Widget) SetOverflow(overflow Overflow) {
	var _arg0 *C.GtkWidget  // out
	var _arg1 C.GtkOverflow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOverflow(overflow)

	C.gtk_widget_set_overflow(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(overflow)
}

// SetParent sets parent as the parent widget of widget.
//
// This takes care of details such as updating the state and style of the child
// to reflect its new location and resizing the parent. The opposite function is
// gtk.Widget.Unparent().
//
// This function is useful only when implementing subclasses of GtkWidget.
//
// The function takes the following parameters:
//
//    - parent widget.
//
func (widget *Widget) SetParent(parent Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	C.gtk_widget_set_parent(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parent)
}

// SetReceivesDefault specifies whether widget will be treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// The function takes the following parameters:
//
//    - receivesDefault: whether or not widget can be a default widget.
//
func (widget *Widget) SetReceivesDefault(receivesDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if receivesDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_receives_default(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(receivesDefault)
}

// SetSensitive sets the sensitivity of a widget.
//
// A widget is sensitive if the user can interact with it. Insensitive widgets
// are “grayed out” and the user can’t interact with them. Insensitive widgets
// are known as “inactive”, “disabled”, or “ghosted” in some other toolkits.
//
// The function takes the following parameters:
//
//    - sensitive: TRUE to make the widget sensitive.
//
func (widget *Widget) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_sensitive(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(sensitive)
}

// SetSizeRequest sets the minimum size of a widget.
//
// That is, the widget’s size request will be at least width by height. You can
// use this function to force a widget to be larger than it normally would be.
//
// In most cases, gtk.Window.SetDefaultSize() is a better choice for toplevel
// windows than this function; setting the default size will still allow users
// to shrink the window. Setting the size request will force them to leave the
// window at least as large as the size request.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept while
// still functioning well and drawing itself correctly. However in some strange
// cases a widget may be allocated less than its requested size, and in many
// cases a widget may be allocated more space than it requested.
//
// If the size request in a given direction is -1 (unset), then the “natural”
// size request of the widget will be used instead.
//
// The size request set here does not include any margin from the properties
// gtk.Widget:margin-start, gtk.Widget:margin-end, gtk.Widget:margin-top, and
// gtk.Widget:margin-bottom, but it does include pretty much all other padding
// or border properties set by any subclass of GtkWidget.
//
// The function takes the following parameters:
//
//    - width widget should request, or -1 to unset.
//    - height widget should request, or -1 to unset.
//
func (widget *Widget) SetSizeRequest(width, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_widget_set_size_request(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetStateFlags turns on flag values in the current widget state.
//
// Typical widget states are insensitive, prelighted, etc.
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk.Widget.SetDirection().
//
// This function is for use in widget implementations.
//
// The function takes the following parameters:
//
//    - flags: state flags to turn on.
//    - clear: whether to clear state before turning on flags.
//
func (widget *Widget) SetStateFlags(flags StateFlags, clear bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(flags)
	if clear {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_state_flags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(clear)
}

// SetTooltipMarkup sets markup as the contents of the tooltip, which is marked
// up with Pango markup.
//
// This function will take care of setting the gtk.Widget:has-tooltip as a side
// effect, and of the default handler for the gtk.Widget::query-tooltip signal.
//
// See also gtk.Tooltip.SetMarkup().
//
// The function takes the following parameters:
//
//    - markup (optional) contents of the tooltip for widget.
//
func (widget *Widget) SetTooltipMarkup(markup string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if markup != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(markup)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_tooltip_markup(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(markup)
}

// SetTooltipText sets text as the contents of the tooltip.
//
// If text contains any markup, it will be escaped.
//
// This function will take care of setting gtk.Widget:has-tooltip as a side
// effect, and of the default handler for the gtk.Widget::query-tooltip signal.
//
// See also gtk.Tooltip.SetText().
//
// The function takes the following parameters:
//
//    - text (optional) contents of the tooltip for widget.
//
func (widget *Widget) SetTooltipText(text string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_tooltip_text(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(text)
}

// SetVAlign sets the vertical alignment of widget.
//
// The function takes the following parameters:
//
//    - align: vertical alignment.
//
func (widget *Widget) SetVAlign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkAlign(align)

	C.gtk_widget_set_valign(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(align)
}

// SetVExpand sets whether the widget would like any available extra vertical
// space.
//
// See gtk.Widget.SetHExpand() for more detail.
//
// The function takes the following parameters:
//
//    - expand: whether to expand.
//
func (widget *Widget) SetVExpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(expand)
}

// SetVExpandSet sets whether the vexpand flag will be used.
//
// See gtk.Widget.SetHExpandSet() for more detail.
//
// The function takes the following parameters:
//
//    - set: value for vexpand-set property.
//
func (widget *Widget) SetVExpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand_set(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(set)
}

// SetVisible sets the visibility state of widget.
//
// Note that setting this to TRUE doesn’t mean the widget is actually viewable,
// see gtk.Widget.GetVisible().
//
// This function simply calls gtk.Widget.Show() or gtk.Widget.Hide() but is
// nicer to use when the visibility of the widget depends on some condition.
//
// The function takes the following parameters:
//
//    - visible: whether the widget should be shown or not.
//
func (widget *Widget) SetVisible(visible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_visible(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(visible)
}

// ShouldLayout returns whether widget should contribute to the measuring and
// allocation of its parent.
//
// This is FALSE for invisible children, but also for children that have their
// own surface.
//
// The function returns the following values:
//
//    - ok: TRUE if child should be included in measuring and allocating.
//
func (widget *Widget) ShouldLayout() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_should_layout(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Show flags a widget to be displayed.
//
// Any widget that isn’t shown will not appear on the screen.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
func (widget *Widget) Show() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_show(_arg0)
	runtime.KeepAlive(widget)
}

// SizeAllocate allocates widget with a transformation that translates the
// origin to the position in allocation.
//
// This is a simple form of gtk.Widget.Allocate().
//
// The function takes the following parameters:
//
//    - allocation: position and size to be allocated to widget.
//    - baseline of the child, or -1.
//
func (widget *Widget) SizeAllocate(allocation *Allocation, baseline int) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))
	_arg2 = C.int(baseline)

	C.gtk_widget_size_allocate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(allocation)
	runtime.KeepAlive(baseline)
}

// SnapshotChild: snapshot the a child of widget.
//
// When a widget receives a call to the snapshot function, it must send
// synthetic GtkWidgetClass.snapshot() calls to all children. This function
// provides a convenient way of doing this. A widget, when it receives a call to
// its GtkWidgetClass.snapshot() function, calls gtk_widget_snapshot_child()
// once for each child, passing in the snapshot the widget received.
//
// gtk_widget_snapshot_child() takes care of translating the origin of snapshot,
// and deciding whether the child needs to be snapshot.
//
// This function does nothing for children that implement GtkNative.
//
// The function takes the following parameters:
//
//    - child of widget.
//    - snapshot as passed to the widget. In particular, no calls to
//      gtk_snapshot_translate() or other transform calls should have been made.
//
func (widget *Widget) SnapshotChild(child Widgetter, snapshot *Snapshot) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkSnapshot // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C.gtk_widget_snapshot_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(child)
	runtime.KeepAlive(snapshot)
}

// TranslateCoordinates: translate coordinates relative to src_widget’s
// allocation to coordinates relative to dest_widget’s allocations.
//
// In order to perform this operation, both widget must share a common ancestor.
//
// The function takes the following parameters:
//
//    - destWidget: GtkWidget.
//    - srcX: x position relative to src_widget.
//    - srcY: y position relative to src_widget.
//
// The function returns the following values:
//
//    - destX (optional): location to store X position relative to dest_widget.
//    - destY (optional): location to store Y position relative to dest_widget.
//    - ok: FALSE if src_widget and dest_widget have no common ancestor. In this
//      case, 0 is stored in *dest_x and *dest_y. Otherwise TRUE.
//
func (srcWidget *Widget) TranslateCoordinates(destWidget Widgetter, srcX, srcY float64) (destX, destY float64, ok bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out
	var _arg4 C.double     // in
	var _arg5 C.double     // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(srcWidget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(destWidget).Native()))
	_arg2 = C.double(srcX)
	_arg3 = C.double(srcY)

	_cret = C.gtk_widget_translate_coordinates(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(srcWidget)
	runtime.KeepAlive(destWidget)
	runtime.KeepAlive(srcX)
	runtime.KeepAlive(srcY)

	var _destX float64 // out
	var _destY float64 // out
	var _ok bool       // out

	_destX = float64(_arg4)
	_destY = float64(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _destX, _destY, _ok
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of widget is located.
func (widget *Widget) TriggerTooltipQuery() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_trigger_tooltip_query(_arg0)
	runtime.KeepAlive(widget)
}

// Unmap causes a widget to be unmapped if it’s currently mapped.
//
// This function is only for use in widget implementations.
func (widget *Widget) Unmap() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unmap(_arg0)
	runtime.KeepAlive(widget)
}

// Unparent: dissociate widget from its parent.
//
// This function is only for use in widget implementations, typically in
// dispose.
func (widget *Widget) Unparent() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unparent(_arg0)
	runtime.KeepAlive(widget)
}

// Unrealize causes a widget to be unrealized (frees all GDK resources
// associated with the widget).
//
// This function is only useful in widget implementations.
func (widget *Widget) Unrealize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unrealize(_arg0)
	runtime.KeepAlive(widget)
}

// UnsetStateFlags turns off flag values for the current widget state.
//
// See gtk.Widget.SetStateFlags().
//
// This function is for use in widget implementations.
//
// The function takes the following parameters:
//
//    - flags: state flags to turn off.
//
func (widget *Widget) UnsetStateFlags(flags StateFlags) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(flags)

	C.gtk_widget_unset_state_flags(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
}

// Contains tests if the point at (x, y) is contained in widget.
//
// The coordinates for (x, y) must be in widget coordinates, so (0, 0) is
// assumed to be the top left of widget's content area.
//
// The function takes the following parameters:
//
//    - x: x coordinate to test, relative to widget's origin.
//    - y: y coordinate to test, relative to widget's origin.
//
// The function returns the following values:
//
//    - ok: TRUE if widget contains (x, y).
//
func (widget *Widget) contains(x, y float64) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.contains

	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(x)
	_arg2 = C.double(y)

	_cret = C._gotk4_gtk4_Widget_virtual_contains(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (widget *Widget) directionChanged(previousDirection TextDirection) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.direction_changed

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkTextDirection(previousDirection)

	C._gotk4_gtk4_Widget_virtual_direction_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousDirection)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) focus(direction DirectionType) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.focus

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C._gotk4_gtk4_Widget_virtual_focus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// requestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
//
// Single-child widgets generally propagate the preference of their child, more
// complex widgets need to request something either in context of their children
// or in context of their allocation capabilities.
//
// The function returns the following values:
//
//    - sizeRequestMode: GtkSizeRequestMode preferred by widget.
//
func (widget *Widget) requestMode() SizeRequestMode {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.get_request_mode

	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C._gotk4_gtk4_Widget_virtual_get_request_mode(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// grabFocus causes widget to have the keyboard focus for the GtkWindow it's
// inside.
//
// If widget is not focusable, or its ::grab_focus implementation cannot
// transfer the focus to a descendant of widget that is focusable, it will not
// take focus and FALSE will be returned.
//
// Calling gtk.Widget.GrabFocus() on an already focused widget is allowed,
// should not have an effect, and return TRUE.
//
// The function returns the following values:
//
//    - ok: TRUE if focus is now inside widget.
//
func (widget *Widget) grabFocus() bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.grab_focus

	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C._gotk4_gtk4_Widget_virtual_grab_focus(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide reverses the effects of gtk_widget_show().
//
// This is causing the widget to be hidden (invisible to the user).
func (widget *Widget) hide() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.hide

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_hide(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// keynavFailed emits the ::keynav-failed signal on the widget.
//
// This function should be called whenever keyboard navigation within a single
// widget hits a boundary.
//
// The return value of this function should be interpreted in a way similar to
// the return value of gtk.Widget.ChildFocus(). When TRUE is returned, stay in
// the widget, the failed keyboard navigation is OK and/or there is nowhere we
// can/should move the focus to. When FALSE is returned, the caller should
// continue with keyboard navigation outside the widget, e.g. by calling
// gtk.Widget.ChildFocus() on the widget’s toplevel.
//
// The default gtk.Widget::keynav-failed handler returns FALSE for
// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
// DirectionType it returns TRUE.
//
// Whenever the default handler returns TRUE, it also calls
// gtk.Widget.ErrorBell() to notify the user of the failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either by
// connecting to it or by overriding it) would be a row of gtk.Entry widgets
// where the user should be able to navigate the entire row with the cursor
// keys, as e.g. known from user interfaces that require entering license keys.
//
// The function takes the following parameters:
//
//    - direction of focus movement.
//
// The function returns the following values:
//
//    - ok: TRUE if stopping keyboard navigation is fine, FALSE if the emitting
//      widget should try to handle the keyboard navigation attempt in its parent
//      container(s).
//
func (widget *Widget) keynavFailed(direction DirectionType) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.keynav_failed

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C._gotk4_gtk4_Widget_virtual_keynav_failed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Map causes a widget to be mapped if it isn’t already.
//
// This function is only for use in widget implementations.
func (widget *Widget) _map() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass._map

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_map(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// Measure measures widget in the orientation orientation and for the given
// for_size.
//
// As an example, if orientation is GTK_ORIENTATION_HORIZONTAL and for_size is
// 300, this functions will compute the minimum and natural width of widget if
// it is allocated at a height of 300 pixels.
//
// See GtkWidget’s geometry management section
// (class.Widget.html#height-for-width-geometry-management) for a more details
// on implementing WidgetClass.measure().
//
// The function takes the following parameters:
//
//    - orientation to measure.
//    - forSize: size for the opposite of orientation, i.e. if orientation is
//      GTK_ORIENTATION_HORIZONTAL, this is the height the widget should be
//      measured with. The GTK_ORIENTATION_VERTICAL case is analogous. This way,
//      both height-for-width and width-for-height requests can be implemented.
//      If no size is known, -1 can be passed.
//
// The function returns the following values:
//
//    - minimum (optional): location to store the minimum size, or NULL.
//    - natural (optional): location to store the natural size, or NULL.
//    - minimumBaseline (optional): location to store the baseline position for
//      the minimum size, or NULL.
//    - naturalBaseline (optional): location to store the baseline position for
//      the natural size, or NULL.
//
func (widget *Widget) measure(orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.measure

	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _arg2 C.int            // out
	var _arg3 C.int            // in
	var _arg4 C.int            // in
	var _arg5 C.int            // in
	var _arg6 C.int            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.int(forSize)

	C._gotk4_gtk4_Widget_virtual_measure(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(forSize)

	var _minimum int         // out
	var _natural int         // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimum = int(_arg3)
	_natural = int(_arg4)
	_minimumBaseline = int(_arg5)
	_naturalBaseline = int(_arg6)

	return _minimum, _natural, _minimumBaseline, _naturalBaseline
}

// mnemonicActivate emits the GtkWidget::mnemonic-activate signal.
//
// The function takes the following parameters:
//
//    - groupCycling: TRUE if there are other widgets with the same mnemonic.
//
// The function returns the following values:
//
//    - ok: TRUE if the signal has been handled.
//
func (widget *Widget) mnemonicActivate(groupCycling bool) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.mnemonic_activate

	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gtk4_Widget_virtual_mnemonic_activate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(groupCycling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (widget *Widget) moveFocus(direction DirectionType) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.move_focus

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	C._gotk4_gtk4_Widget_virtual_move_focus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)
}

// The function takes the following parameters:
//
//    - x
//    - y
//    - keyboardTooltip
//    - tooltip
//
// The function returns the following values:
//
func (widget *Widget) queryTooltip(x, y int, keyboardTooltip bool, tooltip *Tooltip) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.query_tooltip

	var _arg0 *C.GtkWidget  // out
	var _arg1 C.int         // out
	var _arg2 C.int         // out
	var _arg3 C.gboolean    // out
	var _arg4 *C.GtkTooltip // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	if keyboardTooltip {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))

	_cret = C._gotk4_gtk4_Widget_virtual_query_tooltip(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(keyboardTooltip)
	runtime.KeepAlive(tooltip)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Realize creates the GDK resources associated with a widget.
//
// Normally realization happens implicitly; if you show a widget and all its
// parent containers, then the widget will be realized and mapped automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling this function realizes the widget’s parents in addition to widget
// itself. If a widget is not yet inside a toplevel window when you realize it,
// bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as gtk.Widget::realize.
func (widget *Widget) realize() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.realize

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_realize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

func (widget *Widget) root() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.root

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_root(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// setFocusChild: set child as the current focus child of widget.
//
// The previous focus child will be unset.
//
// This function is only suitable for widget implementations. If you want a
// certain widget to get the input focus, call gtk.Widget.GrabFocus() on it.
//
// The function takes the following parameters:
//
//    - child (optional): direct child widget of widget or NULL to unset the
//      focus child of widget.
//
func (widget *Widget) setFocusChild(child Widgetter) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.set_focus_child

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C._gotk4_gtk4_Widget_virtual_set_focus_child(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(child)
}

// Show flags a widget to be displayed.
//
// Any widget that isn’t shown will not appear on the screen.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
func (widget *Widget) show() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.show

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_show(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
//    - width
//    - height
//    - baseline
//
func (widget *Widget) sizeAllocate(width, height, baseline int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.size_allocate

	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)
	_arg3 = C.int(baseline)

	C._gotk4_gtk4_Widget_virtual_size_allocate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(baseline)
}

// The function takes the following parameters:
//
func (widget *Widget) snapshot(snapshot *Snapshot) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.snapshot

	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GtkSnapshot // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C._gotk4_gtk4_Widget_virtual_snapshot(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(snapshot)
}

// The function takes the following parameters:
//
func (widget *Widget) stateFlagsChanged(previousStateFlags StateFlags) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.state_flags_changed

	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(previousStateFlags)

	C._gotk4_gtk4_Widget_virtual_state_flags_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousStateFlags)
}

// The function takes the following parameters:
//
func (widget *Widget) systemSettingChanged(settings SystemSetting) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.system_setting_changed

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkSystemSetting // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkSystemSetting(settings)

	C._gotk4_gtk4_Widget_virtual_system_setting_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(settings)
}

// Unmap causes a widget to be unmapped if it’s currently mapped.
//
// This function is only for use in widget implementations.
func (widget *Widget) unmap() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unmap

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_unmap(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// Unrealize causes a widget to be unrealized (frees all GDK resources
// associated with the widget).
//
// This function is only useful in widget implementations.
func (widget *Widget) unrealize() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unrealize

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_unrealize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

func (widget *Widget) unroot() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unroot

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_unroot(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// WidgetGetDefaultDirection obtains the current default reading direction.
//
// See gtk.Widget().SetDefaultDirection.
//
// The function returns the following values:
//
//    - textDirection: current default direction.
//
func WidgetGetDefaultDirection() TextDirection {
	var _cret C.GtkTextDirection // in

	_cret = C.gtk_widget_get_default_direction()

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// WidgetSetDefaultDirection sets the default reading direction for widgets.
//
// See gtk.Widget.SetDirection().
//
// The function takes the following parameters:
//
//    - dir: new default direction. This cannot be GTK_TEXT_DIR_NONE.
//
func WidgetSetDefaultDirection(dir TextDirection) {
	var _arg1 C.GtkTextDirection // out

	_arg1 = C.GtkTextDirection(dir)

	C.gtk_widget_set_default_direction(_arg1)
	runtime.KeepAlive(dir)
}

// Requisition represents the desired size of a widget. See [GtkWidget’s
// geometry management section][geometry-management] for more information.
//
// An instance of this type is always passed by reference.
type Requisition struct {
	*requisition
}

// requisition is the struct that's finalized.
type requisition struct {
	native *C.GtkRequisition
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Requisition{&requisition{(*C.GtkRequisition)(b)}}, nil
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	var _cret *C.GtkRequisition // in

	_cret = C.gtk_requisition_new()

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_requisition)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_requisition_free((*C.GtkRequisition)(intern.C))
		},
	)

	return _requisition
}

// Width widget’s desired width.
func (r *Requisition) Width() int {
	valptr := &r.native.width
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Height widget’s desired height.
func (r *Requisition) Height() int {
	valptr := &r.native.height
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width widget’s desired width.
func (r *Requisition) SetWidth(width int) {
	valptr := &r.native.width
	*valptr = C.int(width)
}

// Height widget’s desired height.
func (r *Requisition) SetHeight(height int) {
	valptr := &r.native.height
	*valptr = C.int(height)
}

// Copy copies a GtkRequisition.
//
// The function returns the following values:
//
//    - ret: copy of requisition.
//
func (requisition *Requisition) Copy() *Requisition {
	var _arg0 *C.GtkRequisition // out
	var _cret *C.GtkRequisition // in

	_arg0 = (*C.GtkRequisition)(gextras.StructNative(unsafe.Pointer(requisition)))

	_cret = C.gtk_requisition_copy(_arg0)
	runtime.KeepAlive(requisition)

	var _ret *Requisition // out

	_ret = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_requisition_free((*C.GtkRequisition)(intern.C))
		},
	)

	return _ret
}

// WidgetClass: instance of this type is always passed by reference.
type WidgetClass struct {
	*widgetClass
}

// widgetClass is the struct that's finalized.
type widgetClass struct {
	native *C.GtkWidgetClass
}

// AddShortcut installs a shortcut in widget_class.
//
// Every instance created for widget_class or its subclasses will inherit this
// shortcut and trigger it.
//
// Shortcuts added this way will be triggered in the GTK_PHASE_BUBBLE phase,
// which means they may also trigger if child widgets have focus.
//
// This function must only be used in class initialization functions otherwise
// it is not guaranteed that the shortcut will be installed.
//
// The function takes the following parameters:
//
//    - shortcut to add.
//
func (widgetClass *WidgetClass) AddShortcut(shortcut *Shortcut) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.GtkShortcut    // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(shortcut).Native()))

	C.gtk_widget_class_add_shortcut(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(shortcut)
}

// BindTemplateChildFull: automatically assign an object declared in the class
// template XML to be set to a location on a freshly built instance’s private
// data, or alternatively accessible via gtk.Widget.GetTemplateChild().
//
// The struct can point either into the public instance, then you should use
// G_STRUCT_OFFSET(WidgetType, member) for struct_offset, or in the private
// struct, then you should use G_PRIVATE_OFFSET(WidgetType, member).
//
// An explicit strong reference will be held automatically for the duration of
// your instance’s life cycle, it will be released automatically when
// GObjectClass.dispose() runs on your instance and if a struct_offset that is
// != 0 is specified, then the automatic location in your instance public or
// private data will be set to NULL. You can however access an automated child
// pointer the first time your classes GObjectClass.dispose() runs, or
// alternatively in gtk.Widget::destroy.
//
// If internal_child is specified, gtk.Buildable.GetInternalChild() will be
// automatically implemented by the GtkWidget class so there is no need to
// implement it manually.
//
// The wrapper macros gtk.WidgetClassBindTemplateChild(),
// gtk.WidgetClassBindTemplateChildInternal(),
// gtk.WidgetClassBindTemplateChildPrivate() and
// gtk.WidgetClassBindTemplateChildInternalPrivate() might be more convenient to
// use.
//
// Note that this must be called from a composite widget classes class
// initializer after calling gtk.WidgetClass.SetTemplate().
//
// The function takes the following parameters:
//
//    - name: “id” of the child defined in the template XML.
//    - internalChild: whether the child should be accessible as an
//      “internal-child” when this class is used in GtkBuilder XML.
//    - structOffset: structure offset into the composite widget’s instance
//      public or private structure where the automated child pointer should be
//      set, or 0 to not assign the pointer.
//
func (widgetClass *WidgetClass) BindTemplateChildFull(name string, internalChild bool, structOffset int) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out
	var _arg2 C.gboolean        // out
	var _arg3 C.gssize          // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if internalChild {
		_arg2 = C.TRUE
	}
	_arg3 = C.gssize(structOffset)

	C.gtk_widget_class_bind_template_child_full(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(name)
	runtime.KeepAlive(internalChild)
	runtime.KeepAlive(structOffset)
}

// AccessibleRole retrieves the accessible role used by the given GtkWidget
// class.
//
// Different accessible roles have different states, and are rendered
// differently by assistive technologies.
//
// See also: gtk.Accessible.GetAccessibleRole().
//
// The function returns the following values:
//
//    - accessibleRole: accessible role for the widget class.
//
func (widgetClass *WidgetClass) AccessibleRole() AccessibleRole {
	var _arg0 *C.GtkWidgetClass   // out
	var _cret C.GtkAccessibleRole // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_accessible_role(_arg0)
	runtime.KeepAlive(widgetClass)

	var _accessibleRole AccessibleRole // out

	_accessibleRole = AccessibleRole(_cret)

	return _accessibleRole
}

// ActivateSignal retrieves the signal id for the activation signal set using
// gtk_widget_class_set_activate_signal().
//
// The function returns the following values:
//
//    - guint: signal id, or 0 if the widget class does not specify an activation
//      signal.
//
func (widgetClass *WidgetClass) ActivateSignal() uint {
	var _arg0 *C.GtkWidgetClass // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_activate_signal(_arg0)
	runtime.KeepAlive(widgetClass)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CSSName gets the name used by this class for matching in CSS code.
//
// See gtk_widget_class_set_css_name() for details.
//
// The function returns the following values:
//
//    - utf8: CSS name of the given class.
//
func (widgetClass *WidgetClass) CSSName() string {
	var _arg0 *C.GtkWidgetClass // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_css_name(_arg0)
	runtime.KeepAlive(widgetClass)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// LayoutManagerType retrieves the type of the gtk.LayoutManager used by the
// GtkWidget class.
//
// See also: gtk_widget_class_set_layout_manager_type().
//
// The function returns the following values:
//
//    - gType: type of a GtkLayoutManager subclass, or G_TYPE_INVALID.
//
func (widgetClass *WidgetClass) LayoutManagerType() coreglib.Type {
	var _arg0 *C.GtkWidgetClass // out
	var _cret C.GType           // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_layout_manager_type(_arg0)
	runtime.KeepAlive(widgetClass)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// InstallPropertyAction installs an action called action_name on widget_class
// and binds its state to the value of the property_name property.
//
// This function will perform a few santity checks on the property selected via
// property_name. Namely, the property must exist, must be readable, writable
// and must not be construct-only. There are also restrictions on the type of
// the given property, it must be boolean, int, unsigned int, double or string.
// If any of these conditions are not met, a critical warning will be printed
// and no action will be added.
//
// The state type of the action matches the property type.
//
// If the property is boolean, the action will have no parameter and toggle the
// property value. Otherwise, the action will have a parameter of the same type
// as the property.
//
// The function takes the following parameters:
//
//    - actionName: name of the action.
//    - propertyName: name of the property in instances of widget_class or any
//      parent class.
//
func (widgetClass *WidgetClass) InstallPropertyAction(actionName string, propertyName string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_class_install_property_action(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(propertyName)
}

// QueryAction queries the actions that have been installed for a widget class
// using gtk.WidgetClass.InstallAction() during class initialization.
//
// Note that this function will also return actions defined by parent classes.
// You can identify those by looking at owner.
//
// The function takes the following parameters:
//
//    - index_: position of the action to query.
//
// The function returns the following values:
//
//    - owner: return location for the type where the action was defined.
//    - actionName: return location for the action name.
//    - parameterType (optional): return location for the parameter type.
//    - propertyName (optional): return location for the property name.
//    - ok: TRUE if the action was found, FALSE if index_ is out of range.
//
func (widgetClass *WidgetClass) QueryAction(index_ uint) (owner coreglib.Type, actionName string, parameterType *glib.VariantType, propertyName string, ok bool) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 C.guint           // out
	var _arg2 C.GType           // in
	var _arg3 *C.char           // in
	var _arg4 *C.GVariantType   // in
	var _arg5 *C.char           // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.guint(index_)

	_cret = C.gtk_widget_class_query_action(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(index_)

	var _owner coreglib.Type             // out
	var _actionName string               // out
	var _parameterType *glib.VariantType // out
	var _propertyName string             // out
	var _ok bool                         // out

	_owner = coreglib.Type(_arg2)
	_actionName = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	defer C.free(unsafe.Pointer(_arg3))
	if _arg4 != nil {
		_parameterType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_arg4)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_parameterType)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_type_free((*C.GVariantType)(intern.C))
			},
		)
	}
	if _arg5 != nil {
		_propertyName = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if _cret != 0 {
		_ok = true
	}

	return _owner, _actionName, _parameterType, _propertyName, _ok
}

// SetAccessibleRole sets the accessible role used by the given GtkWidget class.
//
// Different accessible roles have different states, and are rendered
// differently by assistive technologies.
//
// The function takes the following parameters:
//
//    - accessibleRole: GtkAccessibleRole used by the widget_class.
//
func (widgetClass *WidgetClass) SetAccessibleRole(accessibleRole AccessibleRole) {
	var _arg0 *C.GtkWidgetClass   // out
	var _arg1 C.GtkAccessibleRole // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.GtkAccessibleRole(accessibleRole)

	C.gtk_widget_class_set_accessible_role(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(accessibleRole)
}

// SetActivateSignal sets the GtkWidgetClass.activate_signal field with the
// given signal_id; the signal will be emitted when calling
// gtk_widget_activate().
//
// The signal_id must have been registered with g_signal_new() or
// g_signal_newv() before calling this function.
//
// The function takes the following parameters:
//
//    - signalId: id for the activate signal.
//
func (widgetClass *WidgetClass) SetActivateSignal(signalId uint) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.guint(signalId)

	C.gtk_widget_class_set_activate_signal(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(signalId)
}

// SetActivateSignalFromName sets the GtkWidgetClass.activate_signal field with
// the signal id for the given signal_name; the signal will be emitted when
// calling gtk_widget_activate().
//
// The signal_name of widget_type must have been registered with g_signal_new()
// or g_signal_newv() before calling this function.
//
// The function takes the following parameters:
//
//    - signalName: name of the activate signal of widget_type.
//
func (widgetClass *WidgetClass) SetActivateSignalFromName(signalName string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(signalName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_class_set_activate_signal_from_name(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(signalName)
}

// SetCSSName sets the name to be used for CSS matching of widgets.
//
// If this function is not called for a given class, the name set on the parent
// class is used. By default, GtkWidget uses the name "widget".
//
// The function takes the following parameters:
//
//    - name to use.
//
func (widgetClass *WidgetClass) SetCSSName(name string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_class_set_css_name(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(name)
}

// SetLayoutManagerType sets the type to be used for creating layout managers
// for widgets of widget_class.
//
// The given type must be a subtype of gtk.LayoutManager.
//
// This function should only be called from class init functions of widgets.
//
// The function takes the following parameters:
//
//    - typ: object type that implements the GtkLayoutManager for widget_class.
//
func (widgetClass *WidgetClass) SetLayoutManagerType(typ coreglib.Type) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 C.GType           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.GType(typ)

	C.gtk_widget_class_set_layout_manager_type(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(typ)
}

// SetTemplate: this should be called at class initialization time to specify
// the GtkBuilder XML to be used to extend a widget.
//
// For convenience, gtk.WidgetClass.SetTemplateFromResource() is also provided.
//
// Note that any class that installs templates must call
// gtk.Widget.InitTemplate() in the widget’s instance initializer.
//
// The function takes the following parameters:
//
//    - templateBytes holding the Builder XML.
//
func (widgetClass *WidgetClass) SetTemplate(templateBytes *glib.Bytes) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.GBytes         // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(templateBytes)))

	C.gtk_widget_class_set_template(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(templateBytes)
}

// SetTemplateFromResource: convenience function that calls
// gtk.WidgetClass.SetTemplate() with the contents of a GResource.
//
// Note that any class that installs templates must call
// gtk.Widget.InitTemplate() in the widget’s instance initializer.
//
// The function takes the following parameters:
//
//    - resourceName: name of the resource to load the template from.
//
func (widgetClass *WidgetClass) SetTemplateFromResource(resourceName string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourceName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_class_set_template_from_resource(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(resourceName)
}

// SetTemplateScope: for use in language bindings, this will override the
// default GtkBuilderScope to be used when parsing GtkBuilder XML from this
// class’s template data.
//
// Note that this must be called from a composite widget classes class
// initializer after calling gtk_widget_class_set_template().
//
// The function takes the following parameters:
//
//    - scope: GtkBuilderScope to use when loading the class template.
//
func (widgetClass *WidgetClass) SetTemplateScope(scope BuilderScoper) {
	var _arg0 *C.GtkWidgetClass  // out
	var _arg1 *C.GtkBuilderScope // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(coreglib.InternObject(scope).Native()))

	C.gtk_widget_class_set_template_scope(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(scope)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

//export _gotk4_gtk4_StyleProvider_ConnectGTKPrivateChanged
func _gotk4_gtk4_StyleProvider_ConnectGTKPrivateChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk4_AdjustmentClass_changed
func _gotk4_gtk4_AdjustmentClass_changed(arg0 *C.GtkAdjustment) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AdjustmentOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AdjustmentOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk4_AdjustmentClass_value_changed
func _gotk4_gtk4_AdjustmentClass_value_changed(arg0 *C.GtkAdjustment) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[AdjustmentOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected AdjustmentOverrides.ValueChanged, got none")
	}

	overrides.ValueChanged()
}

//export _gotk4_gtk4_ApplicationClass_window_added
func _gotk4_gtk4_ApplicationClass_window_added(arg0 *C.GtkApplication, arg1 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ApplicationOverrides](instance0)
	if overrides.WindowAdded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ApplicationOverrides.WindowAdded, got none")
	}

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.WindowAdded(_window)
}

//export _gotk4_gtk4_ApplicationClass_window_removed
func _gotk4_gtk4_ApplicationClass_window_removed(arg0 *C.GtkApplication, arg1 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ApplicationOverrides](instance0)
	if overrides.WindowRemoved == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ApplicationOverrides.WindowRemoved, got none")
	}

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.WindowRemoved(_window)
}

//export _gotk4_gtk4_ButtonClass_activate
func _gotk4_gtk4_ButtonClass_activate(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk4_ButtonClass_clicked
func _gotk4_gtk4_ButtonClass_clicked(arg0 *C.GtkButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ButtonOverrides](instance0)
	if overrides.Clicked == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ButtonOverrides.Clicked, got none")
	}

	overrides.Clicked()
}

//export _gotk4_gtk4_CellAreaClass_activate
func _gotk4_gtk4_CellAreaClass_activate(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GdkRectangle, arg4 C.GtkCellRendererState, arg5 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Activate, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _cellArea *gdk.Rectangle  // out
	var _flags CellRendererState  // out
	var _editOnly bool            // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_flags = CellRendererState(arg4)
	if arg5 != 0 {
		_editOnly = true
	}

	ok := overrides.Activate(_context, _widget, _cellArea, _flags, _editOnly)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_CellAreaClass_add
func _gotk4_gtk4_CellAreaClass_add(arg0 *C.GtkCellArea, arg1 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Add == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Add, got none")
	}

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	overrides.Add(_renderer)
}

//export _gotk4_gtk4_CellAreaClass_apply_attributes
func _gotk4_gtk4_CellAreaClass_apply_attributes(arg0 *C.GtkCellArea, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gboolean, arg4 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.ApplyAttributes == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.ApplyAttributes, got none")
	}

	var _treeModel TreeModeller // out
	var _iter *TreeIter         // out
	var _isExpander bool        // out
	var _isExpanded bool        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_treeModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	if arg3 != 0 {
		_isExpander = true
	}
	if arg4 != 0 {
		_isExpanded = true
	}

	overrides.ApplyAttributes(_treeModel, _iter, _isExpander, _isExpanded)
}

//export _gotk4_gtk4_CellAreaClass_copy_context
func _gotk4_gtk4_CellAreaClass_copy_context(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext) (cret *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.CopyContext == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.CopyContext, got none")
	}

	var _context *CellAreaContext // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))

	cellAreaContext := overrides.CopyContext(_context)

	var _ *CellAreaContext

	cret = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(cellAreaContext).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(cellAreaContext).Native()))

	return cret
}

//export _gotk4_gtk4_CellAreaClass_create_context
func _gotk4_gtk4_CellAreaClass_create_context(arg0 *C.GtkCellArea) (cret *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.CreateContext == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.CreateContext, got none")
	}

	cellAreaContext := overrides.CreateContext()

	var _ *CellAreaContext

	cret = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(cellAreaContext).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(cellAreaContext).Native()))

	return cret
}

//export _gotk4_gtk4_CellAreaClass_event
func _gotk4_gtk4_CellAreaClass_event(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GdkEvent, arg4 *C.GdkRectangle, arg5 C.GtkCellRendererState) (cret C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Event == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Event, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _event gdk.Eventer        // out
	var _cellArea *gdk.Rectangle  // out
	var _flags CellRendererState  // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gdk.Eventer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Eventer)
			return ok
		})
		rv, ok := casted.(gdk.Eventer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Eventer")
		}
		_event = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_flags = CellRendererState(arg5)

	gint := overrides.Event(_context, _widget, _event, _cellArea, _flags)

	var _ int

	cret = C.int(gint)

	return cret
}

//export _gotk4_gtk4_CellAreaClass_focus
func _gotk4_gtk4_CellAreaClass_focus(arg0 *C.GtkCellArea, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Focus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Focus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.Focus(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_CellAreaClass_get_preferred_height
func _gotk4_gtk4_CellAreaClass_get_preferred_height(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.int, arg4 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredHeight, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumHeight, naturalHeight := overrides.PreferredHeight(_context, _widget)

	var _ int
	var _ int

	*arg3 = C.int(minimumHeight)
	*arg4 = C.int(naturalHeight)
}

//export _gotk4_gtk4_CellAreaClass_get_preferred_height_for_width
func _gotk4_gtk4_CellAreaClass_get_preferred_height_for_width(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 C.int, arg4 *C.int, arg5 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredHeightForWidth, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _width int                // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int(arg3)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_context, _widget, _width)

	var _ int
	var _ int

	*arg4 = C.int(minimumHeight)
	*arg5 = C.int(naturalHeight)
}

//export _gotk4_gtk4_CellAreaClass_get_preferred_width
func _gotk4_gtk4_CellAreaClass_get_preferred_width(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.int, arg4 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredWidth, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumWidth, naturalWidth := overrides.PreferredWidth(_context, _widget)

	var _ int
	var _ int

	*arg3 = C.int(minimumWidth)
	*arg4 = C.int(naturalWidth)
}

//export _gotk4_gtk4_CellAreaClass_get_preferred_width_for_height
func _gotk4_gtk4_CellAreaClass_get_preferred_width_for_height(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 C.int, arg4 *C.int, arg5 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.PreferredWidthForHeight, got none")
	}

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _height int               // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int(arg3)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_context, _widget, _height)

	var _ int
	var _ int

	*arg4 = C.int(minimumWidth)
	*arg5 = C.int(naturalWidth)
}

//export _gotk4_gtk4_CellAreaClass_get_request_mode
func _gotk4_gtk4_CellAreaClass_get_request_mode(arg0 *C.GtkCellArea) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk4_CellAreaClass_is_activatable
func _gotk4_gtk4_CellAreaClass_is_activatable(arg0 *C.GtkCellArea) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.IsActivatable == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.IsActivatable, got none")
	}

	ok := overrides.IsActivatable()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_CellAreaClass_remove
func _gotk4_gtk4_CellAreaClass_remove(arg0 *C.GtkCellArea, arg1 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Remove == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Remove, got none")
	}

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	overrides.Remove(_renderer)
}

//export _gotk4_gtk4_CellAreaClass_snapshot
func _gotk4_gtk4_CellAreaClass_snapshot(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GtkSnapshot, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState, arg7 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaOverrides](instance0)
	if overrides.Snapshot == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaOverrides.Snapshot, got none")
	}

	var _context *CellAreaContext      // out
	var _widget Widgetter              // out
	var _snapshot *Snapshot            // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out
	var _paintFocus bool               // out

	_context = wrapCellAreaContext(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_snapshot = wrapSnapshot(coreglib.Take(unsafe.Pointer(arg3)))
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)
	if arg7 != 0 {
		_paintFocus = true
	}

	overrides.Snapshot(_context, _widget, _snapshot, _backgroundArea, _cellArea, _flags, _paintFocus)
}

//export _gotk4_gtk4_CellAreaContextClass_allocate
func _gotk4_gtk4_CellAreaContextClass_allocate(arg0 *C.GtkCellAreaContext, arg1 C.int, arg2 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.Allocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.Allocate, got none")
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	overrides.Allocate(_width, _height)
}

//export _gotk4_gtk4_CellAreaContextClass_get_preferred_height_for_width
func _gotk4_gtk4_CellAreaContextClass_get_preferred_height_for_width(arg0 *C.GtkCellAreaContext, arg1 C.int, arg2 *C.int, arg3 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.PreferredHeightForWidth, got none")
	}

	var _width int // out

	_width = int(arg1)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_width)

	var _ int
	var _ int

	*arg2 = C.int(minimumHeight)
	*arg3 = C.int(naturalHeight)
}

//export _gotk4_gtk4_CellAreaContextClass_get_preferred_width_for_height
func _gotk4_gtk4_CellAreaContextClass_get_preferred_width_for_height(arg0 *C.GtkCellAreaContext, arg1 C.int, arg2 *C.int, arg3 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.PreferredWidthForHeight, got none")
	}

	var _height int // out

	_height = int(arg1)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_height)

	var _ int
	var _ int

	*arg2 = C.int(minimumWidth)
	*arg3 = C.int(naturalWidth)
}

//export _gotk4_gtk4_CellAreaContextClass_reset
func _gotk4_gtk4_CellAreaContextClass_reset(arg0 *C.GtkCellAreaContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellAreaContextOverrides](instance0)
	if overrides.Reset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellAreaContextOverrides.Reset, got none")
	}

	overrides.Reset()
}

//export _gotk4_gtk4_CellRendererClass_activate
func _gotk4_gtk4_CellRendererClass_activate(arg0 *C.GtkCellRenderer, arg1 *C.GdkEvent, arg2 *C.GtkWidget, arg3 *C.char, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.Activate, got none")
	}

	var _event gdk.Eventer             // out
	var _widget Widgetter              // out
	var _path string                   // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Eventer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Eventer)
			return ok
		})
		rv, ok := casted.(gdk.Eventer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Eventer")
		}
		_event = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)

	ok := overrides.Activate(_event, _widget, _path, _backgroundArea, _cellArea, _flags)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_CellRendererClass_editing_canceled
func _gotk4_gtk4_CellRendererClass_editing_canceled(arg0 *C.GtkCellRenderer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.EditingCanceled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.EditingCanceled, got none")
	}

	overrides.EditingCanceled()
}

//export _gotk4_gtk4_CellRendererClass_editing_started
func _gotk4_gtk4_CellRendererClass_editing_started(arg0 *C.GtkCellRenderer, arg1 *C.GtkCellEditable, arg2 *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.EditingStarted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.EditingStarted, got none")
	}

	var _editable CellEditabler // out
	var _path string            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.EditingStarted(_editable, _path)
}

//export _gotk4_gtk4_CellRendererClass_get_aligned_area
func _gotk4_gtk4_CellRendererClass_get_aligned_area(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.GtkCellRendererState, arg3 *C.GdkRectangle, arg4 *C.GdkRectangle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.AlignedArea == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.AlignedArea, got none")
	}

	var _widget Widgetter        // out
	var _flags CellRendererState // out
	var _cellArea *gdk.Rectangle // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_flags = CellRendererState(arg2)
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	alignedArea := overrides.AlignedArea(_widget, _flags, _cellArea)

	var _ *gdk.Rectangle

	*arg4 = *(*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(alignedArea)))
}

//export _gotk4_gtk4_CellRendererClass_get_preferred_height
func _gotk4_gtk4_CellRendererClass_get_preferred_height(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 *C.int, arg3 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredHeight, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := overrides.PreferredHeight(_widget)

	var _ int
	var _ int

	*arg2 = C.int(minimumSize)
	*arg3 = C.int(naturalSize)
}

//export _gotk4_gtk4_CellRendererClass_get_preferred_height_for_width
func _gotk4_gtk4_CellRendererClass_get_preferred_height_for_width(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.int, arg3 *C.int, arg4 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredHeightForWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredHeightForWidth, got none")
	}

	var _widget Widgetter // out
	var _width int        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int(arg2)

	minimumHeight, naturalHeight := overrides.PreferredHeightForWidth(_widget, _width)

	var _ int
	var _ int

	*arg3 = C.int(minimumHeight)
	*arg4 = C.int(naturalHeight)
}

//export _gotk4_gtk4_CellRendererClass_get_preferred_width
func _gotk4_gtk4_CellRendererClass_get_preferred_width(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 *C.int, arg3 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredWidth == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredWidth, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := overrides.PreferredWidth(_widget)

	var _ int
	var _ int

	*arg2 = C.int(minimumSize)
	*arg3 = C.int(naturalSize)
}

//export _gotk4_gtk4_CellRendererClass_get_preferred_width_for_height
func _gotk4_gtk4_CellRendererClass_get_preferred_width_for_height(arg0 *C.GtkCellRenderer, arg1 *C.GtkWidget, arg2 C.int, arg3 *C.int, arg4 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.PreferredWidthForHeight == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.PreferredWidthForHeight, got none")
	}

	var _widget Widgetter // out
	var _height int       // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int(arg2)

	minimumWidth, naturalWidth := overrides.PreferredWidthForHeight(_widget, _height)

	var _ int
	var _ int

	*arg3 = C.int(minimumWidth)
	*arg4 = C.int(naturalWidth)
}

//export _gotk4_gtk4_CellRendererClass_get_request_mode
func _gotk4_gtk4_CellRendererClass_get_request_mode(arg0 *C.GtkCellRenderer) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk4_CellRendererClass_snapshot
func _gotk4_gtk4_CellRendererClass_snapshot(arg0 *C.GtkCellRenderer, arg1 *C.GtkSnapshot, arg2 *C.GtkWidget, arg3 *C.GdkRectangle, arg4 *C.GdkRectangle, arg5 C.GtkCellRendererState) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.Snapshot == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.Snapshot, got none")
	}

	var _snapshot *Snapshot            // out
	var _widget Widgetter              // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	_snapshot = wrapSnapshot(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_flags = CellRendererState(arg5)

	overrides.Snapshot(_snapshot, _widget, _backgroundArea, _cellArea, _flags)
}

//export _gotk4_gtk4_CellRendererClass_start_editing
func _gotk4_gtk4_CellRendererClass_start_editing(arg0 *C.GtkCellRenderer, arg1 *C.GdkEvent, arg2 *C.GtkWidget, arg3 *C.char, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState) (cret *C.GtkCellEditable) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererOverrides](instance0)
	if overrides.StartEditing == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererOverrides.StartEditing, got none")
	}

	var _event gdk.Eventer             // out
	var _widget Widgetter              // out
	var _path string                   // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Eventer)
				return ok
			})
			rv, ok := casted.(gdk.Eventer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Eventer")
			}
			_event = rv
		}
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)

	cellEditable := overrides.StartEditing(_event, _widget, _path, _backgroundArea, _cellArea, _flags)

	var _ *CellEditable

	if cellEditable != nil {
		cret = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))
	}

	return cret
}

//export _gotk4_gtk4_CellRendererTextClass_edited
func _gotk4_gtk4_CellRendererTextClass_edited(arg0 *C.GtkCellRendererText, arg1 *C.char, arg2 *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CellRendererTextOverrides](instance0)
	if overrides.Edited == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CellRendererTextOverrides.Edited, got none")
	}

	var _path string    // out
	var _newText string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	overrides.Edited(_path, _newText)
}

//export _gotk4_gtk4_CheckButtonClass_activate
func _gotk4_gtk4_CheckButtonClass_activate(arg0 *C.GtkCheckButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CheckButtonOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CheckButtonOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk4_CheckButtonClass_toggled
func _gotk4_gtk4_CheckButtonClass_toggled(arg0 *C.GtkCheckButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[CheckButtonOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected CheckButtonOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk4_ComboBoxClass_changed
func _gotk4_gtk4_ComboBoxClass_changed(arg0 *C.GtkComboBox) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ComboBoxOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ComboBoxOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk4_ComboBoxClass_format_entry_text
func _gotk4_gtk4_ComboBoxClass_format_entry_text(arg0 *C.GtkComboBox, arg1 *C.char) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ComboBoxOverrides](instance0)
	if overrides.FormatEntryText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ComboBoxOverrides.FormatEntryText, got none")
	}

	var _path string // out

	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	utf8 := overrides.FormatEntryText(_path)

	var _ string

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk4_DialogClass_close
func _gotk4_gtk4_DialogClass_close(arg0 *C.GtkDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DialogOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DialogOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk4_DialogClass_response
func _gotk4_gtk4_DialogClass_response(arg0 *C.GtkDialog, arg1 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DialogOverrides](instance0)
	if overrides.Response == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DialogOverrides.Response, got none")
	}

	var _responseId int // out

	_responseId = int(arg1)

	overrides.Response(_responseId)
}

//export _gotk4_gtk4_DrawingAreaClass_resize
func _gotk4_gtk4_DrawingAreaClass_resize(arg0 *C.GtkDrawingArea, arg1 C.int, arg2 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[DrawingAreaOverrides](instance0)
	if overrides.Resize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected DrawingAreaOverrides.Resize, got none")
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	overrides.Resize(_width, _height)
}

//export _gotk4_gtk4_EntryClass_activate
func _gotk4_gtk4_EntryClass_activate(arg0 *C.GtkEntry) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk4_EntryBufferClass_delete_text
func _gotk4_gtk4_EntryBufferClass_delete_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 C.guint) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.DeleteText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.DeleteText, got none")
	}

	var _position uint // out
	var _nChars uint   // out

	_position = uint(arg1)
	_nChars = uint(arg2)

	guint := overrides.DeleteText(_position, _nChars)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk4_EntryBufferClass_deleted_text
func _gotk4_gtk4_EntryBufferClass_deleted_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.DeletedText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.DeletedText, got none")
	}

	var _position uint // out
	var _nChars uint   // out

	_position = uint(arg1)
	_nChars = uint(arg2)

	overrides.DeletedText(_position, _nChars)
}

//export _gotk4_gtk4_EntryBufferClass_get_length
func _gotk4_gtk4_EntryBufferClass_get_length(arg0 *C.GtkEntryBuffer) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.Length == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.Length, got none")
	}

	guint := overrides.Length()

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk4_EntryBufferClass_get_text
func _gotk4_gtk4_EntryBufferClass_get_text(arg0 *C.GtkEntryBuffer, arg1 *C.gsize) (cret *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.Text == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.Text, got none")
	}

	var _nBytes *uint // out

	_nBytes = (*uint)(unsafe.Pointer(arg1))

	utf8 := overrides.Text(_nBytes)

	var _ string

	cret = (*C.char)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

//export _gotk4_gtk4_EntryBufferClass_insert_text
func _gotk4_gtk4_EntryBufferClass_insert_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 *C.char, arg3 C.guint) (cret C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.InsertText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.InsertText, got none")
	}

	var _position uint // out
	var _chars string  // out
	var _nChars uint   // out

	_position = uint(arg1)
	_chars = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_nChars = uint(arg3)

	guint := overrides.InsertText(_position, _chars, _nChars)

	var _ uint

	cret = C.guint(guint)

	return cret
}

//export _gotk4_gtk4_EntryBufferClass_inserted_text
func _gotk4_gtk4_EntryBufferClass_inserted_text(arg0 *C.GtkEntryBuffer, arg1 C.guint, arg2 *C.char, arg3 C.guint) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[EntryBufferOverrides](instance0)
	if overrides.InsertedText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected EntryBufferOverrides.InsertedText, got none")
	}

	var _position uint // out
	var _chars string  // out
	var _nChars uint   // out

	_position = uint(arg1)
	_chars = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_nChars = uint(arg3)

	overrides.InsertedText(_position, _chars, _nChars)
}

//export _gotk4_gtk4_FilterClass_get_strictness
func _gotk4_gtk4_FilterClass_get_strictness(arg0 *C.GtkFilter) (cret C.GtkFilterMatch) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FilterOverrides](instance0)
	if overrides.Strictness == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FilterOverrides.Strictness, got none")
	}

	filterMatch := overrides.Strictness()

	var _ FilterMatch

	cret = C.GtkFilterMatch(filterMatch)

	return cret
}

//export _gotk4_gtk4_FilterClass_match
func _gotk4_gtk4_FilterClass_match(arg0 *C.GtkFilter, arg1 C.gpointer) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FilterOverrides](instance0)
	if overrides.Match == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FilterOverrides.Match, got none")
	}

	var _item *coreglib.Object // out

	_item = coreglib.Take(unsafe.Pointer(arg1))

	ok := overrides.Match(_item)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_FlowBoxChildClass_activate
func _gotk4_gtk4_FlowBoxChildClass_activate(arg0 *C.GtkFlowBoxChild) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FlowBoxChildOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FlowBoxChildOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk4_FrameClass_compute_child_allocation
func _gotk4_gtk4_FrameClass_compute_child_allocation(arg0 *C.GtkFrame, arg1 *C.GtkAllocation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[FrameOverrides](instance0)
	if overrides.ComputeChildAllocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected FrameOverrides.ComputeChildAllocation, got none")
	}

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	overrides.ComputeChildAllocation(_allocation)
}

//export _gotk4_gtk4_GLAreaClass_render
func _gotk4_gtk4_GLAreaClass_render(arg0 *C.GtkGLArea, arg1 *C.GdkGLContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[GLAreaOverrides](instance0)
	if overrides.Render == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected GLAreaOverrides.Render, got none")
	}

	var _context gdk.GLContexter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.GLContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.GLContexter)
			return ok
		})
		rv, ok := casted.(gdk.GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
		}
		_context = rv
	}

	ok := overrides.Render(_context)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_GLAreaClass_resize
func _gotk4_gtk4_GLAreaClass_resize(arg0 *C.GtkGLArea, arg1 C.int, arg2 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[GLAreaOverrides](instance0)
	if overrides.Resize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected GLAreaOverrides.Resize, got none")
	}

	var _width int  // out
	var _height int // out

	_width = int(arg1)
	_height = int(arg2)

	overrides.Resize(_width, _height)
}

//export _gotk4_gtk4_IMContextClass_commit
func _gotk4_gtk4_IMContextClass_commit(arg0 *C.GtkIMContext, arg1 *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Commit == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Commit, got none")
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.Commit(_str)
}

//export _gotk4_gtk4_IMContextClass_delete_surrounding
func _gotk4_gtk4_IMContextClass_delete_surrounding(arg0 *C.GtkIMContext, arg1 C.int, arg2 C.int) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.DeleteSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.DeleteSurrounding, got none")
	}

	var _offset int // out
	var _nChars int // out

	_offset = int(arg1)
	_nChars = int(arg2)

	ok := overrides.DeleteSurrounding(_offset, _nChars)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_IMContextClass_filter_keypress
func _gotk4_gtk4_IMContextClass_filter_keypress(arg0 *C.GtkIMContext, arg1 *C.GdkEvent) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FilterKeypress == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FilterKeypress, got none")
	}

	var _event gdk.Eventer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Eventer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Eventer)
			return ok
		})
		rv, ok := casted.(gdk.Eventer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Eventer")
		}
		_event = rv
	}

	ok := overrides.FilterKeypress(_event)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_IMContextClass_focus_in
func _gotk4_gtk4_IMContextClass_focus_in(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FocusIn == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FocusIn, got none")
	}

	overrides.FocusIn()
}

//export _gotk4_gtk4_IMContextClass_focus_out
func _gotk4_gtk4_IMContextClass_focus_out(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.FocusOut == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.FocusOut, got none")
	}

	overrides.FocusOut()
}

//export _gotk4_gtk4_IMContextClass_get_preedit_string
func _gotk4_gtk4_IMContextClass_get_preedit_string(arg0 *C.GtkIMContext, arg1 **C.char, arg2 **C.PangoAttrList, arg3 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditString == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditString, got none")
	}

	str, attrs, cursorPos := overrides.PreeditString()

	var _ string
	var _ *pango.AttrList
	var _ int

	*arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	*arg2 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	*arg3 = C.int(cursorPos)
}

//export _gotk4_gtk4_IMContextClass_get_surrounding
func _gotk4_gtk4_IMContextClass_get_surrounding(arg0 *C.GtkIMContext, arg1 **C.char, arg2 *C.int) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Surrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Surrounding, got none")
	}

	text, cursorIndex, ok := overrides.Surrounding()

	var _ string
	var _ int
	var _ bool

	*arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	*arg2 = C.int(cursorIndex)
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_IMContextClass_get_surrounding_with_selection
func _gotk4_gtk4_IMContextClass_get_surrounding_with_selection(arg0 *C.GtkIMContext, arg1 **C.char, arg2 *C.int, arg3 *C.int) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SurroundingWithSelection == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SurroundingWithSelection, got none")
	}

	text, cursorIndex, anchorIndex, ok := overrides.SurroundingWithSelection()

	var _ string
	var _ int
	var _ int
	var _ bool

	*arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	*arg2 = C.int(cursorIndex)
	*arg3 = C.int(anchorIndex)
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_IMContextClass_preedit_changed
func _gotk4_gtk4_IMContextClass_preedit_changed(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditChanged, got none")
	}

	overrides.PreeditChanged()
}

//export _gotk4_gtk4_IMContextClass_preedit_end
func _gotk4_gtk4_IMContextClass_preedit_end(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditEnd == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditEnd, got none")
	}

	overrides.PreeditEnd()
}

//export _gotk4_gtk4_IMContextClass_preedit_start
func _gotk4_gtk4_IMContextClass_preedit_start(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.PreeditStart == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.PreeditStart, got none")
	}

	overrides.PreeditStart()
}

//export _gotk4_gtk4_IMContextClass_reset
func _gotk4_gtk4_IMContextClass_reset(arg0 *C.GtkIMContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.Reset == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.Reset, got none")
	}

	overrides.Reset()
}

//export _gotk4_gtk4_IMContextClass_retrieve_surrounding
func _gotk4_gtk4_IMContextClass_retrieve_surrounding(arg0 *C.GtkIMContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.RetrieveSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.RetrieveSurrounding, got none")
	}

	ok := overrides.RetrieveSurrounding()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_IMContextClass_set_client_widget
func _gotk4_gtk4_IMContextClass_set_client_widget(arg0 *C.GtkIMContext, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetClientWidget == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetClientWidget, got none")
	}

	var _widget Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	overrides.SetClientWidget(_widget)
}

//export _gotk4_gtk4_IMContextClass_set_cursor_location
func _gotk4_gtk4_IMContextClass_set_cursor_location(arg0 *C.GtkIMContext, arg1 *C.GdkRectangle) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetCursorLocation == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetCursorLocation, got none")
	}

	var _area *gdk.Rectangle // out

	_area = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.SetCursorLocation(_area)
}

//export _gotk4_gtk4_IMContextClass_set_surrounding
func _gotk4_gtk4_IMContextClass_set_surrounding(arg0 *C.GtkIMContext, arg1 *C.char, arg2 C.int, arg3 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetSurrounding == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetSurrounding, got none")
	}

	var _text string     // out
	var _len int         // out
	var _cursorIndex int // out

	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_len = int(arg2)
	_cursorIndex = int(arg3)

	overrides.SetSurrounding(_text, _len, _cursorIndex)
}

//export _gotk4_gtk4_IMContextClass_set_surrounding_with_selection
func _gotk4_gtk4_IMContextClass_set_surrounding_with_selection(arg0 *C.GtkIMContext, arg1 *C.char, arg2 C.int, arg3 C.int, arg4 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetSurroundingWithSelection == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetSurroundingWithSelection, got none")
	}

	var _text string     // out
	var _len int         // out
	var _cursorIndex int // out
	var _anchorIndex int // out

	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_len = int(arg2)
	_cursorIndex = int(arg3)
	_anchorIndex = int(arg4)

	overrides.SetSurroundingWithSelection(_text, _len, _cursorIndex, _anchorIndex)
}

//export _gotk4_gtk4_IMContextClass_set_use_preedit
func _gotk4_gtk4_IMContextClass_set_use_preedit(arg0 *C.GtkIMContext, arg1 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[IMContextOverrides](instance0)
	if overrides.SetUsePreedit == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected IMContextOverrides.SetUsePreedit, got none")
	}

	var _usePreedit bool // out

	if arg1 != 0 {
		_usePreedit = true
	}

	overrides.SetUsePreedit(_usePreedit)
}

//export _gotk4_gtk4_LayoutManagerClass_allocate
func _gotk4_gtk4_LayoutManagerClass_allocate(arg0 *C.GtkLayoutManager, arg1 *C.GtkWidget, arg2 C.int, arg3 C.int, arg4 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LayoutManagerOverrides](instance0)
	if overrides.Allocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LayoutManagerOverrides.Allocate, got none")
	}

	var _widget Widgetter // out
	var _width int        // out
	var _height int       // out
	var _baseline int     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int(arg2)
	_height = int(arg3)
	_baseline = int(arg4)

	overrides.Allocate(_widget, _width, _height, _baseline)
}

//export _gotk4_gtk4_LayoutManagerClass_create_layout_child
func _gotk4_gtk4_LayoutManagerClass_create_layout_child(arg0 *C.GtkLayoutManager, arg1 *C.GtkWidget, arg2 *C.GtkWidget) (cret *C.GtkLayoutChild) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LayoutManagerOverrides](instance0)
	if overrides.CreateLayoutChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LayoutManagerOverrides.CreateLayoutChild, got none")
	}

	var _widget Widgetter   // out
	var _forChild Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_forChild = rv
	}

	layoutChild := overrides.CreateLayoutChild(_widget, _forChild)

	var _ LayoutChilder

	cret = (*C.GtkLayoutChild)(unsafe.Pointer(coreglib.InternObject(layoutChild).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(layoutChild).Native()))

	return cret
}

//export _gotk4_gtk4_LayoutManagerClass_get_request_mode
func _gotk4_gtk4_LayoutManagerClass_get_request_mode(arg0 *C.GtkLayoutManager, arg1 *C.GtkWidget) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LayoutManagerOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LayoutManagerOverrides.RequestMode, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	sizeRequestMode := overrides.RequestMode(_widget)

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk4_LayoutManagerClass_measure
func _gotk4_gtk4_LayoutManagerClass_measure(arg0 *C.GtkLayoutManager, arg1 *C.GtkWidget, arg2 C.GtkOrientation, arg3 C.int, arg4 *C.int, arg5 *C.int, arg6 *C.int, arg7 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LayoutManagerOverrides](instance0)
	if overrides.Measure == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LayoutManagerOverrides.Measure, got none")
	}

	var _widget Widgetter        // out
	var _orientation Orientation // out
	var _forSize int             // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_orientation = Orientation(arg2)
	_forSize = int(arg3)

	minimum, natural, minimumBaseline, naturalBaseline := overrides.Measure(_widget, _orientation, _forSize)

	var _ int
	var _ int
	var _ int
	var _ int

	*arg4 = C.int(minimum)
	*arg5 = C.int(natural)
	*arg6 = C.int(minimumBaseline)
	*arg7 = C.int(naturalBaseline)
}

//export _gotk4_gtk4_LayoutManagerClass_root
func _gotk4_gtk4_LayoutManagerClass_root(arg0 *C.GtkLayoutManager) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LayoutManagerOverrides](instance0)
	if overrides.Root == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LayoutManagerOverrides.Root, got none")
	}

	overrides.Root()
}

//export _gotk4_gtk4_LayoutManagerClass_unroot
func _gotk4_gtk4_LayoutManagerClass_unroot(arg0 *C.GtkLayoutManager) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[LayoutManagerOverrides](instance0)
	if overrides.Unroot == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected LayoutManagerOverrides.Unroot, got none")
	}

	overrides.Unroot()
}

//export _gotk4_gtk4_ListBox_ConnectActivateCursorRow
func _gotk4_gtk4_ListBox_ConnectActivateCursorRow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk4_ListBox_ConnectMoveCursor
func _gotk4_gtk4_ListBox_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean, arg4 C.gboolean, arg5 C.guintptr) {
	var f func(object MovementStep, p0 int, p1, p2 bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object MovementStep, p0 int, p1, p2 bool))
	}

	var _object MovementStep // out
	var _p0 int              // out
	var _p1 bool             // out
	var _p2 bool             // out

	_object = MovementStep(arg1)
	_p0 = int(arg2)
	if arg3 != 0 {
		_p1 = true
	}
	if arg4 != 0 {
		_p2 = true
	}

	f(_object, _p0, _p1, _p2)
}

//export _gotk4_gtk4_ListBox_ConnectToggleCursorRow
func _gotk4_gtk4_ListBox_ConnectToggleCursorRow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk4_ListBoxRowClass_activate
func _gotk4_gtk4_ListBoxRowClass_activate(arg0 *C.GtkListBoxRow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ListBoxRowOverrides](instance0)
	if overrides.Activate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ListBoxRowOverrides.Activate, got none")
	}

	overrides.Activate()
}

//export _gotk4_gtk4_MediaFileClass_close
func _gotk4_gtk4_MediaFileClass_close(arg0 *C.GtkMediaFile) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MediaFileOverrides](instance0)
	if overrides.Close == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MediaFileOverrides.Close, got none")
	}

	overrides.Close()
}

//export _gotk4_gtk4_MediaFileClass_open
func _gotk4_gtk4_MediaFileClass_open(arg0 *C.GtkMediaFile) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MediaFileOverrides](instance0)
	if overrides.Open == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MediaFileOverrides.Open, got none")
	}

	overrides.Open()
}

//export _gotk4_gtk4_MediaStreamClass_pause
func _gotk4_gtk4_MediaStreamClass_pause(arg0 *C.GtkMediaStream) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MediaStreamOverrides](instance0)
	if overrides.Pause == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MediaStreamOverrides.Pause, got none")
	}

	overrides.Pause()
}

//export _gotk4_gtk4_MediaStreamClass_play
func _gotk4_gtk4_MediaStreamClass_play(arg0 *C.GtkMediaStream) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MediaStreamOverrides](instance0)
	if overrides.Play == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MediaStreamOverrides.Play, got none")
	}

	ok := overrides.Play()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_MediaStreamClass_realize
func _gotk4_gtk4_MediaStreamClass_realize(arg0 *C.GtkMediaStream, arg1 *C.GdkSurface) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MediaStreamOverrides](instance0)
	if overrides.Realize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MediaStreamOverrides.Realize, got none")
	}

	var _surface gdk.Surfacer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Surfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Surfacer)
			return ok
		})
		rv, ok := casted.(gdk.Surfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
		}
		_surface = rv
	}

	overrides.Realize(_surface)
}

//export _gotk4_gtk4_MediaStreamClass_seek
func _gotk4_gtk4_MediaStreamClass_seek(arg0 *C.GtkMediaStream, arg1 C.gint64) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MediaStreamOverrides](instance0)
	if overrides.Seek == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MediaStreamOverrides.Seek, got none")
	}

	var _timestamp int64 // out

	_timestamp = int64(arg1)

	overrides.Seek(_timestamp)
}

//export _gotk4_gtk4_MediaStreamClass_unrealize
func _gotk4_gtk4_MediaStreamClass_unrealize(arg0 *C.GtkMediaStream, arg1 *C.GdkSurface) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MediaStreamOverrides](instance0)
	if overrides.Unrealize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MediaStreamOverrides.Unrealize, got none")
	}

	var _surface gdk.Surfacer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gdk.Surfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Surfacer)
			return ok
		})
		rv, ok := casted.(gdk.Surfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
		}
		_surface = rv
	}

	overrides.Unrealize(_surface)
}

//export _gotk4_gtk4_MediaStreamClass_update_audio
func _gotk4_gtk4_MediaStreamClass_update_audio(arg0 *C.GtkMediaStream, arg1 C.gboolean, arg2 C.double) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[MediaStreamOverrides](instance0)
	if overrides.UpdateAudio == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected MediaStreamOverrides.UpdateAudio, got none")
	}

	var _muted bool     // out
	var _volume float64 // out

	if arg1 != 0 {
		_muted = true
	}
	_volume = float64(arg2)

	overrides.UpdateAudio(_muted, _volume)
}

//export _gotk4_gtk4_NativeDialogClass_hide
func _gotk4_gtk4_NativeDialogClass_hide(arg0 *C.GtkNativeDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Hide == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Hide, got none")
	}

	overrides.Hide()
}

//export _gotk4_gtk4_NativeDialogClass_response
func _gotk4_gtk4_NativeDialogClass_response(arg0 *C.GtkNativeDialog, arg1 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Response == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Response, got none")
	}

	var _responseId int // out

	_responseId = int(arg1)

	overrides.Response(_responseId)
}

//export _gotk4_gtk4_NativeDialogClass_show
func _gotk4_gtk4_NativeDialogClass_show(arg0 *C.GtkNativeDialog) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[NativeDialogOverrides](instance0)
	if overrides.Show == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected NativeDialogOverrides.Show, got none")
	}

	overrides.Show()
}

//export _gotk4_gtk4_Notebook_ConnectChangeCurrentPage
func _gotk4_gtk4_Notebook_ConnectChangeCurrentPage(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int) (ok bool))
	}

	var _object int // out

	_object = int(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_Notebook_ConnectFocusTab
func _gotk4_gtk4_Notebook_ConnectFocusTab(arg0 C.gpointer, arg1 C.GtkNotebookTab, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object NotebookTab) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object NotebookTab) (ok bool))
	}

	var _object NotebookTab // out

	_object = NotebookTab(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_Notebook_ConnectMoveFocusOut
func _gotk4_gtk4_Notebook_ConnectMoveFocusOut(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(object DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType))
	}

	var _object DirectionType // out

	_object = DirectionType(arg1)

	f(_object)
}

//export _gotk4_gtk4_Notebook_ConnectReorderTab
func _gotk4_gtk4_Notebook_ConnectReorderTab(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.gboolean, arg3 C.guintptr) (cret C.gboolean) {
	var f func(object DirectionType, p0 bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType, p0 bool) (ok bool))
	}

	var _object DirectionType // out
	var _p0 bool              // out

	_object = DirectionType(arg1)
	if arg2 != 0 {
		_p0 = true
	}

	ok := f(_object, _p0)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_Notebook_ConnectSelectPage
func _gotk4_gtk4_Notebook_ConnectSelectPage(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object bool) (ok bool))
	}

	var _object bool // out

	if arg1 != 0 {
		_object = true
	}

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_PopoverClass_activate_default
func _gotk4_gtk4_PopoverClass_activate_default(arg0 *C.GtkPopover) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PopoverOverrides](instance0)
	if overrides.ActivateDefault == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PopoverOverrides.ActivateDefault, got none")
	}

	overrides.ActivateDefault()
}

//export _gotk4_gtk4_PopoverClass_closed
func _gotk4_gtk4_PopoverClass_closed(arg0 *C.GtkPopover) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PopoverOverrides](instance0)
	if overrides.Closed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PopoverOverrides.Closed, got none")
	}

	overrides.Closed()
}

//export _gotk4_gtk4_PrintOperationClass_begin_print
func _gotk4_gtk4_PrintOperationClass_begin_print(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.BeginPrint == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.BeginPrint, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.BeginPrint(_context)
}

//export _gotk4_gtk4_PrintOperationClass_custom_widget_apply
func _gotk4_gtk4_PrintOperationClass_custom_widget_apply(arg0 *C.GtkPrintOperation, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.CustomWidgetApply == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.CustomWidgetApply, got none")
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	overrides.CustomWidgetApply(_widget)
}

//export _gotk4_gtk4_PrintOperationClass_done
func _gotk4_gtk4_PrintOperationClass_done(arg0 *C.GtkPrintOperation, arg1 C.GtkPrintOperationResult) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Done == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Done, got none")
	}

	var _result PrintOperationResult // out

	_result = PrintOperationResult(arg1)

	overrides.Done(_result)
}

//export _gotk4_gtk4_PrintOperationClass_draw_page
func _gotk4_gtk4_PrintOperationClass_draw_page(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext, arg2 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.DrawPage == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.DrawPage, got none")
	}

	var _context *PrintContext // out
	var _pageNr int            // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int(arg2)

	overrides.DrawPage(_context, _pageNr)
}

//export _gotk4_gtk4_PrintOperationClass_end_print
func _gotk4_gtk4_PrintOperationClass_end_print(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.EndPrint == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.EndPrint, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.EndPrint(_context)
}

//export _gotk4_gtk4_PrintOperationClass_paginate
func _gotk4_gtk4_PrintOperationClass_paginate(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Paginate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Paginate, got none")
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	ok := overrides.Paginate(_context)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_PrintOperationClass_preview
func _gotk4_gtk4_PrintOperationClass_preview(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintOperationPreview, arg2 *C.GtkPrintContext, arg3 *C.GtkWindow) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.Preview == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.Preview, got none")
	}

	var _preview PrintOperationPreviewer // out
	var _context *PrintContext           // out
	var _parent *Window                  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.PrintOperationPreviewer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PrintOperationPreviewer)
			return ok
		})
		rv, ok := casted.(PrintOperationPreviewer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.PrintOperationPreviewer")
		}
		_preview = rv
	}
	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg2)))
	_parent = wrapWindow(coreglib.Take(unsafe.Pointer(arg3)))

	ok := overrides.Preview(_preview, _context, _parent)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_PrintOperationClass_request_page_setup
func _gotk4_gtk4_PrintOperationClass_request_page_setup(arg0 *C.GtkPrintOperation, arg1 *C.GtkPrintContext, arg2 C.int, arg3 *C.GtkPageSetup) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.RequestPageSetup == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.RequestPageSetup, got none")
	}

	var _context *PrintContext // out
	var _pageNr int            // out
	var _setup *PageSetup      // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int(arg2)
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg3)))

	overrides.RequestPageSetup(_context, _pageNr, _setup)
}

//export _gotk4_gtk4_PrintOperationClass_status_changed
func _gotk4_gtk4_PrintOperationClass_status_changed(arg0 *C.GtkPrintOperation) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.StatusChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.StatusChanged, got none")
	}

	overrides.StatusChanged()
}

//export _gotk4_gtk4_PrintOperationClass_update_custom_widget
func _gotk4_gtk4_PrintOperationClass_update_custom_widget(arg0 *C.GtkPrintOperation, arg1 *C.GtkWidget, arg2 *C.GtkPageSetup, arg3 *C.GtkPrintSettings) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[PrintOperationOverrides](instance0)
	if overrides.UpdateCustomWidget == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected PrintOperationOverrides.UpdateCustomWidget, got none")
	}

	var _widget Widgetter        // out
	var _setup *PageSetup        // out
	var _settings *PrintSettings // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg2)))
	_settings = wrapPrintSettings(coreglib.Take(unsafe.Pointer(arg3)))

	overrides.UpdateCustomWidget(_widget, _setup, _settings)
}

//export _gotk4_gtk4_RangeClass_adjust_bounds
func _gotk4_gtk4_RangeClass_adjust_bounds(arg0 *C.GtkRange, arg1 C.double) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.AdjustBounds == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.AdjustBounds, got none")
	}

	var _newValue float64 // out

	_newValue = float64(arg1)

	overrides.AdjustBounds(_newValue)
}

//export _gotk4_gtk4_RangeClass_change_value
func _gotk4_gtk4_RangeClass_change_value(arg0 *C.GtkRange, arg1 C.GtkScrollType, arg2 C.double) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.ChangeValue == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.ChangeValue, got none")
	}

	var _scroll ScrollType // out
	var _newValue float64  // out

	_scroll = ScrollType(arg1)
	_newValue = float64(arg2)

	ok := overrides.ChangeValue(_scroll, _newValue)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_RangeClass_get_range_border
func _gotk4_gtk4_RangeClass_get_range_border(arg0 *C.GtkRange, arg1 *C.GtkBorder) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.RangeBorder == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.RangeBorder, got none")
	}

	var _border_ *Border // out

	_border_ = (*Border)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	overrides.RangeBorder(_border_)
}

//export _gotk4_gtk4_RangeClass_move_slider
func _gotk4_gtk4_RangeClass_move_slider(arg0 *C.GtkRange, arg1 C.GtkScrollType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.MoveSlider == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.MoveSlider, got none")
	}

	var _scroll ScrollType // out

	_scroll = ScrollType(arg1)

	overrides.MoveSlider(_scroll)
}

//export _gotk4_gtk4_RangeClass_value_changed
func _gotk4_gtk4_RangeClass_value_changed(arg0 *C.GtkRange) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RangeOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RangeOverrides.ValueChanged, got none")
	}

	overrides.ValueChanged()
}

//export _gotk4_gtk4_RecentManagerClass_changed
func _gotk4_gtk4_RecentManagerClass_changed(arg0 *C.GtkRecentManager) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[RecentManagerOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected RecentManagerOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk4_ScaleClass_get_layout_offsets
func _gotk4_gtk4_ScaleClass_get_layout_offsets(arg0 *C.GtkScale, arg1 *C.int, arg2 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleOverrides](instance0)
	if overrides.LayoutOffsets == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleOverrides.LayoutOffsets, got none")
	}

	x, y := overrides.LayoutOffsets()

	var _ int
	var _ int

	*arg1 = C.int(x)
	*arg2 = C.int(y)
}

//export _gotk4_gtk4_ScaleButtonClass_value_changed
func _gotk4_gtk4_ScaleButtonClass_value_changed(arg0 *C.GtkScaleButton, arg1 C.double) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ScaleButtonOverrides](instance0)
	if overrides.ValueChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ScaleButtonOverrides.ValueChanged, got none")
	}

	var _value float64 // out

	_value = float64(arg1)

	overrides.ValueChanged(_value)
}

//export _gotk4_gtk4_ShortcutsSection_ConnectChangeCurrentPage
func _gotk4_gtk4_ShortcutsSection_ConnectChangeCurrentPage(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int) (ok bool))
	}

	var _object int // out

	_object = int(arg1)

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_SorterClass_compare
func _gotk4_gtk4_SorterClass_compare(arg0 *C.GtkSorter, arg1 C.gpointer, arg2 C.gpointer) (cret C.GtkOrdering) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SorterOverrides](instance0)
	if overrides.Compare == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SorterOverrides.Compare, got none")
	}

	var _item1 *coreglib.Object // out
	var _item2 *coreglib.Object // out

	_item1 = coreglib.Take(unsafe.Pointer(arg1))
	_item2 = coreglib.Take(unsafe.Pointer(arg2))

	ordering := overrides.Compare(_item1, _item2)

	var _ Ordering

	cret = C.GtkOrdering(ordering)

	return cret
}

//export _gotk4_gtk4_SorterClass_get_order
func _gotk4_gtk4_SorterClass_get_order(arg0 *C.GtkSorter) (cret C.GtkSorterOrder) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[SorterOverrides](instance0)
	if overrides.Order == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected SorterOverrides.Order, got none")
	}

	sorterOrder := overrides.Order()

	var _ SorterOrder

	cret = C.GtkSorterOrder(sorterOrder)

	return cret
}

//export _gotk4_gtk4_StyleContextClass_changed
func _gotk4_gtk4_StyleContextClass_changed(arg0 *C.GtkStyleContext) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[StyleContextOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected StyleContextOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk4_TextBufferClass_apply_tag
func _gotk4_gtk4_TextBufferClass_apply_tag(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.ApplyTag == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.ApplyTag, got none")
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	overrides.ApplyTag(_tag, _start, _end)
}

//export _gotk4_gtk4_TextBufferClass_begin_user_action
func _gotk4_gtk4_TextBufferClass_begin_user_action(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.BeginUserAction == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.BeginUserAction, got none")
	}

	overrides.BeginUserAction()
}

//export _gotk4_gtk4_TextBufferClass_changed
func _gotk4_gtk4_TextBufferClass_changed(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.Changed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.Changed, got none")
	}

	overrides.Changed()
}

//export _gotk4_gtk4_TextBufferClass_delete_range
func _gotk4_gtk4_TextBufferClass_delete_range(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.DeleteRange == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.DeleteRange, got none")
	}

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.DeleteRange(_start, _end)
}

//export _gotk4_gtk4_TextBufferClass_end_user_action
func _gotk4_gtk4_TextBufferClass_end_user_action(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.EndUserAction == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.EndUserAction, got none")
	}

	overrides.EndUserAction()
}

//export _gotk4_gtk4_TextBufferClass_insert_child_anchor
func _gotk4_gtk4_TextBufferClass_insert_child_anchor(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextChildAnchor) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertChildAnchor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertChildAnchor, got none")
	}

	var _iter *TextIter          // out
	var _anchor *TextChildAnchor // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_anchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.InsertChildAnchor(_iter, _anchor)
}

//export _gotk4_gtk4_TextBufferClass_insert_paintable
func _gotk4_gtk4_TextBufferClass_insert_paintable(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GdkPaintable) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertPaintable == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertPaintable, got none")
	}

	var _iter *TextIter           // out
	var _paintable gdk.Paintabler // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gdk.Paintabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Paintabler)
			return ok
		})
		rv, ok := casted.(gdk.Paintabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Paintabler")
		}
		_paintable = rv
	}

	overrides.InsertPaintable(_iter, _paintable)
}

//export _gotk4_gtk4_TextBufferClass_insert_text
func _gotk4_gtk4_TextBufferClass_insert_text(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.char, arg3 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.InsertText == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.InsertText, got none")
	}

	var _pos *TextIter     // out
	var _newText string    // out
	var _newTextLength int // out

	_pos = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_newTextLength = int(arg3)

	overrides.InsertText(_pos, _newText, _newTextLength)
}

//export _gotk4_gtk4_TextBufferClass_mark_deleted
func _gotk4_gtk4_TextBufferClass_mark_deleted(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextMark) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.MarkDeleted == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.MarkDeleted, got none")
	}

	var _mark *TextMark // out

	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.MarkDeleted(_mark)
}

//export _gotk4_gtk4_TextBufferClass_mark_set
func _gotk4_gtk4_TextBufferClass_mark_set(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextMark) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.MarkSet == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.MarkSet, got none")
	}

	var _location *TextIter // out
	var _mark *TextMark     // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.MarkSet(_location, _mark)
}

//export _gotk4_gtk4_TextBufferClass_modified_changed
func _gotk4_gtk4_TextBufferClass_modified_changed(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.ModifiedChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.ModifiedChanged, got none")
	}

	overrides.ModifiedChanged()
}

//export _gotk4_gtk4_TextBufferClass_paste_done
func _gotk4_gtk4_TextBufferClass_paste_done(arg0 *C.GtkTextBuffer, arg1 *C.GdkClipboard) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.PasteDone == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.PasteDone, got none")
	}

	var _clipboard *gdk.Clipboard // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_clipboard = &gdk.Clipboard{
			Object: obj,
		}
	}

	overrides.PasteDone(_clipboard)
}

//export _gotk4_gtk4_TextBufferClass_redo
func _gotk4_gtk4_TextBufferClass_redo(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.Redo == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.Redo, got none")
	}

	overrides.Redo()
}

//export _gotk4_gtk4_TextBufferClass_remove_tag
func _gotk4_gtk4_TextBufferClass_remove_tag(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.RemoveTag == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.RemoveTag, got none")
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	overrides.RemoveTag(_tag, _start, _end)
}

//export _gotk4_gtk4_TextBufferClass_undo
func _gotk4_gtk4_TextBufferClass_undo(arg0 *C.GtkTextBuffer) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextBufferOverrides](instance0)
	if overrides.Undo == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextBufferOverrides.Undo, got none")
	}

	overrides.Undo()
}

//export _gotk4_gtk4_TextViewClass_backspace
func _gotk4_gtk4_TextViewClass_backspace(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.Backspace == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.Backspace, got none")
	}

	overrides.Backspace()
}

//export _gotk4_gtk4_TextViewClass_copy_clipboard
func _gotk4_gtk4_TextViewClass_copy_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.CopyClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.CopyClipboard, got none")
	}

	overrides.CopyClipboard()
}

//export _gotk4_gtk4_TextViewClass_cut_clipboard
func _gotk4_gtk4_TextViewClass_cut_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.CutClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.CutClipboard, got none")
	}

	overrides.CutClipboard()
}

//export _gotk4_gtk4_TextViewClass_delete_from_cursor
func _gotk4_gtk4_TextViewClass_delete_from_cursor(arg0 *C.GtkTextView, arg1 C.GtkDeleteType, arg2 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.DeleteFromCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.DeleteFromCursor, got none")
	}

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	overrides.DeleteFromCursor(_typ, _count)
}

//export _gotk4_gtk4_TextViewClass_extend_selection
func _gotk4_gtk4_TextViewClass_extend_selection(arg0 *C.GtkTextView, arg1 C.GtkTextExtendSelection, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 *C.GtkTextIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.ExtendSelection == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.ExtendSelection, got none")
	}

	var _granularity TextExtendSelection // out
	var _location *TextIter              // out
	var _start *TextIter                 // out
	var _end *TextIter                   // out

	_granularity = TextExtendSelection(arg1)
	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := overrides.ExtendSelection(_granularity, _location, _start, _end)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TextViewClass_insert_at_cursor
func _gotk4_gtk4_TextViewClass_insert_at_cursor(arg0 *C.GtkTextView, arg1 *C.char) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.InsertAtCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.InsertAtCursor, got none")
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	overrides.InsertAtCursor(_str)
}

//export _gotk4_gtk4_TextViewClass_insert_emoji
func _gotk4_gtk4_TextViewClass_insert_emoji(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.InsertEmoji == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.InsertEmoji, got none")
	}

	overrides.InsertEmoji()
}

//export _gotk4_gtk4_TextViewClass_move_cursor
func _gotk4_gtk4_TextViewClass_move_cursor(arg0 *C.GtkTextView, arg1 C.GtkMovementStep, arg2 C.int, arg3 C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.MoveCursor, got none")
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	overrides.MoveCursor(_step, _count, _extendSelection)
}

//export _gotk4_gtk4_TextViewClass_paste_clipboard
func _gotk4_gtk4_TextViewClass_paste_clipboard(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.PasteClipboard == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.PasteClipboard, got none")
	}

	overrides.PasteClipboard()
}

//export _gotk4_gtk4_TextViewClass_set_anchor
func _gotk4_gtk4_TextViewClass_set_anchor(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.SetAnchor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.SetAnchor, got none")
	}

	overrides.SetAnchor()
}

//export _gotk4_gtk4_TextViewClass_snapshot_layer
func _gotk4_gtk4_TextViewClass_snapshot_layer(arg0 *C.GtkTextView, arg1 C.GtkTextViewLayer, arg2 *C.GtkSnapshot) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.SnapshotLayer == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.SnapshotLayer, got none")
	}

	var _layer TextViewLayer // out
	var _snapshot *Snapshot  // out

	_layer = TextViewLayer(arg1)
	_snapshot = wrapSnapshot(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.SnapshotLayer(_layer, _snapshot)
}

//export _gotk4_gtk4_TextViewClass_toggle_overwrite
func _gotk4_gtk4_TextViewClass_toggle_overwrite(arg0 *C.GtkTextView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TextViewOverrides](instance0)
	if overrides.ToggleOverwrite == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TextViewOverrides.ToggleOverwrite, got none")
	}

	overrides.ToggleOverwrite()
}

//export _gotk4_gtk4_ToggleButtonClass_toggled
func _gotk4_gtk4_ToggleButtonClass_toggled(arg0 *C.GtkToggleButton) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[ToggleButtonOverrides](instance0)
	if overrides.Toggled == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected ToggleButtonOverrides.Toggled, got none")
	}

	overrides.Toggled()
}

//export _gotk4_gtk4_TreeModelFilterClass_modify
func _gotk4_gtk4_TreeModelFilterClass_modify(arg0 *C.GtkTreeModelFilter, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 *C.GValue, arg4 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeModelFilterOverrides](instance0)
	if overrides.Modify == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeModelFilterOverrides.Modify, got none")
	}

	var _childModel TreeModeller // out
	var _iter *TreeIter          // out
	var _value *coreglib.Value   // out
	var _column int              // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_childModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_value = coreglib.ValueFromNative(unsafe.Pointer(arg3))
	_column = int(arg4)

	overrides.Modify(_childModel, _iter, _value, _column)
}

//export _gotk4_gtk4_TreeModelFilterClass_visible
func _gotk4_gtk4_TreeModelFilterClass_visible(arg0 *C.GtkTreeModelFilter, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeModelFilterOverrides](instance0)
	if overrides.Visible == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeModelFilterOverrides.Visible, got none")
	}

	var _childModel TreeModeller // out
	var _iter *TreeIter          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_childModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.Visible(_childModel, _iter)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_columns_changed
func _gotk4_gtk4_TreeViewClass_columns_changed(arg0 *C.GtkTreeView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ColumnsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ColumnsChanged, got none")
	}

	overrides.ColumnsChanged()
}

//export _gotk4_gtk4_TreeViewClass_cursor_changed
func _gotk4_gtk4_TreeViewClass_cursor_changed(arg0 *C.GtkTreeView) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.CursorChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.CursorChanged, got none")
	}

	overrides.CursorChanged()
}

//export _gotk4_gtk4_TreeViewClass_expand_collapse_cursor_row
func _gotk4_gtk4_TreeViewClass_expand_collapse_cursor_row(arg0 *C.GtkTreeView, arg1 C.gboolean, arg2 C.gboolean, arg3 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ExpandCollapseCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ExpandCollapseCursorRow, got none")
	}

	var _logical bool // out
	var _expand bool  // out
	var _openAll bool // out

	if arg1 != 0 {
		_logical = true
	}
	if arg2 != 0 {
		_expand = true
	}
	if arg3 != 0 {
		_openAll = true
	}

	ok := overrides.ExpandCollapseCursorRow(_logical, _expand, _openAll)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_move_cursor
func _gotk4_gtk4_TreeViewClass_move_cursor(arg0 *C.GtkTreeView, arg1 C.GtkMovementStep, arg2 C.int, arg3 C.gboolean, arg4 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.MoveCursor == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.MoveCursor, got none")
	}

	var _step MovementStep // out
	var _count int         // out
	var _extend bool       // out
	var _modify bool       // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extend = true
	}
	if arg4 != 0 {
		_modify = true
	}

	ok := overrides.MoveCursor(_step, _count, _extend, _modify)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_row_activated
func _gotk4_gtk4_TreeViewClass_row_activated(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 *C.GtkTreeViewColumn) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowActivated == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowActivated, got none")
	}

	var _path *TreePath         // out
	var _column *TreeViewColumn // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg2)))

	overrides.RowActivated(_path, _column)
}

//export _gotk4_gtk4_TreeViewClass_row_collapsed
func _gotk4_gtk4_TreeViewClass_row_collapsed(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowCollapsed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowCollapsed, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RowCollapsed(_iter, _path)
}

//export _gotk4_gtk4_TreeViewClass_row_expanded
func _gotk4_gtk4_TreeViewClass_row_expanded(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.RowExpanded == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.RowExpanded, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	overrides.RowExpanded(_iter, _path)
}

//export _gotk4_gtk4_TreeViewClass_select_all
func _gotk4_gtk4_TreeViewClass_select_all(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectAll, got none")
	}

	ok := overrides.SelectAll()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_select_cursor_parent
func _gotk4_gtk4_TreeViewClass_select_cursor_parent(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectCursorParent == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectCursorParent, got none")
	}

	ok := overrides.SelectCursorParent()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_select_cursor_row
func _gotk4_gtk4_TreeViewClass_select_cursor_row(arg0 *C.GtkTreeView, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.SelectCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.SelectCursorRow, got none")
	}

	var _startEditing bool // out

	if arg1 != 0 {
		_startEditing = true
	}

	ok := overrides.SelectCursorRow(_startEditing)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_start_interactive_search
func _gotk4_gtk4_TreeViewClass_start_interactive_search(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.StartInteractiveSearch == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.StartInteractiveSearch, got none")
	}

	ok := overrides.StartInteractiveSearch()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_test_collapse_row
func _gotk4_gtk4_TreeViewClass_test_collapse_row(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.TestCollapseRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.TestCollapseRow, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.TestCollapseRow(_iter, _path)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_test_expand_row
func _gotk4_gtk4_TreeViewClass_test_expand_row(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.TestExpandRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.TestExpandRow, got none")
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := overrides.TestExpandRow(_iter, _path)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_toggle_cursor_row
func _gotk4_gtk4_TreeViewClass_toggle_cursor_row(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.ToggleCursorRow == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.ToggleCursorRow, got none")
	}

	ok := overrides.ToggleCursorRow()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeViewClass_unselect_all
func _gotk4_gtk4_TreeViewClass_unselect_all(arg0 *C.GtkTreeView) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[TreeViewOverrides](instance0)
	if overrides.UnselectAll == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected TreeViewOverrides.UnselectAll, got none")
	}

	ok := overrides.UnselectAll()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeView_ConnectExpandCollapseCursorRow
func _gotk4_gtk4_TreeView_ConnectExpandCollapseCursorRow(arg0 C.gpointer, arg1 C.gboolean, arg2 C.gboolean, arg3 C.gboolean, arg4 C.guintptr) (cret C.gboolean) {
	var f func(object, p0, p1 bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0, p1 bool) (ok bool))
	}

	var _object bool // out
	var _p0 bool     // out
	var _p1 bool     // out

	if arg1 != 0 {
		_object = true
	}
	if arg2 != 0 {
		_p0 = true
	}
	if arg3 != 0 {
		_p1 = true
	}

	ok := f(_object, _p0, _p1)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeView_ConnectSelectAll
func _gotk4_gtk4_TreeView_ConnectSelectAll(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeView_ConnectSelectCursorParent
func _gotk4_gtk4_TreeView_ConnectSelectCursorParent(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeView_ConnectSelectCursorRow
func _gotk4_gtk4_TreeView_ConnectSelectCursorRow(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object bool) (ok bool))
	}

	var _object bool // out

	if arg1 != 0 {
		_object = true
	}

	ok := f(_object)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeView_ConnectStartInteractiveSearch
func _gotk4_gtk4_TreeView_ConnectStartInteractiveSearch(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeView_ConnectToggleCursorRow
func _gotk4_gtk4_TreeView_ConnectToggleCursorRow(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_TreeView_ConnectUnselectAll
func _gotk4_gtk4_TreeView_ConnectUnselectAll(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WidgetClass_contains
func _gotk4_gtk4_WidgetClass_contains(arg0 *C.GtkWidget, arg1 C.double, arg2 C.double) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Contains == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Contains, got none")
	}

	var _x float64 // out
	var _y float64 // out

	_x = float64(arg1)
	_y = float64(arg2)

	ok := overrides.Contains(_x, _y)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WidgetClass_direction_changed
func _gotk4_gtk4_WidgetClass_direction_changed(arg0 *C.GtkWidget, arg1 C.GtkTextDirection) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.DirectionChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.DirectionChanged, got none")
	}

	var _previousDirection TextDirection // out

	_previousDirection = TextDirection(arg1)

	overrides.DirectionChanged(_previousDirection)
}

//export _gotk4_gtk4_WidgetClass_focus
func _gotk4_gtk4_WidgetClass_focus(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Focus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Focus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.Focus(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WidgetClass_get_request_mode
func _gotk4_gtk4_WidgetClass_get_request_mode(arg0 *C.GtkWidget) (cret C.GtkSizeRequestMode) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.RequestMode == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.RequestMode, got none")
	}

	sizeRequestMode := overrides.RequestMode()

	var _ SizeRequestMode

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk4_WidgetClass_grab_focus
func _gotk4_gtk4_WidgetClass_grab_focus(arg0 *C.GtkWidget) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.GrabFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.GrabFocus, got none")
	}

	ok := overrides.GrabFocus()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WidgetClass_hide
func _gotk4_gtk4_WidgetClass_hide(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Hide == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Hide, got none")
	}

	overrides.Hide()
}

//export _gotk4_gtk4_WidgetClass_keynav_failed
func _gotk4_gtk4_WidgetClass_keynav_failed(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.KeynavFailed == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.KeynavFailed, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := overrides.KeynavFailed(_direction)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WidgetClass_map
func _gotk4_gtk4_WidgetClass_map(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Map == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Map, got none")
	}

	overrides.Map()
}

//export _gotk4_gtk4_WidgetClass_measure
func _gotk4_gtk4_WidgetClass_measure(arg0 *C.GtkWidget, arg1 C.GtkOrientation, arg2 C.int, arg3 *C.int, arg4 *C.int, arg5 *C.int, arg6 *C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Measure == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Measure, got none")
	}

	var _orientation Orientation // out
	var _forSize int             // out

	_orientation = Orientation(arg1)
	_forSize = int(arg2)

	minimum, natural, minimumBaseline, naturalBaseline := overrides.Measure(_orientation, _forSize)

	var _ int
	var _ int
	var _ int
	var _ int

	*arg3 = C.int(minimum)
	*arg4 = C.int(natural)
	*arg5 = C.int(minimumBaseline)
	*arg6 = C.int(naturalBaseline)
}

//export _gotk4_gtk4_WidgetClass_mnemonic_activate
func _gotk4_gtk4_WidgetClass_mnemonic_activate(arg0 *C.GtkWidget, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MnemonicActivate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MnemonicActivate, got none")
	}

	var _groupCycling bool // out

	if arg1 != 0 {
		_groupCycling = true
	}

	ok := overrides.MnemonicActivate(_groupCycling)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WidgetClass_move_focus
func _gotk4_gtk4_WidgetClass_move_focus(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.MoveFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.MoveFocus, got none")
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	overrides.MoveFocus(_direction)
}

//export _gotk4_gtk4_WidgetClass_query_tooltip
func _gotk4_gtk4_WidgetClass_query_tooltip(arg0 *C.GtkWidget, arg1 C.int, arg2 C.int, arg3 C.gboolean, arg4 *C.GtkTooltip) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.QueryTooltip == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.QueryTooltip, got none")
	}

	var _x int                // out
	var _y int                // out
	var _keyboardTooltip bool // out
	var _tooltip *Tooltip     // out

	_x = int(arg1)
	_y = int(arg2)
	if arg3 != 0 {
		_keyboardTooltip = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := overrides.QueryTooltip(_x, _y, _keyboardTooltip, _tooltip)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WidgetClass_realize
func _gotk4_gtk4_WidgetClass_realize(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Realize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Realize, got none")
	}

	overrides.Realize()
}

//export _gotk4_gtk4_WidgetClass_root
func _gotk4_gtk4_WidgetClass_root(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Root == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Root, got none")
	}

	overrides.Root()
}

//export _gotk4_gtk4_WidgetClass_set_focus_child
func _gotk4_gtk4_WidgetClass_set_focus_child(arg0 *C.GtkWidget, arg1 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SetFocusChild == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SetFocusChild, got none")
	}

	var _child Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_child = rv
		}
	}

	overrides.SetFocusChild(_child)
}

//export _gotk4_gtk4_WidgetClass_show
func _gotk4_gtk4_WidgetClass_show(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Show == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Show, got none")
	}

	overrides.Show()
}

//export _gotk4_gtk4_WidgetClass_size_allocate
func _gotk4_gtk4_WidgetClass_size_allocate(arg0 *C.GtkWidget, arg1 C.int, arg2 C.int, arg3 C.int) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SizeAllocate == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SizeAllocate, got none")
	}

	var _width int    // out
	var _height int   // out
	var _baseline int // out

	_width = int(arg1)
	_height = int(arg2)
	_baseline = int(arg3)

	overrides.SizeAllocate(_width, _height, _baseline)
}

//export _gotk4_gtk4_WidgetClass_snapshot
func _gotk4_gtk4_WidgetClass_snapshot(arg0 *C.GtkWidget, arg1 *C.GtkSnapshot) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Snapshot == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Snapshot, got none")
	}

	var _snapshot *Snapshot // out

	_snapshot = wrapSnapshot(coreglib.Take(unsafe.Pointer(arg1)))

	overrides.Snapshot(_snapshot)
}

//export _gotk4_gtk4_WidgetClass_state_flags_changed
func _gotk4_gtk4_WidgetClass_state_flags_changed(arg0 *C.GtkWidget, arg1 C.GtkStateFlags) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.StateFlagsChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.StateFlagsChanged, got none")
	}

	var _previousStateFlags StateFlags // out

	_previousStateFlags = StateFlags(arg1)

	overrides.StateFlagsChanged(_previousStateFlags)
}

//export _gotk4_gtk4_WidgetClass_system_setting_changed
func _gotk4_gtk4_WidgetClass_system_setting_changed(arg0 *C.GtkWidget, arg1 C.GtkSystemSetting) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.SystemSettingChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.SystemSettingChanged, got none")
	}

	var _settings SystemSetting // out

	_settings = SystemSetting(arg1)

	overrides.SystemSettingChanged(_settings)
}

//export _gotk4_gtk4_WidgetClass_unmap
func _gotk4_gtk4_WidgetClass_unmap(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Unmap == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Unmap, got none")
	}

	overrides.Unmap()
}

//export _gotk4_gtk4_WidgetClass_unrealize
func _gotk4_gtk4_WidgetClass_unrealize(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Unrealize == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Unrealize, got none")
	}

	overrides.Unrealize()
}

//export _gotk4_gtk4_WidgetClass_unroot
func _gotk4_gtk4_WidgetClass_unroot(arg0 *C.GtkWidget) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WidgetOverrides](instance0)
	if overrides.Unroot == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WidgetOverrides.Unroot, got none")
	}

	overrides.Unroot()
}

//export _gotk4_gtk4_WindowClass_activate_default
func _gotk4_gtk4_WindowClass_activate_default(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.ActivateDefault == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.ActivateDefault, got none")
	}

	overrides.ActivateDefault()
}

//export _gotk4_gtk4_WindowClass_activate_focus
func _gotk4_gtk4_WindowClass_activate_focus(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.ActivateFocus == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.ActivateFocus, got none")
	}

	overrides.ActivateFocus()
}

//export _gotk4_gtk4_WindowClass_close_request
func _gotk4_gtk4_WindowClass_close_request(arg0 *C.GtkWindow) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.CloseRequest == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.CloseRequest, got none")
	}

	ok := overrides.CloseRequest()

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WindowClass_enable_debugging
func _gotk4_gtk4_WindowClass_enable_debugging(arg0 *C.GtkWindow, arg1 C.gboolean) (cret C.gboolean) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.EnableDebugging == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.EnableDebugging, got none")
	}

	var _toggle bool // out

	if arg1 != 0 {
		_toggle = true
	}

	ok := overrides.EnableDebugging(_toggle)

	var _ bool

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WindowClass_keys_changed
func _gotk4_gtk4_WindowClass_keys_changed(arg0 *C.GtkWindow) {
	instance0 := coreglib.Take(unsafe.Pointer(arg0))
	overrides := coreglib.OverridesFromObj[WindowOverrides](instance0)
	if overrides.KeysChanged == nil {
		panic("gotk4: " + instance0.TypeFromInstance().String() + ": expected WindowOverrides.KeysChanged, got none")
	}

	overrides.KeysChanged()
}

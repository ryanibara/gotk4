// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gtk4_TextBufferClass_apply_tag(void*, void*, void*, void*);
// extern void _gotk4_gtk4_TextBufferClass_begin_user_action(void*);
// extern void _gotk4_gtk4_TextBufferClass_changed(void*);
// extern void _gotk4_gtk4_TextBufferClass_delete_range(void*, void*, void*);
// extern void _gotk4_gtk4_TextBufferClass_end_user_action(void*);
// extern void _gotk4_gtk4_TextBufferClass_insert_child_anchor(void*, void*, void*);
// extern void _gotk4_gtk4_TextBufferClass_insert_paintable(void*, void*, void*);
// extern void _gotk4_gtk4_TextBufferClass_insert_text(void*, void*, void*, int);
// extern void _gotk4_gtk4_TextBufferClass_mark_deleted(void*, void*);
// extern void _gotk4_gtk4_TextBufferClass_mark_set(void*, void*, void*);
// extern void _gotk4_gtk4_TextBufferClass_modified_changed(void*);
// extern void _gotk4_gtk4_TextBufferClass_paste_done(void*, void*);
// extern void _gotk4_gtk4_TextBufferClass_redo(void*);
// extern void _gotk4_gtk4_TextBufferClass_remove_tag(void*, void*, void*, void*);
// extern void _gotk4_gtk4_TextBufferClass_undo(void*);
// extern void _gotk4_gtk4_TextBuffer_ConnectApplyTag(gpointer, void*, void*, void*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectBeginUserAction(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectDeleteRange(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectEndUserAction(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertChildAnchor(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertPaintable(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertText(gpointer, void*, void*, gint, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectMarkDeleted(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectMarkSet(gpointer, void*, void*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectModifiedChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectPasteDone(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectRedo(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectRemoveTag(gpointer, void*, void*, void*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectUndo(gpointer, guintptr);
import "C"

// GTypeTextBuffer returns the GType for the type TextBuffer.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTextBuffer() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "TextBuffer").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTextBuffer)
	return gtype
}

// TextBufferOverrider contains methods that are overridable.
type TextBufferOverrider interface {
	// ApplyTag emits the “apply-tag” signal on buffer.
	//
	// The default handler for the signal applies tag to the given range. start
	// and end do not have to be in order.
	//
	// The function takes the following parameters:
	//
	//    - tag: GtkTextTag.
	//    - start: one bound of range to be tagged.
	//    - end: other bound of range to be tagged.
	//
	ApplyTag(tag *TextTag, start, end *TextIter)
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation.
	//
	// The operations between gtk_text_buffer_begin_user_action() and
	// gtk_text_buffer_end_user_action() can then be grouped when creating an
	// undo stack. GtkTextBuffer maintains a count of calls to
	// gtk_text_buffer_begin_user_action() that have not been closed with a call
	// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
	// and “end-user-action” signals only for the outermost pair of calls. This
	// allows you to build user actions from other user actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	Changed()
	// The function takes the following parameters:
	//
	//    - start
	//    - end
	//
	DeleteRange(start, end *TextIter)
	// EndUserAction ends a user-visible operation.
	//
	// Should be paired with a call to gtk.TextBuffer.BeginUserAction(). See
	// that function for a full explanation.
	EndUserAction()
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// iter.
	//
	// The anchor will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode “object replacement character” 0xFFFC. Note that the “slice”
	// variants for obtaining portions of the buffer as a string include this
	// character for child anchors, but the “text” variants do not. E.g. see
	// gtk.TextBuffer.GetSlice() and gtk.TextBuffer.GetText().
	//
	// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient
	// alternative to this function. The buffer will add a reference to the
	// anchor, so you can unref it after insertion.
	//
	// The function takes the following parameters:
	//
	//    - iter: location to insert the anchor.
	//    - anchor: GtkTextChildAnchor.
	//
	InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor)
	// InsertPaintable inserts an image into the text buffer at iter.
	//
	// The image will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode “object replacement character” 0xFFFC. Note that the “slice”
	// variants for obtaining portions of the buffer as a string include this
	// character for paintable, but the “text” variants do not. e.g. see
	// gtk.TextBuffer.GetSlice() and gtk.TextBuffer.GetText().
	//
	// The function takes the following parameters:
	//
	//    - iter: location to insert the paintable.
	//    - paintable: GdkPaintable.
	//
	InsertPaintable(iter *TextIter, paintable gdk.Paintabler)
	// The function takes the following parameters:
	//
	//    - pos
	//    - newText
	//    - newTextLength
	//
	InsertText(pos *TextIter, newText string, newTextLength int32)
	// The function takes the following parameters:
	//
	MarkDeleted(mark *TextMark)
	// The function takes the following parameters:
	//
	//    - location
	//    - mark
	//
	MarkSet(location *TextIter, mark *TextMark)
	ModifiedChanged()
	// The function takes the following parameters:
	//
	PasteDone(clipboard *gdk.Clipboard)
	// Redo redoes the next redoable action on the buffer, if there is one.
	Redo()
	// RemoveTag emits the “remove-tag” signal.
	//
	// The default handler for the signal removes all occurrences of tag from
	// the given range. start and end don’t have to be in order.
	//
	// The function takes the following parameters:
	//
	//    - tag: GtkTextTag.
	//    - start: one bound of range to be untagged.
	//    - end: other bound of range to be untagged.
	//
	RemoveTag(tag *TextTag, start, end *TextIter)
	// Undo undoes the last undoable action on the buffer, if there is one.
	Undo()
}

// TextBuffer stores text and attributes for display in a GtkTextView.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextBuffer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TextBuffer)(nil)
)

func classInitTextBufferer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "TextBufferClass")

	if _, ok := goval.(interface {
		ApplyTag(tag *TextTag, start, end *TextIter)
	}); ok {
		o := pclass.StructFieldOffset("apply_tag")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_apply_tag)
	}

	if _, ok := goval.(interface{ BeginUserAction() }); ok {
		o := pclass.StructFieldOffset("begin_user_action")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_begin_user_action)
	}

	if _, ok := goval.(interface{ Changed() }); ok {
		o := pclass.StructFieldOffset("changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_changed)
	}

	if _, ok := goval.(interface{ DeleteRange(start, end *TextIter) }); ok {
		o := pclass.StructFieldOffset("delete_range")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_delete_range)
	}

	if _, ok := goval.(interface{ EndUserAction() }); ok {
		o := pclass.StructFieldOffset("end_user_action")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_end_user_action)
	}

	if _, ok := goval.(interface {
		InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor)
	}); ok {
		o := pclass.StructFieldOffset("insert_child_anchor")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_insert_child_anchor)
	}

	if _, ok := goval.(interface {
		InsertPaintable(iter *TextIter, paintable gdk.Paintabler)
	}); ok {
		o := pclass.StructFieldOffset("insert_paintable")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_insert_paintable)
	}

	if _, ok := goval.(interface {
		InsertText(pos *TextIter, newText string, newTextLength int32)
	}); ok {
		o := pclass.StructFieldOffset("insert_text")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_insert_text)
	}

	if _, ok := goval.(interface{ MarkDeleted(mark *TextMark) }); ok {
		o := pclass.StructFieldOffset("mark_deleted")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_mark_deleted)
	}

	if _, ok := goval.(interface {
		MarkSet(location *TextIter, mark *TextMark)
	}); ok {
		o := pclass.StructFieldOffset("mark_set")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_mark_set)
	}

	if _, ok := goval.(interface{ ModifiedChanged() }); ok {
		o := pclass.StructFieldOffset("modified_changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_modified_changed)
	}

	if _, ok := goval.(interface {
		PasteDone(clipboard *gdk.Clipboard)
	}); ok {
		o := pclass.StructFieldOffset("paste_done")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_paste_done)
	}

	if _, ok := goval.(interface{ Redo() }); ok {
		o := pclass.StructFieldOffset("redo")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_redo)
	}

	if _, ok := goval.(interface {
		RemoveTag(tag *TextTag, start, end *TextIter)
	}); ok {
		o := pclass.StructFieldOffset("remove_tag")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_remove_tag)
	}

	if _, ok := goval.(interface{ Undo() }); ok {
		o := pclass.StructFieldOffset("undo")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_TextBufferClass_undo)
	}
}

//export _gotk4_gtk4_TextBufferClass_apply_tag
func _gotk4_gtk4_TextBufferClass_apply_tag(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ApplyTag(tag *TextTag, start, end *TextIter)
	})

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	iface.ApplyTag(_tag, _start, _end)
}

//export _gotk4_gtk4_TextBufferClass_begin_user_action
func _gotk4_gtk4_TextBufferClass_begin_user_action(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ BeginUserAction() })

	iface.BeginUserAction()
}

//export _gotk4_gtk4_TextBufferClass_changed
func _gotk4_gtk4_TextBufferClass_changed(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Changed() })

	iface.Changed()
}

//export _gotk4_gtk4_TextBufferClass_delete_range
func _gotk4_gtk4_TextBufferClass_delete_range(arg0 *C.void, arg1 *C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ DeleteRange(start, end *TextIter) })

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iface.DeleteRange(_start, _end)
}

//export _gotk4_gtk4_TextBufferClass_end_user_action
func _gotk4_gtk4_TextBufferClass_end_user_action(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ EndUserAction() })

	iface.EndUserAction()
}

//export _gotk4_gtk4_TextBufferClass_insert_child_anchor
func _gotk4_gtk4_TextBufferClass_insert_child_anchor(arg0 *C.void, arg1 *C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor)
	})

	var _iter *TextIter          // out
	var _anchor *TextChildAnchor // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_anchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(arg2)))

	iface.InsertChildAnchor(_iter, _anchor)
}

//export _gotk4_gtk4_TextBufferClass_insert_paintable
func _gotk4_gtk4_TextBufferClass_insert_paintable(arg0 *C.void, arg1 *C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		InsertPaintable(iter *TextIter, paintable gdk.Paintabler)
	})

	var _iter *TextIter           // out
	var _paintable gdk.Paintabler // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gdk.Paintabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Paintabler)
			return ok
		})
		rv, ok := casted.(gdk.Paintabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Paintabler")
		}
		_paintable = rv
	}

	iface.InsertPaintable(_iter, _paintable)
}

//export _gotk4_gtk4_TextBufferClass_insert_text
func _gotk4_gtk4_TextBufferClass_insert_text(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 C.int) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		InsertText(pos *TextIter, newText string, newTextLength int32)
	})

	var _pos *TextIter       // out
	var _newText string      // out
	var _newTextLength int32 // out

	_pos = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_newTextLength = int32(arg3)

	iface.InsertText(_pos, _newText, _newTextLength)
}

//export _gotk4_gtk4_TextBufferClass_mark_deleted
func _gotk4_gtk4_TextBufferClass_mark_deleted(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ MarkDeleted(mark *TextMark) })

	var _mark *TextMark // out

	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg1)))

	iface.MarkDeleted(_mark)
}

//export _gotk4_gtk4_TextBufferClass_mark_set
func _gotk4_gtk4_TextBufferClass_mark_set(arg0 *C.void, arg1 *C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		MarkSet(location *TextIter, mark *TextMark)
	})

	var _location *TextIter // out
	var _mark *TextMark     // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg2)))

	iface.MarkSet(_location, _mark)
}

//export _gotk4_gtk4_TextBufferClass_modified_changed
func _gotk4_gtk4_TextBufferClass_modified_changed(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ModifiedChanged() })

	iface.ModifiedChanged()
}

//export _gotk4_gtk4_TextBufferClass_paste_done
func _gotk4_gtk4_TextBufferClass_paste_done(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PasteDone(clipboard *gdk.Clipboard)
	})

	var _clipboard *gdk.Clipboard // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_clipboard = &gdk.Clipboard{
			Object: obj,
		}
	}

	iface.PasteDone(_clipboard)
}

//export _gotk4_gtk4_TextBufferClass_redo
func _gotk4_gtk4_TextBufferClass_redo(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Redo() })

	iface.Redo()
}

//export _gotk4_gtk4_TextBufferClass_remove_tag
func _gotk4_gtk4_TextBufferClass_remove_tag(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		RemoveTag(tag *TextTag, start, end *TextIter)
	})

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	iface.RemoveTag(_tag, _start, _end)
}

//export _gotk4_gtk4_TextBufferClass_undo
func _gotk4_gtk4_TextBufferClass_undo(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Undo() })

	iface.Undo()
}

func wrapTextBuffer(obj *coreglib.Object) *TextBuffer {
	return &TextBuffer{
		Object: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	return wrapTextBuffer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_TextBuffer_ConnectApplyTag
func _gotk4_gtk4_TextBuffer_ConnectApplyTag(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 C.guintptr) {
	var f func(tag *TextTag, start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag, start, end *TextIter))
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	f(_tag, _start, _end)
}

// ConnectApplyTag is emitted to apply a tag to a range of text in a
// GtkTextBuffer.
//
// Applying actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk.TextBuffer.ApplyTag(), gtk.TextBuffer.InsertWithTags(),
// gtk.TextBuffer.InsertRange().
func (buffer *TextBuffer) ConnectApplyTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "apply-tag", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectApplyTag), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectBeginUserAction
func _gotk4_gtk4_TextBuffer_ConnectBeginUserAction(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectBeginUserAction is emitted at the beginning of a single user-visible
// operation on a GtkTextBuffer.
//
// See also: gtk.TextBuffer.BeginUserAction(),
// gtk.TextBuffer.InsertInteractive(), gtk.TextBuffer.InsertRangeInteractive(),
// gtk.TextBuffer.DeleteInteractive(), gtk.TextBuffer.Backspace(),
// gtk.TextBuffer.DeleteSelection().
func (buffer *TextBuffer) ConnectBeginUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "begin-user-action", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectBeginUserAction), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectChanged
func _gotk4_gtk4_TextBuffer_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectChanged is emitted when the content of a GtkTextBuffer has changed.
func (buffer *TextBuffer) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "changed", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectChanged), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectDeleteRange
func _gotk4_gtk4_TextBuffer_ConnectDeleteRange(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 C.guintptr) {
	var f func(start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(start, end *TextIter))
	}

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_start, _end)
}

// ConnectDeleteRange is emitted to delete a range from a GtkTextBuffer.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them). The default
// signal handler revalidates the start and end iters to both point to the
// location where text was deleted. Handlers which run after the default handler
// (see g_signal_connect_after()) do not have access to the deleted text.
//
// See also: gtk.TextBuffer.Delete().
func (buffer *TextBuffer) ConnectDeleteRange(f func(start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "delete-range", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectDeleteRange), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectEndUserAction
func _gotk4_gtk4_TextBuffer_ConnectEndUserAction(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectEndUserAction is emitted at the end of a single user-visible operation
// on the GtkTextBuffer.
//
// See also: gtk.TextBuffer.EndUserAction(), gtk.TextBuffer.InsertInteractive(),
// gtk.TextBuffer.InsertRangeInteractive(), gtk.TextBuffer.DeleteInteractive(),
// gtk.TextBuffer.Backspace(), gtk.TextBuffer.DeleteSelection(),
// gtk.TextBuffer.Backspace().
func (buffer *TextBuffer) ConnectEndUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "end-user-action", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectEndUserAction), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectInsertChildAnchor
func _gotk4_gtk4_TextBuffer_ConnectInsertChildAnchor(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 C.guintptr) {
	var f func(location *TextIter, anchor *TextChildAnchor)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, anchor *TextChildAnchor))
	}

	var _location *TextIter      // out
	var _anchor *TextChildAnchor // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_anchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(arg2)))

	f(_location, _anchor)
}

// ConnectInsertChildAnchor is emitted to insert a GtkTextChildAnchor in a
// GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted anchor.
//
// See also: gtk.TextBuffer.InsertChildAnchor().
func (buffer *TextBuffer) ConnectInsertChildAnchor(f func(location *TextIter, anchor *TextChildAnchor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-child-anchor", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertChildAnchor), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectInsertPaintable
func _gotk4_gtk4_TextBuffer_ConnectInsertPaintable(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 C.guintptr) {
	var f func(location *TextIter, paintable gdk.Paintabler)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, paintable gdk.Paintabler))
	}

	var _location *TextIter       // out
	var _paintable gdk.Paintabler // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gdk.Paintabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Paintabler)
			return ok
		})
		rv, ok := casted.(gdk.Paintabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Paintabler")
		}
		_paintable = rv
	}

	f(_location, _paintable)
}

// ConnectInsertPaintable is emitted to insert a GdkPaintable in a
// GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted paintable.
//
// See also: gtk.TextBuffer.InsertPaintable().
func (buffer *TextBuffer) ConnectInsertPaintable(f func(location *TextIter, paintable gdk.Paintabler)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-paintable", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertPaintable), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectInsertText
func _gotk4_gtk4_TextBuffer_ConnectInsertText(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 C.gint, arg4 C.guintptr) {
	var f func(location *TextIter, text string, len int32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, text string, len int32))
	}

	var _location *TextIter // out
	var _text string        // out
	var _len int32          // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_len = int32(arg3)

	f(_location, _text, _len)
}

// ConnectInsertText is emitted to insert text in a GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to point to the end of the inserted text.
//
// See also: gtk,textbuffer.Insert, gtk.TextBuffer.InsertRange().
func (buffer *TextBuffer) ConnectInsertText(f func(location *TextIter, text string, len int32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-text", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertText), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectMarkDeleted
func _gotk4_gtk4_TextBuffer_ConnectMarkDeleted(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(mark *TextMark)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mark *TextMark))
	}

	var _mark *TextMark // out

	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg1)))

	f(_mark)
}

// ConnectMarkDeleted is emitted as notification after a GtkTextMark is deleted.
//
// See also: gtk.TextBuffer.DeleteMark().
func (buffer *TextBuffer) ConnectMarkDeleted(f func(mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "mark-deleted", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectMarkDeleted), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectMarkSet
func _gotk4_gtk4_TextBuffer_ConnectMarkSet(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 C.guintptr) {
	var f func(location *TextIter, mark *TextMark)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, mark *TextMark))
	}

	var _location *TextIter // out
	var _mark *TextMark     // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg2)))

	f(_location, _mark)
}

// ConnectMarkSet is emitted as notification after a GtkTextMark is set.
//
// See also: gtk.TextBuffer.CreateMark(), gtk.TextBuffer.MoveMark().
func (buffer *TextBuffer) ConnectMarkSet(f func(location *TextIter, mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "mark-set", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectMarkSet), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectModifiedChanged
func _gotk4_gtk4_TextBuffer_ConnectModifiedChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectModifiedChanged is emitted when the modified bit of a GtkTextBuffer
// flips.
//
// See also: gtk.TextBuffer.SetModified().
func (buffer *TextBuffer) ConnectModifiedChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "modified-changed", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectModifiedChanged), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectPasteDone
func _gotk4_gtk4_TextBuffer_ConnectPasteDone(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(clipboard *gdk.Clipboard)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(clipboard *gdk.Clipboard))
	}

	var _clipboard *gdk.Clipboard // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_clipboard = &gdk.Clipboard{
			Object: obj,
		}
	}

	f(_clipboard)
}

// ConnectPasteDone is emitted after paste operation has been completed.
//
// This is useful to properly scroll the view to the end of the pasted text. See
// gtk.TextBuffer.PasteClipboard() for more details.
func (buffer *TextBuffer) ConnectPasteDone(f func(clipboard *gdk.Clipboard)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "paste-done", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectPasteDone), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectRedo
func _gotk4_gtk4_TextBuffer_ConnectRedo(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectRedo is emitted when a request has been made to redo the previously
// undone operation.
func (buffer *TextBuffer) ConnectRedo(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "redo", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectRedo), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectRemoveTag
func _gotk4_gtk4_TextBuffer_ConnectRemoveTag(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 C.guintptr) {
	var f func(tag *TextTag, start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag, start, end *TextIter))
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	f(_tag, _start, _end)
}

// ConnectRemoveTag is emitted to remove all occurrences of tag from a range of
// text in a GtkTextBuffer.
//
// Removal actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk.TextBuffer.RemoveTag().
func (buffer *TextBuffer) ConnectRemoveTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "remove-tag", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectRemoveTag), f)
}

//export _gotk4_gtk4_TextBuffer_ConnectUndo
func _gotk4_gtk4_TextBuffer_ConnectUndo(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectUndo is emitted when a request has been made to undo the previous
// operation or set of operations that have been grouped together.
func (buffer *TextBuffer) ConnectUndo(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "undo", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectUndo), f)
}

// NewTextBuffer creates a new text buffer.
//
// The function takes the following parameters:
//
//    - table (optional): tag table, or NULL to create a new one.
//
// The function returns the following values:
//
//    - textBuffer: new text buffer.
//
func NewTextBuffer(table *TextTagTable) *TextBuffer {
	var _args [1]girepository.Argument

	if table != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("new_TextBuffer", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(table)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textBuffer
}

// AddMark adds the mark at position where.
//
// The mark must not be added to another buffer, and if its name is not NULL
// then there must not be another mark in the buffer with the same name.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
//
// The function takes the following parameters:
//
//    - mark to add.
//    - where: location to place mark.
//
func (buffer *TextBuffer) AddMark(mark *TextMark, where *TextIter) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("add_mark", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// AddSelectionClipboard adds clipboard to the list of clipboards in which the
// selection contents of buffer are available.
//
// In most cases, clipboard will be the GdkClipboard returned by
// gtk.Widget.GetPrimaryClipboard() for a view of buffer.
//
// The function takes the following parameters:
//
//    - clipboard: GdkClipboard.
//
func (buffer *TextBuffer) AddSelectionClipboard(clipboard *gdk.Clipboard) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("add_selection_clipboard", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// ApplyTag emits the “apply-tag” signal on buffer.
//
// The default handler for the signal applies tag to the given range. start and
// end do not have to be in order.
//
// The function takes the following parameters:
//
//    - tag: GtkTextTag.
//    - start: one bound of range to be tagged.
//    - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) ApplyTag(tag *TextTag, start, end *TextIter) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("apply_tag", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ApplyTagByName emits the “apply-tag” signal on buffer.
//
// Calls gtk.TextTagTable.Lookup() on the buffer’s tag table to get a
// GtkTextTag, then calls gtk.TextBuffer.ApplyTag().
//
// The function takes the following parameters:
//
//    - name of a named GtkTextTag.
//    - start: one bound of range to be tagged.
//    - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) ApplyTagByName(name string, start, end *TextIter) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("apply_tag_by_name", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by iter.
//
// In the normal case a single character will be deleted, but when combining
// accents are involved, more than one character can be deleted, and when
// precomposed character and accent combinations are involved, less than one
// character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the iter will be re-initialized to
// point to the location where text was deleted.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - interactive: whether the deletion is caused by user interaction.
//    - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//    - ok: TRUE if the buffer was modified.
//
func (buffer *TextBuffer) Backspace(iter *TextIter, interactive, defaultEditable bool) bool {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if interactive {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}
	if defaultEditable {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("backspace", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BeginIrreversibleAction denotes the beginning of an action that may not be
// undone.
//
// This will cause any previous operations in the undo/redo queue to be cleared.
//
// This should be paired with a call to gtk.TextBuffer.EndIrreversibleAction()
// after the irreversible action has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer *TextBuffer) BeginIrreversibleAction() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("begin_irreversible_action", _args[:], nil)

	runtime.KeepAlive(buffer)
}

// BeginUserAction: called to indicate that the buffer operations between here
// and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when creating an undo
// stack. GtkTextBuffer maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with a call to
// gtk_text_buffer_end_user_action(), and emits the “begin-user-action” and
// “end-user-action” signals only for the outermost pair of calls. This allows
// you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user action
// around the buffer operations they perform, so there's no need to add extra
// calls if you user action consists solely of a single call to one of those
// functions.
func (buffer *TextBuffer) BeginUserAction() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("begin_user_action", _args[:], nil)

	runtime.KeepAlive(buffer)
}

// CopyClipboard copies the currently-selected text to a clipboard.
//
// The function takes the following parameters:
//
//    - clipboard: GdkClipboard object to copy to.
//
func (buffer *TextBuffer) CopyClipboard(clipboard *gdk.Clipboard) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("copy_clipboard", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// CreateChildAnchor creates and inserts a child anchor.
//
// This is a convenience function which simply creates a child anchor with
// gtk.TextChildAnchor.New and inserts it into the buffer with
// gtk.TextBuffer.InsertChildAnchor().
//
// The new anchor is owned by the buffer; no reference count is returned to the
// caller of this function.
//
// The function takes the following parameters:
//
//    - iter: location in the buffer.
//
// The function returns the following values:
//
//    - textChildAnchor: created child anchor.
//
func (buffer *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("create_child_anchor", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// CreateMark creates a mark at position where.
//
// If mark_name is NULL, the mark is anonymous; otherwise, the mark can be
// retrieved by name using gtk.TextBuffer.GetMark(). If a mark has left gravity,
// and text is inserted at the mark’s current location, the mark will be moved
// to the left of the newly-inserted text. If the mark has right gravity
// (left_gravity = FALSE), the mark will end up on the right of newly-inserted
// text. The standard left-to-right cursor is a mark with right gravity (when
// you type, the cursor stays on the right side of the text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
//
// The function takes the following parameters:
//
//    - markName (optional): name for mark, or NULL.
//    - where: location to place mark.
//    - leftGravity: whether the mark has left gravity.
//
// The function returns the following values:
//
//    - textMark: new TextMark object.
//
func (buffer *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if markName != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(markName)))
		defer C.free(unsafe.Pointer(_args[1]))
	}
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))
	if leftGravity {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("create_mark", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(markName)
	runtime.KeepAlive(where)
	runtime.KeepAlive(leftGravity)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
//
// The function takes the following parameters:
//
//    - clipboard: GdkClipboard object to cut to.
//    - defaultEditable: default editability of the buffer.
//
func (buffer *TextBuffer) CutClipboard(clipboard *gdk.Clipboard, defaultEditable bool) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if defaultEditable {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("cut_clipboard", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(defaultEditable)
}

// Delete deletes text between start and end.
//
// The order of start and end is not actually relevant; gtk_text_buffer_delete()
// will reorder them.
//
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified, all
// outstanding iterators become invalid after calling this function; however,
// the start and end will be re-initialized to point to the location where text
// was deleted.
//
// The function takes the following parameters:
//
//    - start: position in buffer.
//    - end: another position in buffer.
//
func (buffer *TextBuffer) Delete(start, end *TextIter) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// DeleteInteractive deletes all editable text in the given range.
//
// Calls gtk.TextBuffer.Delete() for each editable sub-range of [start,end).
// start and end are revalidated to point to the location of the last deleted
// range, or left untouched if no text was deleted.
//
// The function takes the following parameters:
//
//    - startIter: start of range to delete.
//    - endIter: end of range.
//    - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//    - ok: whether some text was actually deleted.
//
func (buffer *TextBuffer) DeleteInteractive(startIter, endIter *TextIter, defaultEditable bool) bool {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(startIter)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(endIter)))
	if defaultEditable {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete_interactive", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(startIter)
	runtime.KeepAlive(endIter)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DeleteMark deletes mark, so that it’s no longer located anywhere in the
// buffer.
//
// Removes the reference the buffer holds to the mark, so if you haven’t called
// g_object_ref() on the mark, it will be freed. Even if the mark isn’t freed,
// most operations on mark become invalid, until it gets added to a buffer again
// with gtk.TextBuffer.AddMark(). Use gtk.TextMark.GetDeleted() to find out if a
// mark has been removed from its buffer.
//
// The gtk.TextBuffer::mark-deleted signal will be emitted as notification after
// the mark is deleted.
//
// The function takes the following parameters:
//
//    - mark: GtkTextMark in buffer.
//
func (buffer *TextBuffer) DeleteMark(mark *TextMark) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete_mark", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
}

// DeleteMarkByName deletes the mark named name; the mark must exist.
//
// See gtk.TextBuffer.DeleteMark() for details.
//
// The function takes the following parameters:
//
//    - name of a mark in buffer.
//
func (buffer *TextBuffer) DeleteMarkByName(name string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete_mark_by_name", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
}

// DeleteSelection deletes the range between the “insert” and “selection_bound”
// marks, that is, the currently-selected text.
//
// If interactive is TRUE, the editability of the selection will be considered
// (users can’t delete uneditable text).
//
// The function takes the following parameters:
//
//    - interactive: whether the deletion is caused by user interaction.
//    - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//    - ok: whether there was a non-empty selection to delete.
//
func (buffer *TextBuffer) DeleteSelection(interactive, defaultEditable bool) bool {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if interactive {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}
	if defaultEditable {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete_selection", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// EndIrreversibleAction denotes the end of an action that may not be undone.
//
// This will cause any previous operations in the undo/redo queue to be cleared.
//
// This should be called after completing modifications to the text buffer after
// gtk_text_buffer_begin_irreversible_action() was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer *TextBuffer) EndIrreversibleAction() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("end_irreversible_action", _args[:], nil)

	runtime.KeepAlive(buffer)
}

// EndUserAction ends a user-visible operation.
//
// Should be paired with a call to gtk.TextBuffer.BeginUserAction(). See that
// function for a full explanation.
func (buffer *TextBuffer) EndUserAction() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("end_user_action", _args[:], nil)

	runtime.KeepAlive(buffer)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the entire
// buffer lies within the range [start,end).
//
// The function returns the following values:
//
//    - start: iterator to initialize with first position in the buffer.
//    - end: iterator to initialize with the end iterator.
//
func (buffer *TextBuffer) Bounds() (start, end *TextIter) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_bounds", _args[:], _outs[:])

	runtime.KeepAlive(buffer)

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[1])))

	return _start, _end
}

// CanRedo gets whether there is a redoable action in the history.
//
// The function returns the following values:
//
//    - ok: TRUE if there is an redoable action.
//
func (buffer *TextBuffer) CanRedo() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_can_redo", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// CanUndo gets whether there is an undoable action in the history.
//
// The function returns the following values:
//
//    - ok: TRUE if there is an undoable action.
//
func (buffer *TextBuffer) CanUndo() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_can_undo", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// CharCount gets the number of characters in the buffer.
//
// Note that characters and bytes are not the same, you can’t e.g. expect the
// contents of the buffer in string form to be this many bytes long.
//
// The character count is cached, so this function is very fast.
//
// The function returns the following values:
//
//    - gint: number of characters in the buffer.
//
func (buffer *TextBuffer) CharCount() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_char_count", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// EnableUndo gets whether the buffer is saving modifications to the buffer to
// allow for undo and redo actions.
//
// See gtk.TextBuffer.BeginIrreversibleAction() and
// gtk.TextBuffer.EndIrreversibleAction() to create changes to the buffer that
// cannot be undone.
//
// The function returns the following values:
//
func (buffer *TextBuffer) EnableUndo() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_enable_undo", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// EndIter initializes iter with the “end iterator,” one past the last valid
// character in the text buffer.
//
// If dereferenced with gtk.TextIter.GetChar(), the end iterator has a character
// value of 0. The entire buffer lies in the range from the first position in
// the buffer (call gtk.TextBuffer.GetStartIter() to get character position 0)
// to the end iterator.
//
// The function returns the following values:
//
//    - iter: iterator to initialize.
//
func (buffer *TextBuffer) EndIter() *TextIter {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_end_iter", _args[:], _outs[:])

	runtime.KeepAlive(buffer)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))

	return _iter
}

// HasSelection indicates whether the buffer has some text currently selected.
//
// The function returns the following values:
//
//    - ok: TRUE if the there is text selected.
//
func (buffer *TextBuffer) HasSelection() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_has_selection", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// GetInsert returns the mark that represents the cursor (insertion point).
//
// Equivalent to calling gtk.TextBuffer.GetMark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
//
// The function returns the following values:
//
//    - textMark: insertion point mark.
//
func (buffer *TextBuffer) GetInsert() *TextMark {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_insert", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// IterAtChildAnchor obtains the location of anchor within buffer.
//
// The function takes the following parameters:
//
//    - anchor: child anchor that appears in buffer.
//
// The function returns the following values:
//
//    - iter: iterator to be initialized.
//
func (buffer *TextBuffer) IterAtChildAnchor(anchor *TextChildAnchor) *TextIter {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_iter_at_child_anchor", _args[:], _outs[:])

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(anchor)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))

	return _iter
}

// IterAtLine initializes iter to the start of the given line.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned.
//
// The function takes the following parameters:
//
//    - lineNumber: line number counting from 0.
//
// The function returns the following values:
//
//    - iter: iterator to initialize.
//    - ok: whether the exact position has been found.
//
func (buffer *TextBuffer) IterAtLine(lineNumber int32) (*TextIter, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(lineNumber)

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_iter_at_line", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineIndex obtains an iterator pointing to byte_index within the given
// line.
//
// byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned. And if byte_index is off the end of the line,
// the iterator at the end of the line is returned.
//
// The function takes the following parameters:
//
//    - lineNumber: line number counting from 0.
//    - byteIndex: byte index from start of line.
//
// The function returns the following values:
//
//    - iter: iterator to initialize.
//    - ok: whether the exact position has been found.
//
func (buffer *TextBuffer) IterAtLineIndex(lineNumber, byteIndex int32) (*TextIter, bool) {
	var _args [3]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(lineNumber)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(byteIndex)

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_iter_at_line_index", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(byteIndex)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineOffset obtains an iterator pointing to char_offset within the given
// line.
//
// Note characters, not bytes; UTF-8 may encode one character as multiple bytes.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned. And if char_offset is off the end of the line,
// the iterator at the end of the line is returned.
//
// The function takes the following parameters:
//
//    - lineNumber: line number counting from 0.
//    - charOffset: char offset from start of line.
//
// The function returns the following values:
//
//    - iter: iterator to initialize.
//    - ok: whether the exact position has been found.
//
func (buffer *TextBuffer) IterAtLineOffset(lineNumber, charOffset int32) (*TextIter, bool) {
	var _args [3]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(lineNumber)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(charOffset)

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_iter_at_line_offset", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(charOffset)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtMark initializes iter with the current position of mark.
//
// The function takes the following parameters:
//
//    - mark: GtkTextMark in buffer.
//
// The function returns the following values:
//
//    - iter: iterator to initialize.
//
func (buffer *TextBuffer) IterAtMark(mark *TextMark) *TextIter {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_iter_at_mark", _args[:], _outs[:])

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))

	return _iter
}

// IterAtOffset initializes iter to a position char_offset chars from the start
// of the entire buffer.
//
// If char_offset is -1 or greater than the number of characters in the buffer,
// iter is initialized to the end iterator, the iterator one past the last valid
// character in the buffer.
//
// The function takes the following parameters:
//
//    - charOffset: char offset from start of buffer, counting from 0, or -1.
//
// The function returns the following values:
//
//    - iter: iterator to initialize.
//
func (buffer *TextBuffer) IterAtOffset(charOffset int32) *TextIter {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(charOffset)

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_iter_at_offset", _args[:], _outs[:])

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(charOffset)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))

	return _iter
}

// LineCount obtains the number of lines in the buffer.
//
// This value is cached, so the function is very fast.
//
// The function returns the following values:
//
//    - gint: number of lines in the buffer.
//
func (buffer *TextBuffer) LineCount() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_line_count", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// Mark returns the mark named name in buffer buffer, or NULL if no such mark
// exists in the buffer.
//
// The function takes the following parameters:
//
//    - name: mark name.
//
// The function returns the following values:
//
//    - textMark (optional) or NULL.
//
func (buffer *TextBuffer) Mark(name string) *TextMark {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_mark", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _textMark *TextMark // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _textMark
}

// MaxUndoLevels gets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
//
// The function returns the following values:
//
func (buffer *TextBuffer) MaxUndoLevels() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_max_undo_levels", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Modified indicates whether the buffer has been modified since the last call
// to gtk.TextBuffer.SetModified() set the modification flag to FALSE.
//
// Used for example to enable a “save” function in a text editor.
//
// The function returns the following values:
//
//    - ok: TRUE if the buffer has been modified.
//
func (buffer *TextBuffer) Modified() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_modified", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SelectionBound returns the mark that represents the selection bound.
//
// Equivalent to calling gtk.TextBuffer.GetMark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert” are
// in the same place, then there is no current selection.
// gtk.TextBuffer.GetSelectionBounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a selection
// and what its bounds are.
//
// The function returns the following values:
//
//    - textMark: selection bound mark.
//
func (buffer *TextBuffer) SelectionBound() *TextMark {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_selection_bound", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// SelectionBounds returns TRUE if some text is selected; places the bounds of
// the selection in start and end.
//
// If the selection has length 0, then start and end are filled in with the same
// value. start and end will be in ascending order. If start and end are NULL,
// then they are not filled in, but the return value still indicates whether
// text is selected.
//
// The function returns the following values:
//
//    - start: iterator to initialize with selection start.
//    - end: iterator to initialize with selection end.
//    - ok: whether the selection has nonzero length.
//
func (buffer *TextBuffer) SelectionBounds() (start, end *TextIter, ok bool) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_selection_bounds", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _start *TextIter // out
	var _end *TextIter   // out
	var _ok bool         // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[1])))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// SelectionContent: get a content provider for this buffer.
//
// It can be used to make the content of buffer available in a GdkClipboard, see
// gdk.Clipboard.SetContent().
//
// The function returns the following values:
//
//    - contentProvider: new GdkContentProvider.
//
func (buffer *TextBuffer) SelectionContent() *gdk.ContentProvider {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_selection_content", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _contentProvider *gdk.ContentProvider // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_contentProvider = &gdk.ContentProvider{
			Object: obj,
		}
	}

	return _contentProvider
}

// Slice returns the text in the range [start,end).
//
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if include_hidden_chars is FALSE. The returned string includes a
// 0xFFFC character whenever the buffer contains embedded images, so byte and
// character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with gtk.TextBuffer.GetText().
// Note that 0xFFFC can occur in normal text as well, so it is not a reliable
// indicator that a paintable or widget is in the buffer.
//
// The function takes the following parameters:
//
//    - start of a range.
//    - end of a range.
//    - includeHiddenChars: whether to include invisible text.
//
// The function returns the following values:
//
//    - utf8: allocated UTF-8 string.
//
func (buffer *TextBuffer) Slice(start, end *TextIter, includeHiddenChars bool) string {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_slice", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// StartIter: initialized iter with the first position in the text buffer.
//
// This is the same as using gtk.TextBuffer.GetIterAtOffset() to get the iter at
// character offset 0.
//
// The function returns the following values:
//
//    - iter: iterator to initialize.
//
func (buffer *TextBuffer) StartIter() *TextIter {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_start_iter", _args[:], _outs[:])

	runtime.KeepAlive(buffer)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))

	return _iter
}

// TagTable: get the GtkTextTagTable associated with this buffer.
//
// The function returns the following values:
//
//    - textTagTable buffer’s tag table.
//
func (buffer *TextBuffer) TagTable() *TextTagTable {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_tag_table", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _textTagTable *TextTagTable // out

	_textTagTable = wrapTextTagTable(coreglib.Take(unsafe.Pointer(_cret)))

	return _textTagTable
}

// Text returns the text in the range [start,end).
//
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if include_hidden_chars is FALSE. Does not include characters
// representing embedded images, so byte and character indexes into the returned
// string do not correspond to byte and character indexes into the buffer.
// Contrast with gtk.TextBuffer.GetSlice().
//
// The function takes the following parameters:
//
//    - start of a range.
//    - end of a range.
//    - includeHiddenChars: whether to include invisible text.
//
// The function returns the following values:
//
//    - utf8: allocated UTF-8 string.
//
func (buffer *TextBuffer) Text(start, end *TextIter, includeHiddenChars bool) string {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_text", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts len bytes of text at position iter.
//
// If len is -1, text must be nul-terminated and will be inserted in its
// entirety. Emits the “insert-text” signal; insertion actually occurs in the
// default handler for the signal. iter is invalidated when insertion occurs
// (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
//
// The function takes the following parameters:
//
//    - iter: position in the buffer.
//    - text in UTF-8 format.
//
func (buffer *TextBuffer) Insert(iter *TextIter, text string) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.int)(unsafe.Pointer(&_args[3])) = (C.int)(len(text))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[2])))), len(text)), text)
	defer C.free(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[2]))))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
}

// InsertAtCursor inserts text in buffer.
//
// Simply calls gtk.TextBuffer.Insert(), using the current cursor position as
// the insertion point.
//
// The function takes the following parameters:
//
//    - text in UTF-8 format.
//
func (buffer *TextBuffer) InsertAtCursor(text string) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(*C.int)(unsafe.Pointer(&_args[2])) = (C.int)(len(text))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[1])))), len(text)), text)
	defer C.free(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[1]))))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_at_cursor", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at iter.
//
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the “text” variants do not. E.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient alternative
// to this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
//
// The function takes the following parameters:
//
//    - iter: location to insert the anchor.
//    - anchor: GtkTextChildAnchor.
//
func (buffer *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_child_anchor", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(anchor)
}

// InsertInteractive inserts text in buffer.
//
// Like gtk.TextBuffer.Insert(), but the insertion will not occur if iter is at
// a non-editable location in the buffer. Usually you want to prevent insertions
// at ineditable locations if the insertion results from a user action (is
// interactive).
//
// default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - text: some UTF-8 text.
//    - defaultEditable: default editability of buffer.
//
// The function returns the following values:
//
//    - ok: whether text was actually inserted.
//
func (buffer *TextBuffer) InsertInteractive(iter *TextIter, text string, defaultEditable bool) bool {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.int)(unsafe.Pointer(&_args[3])) = (C.int)(len(text))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[2])))), len(text)), text)
	defer C.free(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[2]))))
	if defaultEditable {
		*(*C.gboolean)(unsafe.Pointer(&_args[4])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_interactive", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// InsertInteractiveAtCursor inserts text in buffer.
//
// Calls gtk.TextBuffer.InsertInteractive() at the cursor position.
//
// default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//    - text in UTF-8 format.
//    - defaultEditable: default editability of buffer.
//
// The function returns the following values:
//
//    - ok: whether text was actually inserted.
//
func (buffer *TextBuffer) InsertInteractiveAtCursor(text string, defaultEditable bool) bool {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(*C.int)(unsafe.Pointer(&_args[2])) = (C.int)(len(text))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[1])))), len(text)), text)
	defer C.free(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[1]))))
	if defaultEditable {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_interactive_at_cursor", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// InsertMarkup inserts the text in markup at position iter.
//
// markup will be inserted in its entirety and must be nul-terminated and valid
// UTF-8. Emits the gtk.TextBuffer::insert-text signal, possibly multiple times;
// insertion actually occurs in the default handler for the signal. iter will
// point to the end of the inserted text on return.
//
// The function takes the following parameters:
//
//    - iter: location to insert the markup.
//    - markup: nul-terminated UTF-8 string containing Pango markup.
//
func (buffer *TextBuffer) InsertMarkup(iter *TextIter, markup string) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.int)(unsafe.Pointer(&_args[3])) = (C.int)(len(markup))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(C.calloc(C.size_t((len(markup) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[2])))), len(markup)), markup)
	defer C.free(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[2]))))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_markup", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(markup)
}

// InsertPaintable inserts an image into the text buffer at iter.
//
// The image will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the “text” variants do not. e.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// The function takes the following parameters:
//
//    - iter: location to insert the paintable.
//    - paintable: GdkPaintable.
//
func (buffer *TextBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintabler) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_paintable", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(paintable)
}

// InsertRange copies text, tags, and paintables between start and end and
// inserts the copy at iter.
//
// The order of start and end doesn’t matter.
//
// Used instead of simply getting/inserting text because it preserves images and
// tags. If start and end are in a different buffer from buffer, the two buffers
// must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - start: position in a GtkTextBuffer.
//    - end: another position in the same buffer as start.
//
func (buffer *TextBuffer) InsertRange(iter, start, end *TextIter) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_range", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// InsertRangeInteractive copies text, tags, and paintables between start and
// end and inserts the copy at iter.
//
// Same as gtk.TextBuffer.InsertRange(), but does nothing if the insertion point
// isn’t editable. The default_editable parameter indicates whether the text is
// editable at iter if no tags enclosing iter affect editability. Typically the
// result of gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - start: position in a GtkTextBuffer.
//    - end: another position in the same buffer as start.
//    - defaultEditable: default editability of the buffer.
//
// The function returns the following values:
//
//    - ok: whether an insertion was possible at iter.
//
func (buffer *TextBuffer) InsertRangeInteractive(iter, start, end *TextIter, defaultEditable bool) bool {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	if defaultEditable {
		*(*C.gboolean)(unsafe.Pointer(&_args[4])) = C.TRUE
	}

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_range_interactive", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// MoveMark moves mark to the new location where.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the move.
//
// The function takes the following parameters:
//
//    - mark: GtkTextMark.
//    - where: new location for mark in buffer.
//
func (buffer *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("move_mark", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// MoveMarkByName moves the mark named name (which must exist) to location
// where.
//
// See gtk.TextBuffer.MoveMark() for details.
//
// The function takes the following parameters:
//
//    - name of a mark.
//    - where: new location for mark.
//
func (buffer *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("move_mark_by_name", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(where)
}

// PasteClipboard pastes the contents of a clipboard.
//
// If override_location is NULL, the pasted text will be inserted at the cursor
// position, or the buffer selection will be replaced if the selection is
// non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
//
// The function takes the following parameters:
//
//    - clipboard: GdkClipboard to paste from.
//    - overrideLocation (optional): location to insert pasted text, or NULL.
//    - defaultEditable: whether the buffer is editable by default.
//
func (buffer *TextBuffer) PasteClipboard(clipboard *gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if overrideLocation != nil {
		*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(overrideLocation)))
	}
	if defaultEditable {
		*(*C.gboolean)(unsafe.Pointer(&_args[3])) = C.TRUE
	}

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("paste_clipboard", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(overrideLocation)
	runtime.KeepAlive(defaultEditable)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them to the same place in two steps with
// gtk.TextBuffer.MoveMark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
//
// The function takes the following parameters:
//
//    - where to put the cursor.
//
func (buffer *TextBuffer) PlaceCursor(where *TextIter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("place_cursor", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(where)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (buffer *TextBuffer) Redo() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("redo", _args[:], nil)

	runtime.KeepAlive(buffer)
}

// RemoveAllTags removes all tags in the range between start and end.
//
// Be careful with this function; it could remove tags added in code unrelated
// to the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that add
// tags.
//
// The function takes the following parameters:
//
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveAllTags(start, end *TextIter) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("remove_all_tags", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveSelectionClipboard removes a GdkClipboard added with
// gtk_text_buffer_add_selection_clipboard().
//
// The function takes the following parameters:
//
//    - clipboard: GdkClipboard added to buffer by
//      gtk.TextBuffer.AddSelectionClipboard().
//
func (buffer *TextBuffer) RemoveSelectionClipboard(clipboard *gdk.Clipboard) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("remove_selection_clipboard", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// RemoveTag emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences of tag from the
// given range. start and end don’t have to be in order.
//
// The function takes the following parameters:
//
//    - tag: GtkTextTag.
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveTag(tag *TextTag, start, end *TextIter) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("remove_tag", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveTagByName emits the “remove-tag” signal.
//
// Calls gtk.TextTagTable.Lookup() on the buffer’s tag table to get a
// GtkTextTag, then calls gtk.TextBuffer.RemoveTag().
//
// The function takes the following parameters:
//
//    - name of a GtkTextTag.
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveTagByName(name string, start, end *TextIter) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[1]))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("remove_tag_by_name", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them in two steps with gtk.TextBuffer.MoveMark(), you will
// temporarily select a region in between their old and new locations, which can
// be pretty inefficient since the temporarily-selected region will force stuff
// to be recalculated. This function moves them as a unit, which can be
// optimized.
//
// The function takes the following parameters:
//
//    - ins: where to put the “insert” mark.
//    - bound: where to put the “selection_bound” mark.
//
func (buffer *TextBuffer) SelectRange(ins, bound *TextIter) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(ins)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(bound)))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("select_range", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ins)
	runtime.KeepAlive(bound)
}

// SetEnableUndo sets whether or not to enable undoable actions in the text
// buffer.
//
// If enabled, the user will be able to undo the last number of actions up to
// gtk.TextBuffer.GetMaxUndoLevels().
//
// See gtk.TextBuffer.BeginIrreversibleAction() and
// gtk.TextBuffer.EndIrreversibleAction() to create changes to the buffer that
// cannot be undone.
//
// The function takes the following parameters:
//
//    - enableUndo: TRUE to enable undo.
//
func (buffer *TextBuffer) SetEnableUndo(enableUndo bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if enableUndo {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("set_enable_undo", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(enableUndo)
}

// SetMaxUndoLevels sets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
//
// The function takes the following parameters:
//
//    - maxUndoLevels: maximum number of undo actions to perform.
//
func (buffer *TextBuffer) SetMaxUndoLevels(maxUndoLevels uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(maxUndoLevels)

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("set_max_undo_levels", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(maxUndoLevels)
}

// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved.
//
// Whenever the buffer is saved to disk, call gtk_text_buffer_set_modified
// (buffer, FALSE). When the buffer is modified, it will automatically toggled
// on the modified bit again. When the modified bit flips, the buffer emits the
// gtk.TextBuffer::modified-changed signal.
//
// The function takes the following parameters:
//
//    - setting: modification flag setting.
//
func (buffer *TextBuffer) SetModified(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("set_modified", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(setting)
}

// SetText deletes current contents of buffer, and inserts text instead.
//
// If len is -1, text must be nul-terminated. text must be valid UTF-8.
//
// The function takes the following parameters:
//
//    - text: UTF-8 text to insert.
//
func (buffer *TextBuffer) SetText(text string) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(*C.int)(unsafe.Pointer(&_args[2])) = (C.int)(len(text))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[1])))), len(text)), text)
	defer C.free(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_args[1]))))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("set_text", _args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (buffer *TextBuffer) Undo() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("undo", _args[:], nil)

	runtime.KeepAlive(buffer)
}

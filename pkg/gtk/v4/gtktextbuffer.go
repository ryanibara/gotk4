// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
// extern void _gotk4_gtk4_TextBuffer_ConnectUndo(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectRemoveTag(gpointer, GtkTextTag*, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectRedo(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectPasteDone(gpointer, GdkClipboard*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectModifiedChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectMarkSet(gpointer, GtkTextIter*, GtkTextMark*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectMarkDeleted(gpointer, GtkTextMark*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertText(gpointer, GtkTextIter*, gchar*, gint, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertPaintable(gpointer, GtkTextIter*, GdkPaintable*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertChildAnchor(gpointer, GtkTextIter*, GtkTextChildAnchor*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectEndUserAction(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectDeleteRange(gpointer, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectBeginUserAction(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectApplyTag(gpointer, GtkTextTag*, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk4_TextBufferClass_undo(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_remove_tag(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtk4_TextBufferClass_redo(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_paste_done(GtkTextBuffer*, GdkClipboard*);
// extern void _gotk4_gtk4_TextBufferClass_modified_changed(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_mark_set(GtkTextBuffer*, GtkTextIter*, GtkTextMark*);
// extern void _gotk4_gtk4_TextBufferClass_mark_deleted(GtkTextBuffer*, GtkTextMark*);
// extern void _gotk4_gtk4_TextBufferClass_insert_text(GtkTextBuffer*, GtkTextIter*, char*, int);
// extern void _gotk4_gtk4_TextBufferClass_insert_paintable(GtkTextBuffer*, GtkTextIter*, GdkPaintable*);
// extern void _gotk4_gtk4_TextBufferClass_insert_child_anchor(GtkTextBuffer*, GtkTextIter*, GtkTextChildAnchor*);
// extern void _gotk4_gtk4_TextBufferClass_end_user_action(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_delete_range(GtkTextBuffer*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtk4_TextBufferClass_changed(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_begin_user_action(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_apply_tag(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*);
// void _gotk4_gtk4_TextBuffer_virtual_apply_tag(void* fnptr, GtkTextBuffer* arg0, GtkTextTag* arg1, GtkTextIter* arg2, GtkTextIter* arg3) {
//   ((void (*)(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TextBuffer_virtual_begin_user_action(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_changed(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_delete_range(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, GtkTextIter* arg2) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, GtkTextIter*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextBuffer_virtual_end_user_action(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_insert_child_anchor(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, GtkTextChildAnchor* arg2) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, GtkTextChildAnchor*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextBuffer_virtual_insert_paintable(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, GdkPaintable* arg2) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, GdkPaintable*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextBuffer_virtual_insert_text(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, char* arg2, int arg3) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, char*, int))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TextBuffer_virtual_mark_deleted(void* fnptr, GtkTextBuffer* arg0, GtkTextMark* arg1) {
//   ((void (*)(GtkTextBuffer*, GtkTextMark*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_TextBuffer_virtual_mark_set(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, GtkTextMark* arg2) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, GtkTextMark*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextBuffer_virtual_modified_changed(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_paste_done(void* fnptr, GtkTextBuffer* arg0, GdkClipboard* arg1) {
//   ((void (*)(GtkTextBuffer*, GdkClipboard*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_TextBuffer_virtual_redo(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_remove_tag(void* fnptr, GtkTextBuffer* arg0, GtkTextTag* arg1, GtkTextIter* arg2, GtkTextIter* arg3) {
//   ((void (*)(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TextBuffer_virtual_undo(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeTextBuffer = coreglib.Type(C.gtk_text_buffer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTextBuffer, F: marshalTextBuffer},
	})
}

// TextBufferOverrides contains methods that are overridable.
type TextBufferOverrides struct {
	// ApplyTag emits the “apply-tag” signal on buffer.
	//
	// The default handler for the signal applies tag to the given range.
	// start and end do not have to be in order.
	//
	// The function takes the following parameters:
	//
	//   - tag: GtkTextTag.
	//   - start: one bound of range to be tagged.
	//   - end: other bound of range to be tagged.
	//
	ApplyTag func(tag *TextTag, start, end *TextIter)
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation.
	//
	// The operations between gtk_text_buffer_begin_user_action() and
	// gtk_text_buffer_end_user_action() can then be grouped when
	// creating an undo stack. GtkTextBuffer maintains a count of calls to
	// gtk_text_buffer_begin_user_action() that have not been closed with a call
	// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
	// and “end-user-action” signals only for the outermost pair of calls.
	// This allows you to build user actions from other user actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction func()
	Changed         func()
	// The function takes the following parameters:
	//
	//   - start
	//   - end
	//
	DeleteRange func(start, end *TextIter)
	// EndUserAction ends a user-visible operation.
	//
	// Should be paired with a call to gtk.TextBuffer.BeginUserAction().
	// See that function for a full explanation.
	EndUserAction func()
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// iter.
	//
	// The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk.TextBuffer.GetSlice() and gtk.TextBuffer.GetText().
	//
	// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient
	// alternative to this function. The buffer will add a reference to the
	// anchor, so you can unref it after insertion.
	//
	// The function takes the following parameters:
	//
	//   - iter: location to insert the anchor.
	//   - anchor: GtkTextChildAnchor.
	//
	InsertChildAnchor func(iter *TextIter, anchor *TextChildAnchor)
	// InsertPaintable inserts an image into the text buffer at iter.
	//
	// The image will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for paintable, but the “text” variants do not. e.g.
	// see gtk.TextBuffer.GetSlice() and gtk.TextBuffer.GetText().
	//
	// The function takes the following parameters:
	//
	//   - iter: location to insert the paintable.
	//   - paintable: GdkPaintable.
	//
	InsertPaintable func(iter *TextIter, paintable gdk.Paintabler)
	// The function takes the following parameters:
	//
	//   - pos
	//   - newText
	//   - newTextLength
	//
	InsertText func(pos *TextIter, newText string, newTextLength int)
	// The function takes the following parameters:
	//
	MarkDeleted func(mark *TextMark)
	// The function takes the following parameters:
	//
	//   - location
	//   - mark
	//
	MarkSet         func(location *TextIter, mark *TextMark)
	ModifiedChanged func()
	// The function takes the following parameters:
	//
	PasteDone func(clipboard *gdk.Clipboard)
	// Redo redoes the next redoable action on the buffer, if there is one.
	Redo func()
	// RemoveTag emits the “remove-tag” signal.
	//
	// The default handler for the signal removes all occurrences of tag from
	// the given range. start and end don’t have to be in order.
	//
	// The function takes the following parameters:
	//
	//   - tag: GtkTextTag.
	//   - start: one bound of range to be untagged.
	//   - end: other bound of range to be untagged.
	//
	RemoveTag func(tag *TextTag, start, end *TextIter)
	// Undo undoes the last undoable action on the buffer, if there is one.
	Undo func()
}

func defaultTextBufferOverrides(v *TextBuffer) TextBufferOverrides {
	return TextBufferOverrides{
		ApplyTag:          v.applyTag,
		BeginUserAction:   v.beginUserAction,
		Changed:           v.changed,
		DeleteRange:       v.deleteRange,
		EndUserAction:     v.endUserAction,
		InsertChildAnchor: v.insertChildAnchor,
		InsertPaintable:   v.insertPaintable,
		InsertText:        v.insertText,
		MarkDeleted:       v.markDeleted,
		MarkSet:           v.markSet,
		ModifiedChanged:   v.modifiedChanged,
		PasteDone:         v.pasteDone,
		Redo:              v.redo,
		RemoveTag:         v.removeTag,
		Undo:              v.undo,
	}
}

// TextBuffer stores text and attributes for display in a GtkTextView.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextBuffer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TextBuffer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TextBuffer, *TextBufferClass, TextBufferOverrides](
		GTypeTextBuffer,
		initTextBufferClass,
		wrapTextBuffer,
		defaultTextBufferOverrides,
	)
}

func initTextBufferClass(gclass unsafe.Pointer, overrides TextBufferOverrides, classInitFunc func(*TextBufferClass)) {
	pclass := (*C.GtkTextBufferClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTextBuffer))))

	if overrides.ApplyTag != nil {
		pclass.apply_tag = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_apply_tag)
	}

	if overrides.BeginUserAction != nil {
		pclass.begin_user_action = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_begin_user_action)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_changed)
	}

	if overrides.DeleteRange != nil {
		pclass.delete_range = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_delete_range)
	}

	if overrides.EndUserAction != nil {
		pclass.end_user_action = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_end_user_action)
	}

	if overrides.InsertChildAnchor != nil {
		pclass.insert_child_anchor = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_insert_child_anchor)
	}

	if overrides.InsertPaintable != nil {
		pclass.insert_paintable = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_insert_paintable)
	}

	if overrides.InsertText != nil {
		pclass.insert_text = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_insert_text)
	}

	if overrides.MarkDeleted != nil {
		pclass.mark_deleted = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_mark_deleted)
	}

	if overrides.MarkSet != nil {
		pclass.mark_set = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_mark_set)
	}

	if overrides.ModifiedChanged != nil {
		pclass.modified_changed = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_modified_changed)
	}

	if overrides.PasteDone != nil {
		pclass.paste_done = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_paste_done)
	}

	if overrides.Redo != nil {
		pclass.redo = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_redo)
	}

	if overrides.RemoveTag != nil {
		pclass.remove_tag = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_remove_tag)
	}

	if overrides.Undo != nil {
		pclass.undo = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_undo)
	}

	if classInitFunc != nil {
		class := (*TextBufferClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTextBuffer(obj *coreglib.Object) *TextBuffer {
	return &TextBuffer{
		Object: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	return wrapTextBuffer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectApplyTag is emitted to apply a tag to a range of text in a
// GtkTextBuffer.
//
// Applying actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk.TextBuffer.ApplyTag(), gtk.TextBuffer.InsertWithTags(),
// gtk.TextBuffer.InsertRange().
func (buffer *TextBuffer) ConnectApplyTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "apply-tag", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectApplyTag), f)
}

// ConnectBeginUserAction is emitted at the beginning of a single user-visible
// operation on a GtkTextBuffer.
//
// See also: gtk.TextBuffer.BeginUserAction(),
// gtk.TextBuffer.InsertInteractive(), gtk.TextBuffer.InsertRangeInteractive(),
// gtk.TextBuffer.DeleteInteractive(), gtk.TextBuffer.Backspace(),
// gtk.TextBuffer.DeleteSelection().
func (buffer *TextBuffer) ConnectBeginUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "begin-user-action", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectBeginUserAction), f)
}

// ConnectChanged is emitted when the content of a GtkTextBuffer has changed.
func (buffer *TextBuffer) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "changed", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectChanged), f)
}

// ConnectDeleteRange is emitted to delete a range from a GtkTextBuffer.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them). The default
// signal handler revalidates the start and end iters to both point to the
// location where text was deleted. Handlers which run after the default handler
// (see g_signal_connect_after()) do not have access to the deleted text.
//
// See also: gtk.TextBuffer.Delete().
func (buffer *TextBuffer) ConnectDeleteRange(f func(start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "delete-range", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectDeleteRange), f)
}

// ConnectEndUserAction is emitted at the end of a single user-visible operation
// on the GtkTextBuffer.
//
// See also: gtk.TextBuffer.EndUserAction(), gtk.TextBuffer.InsertInteractive(),
// gtk.TextBuffer.InsertRangeInteractive(), gtk.TextBuffer.DeleteInteractive(),
// gtk.TextBuffer.Backspace(), gtk.TextBuffer.DeleteSelection(),
// gtk.TextBuffer.Backspace().
func (buffer *TextBuffer) ConnectEndUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "end-user-action", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectEndUserAction), f)
}

// ConnectInsertChildAnchor is emitted to insert a GtkTextChildAnchor in a
// GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted anchor.
//
// See also: gtk.TextBuffer.InsertChildAnchor().
func (buffer *TextBuffer) ConnectInsertChildAnchor(f func(location *TextIter, anchor *TextChildAnchor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-child-anchor", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertChildAnchor), f)
}

// ConnectInsertPaintable is emitted to insert a GdkPaintable in a
// GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted paintable.
//
// See also: gtk.TextBuffer.InsertPaintable().
func (buffer *TextBuffer) ConnectInsertPaintable(f func(location *TextIter, paintable gdk.Paintabler)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-paintable", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertPaintable), f)
}

// ConnectInsertText is emitted to insert text in a GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to point to the end of the inserted text.
//
// See also: gtk,textbuffer.Insert, gtk.TextBuffer.InsertRange().
func (buffer *TextBuffer) ConnectInsertText(f func(location *TextIter, text string, len int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-text", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertText), f)
}

// ConnectMarkDeleted is emitted as notification after a GtkTextMark is deleted.
//
// See also: gtk.TextBuffer.DeleteMark().
func (buffer *TextBuffer) ConnectMarkDeleted(f func(mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "mark-deleted", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectMarkDeleted), f)
}

// ConnectMarkSet is emitted as notification after a GtkTextMark is set.
//
// See also: gtk.TextBuffer.CreateMark(), gtk.TextBuffer.MoveMark().
func (buffer *TextBuffer) ConnectMarkSet(f func(location *TextIter, mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "mark-set", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectMarkSet), f)
}

// ConnectModifiedChanged is emitted when the modified bit of a GtkTextBuffer
// flips.
//
// See also: gtk.TextBuffer.SetModified().
func (buffer *TextBuffer) ConnectModifiedChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "modified-changed", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectModifiedChanged), f)
}

// ConnectPasteDone is emitted after paste operation has been completed.
//
// This is useful to properly scroll the view to the end of the pasted text.
// See gtk.TextBuffer.PasteClipboard() for more details.
func (buffer *TextBuffer) ConnectPasteDone(f func(clipboard *gdk.Clipboard)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "paste-done", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectPasteDone), f)
}

// ConnectRedo is emitted when a request has been made to redo the previously
// undone operation.
func (buffer *TextBuffer) ConnectRedo(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "redo", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectRedo), f)
}

// ConnectRemoveTag is emitted to remove all occurrences of tag from a range of
// text in a GtkTextBuffer.
//
// Removal actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk.TextBuffer.RemoveTag().
func (buffer *TextBuffer) ConnectRemoveTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "remove-tag", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectRemoveTag), f)
}

// ConnectUndo is emitted when a request has been made to undo the previous
// operation or set of operations that have been grouped together.
func (buffer *TextBuffer) ConnectUndo(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "undo", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectUndo), f)
}

// NewTextBuffer creates a new text buffer.
//
// The function takes the following parameters:
//
//   - table (optional): tag table, or NULL to create a new one.
//
// The function returns the following values:
//
//   - textBuffer: new text buffer.
//
func NewTextBuffer(table *TextTagTable) *TextBuffer {
	var _arg1 *C.GtkTextTagTable // out
	var _cret *C.GtkTextBuffer   // in

	if table != nil {
		_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	}

	_cret = C.gtk_text_buffer_new(_arg1)
	runtime.KeepAlive(table)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textBuffer
}

// AddMark adds the mark at position where.
//
// The mark must not be added to another buffer, and if its name is not NULL
// then there must not be another mark in the buffer with the same name.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
//
// The function takes the following parameters:
//
//   - mark to add.
//   - where: location to place mark.
//
func (buffer *TextBuffer) AddMark(mark *TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// AddSelectionClipboard adds clipboard to the list of clipboards in which the
// selection contents of buffer are available.
//
// In most cases, clipboard will be the GdkClipboard returned by
// gtk.Widget.GetPrimaryClipboard() for a view of buffer.
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard.
//
func (buffer *TextBuffer) AddSelectionClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// ApplyTag emits the “apply-tag” signal on buffer.
//
// The default handler for the signal applies tag to the given range. start and
// end do not have to be in order.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//   - start: one bound of range to be tagged.
//   - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) ApplyTag(tag *TextTag, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ApplyTagByName emits the “apply-tag” signal on buffer.
//
// Calls gtk.TextTagTable.Lookup() on the buffer’s tag table to get a
// GtkTextTag, then calls gtk.TextBuffer.ApplyTag().
//
// The function takes the following parameters:
//
//   - name of a named GtkTextTag.
//   - start: one bound of range to be tagged.
//   - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) ApplyTagByName(name string, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by iter.
//
// In the normal case a single character will be deleted, but when combining
// accents are involved, more than one character can be deleted, and when
// precomposed character and accent combinations are involved, less than one
// character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the iter will be re-initialized to
// point to the location where text was deleted.
//
// The function takes the following parameters:
//
//   - iter: position in buffer.
//   - interactive: whether the deletion is caused by user interaction.
//   - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//   - ok: TRUE if the buffer was modified.
//
func (buffer *TextBuffer) Backspace(iter *TextIter, interactive, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 C.gboolean       // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if interactive {
		_arg2 = C.TRUE
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BeginIrreversibleAction denotes the beginning of an action that may not be
// undone.
//
// This will cause any previous operations in the undo/redo queue to be cleared.
//
// This should be paired with a call to gtk.TextBuffer.EndIrreversibleAction()
// after the irreversible action has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer *TextBuffer) BeginIrreversibleAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_begin_irreversible_action(_arg0)
	runtime.KeepAlive(buffer)
}

// BeginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when
// creating an undo stack. GtkTextBuffer maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with a call
// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action” and
// “end-user-action” signals only for the outermost pair of calls. This allows
// you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user action
// around the buffer operations they perform, so there's no need to add extra
// calls if you user action consists solely of a single call to one of those
// functions.
func (buffer *TextBuffer) BeginUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_begin_user_action(_arg0)
	runtime.KeepAlive(buffer)
}

// CopyClipboard copies the currently-selected text to a clipboard.
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard object to copy to.
//
func (buffer *TextBuffer) CopyClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// CreateChildAnchor creates and inserts a child anchor.
//
// This is a convenience function which simply creates a child anchor
// with gtk.TextChildAnchor.New and inserts it into the buffer with
// gtk.TextBuffer.InsertChildAnchor().
//
// The new anchor is owned by the buffer; no reference count is returned to the
// caller of this function.
//
// The function takes the following parameters:
//
//   - iter: location in the buffer.
//
// The function returns the following values:
//
//   - textChildAnchor: created child anchor.
//
func (buffer *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// CreateMark creates a mark at position where.
//
// If mark_name is NULL, the mark is anonymous; otherwise, the mark can be
// retrieved by name using gtk.TextBuffer.GetMark(). If a mark has left gravity,
// and text is inserted at the mark’s current location, the mark will be
// moved to the left of the newly-inserted text. If the mark has right gravity
// (left_gravity = FALSE), the mark will end up on the right of newly-inserted
// text. The standard left-to-right cursor is a mark with right gravity (when
// you type, the cursor stays on the right side of the text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
//
// The function takes the following parameters:
//
//   - markName (optional): name for mark, or NULL.
//   - where: location to place mark.
//   - leftGravity: whether the mark has left gravity.
//
// The function returns the following values:
//
//   - textMark: new TextMark object.
//
func (buffer *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if markName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(markName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))
	if leftGravity {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(markName)
	runtime.KeepAlive(where)
	runtime.KeepAlive(leftGravity)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard object to cut to.
//   - defaultEditable: default editability of the buffer.
//
func (buffer *TextBuffer) CutClipboard(clipboard *gdk.Clipboard, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if defaultEditable {
		_arg2 = C.TRUE
	}

	C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(defaultEditable)
}

// Delete deletes text between start and end.
//
// The order of start and end is not actually relevant; gtk_text_buffer_delete()
// will reorder them.
//
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified, all
// outstanding iterators become invalid after calling this function; however,
// the start and end will be re-initialized to point to the location where text
// was deleted.
//
// The function takes the following parameters:
//
//   - start: position in buffer.
//   - end: another position in buffer.
//
func (buffer *TextBuffer) Delete(start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// DeleteInteractive deletes all editable text in the given range.
//
// Calls gtk.TextBuffer.Delete() for each editable sub-range of [start,end).
// start and end are revalidated to point to the location of the last deleted
// range, or left untouched if no text was deleted.
//
// The function takes the following parameters:
//
//   - startIter: start of range to delete.
//   - endIter: end of range.
//   - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//   - ok: whether some text was actually deleted.
//
func (buffer *TextBuffer) DeleteInteractive(startIter, endIter *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(startIter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(endIter)))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(startIter)
	runtime.KeepAlive(endIter)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeleteMark deletes mark, so that it’s no longer located anywhere in the
// buffer.
//
// Removes the reference the buffer holds to the mark, so if you haven’t called
// g_object_ref() on the mark, it will be freed. Even if the mark isn’t freed,
// most operations on mark become invalid, until it gets added to a buffer again
// with gtk.TextBuffer.AddMark(). Use gtk.TextMark.GetDeleted() to find out if a
// mark has been removed from its buffer.
//
// The gtk.TextBuffer::mark-deleted signal will be emitted as notification after
// the mark is deleted.
//
// The function takes the following parameters:
//
//   - mark: GtkTextMark in buffer.
//
func (buffer *TextBuffer) DeleteMark(mark *TextMark) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C.gtk_text_buffer_delete_mark(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
}

// DeleteMarkByName deletes the mark named name; the mark must exist.
//
// See gtk.TextBuffer.DeleteMark() for details.
//
// The function takes the following parameters:
//
//   - name of a mark in buffer.
//
func (buffer *TextBuffer) DeleteMarkByName(name string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
}

// DeleteSelection deletes the range between the “insert” and “selection_bound”
// marks, that is, the currently-selected text.
//
// If interactive is TRUE, the editability of the selection will be considered
// (users can’t delete uneditable text).
//
// The function takes the following parameters:
//
//   - interactive: whether the deletion is caused by user interaction.
//   - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//   - ok: whether there was a non-empty selection to delete.
//
func (buffer *TextBuffer) DeleteSelection(interactive, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out
	var _arg2 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if interactive {
		_arg1 = C.TRUE
	}
	if defaultEditable {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndIrreversibleAction denotes the end of an action that may not be undone.
//
// This will cause any previous operations in the undo/redo queue to be cleared.
//
// This should be called after completing modifications to the text buffer after
// gtk_text_buffer_begin_irreversible_action() was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer *TextBuffer) EndIrreversibleAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_end_irreversible_action(_arg0)
	runtime.KeepAlive(buffer)
}

// EndUserAction ends a user-visible operation.
//
// Should be paired with a call to gtk.TextBuffer.BeginUserAction(). See that
// function for a full explanation.
func (buffer *TextBuffer) EndUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_end_user_action(_arg0)
	runtime.KeepAlive(buffer)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the entire
// buffer lies within the range [start,end).
//
// The function returns the following values:
//
//   - start: iterator to initialize with first position in the buffer.
//   - end: iterator to initialize with the end iterator.
//
func (buffer *TextBuffer) Bounds() (start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_get_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _start, _end
}

// CanRedo gets whether there is a redoable action in the history.
//
// The function returns the following values:
//
//   - ok: TRUE if there is an redoable action.
//
func (buffer *TextBuffer) CanRedo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_can_redo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanUndo gets whether there is an undoable action in the history.
//
// The function returns the following values:
//
//   - ok: TRUE if there is an undoable action.
//
func (buffer *TextBuffer) CanUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_can_undo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CharCount gets the number of characters in the buffer.
//
// Note that characters and bytes are not the same, you can’t e.g. expect the
// contents of the buffer in string form to be this many bytes long.
//
// The character count is cached, so this function is very fast.
//
// The function returns the following values:
//
//   - gint: number of characters in the buffer.
//
func (buffer *TextBuffer) CharCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_char_count(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// EnableUndo gets whether the buffer is saving modifications to the buffer to
// allow for undo and redo actions.
//
// See gtk.TextBuffer.BeginIrreversibleAction() and
// gtk.TextBuffer.EndIrreversibleAction() to create changes to the buffer that
// cannot be undone.
//
// The function returns the following values:
//
func (buffer *TextBuffer) EnableUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_enable_undo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndIter initializes iter with the “end iterator,” one past the last valid
// character in the text buffer.
//
// If dereferenced with gtk.TextIter.GetChar(), the end iterator has a character
// value of 0. The entire buffer lies in the range from the first position in
// the buffer (call gtk.TextBuffer.GetStartIter() to get character position 0)
// to the end iterator.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//
func (buffer *TextBuffer) EndIter() *TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_get_end_iter(_arg0, &_arg1)
	runtime.KeepAlive(buffer)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// HasSelection indicates whether the buffer has some text currently selected.
//
// The function returns the following values:
//
//   - ok: TRUE if the there is text selected.
//
func (buffer *TextBuffer) HasSelection() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_has_selection(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetInsert returns the mark that represents the cursor (insertion point).
//
// Equivalent to calling gtk.TextBuffer.GetMark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
//
// The function returns the following values:
//
//   - textMark: insertion point mark.
//
func (buffer *TextBuffer) GetInsert() *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_insert(_arg0)
	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// IterAtChildAnchor obtains the location of anchor within buffer.
//
// The function takes the following parameters:
//
//   - anchor: child anchor that appears in buffer.
//
// The function returns the following values:
//
//   - iter: iterator to be initialized.
//
func (buffer *TextBuffer) IterAtChildAnchor(anchor *TextChildAnchor) *TextIter {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 C.GtkTextIter         // in
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(anchor)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtLine initializes iter to the start of the given line.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned.
//
// The function takes the following parameters:
//
//   - lineNumber: line number counting from 0.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//   - ok: whether the exact position has been found.
//
func (buffer *TextBuffer) IterAtLine(lineNumber int) (*TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = C.int(lineNumber)

	_cret = C.gtk_text_buffer_get_iter_at_line(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineIndex obtains an iterator pointing to byte_index within the given
// line.
//
// byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned. And if byte_index is off the end of the line,
// the iterator at the end of the line is returned.
//
// The function takes the following parameters:
//
//   - lineNumber: line number counting from 0.
//   - byteIndex: byte index from start of line.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//   - ok: whether the exact position has been found.
//
func (buffer *TextBuffer) IterAtLineIndex(lineNumber, byteIndex int) (*TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(byteIndex)

	_cret = C.gtk_text_buffer_get_iter_at_line_index(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(byteIndex)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineOffset obtains an iterator pointing to char_offset within the given
// line.
//
// Note characters, not bytes; UTF-8 may encode one character as multiple bytes.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned. And if char_offset is off the end of the line,
// the iterator at the end of the line is returned.
//
// The function takes the following parameters:
//
//   - lineNumber: line number counting from 0.
//   - charOffset: char offset from start of line.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//   - ok: whether the exact position has been found.
//
func (buffer *TextBuffer) IterAtLineOffset(lineNumber, charOffset int) (*TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(charOffset)

	_cret = C.gtk_text_buffer_get_iter_at_line_offset(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(charOffset)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtMark initializes iter with the current position of mark.
//
// The function takes the following parameters:
//
//   - mark: GtkTextMark in buffer.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//
func (buffer *TextBuffer) IterAtMark(mark *TextMark) *TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C.gtk_text_buffer_get_iter_at_mark(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtOffset initializes iter to a position char_offset chars from the start
// of the entire buffer.
//
// If char_offset is -1 or greater than the number of characters in the buffer,
// iter is initialized to the end iterator, the iterator one past the last valid
// character in the buffer.
//
// The function takes the following parameters:
//
//   - charOffset: char offset from start of buffer, counting from 0, or -1.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//
func (buffer *TextBuffer) IterAtOffset(charOffset int) *TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = C.int(charOffset)

	C.gtk_text_buffer_get_iter_at_offset(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(charOffset)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// LineCount obtains the number of lines in the buffer.
//
// This value is cached, so the function is very fast.
//
// The function returns the following values:
//
//   - gint: number of lines in the buffer.
//
func (buffer *TextBuffer) LineCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_line_count(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Mark returns the mark named name in buffer buffer, or NULL if no such mark
// exists in the buffer.
//
// The function takes the following parameters:
//
//   - name: mark name.
//
// The function returns the following values:
//
//   - textMark (optional) or NULL.
//
func (buffer *TextBuffer) Mark(name string) *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _textMark *TextMark // out

	if _cret != nil {
		_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _textMark
}

// MaxUndoLevels gets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
//
// The function returns the following values:
//
func (buffer *TextBuffer) MaxUndoLevels() uint {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_max_undo_levels(_arg0)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Modified indicates whether the buffer has been modified since the last call
// to gtk.TextBuffer.SetModified() set the modification flag to FALSE.
//
// Used for example to enable a “save” function in a text editor.
//
// The function returns the following values:
//
//   - ok: TRUE if the buffer has been modified.
//
func (buffer *TextBuffer) Modified() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_modified(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionBound returns the mark that represents the selection bound.
//
// Equivalent to calling gtk.TextBuffer.GetMark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and
// “insert” are in the same place, then there is no current selection.
// gtk.TextBuffer.GetSelectionBounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a selection
// and what its bounds are.
//
// The function returns the following values:
//
//   - textMark: selection bound mark.
//
func (buffer *TextBuffer) SelectionBound() *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_selection_bound(_arg0)
	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// SelectionBounds returns TRUE if some text is selected; places the bounds of
// the selection in start and end.
//
// If the selection has length 0, then start and end are filled in with the same
// value. start and end will be in ascending order. If start and end are NULL,
// then they are not filled in, but the return value still indicates whether
// text is selected.
//
// The function returns the following values:
//
//   - start: iterator to initialize with selection start.
//   - end: iterator to initialize with selection end.
//   - ok: whether the selection has nonzero length.
//
func (buffer *TextBuffer) SelectionBounds() (start, end *TextIter, ok bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _start *TextIter // out
	var _end *TextIter   // out
	var _ok bool         // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// SelectionContent: get a content provider for this buffer.
//
// It can be used to make the content of buffer available in a GdkClipboard,
// see gdk.Clipboard.SetContent().
//
// The function returns the following values:
//
//   - contentProvider: new GdkContentProvider.
//
func (buffer *TextBuffer) SelectionContent() *gdk.ContentProvider {
	var _arg0 *C.GtkTextBuffer      // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_selection_content(_arg0)
	runtime.KeepAlive(buffer)

	var _contentProvider *gdk.ContentProvider // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_contentProvider = &gdk.ContentProvider{
			Object: obj,
		}
	}

	return _contentProvider
}

// Slice returns the text in the range [start,end).
//
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if include_hidden_chars is FALSE. The returned string includes
// a 0xFFFC character whenever the buffer contains embedded images, so byte
// and character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with gtk.TextBuffer.GetText().
// Note that 0xFFFC can occur in normal text as well, so it is not a reliable
// indicator that a paintable or widget is in the buffer.
//
// The function takes the following parameters:
//
//   - start of a range.
//   - end of a range.
//   - includeHiddenChars: whether to include invisible text.
//
// The function returns the following values:
//
//   - utf8: allocated UTF-8 string.
//
func (buffer *TextBuffer) Slice(start, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// StartIter: initialized iter with the first position in the text buffer.
//
// This is the same as using gtk.TextBuffer.GetIterAtOffset() to get the iter at
// character offset 0.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//
func (buffer *TextBuffer) StartIter() *TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_get_start_iter(_arg0, &_arg1)
	runtime.KeepAlive(buffer)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// TagTable: get the GtkTextTagTable associated with this buffer.
//
// The function returns the following values:
//
//   - textTagTable buffer’s tag table.
//
func (buffer *TextBuffer) TagTable() *TextTagTable {
	var _arg0 *C.GtkTextBuffer   // out
	var _cret *C.GtkTextTagTable // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_tag_table(_arg0)
	runtime.KeepAlive(buffer)

	var _textTagTable *TextTagTable // out

	_textTagTable = wrapTextTagTable(coreglib.Take(unsafe.Pointer(_cret)))

	return _textTagTable
}

// Text returns the text in the range [start,end).
//
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if include_hidden_chars is FALSE. Does not include characters
// representing embedded images, so byte and character indexes into the returned
// string do not correspond to byte and character indexes into the buffer.
// Contrast with gtk.TextBuffer.GetSlice().
//
// The function takes the following parameters:
//
//   - start of a range.
//   - end of a range.
//   - includeHiddenChars: whether to include invisible text.
//
// The function returns the following values:
//
//   - utf8: allocated UTF-8 string.
//
func (buffer *TextBuffer) Text(start, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts len bytes of text at position iter.
//
// If len is -1, text must be nul-terminated and will be inserted in its
// entirety. Emits the “insert-text” signal; insertion actually occurs in
// the default handler for the signal. iter is invalidated when insertion
// occurs (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
//
// The function takes the following parameters:
//
//   - iter: position in the buffer.
//   - text in UTF-8 format.
//
func (buffer *TextBuffer) Insert(iter *TextIter, text string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.int)(len(text))
	_arg2 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
}

// InsertAtCursor inserts text in buffer.
//
// Simply calls gtk.TextBuffer.Insert(), using the current cursor position as
// the insertion point.
//
// The function takes the following parameters:
//
//   - text in UTF-8 format.
//
func (buffer *TextBuffer) InsertAtCursor(text string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at iter.
//
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the “text” variants do not. E.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient alternative
// to this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
//
// The function takes the following parameters:
//
//   - iter: location to insert the anchor.
//   - anchor: GtkTextChildAnchor.
//
func (buffer *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(anchor)
}

// InsertInteractive inserts text in buffer.
//
// Like gtk.TextBuffer.Insert(), but the insertion will not occur if iter is at
// a non-editable location in the buffer. Usually you want to prevent insertions
// at ineditable locations if the insertion results from a user action (is
// interactive).
//
// default_editable indicates the editability of text that doesn't have
// a tag affecting editability applied to it. Typically the result of
// gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//   - iter: position in buffer.
//   - text: some UTF-8 text.
//   - defaultEditable: default editability of buffer.
//
// The function returns the following values:
//
//   - ok: whether text was actually inserted.
//
func (buffer *TextBuffer) InsertInteractive(iter *TextIter, text string, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int
	var _arg4 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.int)(len(text))
	_arg2 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg2))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertInteractiveAtCursor inserts text in buffer.
//
// Calls gtk.TextBuffer.InsertInteractive() at the cursor position.
//
// default_editable indicates the editability of text that doesn't have
// a tag affecting editability applied to it. Typically the result of
// gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//   - text in UTF-8 format.
//   - defaultEditable: default editability of buffer.
//
// The function returns the following values:
//
//   - ok: whether text was actually inserted.
//
func (buffer *TextBuffer) InsertInteractiveAtCursor(text string, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertMarkup inserts the text in markup at position iter.
//
// markup will be inserted in its entirety and must be nul-terminated and valid
// UTF-8. Emits the gtk.TextBuffer::insert-text signal, possibly multiple times;
// insertion actually occurs in the default handler for the signal. iter will
// point to the end of the inserted text on return.
//
// The function takes the following parameters:
//
//   - iter: location to insert the markup.
//   - markup: nul-terminated UTF-8 string containing Pango markup.
//
func (buffer *TextBuffer) InsertMarkup(iter *TextIter, markup string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.int)(len(markup))
	_arg2 = (*C.char)(C.calloc(C.size_t((len(markup) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(markup)), markup)
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(markup)
}

// InsertPaintable inserts an image into the text buffer at iter.
//
// The image will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the “text” variants do not. e.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// The function takes the following parameters:
//
//   - iter: location to insert the paintable.
//   - paintable: GdkPaintable.
//
func (buffer *TextBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintabler) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPaintable  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	C.gtk_text_buffer_insert_paintable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(paintable)
}

// InsertRange copies text, tags, and paintables between start and end and
// inserts the copy at iter.
//
// The order of start and end doesn’t matter.
//
// Used instead of simply getting/inserting text because it preserves images and
// tags. If start and end are in a different buffer from buffer, the two buffers
// must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
//
// The function takes the following parameters:
//
//   - iter: position in buffer.
//   - start: position in a GtkTextBuffer.
//   - end: another position in the same buffer as start.
//
func (buffer *TextBuffer) InsertRange(iter, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// InsertRangeInteractive copies text, tags, and paintables between start and
// end and inserts the copy at iter.
//
// Same as gtk.TextBuffer.InsertRange(), but does nothing if the insertion point
// isn’t editable. The default_editable parameter indicates whether the text is
// editable at iter if no tags enclosing iter affect editability. Typically the
// result of gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//   - iter: position in buffer.
//   - start: position in a GtkTextBuffer.
//   - end: another position in the same buffer as start.
//   - defaultEditable: default editability of the buffer.
//
// The function returns the following values:
//
//   - ok: whether an insertion was possible at iter.
//
func (buffer *TextBuffer) InsertRangeInteractive(iter, start, end *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMark moves mark to the new location where.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the move.
//
// The function takes the following parameters:
//
//   - mark: GtkTextMark.
//   - where: new location for mark in buffer.
//
func (buffer *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// MoveMarkByName moves the mark named name (which must exist) to location
// where.
//
// See gtk.TextBuffer.MoveMark() for details.
//
// The function takes the following parameters:
//
//   - name of a mark.
//   - where: new location for mark.
//
func (buffer *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(where)
}

// PasteClipboard pastes the contents of a clipboard.
//
// If override_location is NULL, the pasted text will be inserted at the cursor
// position, or the buffer selection will be replaced if the selection is
// non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard to paste from.
//   - overrideLocation (optional): location to insert pasted text, or NULL.
//   - defaultEditable: whether the buffer is editable by default.
//
func (buffer *TextBuffer) PasteClipboard(clipboard *gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if overrideLocation != nil {
		_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(overrideLocation)))
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(overrideLocation)
	runtime.KeepAlive(defaultEditable)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them to the same place in two steps with
// gtk.TextBuffer.MoveMark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
//
// The function takes the following parameters:
//
//   - where to put the cursor.
//
func (buffer *TextBuffer) PlaceCursor(where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_place_cursor(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(where)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (buffer *TextBuffer) Redo() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_redo(_arg0)
	runtime.KeepAlive(buffer)
}

// RemoveAllTags removes all tags in the range between start and end.
//
// Be careful with this function; it could remove tags added in code unrelated
// to the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that add
// tags.
//
// The function takes the following parameters:
//
//   - start: one bound of range to be untagged.
//   - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveAllTags(start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveSelectionClipboard removes a GdkClipboard added with
// gtk_text_buffer_add_selection_clipboard().
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard added to buffer by
//     gtk.TextBuffer.AddSelectionClipboard().
//
func (buffer *TextBuffer) RemoveSelectionClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// RemoveTag emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences of tag from the
// given range. start and end don’t have to be in order.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//   - start: one bound of range to be untagged.
//   - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveTag(tag *TextTag, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveTagByName emits the “remove-tag” signal.
//
// Calls gtk.TextTagTable.Lookup() on the buffer’s tag table to get a
// GtkTextTag, then calls gtk.TextBuffer.RemoveTag().
//
// The function takes the following parameters:
//
//   - name of a GtkTextTag.
//   - start: one bound of range to be untagged.
//   - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveTagByName(name string, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them in two steps with gtk.TextBuffer.MoveMark(), you will
// temporarily select a region in between their old and new locations, which
// can be pretty inefficient since the temporarily-selected region will force
// stuff to be recalculated. This function moves them as a unit, which can be
// optimized.
//
// The function takes the following parameters:
//
//   - ins: where to put the “insert” mark.
//   - bound: where to put the “selection_bound” mark.
//
func (buffer *TextBuffer) SelectRange(ins, bound *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(ins)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(bound)))

	C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ins)
	runtime.KeepAlive(bound)
}

// SetEnableUndo sets whether or not to enable undoable actions in the text
// buffer.
//
// If enabled, the user will be able to undo the last number of actions up to
// gtk.TextBuffer.GetMaxUndoLevels().
//
// See gtk.TextBuffer.BeginIrreversibleAction() and
// gtk.TextBuffer.EndIrreversibleAction() to create changes to the buffer that
// cannot be undone.
//
// The function takes the following parameters:
//
//   - enableUndo: TRUE to enable undo.
//
func (buffer *TextBuffer) SetEnableUndo(enableUndo bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if enableUndo {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_enable_undo(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(enableUndo)
}

// SetMaxUndoLevels sets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
//
// The function takes the following parameters:
//
//   - maxUndoLevels: maximum number of undo actions to perform.
//
func (buffer *TextBuffer) SetMaxUndoLevels(maxUndoLevels uint) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(maxUndoLevels)

	C.gtk_text_buffer_set_max_undo_levels(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(maxUndoLevels)
}

// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved.
//
// Whenever the buffer is saved to disk, call gtk_text_buffer_set_modified
// (buffer, FALSE). When the buffer is modified, it will automatically toggled
// on the modified bit again. When the modified bit flips, the buffer emits the
// gtk.TextBuffer::modified-changed signal.
//
// The function takes the following parameters:
//
//   - setting: modification flag setting.
//
func (buffer *TextBuffer) SetModified(setting bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_modified(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(setting)
}

// SetText deletes current contents of buffer, and inserts text instead.
//
// If len is -1, text must be nul-terminated. text must be valid UTF-8.
//
// The function takes the following parameters:
//
//   - text: UTF-8 text to insert.
//
func (buffer *TextBuffer) SetText(text string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (buffer *TextBuffer) Undo() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_undo(_arg0)
	runtime.KeepAlive(buffer)
}

// applyTag emits the “apply-tag” signal on buffer.
//
// The default handler for the signal applies tag to the given range. start and
// end do not have to be in order.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//   - start: one bound of range to be tagged.
//   - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) applyTag(tag *TextTag, start, end *TextIter) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.apply_tag

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C._gotk4_gtk4_TextBuffer_virtual_apply_tag(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// beginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when
// creating an undo stack. GtkTextBuffer maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with a call
// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action” and
// “end-user-action” signals only for the outermost pair of calls. This allows
// you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user action
// around the buffer operations they perform, so there's no need to add extra
// calls if you user action consists solely of a single call to one of those
// functions.
func (buffer *TextBuffer) beginUserAction() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.begin_user_action

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_begin_user_action(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

func (buffer *TextBuffer) changed() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.changed

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// The function takes the following parameters:
//
//   - start
//   - end
//
func (buffer *TextBuffer) deleteRange(start, end *TextIter) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.delete_range

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C._gotk4_gtk4_TextBuffer_virtual_delete_range(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// endUserAction ends a user-visible operation.
//
// Should be paired with a call to gtk.TextBuffer.BeginUserAction(). See that
// function for a full explanation.
func (buffer *TextBuffer) endUserAction() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.end_user_action

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_end_user_action(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// insertChildAnchor inserts a child widget anchor into the text buffer at iter.
//
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the “text” variants do not. E.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient alternative
// to this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
//
// The function takes the following parameters:
//
//   - iter: location to insert the anchor.
//   - anchor: GtkTextChildAnchor.
//
func (buffer *TextBuffer) insertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.insert_child_anchor

	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_insert_child_anchor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(anchor)
}

// insertPaintable inserts an image into the text buffer at iter.
//
// The image will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the “text” variants do not. e.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// The function takes the following parameters:
//
//   - iter: location to insert the paintable.
//   - paintable: GdkPaintable.
//
func (buffer *TextBuffer) insertPaintable(iter *TextIter, paintable gdk.Paintabler) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.insert_paintable

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPaintable  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_insert_paintable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(paintable)
}

// The function takes the following parameters:
//
//   - pos
//   - newText
//   - newTextLength
//
func (buffer *TextBuffer) insertText(pos *TextIter, newText string, newTextLength int) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.insert_text

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(pos)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(newText)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(newTextLength)

	C._gotk4_gtk4_TextBuffer_virtual_insert_text(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(newText)
	runtime.KeepAlive(newTextLength)
}

// The function takes the following parameters:
//
func (buffer *TextBuffer) markDeleted(mark *TextMark) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.mark_deleted

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_mark_deleted(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
}

// The function takes the following parameters:
//
//   - location
//   - mark
//
func (buffer *TextBuffer) markSet(location *TextIter, mark *TextMark) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.mark_set

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(location)))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_mark_set(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(location)
	runtime.KeepAlive(mark)
}

func (buffer *TextBuffer) modifiedChanged() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.modified_changed

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_modified_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// The function takes the following parameters:
//
func (buffer *TextBuffer) pasteDone(clipboard *gdk.Clipboard) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.paste_done

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_paste_done(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (buffer *TextBuffer) redo() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.redo

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_redo(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// removeTag emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences of tag from the
// given range. start and end don’t have to be in order.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//   - start: one bound of range to be untagged.
//   - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) removeTag(tag *TextTag, start, end *TextIter) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.remove_tag

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C._gotk4_gtk4_TextBuffer_virtual_remove_tag(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (buffer *TextBuffer) undo() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.undo

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_undo(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// TextBufferClass class structure for TextBuffer.
//
// An instance of this type is always passed by reference.
type TextBufferClass struct {
	*textBufferClass
}

// textBufferClass is the struct that's finalized.
type textBufferClass struct {
	native *C.GtkTextBufferClass
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
// extern void callbackDelete(gpointer);
// gboolean _gotk4_gtk4_TreeViewColumnDropFunc(GtkTreeView*, GtkTreeViewColumn*, GtkTreeViewColumn*, GtkTreeViewColumn*, gpointer);
// gboolean _gotk4_gtk4_TreeViewRowSeparatorFunc(GtkTreeModel*, GtkTreeIter*, gpointer);
// gboolean _gotk4_gtk4_TreeViewSearchEqualFunc(GtkTreeModel*, int, char*, GtkTreeIter*, gpointer);
// void _gotk4_gtk4_TreeCellDataFunc(GtkTreeViewColumn*, GtkCellRenderer*, GtkTreeModel*, GtkTreeIter*, gpointer);
// void _gotk4_gtk4_TreeViewMappingFunc(GtkTreeView*, GtkTreePath*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
		{T: externglib.Type(C.gtk_tree_view_get_type()), F: marshalTreeViewer},
	})
}

// TreeViewDropPosition: enum for determining where a dropped row goes.
type TreeViewDropPosition int

const (
	// TreeViewDropBefore: dropped row is inserted before
	TreeViewDropBefore TreeViewDropPosition = iota
	// TreeViewDropAfter: dropped row is inserted after
	TreeViewDropAfter
	// TreeViewDropIntoOrBefore: dropped row becomes a child or is inserted
	// before
	TreeViewDropIntoOrBefore
	// TreeViewDropIntoOrAfter: dropped row becomes a child or is inserted after
	TreeViewDropIntoOrAfter
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for TreeViewDropPosition.
func (t TreeViewDropPosition) String() string {
	switch t {
	case TreeViewDropBefore:
		return "Before"
	case TreeViewDropAfter:
		return "After"
	case TreeViewDropIntoOrBefore:
		return "IntoOrBefore"
	case TreeViewDropIntoOrAfter:
		return "IntoOrAfter"
	default:
		return fmt.Sprintf("TreeViewDropPosition(%d)", t)
	}
}

// TreeViewColumnDropFunc: function type for determining whether column can be
// dropped in a particular spot (as determined by prev_column and next_column).
// In left to right locales, prev_column is on the left of the potential drop
// spot, and next_column is on the right. In right to left mode, this is
// reversed. This function should return TRUE if the spot is a valid drop spot.
// Please note that returning TRUE does not actually indicate that the column
// drop was made, but is meant only to indicate a possible drop spot to the
// user.
type TreeViewColumnDropFunc func(treeView *TreeView, column *TreeViewColumn, prevColumn *TreeViewColumn, nextColumn *TreeViewColumn) (ok bool)

//export _gotk4_gtk4_TreeViewColumnDropFunc
func _gotk4_gtk4_TreeViewColumnDropFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreeViewColumn, arg2 *C.GtkTreeViewColumn, arg3 *C.GtkTreeViewColumn, arg4 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView *TreeView         // out
	var column *TreeViewColumn     // out
	var prevColumn *TreeViewColumn // out
	var nextColumn *TreeViewColumn // out

	treeView = wrapTreeView(externglib.Take(unsafe.Pointer(arg0)))
	column = wrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg1)))
	prevColumn = wrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg2)))
	nextColumn = wrapTreeViewColumn(externglib.Take(unsafe.Pointer(arg3)))

	fn := v.(TreeViewColumnDropFunc)
	ok := fn(treeView, column, prevColumn, nextColumn)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TreeViewMappingFunc: function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(treeView *TreeView, path *TreePath)

//export _gotk4_gtk4_TreeViewMappingFunc
func _gotk4_gtk4_TreeViewMappingFunc(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 C.gpointer) {
	v := gbox.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var treeView *TreeView // out
	var path *TreePath     // out

	treeView = wrapTreeView(externglib.Take(unsafe.Pointer(arg0)))
	path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	fn := v.(TreeViewMappingFunc)
	fn(treeView, path)
}

// TreeViewRowSeparatorFunc: function type for determining whether the row
// pointed to by iter should be rendered as a separator. A common way to
// implement this is to have a boolean column in the model, whose values the
// TreeViewRowSeparatorFunc returns.
type TreeViewRowSeparatorFunc func(model TreeModeller, iter *TreeIter) (ok bool)

//export _gotk4_gtk4_TreeViewRowSeparatorFunc
func _gotk4_gtk4_TreeViewRowSeparatorFunc(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg2))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModeller // out
	var iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg0)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(TreeModeller)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gtk.TreeModeller")
		}
		model = rv
	}
	iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	fn := v.(TreeViewRowSeparatorFunc)
	ok := fn(model, iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TreeViewSearchEqualFunc: function used for checking whether a row in model
// matches a search key string entered by the user. Note the return value is
// reversed from what you would normally expect, though it has some similarity
// to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(model TreeModeller, column int, key string, iter *TreeIter) (ok bool)

//export _gotk4_gtk4_TreeViewSearchEqualFunc
func _gotk4_gtk4_TreeViewSearchEqualFunc(arg0 *C.GtkTreeModel, arg1 C.int, arg2 *C.char, arg3 *C.GtkTreeIter, arg4 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg4))
	if v == nil {
		panic(`callback not found`)
	}

	var model TreeModeller // out
	var column int         // out
	var key string         // out
	var iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg0)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(TreeModeller)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gtk.TreeModeller")
		}
		model = rv
	}
	column = int(arg1)
	key = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	fn := v.(TreeViewSearchEqualFunc)
	ok := fn(model, column, key, iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TreeViewOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TreeViewOverrider interface {
	ColumnsChanged()
	CursorChanged()
	ExpandCollapseCursorRow(logical bool, expand bool, openAll bool) bool
	MoveCursor(step MovementStep, count int, extend bool, modify bool) bool
	// RowActivated activates the cell determined by path and column.
	RowActivated(path *TreePath, column *TreeViewColumn)
	RowCollapsed(iter *TreeIter, path *TreePath)
	RowExpanded(iter *TreeIter, path *TreePath)
	SelectAll() bool
	SelectCursorParent() bool
	SelectCursorRow(startEditing bool) bool
	StartInteractiveSearch() bool
	TestCollapseRow(iter *TreeIter, path *TreePath) bool
	TestExpandRow(iter *TreeIter, path *TreePath) bool
	ToggleCursorRow() bool
	UnselectAll() bool
}

// TreeView: widget for displaying both trees and lists
//
// Widget that displays any object that implements the gtk.TreeModel interface.
//
// Please refer to the tree widget conceptual overview
// (section-tree-widget.html) for an overview of all the objects and data types
// related to the tree widget and how they work together.
//
//
// Coordinate systems in GtkTreeView API
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ! (tree-view-coordinates.png)
//
// - Widget coordinates: Coordinates relative to the widget (usually
// widget->window).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk.TreeView.ConvertWidgetToBinWindowCoords() (and vice
// versa), for the latter gtk.TreeView.ConvertBinWindowToTreeCoords() (and vice
// versa).
//
//
// GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// gtk.TreeViewColumn objects as <child> elements and exposes the internal
// gtk.TreeSelection in UI definitions.
//
// An example of a UI definition fragment with GtkTreeView:
//
//    <object class="GtkTreeView" id="treeview">
//      <property name="model">liststore1</property>
//      <child>
//        <object class="GtkTreeViewColumn" id="test-column">
//          <property name="title">Test</property>
//          <child>
//            <object class="GtkCellRendererText" id="test-renderer"/>
//            <attributes>
//              <attribute name="text">1</attribute>
//            </attributes>
//          </child>
//        </object>
//      </child>
//      <child internal-child="selection">
//        <object class="GtkTreeSelection" id="selection">
//          <signal name="changed" handler="on_treeview_selection_changed"/>
//        </object>
//      </child>
//    </object>
//
//
// CSS nodes
//
//    treeview.view
//    ├── header
//    │   ├── button
//    │   │   ╰── [sort-indicator]
//    ┊   ┊
//    │   ╰── button
//    │       ╰── [sort-indicator]
//    │
//    ├── [rubberband]
//    ╰── [dndtarget]
//
//
// GtkTreeView has a main CSS node with name treeview and style class .view. It
// has a subnode with name header, which is the parent for all the column header
// widgets' CSS nodes.
//
// Each column header consists of a button, which among other content, has a
// child with name sort-indicator, which carries the .ascending or .descending
// style classes when the column header should show a sort indicator. The CSS is
// expected to provide a suitable image using the -gtk-icon-source property.
//
// For rubberband selection, a subnode with name rubberband is used.
//
// For the drop target location during DND, a subnode with name dndtarget is
// used.
type TreeView struct {
	Widget

	Scrollable
	*externglib.Object
}

func wrapTreeView(obj *externglib.Object) *TreeView {
	return &TreeView{
		Widget: Widget{
			InitiallyUnowned: externglib.InitiallyUnowned{
				Object: obj,
			},
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
			Object: obj,
		},
		Scrollable: Scrollable{
			Object: obj,
		},
		Object: obj,
	}
}

func marshalTreeViewer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTreeView(obj), nil
}

// NewTreeView creates a new TreeView widget.
func NewTreeView() *TreeView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_tree_view_new()

	var _treeView *TreeView // out

	_treeView = wrapTreeView(externglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// NewTreeViewWithModel creates a new TreeView widget with the model initialized
// to model.
func NewTreeViewWithModel(model TreeModeller) *TreeView {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

	_cret = C.gtk_tree_view_new_with_model(_arg1)
	runtime.KeepAlive(model)

	var _treeView *TreeView // out

	_treeView = wrapTreeView(externglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// AppendColumn appends column to the list of columns. If tree_view has
// “fixed_height” mode enabled, then column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
func (treeView *TreeView) AppendColumn(column *TreeViewColumn) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	_cret = C.gtk_tree_view_append_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CollapseAll: recursively collapses all visible, expanded nodes in tree_view.
func (treeView *TreeView) CollapseAll() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	C.gtk_tree_view_collapse_all(_arg0)
	runtime.KeepAlive(treeView)
}

// CollapseRow collapses a row (hides its child rows, if they exist).
func (treeView *TreeView) CollapseRow(path *TreePath) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_view_collapse_row(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColumnsAutosize resizes all columns to their optimal width. Only works after
// the treeview has been realized.
func (treeView *TreeView) ColumnsAutosize() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	C.gtk_tree_view_columns_autosize(_arg0)
	runtime.KeepAlive(treeView)
}

// ConvertBinWindowToTreeCoords converts bin_window coordinates to coordinates
// for the tree (the full scrollable area of the tree).
func (treeView *TreeView) ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(bx)
	_arg2 = C.int(by)

	C.gtk_tree_view_convert_bin_window_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(bx)
	runtime.KeepAlive(by)

	var _tx int // out
	var _ty int // out

	_tx = int(_arg3)
	_ty = int(_arg4)

	return _tx, _ty
}

// ConvertBinWindowToWidgetCoords converts bin_window coordinates to widget
// relative coordinates.
func (treeView *TreeView) ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(bx)
	_arg2 = C.int(by)

	C.gtk_tree_view_convert_bin_window_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(bx)
	runtime.KeepAlive(by)

	var _wx int // out
	var _wy int // out

	_wx = int(_arg3)
	_wy = int(_arg4)

	return _wx, _wy
}

// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to bin_window coordinates.
func (treeView *TreeView) ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(tx)
	_arg2 = C.int(ty)

	C.gtk_tree_view_convert_tree_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tx)
	runtime.KeepAlive(ty)

	var _bx int // out
	var _by int // out

	_bx = int(_arg3)
	_by = int(_arg4)

	return _bx, _by
}

// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to widget coordinates.
func (treeView *TreeView) ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(tx)
	_arg2 = C.int(ty)

	C.gtk_tree_view_convert_tree_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tx)
	runtime.KeepAlive(ty)

	var _wx int // out
	var _wy int // out

	_wx = int(_arg3)
	_wy = int(_arg4)

	return _wx, _wy
}

// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates for
// the bin_window.
func (treeView *TreeView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(wx)
	_arg2 = C.int(wy)

	C.gtk_tree_view_convert_widget_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(wx)
	runtime.KeepAlive(wy)

	var _bx int // out
	var _by int // out

	_bx = int(_arg3)
	_by = int(_arg4)

	return _bx, _by
}

// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for the
// tree (the full scrollable area of the tree).
func (treeView *TreeView) ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(wx)
	_arg2 = C.int(wy)

	C.gtk_tree_view_convert_widget_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(wx)
	runtime.KeepAlive(wy)

	var _tx int // out
	var _ty int // out

	_tx = int(_arg3)
	_ty = int(_arg4)

	return _tx, _ty
}

// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
// path. This image is used for a drag icon.
func (treeView *TreeView) CreateRowDragIcon(path *TreePath) gdk.Paintabler {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 *C.GtkTreePath  // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_view_create_row_drag_icon(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _paintable gdk.Paintabler // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.AssumeOwnership(objptr)
			rv, ok := (externglib.CastObject(object)).(gdk.Paintabler)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gdk.Paintabler")
			}
			_paintable = rv
		}
	}

	return _paintable
}

// EnableModelDragDest turns tree_view into a drop destination for automatic
// DND. Calling this method sets TreeView:reorderable to FALSE.
func (treeView *TreeView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GdkContentFormats // out
	var _arg2 C.GdkDragAction      // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg2 = C.GdkDragAction(actions)

	C.gtk_tree_view_enable_model_drag_dest(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(actions)
}

// EnableModelDragSource turns tree_view into a drag source for automatic DND.
// Calling this method sets TreeView:reorderable to FALSE.
func (treeView *TreeView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.GdkModifierType    // out
	var _arg2 *C.GdkContentFormats // out
	var _arg3 C.GdkDragAction      // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.GdkModifierType(startButtonMask)
	_arg2 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg3 = C.GdkDragAction(actions)

	C.gtk_tree_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(startButtonMask)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(actions)
}

// ExpandAll: recursively expands all nodes in the tree_view.
func (treeView *TreeView) ExpandAll() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	C.gtk_tree_view_expand_all(_arg0)
	runtime.KeepAlive(treeView)
}

// ExpandRow opens the row so its children are visible.
func (treeView *TreeView) ExpandRow(path *TreePath, openAll bool) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _arg2 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if openAll {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_tree_view_expand_row(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(openAll)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExpandToPath expands the row at path. This will also expand all parent rows
// of path as necessary.
func (treeView *TreeView) ExpandToPath(path *TreePath) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_view_expand_to_path(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
}

// ActivateOnSingleClick gets the setting set by
// gtk_tree_view_set_activate_on_single_click().
func (treeView *TreeView) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_activate_on_single_click(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackgroundArea fills the bounding rectangle in bin_window coordinates for the
// cell at the row specified by path and the column specified by column. If path
// is NULL, or points to a node not found in the tree, the y and height fields
// of the rectangle will be filled with 0. If column is NULL, the x and width
// fields will be filled with 0. The returned rectangle is equivalent to the
// background_area passed to gtk_cell_renderer_render(). These background areas
// tile to cover the entire bin window. Contrast with the cell_area, returned by
// gtk_tree_view_get_cell_area(), which returns only the cell itself, excluding
// surrounding borders and the tree expander area.
func (treeView *TreeView) BackgroundArea(path *TreePath, column *TreeViewColumn) gdk.Rectangle {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.GdkRectangle       // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	}

	C.gtk_tree_view_get_background_area(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)

	var _rect gdk.Rectangle // out

	_rect = *(*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _rect
}

// CellArea fills the bounding rectangle in bin_window coordinates for the cell
// at the row specified by path and the column specified by column. If path is
// NULL, or points to a path not currently displayed, the y and height fields of
// the rectangle will be filled with 0. If column is NULL, the x and width
// fields will be filled with 0. The sum of all cell rects does not cover the
// entire tree; there are extra pixels in between rows, for example. The
// returned rectangle is equivalent to the cell_area passed to
// gtk_cell_renderer_render(). This function is only valid if tree_view is
// realized.
func (treeView *TreeView) CellArea(path *TreePath, column *TreeViewColumn) gdk.Rectangle {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.GdkRectangle       // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	}

	C.gtk_tree_view_get_cell_area(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)

	var _rect gdk.Rectangle // out

	_rect = *(*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _rect
}

// Column gets the TreeViewColumn at the given position in the #tree_view.
func (treeView *TreeView) Column(n int) *TreeViewColumn {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.int                // out
	var _cret *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(n)

	_cret = C.gtk_tree_view_get_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(n)

	var _treeViewColumn *TreeViewColumn // out

	if _cret != nil {
		_treeViewColumn = wrapTreeViewColumn(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeViewColumn
}

// Columns returns a #GList of all the TreeViewColumn s currently in tree_view.
// The returned list must be freed with g_list_free ().
func (treeView *TreeView) Columns() []TreeViewColumn {
	var _arg0 *C.GtkTreeView // out
	var _cret *C.GList       // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_columns(_arg0)
	runtime.KeepAlive(treeView)

	var _list []TreeViewColumn // out

	_list = make([]TreeViewColumn, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkTreeViewColumn)(v)
		var dst TreeViewColumn // out
		dst = *wrapTreeViewColumn(externglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Cursor fills in path and focus_column with the current path and focus column.
// If the cursor isn’t currently set, then *path will be NULL. If no column
// currently has focus, then *focus_column will be NULL.
//
// The returned TreePath must be freed with gtk_tree_path_free() when you are
// done with it.
func (treeView *TreeView) Cursor() (*TreePath, *TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // in
	var _arg2 *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	C.gtk_tree_view_get_cursor(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(treeView)

	var _path *TreePath              // out
	var _focusColumn *TreeViewColumn // out

	if _arg1 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg2 != nil {
		_focusColumn = wrapTreeViewColumn(externglib.Take(unsafe.Pointer(_arg2)))
	}

	return _path, _focusColumn
}

// DestRowAtPos determines the destination row for a given position. drag_x and
// drag_y are expected to be in widget coordinates. This function is only
// meaningful if tree_view is realized. Therefore this function will always
// return FALSE if tree_view is not realized or does not have a model.
func (treeView *TreeView) DestRowAtPos(dragX int, dragY int) (*TreePath, TreeViewDropPosition, bool) {
	var _arg0 *C.GtkTreeView            // out
	var _arg1 C.int                     // out
	var _arg2 C.int                     // out
	var _arg3 *C.GtkTreePath            // in
	var _arg4 C.GtkTreeViewDropPosition // in
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(dragX)
	_arg2 = C.int(dragY)

	_cret = C.gtk_tree_view_get_dest_row_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(dragX)
	runtime.KeepAlive(dragY)

	var _path *TreePath           // out
	var _pos TreeViewDropPosition // out
	var _ok bool                  // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_pos = TreeViewDropPosition(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _path, _pos, _ok
}

// DragDestRow gets information about the row that is highlighted for feedback.
func (treeView *TreeView) DragDestRow() (*TreePath, TreeViewDropPosition) {
	var _arg0 *C.GtkTreeView            // out
	var _arg1 *C.GtkTreePath            // in
	var _arg2 C.GtkTreeViewDropPosition // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	C.gtk_tree_view_get_drag_dest_row(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(treeView)

	var _path *TreePath           // out
	var _pos TreeViewDropPosition // out

	if _arg1 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_pos = TreeViewDropPosition(_arg2)

	return _path, _pos
}

// EnableSearch returns whether or not the tree allows to start interactive
// searching by typing in text.
func (treeView *TreeView) EnableSearch() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_enable_search(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnableTreeLines returns whether or not tree lines are drawn in tree_view.
func (treeView *TreeView) EnableTreeLines() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_enable_tree_lines(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExpanderColumn returns the column that is the current expander column, or
// NULL if none has been set. This column has the expander arrow drawn next to
// it.
func (treeView *TreeView) ExpanderColumn() *TreeViewColumn {
	var _arg0 *C.GtkTreeView       // out
	var _cret *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_expander_column(_arg0)
	runtime.KeepAlive(treeView)

	var _treeViewColumn *TreeViewColumn // out

	if _cret != nil {
		_treeViewColumn = wrapTreeViewColumn(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeViewColumn
}

// FixedHeightMode returns whether fixed height mode is turned on for tree_view.
func (treeView *TreeView) FixedHeightMode() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_fixed_height_mode(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GridLines returns which grid lines are enabled in tree_view.
func (treeView *TreeView) GridLines() TreeViewGridLines {
	var _arg0 *C.GtkTreeView         // out
	var _cret C.GtkTreeViewGridLines // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_grid_lines(_arg0)
	runtime.KeepAlive(treeView)

	var _treeViewGridLines TreeViewGridLines // out

	_treeViewGridLines = TreeViewGridLines(_cret)

	return _treeViewGridLines
}

// HeadersClickable returns whether all header columns are clickable.
func (treeView *TreeView) HeadersClickable() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_headers_clickable(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HeadersVisible returns TRUE if the headers on the tree_view are visible.
func (treeView *TreeView) HeadersVisible() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_headers_visible(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HoverExpand returns whether hover expansion mode is turned on for tree_view.
func (treeView *TreeView) HoverExpand() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_hover_expand(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HoverSelection returns whether hover selection mode is turned on for
// tree_view.
func (treeView *TreeView) HoverSelection() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_hover_selection(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LevelIndentation returns the amount, in pixels, of extra indentation for
// child levels in tree_view.
func (treeView *TreeView) LevelIndentation() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_level_indentation(_arg0)
	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Model returns the model the TreeView is based on. Returns NULL if the model
// is unset.
func (treeView *TreeView) Model() TreeModeller {
	var _arg0 *C.GtkTreeView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_model(_arg0)
	runtime.KeepAlive(treeView)

	var _treeModel TreeModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(TreeModeller)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.TreeModeller")
			}
			_treeModel = rv
		}
	}

	return _treeModel
}

// NColumns queries the number of columns in the given tree_view.
func (treeView *TreeView) NColumns() uint {
	var _arg0 *C.GtkTreeView // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_n_columns(_arg0)
	runtime.KeepAlive(treeView)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PathAtPos finds the path at the point (x, y), relative to bin_window
// coordinates. That is, x and y are relative to an events coordinates.
// Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
// things like popup menus. If path is non-NULL, then it will be filled with the
// TreePath at that point. This path should be freed with gtk_tree_path_free().
// If column is non-NULL, then it will be filled with the column at that point.
// cell_x and cell_y return the coordinates relative to the cell background
// (i.e. the background_area passed to gtk_cell_renderer_render()). This
// function is only meaningful if tree_view is realized. Therefore this function
// will always return FALSE if tree_view is not realized or does not have a
// model.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
func (treeView *TreeView) PathAtPos(x int, y int) (path *TreePath, column *TreeViewColumn, cellX int, cellY int, ok bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.int                // out
	var _arg2 C.int                // out
	var _arg3 *C.GtkTreePath       // in
	var _arg4 *C.GtkTreeViewColumn // in
	var _arg5 C.int                // in
	var _arg6 C.int                // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gtk_tree_view_get_path_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _path *TreePath         // out
	var _column *TreeViewColumn // out
	var _cellX int              // out
	var _cellY int              // out
	var _ok bool                // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg4 != nil {
		_column = wrapTreeViewColumn(externglib.Take(unsafe.Pointer(_arg4)))
	}
	_cellX = int(_arg5)
	_cellY = int(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _path, _column, _cellX, _cellY, _ok
}

// Reorderable retrieves whether the user can reorder the tree via
// drag-and-drop. See gtk_tree_view_set_reorderable().
func (treeView *TreeView) Reorderable() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_reorderable(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RubberBanding returns whether rubber banding is turned on for tree_view. If
// the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
func (treeView *TreeView) RubberBanding() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_rubber_banding(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SearchColumn gets the column searched on by the interactive search code.
func (treeView *TreeView) SearchColumn() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_search_column(_arg0)
	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SearchEntry returns the Entry which is currently in use as interactive search
// entry for tree_view. In case the built-in entry is being used, NULL will be
// returned.
func (treeView *TreeView) SearchEntry() Editabler {
	var _arg0 *C.GtkTreeView // out
	var _cret *C.GtkEditable // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_search_entry(_arg0)
	runtime.KeepAlive(treeView)

	var _editable Editabler // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(Editabler)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Editabler")
			}
			_editable = rv
		}
	}

	return _editable
}

// Selection gets the TreeSelection associated with tree_view.
func (treeView *TreeView) Selection() *TreeSelection {
	var _arg0 *C.GtkTreeView      // out
	var _cret *C.GtkTreeSelection // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_selection(_arg0)
	runtime.KeepAlive(treeView)

	var _treeSelection *TreeSelection // out

	_treeSelection = wrapTreeSelection(externglib.Take(unsafe.Pointer(_cret)))

	return _treeSelection
}

// ShowExpanders returns whether or not expanders are drawn in tree_view.
func (treeView *TreeView) ShowExpanders() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_show_expanders(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TooltipColumn returns the column of tree_view’s model which is being used for
// displaying tooltips on tree_view’s rows.
func (treeView *TreeView) TooltipColumn() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_tooltip_column(_arg0)
	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for TreeView. The x, y and keyboard_tip
// values which are received in the signal handler, should be passed to this
// function without modification.
//
// The return value indicates whether there is a tree view row at the given
// coordinates (TRUE) or not (FALSE) for mouse tooltips. For keyboard tooltips
// the row returned will be the cursor row. When TRUE, then any of model, path
// and iter which have been provided will be set to point to that row and the
// corresponding model. x and y will always be converted to be relative to
// tree_view’s bin_window if keyboard_tooltip is FALSE.
func (treeView *TreeView) TooltipContext(x int, y int, keyboardTip bool) (TreeModeller, *TreePath, TreeIter, bool) {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.gboolean      // out
	var _arg4 *C.GtkTreeModel // in
	var _arg5 *C.GtkTreePath  // in
	var _arg6 C.GtkTreeIter   // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	if keyboardTip {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_tree_view_get_tooltip_context(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(keyboardTip)

	var _model TreeModeller // out
	var _path *TreePath     // out
	var _iter TreeIter      // out
	var _ok bool            // out

	if _arg4 != nil {
		{
			objptr := unsafe.Pointer(_arg4)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(TreeModeller)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.TreeModeller")
			}
			_model = rv
		}
	}
	if _arg5 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_iter = *(*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg6))))
	if _cret != 0 {
		_ok = true
	}

	return _model, _path, _iter, _ok
}

// VisibleRange sets start_path and end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
//
// The paths should be freed with gtk_tree_path_free() after use.
func (treeView *TreeView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // in
	var _arg2 *C.GtkTreePath // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_get_visible_range(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(treeView)

	var _startPath *TreePath // out
	var _endPath *TreePath   // out
	var _ok bool             // out

	if _arg1 != nil {
		_startPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_startPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg2 != nil {
		_endPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_endPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// VisibleRect fills visible_rect with the currently-visible region of the
// buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start at
// 0,0 for row 0 of the tree, and cover the entire scrollable area of the tree.
func (treeView *TreeView) VisibleRect() gdk.Rectangle {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	C.gtk_tree_view_get_visible_rect(_arg0, &_arg1)
	runtime.KeepAlive(treeView)

	var _visibleRect gdk.Rectangle // out

	_visibleRect = *(*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _visibleRect
}

// InsertColumn: this inserts the column into the tree_view at position. If
// position is -1, then the column is inserted at the end. If tree_view has
// “fixed_height” mode enabled, then column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
func (treeView *TreeView) InsertColumn(column *TreeViewColumn, position int) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _arg2 C.int                // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	_arg2 = C.int(position)

	_cret = C.gtk_tree_view_insert_column(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
	runtime.KeepAlive(position)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InsertColumnWithDataFunc: convenience function that inserts a new column into
// the TreeView with the given cell renderer and a TreeCellDataFunc to set cell
// renderer attributes (normally using data from the model). See also
// gtk_tree_view_column_set_cell_data_func(), gtk_tree_view_column_pack_start().
// If tree_view has “fixed_height” mode enabled, then the new column will have
// its “sizing” property set to be GTK_TREE_VIEW_COLUMN_FIXED.
func (treeView *TreeView) InsertColumnWithDataFunc(position int, title string, cell CellRendererer, fn TreeCellDataFunc) int {
	var _arg0 *C.GtkTreeView        // out
	var _arg1 C.int                 // out
	var _arg2 *C.char               // out
	var _arg3 *C.GtkCellRenderer    // out
	var _arg4 C.GtkTreeCellDataFunc // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify
	var _cret C.int // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(position)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	_arg4 = (*[0]byte)(C._gotk4_gtk4_TreeCellDataFunc)
	_arg5 = C.gpointer(gbox.Assign(fn))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gtk_tree_view_insert_column_with_data_func(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(position)
	runtime.KeepAlive(title)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(fn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsBlankAtPos: determine whether the point (x, y) in tree_view is blank, that
// is no cell content nor an expander arrow is drawn at the location. If so, the
// location can be considered as the background. You might wish to take special
// action on clicks on the background, such as clearing a current selection,
// having a custom context menu or starting rubber banding.
//
// The x and y coordinate that are provided must be relative to bin_window
// coordinates. Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// The path, column, cell_x and cell_y arguments will be filled in likewise as
// for gtk_tree_view_get_path_at_pos(). Please see
// gtk_tree_view_get_path_at_pos() for more information.
func (treeView *TreeView) IsBlankAtPos(x int, y int) (path *TreePath, column *TreeViewColumn, cellX int, cellY int, ok bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.int                // out
	var _arg2 C.int                // out
	var _arg3 *C.GtkTreePath       // in
	var _arg4 *C.GtkTreeViewColumn // in
	var _arg5 C.int                // in
	var _arg6 C.int                // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gtk_tree_view_is_blank_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _path *TreePath         // out
	var _column *TreeViewColumn // out
	var _cellX int              // out
	var _cellY int              // out
	var _ok bool                // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg4 != nil {
		_column = wrapTreeViewColumn(externglib.Take(unsafe.Pointer(_arg4)))
	}
	_cellX = int(_arg5)
	_cellY = int(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _path, _column, _cellX, _cellY, _ok
}

// IsRubberBandingActive returns whether a rubber banding operation is currently
// being done in tree_view.
func (treeView *TreeView) IsRubberBandingActive() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	_cret = C.gtk_tree_view_is_rubber_banding_active(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MapExpandedRows calls func on all expanded rows.
func (treeView *TreeView) MapExpandedRows(fn TreeViewMappingFunc) {
	var _arg0 *C.GtkTreeView           // out
	var _arg1 C.GtkTreeViewMappingFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewMappingFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_tree_view_map_expanded_rows(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(fn)
}

// MoveColumnAfter moves column to be after to base_column. If base_column is
// NULL, then column is placed in the first position.
func (treeView *TreeView) MoveColumnAfter(column *TreeViewColumn, baseColumn *TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	if baseColumn != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(baseColumn.Native()))
	}

	C.gtk_tree_view_move_column_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
	runtime.KeepAlive(baseColumn)
}

// RemoveColumn removes column from tree_view.
func (treeView *TreeView) RemoveColumn(column *TreeViewColumn) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	_cret = C.gtk_tree_view_remove_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RowActivated activates the cell determined by path and column.
func (treeView *TreeView) RowActivated(path *TreePath, column *TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

	C.gtk_tree_view_row_activated(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
}

// RowExpanded returns TRUE if the node pointed to by path is expanded in
// tree_view.
func (treeView *TreeView) RowExpanded(path *TreePath) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_view_row_expanded(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToCell moves the alignments of tree_view to the position specified by
// column and path. If column is NULL, then no horizontal scrolling occurs.
// Likewise, if path is NULL no vertical scrolling occurs. At a minimum, one of
// column or path need to be non-NULL. row_align determines where the row is
// placed, and col_align determines where column is placed. Both are expected to
// be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom
// alignment, 0.5 means center.
//
// If use_align is FALSE, then the alignment arguments are ignored, and the tree
// does the minimum amount of work to scroll the cell onto the screen. This
// means that the cell will be scrolled to the edge closest to its current
// position. If the cell is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and path is a valid row on the
// model. If the model changes before the tree_view is realized, the centered
// path will be modified to reflect this change.
func (treeView *TreeView) ScrollToCell(path *TreePath, column *TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.gboolean           // out
	var _arg4 C.float              // out
	var _arg5 C.float              // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	}
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.float(rowAlign)
	_arg5 = C.float(colAlign)

	C.gtk_tree_view_scroll_to_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(rowAlign)
	runtime.KeepAlive(colAlign)
}

// ScrollToPoint scrolls the tree view such that the top-left corner of the
// visible area is tree_x, tree_y, where tree_x and tree_y are specified in tree
// coordinates. The tree_view must be realized before this function is called.
// If it isn't, you probably want to be using gtk_tree_view_scroll_to_cell().
//
// If either tree_x or tree_y are -1, then that direction isn’t scrolled.
func (treeView *TreeView) ScrollToPoint(treeX int, treeY int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(treeX)
	_arg2 = C.int(treeY)

	C.gtk_tree_view_scroll_to_point(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(treeX)
	runtime.KeepAlive(treeY)
}

// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
// emitted on a single click instead of a double click.
func (treeView *TreeView) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_activate_on_single_click(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(single)
}

// SetColumnDragFunction sets a user function for determining where a column may
// be dropped when dragged. This function is called on every column pair in turn
// at the beginning of a column drag to determine where a drop can take place.
// The arguments passed to func are: the tree_view, the TreeViewColumn being
// dragged, the two TreeViewColumn s determining the drop spot, and user_data.
// If either of the TreeViewColumn arguments for the drop spot are NULL, then
// they indicate an edge. If func is set to be NULL, then tree_view reverts to
// the default behavior of allowing all columns to be dropped everywhere.
func (treeView *TreeView) SetColumnDragFunction(fn TreeViewColumnDropFunc) {
	var _arg0 *C.GtkTreeView              // out
	var _arg1 C.GtkTreeViewColumnDropFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewColumnDropFunc)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_tree_view_set_column_drag_function(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(fn)
}

// SetCursor sets the current keyboard focus to be at path, and selects it. This
// is useful when you want to focus the user’s attention on a particular row. If
// focus_column is not NULL, then focus is given to the column specified by it.
// Additionally, if focus_column is specified, and start_editing is TRUE, then
// editing should be started in the specified cell. This function is often
// followed by gtk_widget_grab_focus (tree_view) in order to give keyboard focus
// to the widget. Please note that editing can only happen when the widget is
// realized.
//
// If path is invalid for model, the current cursor (if any) will be unset and
// the function will return without failing.
func (treeView *TreeView) SetCursor(path *TreePath, focusColumn *TreeViewColumn, startEditing bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.gboolean           // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if focusColumn != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
	}
	if startEditing {
		_arg3 = C.TRUE
	}

	C.gtk_tree_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(focusColumn)
	runtime.KeepAlive(startEditing)
}

// SetCursorOnCell sets the current keyboard focus to be at path, and selects
// it. This is useful when you want to focus the user’s attention on a
// particular row. If focus_column is not NULL, then focus is given to the
// column specified by it. If focus_column and focus_cell are not NULL, and
// focus_column contains 2 or more editable or activatable cells, then focus is
// given to the cell specified by focus_cell. Additionally, if focus_column is
// specified, and start_editing is TRUE, then editing should be started in the
// specified cell. This function is often followed by gtk_widget_grab_focus
// (tree_view) in order to give keyboard focus to the widget. Please note that
// editing can only happen when the widget is realized.
//
// If path is invalid for model, the current cursor (if any) will be unset and
// the function will return without failing.
func (treeView *TreeView) SetCursorOnCell(path *TreePath, focusColumn *TreeViewColumn, focusCell CellRendererer, startEditing bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 *C.GtkCellRenderer   // out
	var _arg4 C.gboolean           // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if focusColumn != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
	}
	if focusCell != nil {
		_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(focusCell.Native()))
	}
	if startEditing {
		_arg4 = C.TRUE
	}

	C.gtk_tree_view_set_cursor_on_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(focusColumn)
	runtime.KeepAlive(focusCell)
	runtime.KeepAlive(startEditing)
}

// SetDragDestRow sets the row that is highlighted for feedback. If path is
// NULL, an existing highlight is removed.
func (treeView *TreeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition) {
	var _arg0 *C.GtkTreeView            // out
	var _arg1 *C.GtkTreePath            // out
	var _arg2 C.GtkTreeViewDropPosition // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	_arg2 = C.GtkTreeViewDropPosition(pos)

	C.gtk_tree_view_set_drag_dest_row(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
}

// SetEnableSearch: if enable_search is set, then the user can type in text to
// search through the tree interactively (this is sometimes called "typeahead
// find").
//
// Note that even if this is FALSE, the user can still initiate a search using
// the “start-interactive-search” key binding.
func (treeView *TreeView) SetEnableSearch(enableSearch bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if enableSearch {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_enable_search(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enableSearch)
}

// SetEnableTreeLines sets whether to draw lines interconnecting the expanders
// in tree_view. This does not have any visible effects for lists.
func (treeView *TreeView) SetEnableTreeLines(enabled bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_enable_tree_lines(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enabled)
}

// SetExpanderColumn sets the column to draw the expander arrow at. It must be
// in tree_view. If column is NULL, then the expander arrow is always at the
// first visible column.
//
// If you do not want expander arrow to appear in your tree, set the expander
// column to a hidden column.
func (treeView *TreeView) SetExpanderColumn(column *TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if column != nil {
		_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	}

	C.gtk_tree_view_set_expander_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetFixedHeightMode enables or disables the fixed height mode of tree_view.
// Fixed height mode speeds up TreeView by assuming that all rows have the same
// height. Only enable this option if all rows are the same height and all
// columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
func (treeView *TreeView) SetFixedHeightMode(enable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_fixed_height_mode(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enable)
}

// SetGridLines sets which grid lines to draw in tree_view.
func (treeView *TreeView) SetGridLines(gridLines TreeViewGridLines) {
	var _arg0 *C.GtkTreeView         // out
	var _arg1 C.GtkTreeViewGridLines // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.GtkTreeViewGridLines(gridLines)

	C.gtk_tree_view_set_grid_lines(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(gridLines)
}

// SetHeadersClickable: allow the column title buttons to be clicked.
func (treeView *TreeView) SetHeadersClickable(setting bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_headers_clickable(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(setting)
}

// SetHeadersVisible sets the visibility state of the headers.
func (treeView *TreeView) SetHeadersVisible(headersVisible bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if headersVisible {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_headers_visible(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(headersVisible)
}

// SetHoverExpand enables or disables the hover expansion mode of tree_view.
// Hover expansion makes rows expand or collapse if the pointer moves over them.
func (treeView *TreeView) SetHoverExpand(expand bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_hover_expand(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(expand)
}

// SetHoverSelection enables or disables the hover selection mode of tree_view.
// Hover selection makes the selected row follow the pointer. Currently, this
// works only for the selection modes GTK_SELECTION_SINGLE and
// GTK_SELECTION_BROWSE.
func (treeView *TreeView) SetHoverSelection(hover bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if hover {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_hover_selection(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(hover)
}

// SetLevelIndentation sets the amount of extra indentation for child levels to
// use in tree_view in addition to the default indentation. The value should be
// specified in pixels, a value of 0 disables this feature and in this case only
// the default indentation will be used. This does not have any visible effects
// for lists.
func (treeView *TreeView) SetLevelIndentation(indentation int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(indentation)

	C.gtk_tree_view_set_level_indentation(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(indentation)
}

// SetModel sets the model for a TreeView. If the tree_view already has a model
// set, it will remove it before setting the new model. If model is NULL, then
// it will unset the old model.
func (treeView *TreeView) SetModel(model TreeModeller) {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if model != nil {
		_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
	}

	C.gtk_tree_view_set_model(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(model)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If reorderable
// is TRUE, then the user can reorder the model by dragging and dropping rows.
// The developer can listen to these changes by connecting to the model’s
// TreeModel::row-inserted and TreeModel::row-deleted signals. The reordering is
// implemented by setting up the tree view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any other
// purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
func (treeView *TreeView) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_reorderable(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(reorderable)
}

// SetRowSeparatorFunc sets the row separator function, which is used to
// determine whether a row should be drawn as a separator. If the row separator
// function is NULL, no separators are drawn. This is the default value.
func (treeView *TreeView) SetRowSeparatorFunc(fn TreeViewRowSeparatorFunc) {
	var _arg0 *C.GtkTreeView                // out
	var _arg1 C.GtkTreeViewRowSeparatorFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewRowSeparatorFunc)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_tree_view_set_row_separator_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(fn)
}

// SetRubberBanding enables or disables rubber banding in tree_view. If the
// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the user to
// select multiple rows by dragging the mouse.
func (treeView *TreeView) SetRubberBanding(enable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_rubber_banding(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enable)
}

// SetSearchColumn sets column as the column where the interactive search code
// should search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search” key
// binding to bring up search popup. The enable-search property controls whether
// simply typing text will also start an interactive search.
//
// Note that column refers to a column of the current model. The search column
// is reset to -1 when the model is changed.
func (treeView *TreeView) SetSearchColumn(column int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(column)

	C.gtk_tree_view_set_search_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetSearchEntry sets the entry which the interactive search code will use for
// this tree_view. This is useful when you want to provide a search entry in our
// interface at all time at a fixed position. Passing NULL for entry will make
// the interactive search code use the built-in popup entry again.
func (treeView *TreeView) SetSearchEntry(entry Editabler) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkEditable // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if entry != nil {
		_arg1 = (*C.GtkEditable)(unsafe.Pointer(entry.Native()))
	}

	C.gtk_tree_view_set_search_entry(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(entry)
}

// SetSearchEqualFunc sets the compare function for the interactive search
// capabilities; note that somewhat like strcmp() returning 0 for equality
// TreeViewSearchEqualFunc returns FALSE on matches.
func (treeView *TreeView) SetSearchEqualFunc(searchEqualFunc TreeViewSearchEqualFunc) {
	var _arg0 *C.GtkTreeView               // out
	var _arg1 C.GtkTreeViewSearchEqualFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewSearchEqualFunc)
	_arg2 = C.gpointer(gbox.Assign(searchEqualFunc))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_tree_view_set_search_equal_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(searchEqualFunc)
}

// SetShowExpanders sets whether to draw and enable expanders and indent child
// rows in tree_view. When disabled there will be no expanders visible in trees
// and there will be no way to expand and collapse rows by default. Also note
// that hiding the expanders will disable the default indentation. You can set a
// custom indentation in this case using gtk_tree_view_set_level_indentation().
// This does not have any visible effects for lists.
func (treeView *TreeView) SetShowExpanders(enabled bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_show_expanders(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enabled)
}

// SetTooltipCell sets the tip area of tooltip to the area path, column and cell
// have in common. For example if path is NULL and column is set, the tip area
// will be set to the full area covered by column. See also
// gtk_tooltip_set_tip_area().
//
// Note that if path is not specified and cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the correct
// position. In such cases path must be set to the current node under the mouse
// cursor for this function to operate correctly.
//
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
func (treeView *TreeView) SetTooltipCell(tooltip *Tooltip, path *TreePath, column *TreeViewColumn, cell CellRendererer) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTooltip        // out
	var _arg2 *C.GtkTreePath       // out
	var _arg3 *C.GtkTreeViewColumn // out
	var _arg4 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	if path != nil {
		_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg3 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
	}
	if cell != nil {
		_arg4 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
	}

	C.gtk_tree_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
	runtime.KeepAlive(cell)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full rows, you can use this function to have TreeView handle these
// automatically for you. column should be set to the column in tree_view’s
// model containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, Widget:has-tooltip will be set to TRUE and tree_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(), so
// &, <, etc have to be escaped in the text.
func (treeView *TreeView) SetTooltipColumn(column int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = C.int(column)

	C.gtk_tree_view_set_tooltip_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetTooltipRow sets the tip area of tooltip to be the area covered by the row
// at path. See also gtk_tree_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
func (treeView *TreeView) SetTooltipRow(tooltip *Tooltip, path *TreePath) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTooltip  // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_view_set_tooltip_row(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
}

// UnsetRowsDragDest undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// TreeView:reorderable to FALSE.
func (treeView *TreeView) UnsetRowsDragDest() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	C.gtk_tree_view_unset_rows_drag_dest(_arg0)
	runtime.KeepAlive(treeView)
}

// UnsetRowsDragSource undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// TreeView:reorderable to FALSE.
func (treeView *TreeView) UnsetRowsDragSource() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(treeView.Native()))

	C.gtk_tree_view_unset_rows_drag_source(_arg0)
	runtime.KeepAlive(treeView)
}

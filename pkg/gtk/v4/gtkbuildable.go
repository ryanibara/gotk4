// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
// GObject* _gotk4_gtk4_Buildable_virtual_get_internal_child(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, char* arg2) {
//   return ((GObject* (*)(GtkBuildable*, GtkBuilder*, char*))(fnptr))(arg0, arg1, arg2);
// };
// char* _gotk4_gtk4_Buildable_virtual_get_id(void* fnptr, GtkBuildable* arg0) {
//   return ((char* (*)(GtkBuildable*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_Buildable_virtual_custom_tag_start(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, GObject* arg2, char* arg3, GtkBuildableParser* arg4, gpointer* arg5) {
//   return ((gboolean (*)(GtkBuildable*, GtkBuilder*, GObject*, char*, GtkBuildableParser*, gpointer*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gtk4_Buildable_virtual_add_child(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, GObject* arg2, char* arg3) {
//   ((void (*)(GtkBuildable*, GtkBuilder*, GObject*, char*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_Buildable_virtual_custom_finished(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, GObject* arg2, char* arg3, gpointer arg4) {
//   ((void (*)(GtkBuildable*, GtkBuilder*, GObject*, char*, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_Buildable_virtual_custom_tag_end(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, GObject* arg2, char* arg3, gpointer arg4) {
//   ((void (*)(GtkBuildable*, GtkBuilder*, GObject*, char*, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_Buildable_virtual_parser_finished(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1) {
//   ((void (*)(GtkBuildable*, GtkBuilder*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Buildable_virtual_set_buildable_property(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, char* arg2, GValue* arg3) {
//   ((void (*)(GtkBuildable*, GtkBuilder*, char*, GValue*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_Buildable_virtual_set_id(void* fnptr, GtkBuildable* arg0, char* arg1) {
//   ((void (*)(GtkBuildable*, char*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeBuildable = coreglib.Type(C.gtk_buildable_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeBuildable, F: marshalBuildable},
	})
}

// Buildable: GtkBuildable allows objects to extend and customize their
// deserialization from ui files.
//
// The interface includes methods for setting names and properties of objects,
// parsing custom tags and constructing child objects.
//
// The GtkBuildable interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK. The main user of this interface
// is gtk.Builder. There should be very little need for applications to call any
// of these functions directly.
//
// An object only needs to implement this interface if it needs to extend the
// GtkBuilder XML format or run any extra routines at deserialization time.
//
// Buildable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Buildable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Buildable)(nil)
)

// Buildabler describes Buildable's interface methods.
type Buildabler interface {
	coreglib.Objector

	// BuildableID gets the ID of the buildable object.
	BuildableID() string
}

var _ Buildabler = (*Buildable)(nil)

func wrapBuildable(obj *coreglib.Object) *Buildable {
	return &Buildable{
		Object: obj,
	}
}

func marshalBuildable(p uintptr) (interface{}, error) {
	return wrapBuildable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// BuildableID gets the ID of the buildable object.
//
// GtkBuilder sets the name based on the ID attribute of the <object> tag used
// to construct the buildable.
//
// The function returns the following values:
//
//   - utf8: ID of the buildable object.
//
func (buildable *Buildable) BuildableID() string {
	var _arg0 *C.GtkBuildable // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))

	_cret = C.gtk_buildable_get_buildable_id(_arg0)
	runtime.KeepAlive(buildable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// addChild adds a child to buildable. type is an optional string describing how
// the child should be added.
//
// The function takes the following parameters:
//
//   - builder: Builder.
//   - child to add.
//   - typ (optional): kind of child or NULL.
//
func (buildable *Buildable) addChild(builder *Builder, child *coreglib.Object, typ string) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.add_child

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.GObject      // out
	var _arg3 *C.char         // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	if typ != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(typ)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C._gotk4_gtk4_Buildable_virtual_add_child(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(child)
	runtime.KeepAlive(typ)
}

// customFinished: similar to gtk_buildable_parser_finished() but is called once
// for each custom tag handled by the buildable.
//
// The function takes the following parameters:
//
//   - builder: Builder.
//   - child (optional) object or NULL for non-child tags.
//   - tagname: name of the tag.
//   - data (optional): user data created in custom_tag_start.
//
func (buildable *Buildable) customFinished(builder *Builder, child *coreglib.Object, tagname string, data unsafe.Pointer) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.custom_finished

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.GObject      // out
	var _arg3 *C.char         // out
	var _arg4 C.gpointer      // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if child != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(tagname)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.gpointer)(unsafe.Pointer(data))

	C._gotk4_gtk4_Buildable_virtual_custom_finished(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tagname)
	runtime.KeepAlive(data)
}

// customTagEnd: called at the end of each custom element handled by the
// buildable.
//
// The function takes the following parameters:
//
//   - builder used to construct this object.
//   - child (optional) object or NULL for non-child tags.
//   - tagname: name of tag.
//   - data (optional): user data that will be passed in to parser functions.
//
func (buildable *Buildable) customTagEnd(builder *Builder, child *coreglib.Object, tagname string, data unsafe.Pointer) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.custom_tag_end

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.GObject      // out
	var _arg3 *C.char         // out
	var _arg4 C.gpointer      // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if child != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(tagname)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.gpointer)(unsafe.Pointer(data))

	C._gotk4_gtk4_Buildable_virtual_custom_tag_end(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tagname)
	runtime.KeepAlive(data)
}

// customTagStart: called for each unknown element under <child>.
//
// The function takes the following parameters:
//
//   - builder used to construct this object.
//   - child (optional) object or NULL for non-child tags.
//   - tagname: name of tag.
//
// The function returns the following values:
//
//   - parser to fill in.
//   - data (optional): return location for user data that will be passed in to
//     parser functions.
//   - ok: TRUE if an object has a custom implementation, FALSE if it doesn't.
//
func (buildable *Buildable) customTagStart(builder *Builder, child *coreglib.Object, tagname string) (*BuildableParser, unsafe.Pointer, bool) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.custom_tag_start

	var _arg0 *C.GtkBuildable      // out
	var _arg1 *C.GtkBuilder        // out
	var _arg2 *C.GObject           // out
	var _arg3 *C.char              // out
	var _arg4 C.GtkBuildableParser // in
	var _arg5 C.gpointer           // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if child != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(tagname)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C._gotk4_gtk4_Buildable_virtual_custom_tag_start(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tagname)

	var _parser *BuildableParser // out
	var _data unsafe.Pointer     // out
	var _ok bool                 // out

	_parser = (*BuildableParser)(gextras.NewStructNative(unsafe.Pointer((&_arg4))))
	_data = (unsafe.Pointer)(unsafe.Pointer(_arg5))
	if _cret != 0 {
		_ok = true
	}

	return _parser, _data, _ok
}

// The function returns the following values:
//
func (buildable *Buildable) iD() string {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.get_id

	var _arg0 *C.GtkBuildable // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))

	_cret = C._gotk4_gtk4_Buildable_virtual_get_id(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buildable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// internalChild retrieves the internal child called childname of the buildable
// object.
//
// The function takes the following parameters:
//
//   - builder: Builder.
//   - childname: name of child.
//
// The function returns the following values:
//
//   - object: internal child of the buildable object.
//
func (buildable *Buildable) internalChild(builder *Builder, childname string) *coreglib.Object {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.get_internal_child

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.char         // out
	var _cret *C.GObject      // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(childname)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gtk4_Buildable_virtual_get_internal_child(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(childname)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// The function takes the following parameters:
//
func (buildable *Buildable) parserFinished(builder *Builder) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.parser_finished

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))

	C._gotk4_gtk4_Buildable_virtual_parser_finished(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
}

// The function takes the following parameters:
//
//   - builder
//   - name
//   - value
//
func (buildable *Buildable) setBuildableProperty(builder *Builder, name string, value *coreglib.Value) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.set_buildable_property

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.char         // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C._gotk4_gtk4_Buildable_virtual_set_buildable_property(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// The function takes the following parameters:
//
func (buildable *Buildable) setID(id string) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.set_id

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gtk4_Buildable_virtual_set_id(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(id)
}

// BuildableIface: GtkBuildableIface interface contains methods that are
// necessary to allow GtkBuilder to construct an object from a GtkBuilder UI
// definition.
//
// An instance of this type is always passed by reference.
type BuildableIface struct {
	*buildableIface
}

// buildableIface is the struct that's finalized.
type buildableIface struct {
	native *C.GtkBuildableIface
}

// BuildableParser: sub-parser for GtkBuildable implementations.
//
// An instance of this type is always passed by reference.
type BuildableParser struct {
	*buildableParser
}

// buildableParser is the struct that's finalized.
type buildableParser struct {
	native *C.GtkBuildableParser
}

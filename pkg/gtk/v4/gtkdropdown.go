// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gtkdropdown.go.
var GTypeDropDown = coreglib.Type(C.gtk_drop_down_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeDropDown, F: marshalDropDown},
	})
}

// DropDownOverrider contains methods that are overridable.
type DropDownOverrider interface {
}

// DropDown: GtkDropDown is a widget that allows the user to choose an item from
// a list of options.
//
// !An example GtkDropDown (drop-down.png)
//
// The GtkDropDown displays the selected choice.
//
// The options are given to GtkDropDown in the form of GListModel and how the
// individual options are represented is determined by a gtk.ListItemFactory.
// The default factory displays simple strings.
//
// GtkDropDown knows how to obtain strings from the items in a gtk.StringList;
// for other models, you have to provide an expression to find the strings via
// gtk.DropDown.SetExpression().
//
// GtkDropDown can optionally allow search in the popup, which is useful if the
// list of options is long. To enable the search entry, use
// gtk.DropDown.SetEnableSearch().
//
//
// CSS nodes
//
// GtkDropDown has a single CSS node with name dropdown, with the button and
// popover nodes as children.
//
//
// Accessibility
//
// GtkDropDown uses the GTK_ACCESSIBLE_ROLE_COMBO_BOX role.
type DropDown struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*DropDown)(nil)
)

func classInitDropDowner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapDropDown(obj *coreglib.Object) *DropDown {
	return &DropDown{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalDropDown(p uintptr) (interface{}, error) {
	return wrapDropDown(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDropDown creates a new GtkDropDown.
//
// You may want to call gtk.DropDown.SetFactory() to set up a way to map its
// items to widgets.
//
// The function takes the following parameters:
//
//    - model (optional) to use or NULL for none.
//    - expression (optional) to use or NULL for none.
//
// The function returns the following values:
//
//    - dropDown: new GtkDropDown.
//
func NewDropDown(model gio.ListModeller, expression Expressioner) *DropDown {
	var _args [2]girepository.Argument

	if model != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}
	if expression != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(expression).Native()))
	}

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("new_DropDown", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)
	runtime.KeepAlive(expression)

	var _dropDown *DropDown // out

	_dropDown = wrapDropDown(coreglib.Take(unsafe.Pointer(_cret)))

	return _dropDown
}

// NewDropDownFromStrings creates a new GtkDropDown that is populated with the
// strings.
//
// The function takes the following parameters:
//
//    - strings to put in the dropdown.
//
// The function returns the following values:
//
//    - dropDown: new GtkDropDown.
//
func NewDropDownFromStrings(strings []string) *DropDown {
	var _args [1]girepository.Argument

	{
		*(***C.void)(unsafe.Pointer(&_args[0])) = (**C.void)(C.calloc(C.size_t((len(strings) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_args[0]))
		{
			out := unsafe.Slice(_args[0], len(strings)+1)
			var zero *C.void
			out[len(strings)] = zero
			for i := range strings {
				*(**C.void)(unsafe.Pointer(&out[i])) = (*C.void)(unsafe.Pointer(C.CString(strings[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("new_DropDown_from_strings", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(strings)

	var _dropDown *DropDown // out

	_dropDown = wrapDropDown(coreglib.Take(unsafe.Pointer(_cret)))

	return _dropDown
}

// EnableSearch returns whether search is enabled.
//
// The function returns the following values:
//
//    - ok: TRUE if the popup includes a search entry.
//
func (self *DropDown) EnableSearch() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("get_enable_search", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Expression gets the expression set that is used to obtain strings from items.
//
// See gtk.DropDown.SetExpression().
//
// The function returns the following values:
//
//    - expression (optional): GtkExpression or NULL.
//
func (self *DropDown) Expression() Expressioner {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("get_expression", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _expression Expressioner // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Expressioner)
				return ok
			})
			rv, ok := casted.(Expressioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// Factory gets the factory that's currently used to populate list items.
//
// The factory returned by this function is always used for the item in the
// button. It is also used for items in the popup if gtk.DropDown:list-factory
// is not set.
//
// The function returns the following values:
//
//    - listItemFactory (optional): factory in use.
//
func (self *DropDown) Factory() *ListItemFactory {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("get_factory", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _listItemFactory *ListItemFactory // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_listItemFactory = wrapListItemFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listItemFactory
}

// ListFactory gets the factory that's currently used to populate list items in
// the popup.
//
// The function returns the following values:
//
//    - listItemFactory (optional): factory in use.
//
func (self *DropDown) ListFactory() *ListItemFactory {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("get_list_factory", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _listItemFactory *ListItemFactory // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_listItemFactory = wrapListItemFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listItemFactory
}

// Model gets the model that provides the displayed items.
//
// The function returns the following values:
//
//    - listModel (optional): model in use.
//
func (self *DropDown) Model() *gio.ListModel {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("get_model", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// Selected gets the position of the selected item.
//
// The function returns the following values:
//
//    - guint: position of the selected item, or GTK_INVALID_LIST_POSITION if not
//      item is selected.
//
func (self *DropDown) Selected() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("get_selected", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// SelectedItem gets the selected item. If no item is selected, NULL is
// returned.
//
// The function returns the following values:
//
//    - object (optional): selected item.
//
func (self *DropDown) SelectedItem() *coreglib.Object {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "DropDown").InvokeMethod("get_selected_item", _args[:], nil)
	_cret = *(*C.gpointer)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// SetEnableSearch sets whether a search entry will be shown in the popup that
// allows to search for items in the list.
//
// Note that gtk.DropDown:expression must be set for search to work.
//
// The function takes the following parameters:
//
//    - enableSearch: whether to enable search.
//
func (self *DropDown) SetEnableSearch(enableSearch bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if enableSearch {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "DropDown").InvokeMethod("set_enable_search", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(enableSearch)
}

// SetExpression sets the expression that gets evaluated to obtain strings from
// items.
//
// This is used for search in the popup. The expression must have a value type
// of G_TYPE_STRING.
//
// The function takes the following parameters:
//
//    - expression (optional): GtkExpression, or NULL.
//
func (self *DropDown) SetExpression(expression Expressioner) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expression != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
	}

	girepository.MustFind("Gtk", "DropDown").InvokeMethod("set_expression", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(expression)
}

// SetFactory sets the GtkListItemFactory to use for populating list items.
//
// The function takes the following parameters:
//
//    - factory (optional) to use or NULL for none.
//
func (self *DropDown) SetFactory(factory *ListItemFactory) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if factory != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	}

	girepository.MustFind("Gtk", "DropDown").InvokeMethod("set_factory", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetListFactory sets the GtkListItemFactory to use for populating list items
// in the popup.
//
// The function takes the following parameters:
//
//    - factory (optional) to use or NULL for none.
//
func (self *DropDown) SetListFactory(factory *ListItemFactory) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if factory != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	}

	girepository.MustFind("Gtk", "DropDown").InvokeMethod("set_list_factory", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetModel sets the GListModel to use.
//
// The function takes the following parameters:
//
//    - model (optional) to use or NULL for none.
//
func (self *DropDown) SetModel(model gio.ListModeller) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	girepository.MustFind("Gtk", "DropDown").InvokeMethod("set_model", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetSelected selects the item at the given position.
//
// The function takes the following parameters:
//
//    - position of the item to select, or GTK_INVALID_LIST_POSITION.
//
func (self *DropDown) SetSelected(position uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(position)

	girepository.MustFind("Gtk", "DropDown").InvokeMethod("set_selected", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

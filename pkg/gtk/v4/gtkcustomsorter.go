// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gint _gotk4_glib2_CompareDataFunc(gpointer, gpointer, gpointer);
// extern gint _gotk4_gtk4_CompareDataFunc(gpointer, gpointer, gpointer);
// extern void callbackDelete(gpointer);
import "C"

// GTypeCustomSorter returns the GType for the type CustomSorter.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeCustomSorter() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "CustomSorter").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalCustomSorter)
	return gtype
}

// CustomSorterOverrider contains methods that are overridable.
type CustomSorterOverrider interface {
}

// CustomSorter: GtkCustomSorter is a GtkSorter implementation that sorts via a
// callback function.
type CustomSorter struct {
	_ [0]func() // equal guard
	Sorter
}

var (
	_ coreglib.Objector = (*CustomSorter)(nil)
)

func classInitCustomSorterer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapCustomSorter(obj *coreglib.Object) *CustomSorter {
	return &CustomSorter{
		Sorter: Sorter{
			Object: obj,
		},
	}
}

func marshalCustomSorter(p uintptr) (interface{}, error) {
	return wrapCustomSorter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCustomSorter creates a new GtkSorter that works by calling sort_func to
// compare items.
//
// If sort_func is NULL, all items are considered equal.
//
// The function takes the following parameters:
//
//    - sortFunc (optional): GCompareDataFunc to use for sorting.
//
// The function returns the following values:
//
//    - customSorter: new GtkCustomSorter.
//
func NewCustomSorter(sortFunc glib.CompareDataFunc) *CustomSorter {
	var _args [3]girepository.Argument

	if sortFunc != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[0])) = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
		_args[1] = C.gpointer(gbox.Assign(sortFunc))
		_args[2] = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_info := girepository.MustFind("Gtk", "CustomSorter")
	_gret := _info.InvokeClassMethod("new_CustomSorter", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(sortFunc)

	var _customSorter *CustomSorter // out

	_customSorter = wrapCustomSorter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _customSorter
}

// SetSortFunc sets (or unsets) the function used for sorting items.
//
// If sort_func is NULL, all items are considered equal.
//
// If the sort func changes its sorting behavior, gtk_sorter_changed() needs to
// be called.
//
// If a previous function was set, its user_destroy will be called now.
//
// The function takes the following parameters:
//
//    - sortFunc (optional): function to sort items.
//
func (self *CustomSorter) SetSortFunc(sortFunc glib.CompareDataFunc) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if sortFunc != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
		_args[2] = C.gpointer(gbox.Assign(sortFunc))
		_args[3] = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_info := girepository.MustFind("Gtk", "CustomSorter")
	_info.InvokeClassMethod("set_sort_func", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(sortFunc)
}

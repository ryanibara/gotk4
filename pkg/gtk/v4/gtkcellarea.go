// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
// extern GtkCellAreaContext* _gotk4_gtk4_CellAreaClass_copy_context(GtkCellArea*, GtkCellAreaContext*);
// extern GtkCellAreaContext* _gotk4_gtk4_CellAreaClass_create_context(GtkCellArea*);
// extern GtkSizeRequestMode _gotk4_gtk4_CellAreaClass_get_request_mode(GtkCellArea*);
// extern gboolean _gotk4_gtk4_CellAllocCallback(GtkCellRenderer*, GdkRectangle*, GdkRectangle*, gpointer);
// extern gboolean _gotk4_gtk4_CellAreaClass_activate(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GdkRectangle*, GtkCellRendererState, gboolean);
// extern gboolean _gotk4_gtk4_CellAreaClass_focus(GtkCellArea*, GtkDirectionType);
// extern gboolean _gotk4_gtk4_CellAreaClass_is_activatable(GtkCellArea*);
// extern gboolean _gotk4_gtk4_CellCallback(GtkCellRenderer*, gpointer);
// extern int _gotk4_gtk4_CellAreaClass_event(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GdkEvent*, GdkRectangle*, GtkCellRendererState);
// extern void _gotk4_gtk4_CellAreaClass_add(GtkCellArea*, GtkCellRenderer*);
// extern void _gotk4_gtk4_CellAreaClass_apply_attributes(GtkCellArea*, GtkTreeModel*, GtkTreeIter*, gboolean, gboolean);
// extern void _gotk4_gtk4_CellAreaClass_get_preferred_height(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int*, int*);
// extern void _gotk4_gtk4_CellAreaClass_get_preferred_height_for_width(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int, int*, int*);
// extern void _gotk4_gtk4_CellAreaClass_get_preferred_width(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int*, int*);
// extern void _gotk4_gtk4_CellAreaClass_get_preferred_width_for_height(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int, int*, int*);
// extern void _gotk4_gtk4_CellAreaClass_remove(GtkCellArea*, GtkCellRenderer*);
// extern void _gotk4_gtk4_CellAreaClass_snapshot(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GtkSnapshot*, GdkRectangle*, GdkRectangle*, GtkCellRendererState, gboolean);
// extern void _gotk4_gtk4_CellArea_ConnectAddEditable(gpointer, GtkCellRenderer*, GtkCellEditable*, GdkRectangle*, gchar*, guintptr);
// extern void _gotk4_gtk4_CellArea_ConnectApplyAttributes(gpointer, GtkTreeModel*, GtkTreeIter*, gboolean, gboolean, guintptr);
// extern void _gotk4_gtk4_CellArea_ConnectFocusChanged(gpointer, GtkCellRenderer*, gchar*, guintptr);
// extern void _gotk4_gtk4_CellArea_ConnectRemoveEditable(gpointer, GtkCellRenderer*, GtkCellEditable*, guintptr);
import "C"

// glib.Type values for gtkcellarea.go.
var GTypeCellArea = externglib.Type(C.gtk_cell_area_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeCellArea, F: marshalCellArea},
	})
}

// CellAllocCallback: type of the callback functions used for iterating over the
// cell renderers and their allocated areas inside a CellArea, see
// gtk_cell_area_foreach_alloc().
type CellAllocCallback func(renderer CellRendererer, cellArea, cellBackground *gdk.Rectangle) (ok bool)

//export _gotk4_gtk4_CellAllocCallback
func _gotk4_gtk4_CellAllocCallback(arg1 *C.GtkCellRenderer, arg2 *C.GdkRectangle, arg3 *C.GdkRectangle, arg4 C.gpointer) (cret C.gboolean) {
	var fn CellAllocCallback
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CellAllocCallback)
	}

	var _renderer CellRendererer       // out
	var _cellArea *gdk.Rectangle       // out
	var _cellBackground *gdk.Rectangle // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_cellBackground = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := fn(_renderer, _cellArea, _cellBackground)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// CellCallback: type of the callback functions used for iterating over the cell
// renderers of a CellArea, see gtk_cell_area_foreach().
type CellCallback func(renderer CellRendererer) (ok bool)

//export _gotk4_gtk4_CellCallback
func _gotk4_gtk4_CellCallback(arg1 *C.GtkCellRenderer, arg2 C.gpointer) (cret C.gboolean) {
	var fn CellCallback
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(CellCallback)
	}

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	ok := fn(_renderer)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// CellAreaOverrider contains methods that are overridable.
type CellAreaOverrider interface {
	externglib.Objector
	// Activate activates area, usually by activating the currently focused
	// cell, however some subclasses which embed widgets in the area can also
	// activate a widget if it currently has the focus.
	//
	// The function takes the following parameters:
	//
	//    - context in context with the current row data.
	//    - widget that area is rendering on.
	//    - cellArea: size and location of area relative to widget’s allocation.
	//    - flags flags for area for this row of data.
	//    - editOnly: if TRUE then only cell renderers that are
	//      GTK_CELL_RENDERER_MODE_EDITABLE will be activated.
	//
	// The function returns the following values:
	//
	//    - ok: whether area was successfully activated.
	//
	Activate(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	// Add adds renderer to area with the default child cell properties.
	//
	// The function takes the following parameters:
	//
	//    - renderer to add to area.
	//
	Add(renderer CellRendererer)
	// ApplyAttributes applies any connected attributes to the renderers in area
	// by pulling the values from tree_model.
	//
	// The function takes the following parameters:
	//
	//    - treeModel to pull values from.
	//    - iter in tree_model to apply values for.
	//    - isExpander: whether iter has children.
	//    - isExpanded: whether iter is expanded in the view and children are
	//      visible.
	//
	ApplyAttributes(treeModel TreeModelOverrider, iter *TreeIter, isExpander, isExpanded bool)
	// CopyContext: this is sometimes needed for cases where rows need to share
	// alignments in one orientation but may be separately grouped in the
	// opposing orientation.
	//
	// For instance, IconView creates all icons (rows) to have the same width
	// and the cells theirin to have the same horizontal alignments. However
	// each row of icons may have a separate collective height. IconView uses
	// this to request the heights of each row based on a context which was
	// already used to request all the row widths that are to be displayed.
	//
	// The function takes the following parameters:
	//
	//    - context to copy.
	//
	// The function returns the following values:
	//
	//    - cellAreaContext: newly created CellAreaContext copy of context.
	//
	CopyContext(context *CellAreaContext) *CellAreaContext
	// CreateContext creates a CellAreaContext to be used with area for all
	// purposes. CellAreaContext stores geometry information for rows for which
	// it was operated on, it is important to use the same context for the same
	// row of data at all times (i.e. one should render and handle events with
	// the same CellAreaContext which was used to request the size of those rows
	// of data).
	//
	// The function returns the following values:
	//
	//    - cellAreaContext: newly created CellAreaContext which can be used with
	//      area.
	//
	CreateContext() *CellAreaContext
	// Event delegates event handling to a CellArea.
	//
	// The function takes the following parameters:
	//
	//    - context for this row of data.
	//    - widget that area is rendering to.
	//    - event to handle.
	//    - cellArea: widget relative coordinates for area.
	//    - flags for area in this row.
	//
	// The function returns the following values:
	//
	//    - gint: TRUE if the event was handled by area.
	//
	Event(context *CellAreaContext, widget Widgetter, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) int
	// Focus: this should be called by the area’s owning layout widget when
	// focus is to be passed to area, or moved within area for a given direction
	// and row data.
	//
	// Implementing CellArea classes should implement this method to receive and
	// navigate focus in its own way particular to how it lays out cells.
	//
	// The function takes the following parameters:
	//
	//    - direction: DirectionType.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if focus remains inside area as a result of this call.
	//
	Focus(direction DirectionType) bool
	// PreferredHeight retrieves a cell area’s initial minimum and natural
	// height.
	//
	// area will store some geometrical information in context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the minimum_height and natural_height of this call but
	// rather to consult gtk_cell_area_context_get_preferred_height() after a
	// series of requests.
	//
	// The function takes the following parameters:
	//
	//    - context to perform this request with.
	//    - widget where area will be rendering.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location to store the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location to store the natural height, or
	//      NULL.
	//
	PreferredHeight(context *CellAreaContext, widget Widgetter) (minimumHeight int, naturalHeight int)
	// PreferredHeightForWidth retrieves a cell area’s minimum and natural
	// height if it would be given the specified width.
	//
	// area stores some geometrical information in context along the way while
	// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_width() requests with context first
	// and then call gtk_cell_area_get_preferred_height_for_width() on each cell
	// area individually to get the height for width of each fully requested
	// row.
	//
	// If at some point, the width of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_width() again and then the
	// full width of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_width().
	//
	// The function takes the following parameters:
	//
	//    - context which has already been requested for widths.
	//    - widget where area will be rendering.
	//    - width for which to check the height of this area.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location to store the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location to store the natural height, or
	//      NULL.
	//
	PreferredHeightForWidth(context *CellAreaContext, widget Widgetter, width int) (minimumHeight int, naturalHeight int)
	// PreferredWidth retrieves a cell area’s initial minimum and natural width.
	//
	// area will store some geometrical information in context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the minimum_width and natural_width of this call but
	// rather to consult gtk_cell_area_context_get_preferred_width() after a
	// series of requests.
	//
	// The function takes the following parameters:
	//
	//    - context to perform this request with.
	//    - widget where area will be rendering.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location to store the minimum width, or
	//      NULL.
	//    - naturalWidth (optional): location to store the natural width, or
	//      NULL.
	//
	PreferredWidth(context *CellAreaContext, widget Widgetter) (minimumWidth int, naturalWidth int)
	// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
	// if it would be given the specified height.
	//
	// area stores some geometrical information in context along the way while
	// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_height() requests with context
	// first and then call gtk_cell_area_get_preferred_width_for_height() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the height of a single row changes, it should be
	// requested with gtk_cell_area_get_preferred_height() again and then the
	// full height of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_height().
	//
	// The function takes the following parameters:
	//
	//    - context which has already been requested for widths.
	//    - widget where area will be rendering.
	//    - height for which to check the width of this area.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location to store the minimum width, or
	//      NULL.
	//    - naturalWidth (optional): location to store the natural width, or
	//      NULL.
	//
	PreferredWidthForHeight(context *CellAreaContext, widget Widgetter, height int) (minimumWidth int, naturalWidth int)
	// RequestMode gets whether the area prefers a height-for-width layout or a
	// width-for-height layout.
	//
	// The function returns the following values:
	//
	//    - sizeRequestMode preferred by area.
	//
	RequestMode() SizeRequestMode
	// IsActivatable returns whether the area can do anything when activated,
	// after applying new attributes to area.
	//
	// The function returns the following values:
	//
	//    - ok: whether area can do anything when activated.
	//
	IsActivatable() bool
	// Remove removes renderer from area.
	//
	// The function takes the following parameters:
	//
	//    - renderer to remove from area.
	//
	Remove(renderer CellRendererer)
	// Snapshot snapshots area’s cells according to area’s layout onto at the
	// given coordinates.
	//
	// The function takes the following parameters:
	//
	//    - context for this row of data.
	//    - widget that area is rendering to.
	//    - snapshot to draw to.
	//    - backgroundArea: widget relative coordinates for area’s background.
	//    - cellArea: widget relative coordinates for area.
	//    - flags for area in this row.
	//    - paintFocus: whether area should paint focus on focused cells for
	//      focused rows or not.
	//
	Snapshot(context *CellAreaContext, widget Widgetter, snapshot *Snapshot, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
}

// WrapCellAreaOverrider wraps the CellAreaOverrider
// interface implementation to access the instance methods.
func WrapCellAreaOverrider(obj CellAreaOverrider) *CellArea {
	return wrapCellArea(externglib.BaseObject(obj))
}

// CellArea: abstract class for laying out GtkCellRenderers
//
// The CellArea is an abstract class for CellLayout widgets (also referred to as
// "layouting widgets") to interface with an arbitrary number of CellRenderers
// and interact with the user for a given TreeModel row.
//
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
//
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
//
//
// Requesting area sizes
//
// As outlined in [GtkWidget’s geometry management
// section][geometry-management], GTK uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
//
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
//
// It’s also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear “columnized” inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
//
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, it’s important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
//
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      int         focus_row;
//      gboolean    have_focus = FALSE;
//
//      focus_row = priv->focus_row;
//
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
//
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
//
// Cell Properties
//
// The CellArea introduces cell properties for CellRenderers. This provides some
// general interfaces for defining the relationship cell areas have with their
// cells. For instance in a CellAreaBox a cell might “expand” and receive extra
// space when the area is allocated more than its full natural request, or a
// cell might be configured to “align” with adjacent rows which were requested
// and rendered with the same CellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
type CellArea struct {
	_ [0]func() // equal guard
	externglib.InitiallyUnowned

	*externglib.Object
	Buildable
	CellLayout
}

var (
	_ externglib.Objector = (*CellArea)(nil)
)

// CellAreaer describes types inherited from class CellArea.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type CellAreaer interface {
	externglib.Objector
	baseCellArea() *CellArea
}

var _ CellAreaer = (*CellArea)(nil)

func classInitCellAreaer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkCellAreaClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkCellAreaClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface {
		Activate(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	}); ok {
		pclass.activate = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_activate)
	}

	if _, ok := goval.(interface{ Add(renderer CellRendererer) }); ok {
		pclass.add = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_add)
	}

	if _, ok := goval.(interface {
		ApplyAttributes(treeModel TreeModelOverrider, iter *TreeIter, isExpander, isExpanded bool)
	}); ok {
		pclass.apply_attributes = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_apply_attributes)
	}

	if _, ok := goval.(interface {
		CopyContext(context *CellAreaContext) *CellAreaContext
	}); ok {
		pclass.copy_context = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_copy_context)
	}

	if _, ok := goval.(interface{ CreateContext() *CellAreaContext }); ok {
		pclass.create_context = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_create_context)
	}

	if _, ok := goval.(interface {
		Event(context *CellAreaContext, widget Widgetter, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) int
	}); ok {
		pclass.event = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_event)
	}

	if _, ok := goval.(interface {
		Focus(direction DirectionType) bool
	}); ok {
		pclass.focus = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_focus)
	}

	if _, ok := goval.(interface {
		PreferredHeight(context *CellAreaContext, widget Widgetter) (minimumHeight int, naturalHeight int)
	}); ok {
		pclass.get_preferred_height = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_preferred_height)
	}

	if _, ok := goval.(interface {
		PreferredHeightForWidth(context *CellAreaContext, widget Widgetter, width int) (minimumHeight int, naturalHeight int)
	}); ok {
		pclass.get_preferred_height_for_width = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_preferred_height_for_width)
	}

	if _, ok := goval.(interface {
		PreferredWidth(context *CellAreaContext, widget Widgetter) (minimumWidth int, naturalWidth int)
	}); ok {
		pclass.get_preferred_width = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_preferred_width)
	}

	if _, ok := goval.(interface {
		PreferredWidthForHeight(context *CellAreaContext, widget Widgetter, height int) (minimumWidth int, naturalWidth int)
	}); ok {
		pclass.get_preferred_width_for_height = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_preferred_width_for_height)
	}

	if _, ok := goval.(interface{ RequestMode() SizeRequestMode }); ok {
		pclass.get_request_mode = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_request_mode)
	}

	if _, ok := goval.(interface{ IsActivatable() bool }); ok {
		pclass.is_activatable = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_is_activatable)
	}

	if _, ok := goval.(interface{ Remove(renderer CellRendererer) }); ok {
		pclass.remove = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_remove)
	}

	if _, ok := goval.(interface {
		Snapshot(context *CellAreaContext, widget Widgetter, snapshot *Snapshot, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
	}); ok {
		pclass.snapshot = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_snapshot)
	}
}

//export _gotk4_gtk4_CellAreaClass_activate
func _gotk4_gtk4_CellAreaClass_activate(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GdkRectangle, arg4 C.GtkCellRendererState, arg5 C.gboolean) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Activate(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	})

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _cellArea *gdk.Rectangle  // out
	var _flags CellRendererState  // out
	var _editOnly bool            // out

	_context = wrapCellAreaContext(externglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_flags = CellRendererState(arg4)
	if arg5 != 0 {
		_editOnly = true
	}

	ok := iface.Activate(_context, _widget, _cellArea, _flags, _editOnly)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_CellAreaClass_add
func _gotk4_gtk4_CellAreaClass_add(arg0 *C.GtkCellArea, arg1 *C.GtkCellRenderer) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Add(renderer CellRendererer) })

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	iface.Add(_renderer)
}

//export _gotk4_gtk4_CellAreaClass_apply_attributes
func _gotk4_gtk4_CellAreaClass_apply_attributes(arg0 *C.GtkCellArea, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gboolean, arg4 C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ApplyAttributes(treeModel TreeModelOverrider, iter *TreeIter, isExpander, isExpanded bool)
	})

	var _treeModel TreeModelOverrider // out
	var _iter *TreeIter               // out
	var _isExpander bool              // out
	var _isExpanded bool              // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(TreeModelOverrider)
			return ok
		})
		rv, ok := casted.(TreeModelOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_treeModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	if arg3 != 0 {
		_isExpander = true
	}
	if arg4 != 0 {
		_isExpanded = true
	}

	iface.ApplyAttributes(_treeModel, _iter, _isExpander, _isExpanded)
}

//export _gotk4_gtk4_CellAreaClass_copy_context
func _gotk4_gtk4_CellAreaClass_copy_context(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext) (cret *C.GtkCellAreaContext) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		CopyContext(context *CellAreaContext) *CellAreaContext
	})

	var _context *CellAreaContext // out

	_context = wrapCellAreaContext(externglib.Take(unsafe.Pointer(arg1)))

	cellAreaContext := iface.CopyContext(_context)

	cret = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(cellAreaContext).Native()))
	C.g_object_ref(C.gpointer(externglib.InternObject(cellAreaContext).Native()))

	return cret
}

//export _gotk4_gtk4_CellAreaClass_create_context
func _gotk4_gtk4_CellAreaClass_create_context(arg0 *C.GtkCellArea) (cret *C.GtkCellAreaContext) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CreateContext() *CellAreaContext })

	cellAreaContext := iface.CreateContext()

	cret = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(cellAreaContext).Native()))
	C.g_object_ref(C.gpointer(externglib.InternObject(cellAreaContext).Native()))

	return cret
}

//export _gotk4_gtk4_CellAreaClass_event
func _gotk4_gtk4_CellAreaClass_event(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GdkEvent, arg4 *C.GdkRectangle, arg5 C.GtkCellRendererState) (cret C.int) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Event(context *CellAreaContext, widget Widgetter, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) int
	})

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _event gdk.Eventer        // out
	var _cellArea *gdk.Rectangle  // out
	var _flags CellRendererState  // out

	_context = wrapCellAreaContext(externglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gdk.Eventer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(gdk.Eventer)
			return ok
		})
		rv, ok := casted.(gdk.Eventer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Eventer")
		}
		_event = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_flags = CellRendererState(arg5)

	gint := iface.Event(_context, _widget, _event, _cellArea, _flags)

	cret = C.int(gint)

	return cret
}

//export _gotk4_gtk4_CellAreaClass_focus
func _gotk4_gtk4_CellAreaClass_focus(arg0 *C.GtkCellArea, arg1 C.GtkDirectionType) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Focus(direction DirectionType) bool
	})

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := iface.Focus(_direction)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_CellAreaClass_get_preferred_height
func _gotk4_gtk4_CellAreaClass_get_preferred_height(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.int, arg4 *C.int) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeight(context *CellAreaContext, widget Widgetter) (minimumHeight int, naturalHeight int)
	})

	var _context *CellAreaContext // out
	var _widget Widgetter         // out

	_context = wrapCellAreaContext(externglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumHeight, naturalHeight := iface.PreferredHeight(_context, _widget)

	*arg3 = C.int(minimumHeight)
	*arg4 = C.int(naturalHeight)
}

//export _gotk4_gtk4_CellAreaClass_get_preferred_height_for_width
func _gotk4_gtk4_CellAreaClass_get_preferred_height_for_width(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 C.int, arg4 *C.int, arg5 *C.int) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeightForWidth(context *CellAreaContext, widget Widgetter, width int) (minimumHeight int, naturalHeight int)
	})

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _width int                // out

	_context = wrapCellAreaContext(externglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int(arg3)

	minimumHeight, naturalHeight := iface.PreferredHeightForWidth(_context, _widget, _width)

	*arg4 = C.int(minimumHeight)
	*arg5 = C.int(naturalHeight)
}

//export _gotk4_gtk4_CellAreaClass_get_preferred_width
func _gotk4_gtk4_CellAreaClass_get_preferred_width(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.int, arg4 *C.int) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredWidth(context *CellAreaContext, widget Widgetter) (minimumWidth int, naturalWidth int)
	})

	var _context *CellAreaContext // out
	var _widget Widgetter         // out

	_context = wrapCellAreaContext(externglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumWidth, naturalWidth := iface.PreferredWidth(_context, _widget)

	*arg3 = C.int(minimumWidth)
	*arg4 = C.int(naturalWidth)
}

//export _gotk4_gtk4_CellAreaClass_get_preferred_width_for_height
func _gotk4_gtk4_CellAreaClass_get_preferred_width_for_height(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 C.int, arg4 *C.int, arg5 *C.int) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredWidthForHeight(context *CellAreaContext, widget Widgetter, height int) (minimumWidth int, naturalWidth int)
	})

	var _context *CellAreaContext // out
	var _widget Widgetter         // out
	var _height int               // out

	_context = wrapCellAreaContext(externglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int(arg3)

	minimumWidth, naturalWidth := iface.PreferredWidthForHeight(_context, _widget, _height)

	*arg4 = C.int(minimumWidth)
	*arg5 = C.int(naturalWidth)
}

//export _gotk4_gtk4_CellAreaClass_get_request_mode
func _gotk4_gtk4_CellAreaClass_get_request_mode(arg0 *C.GtkCellArea) (cret C.GtkSizeRequestMode) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ RequestMode() SizeRequestMode })

	sizeRequestMode := iface.RequestMode()

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk4_CellAreaClass_is_activatable
func _gotk4_gtk4_CellAreaClass_is_activatable(arg0 *C.GtkCellArea) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ IsActivatable() bool })

	ok := iface.IsActivatable()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_CellAreaClass_remove
func _gotk4_gtk4_CellAreaClass_remove(arg0 *C.GtkCellArea, arg1 *C.GtkCellRenderer) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Remove(renderer CellRendererer) })

	var _renderer CellRendererer // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}

	iface.Remove(_renderer)
}

//export _gotk4_gtk4_CellAreaClass_snapshot
func _gotk4_gtk4_CellAreaClass_snapshot(arg0 *C.GtkCellArea, arg1 *C.GtkCellAreaContext, arg2 *C.GtkWidget, arg3 *C.GtkSnapshot, arg4 *C.GdkRectangle, arg5 *C.GdkRectangle, arg6 C.GtkCellRendererState, arg7 C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Snapshot(context *CellAreaContext, widget Widgetter, snapshot *Snapshot, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
	})

	var _context *CellAreaContext      // out
	var _widget Widgetter              // out
	var _snapshot *Snapshot            // out
	var _backgroundArea *gdk.Rectangle // out
	var _cellArea *gdk.Rectangle       // out
	var _flags CellRendererState       // out
	var _paintFocus bool               // out

	_context = wrapCellAreaContext(externglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_snapshot = wrapSnapshot(externglib.Take(unsafe.Pointer(arg3)))
	_backgroundArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg5)))
	_flags = CellRendererState(arg6)
	if arg7 != 0 {
		_paintFocus = true
	}

	iface.Snapshot(_context, _widget, _snapshot, _backgroundArea, _cellArea, _flags, _paintFocus)
}

func wrapCellArea(obj *externglib.Object) *CellArea {
	return &CellArea{
		InitiallyUnowned: externglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
		CellLayout: CellLayout{
			Object: obj,
		},
	}
}

func marshalCellArea(p uintptr) (interface{}, error) {
	return wrapCellArea(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (area *CellArea) baseCellArea() *CellArea {
	return area
}

// BaseCellArea returns the underlying base object from the
// interface.
func BaseCellArea(obj CellAreaer) *CellArea {
	return obj.baseCellArea()
}

//export _gotk4_gtk4_CellArea_ConnectAddEditable
func _gotk4_gtk4_CellArea_ConnectAddEditable(arg0 C.gpointer, arg1 *C.GtkCellRenderer, arg2 *C.GtkCellEditable, arg3 *C.GdkRectangle, arg4 *C.gchar, arg5 C.guintptr) {
	var f func(renderer CellRendererer, editable CellEditableOverrider, cellArea *gdk.Rectangle, path string)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(renderer CellRendererer, editable CellEditableOverrider, cellArea *gdk.Rectangle, path string))
	}

	var _renderer CellRendererer        // out
	var _editable CellEditableOverrider // out
	var _cellArea *gdk.Rectangle        // out
	var _path string                    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellEditableOverrider)
			return ok
		})
		rv, ok := casted.(CellEditableOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))

	f(_renderer, _editable, _cellArea, _path)
}

// ConnectAddEditable indicates that editing has started on renderer and that
// editable should be added to the owning cell-layouting widget at cell_area.
func (area *CellArea) ConnectAddEditable(f func(renderer CellRendererer, editable CellEditableOverrider, cellArea *gdk.Rectangle, path string)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(area, "add-editable", false, unsafe.Pointer(C._gotk4_gtk4_CellArea_ConnectAddEditable), f)
}

//export _gotk4_gtk4_CellArea_ConnectApplyAttributes
func _gotk4_gtk4_CellArea_ConnectApplyAttributes(arg0 C.gpointer, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gboolean, arg4 C.gboolean, arg5 C.guintptr) {
	var f func(model TreeModelOverrider, iter *TreeIter, isExpander, isExpanded bool)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(model TreeModelOverrider, iter *TreeIter, isExpander, isExpanded bool))
	}

	var _model TreeModelOverrider // out
	var _iter *TreeIter           // out
	var _isExpander bool          // out
	var _isExpanded bool          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(TreeModelOverrider)
			return ok
		})
		rv, ok := casted.(TreeModelOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	if arg3 != 0 {
		_isExpander = true
	}
	if arg4 != 0 {
		_isExpanded = true
	}

	f(_model, _iter, _isExpander, _isExpanded)
}

// ConnectApplyAttributes: this signal is emitted whenever applying attributes
// to area from model.
func (area *CellArea) ConnectApplyAttributes(f func(model TreeModelOverrider, iter *TreeIter, isExpander, isExpanded bool)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(area, "apply-attributes", false, unsafe.Pointer(C._gotk4_gtk4_CellArea_ConnectApplyAttributes), f)
}

//export _gotk4_gtk4_CellArea_ConnectFocusChanged
func _gotk4_gtk4_CellArea_ConnectFocusChanged(arg0 C.gpointer, arg1 *C.GtkCellRenderer, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(renderer CellRendererer, path string)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(renderer CellRendererer, path string))
	}

	var _renderer CellRendererer // out
	var _path string             // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_renderer, _path)
}

// ConnectFocusChanged indicates that focus changed on this area. This signal is
// emitted either as a result of focus handling or event handling.
//
// It's possible that the signal is emitted even if the currently focused
// renderer did not change, this is because focus may change to the same
// renderer in the same cell area for a different row of data.
func (area *CellArea) ConnectFocusChanged(f func(renderer CellRendererer, path string)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(area, "focus-changed", false, unsafe.Pointer(C._gotk4_gtk4_CellArea_ConnectFocusChanged), f)
}

//export _gotk4_gtk4_CellArea_ConnectRemoveEditable
func _gotk4_gtk4_CellArea_ConnectRemoveEditable(arg0 C.gpointer, arg1 *C.GtkCellRenderer, arg2 *C.GtkCellEditable, arg3 C.guintptr) {
	var f func(renderer CellRendererer, editable CellEditableOverrider)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(renderer CellRendererer, editable CellEditableOverrider))
	}

	var _renderer CellRendererer        // out
	var _editable CellEditableOverrider // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_renderer = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellEditableOverrider)
			return ok
		})
		rv, ok := casted.(CellEditableOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}

	f(_renderer, _editable)
}

// ConnectRemoveEditable indicates that editing finished on renderer and that
// editable should be removed from the owning cell-layouting widget.
func (area *CellArea) ConnectRemoveEditable(f func(renderer CellRendererer, editable CellEditableOverrider)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(area, "remove-editable", false, unsafe.Pointer(C._gotk4_gtk4_CellArea_ConnectRemoveEditable), f)
}

// Activate activates area, usually by activating the currently focused cell,
// however some subclasses which embed widgets in the area can also activate a
// widget if it currently has the focus.
//
// The function takes the following parameters:
//
//    - context in context with the current row data.
//    - widget that area is rendering on.
//    - cellArea: size and location of area relative to widget’s allocation.
//    - flags flags for area for this row of data.
//    - editOnly: if TRUE then only cell renderers that are
//      GTK_CELL_RENDERER_MODE_EDITABLE will be activated.
//
// The function returns the following values:
//
//    - ok: whether area was successfully activated.
//
func (area *CellArea) Activate(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 C.GtkCellRendererState // out
	var _arg5 C.gboolean             // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = C.GtkCellRendererState(flags)
	if editOnly {
		_arg5 = C.TRUE
	}

	_cret = C.gtk_cell_area_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(editOnly)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateCell: this is used by CellArea subclasses when handling events to
// activate cells, the base CellArea class activates cells for keyboard events
// for free in its own GtkCellArea->activate() implementation.
//
// The function takes the following parameters:
//
//    - widget that area is rendering onto.
//    - renderer in area to activate.
//    - event for which cell activation should occur.
//    - cellArea in widget relative coordinates of renderer for the current row.
//    - flags for renderer.
//
// The function returns the following values:
//
//    - ok: whether cell activation was successful.
//
func (area *CellArea) ActivateCell(widget Widgetter, renderer CellRendererer, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 *C.GtkCellRenderer     // out
	var _arg3 *C.GdkEvent            // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg3 = (*C.GdkEvent)(unsafe.Pointer(externglib.InternObject(event).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg5 = C.GtkCellRendererState(flags)

	_cret = C.gtk_cell_area_activate_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(event)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Add adds renderer to area with the default child cell properties.
//
// The function takes the following parameters:
//
//    - renderer to add to area.
//
func (area *CellArea) Add(renderer CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))

	C.gtk_cell_area_add(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
}

// AddFocusSibling adds sibling to renderer’s focusable area, focus will be
// drawn around renderer and all of its siblings if renderer can focus for a
// given row.
//
// Events handled by focus siblings can also activate the given focusable
// renderer.
//
// The function takes the following parameters:
//
//    - renderer expected to have focus.
//    - sibling to add to renderer’s focus area.
//
func (area *CellArea) AddFocusSibling(renderer, sibling CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(sibling).Native()))

	C.gtk_cell_area_add_focus_sibling(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(sibling)
}

// ApplyAttributes applies any connected attributes to the renderers in area by
// pulling the values from tree_model.
//
// The function takes the following parameters:
//
//    - treeModel to pull values from.
//    - iter in tree_model to apply values for.
//    - isExpander: whether iter has children.
//    - isExpanded: whether iter is expanded in the view and children are
//      visible.
//
func (area *CellArea) ApplyAttributes(treeModel TreeModelOverrider, iter *TreeIter, isExpander, isExpanded bool) {
	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.gboolean      // out
	var _arg4 C.gboolean      // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if isExpander {
		_arg3 = C.TRUE
	}
	if isExpanded {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_apply_attributes(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(isExpander)
	runtime.KeepAlive(isExpanded)
}

// AttributeConnect connects an attribute to apply values from column for the
// TreeModel in use.
//
// The function takes the following parameters:
//
//    - renderer to connect an attribute for.
//    - attribute name.
//    - column column to fetch attribute values from.
//
func (area *CellArea) AttributeConnect(renderer CellRendererer, attribute string, column int) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 C.int              // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(column)

	C.gtk_cell_area_attribute_connect(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(column)
}

// AttributeDisconnect disconnects attribute for the renderer in area so that
// attribute will no longer be updated with values from the model.
//
// The function takes the following parameters:
//
//    - renderer to disconnect an attribute for.
//    - attribute name.
//
func (area *CellArea) AttributeDisconnect(renderer CellRendererer, attribute string) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_cell_area_attribute_disconnect(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(attribute)
}

// AttributeGetColumn returns the model column that an attribute has been mapped
// to, or -1 if the attribute is not mapped.
//
// The function takes the following parameters:
//
//    - renderer: CellRenderer.
//    - attribute on the renderer.
//
// The function returns the following values:
//
//    - gint: model column, or -1.
//
func (area *CellArea) AttributeGetColumn(renderer CellRendererer, attribute string) int {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _cret C.int              // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_cell_area_attribute_get_column(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(attribute)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CellGetProperty gets the value of a cell property for renderer in area.
//
// The function takes the following parameters:
//
//    - renderer inside area.
//    - propertyName: name of the property to get.
//    - value: location to return the value.
//
func (area *CellArea) CellGetProperty(renderer CellRendererer, propertyName string, value *externglib.Value) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 *C.GValue          // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_cell_area_cell_get_property(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// CellSetProperty sets a cell property for renderer in area.
//
// The function takes the following parameters:
//
//    - renderer inside area.
//    - propertyName: name of the cell property to set.
//    - value to set the cell property to.
//
func (area *CellArea) CellSetProperty(renderer CellRendererer, propertyName string, value *externglib.Value) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 *C.GValue          // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_cell_area_cell_set_property(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// CopyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the opposing
// orientation.
//
// For instance, IconView creates all icons (rows) to have the same width and
// the cells theirin to have the same horizontal alignments. However each row of
// icons may have a separate collective height. IconView uses this to request
// the heights of each row based on a context which was already used to request
// all the row widths that are to be displayed.
//
// The function takes the following parameters:
//
//    - context to copy.
//
// The function returns the following values:
//
//    - cellAreaContext: newly created CellAreaContext copy of context.
//
func (area *CellArea) CopyContext(context *CellAreaContext) *CellAreaContext {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))

	_cret = C.gtk_cell_area_copy_context(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)

	var _cellAreaContext *CellAreaContext // out

	_cellAreaContext = wrapCellAreaContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cellAreaContext
}

// CreateContext creates a CellAreaContext to be used with area for all
// purposes. CellAreaContext stores geometry information for rows for which it
// was operated on, it is important to use the same context for the same row of
// data at all times (i.e. one should render and handle events with the same
// CellAreaContext which was used to request the size of those rows of data).
//
// The function returns the following values:
//
//    - cellAreaContext: newly created CellAreaContext which can be used with
//      area.
//
func (area *CellArea) CreateContext() *CellAreaContext {
	var _arg0 *C.GtkCellArea        // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_create_context(_arg0)
	runtime.KeepAlive(area)

	var _cellAreaContext *CellAreaContext // out

	_cellAreaContext = wrapCellAreaContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cellAreaContext
}

// Event delegates event handling to a CellArea.
//
// The function takes the following parameters:
//
//    - context for this row of data.
//    - widget that area is rendering to.
//    - event to handle.
//    - cellArea: widget relative coordinates for area.
//    - flags for area in this row.
//
// The function returns the following values:
//
//    - gint: TRUE if the event was handled by area.
//
func (area *CellArea) Event(context *CellAreaContext, widget Widgetter, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) int {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkEvent            // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out
	var _cret C.int                  // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkEvent)(unsafe.Pointer(externglib.InternObject(event).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg5 = C.GtkCellRendererState(flags)

	_cret = C.gtk_cell_area_event(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Focus: this should be called by the area’s owning layout widget when focus is
// to be passed to area, or moved within area for a given direction and row
// data.
//
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
//
// The function takes the following parameters:
//
//    - direction: DirectionType.
//
// The function returns the following values:
//
//    - ok: TRUE if focus remains inside area as a result of this call.
//
func (area *CellArea) Focus(direction DirectionType) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_cell_area_focus(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEach calls callback for every CellRenderer in area.
//
// The function takes the following parameters:
//
//    - callback to call.
//
func (area *CellArea) ForEach(callback CellCallback) {
	var _arg0 *C.GtkCellArea    // out
	var _arg1 C.GtkCellCallback // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_CellCallback)
	_arg2 = C.gpointer(gbox.Assign(callback))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_cell_area_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(callback)
}

// ForEachAlloc calls callback for every CellRenderer in area with the allocated
// rectangle inside cell_area.
//
// The function takes the following parameters:
//
//    - context for this row of data.
//    - widget that area is rendering to.
//    - cellArea: widget relative coordinates and size for area.
//    - backgroundArea: widget relative coordinates of the background area.
//    - callback to call.
//
func (area *CellArea) ForEachAlloc(context *CellAreaContext, widget Widgetter, cellArea, backgroundArea *gdk.Rectangle, callback CellAllocCallback) {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellAllocCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*[0]byte)(C._gotk4_gtk4_CellAllocCallback)
	_arg6 = C.gpointer(gbox.Assign(callback))
	defer gbox.Delete(uintptr(_arg6))

	C.gtk_cell_area_foreach_alloc(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(callback)
}

// CellAllocation derives the allocation of renderer inside area if area were to
// be renderered in cell_area.
//
// The function takes the following parameters:
//
//    - context used to hold sizes for area.
//    - widget that area is rendering on.
//    - renderer to get the allocation for.
//    - cellArea: whole allocated area for area in widget for this row.
//
// The function returns the following values:
//
//    - allocation: where to store the allocation for renderer.
//
func (area *CellArea) CellAllocation(context *CellAreaContext, widget Widgetter, renderer CellRendererer, cellArea *gdk.Rectangle) *gdk.Rectangle {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 *C.GtkCellRenderer    // out
	var _arg4 *C.GdkRectangle       // out
	var _arg5 C.GdkRectangle        // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))

	C.gtk_cell_area_get_cell_allocation(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(cellArea)

	var _allocation *gdk.Rectangle // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg5))))

	return _allocation
}

// CellAtPosition gets the CellRenderer at x and y coordinates inside area and
// optionally returns the full cell allocation for it inside cell_area.
//
// The function takes the following parameters:
//
//    - context used to hold sizes for area.
//    - widget that area is rendering on.
//    - cellArea: whole allocated area for area in widget for this row.
//    - x position.
//    - y position.
//
// The function returns the following values:
//
//    - allocArea (optional): where to store the inner allocated area of the
//      returned cell renderer, or NULL.
//    - cellRenderer at x and y.
//
func (area *CellArea) CellAtPosition(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, x, y int) (*gdk.Rectangle, CellRendererer) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 *C.GdkRectangle       // out
	var _arg4 C.int                 // out
	var _arg5 C.int                 // out
	var _arg6 C.GdkRectangle        // in
	var _cret *C.GtkCellRenderer    // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = C.int(x)
	_arg5 = C.int(y)

	_cret = C.gtk_cell_area_get_cell_at_position(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _allocArea *gdk.Rectangle    // out
	var _cellRenderer CellRendererer // out

	_allocArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg6))))
	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_cellRenderer = rv
	}

	return _allocArea, _cellRenderer
}

// CurrentPathString gets the current TreePath string for the currently applied
// TreeIter, this is implicitly updated when gtk_cell_area_apply_attributes() is
// called and can be used to interact with renderers from CellArea subclasses.
//
// The function returns the following values:
//
//    - utf8: current TreePath string for the current attributes applied to area.
//      This string belongs to the area and should not be freed.
//
func (area *CellArea) CurrentPathString() string {
	var _arg0 *C.GtkCellArea // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_current_path_string(_arg0)
	runtime.KeepAlive(area)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EditWidget gets the CellEditable widget currently used to edit the currently
// edited cell.
//
// The function returns the following values:
//
//    - cellEditable: currently active CellEditable widget.
//
func (area *CellArea) EditWidget() CellEditableOverrider {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellEditable // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_edit_widget(_arg0)
	runtime.KeepAlive(area)

	var _cellEditable CellEditableOverrider // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellEditableOverrider)
			return ok
		})
		rv, ok := casted.(CellEditableOverrider)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_cellEditable = rv
	}

	return _cellEditable
}

// EditedCell gets the CellRenderer in area that is currently being edited.
//
// The function returns the following values:
//
//    - cellRenderer: currently edited CellRenderer.
//
func (area *CellArea) EditedCell() CellRendererer {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_edited_cell(_arg0)
	runtime.KeepAlive(area)

	var _cellRenderer CellRendererer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_cellRenderer = rv
	}

	return _cellRenderer
}

// FocusCell retrieves the currently focused cell for area.
//
// The function returns the following values:
//
//    - cellRenderer: currently focused cell in area.
//
func (area *CellArea) FocusCell() CellRendererer {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_focus_cell(_arg0)
	runtime.KeepAlive(area)

	var _cellRenderer CellRendererer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_cellRenderer = rv
	}

	return _cellRenderer
}

// FocusFromSibling gets the CellRenderer which is expected to be focusable for
// which renderer is, or may be a sibling.
//
// This is handy for CellArea subclasses when handling events, after determining
// the renderer at the event location it can then chose to activate the focus
// cell for which the event cell may have been a sibling.
//
// The function takes the following parameters:
//
//    - renderer: CellRenderer.
//
// The function returns the following values:
//
//    - cellRenderer (optional) for which renderer is a sibling, or NULL.
//
func (area *CellArea) FocusFromSibling(renderer CellRendererer) CellRendererer {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))

	_cret = C.gtk_cell_area_get_focus_from_sibling(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)

	var _cellRenderer CellRendererer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			_cellRenderer = rv
		}
	}

	return _cellRenderer
}

// FocusSiblings gets the focus sibling cell renderers for renderer.
//
// The function takes the following parameters:
//
//    - renderer expected to have focus.
//
// The function returns the following values:
//
//    - list of CellRenderers. The returned list is internal and should not be
//      freed.
//
func (area *CellArea) FocusSiblings(renderer CellRendererer) []CellRendererer {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret *C.GList           // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))

	_cret = C.gtk_cell_area_get_focus_siblings(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)

	var _list []CellRendererer // out

	_list = make([]CellRendererer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkCellRenderer)(v)
		var dst CellRendererer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.CellRendererer is nil")
			}

			object := externglib.Take(objptr)
			casted := object.WalkCast(func(obj externglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// PreferredHeight retrieves a cell area’s initial minimum and natural height.
//
// area will store some geometrical information in context along the way; when
// requesting sizes over an arbitrary number of rows, it’s not important to
// check the minimum_height and natural_height of this call but rather to
// consult gtk_cell_area_context_get_preferred_height() after a series of
// requests.
//
// The function takes the following parameters:
//
//    - context to perform this request with.
//    - widget where area will be rendering.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location to store the minimum height, or NULL.
//    - naturalHeight (optional): location to store the natural height, or NULL.
//
func (area *CellArea) PreferredHeight(context *CellAreaContext, widget Widgetter) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // in
	var _arg4 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))

	C.gtk_cell_area_get_preferred_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg3)
	_naturalHeight = int(_arg4)

	return _minimumHeight, _naturalHeight
}

// PreferredHeightForWidth retrieves a cell area’s minimum and natural height if
// it would be given the specified width.
//
// area stores some geometrical information in context along the way while
// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
// series of gtk_cell_area_get_preferred_width() requests with context first and
// then call gtk_cell_area_get_preferred_height_for_width() on each cell area
// individually to get the height for width of each fully requested row.
//
// If at some point, the width of a single row changes, it should be requested
// with gtk_cell_area_get_preferred_width() again and then the full width of the
// requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
//
// The function takes the following parameters:
//
//    - context which has already been requested for widths.
//    - widget where area will be rendering.
//    - width for which to check the height of this area.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location to store the minimum height, or NULL.
//    - naturalHeight (optional): location to store the natural height, or NULL.
//
func (area *CellArea) PreferredHeightForWidth(context *CellAreaContext, widget Widgetter, width int) (minimumHeight int, naturalHeight int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // out
	var _arg4 C.int                 // in
	var _arg5 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg3 = C.int(width)

	C.gtk_cell_area_get_preferred_height_for_width(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg4)
	_naturalHeight = int(_arg5)

	return _minimumHeight, _naturalHeight
}

// PreferredWidth retrieves a cell area’s initial minimum and natural width.
//
// area will store some geometrical information in context along the way; when
// requesting sizes over an arbitrary number of rows, it’s not important to
// check the minimum_width and natural_width of this call but rather to consult
// gtk_cell_area_context_get_preferred_width() after a series of requests.
//
// The function takes the following parameters:
//
//    - context to perform this request with.
//    - widget where area will be rendering.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location to store the minimum width, or NULL.
//    - naturalWidth (optional): location to store the natural width, or NULL.
//
func (area *CellArea) PreferredWidth(context *CellAreaContext, widget Widgetter) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // in
	var _arg4 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))

	C.gtk_cell_area_get_preferred_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg3)
	_naturalWidth = int(_arg4)

	return _minimumWidth, _naturalWidth
}

// PreferredWidthForHeight retrieves a cell area’s minimum and natural width if
// it would be given the specified height.
//
// area stores some geometrical information in context along the way while
// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
// series of gtk_cell_area_get_preferred_height() requests with context first
// and then call gtk_cell_area_get_preferred_width_for_height() on each cell
// area individually to get the height for width of each fully requested row.
//
// If at some point, the height of a single row changes, it should be requested
// with gtk_cell_area_get_preferred_height() again and then the full height of
// the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
//
// The function takes the following parameters:
//
//    - context which has already been requested for widths.
//    - widget where area will be rendering.
//    - height for which to check the width of this area.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location to store the minimum width, or NULL.
//    - naturalWidth (optional): location to store the natural width, or NULL.
//
func (area *CellArea) PreferredWidthForHeight(context *CellAreaContext, widget Widgetter, height int) (minimumWidth int, naturalWidth int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // out
	var _arg4 C.int                 // in
	var _arg5 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg3 = C.int(height)

	C.gtk_cell_area_get_preferred_width_for_height(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg4)
	_naturalWidth = int(_arg5)

	return _minimumWidth, _naturalWidth
}

// RequestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
//
// The function returns the following values:
//
//    - sizeRequestMode preferred by area.
//
func (area *CellArea) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkCellArea       // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_request_mode(_arg0)
	runtime.KeepAlive(area)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// HasRenderer checks if area contains renderer.
//
// The function takes the following parameters:
//
//    - renderer to check.
//
// The function returns the following values:
//
//    - ok: TRUE if renderer is in the area.
//
func (area *CellArea) HasRenderer(renderer CellRendererer) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))

	_cret = C.gtk_cell_area_has_renderer(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InnerCellArea: this is a convenience function for CellArea implementations to
// get the inner area where a given CellRenderer will be rendered. It removes
// any padding previously added by gtk_cell_area_request_renderer().
//
// The function takes the following parameters:
//
//    - widget that area is rendering onto.
//    - cellArea: widget relative coordinates where one of area’s cells is to be
//      placed.
//
// The function returns the following values:
//
//    - innerArea: return location for the inner cell area.
//
func (area *CellArea) InnerCellArea(widget Widgetter, cellArea *gdk.Rectangle) *gdk.Rectangle {
	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.GdkRectangle // out
	var _arg3 C.GdkRectangle  // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))

	C.gtk_cell_area_inner_cell_area(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(area)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)

	var _innerArea *gdk.Rectangle // out

	_innerArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _innerArea
}

// IsActivatable returns whether the area can do anything when activated, after
// applying new attributes to area.
//
// The function returns the following values:
//
//    - ok: whether area can do anything when activated.
//
func (area *CellArea) IsActivatable() bool {
	var _arg0 *C.GtkCellArea // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_is_activatable(_arg0)
	runtime.KeepAlive(area)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocusSibling returns whether sibling is one of renderer’s focus siblings
// (see gtk_cell_area_add_focus_sibling()).
//
// The function takes the following parameters:
//
//    - renderer expected to have focus.
//    - sibling to check against renderer’s sibling list.
//
// The function returns the following values:
//
//    - ok: TRUE if sibling is a focus sibling of renderer.
//
func (area *CellArea) IsFocusSibling(renderer, sibling CellRendererer) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(sibling).Native()))

	_cret = C.gtk_cell_area_is_focus_sibling(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(sibling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes renderer from area.
//
// The function takes the following parameters:
//
//    - renderer to remove from area.
//
func (area *CellArea) Remove(renderer CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))

	C.gtk_cell_area_remove(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
}

// RemoveFocusSibling removes sibling from renderer’s focus sibling list (see
// gtk_cell_area_add_focus_sibling()).
//
// The function takes the following parameters:
//
//    - renderer expected to have focus.
//    - sibling to remove from renderer’s focus area.
//
func (area *CellArea) RemoveFocusSibling(renderer, sibling CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(sibling).Native()))

	C.gtk_cell_area_remove_focus_sibling(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(sibling)
}

// RequestRenderer: this is a convenience function for CellArea implementations
// to request size for cell renderers. It’s important to use this function to
// request size and then use gtk_cell_area_inner_cell_area() at render and event
// time since this function will add padding around the cell for focus painting.
//
// The function takes the following parameters:
//
//    - renderer to request size for.
//    - orientation in which to request size.
//    - widget that area is rendering onto.
//    - forSize: allocation contextual size to request for, or -1 if the base
//      request for the orientation is to be returned.
//
// The function returns the following values:
//
//    - minimumSize (optional): location to store the minimum size, or NULL.
//    - naturalSize (optional): location to store the natural size, or NULL.
//
func (area *CellArea) RequestRenderer(renderer CellRendererer, orientation Orientation, widget Widgetter, forSize int) (minimumSize int, naturalSize int) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.GtkOrientation   // out
	var _arg3 *C.GtkWidget       // out
	var _arg4 C.int              // out
	var _arg5 C.int              // in
	var _arg6 C.int              // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))
	_arg2 = C.GtkOrientation(orientation)
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg4 = C.int(forSize)

	C.gtk_cell_area_request_renderer(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(forSize)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = int(_arg5)
	_naturalSize = int(_arg6)

	return _minimumSize, _naturalSize
}

// SetFocusCell: explicitly sets the currently focused cell to renderer.
//
// This is generally called by implementations of CellAreaClass.focus() or
// CellAreaClass.event(), however it can also be used to implement functions
// such as gtk_tree_view_set_cursor_on_cell().
//
// The function takes the following parameters:
//
//    - renderer to give focus to.
//
func (area *CellArea) SetFocusCell(renderer CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(externglib.InternObject(renderer).Native()))

	C.gtk_cell_area_set_focus_cell(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
}

// Snapshot snapshots area’s cells according to area’s layout onto at the given
// coordinates.
//
// The function takes the following parameters:
//
//    - context for this row of data.
//    - widget that area is rendering to.
//    - snapshot to draw to.
//    - backgroundArea: widget relative coordinates for area’s background.
//    - cellArea: widget relative coordinates for area.
//    - flags for area in this row.
//    - paintFocus: whether area should paint focus on focused cells for focused
//      rows or not.
//
func (area *CellArea) Snapshot(context *CellAreaContext, widget Widgetter, snapshot *Snapshot, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool) {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GtkSnapshot         // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _arg7 C.gboolean             // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(externglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(externglib.InternObject(widget).Native()))
	_arg3 = (*C.GtkSnapshot)(unsafe.Pointer(externglib.InternObject(snapshot).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg6 = C.GtkCellRendererState(flags)
	if paintFocus {
		_arg7 = C.TRUE
	}

	C.gtk_cell_area_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(paintFocus)
}

// StopEditing: explicitly stops the editing of the currently edited cell.
//
// If canceled is TRUE, the currently edited cell renderer will emit the
// ::editing-canceled signal, otherwise the the ::editing-done signal will be
// emitted on the current edit widget.
//
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
//
// The function takes the following parameters:
//
//    - canceled: whether editing was canceled.
//
func (area *CellArea) StopEditing(canceled bool) {
	var _arg0 *C.GtkCellArea // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(externglib.InternObject(area).Native()))
	if canceled {
		_arg1 = C.TRUE
	}

	C.gtk_cell_area_stop_editing(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(canceled)
}

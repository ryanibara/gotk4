// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gtk4_Text_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectInsertAtCursor(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_Text_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectPreeditChanged(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_Text_ConnectToggleOverwrite(gpointer, guintptr);
import "C"

// glib.Type values for gtktext.go.
var GTypeText = coreglib.Type(C.gtk_text_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeText, F: marshalText},
	})
}

// Text: GtkText widget is a single-line text entry widget.
//
// GtkText is the common implementation of single-line text editing that is
// shared between GtkEntry, GtkPasswordEntry, GtkSpinButton and other widgets.
// In all of these, GtkText` is used as the delegate for the gtk.Editable
// implementation.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk.Text.SetVisibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk.Text.SetInvisibleChar().
//
// If you are looking to add icons or progress display in an entry, look at
// GtkEntry. There other alternatives for more specialized use cases, such as
// GtkSearchEntry.
//
// If you need multi-line editable text, look at GtkTextView.
//
// CSS nodes
//
//    text[.read-only]
//    ├── placeholder
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [block-cursor]
//    ╰── [window.popup]
//
//
// GtkText has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
//
// Accessibility
//
// GtkText uses the GTK_ACCESSIBLE_ROLE_NONE role, which causes it to be skipped
// for accessibility. This is because GtkText is expected to be used as a
// delegate for a GtkEditable implementation that will be represented to
// accessibility.
type Text struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Editable
}

var (
	_ Widgetter         = (*Text)(nil)
	_ coreglib.Objector = (*Text)(nil)
)

func wrapText(obj *coreglib.Object) *Text {
	return &Text{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Editable: Editable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalText(p uintptr) (interface{}, error) {
	return wrapText(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_Text_ConnectActivate
func _gotk4_gtk4_Text_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivate is emitted when the user hits the Enter key.
//
// The default bindings for this signal are all forms of the <kbd>Enter</kbd>
// key.
func (self *Text) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectActivate), f)
}

//export _gotk4_gtk4_Text_ConnectBackspace
func _gotk4_gtk4_Text_ConnectBackspace(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectBackspace is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Backspace</kbd> and
// <kbd>Shift</kbd>-<kbd>Backspace</kbd>.
func (self *Text) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "backspace", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectBackspace), f)
}

//export _gotk4_gtk4_Text_ConnectCopyClipboard
func _gotk4_gtk4_Text_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCopyClipboard is emitted to copy the selection to the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>c</kbd> and
// <kbd>Ctrl</kbd>-<kbd>Insert</kbd>.
func (self *Text) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectCopyClipboard), f)
}

//export _gotk4_gtk4_Text_ConnectCutClipboard
func _gotk4_gtk4_Text_ConnectCutClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCutClipboard is emitted to cut the selection to the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>x</kbd> and
// <kbd>Shift</kbd>-<kbd>Delete</kbd>.
func (self *Text) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectCutClipboard), f)
}

//export _gotk4_gtk4_Text_ConnectInsertAtCursor
func _gotk4_gtk4_Text_ConnectInsertAtCursor(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(str string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(str string))
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_str)
}

// ConnectInsertAtCursor is emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This signal has no default bindings.
func (self *Text) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectInsertAtCursor), f)
}

//export _gotk4_gtk4_Text_ConnectInsertEmoji
func _gotk4_gtk4_Text_ConnectInsertEmoji(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectInsertEmoji is emitted to present the Emoji chooser for the self.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>.</kbd> and
// <kbd>Ctrl</kbd>-<kbd>;</kbd>.
func (self *Text) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectInsertEmoji), f)
}

//export _gotk4_gtk4_Text_ConnectPasteClipboard
func _gotk4_gtk4_Text_ConnectPasteClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectPasteClipboard is emitted to paste the contents of the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>v</kbd> and
// <kbd>Shift</kbd>-<kbd>Insert</kbd>.
func (self *Text) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectPasteClipboard), f)
}

//export _gotk4_gtk4_Text_ConnectPreeditChanged
func _gotk4_gtk4_Text_ConnectPreeditChanged(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(preedit string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(preedit string))
	}

	var _preedit string // out

	_preedit = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_preedit)
}

// ConnectPreeditChanged is emitted when the preedit text changes.
//
// If an input method is used, the typed text will not immediately be committed
// to the buffer. So if you are interested in the text, connect to this signal.
func (self *Text) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectPreeditChanged), f)
}

//export _gotk4_gtk4_Text_ConnectToggleOverwrite
func _gotk4_gtk4_Text_ConnectToggleOverwrite(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectToggleOverwrite is emitted to toggle the overwrite mode of the
// GtkText.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal is <kbd>Insert</kbd>.
func (self *Text) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectToggleOverwrite), f)
}

// NewText creates a new GtkText.
//
// The function returns the following values:
//
//    - text: new GtkText.
//
func NewText() *Text {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("new_Text", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _text *Text // out

	_text = wrapText(coreglib.Take(unsafe.Pointer(_cret)))

	return _text
}

// NewTextWithBuffer creates a new GtkText with the specified text buffer.
//
// The function takes the following parameters:
//
//    - buffer to use for the new GtkText.
//
// The function returns the following values:
//
//    - text: new GtkText.
//
func NewTextWithBuffer(buffer *EntryBuffer) *Text {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("new_Text_with_buffer", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _text *Text // out

	_text = wrapText(coreglib.Take(unsafe.Pointer(_cret)))

	return _text
}

// ActivatesDefault retrieves the value set by gtk_text_set_activates_default().
//
// The function returns the following values:
//
//    - ok: TRUE if the GtkText will activate the default widget.
//
func (self *Text) ActivatesDefault() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_activates_default", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Attributes gets the attribute list that was set on the GtkText using
// gtk_text_set_attributes().
//
// The function returns the following values:
//
//    - attrList (optional): attribute list, or NULL if none was set.
//
func (self *Text) Attributes() *pango.AttrList {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_attributes", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _attrList *pango.AttrList // out

	if _cret != nil {
		_attrList = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// Buffer: get the GtkEntryBuffer object which holds the text for this self.
//
// The function returns the following values:
//
//    - entryBuffer: GtkEntryBuffer object.
//
func (self *Text) Buffer() *EntryBuffer {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_buffer", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _entryBuffer *EntryBuffer // out

	_entryBuffer = wrapEntryBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _entryBuffer
}

// EnableEmojiCompletion returns whether Emoji completion is enabled for this
// GtkText widget.
//
// The function returns the following values:
//
//    - ok: TRUE if Emoji completion is enabled.
//
func (self *Text) EnableEmojiCompletion() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_enable_emoji_completion", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
//
// The function returns the following values:
//
//    - menuModel (optional): menu model.
//
func (self *Text) ExtraMenu() gio.MenuModeller {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_extra_menu", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false.
//
// Note that GTK does not compute this value unless it needs it, so the value
// returned by this function is not very useful unless it has been explicitly
// set with gtk.Text.SetInvisibleChar().
//
// The function returns the following values:
//
//    - gunichar: current invisible char, or 0, if text does not show invisible
//      text at all.
//
func (self *Text) InvisibleChar() uint32 {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gunichar // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_invisible_char", _args[:], nil)
	_cret = *(*C.gunichar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// MaxLength retrieves the maximum allowed length of the text in self.
//
// See gtk.Text.SetMaxLength().
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.GetMaxLength() on it.
//
// The function returns the following values:
//
//    - gint: maximum allowed number of characters in GtkText, or 0 if there is
//      no maximum.
//
func (self *Text) MaxLength() int32 {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.int   // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_max_length", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
//
// The function returns the following values:
//
//    - ok: whether the text is overwritten when typing.
//
func (self *Text) OverwriteMode() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_overwrite_mode", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceholderText retrieves the text that will be displayed when self is empty
// and unfocused.
//
// The function returns the following values:
//
//    - utf8 (optional): pointer to the placeholder text as a string. This string
//      points to internally allocated storage in the widget and must not be
//      freed, modified or stored. If no placeholder text has been set, NULL will
//      be returned.
//
func (self *Text) PlaceholderText() string {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_placeholder_text", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// PropagateTextWidth returns whether the GtkText will grow and shrink with the
// content.
//
// The function returns the following values:
//
//    - ok: TRUE if self will propagate the text width.
//
func (self *Text) PropagateTextWidth() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_propagate_text_width", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Tabs gets the tabstops that were set on the GtkText using
// gtk_text_set_tabs().
//
// The function returns the following values:
//
//    - tabArray (optional): tabstops, or NULL if none was set.
//
func (self *Text) Tabs() *pango.TabArray {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_tabs", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _tabArray *pango.TabArray // out

	if _cret != nil {
		_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tabArray
}

// TextLength retrieves the current length of the text in self.
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.GetLength() on it.
//
// The function returns the following values:
//
//    - guint16: current number of characters in GtkText, or 0 if there are none.
//
func (self *Text) TextLength() uint16 {
	var _args [1]girepository.Argument
	var _arg0 *C.void   // out
	var _cret C.guint16 // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_text_length", _args[:], nil)
	_cret = *(*C.guint16)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// TruncateMultiline returns whether the GtkText will truncate multi-line text
// that is pasted into the widget.
//
// The function returns the following values:
//
//    - ok: TRUE if self will truncate multi-line text.
//
func (self *Text) TruncateMultiline() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_truncate_multiline", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visibility retrieves whether the text in self is visible.
//
// The function returns the following values:
//
//    - ok: TRUE if the text is currently visible.
//
func (self *Text) Visibility() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("get_visibility", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GrabFocusWithoutSelecting causes self to have keyboard focus.
//
// It behaves like gtk.Widget.GrabFocus(), except that it doesn't select the
// contents of self. You only want to call this on some special entries which
// the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
//
// The function returns the following values:
//
//    - ok: TRUE if focus is now inside self.
//
func (self *Text) GrabFocusWithoutSelecting() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Text").InvokeMethod("grab_focus_without_selecting", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActivatesDefault: if activates is TRUE, pressing Enter in the self will
// activate the default widget for the window containing self.
//
// This usually means that the dialog containing the GtkText will be closed,
// since the default widget is usually one of the dialog buttons.
//
// The function takes the following parameters:
//
//    - activates: TRUE to activate window’s default widget on Enter keypress.
//
func (self *Text) SetActivatesDefault(activates bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if activates {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_activates_default", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(activates)
}

// SetAttributes sets attributes that are applied to the text.
//
// The function takes the following parameters:
//
//    - attrs (optional): PangoAttrList or NULL to unset.
//
func (self *Text) SetAttributes(attrs *pango.AttrList) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if attrs != nil {
		_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(attrs)))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_attributes", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(attrs)
}

// SetBuffer: set the GtkEntryBuffer object which holds the text for this
// widget.
//
// The function takes the following parameters:
//
//    - buffer: GtkEntryBuffer.
//
func (self *Text) SetBuffer(buffer *EntryBuffer) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_buffer", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(buffer)
}

// SetEnableEmojiCompletion sets whether Emoji completion is enabled.
//
// If it is, typing ':', followed by a recognized keyword, will pop up a window
// with suggested Emojis matching the keyword.
//
// The function takes the following parameters:
//
//    - enableEmojiCompletion: TRUE to enable Emoji completion.
//
func (self *Text) SetEnableEmojiCompletion(enableEmojiCompletion bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if enableEmojiCompletion {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_enable_emoji_completion", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(enableEmojiCompletion)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// self.
//
// The function takes the following parameters:
//
//    - model (optional): GMenuModel.
//
func (self *Text) SetExtraMenu(model gio.MenuModeller) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_extra_menu", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetInvisibleChar sets the character to use in place of the actual text when
// in “password mode”.
//
// By default, GTK picks the best invisible char available in the current font.
// If you set the invisible char to 0, then the user will get no feedback at
// all; there will be no text on the screen as they type.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//
func (self *Text) SetInvisibleChar(ch uint32) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gunichar // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gunichar(ch)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gunichar)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_invisible_char", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(ch)
}

// SetMaxLength sets the maximum allowed length of the contents of the widget.
//
// If the current contents are longer than the given length, then they will be
// truncated to fit.
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.SetMaxLength() on it.
//
// The function takes the following parameters:
//
//    - length: maximum length of the GtkText, or 0 for no maximum. (other than
//      the maximum length of entries.) The value passed in will be clamped to
//      the range 0-65536.
//
func (self *Text) SetMaxLength(length int32) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(length)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.int)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_max_length", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(length)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// GtkText.
//
// The function takes the following parameters:
//
//    - overwrite: new value.
//
func (self *Text) SetOverwriteMode(overwrite bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_overwrite_mode", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(overwrite)
}

// SetPlaceholderText sets text to be displayed in self when it is empty.
//
// This can be used to give a visual hint of the expected contents of the
// GtkText.
//
// The function takes the following parameters:
//
//    - text (optional): string to be displayed when self is empty and unfocused,
//      or NULL.
//
func (self *Text) SetPlaceholderText(text string) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if text != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_placeholder_text", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(text)
}

// SetPropagateTextWidth sets whether the GtkText should grow and shrink with
// the content.
//
// The function takes the following parameters:
//
//    - propagateTextWidth: TRUE to propagate the text width.
//
func (self *Text) SetPropagateTextWidth(propagateTextWidth bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if propagateTextWidth {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_propagate_text_width", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(propagateTextWidth)
}

// SetTabs sets tabstops that are applied to the text.
//
// The function takes the following parameters:
//
//    - tabs (optional): PangoTabArray.
//
func (self *Text) SetTabs(tabs *pango.TabArray) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if tabs != nil {
		_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(tabs)))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_tabs", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(tabs)
}

// SetTruncateMultiline sets whether the GtkText should truncate multi-line text
// that is pasted into the widget.
//
// The function takes the following parameters:
//
//    - truncateMultiline: TRUE to truncate multi-line text.
//
func (self *Text) SetTruncateMultiline(truncateMultiline bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if truncateMultiline {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_truncate_multiline", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(truncateMultiline)
}

// SetVisibility sets whether the contents of the GtkText are visible or not.
//
// When visibility is set to FALSE, characters are displayed as the invisible
// char, and will also appear that way when the text in the widget is copied to
// the clipboard.
//
// By default, GTK picks the best invisible character available in the current
// font, but it can be changed with gtk.Text.SetInvisibleChar().
//
// Note that you probably want to set gtk.Text:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this self, in addition to setting visibility to FALSE.
//
// The function takes the following parameters:
//
//    - visible: TRUE if the contents of the GtkText are displayed as plaintext.
//
func (self *Text) SetVisibility(visible bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Text").InvokeMethod("set_visibility", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(visible)
}

// UnsetInvisibleChar unsets the invisible char.
//
// After calling this, the default invisible char is used again.
func (self *Text) UnsetInvisibleChar() {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "Text").InvokeMethod("unset_invisible_char", _args[:], nil)

	runtime.KeepAlive(self)
}

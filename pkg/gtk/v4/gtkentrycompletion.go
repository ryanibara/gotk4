// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_gtk4_EntryCompletion_ConnectCursorOnMatch(gpointer, GtkTreeModel*, GtkTreeIter*, guintptr);
// extern gboolean _gotk4_gtk4_EntryCompletion_ConnectInsertPrefix(gpointer, gchar*, guintptr);
// extern gboolean _gotk4_gtk4_EntryCompletion_ConnectMatchSelected(gpointer, GtkTreeModel*, GtkTreeIter*, guintptr);
// extern void _gotk4_gtk4_EntryCompletion_ConnectNoMatches(gpointer, guintptr);
import "C"

// glib.Type values for gtkentrycompletion.go.
var GTypeEntryCompletion = coreglib.Type(C.gtk_entry_completion_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeEntryCompletion, F: marshalEntryCompletion},
	})
}

// EntryCompletionMatchFunc: function which decides whether the row indicated by
// iter matches a given key, and should be displayed as a possible completion
// for key.
//
// Note that key is normalized and case-folded (see g_utf8_normalize() and
// g_utf8_casefold()). If this is not appropriate, match functions have access
// to the unmodified key via gtk_editable_get_text (GTK_EDITABLE
// (gtk_entry_completion_get_entry ())).
type EntryCompletionMatchFunc func(completion *EntryCompletion, key string, iter *TreeIter) (ok bool)

//export _gotk4_gtk4_EntryCompletionMatchFunc
func _gotk4_gtk4_EntryCompletionMatchFunc(arg1 *C.GtkEntryCompletion, arg2 *C.char, arg3 *C.GtkTreeIter, arg4 C.gpointer) (cret C.gboolean) {
	var fn EntryCompletionMatchFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(EntryCompletionMatchFunc)
	}

	var _completion *EntryCompletion // out
	var _key string                  // out
	var _iter *TreeIter              // out

	_completion = wrapEntryCompletion(coreglib.Take(unsafe.Pointer(arg1)))
	_key = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := fn(_completion, _key, _iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// EntryCompletion: GtkEntryCompletion is an auxiliary object to provide
// completion functionality for GtkEntry.
//
// It implements the gtk.CellLayout interface, to allow the user to add extra
// cells to the GtkTreeView with completion matches.
//
// “Completion functionality” means that when the user modifies the text in the
// entry, GtkEntryCompletion checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see gtk.EntryCompletion.SetTextColumn()), but this
// can be overridden with a custom match function (see
// gtk.EntryCompletion.SetMatchFunc()).
//
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// gtk.EntryCompletion::match-selected signal and updating the entry in the
// signal handler. Note that you should return TRUE from the signal handler to
// suppress the default behaviour.
//
// To add completion functionality to an entry, use gtk.Entry.SetCompletion().
//
// GtkEntryCompletion uses a gtk.TreeModelFilter model to represent the subset
// of the entire model that is currently matching. While the GtkEntryCompletion
// signals gtk.EntryCompletion::match-selected and
// gtk.EntryCompletion::cursor-on-match take the original model and an iter
// pointing to that model as arguments, other callbacks and signals (such as
// GtkCellLayoutDataFunc or gtk.CellArea::apply-attributes) will generally take
// the filter model as argument. As long as you are only calling
// gtk.TreeModel.Get(), this will make no difference to you. If for some reason,
// you need the original model, use gtk.TreeModelFilter.GetModel(). Don’t forget
// to use gtk.TreeModelFilter.ConvertIterToChildIter() to obtain a matching
// iter.
type EntryCompletion struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
	CellLayout
}

var (
	_ coreglib.Objector = (*EntryCompletion)(nil)
)

func wrapEntryCompletion(obj *coreglib.Object) *EntryCompletion {
	return &EntryCompletion{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
		CellLayout: CellLayout{
			Object: obj,
		},
	}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	return wrapEntryCompletion(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_EntryCompletion_ConnectCursorOnMatch
func _gotk4_gtk4_EntryCompletion_ConnectCursorOnMatch(arg0 C.gpointer, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.guintptr) (cret C.gboolean) {
	var f func(model TreeModeller, iter *TreeIter) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(model TreeModeller, iter *TreeIter) (ok bool))
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := f(_model, _iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectCursorOnMatch is emitted when a match from the cursor is on a match of
// the list.
//
// The default behaviour is to replace the contents of the entry with the
// contents of the text column in the row pointed to by iter.
//
// Note that model is the model that was passed to
// gtk.EntryCompletion.SetModel().
func (completion *EntryCompletion) ConnectCursorOnMatch(f func(model TreeModeller, iter *TreeIter) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "cursor-on-match", false, unsafe.Pointer(C._gotk4_gtk4_EntryCompletion_ConnectCursorOnMatch), f)
}

//export _gotk4_gtk4_EntryCompletion_ConnectInsertPrefix
func _gotk4_gtk4_EntryCompletion_ConnectInsertPrefix(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) (cret C.gboolean) {
	var f func(prefix string) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(prefix string) (ok bool))
	}

	var _prefix string // out

	_prefix = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := f(_prefix)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectInsertPrefix is emitted when the inline autocompletion is triggered.
//
// The default behaviour is to make the entry display the whole prefix and
// select the newly inserted part.
//
// Applications may connect to this signal in order to insert only a smaller
// part of the prefix into the entry - e.g. the entry used in the FileChooser
// inserts only the part of the prefix up to the next '/'.
func (completion *EntryCompletion) ConnectInsertPrefix(f func(prefix string) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "insert-prefix", false, unsafe.Pointer(C._gotk4_gtk4_EntryCompletion_ConnectInsertPrefix), f)
}

//export _gotk4_gtk4_EntryCompletion_ConnectMatchSelected
func _gotk4_gtk4_EntryCompletion_ConnectMatchSelected(arg0 C.gpointer, arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.guintptr) (cret C.gboolean) {
	var f func(model TreeModeller, iter *TreeIter) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(model TreeModeller, iter *TreeIter) (ok bool))
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := f(_model, _iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectMatchSelected is emitted when a match from the list is selected.
//
// The default behaviour is to replace the contents of the entry with the
// contents of the text column in the row pointed to by iter.
//
// Note that model is the model that was passed to
// gtk.EntryCompletion.SetModel().
func (completion *EntryCompletion) ConnectMatchSelected(f func(model TreeModeller, iter *TreeIter) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "match-selected", false, unsafe.Pointer(C._gotk4_gtk4_EntryCompletion_ConnectMatchSelected), f)
}

//export _gotk4_gtk4_EntryCompletion_ConnectNoMatches
func _gotk4_gtk4_EntryCompletion_ConnectNoMatches(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectNoMatches is emitted when the filter model has zero number of rows in
// completion_complete method.
//
// In other words when GtkEntryCompletion is out of suggestions.
func (completion *EntryCompletion) ConnectNoMatches(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "no-matches", false, unsafe.Pointer(C._gotk4_gtk4_EntryCompletion_ConnectNoMatches), f)
}

// NewEntryCompletion creates a new GtkEntryCompletion object.
//
// The function returns the following values:
//
//    - entryCompletion: newly created GtkEntryCompletion object.
//
func NewEntryCompletion() *EntryCompletion {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("new_EntryCompletion", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _entryCompletion *EntryCompletion // out

	_entryCompletion = wrapEntryCompletion(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// NewEntryCompletionWithArea creates a new GtkEntryCompletion object using the
// specified area.
//
// The GtkCellArea is used to layout cells in the underlying GtkTreeViewColumn
// for the drop-down menu.
//
// The function takes the following parameters:
//
//    - area used to layout cells.
//
// The function returns the following values:
//
//    - entryCompletion: newly created GtkEntryCompletion object.
//
func NewEntryCompletionWithArea(area CellAreaer) *EntryCompletion {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	*(*CellAreaer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("new_EntryCompletion_with_area", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(area)

	var _entryCompletion *EntryCompletion // out

	_entryCompletion = wrapEntryCompletion(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// Complete requests a completion operation, or in other words a refiltering of
// the current list with completions, using the current key.
//
// The completion list view will be updated accordingly.
func (completion *EntryCompletion) Complete() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("complete", args[:], nil)

	runtime.KeepAlive(completion)
}

// ComputePrefix computes the common prefix that is shared by all rows in
// completion that start with key.
//
// If no row matches key, NULL will be returned. Note that a text column must
// have been set for this function to work, see
// gtk.EntryCompletion.SetTextColumn() for details.
//
// The function takes the following parameters:
//
//    - key: text to complete for.
//
// The function returns the following values:
//
//    - utf8 (optional): common prefix all rows starting with key or NULL if no
//      row matches key.
//
func (completion *EntryCompletion) ComputePrefix(key string) string {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**EntryCompletion)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("compute_prefix", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// CompletionPrefix: get the original text entered by the user that triggered
// the completion or NULL if there’s no completion ongoing.
//
// The function returns the following values:
//
//    - utf8 (optional): prefix for the current completion.
//
func (completion *EntryCompletion) CompletionPrefix() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("get_completion_prefix", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Entry gets the entry completion has been attached to.
//
// The function returns the following values:
//
//    - widget: entry completion has been attached to.
//
func (completion *EntryCompletion) Entry() Widgetter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("get_entry", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
//
// The function returns the following values:
//
//    - ok: TRUE if inline completion is turned on.
//
func (completion *EntryCompletion) InlineCompletion() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("get_inline_completion", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InlineSelection returns TRUE if inline-selection mode is turned on.
//
// The function returns the following values:
//
//    - ok: TRUE if inline-selection mode is on.
//
func (completion *EntryCompletion) InlineSelection() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("get_inline_selection", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Model returns the model the GtkEntryCompletion is using as data source.
//
// Returns NULL if the model is unset.
//
// The function returns the following values:
//
//    - treeModel (optional) or NULL if none is currently being used.
//
func (completion *EntryCompletion) Model() *TreeModel {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("get_model", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// PopupCompletion returns whether the completions should be presented in a
// popup window.
//
// The function returns the following values:
//
//    - ok: TRUE if popup completion is turned on.
//
func (completion *EntryCompletion) PopupCompletion() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("get_popup_completion", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopupSetWidth returns whether the completion popup window will be resized to
// the width of the entry.
//
// The function returns the following values:
//
//    - ok: TRUE if the popup window will be resized to the width of the entry.
//
func (completion *EntryCompletion) PopupSetWidth() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("get_popup_set_width", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopupSingleMatch returns whether the completion popup window will appear even
// if there is only a single match.
//
// The function returns the following values:
//
//    - ok: TRUE if the popup window will appear regardless of the number of
//      matches.
//
func (completion *EntryCompletion) PopupSingleMatch() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("get_popup_single_match", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertPrefix requests a prefix insertion.
func (completion *EntryCompletion) InsertPrefix() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	*(**EntryCompletion)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("insert_prefix", args[:], nil)

	runtime.KeepAlive(completion)
}

// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
//
// The function takes the following parameters:
//
//    - inlineCompletion: TRUE to do inline completion.
//
func (completion *EntryCompletion) SetInlineCompletion(inlineCompletion bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if inlineCompletion {
		_arg1 = C.TRUE
	}
	*(**EntryCompletion)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("set_inline_completion", args[:], nil)

	runtime.KeepAlive(completion)
	runtime.KeepAlive(inlineCompletion)
}

// SetInlineSelection sets whether it is possible to cycle through the possible
// completions inside the entry.
//
// The function takes the following parameters:
//
//    - inlineSelection: TRUE to do inline selection.
//
func (completion *EntryCompletion) SetInlineSelection(inlineSelection bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if inlineSelection {
		_arg1 = C.TRUE
	}
	*(**EntryCompletion)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("set_inline_selection", args[:], nil)

	runtime.KeepAlive(completion)
	runtime.KeepAlive(inlineSelection)
}

// SetModel sets the model for a GtkEntryCompletion.
//
// If completion already has a model set, it will remove it before setting the
// new model. If model is NULL, then it will unset the model.
//
// The function takes the following parameters:
//
//    - model (optional): GtkTreeModel.
//
func (completion *EntryCompletion) SetModel(model TreeModeller) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if model != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}
	*(**EntryCompletion)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("set_model", args[:], nil)

	runtime.KeepAlive(completion)
	runtime.KeepAlive(model)
}

// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
//
// The function takes the following parameters:
//
//    - popupCompletion: TRUE to do popup completion.
//
func (completion *EntryCompletion) SetPopupCompletion(popupCompletion bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if popupCompletion {
		_arg1 = C.TRUE
	}
	*(**EntryCompletion)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("set_popup_completion", args[:], nil)

	runtime.KeepAlive(completion)
	runtime.KeepAlive(popupCompletion)
}

// SetPopupSetWidth sets whether the completion popup window will be resized to
// be the same width as the entry.
//
// The function takes the following parameters:
//
//    - popupSetWidth: TRUE to make the width of the popup the same as the entry.
//
func (completion *EntryCompletion) SetPopupSetWidth(popupSetWidth bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if popupSetWidth {
		_arg1 = C.TRUE
	}
	*(**EntryCompletion)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("set_popup_set_width", args[:], nil)

	runtime.KeepAlive(completion)
	runtime.KeepAlive(popupSetWidth)
}

// SetPopupSingleMatch sets whether the completion popup window will appear even
// if there is only a single match.
//
// You may want to set this to FALSE if you are using
// gtk.EntryCompletion:inline-completion.
//
// The function takes the following parameters:
//
//    - popupSingleMatch: TRUE if the popup should appear even for a single
//      match.
//
func (completion *EntryCompletion) SetPopupSingleMatch(popupSingleMatch bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if popupSingleMatch {
		_arg1 = C.TRUE
	}
	*(**EntryCompletion)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "EntryCompletion").InvokeMethod("set_popup_single_match", args[:], nil)

	runtime.KeepAlive(completion)
	runtime.KeepAlive(popupSingleMatch)
}

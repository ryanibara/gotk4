// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_drop_target_get_type()), F: marshalDropTargetter},
	})
}

// DropTarget: GtkDropTarget is an event controller to receive Drag-and-Drop
// operations.
//
// The most basic way to use a GtkDropTarget to receive drops on a widget is to
// create it via gtk.DropTarget.New, passing in the GType of the data you want
// to receive and connect to the gtk.DropTarget::drop signal to receive the
// data:
//
//    static gboolean
//    on_drop (GtkDropTarget *target,
//             const GValue  *value,
//             double         x,
//             double         y,
//             gpointer       data)
//    {
//      MyWidget *self = data;
//
//      // Call the appropriate setter depending on the type of data
//      // that we received
//      if (G_VALUE_HOLDS (value, G_TYPE_FILE))
//        my_widget_set_file (self, g_value_get_object (value));
//      else if (G_VALUE_HOLDS (value, GDK_TYPE_PIXBUF))
//        my_widget_set_pixbuf (self, g_value_get_object (value));
//      else
//        return FALSE;
//
//      return TRUE;
//    }
//
//    static void
//    my_widget_init (MyWidget *self)
//    {
//      GtkDropTarget *target =
//        gtk_drop_target_new (G_TYPE_INVALID, GDK_ACTION_COPY);
//
//      // This widget accepts two types of drop types: GFile objects
//      // and GdkPixbuf objects
//      gtk_drop_target_set_gtypes (target, (GTypes [2]) {
//        G_TYPE_FILE,
//        GDK_TYPE_PIXBUF,
//      }, 2);
//
//      gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (target));
//    }
//
//
// GtkDropTarget supports more options, such as:
//
//    * rejecting potential drops via the gtk.DropTarget::accept signal
//      and the gtk.DropTarget.Reject() function to let other drop
//      targets handle the drop
//    * tracking an ongoing drag operation before the drop via the
//      gtk.DropTarget::enter, gtk.DropTarget::motion and
//      gtk.DropTarget::leave signals
//    * configuring how to receive data by setting the
//      gtk.DropTarget:preload property and listening for its
//      availability via the gtk.DropTarget:value property
//
// However, GtkDropTarget is ultimately modeled in a synchronous way and only
// supports data transferred via GType. If you want full control over an ongoing
// drop, the gtk.DropTargetAsync object gives you this ability.
//
// While a pointer is dragged over the drop target's widget and the drop has not
// been rejected, that widget will receive the GTK_STATE_FLAG_DROP_ACTIVE state,
// which can be used to style the widget.
//
// If you are not interested in receiving the drop, but just want to update UI
// state during a Drag-and-Drop operation (e.g. switching tabs), you can use
// gtk.DropControllerMotion.
type DropTarget struct {
	EventController
}

func wrapDropTarget(obj *externglib.Object) *DropTarget {
	return &DropTarget{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalDropTargetter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDropTarget(obj), nil
}

// NewDropTarget creates a new GtkDropTarget object.
//
// If the drop target should support more than 1 type, pass G_TYPE_INVALID for
// type and then call gtk.DropTarget.SetGTypes().
func NewDropTarget(typ externglib.Type, actions gdk.DragAction) *DropTarget {
	var _arg1 C.GType          // out
	var _arg2 C.GdkDragAction  // out
	var _cret *C.GtkDropTarget // in

	_arg1 = C.GType(typ)
	_arg2 = C.GdkDragAction(actions)

	_cret = C.gtk_drop_target_new(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(actions)

	var _dropTarget *DropTarget // out

	_dropTarget = wrapDropTarget(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dropTarget
}

// Actions gets the actions that this drop target supports.
func (self *DropTarget) Actions() gdk.DragAction {
	var _arg0 *C.GtkDropTarget // out
	var _cret C.GdkDragAction  // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_drop_target_get_actions(_arg0)
	runtime.KeepAlive(self)

	var _dragAction gdk.DragAction // out

	_dragAction = gdk.DragAction(_cret)

	return _dragAction
}

// Drop gets the currently handled drop operation.
//
// If no drop operation is going on, NULL is returned.
func (self *DropTarget) Drop() gdk.Dropper {
	var _arg0 *C.GtkDropTarget // out
	var _cret *C.GdkDrop       // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_drop_target_get_drop(_arg0)
	runtime.KeepAlive(self)

	var _drop gdk.Dropper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(gdk.Dropper)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gdk.Dropper")
			}
			_drop = rv
		}
	}

	return _drop
}

// Formats gets the data formats that this drop target accepts.
//
// If the result is NULL, all formats are expected to be supported.
func (self *DropTarget) Formats() *gdk.ContentFormats {
	var _arg0 *C.GtkDropTarget     // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_drop_target_get_formats(_arg0)
	runtime.KeepAlive(self)

	var _contentFormats *gdk.ContentFormats // out

	if _cret != nil {
		_contentFormats = (*gdk.ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_contentFormats)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
			},
		)
	}

	return _contentFormats
}

// GTypes gets the list of supported GTypes for self.
//
// If no type have been set, NULL will be returned.
func (self *DropTarget) GTypes() []externglib.Type {
	var _arg0 *C.GtkDropTarget // out
	var _cret *C.GType         // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_drop_target_get_gtypes(_arg0, &_arg1)
	runtime.KeepAlive(self)

	var _gTypes []externglib.Type // out

	if _cret != nil {
		{
			src := unsafe.Slice(_cret, _arg1)
			_gTypes = make([]externglib.Type, _arg1)
			for i := 0; i < int(_arg1); i++ {
				_gTypes[i] = externglib.Type(src[i])
			}
		}
	}

	return _gTypes
}

// Preload gets whether data should be preloaded on hover.
func (self *DropTarget) Preload() bool {
	var _arg0 *C.GtkDropTarget // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_drop_target_get_preload(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets the current drop data, as a GValue.
func (self *DropTarget) Value() *externglib.Value {
	var _arg0 *C.GtkDropTarget // out
	var _cret *C.GValue        // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_drop_target_get_value(_arg0)
	runtime.KeepAlive(self)

	var _value *externglib.Value // out

	if _cret != nil {
		_value = externglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// Reject rejects the ongoing drop operation.
//
// If no drop operation is ongoing, i.e when gtk.DropTarget:drop is NULL, this
// function does nothing.
//
// This function should be used when delaying the decision on whether to accept
// a drag or not until after reading the data.
func (self *DropTarget) Reject() {
	var _arg0 *C.GtkDropTarget // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))

	C.gtk_drop_target_reject(_arg0)
	runtime.KeepAlive(self)
}

// SetActions sets the actions that this drop target supports.
//
// The function takes the following parameters:
//
//    - actions: supported actions.
//
func (self *DropTarget) SetActions(actions gdk.DragAction) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 C.GdkDragAction  // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))
	_arg1 = C.GdkDragAction(actions)

	C.gtk_drop_target_set_actions(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(actions)
}

// SetGTypes sets the supported GTypes for this drop target.
//
// The function takes the following parameters:
//
//    - types: all supported #GTypes that can be dropped.
//
func (self *DropTarget) SetGTypes(types []externglib.Type) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 *C.GType         // out
	var _arg2 C.gsize

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))
	_arg2 = (C.gsize)(len(types))
	_arg1 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GType)(_arg1), len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	C.gtk_drop_target_set_gtypes(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(types)
}

// SetPreload sets whether data should be preloaded on hover.
//
// The function takes the following parameters:
//
//    - preload: TRUE to preload drop data.
//
func (self *DropTarget) SetPreload(preload bool) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(self.Native()))
	if preload {
		_arg1 = C.TRUE
	}

	C.gtk_drop_target_set_preload(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(preload)
}

// ConnectAccept: emitted on the drop site when a drop operation is about to
// begin.
//
// If the drop is not accepted, FALSE will be returned and the drop target will
// ignore the drop. If TRUE is returned, the drop is accepted for now but may be
// rejected later via a call to gtk.DropTarget.Reject() or ultimately by
// returning FALSE from a gtk.DropTarget::drop handler.
//
// The default handler for this signal decides whether to accept the drop based
// on the formats provided by the drop.
//
// If the decision whether the drop will be accepted or rejected depends on the
// data, this function should return TRUE, the gtk.DropTarget:preload property
// should be set and the value should be inspected via the ::notify:value
// signal, calling gtk.DropTarget.Reject() if required.
func (d *DropTarget) ConnectAccept(f func(drop gdk.Dropper) bool) glib.SignalHandle {
	return d.Connect("accept", f)
}

// ConnectDrop: emitted on the drop site when the user drops the data onto the
// widget.
//
// The signal handler must determine whether the pointer position is in a drop
// zone or not. If it is not in a drop zone, it returns FALSE and no further
// processing is necessary.
//
// Otherwise, the handler returns TRUE. In this case, this handler will accept
// the drop. The handler is responsible for rading the given value and
// performing the drop operation.
func (d *DropTarget) ConnectDrop(f func(value externglib.Value, x, y float64) bool) glib.SignalHandle {
	return d.Connect("drop", f)
}

// ConnectEnter: emitted on the drop site when the pointer enters the widget.
//
// It can be used to set up custom highlighting.
func (d *DropTarget) ConnectEnter(f func(x, y float64) gdk.DragAction) glib.SignalHandle {
	return d.Connect("enter", f)
}

// ConnectLeave: emitted on the drop site when the pointer leaves the widget.
//
// Its main purpose it to undo things done in gtk.DropTarget::enter.
func (d *DropTarget) ConnectLeave(f func()) glib.SignalHandle {
	return d.Connect("leave", f)
}

// ConnectMotion: emitted while the pointer is moving over the drop target.
func (d *DropTarget) ConnectMotion(f func(x, y float64) gdk.DragAction) glib.SignalHandle {
	return d.Connect("motion", f)
}

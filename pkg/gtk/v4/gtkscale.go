// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern char* _gotk4_gtk4_ScaleFormatValueFunc(void*, double, gpointer);
// extern void _gotk4_gtk4_ScaleClass_get_layout_offsets(void*, void*, void*);
// extern void callbackDelete(gpointer);
import "C"

// GTypeScale returns the GType for the type Scale.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeScale() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "Scale").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalScale)
	return gtype
}

type ScaleFormatValueFunc func(scale *Scale, value float64) (utf8 string)

//export _gotk4_gtk4_ScaleFormatValueFunc
func _gotk4_gtk4_ScaleFormatValueFunc(arg1 *C.void, arg2 C.double, arg3 C.gpointer) (cret *C.char) {
	var fn ScaleFormatValueFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ScaleFormatValueFunc)
	}

	var _scale *Scale  // out
	var _value float64 // out

	_scale = wrapScale(coreglib.Take(unsafe.Pointer(arg1)))
	_value = float64(arg2)

	utf8 := fn(_scale, _value)

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

// ScaleOverrider contains methods that are overridable.
type ScaleOverrider interface {
	// LayoutOffsets obtains the coordinates where the scale will draw the
	// PangoLayout representing the text in the scale.
	//
	// Remember when using the PangoLayout function you need to convert to and
	// from pixels using PANGO_PIXELS() or PANGO_SCALE.
	//
	// If the gtkscale:draw-value property is FALSE, the return values are
	// undefined.
	//
	// The function returns the following values:
	//
	//    - x (optional): location to store X offset of layout, or NULL.
	//    - y (optional): location to store Y offset of layout, or NULL.
	//
	LayoutOffsets() (x, y int32)
}

// Scale: GtkScale is a slider control used to select a numeric value.
//
// !An example GtkScale (scales.png)
//
// To use it, you’ll probably want to investigate the methods on its base class,
// gtkrange, in addition to the methods for GtkScale itself. To set the value of
// a scale, you would normally use gtk.Range.SetValue(). To detect changes to
// the value, you would normally use the gtk.Range::value-changed signal.
//
// Note that using the same upper and lower bounds for the GtkScale (through the
// GtkRange methods) will hide the slider itself. This is useful for
// applications that want to show an undeterminate value on the scale, without
// changing the layout of the application (such as movie or music players).
//
//
// GtkScale as GtkBuildable
//
// GtkScale supports a custom <marks> element, which can contain multiple
// <mark\> elements. The “value” and “position” attributes have the same meaning
// as gtk.Scale.AddMark() parameters of the same name. If the element is not
// empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
//
// CSS nodes
//
//    scale[.fine-tune][.marks-before][.marks-after]
//    ├── [value][.top][.right][.bottom][.left]
//    ├── marks.top
//    │   ├── mark
//    │   ┊    ├── [label]
//    │   ┊    ╰── indicator
//    ┊   ┊
//    │   ╰── mark
//    ├── marks.bottom
//    │   ├── mark
//    │   ┊    ├── indicator
//    │   ┊    ╰── [label]
//    ┊   ┊
//    │   ╰── mark
//    ╰── trough
//        ├── [fill]
//        ├── [highlight]
//        ╰── slider
//
//
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see gtk.Scale.SetHasOrigin()), there is a subnode
// with name highlight below the trough node that is used for rendering the
// highlighted part of the trough.
//
// If the scale is showing a fill level (see gtk.Range.SetShowFillLevel()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
//
// If marks are present, there is a marks subnode before or after the trough
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see gtk.Scale:draw-value), there is
// subnode with name value. This node will get the .top or .bottom style classes
// similar to the marks node.
//
//
// Accessibility
//
// GtkScale uses the GTK_ACCESSIBLE_ROLE_SLIDER role.
type Scale struct {
	_ [0]func() // equal guard
	Range
}

var (
	_ Widgetter         = (*Scale)(nil)
	_ coreglib.Objector = (*Scale)(nil)
)

func classInitScaler(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "ScaleClass")

	if _, ok := goval.(interface{ LayoutOffsets() (x, y int32) }); ok {
		o := pclass.StructFieldOffset("get_layout_offsets")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk4_ScaleClass_get_layout_offsets)
	}
}

//export _gotk4_gtk4_ScaleClass_get_layout_offsets
func _gotk4_gtk4_ScaleClass_get_layout_offsets(arg0 *C.void, arg1 *C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ LayoutOffsets() (x, y int32) })

	x, y := iface.LayoutOffsets()

	*arg1 = (*C.void)(unsafe.Pointer(x))
	*arg2 = (*C.void)(unsafe.Pointer(y))
}

func wrapScale(obj *coreglib.Object) *Scale {
	return &Scale{
		Range: Range{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
		},
	}
}

func marshalScale(p uintptr) (interface{}, error) {
	return wrapScale(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ClearMarks removes any marks that have been added.
func (scale *Scale) ClearMarks() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	girepository.MustFind("Gtk", "Scale").InvokeMethod("clear_marks", _args[:], nil)

	runtime.KeepAlive(scale)
}

// Digits gets the number of decimal places that are displayed in the value.
//
// The function returns the following values:
//
//    - gint: number of decimal places that are displayed.
//
func (scale *Scale) Digits() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_gret := girepository.MustFind("Gtk", "Scale").InvokeMethod("get_digits", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scale)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// DrawValue returns whether the current value is displayed as a string next to
// the slider.
//
// The function returns the following values:
//
//    - ok: whether the current value is displayed as a string.
//
func (scale *Scale) DrawValue() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_gret := girepository.MustFind("Gtk", "Scale").InvokeMethod("get_draw_value", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scale)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// HasOrigin returns whether the scale has an origin.
//
// The function returns the following values:
//
//    - ok: TRUE if the scale has an origin.
//
func (scale *Scale) HasOrigin() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_gret := girepository.MustFind("Gtk", "Scale").InvokeMethod("get_has_origin", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scale)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Layout gets the PangoLayout used to display the scale.
//
// The returned object is owned by the scale so does not need to be freed by the
// caller.
//
// The function returns the following values:
//
//    - layout (optional): pango.Layout for this scale, or NULL if the
//      gtkscale:draw-value property is FALSE.
//
func (scale *Scale) Layout() *pango.Layout {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_gret := girepository.MustFind("Gtk", "Scale").InvokeMethod("get_layout", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scale)

	var _layout *pango.Layout // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_layout = &pango.Layout{
				Object: obj,
			}
		}
	}

	return _layout
}

// LayoutOffsets obtains the coordinates where the scale will draw the
// PangoLayout representing the text in the scale.
//
// Remember when using the PangoLayout function you need to convert to and from
// pixels using PANGO_PIXELS() or PANGO_SCALE.
//
// If the gtkscale:draw-value property is FALSE, the return values are
// undefined.
//
// The function returns the following values:
//
//    - x (optional): location to store X offset of layout, or NULL.
//    - y (optional): location to store Y offset of layout, or NULL.
//
func (scale *Scale) LayoutOffsets() (x, y int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	girepository.MustFind("Gtk", "Scale").InvokeMethod("get_layout_offsets", _args[:], _outs[:])

	runtime.KeepAlive(scale)

	var _x int32 // out
	var _y int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_x = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_y = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _x, _y
}

// SetDigits sets the number of decimal places that are displayed in the value.
//
// Also causes the value of the adjustment to be rounded to this number of
// digits, so the retrieved value matches the displayed one, if
// gtkscale:draw-value is TRUE when the value changes. If you want to enforce
// rounding the value when gtkscale:draw-value is FALSE, you can set
// gtkrange:round-digits instead.
//
// Note that rounding to a small number of digits can interfere with the smooth
// autoscrolling that is built into GtkScale. As an alternative, you can use
// gtk.Scale.SetFormatValueFunc() to format the displayed value yourself.
//
// The function takes the following parameters:
//
//    - digits: number of decimal places to display, e.g. use 1 to display 1.0, 2
//      to display 1.00, etc.
//
func (scale *Scale) SetDigits(digits int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(digits)

	girepository.MustFind("Gtk", "Scale").InvokeMethod("set_digits", _args[:], nil)

	runtime.KeepAlive(scale)
	runtime.KeepAlive(digits)
}

// SetDrawValue specifies whether the current value is displayed as a string
// next to the slider.
//
// The function takes the following parameters:
//
//    - drawValue: TRUE to draw the value.
//
func (scale *Scale) SetDrawValue(drawValue bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	if drawValue {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Scale").InvokeMethod("set_draw_value", _args[:], nil)

	runtime.KeepAlive(scale)
	runtime.KeepAlive(drawValue)
}

// SetFormatValueFunc: func allows you to change how the scale value is
// displayed.
//
// The given function will return an allocated string representing value. That
// string will then be used to display the scale's value.
//
// If LL is passed as func, the value will be displayed on its own, rounded
// according to the value of the gtkscale:digits property.
//
// The function takes the following parameters:
//
//    - fn (optional): function that formats the value.
//
func (scale *Scale) SetFormatValueFunc(fn ScaleFormatValueFunc) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	if fn != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_gtk4_ScaleFormatValueFunc)
		_args[2] = C.gpointer(gbox.Assign(fn))
		_args[3] = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	girepository.MustFind("Gtk", "Scale").InvokeMethod("set_format_value_func", _args[:], nil)

	runtime.KeepAlive(scale)
	runtime.KeepAlive(fn)
}

// SetHasOrigin sets whether the scale has an origin.
//
// If gtkscale:has-origin is set to TRUE (the default), the scale will highlight
// the part of the trough between the origin (bottom or left side) and the
// current value.
//
// The function takes the following parameters:
//
//    - hasOrigin: TRUE if the scale has an origin.
//
func (scale *Scale) SetHasOrigin(hasOrigin bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	if hasOrigin {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Scale").InvokeMethod("set_has_origin", _args[:], nil)

	runtime.KeepAlive(scale)
	runtime.KeepAlive(hasOrigin)
}

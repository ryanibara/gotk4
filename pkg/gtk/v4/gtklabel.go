// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_gtk4_Label_ConnectActivateLink(gpointer, void*, guintptr);
// extern void _gotk4_gtk4_Label_ConnectActivateCurrentLink(gpointer, guintptr);
// extern void _gotk4_gtk4_Label_ConnectCopyClipboard(gpointer, guintptr);
import "C"

// glib.Type values for gtklabel.go.
var GTypeLabel = coreglib.Type(C.gtk_label_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeLabel, F: marshalLabel},
	})
}

// Label: GtkLabel widget displays a small amount of text.
//
// As the name implies, most labels are used to label another widget such as a
// button.
//
// !An example GtkLabel (label.png)
//
// CSS nodes
//
//    label
//    ├── [selection]
//    ├── [link]
//    ┊
//    ╰── [link]
//
//
// GtkLabel has a single CSS node with the name label. A wide variety of style
// classes may be applied to labels, such as .title, .subtitle, .dim-label, etc.
// In the GtkShortcutsWindow, labels are used with the .keycap style class.
//
// If the label has a selection, it gets a subnode with name selection.
//
// If the label has links, there is one subnode per link. These subnodes carry
// the link or visited state depending on whether they have been visited. In
// this case, label node also gets a .link style class.
//
//
// GtkLabel as GtkBuildable
//
// The GtkLabel implementation of the GtkBuildable interface supports a custom
// <attributes> element, which supports any number of <attribute> elements. The
// <attribute> element has attributes named “name“, “value“, “start“ and “end“
// and allows you to specify pango.Attribute values for this label.
//
// An example of a UI definition fragment specifying Pango attributes:
//
//    <object class="GtkLabel">
//      <attributes>
//        <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
//        <attribute name="background" value="red" start="5" end="10"/>
//      </attributes>
//    </object>
//
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
//
// Accessibility
//
// GtkLabel uses the K_ACCESSIBLE_ROLE_LABEL role.
//
//
// Mnemonics
//
// Labels may contain “mnemonics”. Mnemonics are underlined characters in the
// label, used for keyboard navigation. Mnemonics are created by providing a
// string with an underscore before the mnemonic character, such as "_File", to
// the functions gtk.Label.NewWithMnemonic or gtk.Label.SetTextWithMnemonic().
//
// Mnemonics automatically activate any activatable widget the label is inside,
// such as a gtk.Button; if the label is not inside the mnemonic’s target
// widget, you have to tell the label about the target using
// gtk.Label.SetMnemonicWidget. Here’s a simple example where the label is
// inside a button:
//
//    // Pressing Alt+H will activate this button
//    GtkWidget *button = gtk_button_new ();
//    GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
//    gtk_button_set_child (GTK_BUTTON (button), label);
//
//
// There’s a convenience function to create buttons with a mnemonic label
// already inside:
//
//    // Pressing Alt+H will activate this button
//    GtkWidget *button = gtk_button_new_with_mnemonic ("_Hello");
//
//
// To create a mnemonic for a widget alongside the label, such as a gtk.Entry,
// you have to point the label at the entry with gtk.Label.SetMnemonicWidget():
//
//    // Pressing Alt+H will focus the entry
//    GtkWidget *entry = gtk_entry_new ();
//    GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
//    gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry);
//
//
// Markup (styled text)
//
// To make it easy to format text in a label (changing colors, fonts, etc.),
// label text can be provided in a simple markup format:
//
// Here’s how to create a label with a small font:
//
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), "<small>Small text</small>");
//
//
// (See the Pango manual for complete documentation] of available tags,
// pango.ParseMarkup())
//
// The markup passed to gtk_label_set_markup() must be valid; for example,
// literal <, > and & characters must be escaped as &lt;, &gt;, and &amp;. If
// you pass text obtained from the user, file, or a network to
// gtk.Label.SetMarkup(), you’ll want to escape it with g_markup_escape_text()
// or g_markup_printf_escaped().
//
// Markup strings are just a convenient way to set the pango.AttrList on a
// label; gtk.Label.SetAttributes() may be a simpler way to set attributes in
// some cases. Be careful though; pango.AttrList tends to cause
// internationalization problems, unless you’re applying attributes to the
// entire string (i.e. unless you set the range of each attribute to [0,
// G_MAXINT)). The reason is that specifying the start_index and end_index for a
// pango.Attribute requires knowledge of the exact string being displayed, so
// translations will cause problems.
//
//
// Selectable labels
//
// Labels can be made selectable with gtk.Label.SetSelectable(). Selectable
// labels allow the user to copy the label contents to the clipboard. Only
// labels that contain useful-to-copy information — such as error messages —
// should be made selectable.
//
//
// Text layout
//
// A label can contain any number of paragraphs, but will have performance
// problems if it contains more than a small number. Paragraphs are separated by
// newlines or other paragraph separators understood by Pango.
//
// Labels can automatically wrap text if you call gtk.Label.SetWrap().
//
// gtk.Label.SetJustify() sets how the lines in a label align with one another.
// If you want to set how the label as a whole aligns in its available space,
// see the gtk.Widget:halign and gtk.Widget:valign properties.
//
// The gtk.Label:width-chars and gtk.Label:max-width-chars properties can be
// used to control the size allocation of ellipsized or wrapped labels. For
// ellipsizing labels, if either is specified (and less than the actual text
// size), it is used as the minimum width, and the actual text size is used as
// the natural width of the label. For wrapping labels, width-chars is used as
// the minimum width, if specified, and max-width-chars is used as the natural
// width. Even if max-width-chars specified, wrapping labels will be rewrapped
// to use all of the available width.
//
//
// Links
//
// GTK supports markup for clickable hyperlinks in addition to regular Pango
// markup. The markup for links is borrowed from HTML, using the <a> with
// “href“, “title“ and “class“ attributes. GTK renders links similar to the way
// they appear in web browsers, with colored, underlined text. The “title“
// attribute is displayed as a tooltip on the link. The “class“ attribute is
// used as style class on the CSS node for the link.
//
// An example looks like this:
//
//    const char *text =
//    "Go to the"
//    "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//    "GTK website</a> for more...";
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), text);
//
//
// It is possible to implement custom handling for links and their tooltips with
// the gtk.Label::activate-link signal and the gtk.Label.GetCurrentURI()
// function.
type Label struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Label)(nil)
)

func wrapLabel(obj *coreglib.Object) *Label {
	return &Label{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalLabel(p uintptr) (interface{}, error) {
	return wrapLabel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_Label_ConnectActivateCurrentLink
func _gotk4_gtk4_Label_ConnectActivateCurrentLink(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivateCurrentLink gets emitted when the user activates a link in the
// label.
//
// The ::activate-current-link is a keybinding signal (class.SignalAction.html).
//
// Applications may also emit the signal with g_signal_emit_by_name() if they
// need to control activation of URIs programmatically.
//
// The default bindings for this signal are all forms of the Enter key.
func (self *Label) ConnectActivateCurrentLink(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate-current-link", false, unsafe.Pointer(C._gotk4_gtk4_Label_ConnectActivateCurrentLink), f)
}

//export _gotk4_gtk4_Label_ConnectActivateLink
func _gotk4_gtk4_Label_ConnectActivateLink(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) (cret C.gboolean) {
	var f func(uri string) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(uri string) (ok bool))
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := f(_uri)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectActivateLink gets emitted to activate a URI.
//
// Applications may connect to it to override the default behaviour, which is to
// call gtk_show_uri().
func (self *Label) ConnectActivateLink(f func(uri string) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate-link", false, unsafe.Pointer(C._gotk4_gtk4_Label_ConnectActivateLink), f)
}

//export _gotk4_gtk4_Label_ConnectCopyClipboard
func _gotk4_gtk4_Label_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCopyClipboard gets emitted to copy the slection to the clipboard.
//
// The ::copy-clipboard signal is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is Ctrl-c.
func (self *Label) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Label_ConnectCopyClipboard), f)
}

// NewLabel creates a new label with the given text inside it.
//
// You can pass NULL to get an empty label widget.
//
// The function takes the following parameters:
//
//    - str (optional): text of the label.
//
// The function returns the following values:
//
//    - label: new GtkLabel.
//
func NewLabel(str string) *Label {
	var _args [1]girepository.Argument

	if str != "" {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_args[0]))
	}

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("new_Label", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _label *Label // out

	_label = wrapLabel(coreglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// NewLabelWithMnemonic creates a new GtkLabel, containing the text in str.
//
// If characters in str are preceded by an underscore, they are underlined. If
// you need a literal underscore character in a label, use '__' (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. The mnemonic key can be used to activate
// another widget, chosen automatically, or explicitly using
// gtk.Label.SetMnemonicWidget().
//
// If gtk.Label.SetMnemonicWidget() is not called, then the first activatable
// ancestor of the GtkLabel will be chosen as the mnemonic widget. For instance,
// if the label is inside a button or menu item, the button or menu item will
// automatically become the mnemonic widget and be activated by the mnemonic.
//
// The function takes the following parameters:
//
//    - str (optional): text of the label, with an underscore in front of the
//      mnemonic character.
//
// The function returns the following values:
//
//    - label: new GtkLabel.
//
func NewLabelWithMnemonic(str string) *Label {
	var _args [1]girepository.Argument

	if str != "" {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_args[0]))
	}

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("new_Label_with_mnemonic", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _label *Label // out

	_label = wrapLabel(coreglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// Attributes gets the labels attribute list.
//
// This is the pango.AttrList that was set on the label using
// gtk.Label.SetAttributes(), if any. This function does not reflect attributes
// that come from the labels markup (see gtk.Label.SetMarkup()). If you want to
// get the effective attributes for the label, use pango_layout_get_attribute
// (gtk_label_get_layout (self)).
//
// The function returns the following values:
//
//    - attrList (optional): attribute list, or NULL if none was set.
//
func (self *Label) Attributes() *pango.AttrList {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_attributes", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _attrList *pango.AttrList // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_attrList = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// CurrentURI returns the URI for the currently active link in the label.
//
// The active link is the one under the mouse pointer or, in a selectable label,
// the link in which the text cursor is currently positioned.
//
// This function is intended for use in a gtk.Label::activate-link handler or
// for use in a gtk.Widget::query-tooltip handler.
//
// The function returns the following values:
//
//    - utf8 (optional): currently active URI or NULL if there is none. The
//      string is owned by GTK and must not be freed or modified.
//
func (self *Label) CurrentURI() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_current_uri", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _utf8 string // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ExtraMenu gets the extra menu model of label.
//
// See gtk.Label.SetExtraMenu().
//
// The function returns the following values:
//
//    - menuModel (optional): menu model.
//
func (self *Label) ExtraMenu() gio.MenuModeller {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_extra_menu", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _menuModel gio.MenuModeller // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// Label fetches the text from a label.
//
// The returned text includes any embedded underlines indicating mnemonics and
// Pango markup. (See gtk.Label.GetText()).
//
// The function returns the following values:
//
//    - utf8: text of the label widget. This string is owned by the widget and
//      must not be modified or freed.
//
func (self *Label) Label() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_label", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Layout gets the PangoLayout used to display the label.
//
// The layout is useful to e.g. convert text positions to pixel positions, in
// combination with gtk.Label.GetLayoutOffsets(). The returned layout is owned
// by the label so need not be freed by the caller. The label is free to
// recreate its layout at any time, so it should be considered read-only.
//
// The function returns the following values:
//
//    - layout: pango.Layout for this label.
//
func (self *Label) Layout() *pango.Layout {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_layout", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _layout *pango.Layout // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// LayoutOffsets obtains the coordinates where the label will draw its
// PangoLayout.
//
// The coordinates are useful to convert mouse events into coordinates inside
// the pango.Layout, e.g. to take some action if some part of the label is
// clicked. Remember when using the pango.Layout functions you need to convert
// to and from pixels using PANGO_PIXELS() or pango.SCALE.
//
// The function returns the following values:
//
//    - x (optional): location to store X offset of layout, or NULL.
//    - y (optional): location to store Y offset of layout, or NULL.
//
func (self *Label) LayoutOffsets() (x, y int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	girepository.MustFind("Gtk", "Label").InvokeMethod("get_layout_offsets", _args[:], _outs[:])

	runtime.KeepAlive(self)

	var _x int32 // out
	var _y int32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_x = *(*int32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_y = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _x, _y
}

// Lines gets the number of lines to which an ellipsized, wrapping label should
// be limited.
//
// See gtk.Label.SetLines().
//
// The function returns the following values:
//
//    - gint: number of lines.
//
func (self *Label) Lines() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_lines", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// MaxWidthChars retrieves the desired maximum width of label, in characters.
//
// See gtk.Label.SetWidthChars().
//
// The function returns the following values:
//
//    - gint: maximum width of the label in characters.
//
func (self *Label) MaxWidthChars() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_max_width_chars", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// MnemonicKeyval: return the mnemonic accelerator.
//
// If the label has been set so that it has a mnemonic key this function returns
// the keyval used for the mnemonic accelerator. If there is no mnemonic set up
// it returns GDK_KEY_VoidSymbol.
//
// The function returns the following values:
//
//    - guint: GDK keyval usable for accelerators, or GDK_KEY_VoidSymbol.
//
func (self *Label) MnemonicKeyval() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_mnemonic_keyval", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut) of
// this label.
//
// See gtk.Label.SetMnemonicWidget().
//
// The function returns the following values:
//
//    - widget (optional): target of the label’s mnemonic, or NULL if none has
//      been set and the default algorithm will be used.
//
func (self *Label) MnemonicWidget() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_mnemonic_widget", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Selectable returns whether the label is selectable.
//
// The function returns the following values:
//
//    - ok: TRUE if the user can copy text from the label.
//
func (self *Label) Selectable() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_selectable", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SelectionBounds gets the selected range of characters in the label.
//
// The function returns the following values:
//
//    - start: return location for start of selection, as a character offset.
//    - end: return location for end of selection, as a character offset.
//    - ok: TRUE if selection is non-empty.
//
func (self *Label) SelectionBounds() (start, end int32, ok bool) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_selection_bounds", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _start int32 // out
	var _end int32   // out
	var _ok bool     // out

	_start = *(*int32)(unsafe.Pointer(_outs[0]))
	_end = *(*int32)(unsafe.Pointer(_outs[1]))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// SingleLineMode returns whether the label is in single line mode.
//
// The function returns the following values:
//
//    - ok: TRUE when the label is in single line mode.
//
func (self *Label) SingleLineMode() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_single_line_mode", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Text fetches the text from a label.
//
// The returned text is as it appears on screen. This does not include any
// embedded underlines indicating mnemonics or Pango markup. (See
// gtk.Label.GetLabel()).
//
// The function returns the following values:
//
//    - utf8: text in the label widget. This is the internal string used by the
//      label, and must not be modified.
//
func (self *Label) Text() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_text", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UseMarkup returns whether the label’s text is interpreted as Pango markup.
//
// See gtk.Label.SetUseMarkup().
//
// The function returns the following values:
//
//    - ok: TRUE if the label’s text will be parsed for markup.
//
func (self *Label) UseMarkup() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_use_markup", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an embedded underlines in the label indicate
// mnemonics.
//
// See gtk.Label.SetUseUnderline().
//
// The function returns the following values:
//
//    - ok: TRUE whether an embedded underline in the label indicates the
//      mnemonic accelerator keys.
//
func (self *Label) UseUnderline() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_use_underline", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// WidthChars retrieves the desired width of label, in characters.
//
// See gtk.Label.SetWidthChars().
//
// The function returns the following values:
//
//    - gint: width of the label in characters.
//
func (self *Label) WidthChars() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_width_chars", _args[:], nil)
	_cret = *(*C.int)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _gint int32 // out

	_gint = int32(*(*C.int)(unsafe.Pointer(&_cret)))

	return _gint
}

// Wrap returns whether lines in the label are automatically wrapped.
//
// See gtk.Label.SetWrap().
//
// The function returns the following values:
//
//    - ok: TRUE if the lines of the label are automatically wrapped.
//
func (self *Label) Wrap() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_wrap", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// XAlign gets the xalign of the label.
//
// See the gtk.Label:xalign property.
//
// The function returns the following values:
//
//    - gfloat: xalign property.
//
func (self *Label) XAlign() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_xalign", _args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// YAlign gets the yalign of the label.
//
// See the gtk.Label:yalign property.
//
// The function returns the following values:
//
//    - gfloat: yalign property.
//
func (self *Label) YAlign() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_yalign", _args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// SelectRegion selects a range of characters in the label, if the label is
// selectable.
//
// See gtk.Label.SetSelectable(). If the label is not selectable, this function
// has no effect. If start_offset or end_offset are -1, then the end of the
// label will be substituted.
//
// The function takes the following parameters:
//
//    - startOffset: start offset (in characters not bytes).
//    - endOffset: end offset (in characters not bytes).
//
func (self *Label) SelectRegion(startOffset, endOffset int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(startOffset)
	*(*C.int)(unsafe.Pointer(&_args[2])) = C.int(endOffset)

	girepository.MustFind("Gtk", "Label").InvokeMethod("select_region", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)
}

// SetAttributes: apply attributes to the label text.
//
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the gtk.Label:use-underline or
// gtk.Label:use-markup properties. While it is not recommended to mix markup
// strings with manually set attributes, if you must; know that the attributes
// will be applied to the label after the markup string is parsed.
//
// The function takes the following parameters:
//
//    - attrs (optional): pango.AttrList, or NULL.
//
func (self *Label) SetAttributes(attrs *pango.AttrList) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if attrs != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(attrs)))
	}

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_attributes", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(attrs)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// label.
//
// The function takes the following parameters:
//
//    - model (optional): GMenuModel.
//
func (self *Label) SetExtraMenu(model gio.MenuModeller) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_extra_menu", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetLabel sets the text of the label.
//
// The label is interpreted as including embedded underlines and/or Pango markup
// depending on the values of the gtk.Label:use-underline and
// gtk.Label:use-markup properties.
//
// The function takes the following parameters:
//
//    - str: new text to set for the label.
//
func (self *Label) SetLabel(str string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_label", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited.
//
// This has no effect if the label is not wrapping or ellipsized. Set this to -1
// if you don’t want to limit the number of lines.
//
// The function takes the following parameters:
//
//    - lines: desired number of lines, or -1.
//
func (self *Label) SetLines(lines int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(lines)

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_lines", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(lines)
}

// SetMarkup sets the labels text and attributes from markup.
//
// The string must be marked up with Pango markup (see pango.ParseMarkup()).
//
// If the str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
//    GtkWidget *self = gtk_label_new (NULL);
//    const char *str = "...";
//    const char *format = "<span style=\"italic\">\s</span>";
//    char *markup;
//
//    markup = g_markup_printf_escaped (format, str);
//    gtk_label_set_markup (GTK_LABEL (self), markup);
//    g_free (markup);
//
//
// This function will set the gtk.Label:use-markup property to TRUE as a side
// effect.
//
// If you set the label contents using the gtk.Label:label property you should
// also ensure that you set the gtk.Label:use-markup property accordingly.
//
// See also: gtk.Label.SetText().
//
// The function takes the following parameters:
//
//    - str: markup string.
//
func (self *Label) SetMarkup(str string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_markup", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetMarkupWithMnemonic sets the labels text, attributes and mnemonic from
// markup.
//
// Parses str which is marked up with Pango markup (see pango.ParseMarkup()),
// setting the label’s text and attribute list based on the parse results. If
// characters in str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using methodGtk.Label.set_mnemonic_widget].
//
// The function takes the following parameters:
//
//    - str: markup string.
//
func (self *Label) SetMarkupWithMnemonic(str string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_markup_with_mnemonic", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetMaxWidthChars sets the desired maximum width in characters of label to
// n_chars.
//
// The function takes the following parameters:
//
//    - nChars: new desired maximum width, in characters.
//
func (self *Label) SetMaxWidthChars(nChars int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(nChars)

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_max_width_chars", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(nChars)
}

// SetMnemonicWidget: associate the label with its mnemonic target.
//
// If the label has been set so that it has a mnemonic key (using i.e.
// gtk.Label.SetMarkupWithMnemonic(), gtk.Label.SetTextWithMnemonic(),
// gtk.Label.NewWithMnemonic or the gtk.Label:useUnderline property) the label
// can be associated with a widget that is the target of the mnemonic. When the
// label is inside a widget (like a gtk.Button or a gtk.Notebook tab) it is
// automatically associated with the correct widget, but sometimes (i.e. when
// the target is a gtk.Entry next to the label) you need to set it explicitly
// using this function.
//
// The target widget will be accelerated by emitting the
// gtkwidget::mnemonic-activate signal on it. The default handler for this
// signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
//
// The function takes the following parameters:
//
//    - widget (optional): target Widget, or NULL to unset.
//
func (self *Label) SetMnemonicWidget(widget Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if widget != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_mnemonic_widget", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(widget)
}

// SetSelectable makes text in the label selectable.
//
// Selectable labels allow the user to select text from the label, for
// copy-and-paste.
//
// The function takes the following parameters:
//
//    - setting: TRUE to allow selecting text in the label.
//
func (self *Label) SetSelectable(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_selectable", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetSingleLineMode sets whether the label is in single line mode.
//
// The function takes the following parameters:
//
//    - singleLineMode: TRUE if the label should be in single line mode.
//
func (self *Label) SetSingleLineMode(singleLineMode bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if singleLineMode {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_single_line_mode", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(singleLineMode)
}

// SetText sets the text within the GtkLabel widget.
//
// It overwrites any text that was there before.
//
// This function will clear any previously set mnemonic accelerators, and set
// the gtk.Label:use-underline property to FALSE as a side effect.
//
// This function will set the gtk.Label:use-markup property to FALSE as a side
// effect.
//
// See also: gtk.Label.SetMarkup().
//
// The function takes the following parameters:
//
//    - str: text you want to set.
//
func (self *Label) SetText(str string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_text", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetTextWithMnemonic sets the label’s text from the string str.
//
// If characters in str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic. The
// mnemonic key can be used to activate another widget, chosen automatically, or
// explicitly using gtk.Label.SetMnemonicWidget().
//
// The function takes the following parameters:
//
//    - str: string.
//
func (self *Label) SetTextWithMnemonic(str string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_text_with_mnemonic", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetUseMarkup sets whether the text of the label contains markup.
//
// See gtk.Label.SetMarkup().
//
// The function takes the following parameters:
//
//    - setting: TRUE if the label’s text should be parsed for markup.
//
func (self *Label) SetUseMarkup(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_use_markup", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetUseUnderline sets whether underlines in the text indicate mnemonics.
//
// The function takes the following parameters:
//
//    - setting: TRUE if underlines in the text indicate mnemonics.
//
func (self *Label) SetUseUnderline(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_use_underline", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetWidthChars sets the desired width in characters of label to n_chars.
//
// The function takes the following parameters:
//
//    - nChars: new desired width, in characters.
//
func (self *Label) SetWidthChars(nChars int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(*C.int)(unsafe.Pointer(&_args[1])) = C.int(nChars)

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_width_chars", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(nChars)
}

// SetWrap toggles line wrapping within the GtkLabel widget.
//
// TRUE makes it break lines if text exceeds the widget’s size. FALSE lets the
// text get cut off by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to TRUE does not make the label wrap at its
// parent container’s width, because GTK widgets conceptually can’t make their
// requisition depend on the parent container’s size. For a label that wraps at
// a specific position, set the label’s width using gtk.Widget.SetSizeRequest().
//
// The function takes the following parameters:
//
//    - wrap: setting.
//
func (self *Label) SetWrap(wrap bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if wrap {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_wrap", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(wrap)
}

// SetXAlign sets the xalign of the label.
//
// See the gtk.Label:xalign property.
//
// The function takes the following parameters:
//
//    - xalign: new xalign value, between 0 and 1.
//
func (self *Label) SetXAlign(xalign float32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(xalign)

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_xalign", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(xalign)
}

// SetYAlign sets the yalign of the label.
//
// See the gtk.Label:yalign property.
//
// The function takes the following parameters:
//
//    - yalign: new yalign value, between 0 and 1.
//
func (self *Label) SetYAlign(yalign float32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(yalign)

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_yalign", _args[:], nil)

	runtime.KeepAlive(self)
	runtime.KeepAlive(yalign)
}

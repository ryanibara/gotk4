// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_gtk4_IconView_ConnectActivateCursorItem(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectItemActivated(gpointer, GtkTreePath*, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectSelectAll(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectSelectCursorItem(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectSelectionChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectToggleCursorItem(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectUnselectAll(gpointer, guintptr);
import "C"

// glib.Type values for gtkiconview.go.
var (
	GTypeIconViewDropPosition = coreglib.Type(C.gtk_icon_view_drop_position_get_type())
	GTypeIconView             = coreglib.Type(C.gtk_icon_view_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeIconViewDropPosition, F: marshalIconViewDropPosition},
		{T: GTypeIconView, F: marshalIconView},
	})
}

// IconViewDropPosition: enum for determining where a dropped item goes.
type IconViewDropPosition C.gint

const (
	// IconViewNoDrop: no drop possible.
	IconViewNoDrop IconViewDropPosition = iota
	// IconViewDropInto: dropped item replaces the item.
	IconViewDropInto
	// IconViewDropLeft: dropped item is inserted to the left.
	IconViewDropLeft
	// IconViewDropRight: dropped item is inserted to the right.
	IconViewDropRight
	// IconViewDropAbove: dropped item is inserted above.
	IconViewDropAbove
	// IconViewDropBelow: dropped item is inserted below.
	IconViewDropBelow
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconViewDropPosition.
func (i IconViewDropPosition) String() string {
	switch i {
	case IconViewNoDrop:
		return "NoDrop"
	case IconViewDropInto:
		return "DropInto"
	case IconViewDropLeft:
		return "DropLeft"
	case IconViewDropRight:
		return "DropRight"
	case IconViewDropAbove:
		return "DropAbove"
	case IconViewDropBelow:
		return "DropBelow"
	default:
		return fmt.Sprintf("IconViewDropPosition(%d)", i)
	}
}

// IconViewForEachFunc: function used by gtk_icon_view_selected_foreach() to map
// all selected rows.
//
// It will be called on every selected row in the view.
type IconViewForEachFunc func(iconView *IconView, path *TreePath)

//export _gotk4_gtk4_IconViewForEachFunc
func _gotk4_gtk4_IconViewForEachFunc(arg1 *C.GtkIconView, arg2 *C.GtkTreePath, arg3 C.gpointer) {
	var fn IconViewForEachFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(IconViewForEachFunc)
	}

	var _iconView *IconView // out
	var _path *TreePath     // out

	_iconView = wrapIconView(coreglib.Take(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	fn(_iconView, _path)
}

// IconView: GtkIconView is a widget which displays data in a grid of icons.
//
// GtkIconView provides an alternative view on a GtkTreeModel. It displays the
// model as a grid of icons with labels. Like gtk.TreeView, it allows to select
// one or multiple items (depending on the selection mode, see
// gtk.IconView.SetSelectionMode()). In addition to selection with the arrow
// keys, GtkIconView supports rubberband selection, which is controlled by
// dragging the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
// CSS nodes
//
//    iconview.view
//    ╰── [rubberband]
//
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	CellLayout
	Scrollable
}

var (
	_ Widgetter         = (*IconView)(nil)
	_ coreglib.Objector = (*IconView)(nil)
)

func wrapIconView(obj *coreglib.Object) *IconView {
	return &IconView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		CellLayout: CellLayout{
			Object: obj,
		},
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalIconView(p uintptr) (interface{}, error) {
	return wrapIconView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_IconView_ConnectActivateCursorItem
func _gotk4_gtk4_IconView_ConnectActivateCursorItem(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectActivateCursorItem: [keybinding signal][GtkSignalAction] which gets
// emitted when the user activates the currently focused item.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control activation programmatically.
//
// The default bindings for this signal are Space, Return and Enter.
func (iconView *IconView) ConnectActivateCursorItem(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "activate-cursor-item", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectActivateCursorItem), f)
}

//export _gotk4_gtk4_IconView_ConnectItemActivated
func _gotk4_gtk4_IconView_ConnectItemActivated(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 C.guintptr) {
	var f func(path *TreePath)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath))
	}

	var _path *TreePath // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_path)
}

// ConnectItemActivated signal is emitted when the method
// gtk_icon_view_item_activated() is called, when the user double clicks an item
// with the "activate-on-single-click" property set to FALSE, or when the user
// single clicks an item when the "activate-on-single-click" property set to
// TRUE. It is also emitted when a non-editable item is selected and one of the
// keys: Space, Return or Enter is pressed.
func (iconView *IconView) ConnectItemActivated(f func(path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "item-activated", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectItemActivated), f)
}

//export _gotk4_gtk4_IconView_ConnectSelectAll
func _gotk4_gtk4_IconView_ConnectSelectAll(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectSelectAll: [keybinding signal][GtkSignalAction] which gets emitted
// when the user selects all items.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// The default binding for this signal is Ctrl-a.
func (iconView *IconView) ConnectSelectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectSelectAll), f)
}

//export _gotk4_gtk4_IconView_ConnectSelectCursorItem
func _gotk4_gtk4_IconView_ConnectSelectCursorItem(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectSelectCursorItem: [keybinding signal][GtkSignalAction] which gets
// emitted when the user selects the item that is currently focused.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// There is no default binding for this signal.
func (iconView *IconView) ConnectSelectCursorItem(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "select-cursor-item", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectSelectCursorItem), f)
}

//export _gotk4_gtk4_IconView_ConnectSelectionChanged
func _gotk4_gtk4_IconView_ConnectSelectionChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectSelectionChanged signal is emitted when the selection (i.e. the set of
// selected items) changes.
func (iconView *IconView) ConnectSelectionChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "selection-changed", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectSelectionChanged), f)
}

//export _gotk4_gtk4_IconView_ConnectToggleCursorItem
func _gotk4_gtk4_IconView_ConnectToggleCursorItem(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectToggleCursorItem: [keybinding signal][GtkSignalAction] which gets
// emitted when the user toggles whether the currently focused item is selected
// or not. The exact effect of this depend on the selection mode.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// There is no default binding for this signal is Ctrl-Space.
func (iconView *IconView) ConnectToggleCursorItem(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "toggle-cursor-item", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectToggleCursorItem), f)
}

//export _gotk4_gtk4_IconView_ConnectUnselectAll
func _gotk4_gtk4_IconView_ConnectUnselectAll(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectUnselectAll: [keybinding signal][GtkSignalAction] which gets emitted
// when the user unselects all items.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// The default binding for this signal is Ctrl-Shift-a.
func (iconView *IconView) ConnectUnselectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "unselect-all", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectUnselectAll), f)
}

// NewIconView creates a new IconView widget.
//
// The function returns the following values:
//
//    - iconView: newly created IconView widget.
//
func NewIconView() *IconView {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("new_IconView", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _iconView *IconView // out

	_iconView = wrapIconView(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// NewIconViewWithArea creates a new IconView widget using the specified area to
// layout cells inside the icons.
//
// The function takes the following parameters:
//
//    - area to use to layout cells.
//
// The function returns the following values:
//
//    - iconView: newly created IconView widget.
//
func NewIconViewWithArea(area CellAreaer) *IconView {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	*(*CellAreaer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("new_IconView_with_area", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(area)

	var _iconView *IconView // out

	_iconView = wrapIconView(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// NewIconViewWithModel creates a new IconView widget with the model model.
//
// The function takes the following parameters:
//
//    - model: model.
//
// The function returns the following values:
//
//    - iconView: newly created IconView widget.
//
func NewIconViewWithModel(model TreeModeller) *IconView {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*TreeModeller)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("new_IconView_with_model", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)

	var _iconView *IconView // out

	_iconView = wrapIconView(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// CreateDragIcon creates a #cairo_surface_t representation of the item at path.
// This image is used for a drag icon.
//
// The function takes the following parameters:
//
//    - path in icon_view.
//
// The function returns the following values:
//
//    - paintable: newly-allocated surface of the drag icon.
//
func (iconView *IconView) CreateDragIcon(path *TreePath) *gdk.Paintable {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("create_drag_icon", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)

	var _paintable *gdk.Paintable // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_paintable = &gdk.Paintable{
			Object: obj,
		}
	}

	return _paintable
}

// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
//
// The function returns the following values:
//
//    - ok: TRUE if item-activated will be emitted on a single click.
//
func (iconView *IconView) ActivateOnSingleClick() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("get_activate_on_single_click", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Cursor fills in path and cell with the current cursor path and cell. If the
// cursor isn’t currently set, then *path will be NULL. If no cell currently has
// focus, then *cell will be NULL.
//
// The returned TreePath must be freed with gtk_tree_path_free().
//
// The function returns the following values:
//
//    - path (optional): return location for the current cursor path, or NULL.
//    - cell (optional): return location the current focus cell, or NULL.
//    - ok: TRUE if the cursor is set.
//
func (iconView *IconView) Cursor() (*TreePath, CellRendererer, bool) {
	var args [1]girepository.Argument
	var outs [2]girepository.Argument
	var _arg0 *C.void    // out
	var _out0 *C.void    // in
	var _out1 *C.void    // in
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("get_cursor", args[:], outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconView)

	var _path *TreePath      // out
	var _cell CellRendererer // out
	var _ok bool             // out
	_out1 = *(**TreePath)(unsafe.Pointer(&outs[1]))

	if _out0 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_out0)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _out1 != nil {
		{
			objptr := unsafe.Pointer(_out1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			_cell = rv
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

// Model returns the model the IconView is based on. Returns NULL if the model
// is unset.
//
// The function returns the following values:
//
//    - treeModel (optional) or NULL if none is currently being used.
//
func (iconView *IconView) Model() *TreeModel {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("get_model", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconView)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
//
// The function returns the following values:
//
//    - ok: TRUE if the list can be reordered.
//
func (iconView *IconView) Reorderable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("get_reorderable", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectedItems creates a list of paths of all selected items. Additionally, if
// you are planning on modifying the model after calling this function, you may
// want to convert the returned list into a list of TreeRowReferences. To do
// this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//    g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);.
//
// The function returns the following values:
//
//    - list containing a TreePath for each selected row.
//
func (iconView *IconView) SelectedItems() []*TreePath {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("get_selected_items", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconView)

	var _list []*TreePath // out

	_list = make([]*TreePath, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *TreePath // out
		dst = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// VisibleRange sets start_path and end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
//
// The function returns the following values:
//
//    - startPath (optional): return location for start of region, or NULL.
//    - endPath (optional): return location for end of region, or NULL.
//    - ok: TRUE, if valid paths were placed in start_path and end_path.
//
func (iconView *IconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var args [1]girepository.Argument
	var outs [2]girepository.Argument
	var _arg0 *C.void    // out
	var _out0 *C.void    // in
	var _out1 *C.void    // in
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("get_visible_range", args[:], outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconView)

	var _startPath *TreePath // out
	var _endPath *TreePath   // out
	var _ok bool             // out
	_out1 = *(**TreePath)(unsafe.Pointer(&outs[1]))

	if _out0 != nil {
		_startPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_out0)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_startPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _out1 != nil {
		_endPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_out1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_endPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// ItemActivated activates the item determined by path.
//
// The function takes the following parameters:
//
//    - path to be activated.
//
func (iconView *IconView) ItemActivated(path *TreePath) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconView").InvokeMethod("item_activated", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
}

// PathIsSelected returns TRUE if the icon pointed to by path is currently
// selected. If path does not point to a valid location, FALSE is returned.
//
// The function takes the following parameters:
//
//    - path to check selection on.
//
// The function returns the following values:
//
//    - ok: TRUE if path is selected.
//
func (iconView *IconView) PathIsSelected(path *TreePath) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "IconView").InvokeMethod("path_is_selected", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectAll selects all the icons. icon_view must has its selection mode set to
// K_SELECTION_MULTIPLE.
func (iconView *IconView) SelectAll() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "IconView").InvokeMethod("select_all", args[:], nil)

	runtime.KeepAlive(iconView)
}

// SelectPath selects the row at path.
//
// The function takes the following parameters:
//
//    - path to be selected.
//
func (iconView *IconView) SelectPath(path *TreePath) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconView").InvokeMethod("select_path", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
}

// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
//
// The function takes the following parameters:
//
//    - single: TRUE to emit item-activated on a single click.
//
func (iconView *IconView) SetActivateOnSingleClick(single bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if single {
		_arg1 = C.TRUE
	}
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconView").InvokeMethod("set_activate_on_single_click", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(single)
}

// SetCursor sets the current keyboard focus to be at path, and selects it. This
// is useful when you want to focus the user’s attention on a particular item.
// If cell is not NULL, then focus is given to the cell specified by it.
// Additionally, if start_editing is TRUE, then editing should be started in the
// specified cell.
//
// This function is often followed by gtk_widget_grab_focus (icon_view) in order
// to give keyboard focus to the widget. Please note that editing can only
// happen when the widget is realized.
//
// The function takes the following parameters:
//
//    - path: TreePath.
//    - cell (optional): one of the cell renderers of icon_view, or NULL.
//    - startEditing: TRUE if the specified cell should start being edited.
//
func (iconView *IconView) SetCursor(path *TreePath, cell CellRendererer, startEditing bool) {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	if cell != nil {
		_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}
	if startEditing {
		_arg3 = C.TRUE
	}
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TreePath)(unsafe.Pointer(&args[2])) = _arg2
	*(*CellRendererer)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "IconView").InvokeMethod("set_cursor", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(startEditing)
}

// SetModel sets the model for a IconView. If the icon_view already has a model
// set, it will remove it before setting the new model. If model is NULL, then
// it will unset the old model.
//
// The function takes the following parameters:
//
//    - model (optional): model.
//
func (iconView *IconView) SetModel(model TreeModeller) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if model != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconView").InvokeMethod("set_model", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(model)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If reorderable
// is TRUE, then the user can reorder the model by dragging and dropping rows.
// The developer can listen to these changes by connecting to the model's
// row_inserted and row_deleted signals. The reordering is implemented by
// setting up the icon view as a drag source and destination. Therefore, drag
// and drop can not be used in a reorderable view for any other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
//
// The function takes the following parameters:
//
//    - reorderable: TRUE, if the list of items can be reordered.
//
func (iconView *IconView) SetReorderable(reorderable bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if reorderable {
		_arg1 = C.TRUE
	}
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconView").InvokeMethod("set_reorderable", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(reorderable)
}

// SetTooltipCell sets the tip area of tooltip to the area which cell occupies
// in the item pointed to by path. See also gtk_tooltip_set_tip_area().
//
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
//
// The function takes the following parameters:
//
//    - tooltip: Tooltip.
//    - path: TreePath.
//    - cell (optional) or NULL.
//
func (iconView *IconView) SetTooltipCell(tooltip *Tooltip, path *TreePath, cell CellRendererer) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	if cell != nil {
		_arg3 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1
	*(**Tooltip)(unsafe.Pointer(&args[2])) = _arg2
	*(**TreePath)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "IconView").InvokeMethod("set_tooltip_cell", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cell)
}

// SetTooltipItem sets the tip area of tooltip to be the area covered by the
// item at path. See also gtk_icon_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
//
// The function takes the following parameters:
//
//    - tooltip: Tooltip.
//    - path: TreePath.
//
func (iconView *IconView) SetTooltipItem(tooltip *Tooltip, path *TreePath) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1
	*(**Tooltip)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "IconView").InvokeMethod("set_tooltip_item", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
}

// UnselectAll unselects all the icons.
func (iconView *IconView) UnselectAll() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "IconView").InvokeMethod("unselect_all", args[:], nil)

	runtime.KeepAlive(iconView)
}

// UnselectPath unselects the row at path.
//
// The function takes the following parameters:
//
//    - path to be unselected.
//
func (iconView *IconView) UnselectPath(path *TreePath) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**IconView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconView").InvokeMethod("unselect_path", args[:], nil)

	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
}

// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to FALSE.
func (iconView *IconView) UnsetModelDragDest() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "IconView").InvokeMethod("unset_model_drag_dest", args[:], nil)

	runtime.KeepAlive(iconView)
}

// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to FALSE.
func (iconView *IconView) UnsetModelDragSource() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	*(**IconView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "IconView").InvokeMethod("unset_model_drag_source", args[:], nil)

	runtime.KeepAlive(iconView)
}

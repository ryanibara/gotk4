// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_gtk4_WindowClass_close_request(GtkWindow*);
// extern gboolean _gotk4_gtk4_WindowClass_enable_debugging(GtkWindow*, gboolean);
// extern gboolean _gotk4_gtk4_Window_ConnectCloseRequest(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_Window_ConnectEnableDebugging(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk4_WindowClass_activate_default(GtkWindow*);
// extern void _gotk4_gtk4_WindowClass_activate_focus(GtkWindow*);
// extern void _gotk4_gtk4_WindowClass_keys_changed(GtkWindow*);
// extern void _gotk4_gtk4_Window_ConnectActivateDefault(gpointer, guintptr);
// extern void _gotk4_gtk4_Window_ConnectActivateFocus(gpointer, guintptr);
// extern void _gotk4_gtk4_Window_ConnectKeysChanged(gpointer, guintptr);
import "C"

// glib.Type values for gtkwindow.go.
var GTypeWindow = coreglib.Type(C.gtk_window_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeWindow, F: marshalWindow},
	})
}

// WindowOverrider contains methods that are overridable.
type WindowOverrider interface {
	ActivateDefault()
	ActivateFocus()
	// The function returns the following values:
	//
	CloseRequest() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	EnableDebugging(toggle bool) bool
	KeysChanged()
}

// Window: GtkWindow is a toplevel window which can contain other widgets.
//
// !An example GtkWindow (window.png)
//
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the gtk.Buildable interface supports setting
// a child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background [.csd / .solid-csd / .ssd] [.maximized / .fullscreen / .tiled]
//    ├── <child>
//    ╰── <titlebar child>.titlebar [.default-decoration]
//
//
// GtkWindow has a main CSS node with name window and style class .background.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .maximized, .fullscreen, .tiled (when
// supported, also .tiled-top, .tiled-left, .tiled-right, .tiled-bottom).
//
// GtkWindow subclasses often add their own discriminating style classes, such
// as .dialog, .popup or .tooltip.
//
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the main
// window node), the CSS border of the toplevel window is used for resize drags.
// In the .csd case, the shadow area outside of the window can be used to resize
// it.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
//
//
// Accessibility
//
// GtkWindow uses the GTK_ACCESSIBLE_ROLE_WINDOW role.
type Window struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Root
	ShortcutManager
}

var (
	_ Widgetter         = (*Window)(nil)
	_ coreglib.Objector = (*Window)(nil)
)

func classInitWindower(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkWindowClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkWindowClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ ActivateDefault() }); ok {
		pclass.activate_default = (*[0]byte)(C._gotk4_gtk4_WindowClass_activate_default)
	}

	if _, ok := goval.(interface{ ActivateFocus() }); ok {
		pclass.activate_focus = (*[0]byte)(C._gotk4_gtk4_WindowClass_activate_focus)
	}

	if _, ok := goval.(interface{ CloseRequest() bool }); ok {
		pclass.close_request = (*[0]byte)(C._gotk4_gtk4_WindowClass_close_request)
	}

	if _, ok := goval.(interface{ EnableDebugging(toggle bool) bool }); ok {
		pclass.enable_debugging = (*[0]byte)(C._gotk4_gtk4_WindowClass_enable_debugging)
	}

	if _, ok := goval.(interface{ KeysChanged() }); ok {
		pclass.keys_changed = (*[0]byte)(C._gotk4_gtk4_WindowClass_keys_changed)
	}
}

//export _gotk4_gtk4_WindowClass_activate_default
func _gotk4_gtk4_WindowClass_activate_default(arg0 *C.GtkWindow) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ActivateDefault() })

	iface.ActivateDefault()
}

//export _gotk4_gtk4_WindowClass_activate_focus
func _gotk4_gtk4_WindowClass_activate_focus(arg0 *C.GtkWindow) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ActivateFocus() })

	iface.ActivateFocus()
}

//export _gotk4_gtk4_WindowClass_close_request
func _gotk4_gtk4_WindowClass_close_request(arg0 *C.GtkWindow) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CloseRequest() bool })

	ok := iface.CloseRequest()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WindowClass_enable_debugging
func _gotk4_gtk4_WindowClass_enable_debugging(arg0 *C.GtkWindow, arg1 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ EnableDebugging(toggle bool) bool })

	var _toggle bool // out

	if arg1 != 0 {
		_toggle = true
	}

	ok := iface.EnableDebugging(_toggle)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk4_WindowClass_keys_changed
func _gotk4_gtk4_WindowClass_keys_changed(arg0 *C.GtkWindow) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ KeysChanged() })

	iface.KeysChanged()
}

func wrapWindow(obj *coreglib.Object) *Window {
	return &Window{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Root: Root{
			NativeSurface: NativeSurface{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
		},
		ShortcutManager: ShortcutManager{
			Object: obj,
		},
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	return wrapWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_Window_ConnectActivateDefault
func _gotk4_gtk4_Window_ConnectActivateDefault(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivateDefault is emitted when the user activates the default widget
// of window.
//
// This is a keybinding signal (class.SignalAction.html).
func (window *Window) ConnectActivateDefault(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "activate-default", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectActivateDefault), f)
}

//export _gotk4_gtk4_Window_ConnectActivateFocus
func _gotk4_gtk4_Window_ConnectActivateFocus(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivateFocus is emitted when the user activates the currently focused
// widget of window.
//
// This is a keybinding signal (class.SignalAction.html).
func (window *Window) ConnectActivateFocus(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "activate-focus", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectActivateFocus), f)
}

//export _gotk4_gtk4_Window_ConnectCloseRequest
func _gotk4_gtk4_Window_ConnectCloseRequest(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectCloseRequest is emitted when the user clicks on the close button of
// the window.
func (window *Window) ConnectCloseRequest(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "close-request", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectCloseRequest), f)
}

//export _gotk4_gtk4_Window_ConnectEnableDebugging
func _gotk4_gtk4_Window_ConnectEnableDebugging(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(toggle bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(toggle bool) (ok bool))
	}

	var _toggle bool // out

	if arg1 != 0 {
		_toggle = true
	}

	ok := f(_toggle)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectEnableDebugging is emitted when the user enables or disables
// interactive debugging.
//
// When toggle is TRUE, interactive debugging is toggled on or off, when it is
// FALSE, the debugger will be pointed at the widget under the pointer.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are Ctrl-Shift-I and Ctrl-Shift-D.
func (window *Window) ConnectEnableDebugging(f func(toggle bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "enable-debugging", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectEnableDebugging), f)
}

//export _gotk4_gtk4_Window_ConnectKeysChanged
func _gotk4_gtk4_Window_ConnectKeysChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectKeysChanged is emitted when the set of accelerators or mnemonics that
// are associated with window changes.
func (window *Window) ConnectKeysChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "keys-changed", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectKeysChanged), f)
}

// NewWindow creates a new GtkWindow.
//
// To get an undecorated window (no window borders), use
// gtk.Window.SetDecorated().
//
// All top-level windows created by gtk_window_new() are stored in an internal
// top-level window list. This list can be obtained from
// gtk.Window().ListToplevels. Due to GTK keeping a reference to the window
// internally, gtk_window_new() does not return a reference to the caller.
//
// To delete a GtkWindow, call gtk.Window.Destroy().
//
// The function returns the following values:
//
//    - window: new GtkWindow.
//
func NewWindow() *Window {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("new_Window", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))

	return _window
}

// Close requests that the window is closed.
//
// This is similar to what happens when a window manager close button is
// clicked.
//
// This function can be used with close buttons in custom titlebars.
func (window *Window) Close() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("close", args[:], nil)

	runtime.KeepAlive(window)
}

// Destroy: drop the internal reference GTK holds on toplevel windows.
func (window *Window) Destroy() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("destroy", args[:], nil)

	runtime.KeepAlive(window)
}

// Fullscreen asks to place window in the fullscreen state.
//
// Note that you shouldn’t assume the window is definitely fullscreen afterward,
// because other entities (e.g. the user or window manager unfullscreen it
// again, and not all window managers honor requests to fullscreen windows.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications of the gtk.Window:fullscreened
// property.
func (window *Window) Fullscreen() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("fullscreen", args[:], nil)

	runtime.KeepAlive(window)
}

// FullscreenOnMonitor asks to place window in the fullscreen state on the given
// monitor.
//
// Note that you shouldn't assume the window is definitely fullscreen afterward,
// or that the windowing system allows fullscreen windows on any given monitor.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications of the gtk.Window:fullscreened
// property.
//
// The function takes the following parameters:
//
//    - monitor: which monitor to go fullscreen on.
//
func (window *Window) FullscreenOnMonitor(monitor *gdk.Monitor) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("fullscreen_on_monitor", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(monitor)
}

// Application gets the GtkApplication associated with the window.
//
// The function returns the following values:
//
//    - application (optional): GtkApplication, or NULL.
//
func (window *Window) Application() *Application {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_application", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _application *Application // out

	if _cret != nil {
		_application = wrapApplication(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _application
}

// Child gets the child widget of window.
//
// The function returns the following values:
//
//    - widget (optional): child widget of window.
//
func (window *Window) Child() Widgetter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Decorated returns whether the window has been set to have decorations.
//
// The function returns the following values:
//
//    - ok: TRUE if the window has been set to have decorations.
//
func (window *Window) Decorated() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_decorated", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultWidget returns the default widget for window.
//
// The function returns the following values:
//
//    - widget (optional): default widget, or NULL if there is none.
//
func (window *Window) DefaultWidget() Widgetter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_default_widget", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Deletable returns whether the window has been set to have a close button.
//
// The function returns the following values:
//
//    - ok: TRUE if the window has been set to have a close button.
//
func (window *Window) Deletable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_deletable", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DestroyWithParent returns whether the window will be destroyed with its
// transient parent.
//
// The function returns the following values:
//
//    - ok: TRUE if the window will be destroyed with its transient parent.
//
func (window *Window) DestroyWithParent() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_destroy_with_parent", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Focus retrieves the current focused widget within the window.
//
// Note that this is the widget that would have the focus if the toplevel window
// focused; if the toplevel window is not focused then gtk_widget_has_focus
// (widget) will not be TRUE for the widget.
//
// The function returns the following values:
//
//    - widget (optional): currently focused widget, or NULL if there is none.
//
func (window *Window) Focus() Widgetter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_focus", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// FocusVisible gets whether “focus rectangles” are supposed to be visible.
//
// The function returns the following values:
//
//    - ok: TRUE if “focus rectangles” are supposed to be visible in this window.
//
func (window *Window) FocusVisible() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_focus_visible", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Group returns the group for window.
//
// If the window has no group, then the default group is returned.
//
// The function returns the following values:
//
//    - windowGroup: GtkWindowGroup for a window or the default group.
//
func (window *Window) Group() *WindowGroup {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	if window != nil {
		_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_group", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _windowGroup *WindowGroup // out

	_windowGroup = wrapWindowGroup(coreglib.Take(unsafe.Pointer(_cret)))

	return _windowGroup
}

// HandleMenubarAccel returns whether this window reacts to F10 key presses by
// activating a menubar it contains.
//
// The function returns the following values:
//
//    - ok: TRUE if the window handles F10.
//
func (window *Window) HandleMenubarAccel() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_handle_menubar_accel", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HideOnClose returns whether the window will be hidden when the close button
// is clicked.
//
// The function returns the following values:
//
//    - ok: TRUE if the window will be hidden.
//
func (window *Window) HideOnClose() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_hide_on_close", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconName returns the name of the themed icon for the window.
//
// The function returns the following values:
//
//    - utf8 (optional): icon name or NULL if the window has no themed icon.
//
func (window *Window) IconName() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_icon_name", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MnemonicsVisible gets whether mnemonics are supposed to be visible.
//
// The function returns the following values:
//
//    - ok: TRUE if mnemonics are supposed to be visible in this window.
//
func (window *Window) MnemonicsVisible() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_mnemonics_visible", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modal returns whether the window is modal.
//
// The function returns the following values:
//
//    - ok: TRUE if the window is set to be modal and establishes a grab when
//      shown.
//
func (window *Window) Modal() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_modal", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Resizable gets the value set by gtk_window_set_resizable().
//
// The function returns the following values:
//
//    - ok: TRUE if the user can resize the window.
//
func (window *Window) Resizable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_resizable", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the window.
//
// The function returns the following values:
//
//    - utf8 (optional): title of the window, or NULL if none has been set
//      explicitly. The returned string is owned by the widget and must not be
//      modified or freed.
//
func (window *Window) Title() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_title", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
//
// The function returns the following values:
//
//    - widget (optional): custom titlebar, or NULL.
//
func (window *Window) Titlebar() Widgetter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_titlebar", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// TransientFor fetches the transient parent for this window.
//
// The function returns the following values:
//
//    - ret (optional): transient parent for this window, or NULL if no transient
//      parent has been set.
//
func (window *Window) TransientFor() *Window {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("get_transient_for", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ret *Window // out

	if _cret != nil {
		_ret = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ret
}

// HasGroup returns whether window has an explicit window group.
//
// The function returns the following values:
//
//    - ok: TRUE if window has an explicit window group.
//
func (window *Window) HasGroup() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("has_group", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive returns whether the window is part of the current active toplevel.
//
// The active toplevel is the window receiving keystrokes.
//
// The return value is TRUE if the window is active toplevel itself. You might
// use this function if you wanted to draw a widget differently in an active
// window from a widget in an inactive window.
//
// The function returns the following values:
//
//    - ok: TRUE if the window part of the current active window.
//
func (window *Window) IsActive() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("is_active", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFullscreen retrieves the current fullscreen state of window.
//
// Note that since fullscreening is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk.Window.Fullscreen() or gtk.Window.Unfullscreen().
//
// If the window isn't yet mapped, the value returned will whether the initial
// requested state is fullscreen.
//
// The function returns the following values:
//
//    - ok: whether the window has a fullscreen state.
//
func (window *Window) IsFullscreen() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("is_fullscreen", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMaximized retrieves the current maximized state of window.
//
// Note that since maximization is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk.Window.Maximize() or gtk.Window.Unmaximize().
//
// If the window isn't yet mapped, the value returned will whether the initial
// requested state is maximized.
//
// The function returns the following values:
//
//    - ok: whether the window has a maximized state.
//
func (window *Window) IsMaximized() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Window").InvokeMethod("is_maximized", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Maximize asks to maximize window, so that it fills the screen.
//
// Note that you shouldn’t assume the window is definitely maximized afterward,
// because other entities (e.g. the user or window manager could unmaximize it
// again, and not all window managers support maximization.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be maximized when it appears onscreen initially.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications on the gtk.Window:maximized
// property.
func (window *Window) Maximize() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("maximize", args[:], nil)

	runtime.KeepAlive(window)
}

// Minimize asks to minimize the specified window.
//
// Note that you shouldn’t assume the window is definitely minimized afterward,
// because the windowing system might not support this functionality; other
// entities (e.g. the user or the window manager could unminimize it again, or
// there may not be a window manager in which case minimization isn’t possible,
// etc.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be minimized before it ever appears onscreen.
//
// You can track result of this operation via the gdk.Toplevel:state property.
func (window *Window) Minimize() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("minimize", args[:], nil)

	runtime.KeepAlive(window)
}

// Present presents a window to the user.
//
// This function should not be used as when it is called, it is too late to
// gather a valid timestamp to allow focus stealing prevention to work
// correctly.
func (window *Window) Present() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("present", args[:], nil)

	runtime.KeepAlive(window)
}

// PresentWithTime presents a window to the user.
//
// This may mean raising the window in the stacking order, unminimizing it,
// moving it to the current desktop, and/or giving it the keyboard focus,
// possibly dependent on the user’s platform, window manager, and preferences.
//
// If window is hidden, this function calls gtk.Widget.Show() as well.
//
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open, and
// the user chooses Preferences from the menu a second time; use
// gtk.Window.Present() to move the already-open dialog where the user can see
// it.
//
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown (when
// clicking a link for example), rather than once the window is ready to be
// shown.
//
// The function takes the following parameters:
//
//    - timestamp of the user interaction (typically a button or key press event)
//      which triggered this call.
//
func (window *Window) PresentWithTime(timestamp uint32) {
	var args [2]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.guint32 // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.guint32(timestamp)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("present_with_time", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(timestamp)
}

// SetApplication sets or unsets the GtkApplication associated with the window.
//
// The application will be kept alive for at least as long as it has any windows
// associated with it (see g_application_hold() for a way to keep it alive
// without windows).
//
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it by setting
// the application to NULL.
//
// This is equivalent to calling gtk.Application.RemoveWindow() and/or
// gtk.Application.AddWindow() on the old/new applications as relevant.
//
// The function takes the following parameters:
//
//    - application (optional): GtkApplication, or NULL to unset.
//
func (window *Window) SetApplication(application *Application) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if application != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_application", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(application)
}

// SetChild sets the child widget of window.
//
// The function takes the following parameters:
//
//    - child (optional) widget.
//
func (window *Window) SetChild(child Widgetter) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if child != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_child", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(child)
}

// SetDecorated sets whether the window should be decorated.
//
// By default, windows are decorated with a title bar, resize controls, etc.
// Some window managers allow GTK to disable these decorations, creating a
// borderless window. If you set the decorated property to FALSE using this
// function, GTK will do its best to convince the window manager not to decorate
// the window. Depending on the system, this function may not have any effect
// when called on a window that is already visible, so you should call it before
// calling gtk.Widget.Show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
//
// The function takes the following parameters:
//
//    - setting: TRUE to decorate the window.
//
func (window *Window) SetDecorated(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_decorated", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDefaultSize sets the default size of a window.
//
// If the window’s “natural” size (its size request) is larger than the default,
// the default will be ignored.
//
// Unlike gtk.Widget.SetSizeRequest(), which sets a size request for a widget
// and thus would keep users from shrinking the window, this function only sets
// the initial size, just as if the user had resized the window themselves.
// Users can still shrink the window again as they normally would. Setting a
// default size of -1 means to use the “natural” default size (the size request
// of the window).
//
// The default size of a window only affects the first time a window is shown;
// if a window is hidden and re-shown, it will remember the size it had prior to
// hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but passing
// 0 for width and height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size, note
// that the appropriate size to save is the one returned by
// gtk.Window.GetDefaultSize(). Using the window allocation directly will not
// work in all circumstances and can lead to growing or shrinking windows.
//
// The function takes the following parameters:
//
//    - width in pixels, or -1 to unset the default width.
//    - height in pixels, or -1 to unset the default height.
//
func (window *Window) SetDefaultSize(width, height int32) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.int   // out
	var _arg2 C.int   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_default_size", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetDefaultWidget sets the default widget.
//
// The default widget is the widget that is activated when the user presses
// Enter in a dialog (for example).
//
// The function takes the following parameters:
//
//    - defaultWidget (optional): widget to be the default, or NULL to unset the
//      default widget for the toplevel.
//
func (window *Window) SetDefaultWidget(defaultWidget Widgetter) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if defaultWidget != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(defaultWidget).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_default_widget", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(defaultWidget)
}

// SetDeletable sets whether the window should be deletable.
//
// By default, windows have a close button in the window frame. Some window
// managers allow GTK to disable this button. If you set the deletable property
// to FALSE using this function, GTK will do its best to convince the window
// manager not to show a close button. Depending on the system, this function
// may not have any effect when called on a window that is already visible, so
// you should call it before calling gtk.Widget.Show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
//
// The function takes the following parameters:
//
//    - setting: TRUE to decorate the window as deletable.
//
func (window *Window) SetDeletable(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_deletable", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDestroyWithParent: if setting is TRUE, then destroying the transient
// parent of window will also destroy window itself.
//
// This is useful for dialogs that shouldn’t persist beyond the lifetime of the
// main window they are associated with, for example.
//
// The function takes the following parameters:
//
//    - setting: whether to destroy window with its transient parent.
//
func (window *Window) SetDestroyWithParent(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_destroy_with_parent", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDisplay sets the GdkDisplay where the window is displayed.
//
// If the window is already mapped, it will be unmapped, and then remapped on
// the new display.
//
// The function takes the following parameters:
//
//    - display: GdkDisplay.
//
func (window *Window) SetDisplay(display *gdk.Display) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_display", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(display)
}

// SetFocus sets the focus widget.
//
// If focus is not the current focus widget, and is focusable, sets it as the
// focus widget for the window. If focus is NULL, unsets the focus widget for
// this window. To set the focus to a particular widget in the toplevel, it is
// usually more convenient to use gtk.Widget.GrabFocus() instead of this
// function.
//
// The function takes the following parameters:
//
//    - focus (optional): widget to be the new focus widget, or NULL to unset any
//      focus widget for the toplevel window.
//
func (window *Window) SetFocus(focus Widgetter) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if focus != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(focus).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_focus", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(focus)
}

// SetFocusVisible sets whether “focus rectangles” are supposed to be visible.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (window *Window) SetFocusVisible(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_focus_visible", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetHandleMenubarAccel sets whether this window should react to F10 key
// presses by activating a menubar it contains.
//
// The function takes the following parameters:
//
//    - handleMenubarAccel: TRUE to make window handle F10.
//
func (window *Window) SetHandleMenubarAccel(handleMenubarAccel bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if handleMenubarAccel {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_handle_menubar_accel", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(handleMenubarAccel)
}

// SetHideOnClose: if setting is TRUE, then clicking the close button on the
// window will not destroy it, but only hide it.
//
// The function takes the following parameters:
//
//    - setting: whether to hide the window when it is closed.
//
func (window *Window) SetHideOnClose(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_hide_on_close", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetIconName sets the icon for the window from a named themed icon.
//
// See the docs for gtk.IconTheme for more details. On some platforms, the
// window icon is not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
//
// The function takes the following parameters:
//
//    - name (optional) of the themed icon.
//
func (window *Window) SetIconName(name string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if name != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_icon_name", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(name)
}

// SetMnemonicsVisible sets whether mnemonics are supposed to be visible.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (window *Window) SetMnemonicsVisible(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_mnemonics_visible", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetModal sets a window modal or non-modal.
//
// Modal windows prevent interaction with other windows in the same application.
// To keep modal dialogs on top of main application windows, use
// gtk.Window.SetTransientFor() to make the dialog transient for the parent;
// most window managers will then disallow lowering the dialog below the parent.
//
// The function takes the following parameters:
//
//    - modal: whether the window is modal.
//
func (window *Window) SetModal(modal bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if modal {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_modal", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(modal)
}

// SetResizable sets whether the user can resize a window.
//
// Windows are user resizable by default.
//
// The function takes the following parameters:
//
//    - resizable: TRUE if the user can resize this window.
//
func (window *Window) SetResizable(resizable bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if resizable {
		_arg1 = C.TRUE
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_resizable", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(resizable)
}

// SetStartupID sets the startup notification ID.
//
// Startup notification identifiers are used by desktop environment to track
// application startup, to provide user feedback and other features. This
// function changes the corresponding property on the underlying GdkSurface.
//
// Normally, startup identifier is managed automatically and you should only use
// this function in special cases like transferring focus from other processes.
// You should use this function before calling gtk.Window.Present() or any
// equivalent function generating a window map event.
//
// This function is only useful on X11, not with other GTK targets.
//
// The function takes the following parameters:
//
//    - startupId: string with startup-notification identifier.
//
func (window *Window) SetStartupID(startupId string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_startup_id", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(startupId)
}

// SetTitle sets the title of the GtkWindow.
//
// The title of a window will be displayed in its title bar; on the X Window
// System, the title bar is rendered by the window manager so exactly how the
// title appears to users may vary according to a user’s exact configuration.
// The title should help a user distinguish this window from other windows they
// may have open. A good title might include the application name and current
// document filename, for example.
//
// Passing NULL does the same as setting the title to an empty string.
//
// The function takes the following parameters:
//
//    - title (optional) of the window.
//
func (window *Window) SetTitle(title string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if title != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_title", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(title)
}

// SetTitlebar sets a custom titlebar for window.
//
// A typical widget used here is gtk.HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to it.
//
// If you set a custom titlebar, GTK will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the system,
// this function may not work for a window that is already visible, so you set
// the titlebar before calling gtk.Widget.Show().
//
// The function takes the following parameters:
//
//    - titlebar (optional): widget to use as titlebar.
//
func (window *Window) SetTitlebar(titlebar Widgetter) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if titlebar != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(titlebar).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_titlebar", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(titlebar)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows window managers to
// e.g. keep the dialog on top of the main window, or center the dialog over the
// main window. gtk.Dialog.NewWithButtons and other convenience functions in GTK
// will sometimes call gtk_window_set_transient_for() on your behalf.
//
// Passing NULL for parent unsets the current transient window.
//
// On Windows, this function puts the child window on top of the parent, much as
// the window manager would have done on X.
//
// The function takes the following parameters:
//
//    - parent (optional) window, or NULL.
//
func (window *Window) SetTransientFor(parent *Window) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if parent != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	*(**Window)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Window").InvokeMethod("set_transient_for", args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(parent)
}

// Unfullscreen asks to remove the fullscreen state for window, and return to
// its previous state.
//
// Note that you shouldn’t assume the window is definitely not fullscreen
// afterward, because other entities (e.g. the user or window manager could
// fullscreen it again, and not all window managers honor requests to
// unfullscreen windows; normally the window will end up restored to its normal
// state. Just don’t write code that crashes if not.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications of the gtk.Window:fullscreened
// property.
func (window *Window) Unfullscreen() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("unfullscreen", args[:], nil)

	runtime.KeepAlive(window)
}

// Unmaximize asks to unmaximize window.
//
// Note that you shouldn’t assume the window is definitely unmaximized
// afterward, because other entities (e.g. the user or window manager maximize
// it again, and not all window managers honor requests to unmaximize.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications on the gtk.Window:maximized
// property.
func (window *Window) Unmaximize() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("unmaximize", args[:], nil)

	runtime.KeepAlive(window)
}

// Unminimize asks to unminimize the specified window.
//
// Note that you shouldn’t assume the window is definitely unminimized
// afterward, because the windowing system might not support this functionality;
// other entities (e.g. the user or the window manager could minimize it again,
// or there may not be a window manager in which case minimization isn’t
// possible, etc.
//
// You can track result of this operation via the gdk.Toplevel:state property.
func (window *Window) Unminimize() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**Window)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Window").InvokeMethod("unminimize", args[:], nil)

	runtime.KeepAlive(window)
}

// WindowGetDefaultIconName returns the fallback icon name for windows.
//
// The returned string is owned by GTK and should not be modified. It is only
// valid until the next call to gtk.Window().SetDefaultIconName.
//
// The function returns the following values:
//
//    - utf8 (optional): fallback icon name for windows.
//
func WindowGetDefaultIconName() string {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "get_default_icon_name").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// WindowGetToplevels returns a list of all existing toplevel windows.
//
// If you want to iterate through the list and perform actions involving
// callbacks that might destroy the widgets or add new ones, be aware that the
// list of toplevels will change and emit the "items-changed" signal.
//
// The function returns the following values:
//
//    - listModel: list of toplevel widgets.
//
func WindowGetToplevels() *gio.ListModel {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "get_toplevels").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// WindowListToplevels returns a list of all existing toplevel windows.
//
// The widgets in the list are not individually referenced. If you want to
// iterate through the list and perform actions involving callbacks that might
// destroy the widgets, you must call g_list_foreach (result,
// (GFunc)g_object_ref, NULL) first, and then unref all the widgets afterwards.
//
// The function returns the following values:
//
//    - list of toplevel widgets.
//
func WindowListToplevels() []Widgetter {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "list_toplevels").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// WindowSetAutoStartupNotification sets whether the window should request
// startup notification.
//
// By default, after showing the first GtkWindow, GTK calls
// gdk.Display.NotifyStartupComplete(). Call this function to disable the
// automatic startup notification. You might do this if your first window is a
// splash screen, and you want to delay notification until after your real main
// window has been shown, for example.
//
// In that example, you would disable startup notification temporarily, show
// your splash screen, then re-enable it so that showing the main window would
// automatically result in notification.
//
// The function takes the following parameters:
//
//    - setting: TRUE to automatically do startup notification.
//
func WindowSetAutoStartupNotification(setting bool) {
	var args [1]girepository.Argument
	var _arg0 C.gboolean // out

	if setting {
		_arg0 = C.TRUE
	}
	*(*bool)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "set_auto_startup_notification").Invoke(args[:], nil)

	runtime.KeepAlive(setting)
}

// WindowSetDefaultIconName sets an icon to be used as fallback.
//
// The fallback icon is used for windows that haven't had
// gtk.Window.SetIconName() called on them.
//
// The function takes the following parameters:
//
//    - name of the themed icon.
//
func WindowSetDefaultIconName(name string) {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg0))
	*(*string)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "set_default_icon_name").Invoke(args[:], nil)

	runtime.KeepAlive(name)
}

// WindowSetInteractiveDebugging opens or closes the interactive debugger
// (#interactive-debugging).
//
// The debugger offers access to the widget hierarchy of the application and to
// useful debugging tools.
//
// The function takes the following parameters:
//
//    - enable: TRUE to enable interactive debugging.
//
func WindowSetInteractiveDebugging(enable bool) {
	var args [1]girepository.Argument
	var _arg0 C.gboolean // out

	if enable {
		_arg0 = C.TRUE
	}
	*(*bool)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "set_interactive_debugging").Invoke(args[:], nil)

	runtime.KeepAlive(enable)
}

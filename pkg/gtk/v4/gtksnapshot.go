// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/gsk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeSnapshot returns the GType for the type Snapshot.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeSnapshot() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "Snapshot").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalSnapshot)
	return gtype
}

// Snapshot: GtkSnapshot assists in creating GskRenderNodes for widgets.
//
// It functions in a similar way to a cairo context, and maintains a stack of
// render nodes and their associated transformations.
//
// The node at the top of the stack is the the one that gtk_snapshot_append_…
// functions operate on. Use the gtk_snapshot_push_… functions and
// gtk_snapshot_pop() to change the current node.
//
// The typical way to obtain a GtkSnapshot object is as an argument to the
// GtkWidgetClass.snapshot() vfunc. If you need to create your own GtkSnapshot,
// use gtk.Snapshot.New.
type Snapshot struct {
	_ [0]func() // equal guard
	gdk.Snapshot
}

var (
	_ gdk.Snapshotter = (*Snapshot)(nil)
)

func wrapSnapshot(obj *coreglib.Object) *Snapshot {
	return &Snapshot{
		Snapshot: gdk.Snapshot{
			Object: obj,
		},
	}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	return wrapSnapshot(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSnapshot creates a new GtkSnapshot.
//
// The function returns the following values:
//
//    - snapshot: newly-allocated GtkSnapshot.
//
func NewSnapshot() *Snapshot {
	_info := girepository.MustFind("Gtk", "Snapshot")
	_gret := _info.InvokeClassMethod("new_Snapshot", nil, nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	var _snapshot *Snapshot // out

	_snapshot = wrapSnapshot(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _snapshot
}

// AppendCairo creates a new GskCairoNode and appends it to the current render
// node of snapshot, without changing the current node.
//
// The function takes the following parameters:
//
//    - bounds for the new node.
//
// The function returns the following values:
//
//    - context: cairo_t suitable for drawing the contents of the newly created
//      render node.
//
func (snapshot *Snapshot) AppendCairo(bounds *graphene.Rect) *cairo.Context {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_gret := _info.InvokeClassMethod("append_cairo", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.cairo_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _context
}

// AppendColor creates a new render node drawing the color into the given bounds
// and appends it to the current render node of snapshot.
//
// You should try to avoid calling this function if color is transparent.
//
// The function takes the following parameters:
//
//    - color: GdkRGBA to draw.
//    - bounds for the new node.
//
func (snapshot *Snapshot) AppendColor(color *gdk.RGBA, bounds *graphene.Rect) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("append_color", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(color)
	runtime.KeepAlive(bounds)
}

// AppendInsetShadow appends an inset shadow into the box given by outline.
//
// The function takes the following parameters:
//
//    - outline of the region surrounded by shadow.
//    - color of the shadow.
//    - dx: horizontal offset of shadow.
//    - dy: vertical offset of shadow.
//    - spread: how far the shadow spreads towards the inside.
//    - blurRadius: how much blur to apply to the shadow.
//
func (snapshot *Snapshot) AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) {
	var _args [7]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(outline)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(*C.float)(unsafe.Pointer(&_args[3])) = C.float(dx)
	*(*C.float)(unsafe.Pointer(&_args[4])) = C.float(dy)
	*(*C.float)(unsafe.Pointer(&_args[5])) = C.float(spread)
	*(*C.float)(unsafe.Pointer(&_args[6])) = C.float(blurRadius)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("append_inset_shadow", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)
}

// The function takes the following parameters:
//
//    - layout
//    - color
//
func (snapshot *Snapshot) AppendLayout(layout *pango.Layout, color *gdk.RGBA) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("append_layout", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(color)
}

// AppendNode appends node to the current render node of snapshot, without
// changing the current node.
//
// If snapshot does not have a current node yet, node will become the initial
// node.
//
// The function takes the following parameters:
//
//    - node: RenderNode.
//
func (snapshot *Snapshot) AppendNode(node gsk.RenderNoder) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("append_node", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(node)
}

// AppendOutsetShadow appends an outset shadow node around the box given by
// outline.
//
// The function takes the following parameters:
//
//    - outline of the region surrounded by shadow.
//    - color of the shadow.
//    - dx: horizontal offset of shadow.
//    - dy: vertical offset of shadow.
//    - spread: how far the shadow spreads towards the outside.
//    - blurRadius: how much blur to apply to the shadow.
//
func (snapshot *Snapshot) AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) {
	var _args [7]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(outline)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(*C.float)(unsafe.Pointer(&_args[3])) = C.float(dx)
	*(*C.float)(unsafe.Pointer(&_args[4])) = C.float(dy)
	*(*C.float)(unsafe.Pointer(&_args[5])) = C.float(spread)
	*(*C.float)(unsafe.Pointer(&_args[6])) = C.float(blurRadius)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("append_outset_shadow", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)
}

// AppendTexture creates a new render node drawing the texture into the given
// bounds and appends it to the current render node of snapshot.
//
// The function takes the following parameters:
//
//    - texture: GdkTexture to render.
//    - bounds for the new node.
//
func (snapshot *Snapshot) AppendTexture(texture gdk.Texturer, bounds *graphene.Rect) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("append_texture", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(bounds)
}

// GLShaderPopTexture removes the top element from the stack of render nodes and
// adds it to the nearest GskGLShaderNode below it.
//
// This must be called the same number of times as the number of textures is
// needed for the shader in gtk.Snapshot.PushGLShader().
func (snapshot *Snapshot) GLShaderPopTexture() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("gl_shader_pop_texture", _args[:], nil)

	runtime.KeepAlive(snapshot)
}

// Perspective applies a perspective projection transform.
//
// See gsk.Transform.Perspective() for a discussion on the details.
//
// The function takes the following parameters:
//
//    - depth: distance of the z=0 plane.
//
func (snapshot *Snapshot) Perspective(depth float32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(depth)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("perspective", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(depth)
}

// Pop removes the top element from the stack of render nodes, and appends it to
// the node underneath it.
func (snapshot *Snapshot) Pop() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("pop", _args[:], nil)

	runtime.KeepAlive(snapshot)
}

// PushBlur blurs an image.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//    - radius: blur radius to use.
//
func (snapshot *Snapshot) PushBlur(radius float64) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(*C.double)(unsafe.Pointer(&_args[1])) = C.double(radius)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_blur", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(radius)
}

// PushClip clips an image to a rectangle.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//    - bounds: rectangle to clip to.
//
func (snapshot *Snapshot) PushClip(bounds *graphene.Rect) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_clip", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
}

// PushColorMatrix modifies the colors of an image by applying an affine
// transformation in RGB space.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//    - colorMatrix: color matrix to use.
//    - colorOffset: color offset to use.
//
func (snapshot *Snapshot) PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(colorMatrix)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(colorOffset)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_color_matrix", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(colorMatrix)
	runtime.KeepAlive(colorOffset)
}

// PushCrossFade snapshots a cross-fade operation between two images with the
// given progress.
//
// Until the first call to gtk.Snapshot.Pop(), the start image will be snapshot.
// After that call, the end image will be recorded until the second call to
// gtk.Snapshot.Pop().
//
// Calling this function requires two subsequent calls to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//    - progress between 0.0 and 1.0.
//
func (snapshot *Snapshot) PushCrossFade(progress float64) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(*C.double)(unsafe.Pointer(&_args[1])) = C.double(progress)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_cross_fade", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(progress)
}

// PushGLShader: push a GskGLShaderNode.
//
// The node uses the given gsk.GLShader and uniform values Additionally this
// takes a list of n_children other nodes which will be passed to the
// GskGLShaderNode.
//
// The take_args argument is a block of data to use for uniform arguments, as
// per types and offsets defined by the shader. Normally this is generated by
// gsk.GLShader.FormatArgs() or gsk.ShaderArgsBuilder.
//
// The snapshotter takes ownership of take_args, so the caller should not free
// it after this.
//
// If the renderer doesn't support GL shaders, or if there is any problem when
// compiling the shader, then the node will draw pink. You should use
// gsk.GLShader.Compile() to ensure the shader will work for the renderer before
// using it.
//
// If the shader requires textures (see gsk.GLShader.GetNTextures()), then it is
// expected that you call gtk.Snapshot.GLShaderPopTexture() the number of times
// that are required. Each of these calls will generate a node that is added as
// a child to the GskGLShaderNode, which in turn will render these offscreen and
// pass as a texture to the shader.
//
// Once all textures (if any) are pop:ed, you must call the regular
// gtk.Snapshot.Pop().
//
// If you want to use pre-existing textures as input to the shader rather than
// rendering new ones, use gtk.Snapshot.AppendTexture() to push a texture node.
// These will be used directly rather than being re-rendered.
//
// For details on how to write shaders, see gsk.GLShader.
//
// The function takes the following parameters:
//
//    - shader: code to run.
//    - bounds: rectangle to render into.
//    - takeArgs: data block with arguments for the shader.
//
func (snapshot *Snapshot) PushGLShader(shader *gsk.GLShader, bounds *graphene.Rect, takeArgs *glib.Bytes) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(takeArgs)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_gl_shader", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(takeArgs)
}

// PushOpacity modifies the opacity of an image.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//    - opacity to use.
//
func (snapshot *Snapshot) PushOpacity(opacity float64) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(*C.double)(unsafe.Pointer(&_args[1])) = C.double(opacity)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_opacity", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(opacity)
}

// PushRepeat creates a node that repeats the child node.
//
// The child is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//    - bounds within which to repeat.
//    - childBounds (optional) bounds of the child or NULL to use the full size
//      of the collected child node.
//
func (snapshot *Snapshot) PushRepeat(bounds, childBounds *graphene.Rect) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))
	if childBounds != nil {
		*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(childBounds)))
	}

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_repeat", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(childBounds)
}

// PushRoundedClip clips an image to a rounded rectangle.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//    - bounds: rounded rectangle to clip to.
//
func (snapshot *Snapshot) PushRoundedClip(bounds *gsk.RoundedRect) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_rounded_clip", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
}

// PushShadow applies a shadow to an image.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//    - shadow: first shadow specification.
//    - nShadows: number of shadow specifications.
//
func (snapshot *Snapshot) PushShadow(shadow *gsk.Shadow, nShadows uint) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(shadow)))
	*(*C.gsize)(unsafe.Pointer(&_args[2])) = C.gsize(nShadows)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("push_shadow", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(shadow)
	runtime.KeepAlive(nShadows)
}

// RenderBackground creates a render node for the CSS background according to
// context, and appends it to the current node of snapshot, without changing the
// current node.
//
// The function takes the following parameters:
//
//    - context: GtkStyleContext to use.
//    - x: x origin of the rectangle.
//    - y: y origin of the rectangle.
//    - width: rectangle width.
//    - height: rectangle height.
//
func (snapshot *Snapshot) RenderBackground(context *StyleContext, x, y, width, height float64) {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(*C.double)(unsafe.Pointer(&_args[2])) = C.double(x)
	*(*C.double)(unsafe.Pointer(&_args[3])) = C.double(y)
	*(*C.double)(unsafe.Pointer(&_args[4])) = C.double(width)
	*(*C.double)(unsafe.Pointer(&_args[5])) = C.double(height)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("render_background", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderFocus creates a render node for the focus outline according to context,
// and appends it to the current node of snapshot, without changing the current
// node.
//
// The function takes the following parameters:
//
//    - context: GtkStyleContext to use.
//    - x: x origin of the rectangle.
//    - y: y origin of the rectangle.
//    - width: rectangle width.
//    - height: rectangle height.
//
func (snapshot *Snapshot) RenderFocus(context *StyleContext, x, y, width, height float64) {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(*C.double)(unsafe.Pointer(&_args[2])) = C.double(x)
	*(*C.double)(unsafe.Pointer(&_args[3])) = C.double(y)
	*(*C.double)(unsafe.Pointer(&_args[4])) = C.double(width)
	*(*C.double)(unsafe.Pointer(&_args[5])) = C.double(height)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("render_focus", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderFrame creates a render node for the CSS border according to context,
// and appends it to the current node of snapshot, without changing the current
// node.
//
// The function takes the following parameters:
//
//    - context: GtkStyleContext to use.
//    - x: x origin of the rectangle.
//    - y: y origin of the rectangle.
//    - width: rectangle width.
//    - height: rectangle height.
//
func (snapshot *Snapshot) RenderFrame(context *StyleContext, x, y, width, height float64) {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(*C.double)(unsafe.Pointer(&_args[2])) = C.double(x)
	*(*C.double)(unsafe.Pointer(&_args[3])) = C.double(y)
	*(*C.double)(unsafe.Pointer(&_args[4])) = C.double(width)
	*(*C.double)(unsafe.Pointer(&_args[5])) = C.double(height)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("render_frame", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderLayout creates a render node for rendering layout according to the
// style information in context, and appends it to the current node of snapshot,
// without changing the current node.
//
// The function takes the following parameters:
//
//    - context: GtkStyleContext to use.
//    - x: x origin of the rectangle.
//    - y: y origin of the rectangle.
//    - layout to render.
//
func (snapshot *Snapshot) RenderLayout(context *StyleContext, x, y float64, layout *pango.Layout) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(*C.double)(unsafe.Pointer(&_args[2])) = C.double(x)
	*(*C.double)(unsafe.Pointer(&_args[3])) = C.double(y)
	*(**C.void)(unsafe.Pointer(&_args[4])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("render_layout", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(layout)
}

// Restore restores snapshot to the state saved by a preceding call to
// gtk_snapshot_save() and removes that state from the stack of saved states.
func (snapshot *Snapshot) Restore() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("restore", _args[:], nil)

	runtime.KeepAlive(snapshot)
}

// Rotate rotates @snapshot's coordinate system by angle degrees in 2D space -
// or in 3D speak, rotates around the Z axis.
//
// To rotate around other axes, use gsk.Transform.Rotate3D().
//
// The function takes the following parameters:
//
//    - angle: rotation angle, in degrees (clockwise).
//
func (snapshot *Snapshot) Rotate(angle float32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(angle)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("rotate", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(angle)
}

// Rotate3D rotates snapshot's coordinate system by angle degrees around axis.
//
// For a rotation in 2D space, use gsk.Transform.Rotate().
//
// The function takes the following parameters:
//
//    - angle: rotation angle, in degrees (clockwise).
//    - axis: rotation axis.
//
func (snapshot *Snapshot) Rotate3D(angle float32, axis *graphene.Vec3) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(angle)
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(axis)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("rotate_3d", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(angle)
	runtime.KeepAlive(axis)
}

// Save makes a copy of the current state of snapshot and saves it on an
// internal stack.
//
// When gtk.Snapshot.Restore() is called, snapshot will be restored to the saved
// state. Multiple calls to gtk_snapshot_save() and gtk_snapshot_restore() can
// be nested; each call to gtk_snapshot_restore() restores the state from the
// matching paired gtk_snapshot_save().
//
// It is necessary to clear all saved states with corresponding calls to
// gtk_snapshot_restore().
func (snapshot *Snapshot) Save() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("save", _args[:], nil)

	runtime.KeepAlive(snapshot)
}

// Scale scales snapshot's coordinate system in 2-dimensional space by the given
// factors.
//
// Use gtk.Snapshot.Scale3D() to scale in all 3 dimensions.
//
// The function takes the following parameters:
//
//    - factorX: scaling factor on the X axis.
//    - factorY: scaling factor on the Y axis.
//
func (snapshot *Snapshot) Scale(factorX, factorY float32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(factorX)
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(factorY)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("scale", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(factorX)
	runtime.KeepAlive(factorY)
}

// Scale3D scales snapshot's coordinate system by the given factors.
//
// The function takes the following parameters:
//
//    - factorX: scaling factor on the X axis.
//    - factorY: scaling factor on the Y axis.
//    - factorZ: scaling factor on the Z axis.
//
func (snapshot *Snapshot) Scale3D(factorX, factorY, factorZ float32) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(factorX)
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(factorY)
	*(*C.float)(unsafe.Pointer(&_args[3])) = C.float(factorZ)

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("scale_3d", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(factorX)
	runtime.KeepAlive(factorY)
	runtime.KeepAlive(factorZ)
}

// ToNode returns the render node that was constructed by snapshot.
//
// After calling this function, it is no longer possible to add more nodes to
// snapshot. The only function that should be called after this is
// g_object_unref().
//
// The function returns the following values:
//
//    - renderNode: constructed GskRenderNode.
//
func (snapshot *Snapshot) ToNode() gsk.RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_gret := _info.InvokeClassMethod("to_node", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(snapshot)

	var _renderNode gsk.RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gsk.RenderNoder)
			return ok
		})
		rv, ok := casted.(gsk.RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ToPaintable returns a paintable encapsulating the render node that was
// constructed by snapshot.
//
// After calling this function, it is no longer possible to add more nodes to
// snapshot. The only function that should be called after this is
// g_object_unref().
//
// The function takes the following parameters:
//
//    - size (optional) of the resulting paintable or NULL to use the bounds of
//      the snapshot.
//
// The function returns the following values:
//
//    - paintable: new Paintable.
//
func (snapshot *Snapshot) ToPaintable(size *graphene.Size) *gdk.Paintable {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	if size != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(size)))
	}

	_info := girepository.MustFind("Gtk", "Snapshot")
	_gret := _info.InvokeClassMethod("to_paintable", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(size)

	var _paintable *gdk.Paintable // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_paintable = &gdk.Paintable{
			Object: obj,
		}
	}

	return _paintable
}

// Transform transforms snapshot's coordinate system with the given transform.
//
// The function takes the following parameters:
//
//    - transform (optional) to apply.
//
func (snapshot *Snapshot) Transform(transform *gsk.Transform) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	if transform != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(transform)))
	}

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("transform", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(transform)
}

// TransformMatrix transforms snapshot's coordinate system with the given
// matrix.
//
// The function takes the following parameters:
//
//    - matrix to multiply the transform with.
//
func (snapshot *Snapshot) TransformMatrix(matrix *graphene.Matrix) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("transform_matrix", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(matrix)
}

// Translate translates snapshot's coordinate system by point in 2-dimensional
// space.
//
// The function takes the following parameters:
//
//    - point to translate the snapshot by.
//
func (snapshot *Snapshot) Translate(point *graphene.Point) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(point)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("translate", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(point)
}

// Translate3D translates snapshot's coordinate system by point.
//
// The function takes the following parameters:
//
//    - point to translate the snapshot by.
//
func (snapshot *Snapshot) Translate3D(point *graphene.Point3D) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(point)))

	_info := girepository.MustFind("Gtk", "Snapshot")
	_info.InvokeClassMethod("translate_3d", _args[:], nil)

	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(point)
}

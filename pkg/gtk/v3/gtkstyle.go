// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_StyleClass_copy(void*, void*);
// extern void _gotk4_gtk3_StyleClass_init_from_rc(void*, void*);
// extern void _gotk4_gtk3_StyleClass_realize(void*);
// extern void _gotk4_gtk3_StyleClass_unrealize(void*);
// extern void _gotk4_gtk3_Style_ConnectRealize(gpointer, guintptr);
// extern void _gotk4_gtk3_Style_ConnectUnrealize(gpointer, guintptr);
import "C"

// GTypeExpanderStyle returns the GType for the type ExpanderStyle.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeExpanderStyle() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "ExpanderStyle").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalExpanderStyle)
	return gtype
}

// GTypeStyle returns the GType for the type Style.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeStyle() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "Style").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalStyle)
	return gtype
}

// ExpanderStyle: used to specify the style of the expanders drawn by a
// TreeView.
type ExpanderStyle C.gint

const (
	// ExpanderCollapsed: style used for a collapsed subtree.
	ExpanderCollapsed ExpanderStyle = iota
	// ExpanderSemiCollapsed: intermediate style used during animation.
	ExpanderSemiCollapsed
	// ExpanderSemiExpanded: intermediate style used during animation.
	ExpanderSemiExpanded
	// ExpanderExpanded: style used for an expanded subtree.
	ExpanderExpanded
)

func marshalExpanderStyle(p uintptr) (interface{}, error) {
	return ExpanderStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ExpanderStyle.
func (e ExpanderStyle) String() string {
	switch e {
	case ExpanderCollapsed:
		return "Collapsed"
	case ExpanderSemiCollapsed:
		return "SemiCollapsed"
	case ExpanderSemiExpanded:
		return "SemiExpanded"
	case ExpanderExpanded:
		return "Expanded"
	default:
		return fmt.Sprintf("ExpanderStyle(%d)", e)
	}
}

// StyleOverrider contains methods that are overridable.
type StyleOverrider interface {
	// The function takes the following parameters:
	//
	Copy(src *Style)
	// The function takes the following parameters:
	//
	InitFromRC(rcStyle *RCStyle)
	Realize()
	Unrealize()
}

// Style object encapsulates the information that provides the look and feel for
// a widget.
//
// > In GTK+ 3.0, GtkStyle has been deprecated and replaced by > StyleContext.
//
// Each Widget has an associated Style object that is used when rendering that
// widget. Also, a Style holds information for the five possible widget states
// though not every widget supports all five states; see StateType.
//
// Usually the Style for a widget is the same as the default style that is set
// by GTK+ and modified the theme engine.
//
// Usually applications should not need to use or modify the Style of their
// widgets.
type Style struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Style)(nil)
)

func classInitStyler(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "StyleClass")

	if _, ok := goval.(interface{ Copy(src *Style) }); ok {
		o := pclass.StructFieldOffset("copy")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StyleClass_copy)
	}

	if _, ok := goval.(interface{ InitFromRC(rcStyle *RCStyle) }); ok {
		o := pclass.StructFieldOffset("init_from_rc")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StyleClass_init_from_rc)
	}

	if _, ok := goval.(interface{ Realize() }); ok {
		o := pclass.StructFieldOffset("realize")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StyleClass_realize)
	}

	if _, ok := goval.(interface{ Unrealize() }); ok {
		o := pclass.StructFieldOffset("unrealize")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StyleClass_unrealize)
	}
}

//export _gotk4_gtk3_StyleClass_copy
func _gotk4_gtk3_StyleClass_copy(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Copy(src *Style) })

	var _src *Style // out

	_src = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))

	iface.Copy(_src)
}

//export _gotk4_gtk3_StyleClass_init_from_rc
func _gotk4_gtk3_StyleClass_init_from_rc(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ InitFromRC(rcStyle *RCStyle) })

	var _rcStyle *RCStyle // out

	_rcStyle = wrapRCStyle(coreglib.Take(unsafe.Pointer(arg1)))

	iface.InitFromRC(_rcStyle)
}

//export _gotk4_gtk3_StyleClass_realize
func _gotk4_gtk3_StyleClass_realize(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Realize() })

	iface.Realize()
}

//export _gotk4_gtk3_StyleClass_unrealize
func _gotk4_gtk3_StyleClass_unrealize(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Unrealize() })

	iface.Unrealize()
}

func wrapStyle(obj *coreglib.Object) *Style {
	return &Style{
		Object: obj,
	}
}

func marshalStyle(p uintptr) (interface{}, error) {
	return wrapStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_Style_ConnectRealize
func _gotk4_gtk3_Style_ConnectRealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectRealize is emitted when the style has been initialized for a
// particular visual. Connecting to this signal is probably seldom useful since
// most of the time applications and widgets only deal with styles that have
// been already realized.
func (style *Style) ConnectRealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(style, "realize", false, unsafe.Pointer(C._gotk4_gtk3_Style_ConnectRealize), f)
}

//export _gotk4_gtk3_Style_ConnectUnrealize
func _gotk4_gtk3_Style_ConnectUnrealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectUnrealize is emitted when the aspects of the style specific to a
// particular visual is being cleaned up. A connection to this signal can be
// useful if a widget wants to cache objects as object data on Style. This
// signal provides a convenient place to free such cached objects.
func (style *Style) ConnectUnrealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(style, "unrealize", false, unsafe.Pointer(C._gotk4_gtk3_Style_ConnectUnrealize), f)
}

// NewStyle creates a new Style.
//
// Deprecated: Use StyleContext.
//
// The function returns the following values:
//
//    - style: new Style.
//
func NewStyle() *Style {
	_info := girepository.MustFind("Gtk", "Style")
	_gret := _info.InvokeClassMethod("new_Style", nil, nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	var _style *Style // out

	_style = wrapStyle(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _style
}

// Copy creates a copy of the passed in Style object.
//
// Deprecated: Use StyleContext instead.
//
// The function returns the following values:
//
//    - ret: copy of style.
//
func (style *Style) Copy() *Style {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(style).Native()))

	_info := girepository.MustFind("Gtk", "Style")
	_gret := _info.InvokeClassMethod("copy", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(style)

	var _ret *Style // out

	_ret = wrapStyle(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// Detach detaches a style from a window. If the style is not attached to any
// windows anymore, it is unrealized. See gtk_style_attach().
//
// Deprecated: Use StyleContext instead.
func (style *Style) Detach() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(style).Native()))

	_info := girepository.MustFind("Gtk", "Style")
	_info.InvokeClassMethod("detach", _args[:], nil)

	runtime.KeepAlive(style)
}

// HasContext returns whether style has an associated StyleContext.
//
// The function returns the following values:
//
//    - ok: TRUE if style has a StyleContext.
//
func (style *Style) HasContext() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(style).Native()))

	_info := girepository.MustFind("Gtk", "Style")
	_gret := _info.InvokeClassMethod("has_context", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(style)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// LookupColor looks up color_name in the style’s logical color mappings,
// filling in color and returning TRUE if found, otherwise returning FALSE. Do
// not cache the found mapping, because it depends on the Style and might change
// when a theme switch occurs.
//
// Deprecated: Use gtk_style_context_lookup_color() instead.
//
// The function takes the following parameters:
//
//    - colorName: name of the logical color to look up.
//
// The function returns the following values:
//
//    - color to fill in.
//    - ok: TRUE if the mapping was found.
//
func (style *Style) LookupColor(colorName string) (*gdk.Color, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(style).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(colorName)))
	defer C.free(unsafe.Pointer(_args[1]))

	_info := girepository.MustFind("Gtk", "Style")
	_gret := _info.InvokeClassMethod("lookup_color", _args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(style)
	runtime.KeepAlive(colorName)

	var _color *gdk.Color // out
	var _ok bool          // out

	_color = (*gdk.Color)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _color, _ok
}

// LookupIconSet looks up stock_id in the icon factories associated with style
// and the default icon factory, returning an icon set if found, otherwise NULL.
//
// Deprecated: Use gtk_style_context_lookup_icon_set() instead.
//
// The function takes the following parameters:
//
//    - stockId: icon name.
//
// The function returns the following values:
//
//    - iconSet: icon set of stock_id.
//
func (style *Style) LookupIconSet(stockId string) *IconSet {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(style).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(stockId)))
	defer C.free(unsafe.Pointer(_args[1]))

	_info := girepository.MustFind("Gtk", "Style")
	_gret := _info.InvokeClassMethod("lookup_icon_set", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(style)
	runtime.KeepAlive(stockId)

	var _iconSet *IconSet // out

	_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_icon_set_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSet)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _iconSet
}

// ClassPath: same as gtk_widget_path(), but always uses the name of a widget’s
// type, never uses a custom name set with gtk_widget_set_name().
//
// Deprecated: Use gtk_widget_get_path() instead.
//
// The function returns the following values:
//
//    - pathLength (optional): location to store the length of the class path, or
//      NULL.
//    - path (optional): location to store the class path as an allocated string,
//      or NULL.
//    - pathReversed (optional): location to store the reverse class path as an
//      allocated string, or NULL.
//
func (widget *Widget) ClassPath() (pathLength uint32, path, pathReversed string) {
	var _args [1]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("class_path", _args[:], _outs[:])

	runtime.KeepAlive(widget)

	var _pathLength uint32   // out
	var _path string         // out
	var _pathReversed string // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_pathLength = *(*uint32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_path = C.GoString((*C.gchar)(unsafe.Pointer(_outs[1])))
		defer C.free(unsafe.Pointer(_outs[1]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[2])) != nil {
		_pathReversed = C.GoString((*C.gchar)(unsafe.Pointer(_outs[2])))
		defer C.free(unsafe.Pointer(_outs[2]))
	}

	return _pathLength, _path, _pathReversed
}

// EnsureStyle ensures that widget has a style (widget->style).
//
// Not a very useful function; most of the time, if you want the style, the
// widget is realized, and realized widgets are guaranteed to have a style
// already.
//
// Deprecated: Use StyleContext instead.
func (widget *Widget) EnsureStyle() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("ensure_style", _args[:], nil)

	runtime.KeepAlive(widget)
}

// ModifierStyle returns the current modifier style for the widget. (As set by
// gtk_widget_modify_style().) If no style has previously set, a new RcStyle
// will be created with all values unset, and set as the modifier style for the
// widget. If you make changes to this rc style, you must call
// gtk_widget_modify_style(), passing in the returned rc style, to make sure
// that your changes take effect.
//
// Caution: passing the style back to gtk_widget_modify_style() will normally
// end up destroying it, because gtk_widget_modify_style() copies the passed-in
// style and sets the copy as the new modifier style, thus dropping any
// reference to the old modifier style. Add a reference to the modifier style if
// you want to keep it alive.
//
// Deprecated: Use StyleContext with a custom StyleProvider instead.
//
// The function returns the following values:
//
//    - rcStyle: modifier style for the widget. This rc style is owned by the
//      widget. If you want to keep a pointer to value this around, you must add
//      a refcount using g_object_ref().
//
func (widget *Widget) ModifierStyle() *RCStyle {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_gret := _info.InvokeClassMethod("get_modifier_style", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(widget)

	var _rcStyle *RCStyle // out

	_rcStyle = wrapRCStyle(coreglib.Take(unsafe.Pointer(_cret)))

	return _rcStyle
}

// Style: simply an accessor function that returns widget->style.
//
// Deprecated: Use StyleContext instead.
//
// The function returns the following values:
//
//    - style widget’s Style.
//
func (widget *Widget) Style() *Style {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_gret := _info.InvokeClassMethod("get_style", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(widget)

	var _style *Style // out

	_style = wrapStyle(coreglib.Take(unsafe.Pointer(_cret)))

	return _style
}

// HasRCStyle determines if the widget style has been looked up through the rc
// mechanism.
//
// Deprecated: Use StyleContext instead.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget has been looked up through the rc mechanism, FALSE
//      otherwise.
//
func (widget *Widget) HasRCStyle() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_gret := _info.InvokeClassMethod("has_rc_style", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(widget)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ModifyCursor sets the cursor color to use in a widget, overriding the Widget
// cursor-color and secondary-cursor-color style properties.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
//
// Deprecated: Use gtk_widget_override_cursor() instead.
//
// The function takes the following parameters:
//
//    - primary (optional): color to use for primary cursor (does not need to be
//      allocated), or NULL to undo the effect of previous calls to of
//      gtk_widget_modify_cursor().
//    - secondary (optional): color to use for secondary cursor (does not need to
//      be allocated), or NULL to undo the effect of previous calls to of
//      gtk_widget_modify_cursor().
//
func (widget *Widget) ModifyCursor(primary, secondary *gdk.Color) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if primary != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(primary)))
	}
	if secondary != nil {
		*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(secondary)))
	}

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("modify_cursor", _args[:], nil)

	runtime.KeepAlive(widget)
	runtime.KeepAlive(primary)
	runtime.KeepAlive(secondary)
}

// ModifyFont sets the font to use for a widget.
//
// All other style values are left untouched. See also
// gtk_widget_modify_style().
//
// Deprecated: Use gtk_widget_override_font() instead.
//
// The function takes the following parameters:
//
//    - fontDesc (optional): font description to use, or NULL to undo the effect
//      of previous calls to gtk_widget_modify_font().
//
func (widget *Widget) ModifyFont(fontDesc *pango.FontDescription) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if fontDesc != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(fontDesc)))
	}

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("modify_font", _args[:], nil)

	runtime.KeepAlive(widget)
	runtime.KeepAlive(fontDesc)
}

// ModifyStyle modifies style values on the widget.
//
// Modifications made using this technique take precedence over style values set
// via an RC file, however, they will be overridden if a style is explicitly set
// on the widget using gtk_widget_set_style(). The RcStyle-struct is designed so
// each field can either be set or unset, so it is possible, using this
// function, to modify some style values and leave the others unchanged.
//
// Note that modifications made with this function are not cumulative with
// previous calls to gtk_widget_modify_style() or with such functions as
// gtk_widget_modify_fg(). If you wish to retain previous values, you must first
// call gtk_widget_get_modifier_style(), make your modifications to the returned
// style, then call gtk_widget_modify_style() with that style. On the other
// hand, if you first call gtk_widget_modify_style(), subsequent calls to such
// functions gtk_widget_modify_fg() will have a cumulative effect with the
// initial modifications.
//
// Deprecated: Use StyleContext with a custom StyleProvider instead.
//
// The function takes the following parameters:
//
//    - style holding the style modifications.
//
func (widget *Widget) ModifyStyle(style *RCStyle) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(style).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("modify_style", _args[:], nil)

	runtime.KeepAlive(widget)
	runtime.KeepAlive(style)
}

// Path obtains the full path to widget. The path is simply the name of a widget
// and all its parents in the container hierarchy, separated by periods. The
// name of a widget comes from gtk_widget_get_name(). Paths are used to apply
// styles to a widget in gtkrc configuration files. Widget names are the type of
// the widget by default (e.g. “GtkButton”) or can be set to an
// application-specific value with gtk_widget_set_name(). By setting the name of
// a widget, you allow users or theme authors to apply styles to that specific
// widget in their gtkrc file. path_reversed_p fills in the path in reverse
// order, i.e. starting with widget’s name instead of starting with the name of
// widget’s outermost ancestor.
//
// Deprecated: Use gtk_widget_get_path() instead.
//
// The function returns the following values:
//
//    - pathLength (optional): location to store length of the path, or NULL.
//    - path (optional): location to store allocated path string, or NULL.
//    - pathReversed (optional): location to store allocated reverse path string,
//      or NULL.
//
func (widget *Widget) Path() (pathLength uint32, path, pathReversed string) {
	var _args [1]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("path", _args[:], _outs[:])

	runtime.KeepAlive(widget)

	var _pathLength uint32   // out
	var _path string         // out
	var _pathReversed string // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_pathLength = *(*uint32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_path = C.GoString((*C.gchar)(unsafe.Pointer(_outs[1])))
		defer C.free(unsafe.Pointer(_outs[1]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[2])) != nil {
		_pathReversed = C.GoString((*C.gchar)(unsafe.Pointer(_outs[2])))
		defer C.free(unsafe.Pointer(_outs[2]))
	}

	return _pathLength, _path, _pathReversed
}

// ResetRCStyles: reset the styles of widget and all descendents, so when they
// are looked up again, they get the correct values for the currently loaded RC
// file settings.
//
// This function is not useful for applications.
//
// Deprecated: Use StyleContext instead, and gtk_widget_reset_style().
func (widget *Widget) ResetRCStyles() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("reset_rc_styles", _args[:], nil)

	runtime.KeepAlive(widget)
}

// SetStyle: used to set the Style for a widget (widget->style). Since GTK 3,
// this function does nothing, the passed in style is ignored.
//
// Deprecated: Use StyleContext instead.
//
// The function takes the following parameters:
//
//    - style (optional) or NULL to remove the effect of a previous call to
//      gtk_widget_set_style() and go back to the default style.
//
func (widget *Widget) SetStyle(style *Style) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if style != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(style).Native()))
	}

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("set_style", _args[:], nil)

	runtime.KeepAlive(widget)
	runtime.KeepAlive(style)
}

// StyleAttach: this function attaches the widget’s Style to the widget's
// Window. It is a replacement for
//
//    widget->style = gtk_style_attach (widget->style, widget->window);
//
// and should only ever be called in a derived widget’s “realize” implementation
// which does not chain up to its parent class' “realize” implementation,
// because one of the parent classes (finally Widget) would attach the style
// itself.
//
// Deprecated: This step is unnecessary with StyleContext.
func (widget *Widget) StyleAttach() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Widget")
	_info.InvokeClassMethod("style_attach", _args[:], nil)

	runtime.KeepAlive(widget)
}

// WidgetGetDefaultStyle returns the default style used by all widgets
// initially.
//
// Deprecated: Use StyleContext instead, and gtk_css_provider_get_default() to
// obtain a StyleProvider with the default widget style information.
//
// The function returns the following values:
//
//    - style: default style. This Style object is owned by GTK+ and should not
//      be modified or freed.
//
func WidgetGetDefaultStyle() *Style {
	_info := girepository.MustFind("Gtk", "get_default_style")
	_gret := _info.Invoke(nil, nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	var _style *Style // out

	_style = wrapStyle(coreglib.Take(unsafe.Pointer(_cret)))

	return _style
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// ActivateKey activates mnemonics and accelerators for this Window. This is
// normally called by the default ::key_press_event handler for toplevel
// windows, however in some cases it may be useful to call this directly when
// overriding the standard key handling for a toplevel window.
//
// The function takes the following parameters:
//
//    - event: EventKey.
//
// The function returns the following values:
//
//    - ok: TRUE if a mnemonic or accelerator was found and activated.
//
func (window *Window) ActivateKey(event *gdk.EventKey) bool {
	var _arg0 *C.GtkWindow   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkEventKey)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_window_activate_key(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AcceptFocus gets the value set by gtk_window_set_accept_focus().
//
// The function returns the following values:
//
//    - ok: TRUE if window should receive the input focus.
//
func (window *Window) AcceptFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_accept_focus(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasToplevelFocus returns whether the input focus is within this GtkWindow.
// For real toplevel windows, this is identical to gtk_window_is_active(), but
// for embedded windows, like Plug, the results will differ.
//
// The function returns the following values:
//
//    - ok: TRUE if the input focus is within this GtkWindow.
//
func (window *Window) HasToplevelFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_has_toplevel_focus(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive returns whether the window is part of the current active toplevel.
// (That is, the toplevel window receiving keystrokes.) The return value is TRUE
// if the window is active toplevel itself, but also if it is, say, a Plug
// embedded in the active toplevel. You might use this function if you wanted to
// draw a widget differently in an active window from a widget in an inactive
// window. See gtk_window_has_toplevel_focus().
//
// The function returns the following values:
//
//    - ok: TRUE if the window part of the current active window.
//
func (window *Window) IsActive() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_is_active(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PropagateKeyEvent: propagate a key press or release event to the focus widget
// and up the focus container chain until a widget handles event. This is
// normally called by the default ::key_press_event and ::key_release_event
// handlers for toplevel windows, however in some cases it may be useful to call
// this directly when overriding the standard key handling for a toplevel
// window.
//
// The function takes the following parameters:
//
//    - event: EventKey.
//
// The function returns the following values:
//
//    - ok: TRUE if a widget in the focus chain handled the event.
//
func (window *Window) PropagateKeyEvent(event *gdk.EventKey) bool {
	var _arg0 *C.GtkWindow   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkEventKey)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_window_propagate_key_event(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAcceptFocus windows may set a hint asking the desktop environment not to
// receive the input focus. This function sets this hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to let this window receive input focus.
//
func (window *Window) SetAcceptFocus(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_accept_focus(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetKeepAbove asks to keep window above, so that it stays on top. Note that
// you shouldn’t assume the window is definitely above afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// above, and not all window managers support keeping windows above. But
// normally the window will end kept above. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept above when it appears onscreen initially.
//
// You can track the above state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window above other windows.
//
func (window *Window) SetKeepAbove(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_keep_above(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetKeepBelow asks to keep window below, so that it stays in bottom. Note that
// you shouldn’t assume the window is definitely below afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// below, and not all window managers support putting windows below. But
// normally the window will be kept below. Just don’t write code that crashes if
// not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept below when it appears onscreen initially.
//
// You can track the below state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window below other windows.
//
func (window *Window) SetKeepBelow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_keep_below(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// WindowSetDefaultIcon sets an icon to be used as fallback for windows that
// haven't had gtk_window_set_icon() called on them from a pixbuf.
//
// The function takes the following parameters:
//
//    - icon: icon.
//
func WindowSetDefaultIcon(icon *gdkpixbuf.Pixbuf) {
	var _arg1 *C.GdkPixbuf // out

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	C.gtk_window_set_default_icon(_arg1)
	runtime.KeepAlive(icon)
}

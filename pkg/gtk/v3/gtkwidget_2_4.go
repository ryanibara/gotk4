// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// gboolean _gotk4_gtk3_Widget_virtual_can_activate_accel(void* fnptr, GtkWidget* arg0, guint arg1) {
//   return ((gboolean (*)(GtkWidget*, guint))(fnptr))(arg0, arg1);
// };
import "C"

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of mnemonic
// labels for the widget is cleared when the widget is destroyed, so the caller
// must make sure to update its internal state at this point as well, by using a
// connection to the Widget::destroy signal or a weak notifier.
//
// The function takes the following parameters:
//
//    - label that acts as a mnemonic label for widget.
//
func (widget *Widget) AddMnemonicLabel(label Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(label).Native()))

	C.gtk_widget_add_mnemonic_label(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(label)
}

// CanActivateAccel determines whether an accelerator that activates the signal
// identified by signal_id can currently be activated. This is done by emitting
// the Widget::can-activate-accel signal on widget; if the signal isn’t
// overridden by a handler or in a derived widget, then the default check is
// that the widget must be sensitive, and the widget and all its ancestors
// mapped.
//
// The function takes the following parameters:
//
//    - signalId: ID of a signal installed on widget.
//
// The function returns the following values:
//
//    - ok: TRUE if the accelerator can be activated.
//
func (widget *Widget) CanActivateAccel(signalId uint) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.guint(signalId)

	_cret = C.gtk_widget_can_activate_accel(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(signalId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NoShowAll returns the current value of the Widget:no-show-all property, which
// determines whether calls to gtk_widget_show_all() will affect this widget.
//
// The function returns the following values:
//
//    - ok: current value of the “no-show-all” property.
//
func (widget *Widget) NoShowAll() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_no_show_all(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListMnemonicLabels returns a newly allocated list of the widgets, normally
// labels, for which this widget is the target of a mnemonic (see for example,
// gtk_label_set_mnemonic_widget()).
//
// The widgets in the list are not individually referenced. If you want to
// iterate through the list and perform actions involving callbacks that might
// destroy the widgets, you must call g_list_foreach (result,
// (GFunc)g_object_ref, NULL) first, and then unref all the widgets afterwards.
//
// The function returns the following values:
//
//    - list of mnemonic labels; free this list with g_list_free() when you are
//      done with it.
//
func (widget *Widget) ListMnemonicLabels() []Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GList     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_list_mnemonic_labels(_arg0)
	runtime.KeepAlive(widget)

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// QueueResizeNoRedraw: this function works like gtk_widget_queue_resize(),
// except that the widget is not invalidated.
func (widget *Widget) QueueResizeNoRedraw() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_resize_no_redraw(_arg0)
	runtime.KeepAlive(widget)
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must have
// previously been added to the list with gtk_widget_add_mnemonic_label().
//
// The function takes the following parameters:
//
//    - label that was previously set as a mnemonic label for widget with
//      gtk_widget_add_mnemonic_label().
//
func (widget *Widget) RemoveMnemonicLabel(label Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(label).Native()))

	C.gtk_widget_remove_mnemonic_label(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(label)
}

// SetNoShowAll sets the Widget:no-show-all property, which determines whether
// calls to gtk_widget_show_all() will affect this widget.
//
// This is mostly for use in constructing widget hierarchies with externally
// controlled visibility, see UIManager.
//
// The function takes the following parameters:
//
//    - noShowAll: new value for the “no-show-all” property.
//
func (widget *Widget) SetNoShowAll(noShowAll bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if noShowAll {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_no_show_all(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(noShowAll)
}

// canActivateAccel determines whether an accelerator that activates the signal
// identified by signal_id can currently be activated. This is done by emitting
// the Widget::can-activate-accel signal on widget; if the signal isn’t
// overridden by a handler or in a derived widget, then the default check is
// that the widget must be sensitive, and the widget and all its ancestors
// mapped.
//
// The function takes the following parameters:
//
//    - signalId: ID of a signal installed on widget.
//
// The function returns the following values:
//
//    - ok: TRUE if the accelerator can be activated.
//
func (widget *Widget) canActivateAccel(signalId uint) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.can_activate_accel

	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.guint(signalId)

	_cret = C._gotk4_gtk3_Widget_virtual_can_activate_accel(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(signalId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_RadioActionClass_changed(void*, void*);
// extern void _gotk4_gtk3_RadioAction_ConnectChanged(gpointer, void*, guintptr);
import "C"

// GTypeRadioAction returns the GType for the type RadioAction.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeRadioAction() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "RadioAction").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalRadioAction)
	return gtype
}

// RadioActionOverrider contains methods that are overridable.
type RadioActionOverrider interface {
	// The function takes the following parameters:
	//
	Changed(current *RadioAction)
}

// RadioAction is similar to RadioMenuItem. A number of radio actions can be
// linked together so that only one may be active at any one time.
type RadioAction struct {
	_ [0]func() // equal guard
	ToggleAction
}

var (
	_ coreglib.Objector = (*RadioAction)(nil)
)

func classInitRadioActioner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "RadioActionClass")

	if _, ok := goval.(interface{ Changed(current *RadioAction) }); ok {
		o := pclass.StructFieldOffset("changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_RadioActionClass_changed)
	}
}

//export _gotk4_gtk3_RadioActionClass_changed
func _gotk4_gtk3_RadioActionClass_changed(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Changed(current *RadioAction) })

	var _current *RadioAction // out

	_current = wrapRadioAction(coreglib.Take(unsafe.Pointer(arg1)))

	iface.Changed(_current)
}

func wrapRadioAction(obj *coreglib.Object) *RadioAction {
	return &RadioAction{
		ToggleAction: ToggleAction{
			Action: Action{
				Object: obj,
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalRadioAction(p uintptr) (interface{}, error) {
	return wrapRadioAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_RadioAction_ConnectChanged
func _gotk4_gtk3_RadioAction_ConnectChanged(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(current *RadioAction)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(current *RadioAction))
	}

	var _current *RadioAction // out

	_current = wrapRadioAction(coreglib.Take(unsafe.Pointer(arg1)))

	f(_current)
}

// ConnectChanged signal is emitted on every member of a radio group when the
// active member is changed. The signal gets emitted after the ::activate
// signals for the previous and current active members.
func (action *RadioAction) ConnectChanged(f func(current *RadioAction)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(action, "changed", false, unsafe.Pointer(C._gotk4_gtk3_RadioAction_ConnectChanged), f)
}

// NewRadioAction creates a new RadioAction object. To add the action to a
// ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - name: unique name for the action.
//    - label (optional) displayed in menu items and on buttons, or NULL.
//    - tooltip (optional) for this action, or NULL.
//    - stockId (optional): stock icon to display in widgets representing this
//      action, or NULL.
//    - value which gtk_radio_action_get_current_value() should return if this
//      action is selected.
//
// The function returns the following values:
//
//    - radioAction: new RadioAction.
//
func NewRadioAction(name, label, tooltip, stockId string, value int32) *RadioAction {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[0]))
	if label != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_args[1]))
	}
	if tooltip != "" {
		*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(C.CString(tooltip)))
		defer C.free(unsafe.Pointer(_args[2]))
	}
	if stockId != "" {
		*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(unsafe.Pointer(C.CString(stockId)))
		defer C.free(unsafe.Pointer(_args[3]))
	}
	*(*C.gint)(unsafe.Pointer(&_args[4])) = C.gint(value)

	_gret := girepository.MustFind("Gtk", "RadioAction").InvokeMethod("new_RadioAction", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(name)
	runtime.KeepAlive(label)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(stockId)
	runtime.KeepAlive(value)

	var _radioAction *RadioAction // out

	_radioAction = wrapRadioAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _radioAction
}

// CurrentValue obtains the value property of the currently active member of the
// group to which action belongs.
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - gint: value of the currently active group member.
//
func (action *RadioAction) CurrentValue() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "RadioAction").InvokeMethod("get_current_value", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Group returns the list representing the radio group for this object. Note
// that the returned list is only valid until the next change to the group.
//
// A common way to set up a group of radio group is the following:
//
//     GSList *group = NULL;
//     GtkRadioAction *action;
//
//     while ( ...more actions to add... /)
//       {
//          action = gtk_radio_action_new (...);
//
//          gtk_radio_action_set_group (action, group);
//          group = gtk_radio_action_get_group (action);
//       }
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - sList: list representing the radio group for this object.
//
func (action *RadioAction) Group() []*RadioAction {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "RadioAction").InvokeMethod("get_group", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _sList []*RadioAction // out

	_sList = make([]*RadioAction, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *RadioAction // out
		dst = wrapRadioAction(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// JoinGroup joins a radio action object to the group of another radio action
// object.
//
// Use this in language bindings instead of the gtk_radio_action_get_group() and
// gtk_radio_action_set_group() methods
//
// A common way to set up a group of radio actions is the following:
//
//     GtkRadioAction *action;
//     GtkRadioAction *last_action;
//
//     while ( ...more actions to add... /)
//       {
//          action = gtk_radio_action_new (...);
//
//          gtk_radio_action_join_group (action, last_action);
//          last_action = action;
//       }
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - groupSource (optional): radio action object whos group we are joining, or
//      NULL to remove the radio action from its group.
//
func (action *RadioAction) JoinGroup(groupSource *RadioAction) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if groupSource != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(groupSource).Native()))
	}

	girepository.MustFind("Gtk", "RadioAction").InvokeMethod("join_group", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(groupSource)
}

// SetCurrentValue sets the currently active group member to the member with
// value property current_value.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - currentValue: new value.
//
func (action *RadioAction) SetCurrentValue(currentValue int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(currentValue)

	girepository.MustFind("Gtk", "RadioAction").InvokeMethod("set_current_value", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(currentValue)
}

// SetGroup sets the radio group for the radio action object.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - group (optional): list representing a radio group, or NULL.
//
func (action *RadioAction) SetGroup(group []*RadioAction) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if group != nil {
		for i := len(group) - 1; i >= 0; i-- {
			src := group[i]
			var dst *C.void // out
			*(**C.void)(unsafe.Pointer(&dst)) = (*C.void)(unsafe.Pointer(coreglib.InternObject(src).Native()))
			*(**C.void)(unsafe.Pointer(&_args[1])) = C.g_slist_prepend(*(**C.void)(unsafe.Pointer(&_args[1])), C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_slist_free(_args[1])
	}

	girepository.MustFind("Gtk", "RadioAction").InvokeMethod("set_group", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(group)
}

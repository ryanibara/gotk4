// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_radio_action_get_type()), F: marshalRadioActioner},
	})
}

// RadioActionOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type RadioActionOverrider interface {
	Changed(current *RadioAction)
}

// RadioAction is similar to RadioMenuItem. A number of radio actions can be
// linked together so that only one may be active at any one time.
type RadioAction struct {
	ToggleAction
}

func wrapRadioAction(obj *externglib.Object) *RadioAction {
	return &RadioAction{
		ToggleAction: ToggleAction{
			Action: Action{
				Object: obj,
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalRadioActioner(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRadioAction(obj), nil
}

// NewRadioAction creates a new RadioAction object. To add the action to a
// ActionGroup and set the accelerator for the action, call
// gtk_action_group_add_action_with_accel().
//
// Deprecated: since version 3.10.
func NewRadioAction(name string, label string, tooltip string, stockId string, value int) *RadioAction {
	var _arg1 *C.gchar          // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.gchar          // out
	var _arg4 *C.gchar          // out
	var _arg5 C.gint            // out
	var _cret *C.GtkRadioAction // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if label != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if tooltip != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(tooltip)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if stockId != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(stockId)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = C.gint(value)

	_cret = C.gtk_radio_action_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(label)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(stockId)
	runtime.KeepAlive(value)

	var _radioAction *RadioAction // out

	_radioAction = wrapRadioAction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _radioAction
}

// CurrentValue obtains the value property of the currently active member of the
// group to which action belongs.
//
// Deprecated: since version 3.10.
func (action *RadioAction) CurrentValue() int {
	var _arg0 *C.GtkRadioAction // out
	var _cret C.gint            // in

	_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(action.Native()))

	_cret = C.gtk_radio_action_get_current_value(_arg0)
	runtime.KeepAlive(action)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Group returns the list representing the radio group for this object. Note
// that the returned list is only valid until the next change to the group.
//
// A common way to set up a group of radio group is the following:
//
//     GSList *group = NULL;
//     GtkRadioAction *action;
//
//     while ( ...more actions to add... /)
//       {
//          action = gtk_radio_action_new (...);
//
//          gtk_radio_action_set_group (action, group);
//          group = gtk_radio_action_get_group (action);
//       }
//
// Deprecated: since version 3.10.
func (action *RadioAction) Group() []RadioAction {
	var _arg0 *C.GtkRadioAction // out
	var _cret *C.GSList         // in

	_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(action.Native()))

	_cret = C.gtk_radio_action_get_group(_arg0)
	runtime.KeepAlive(action)

	var _sList []RadioAction // out

	_sList = make([]RadioAction, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkRadioAction)(v)
		var dst RadioAction // out
		dst = *wrapRadioAction(externglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// JoinGroup joins a radio action object to the group of another radio action
// object.
//
// Use this in language bindings instead of the gtk_radio_action_get_group() and
// gtk_radio_action_set_group() methods
//
// A common way to set up a group of radio actions is the following:
//
//     GtkRadioAction *action;
//     GtkRadioAction *last_action;
//
//     while ( ...more actions to add... /)
//       {
//          action = gtk_radio_action_new (...);
//
//          gtk_radio_action_join_group (action, last_action);
//          last_action = action;
//       }
//
// Deprecated: since version 3.10.
func (action *RadioAction) JoinGroup(groupSource *RadioAction) {
	var _arg0 *C.GtkRadioAction // out
	var _arg1 *C.GtkRadioAction // out

	_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(action.Native()))
	if groupSource != nil {
		_arg1 = (*C.GtkRadioAction)(unsafe.Pointer(groupSource.Native()))
	}

	C.gtk_radio_action_join_group(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(groupSource)
}

// SetCurrentValue sets the currently active group member to the member with
// value property current_value.
//
// Deprecated: since version 3.10.
func (action *RadioAction) SetCurrentValue(currentValue int) {
	var _arg0 *C.GtkRadioAction // out
	var _arg1 C.gint            // out

	_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(action.Native()))
	_arg1 = C.gint(currentValue)

	C.gtk_radio_action_set_current_value(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(currentValue)
}

// SetGroup sets the radio group for the radio action object.
//
// Deprecated: since version 3.10.
func (action *RadioAction) SetGroup(group []RadioAction) {
	var _arg0 *C.GtkRadioAction // out
	var _arg1 *C.GSList         // out

	_arg0 = (*C.GtkRadioAction)(unsafe.Pointer(action.Native()))
	if group != nil {
		for i := len(group) - 1; i >= 0; i-- {
			src := group[i]
			var dst *C.GtkRadioAction // out
			dst = (*C.GtkRadioAction)(unsafe.Pointer((&src).Native()))
			_arg1 = C.g_slist_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
		}
		defer C.g_slist_free(_arg1)
	}

	C.gtk_radio_action_set_group(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(group)
}

// ConnectChanged signal is emitted on every member of a radio group when the
// active member is changed. The signal gets emitted after the ::activate
// signals for the previous and current active members.
func (r *RadioAction) ConnectChanged(f func(current RadioAction)) glib.SignalHandle {
	return r.Connect("changed", f)
}

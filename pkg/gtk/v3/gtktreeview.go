// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_gtk3_TreeViewClass_expand_collapse_cursor_row(GtkTreeView*, gboolean, gboolean, gboolean);
// extern gboolean _gotk4_gtk3_TreeViewClass_select_all(GtkTreeView*);
// extern gboolean _gotk4_gtk3_TreeViewClass_select_cursor_parent(GtkTreeView*);
// extern gboolean _gotk4_gtk3_TreeViewClass_select_cursor_row(GtkTreeView*, gboolean);
// extern gboolean _gotk4_gtk3_TreeViewClass_start_interactive_search(GtkTreeView*);
// extern gboolean _gotk4_gtk3_TreeViewClass_test_collapse_row(GtkTreeView*, GtkTreeIter*, GtkTreePath*);
// extern gboolean _gotk4_gtk3_TreeViewClass_test_expand_row(GtkTreeView*, GtkTreeIter*, GtkTreePath*);
// extern gboolean _gotk4_gtk3_TreeViewClass_toggle_cursor_row(GtkTreeView*);
// extern gboolean _gotk4_gtk3_TreeViewClass_unselect_all(GtkTreeView*);
// extern gboolean _gotk4_gtk3_TreeView_ConnectExpandCollapseCursorRow(gpointer, gboolean, gboolean, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_TreeView_ConnectSelectAll(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_TreeView_ConnectSelectCursorParent(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_TreeView_ConnectSelectCursorRow(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_TreeView_ConnectStartInteractiveSearch(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_TreeView_ConnectTestCollapseRow(gpointer, GtkTreeIter*, GtkTreePath*, guintptr);
// extern gboolean _gotk4_gtk3_TreeView_ConnectTestExpandRow(gpointer, GtkTreeIter*, GtkTreePath*, guintptr);
// extern gboolean _gotk4_gtk3_TreeView_ConnectToggleCursorRow(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_TreeView_ConnectUnselectAll(gpointer, guintptr);
// extern void _gotk4_gtk3_TreeViewClass_columns_changed(GtkTreeView*);
// extern void _gotk4_gtk3_TreeViewClass_cursor_changed(GtkTreeView*);
// extern void _gotk4_gtk3_TreeViewClass_row_activated(GtkTreeView*, GtkTreePath*, GtkTreeViewColumn*);
// extern void _gotk4_gtk3_TreeViewClass_row_collapsed(GtkTreeView*, GtkTreeIter*, GtkTreePath*);
// extern void _gotk4_gtk3_TreeViewClass_row_expanded(GtkTreeView*, GtkTreeIter*, GtkTreePath*);
// extern void _gotk4_gtk3_TreeView_ConnectColumnsChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_TreeView_ConnectCursorChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_TreeView_ConnectRowActivated(gpointer, GtkTreePath*, GtkTreeViewColumn*, guintptr);
// extern void _gotk4_gtk3_TreeView_ConnectRowCollapsed(gpointer, GtkTreeIter*, GtkTreePath*, guintptr);
// extern void _gotk4_gtk3_TreeView_ConnectRowExpanded(gpointer, GtkTreeIter*, GtkTreePath*, guintptr);
import "C"

// glib.Type values for gtktreeview.go.
var (
	GTypeTreeViewDropPosition = coreglib.Type(C.gtk_tree_view_drop_position_get_type())
	GTypeTreeView             = coreglib.Type(C.gtk_tree_view_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeTreeViewDropPosition, F: marshalTreeViewDropPosition},
		{T: GTypeTreeView, F: marshalTreeView},
	})
}

// TreeViewDropPosition: enum for determining where a dropped row goes.
type TreeViewDropPosition C.gint

const (
	// TreeViewDropBefore: dropped row is inserted before.
	TreeViewDropBefore TreeViewDropPosition = iota
	// TreeViewDropAfter: dropped row is inserted after.
	TreeViewDropAfter
	// TreeViewDropIntoOrBefore: dropped row becomes a child or is inserted
	// before.
	TreeViewDropIntoOrBefore
	// TreeViewDropIntoOrAfter: dropped row becomes a child or is inserted
	// after.
	TreeViewDropIntoOrAfter
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TreeViewDropPosition.
func (t TreeViewDropPosition) String() string {
	switch t {
	case TreeViewDropBefore:
		return "Before"
	case TreeViewDropAfter:
		return "After"
	case TreeViewDropIntoOrBefore:
		return "IntoOrBefore"
	case TreeViewDropIntoOrAfter:
		return "IntoOrAfter"
	default:
		return fmt.Sprintf("TreeViewDropPosition(%d)", t)
	}
}

type TreeDestroyCountFunc func(treeView *TreeView, path *TreePath, children int)

//export _gotk4_gtk3_TreeDestroyCountFunc
func _gotk4_gtk3_TreeDestroyCountFunc(arg1 *C.GtkTreeView, arg2 *C.GtkTreePath, arg3 C.gint, arg4 C.gpointer) {
	var fn TreeDestroyCountFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeDestroyCountFunc)
	}

	var _treeView *TreeView // out
	var _path *TreePath     // out
	var _children int       // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_children = int(arg3)

	fn(_treeView, _path, _children)
}

// TreeViewColumnDropFunc: function type for determining whether column can be
// dropped in a particular spot (as determined by prev_column and next_column).
// In left to right locales, prev_column is on the left of the potential drop
// spot, and next_column is on the right. In right to left mode, this is
// reversed. This function should return TRUE if the spot is a valid drop spot.
// Please note that returning TRUE does not actually indicate that the column
// drop was made, but is meant only to indicate a possible drop spot to the
// user.
type TreeViewColumnDropFunc func(treeView *TreeView, column, prevColumn, nextColumn *TreeViewColumn) (ok bool)

//export _gotk4_gtk3_TreeViewColumnDropFunc
func _gotk4_gtk3_TreeViewColumnDropFunc(arg1 *C.GtkTreeView, arg2 *C.GtkTreeViewColumn, arg3 *C.GtkTreeViewColumn, arg4 *C.GtkTreeViewColumn, arg5 C.gpointer) (cret C.gboolean) {
	var fn TreeViewColumnDropFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewColumnDropFunc)
	}

	var _treeView *TreeView         // out
	var _column *TreeViewColumn     // out
	var _prevColumn *TreeViewColumn // out
	var _nextColumn *TreeViewColumn // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(arg1)))
	_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg2)))
	_prevColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg3)))
	_nextColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg4)))

	ok := fn(_treeView, _column, _prevColumn, _nextColumn)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TreeViewMappingFunc: function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(treeView *TreeView, path *TreePath)

//export _gotk4_gtk3_TreeViewMappingFunc
func _gotk4_gtk3_TreeViewMappingFunc(arg1 *C.GtkTreeView, arg2 *C.GtkTreePath, arg3 C.gpointer) {
	var fn TreeViewMappingFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewMappingFunc)
	}

	var _treeView *TreeView // out
	var _path *TreePath     // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	fn(_treeView, _path)
}

// TreeViewRowSeparatorFunc: function type for determining whether the row
// pointed to by iter should be rendered as a separator. A common way to
// implement this is to have a boolean column in the model, whose values the
// TreeViewRowSeparatorFunc returns.
type TreeViewRowSeparatorFunc func(model TreeModeller, iter *TreeIter) (ok bool)

//export _gotk4_gtk3_TreeViewRowSeparatorFunc
func _gotk4_gtk3_TreeViewRowSeparatorFunc(arg1 *C.GtkTreeModel, arg2 *C.GtkTreeIter, arg3 C.gpointer) (cret C.gboolean) {
	var fn TreeViewRowSeparatorFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewRowSeparatorFunc)
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := fn(_model, _iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TreeViewSearchEqualFunc: function used for checking whether a row in model
// matches a search key string entered by the user. Note the return value is
// reversed from what you would normally expect, though it has some similarity
// to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(model TreeModeller, column int, key string, iter *TreeIter) (ok bool)

//export _gotk4_gtk3_TreeViewSearchEqualFunc
func _gotk4_gtk3_TreeViewSearchEqualFunc(arg1 *C.GtkTreeModel, arg2 C.gint, arg3 *C.gchar, arg4 *C.GtkTreeIter, arg5 C.gpointer) (cret C.gboolean) {
	var fn TreeViewSearchEqualFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewSearchEqualFunc)
	}

	var _model TreeModeller // out
	var _column int         // out
	var _key string         // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_column = int(arg2)
	_key = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := fn(_model, _column, _key, _iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

type TreeViewSearchPositionFunc func(treeView *TreeView, searchDialog Widgetter)

//export _gotk4_gtk3_TreeViewSearchPositionFunc
func _gotk4_gtk3_TreeViewSearchPositionFunc(arg1 *C.GtkTreeView, arg2 *C.GtkWidget, arg3 C.gpointer) {
	var fn TreeViewSearchPositionFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeViewSearchPositionFunc)
	}

	var _treeView *TreeView     // out
	var _searchDialog Widgetter // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(arg1)))
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_searchDialog = rv
	}

	fn(_treeView, _searchDialog)
}

// TreeViewOverrider contains methods that are overridable.
type TreeViewOverrider interface {
	ColumnsChanged()
	CursorChanged()
	// The function takes the following parameters:
	//
	//    - logical
	//    - expand
	//    - openAll
	//
	// The function returns the following values:
	//
	ExpandCollapseCursorRow(logical, expand, openAll bool) bool
	// RowActivated activates the cell determined by path and column.
	//
	// The function takes the following parameters:
	//
	//    - path to be activated.
	//    - column to be activated.
	//
	RowActivated(path *TreePath, column *TreeViewColumn)
	// The function takes the following parameters:
	//
	//    - iter
	//    - path
	//
	RowCollapsed(iter *TreeIter, path *TreePath)
	// The function takes the following parameters:
	//
	//    - iter
	//    - path
	//
	RowExpanded(iter *TreeIter, path *TreePath)
	// The function returns the following values:
	//
	SelectAll() bool
	// The function returns the following values:
	//
	SelectCursorParent() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SelectCursorRow(startEditing bool) bool
	// The function returns the following values:
	//
	StartInteractiveSearch() bool
	// The function takes the following parameters:
	//
	//    - iter
	//    - path
	//
	// The function returns the following values:
	//
	TestCollapseRow(iter *TreeIter, path *TreePath) bool
	// The function takes the following parameters:
	//
	//    - iter
	//    - path
	//
	// The function returns the following values:
	//
	TestExpandRow(iter *TreeIter, path *TreePath) bool
	// The function returns the following values:
	//
	ToggleCursorRow() bool
	// The function returns the following values:
	//
	UnselectAll() bool
}

// TreeView: widget that displays any object that implements the TreeModel
// interface.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together.
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ! (tree-view-coordinates.png)
//
// Coordinate systems in GtkTreeView API:
//
// - Widget coordinates: Coordinates relative to the widget (usually
// widget->window).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk_tree_view_convert_widget_to_bin_window_coords() (and
// vice versa), for the latter gtk_tree_view_convert_bin_window_to_tree_coords()
// (and vice versa).
//
//
// GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// TreeViewColumn objects as <child> elements and exposes the internal
// TreeSelection in UI definitions.
//
// An example of a UI definition fragment with GtkTreeView:
//
//    <object class="GtkTreeView" id="treeview">
//      <property name="model">liststore1</property>
//      <child>
//        <object class="GtkTreeViewColumn" id="test-column">
//          <property name="title">Test</property>
//          <child>
//            <object class="GtkCellRendererText" id="test-renderer"/>
//            <attributes>
//              <attribute name="text">1</attribute>
//            </attributes>
//          </child>
//        </object>
//      </child>
//      <child internal-child="selection">
//        <object class="GtkTreeSelection" id="selection">
//          <signal name="changed" handler="on_treeview_selection_changed"/>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    treeview.view
//    ├── header
//    │   ├── <column header>
//    ┊   ┊
//    │   ╰── <column header>
//    │
//    ╰── [rubberband]
//
// GtkTreeView has a main CSS node with name treeview and style class .view. It
// has a subnode with name header, which is the parent for all the column header
// widgets' CSS nodes. For rubberband selection, a subnode with name rubberband
// is used.
type TreeView struct {
	_ [0]func() // equal guard
	Container

	*coreglib.Object
	Scrollable
}

var (
	_ Containerer       = (*TreeView)(nil)
	_ coreglib.Objector = (*TreeView)(nil)
)

func classInitTreeViewer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkTreeViewClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkTreeViewClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ ColumnsChanged() }); ok {
		pclass.columns_changed = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_columns_changed)
	}

	if _, ok := goval.(interface{ CursorChanged() }); ok {
		pclass.cursor_changed = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_cursor_changed)
	}

	if _, ok := goval.(interface {
		ExpandCollapseCursorRow(logical, expand, openAll bool) bool
	}); ok {
		pclass.expand_collapse_cursor_row = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_expand_collapse_cursor_row)
	}

	if _, ok := goval.(interface {
		RowActivated(path *TreePath, column *TreeViewColumn)
	}); ok {
		pclass.row_activated = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_row_activated)
	}

	if _, ok := goval.(interface {
		RowCollapsed(iter *TreeIter, path *TreePath)
	}); ok {
		pclass.row_collapsed = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_row_collapsed)
	}

	if _, ok := goval.(interface {
		RowExpanded(iter *TreeIter, path *TreePath)
	}); ok {
		pclass.row_expanded = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_row_expanded)
	}

	if _, ok := goval.(interface{ SelectAll() bool }); ok {
		pclass.select_all = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_select_all)
	}

	if _, ok := goval.(interface{ SelectCursorParent() bool }); ok {
		pclass.select_cursor_parent = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_select_cursor_parent)
	}

	if _, ok := goval.(interface{ SelectCursorRow(startEditing bool) bool }); ok {
		pclass.select_cursor_row = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_select_cursor_row)
	}

	if _, ok := goval.(interface{ StartInteractiveSearch() bool }); ok {
		pclass.start_interactive_search = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_start_interactive_search)
	}

	if _, ok := goval.(interface {
		TestCollapseRow(iter *TreeIter, path *TreePath) bool
	}); ok {
		pclass.test_collapse_row = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_test_collapse_row)
	}

	if _, ok := goval.(interface {
		TestExpandRow(iter *TreeIter, path *TreePath) bool
	}); ok {
		pclass.test_expand_row = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_test_expand_row)
	}

	if _, ok := goval.(interface{ ToggleCursorRow() bool }); ok {
		pclass.toggle_cursor_row = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_toggle_cursor_row)
	}

	if _, ok := goval.(interface{ UnselectAll() bool }); ok {
		pclass.unselect_all = (*[0]byte)(C._gotk4_gtk3_TreeViewClass_unselect_all)
	}
}

//export _gotk4_gtk3_TreeViewClass_columns_changed
func _gotk4_gtk3_TreeViewClass_columns_changed(arg0 *C.GtkTreeView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ColumnsChanged() })

	iface.ColumnsChanged()
}

//export _gotk4_gtk3_TreeViewClass_cursor_changed
func _gotk4_gtk3_TreeViewClass_cursor_changed(arg0 *C.GtkTreeView) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CursorChanged() })

	iface.CursorChanged()
}

//export _gotk4_gtk3_TreeViewClass_expand_collapse_cursor_row
func _gotk4_gtk3_TreeViewClass_expand_collapse_cursor_row(arg0 *C.GtkTreeView, arg1 C.gboolean, arg2 C.gboolean, arg3 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ExpandCollapseCursorRow(logical, expand, openAll bool) bool
	})

	var _logical bool // out
	var _expand bool  // out
	var _openAll bool // out

	if arg1 != 0 {
		_logical = true
	}
	if arg2 != 0 {
		_expand = true
	}
	if arg3 != 0 {
		_openAll = true
	}

	ok := iface.ExpandCollapseCursorRow(_logical, _expand, _openAll)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_row_activated
func _gotk4_gtk3_TreeViewClass_row_activated(arg0 *C.GtkTreeView, arg1 *C.GtkTreePath, arg2 *C.GtkTreeViewColumn) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		RowActivated(path *TreePath, column *TreeViewColumn)
	})

	var _path *TreePath         // out
	var _column *TreeViewColumn // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg2)))

	iface.RowActivated(_path, _column)
}

//export _gotk4_gtk3_TreeViewClass_row_collapsed
func _gotk4_gtk3_TreeViewClass_row_collapsed(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		RowCollapsed(iter *TreeIter, path *TreePath)
	})

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iface.RowCollapsed(_iter, _path)
}

//export _gotk4_gtk3_TreeViewClass_row_expanded
func _gotk4_gtk3_TreeViewClass_row_expanded(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		RowExpanded(iter *TreeIter, path *TreePath)
	})

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iface.RowExpanded(_iter, _path)
}

//export _gotk4_gtk3_TreeViewClass_select_all
func _gotk4_gtk3_TreeViewClass_select_all(arg0 *C.GtkTreeView) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SelectAll() bool })

	ok := iface.SelectAll()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_select_cursor_parent
func _gotk4_gtk3_TreeViewClass_select_cursor_parent(arg0 *C.GtkTreeView) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SelectCursorParent() bool })

	ok := iface.SelectCursorParent()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_select_cursor_row
func _gotk4_gtk3_TreeViewClass_select_cursor_row(arg0 *C.GtkTreeView, arg1 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SelectCursorRow(startEditing bool) bool })

	var _startEditing bool // out

	if arg1 != 0 {
		_startEditing = true
	}

	ok := iface.SelectCursorRow(_startEditing)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_start_interactive_search
func _gotk4_gtk3_TreeViewClass_start_interactive_search(arg0 *C.GtkTreeView) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ StartInteractiveSearch() bool })

	ok := iface.StartInteractiveSearch()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_test_collapse_row
func _gotk4_gtk3_TreeViewClass_test_collapse_row(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		TestCollapseRow(iter *TreeIter, path *TreePath) bool
	})

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := iface.TestCollapseRow(_iter, _path)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_test_expand_row
func _gotk4_gtk3_TreeViewClass_test_expand_row(arg0 *C.GtkTreeView, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		TestExpandRow(iter *TreeIter, path *TreePath) bool
	})

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := iface.TestExpandRow(_iter, _path)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_toggle_cursor_row
func _gotk4_gtk3_TreeViewClass_toggle_cursor_row(arg0 *C.GtkTreeView) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ToggleCursorRow() bool })

	ok := iface.ToggleCursorRow()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeViewClass_unselect_all
func _gotk4_gtk3_TreeViewClass_unselect_all(arg0 *C.GtkTreeView) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ UnselectAll() bool })

	ok := iface.UnselectAll()

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapTreeView(obj *coreglib.Object) *TreeView {
	return &TreeView{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalTreeView(p uintptr) (interface{}, error) {
	return wrapTreeView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_TreeView_ConnectColumnsChanged
func _gotk4_gtk3_TreeView_ConnectColumnsChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectColumnsChanged: number of columns of the treeview has changed.
func (treeView *TreeView) ConnectColumnsChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "columns-changed", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectColumnsChanged), f)
}

//export _gotk4_gtk3_TreeView_ConnectCursorChanged
func _gotk4_gtk3_TreeView_ConnectCursorChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCursorChanged: position of the cursor (focused cell) has changed.
func (treeView *TreeView) ConnectCursorChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "cursor-changed", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectCursorChanged), f)
}

//export _gotk4_gtk3_TreeView_ConnectExpandCollapseCursorRow
func _gotk4_gtk3_TreeView_ConnectExpandCollapseCursorRow(arg0 C.gpointer, arg1 C.gboolean, arg2 C.gboolean, arg3 C.gboolean, arg4 C.guintptr) (cret C.gboolean) {
	var f func(object, p0, p1 bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object, p0, p1 bool) (ok bool))
	}

	var _object bool // out
	var _p0 bool     // out
	var _p1 bool     // out

	if arg1 != 0 {
		_object = true
	}
	if arg2 != 0 {
		_p0 = true
	}
	if arg3 != 0 {
		_p1 = true
	}

	ok := f(_object, _p0, _p1)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (treeView *TreeView) ConnectExpandCollapseCursorRow(f func(object, p0, p1 bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "expand-collapse-cursor-row", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectExpandCollapseCursorRow), f)
}

//export _gotk4_gtk3_TreeView_ConnectRowActivated
func _gotk4_gtk3_TreeView_ConnectRowActivated(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeViewColumn, arg3 C.guintptr) {
	var f func(path *TreePath, column *TreeViewColumn)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, column *TreeViewColumn))
	}

	var _path *TreePath         // out
	var _column *TreeViewColumn // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(arg2)))

	f(_path, _column)
}

// ConnectRowActivated: "row-activated" signal is emitted when the method
// gtk_tree_view_row_activated() is called, when the user double clicks a
// treeview row with the "activate-on-single-click" property set to FALSE, or
// when the user single clicks a row when the "activate-on-single-click"
// property set to TRUE. It is also emitted when a non-editable row is selected
// and one of the keys: Space, Shift+Space, Return or Enter is pressed.
//
// For selection handling refer to the [tree widget conceptual
// overview][TreeWidget] as well as TreeSelection.
func (treeView *TreeView) ConnectRowActivated(f func(path *TreePath, column *TreeViewColumn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "row-activated", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectRowActivated), f)
}

//export _gotk4_gtk3_TreeView_ConnectRowCollapsed
func _gotk4_gtk3_TreeView_ConnectRowCollapsed(arg0 C.gpointer, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath, arg3 C.guintptr) {
	var f func(iter *TreeIter, path *TreePath)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iter *TreeIter, path *TreePath))
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_iter, _path)
}

// ConnectRowCollapsed: given row has been collapsed (child nodes are hidden).
func (treeView *TreeView) ConnectRowCollapsed(f func(iter *TreeIter, path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "row-collapsed", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectRowCollapsed), f)
}

//export _gotk4_gtk3_TreeView_ConnectRowExpanded
func _gotk4_gtk3_TreeView_ConnectRowExpanded(arg0 C.gpointer, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath, arg3 C.guintptr) {
	var f func(iter *TreeIter, path *TreePath)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iter *TreeIter, path *TreePath))
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_iter, _path)
}

// ConnectRowExpanded: given row has been expanded (child nodes are shown).
func (treeView *TreeView) ConnectRowExpanded(f func(iter *TreeIter, path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "row-expanded", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectRowExpanded), f)
}

//export _gotk4_gtk3_TreeView_ConnectSelectAll
func _gotk4_gtk3_TreeView_ConnectSelectAll(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (treeView *TreeView) ConnectSelectAll(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "select-all", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectSelectAll), f)
}

//export _gotk4_gtk3_TreeView_ConnectSelectCursorParent
func _gotk4_gtk3_TreeView_ConnectSelectCursorParent(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (treeView *TreeView) ConnectSelectCursorParent(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "select-cursor-parent", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectSelectCursorParent), f)
}

//export _gotk4_gtk3_TreeView_ConnectSelectCursorRow
func _gotk4_gtk3_TreeView_ConnectSelectCursorRow(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object bool) (ok bool))
	}

	var _object bool // out

	if arg1 != 0 {
		_object = true
	}

	ok := f(_object)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (treeView *TreeView) ConnectSelectCursorRow(f func(object bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "select-cursor-row", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectSelectCursorRow), f)
}

//export _gotk4_gtk3_TreeView_ConnectStartInteractiveSearch
func _gotk4_gtk3_TreeView_ConnectStartInteractiveSearch(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (treeView *TreeView) ConnectStartInteractiveSearch(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "start-interactive-search", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectStartInteractiveSearch), f)
}

//export _gotk4_gtk3_TreeView_ConnectTestCollapseRow
func _gotk4_gtk3_TreeView_ConnectTestCollapseRow(arg0 C.gpointer, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath, arg3 C.guintptr) (cret C.gboolean) {
	var f func(iter *TreeIter, path *TreePath) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iter *TreeIter, path *TreePath) (ok bool))
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := f(_iter, _path)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectTestCollapseRow: given row is about to be collapsed (hide its children
// nodes). Use this signal if you need to control the collapsibility of
// individual rows.
func (treeView *TreeView) ConnectTestCollapseRow(f func(iter *TreeIter, path *TreePath) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "test-collapse-row", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectTestCollapseRow), f)
}

//export _gotk4_gtk3_TreeView_ConnectTestExpandRow
func _gotk4_gtk3_TreeView_ConnectTestExpandRow(arg0 C.gpointer, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath, arg3 C.guintptr) (cret C.gboolean) {
	var f func(iter *TreeIter, path *TreePath) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(iter *TreeIter, path *TreePath) (ok bool))
	}

	var _iter *TreeIter // out
	var _path *TreePath // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := f(_iter, _path)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectTestExpandRow: given row is about to be expanded (show its children
// nodes). Use this signal if you need to control the expandability of
// individual rows.
func (treeView *TreeView) ConnectTestExpandRow(f func(iter *TreeIter, path *TreePath) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "test-expand-row", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectTestExpandRow), f)
}

//export _gotk4_gtk3_TreeView_ConnectToggleCursorRow
func _gotk4_gtk3_TreeView_ConnectToggleCursorRow(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (treeView *TreeView) ConnectToggleCursorRow(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "toggle-cursor-row", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectToggleCursorRow), f)
}

//export _gotk4_gtk3_TreeView_ConnectUnselectAll
func _gotk4_gtk3_TreeView_ConnectUnselectAll(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (treeView *TreeView) ConnectUnselectAll(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "unselect-all", false, unsafe.Pointer(C._gotk4_gtk3_TreeView_ConnectUnselectAll), f)
}

// NewTreeView creates a new TreeView widget.
//
// The function returns the following values:
//
//    - treeView: newly created TreeView widget.
//
func NewTreeView() *TreeView {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("new_TreeView", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _treeView *TreeView // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// NewTreeViewWithModel creates a new TreeView widget with the model initialized
// to model.
//
// The function takes the following parameters:
//
//    - model: model.
//
// The function returns the following values:
//
//    - treeView: newly created TreeView widget.
//
func NewTreeViewWithModel(model TreeModeller) *TreeView {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	*(*TreeModeller)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("new_TreeView_with_model", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(model)

	var _treeView *TreeView // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// AppendColumn appends column to the list of columns. If tree_view has
// “fixed_height” mode enabled, then column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
//
// The function takes the following parameters:
//
//    - column to add.
//
// The function returns the following values:
//
//    - gint: number of columns in tree_view after appending.
//
func (treeView *TreeView) AppendColumn(column *TreeViewColumn) int {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("append_column", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CollapseAll: recursively collapses all visible, expanded nodes in tree_view.
func (treeView *TreeView) CollapseAll() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("collapse_all", args[:], nil)

	runtime.KeepAlive(treeView)
}

// CollapseRow collapses a row (hides its child rows, if they exist).
//
// The function takes the following parameters:
//
//    - path to a row in the tree_view.
//
// The function returns the following values:
//
//    - ok: TRUE if the row was collapsed.
//
func (treeView *TreeView) CollapseRow(path *TreePath) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("collapse_row", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColumnsAutosize resizes all columns to their optimal width. Only works after
// the treeview has been realized.
func (treeView *TreeView) ColumnsAutosize() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("columns_autosize", args[:], nil)

	runtime.KeepAlive(treeView)
}

// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
// path. This image is used for a drag icon.
//
// The function takes the following parameters:
//
//    - path in tree_view.
//
// The function returns the following values:
//
//    - surface: newly-allocated surface of the drag icon.
//
func (treeView *TreeView) CreateRowDragIcon(path *TreePath) *cairo.Surface {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("create_row_drag_icon", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// ExpandAll: recursively expands all nodes in the tree_view.
func (treeView *TreeView) ExpandAll() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("expand_all", args[:], nil)

	runtime.KeepAlive(treeView)
}

// ExpandRow opens the row so its children are visible.
//
// The function takes the following parameters:
//
//    - path to a row.
//    - openAll: whether to recursively expand, or just expand immediate
//      children.
//
// The function returns the following values:
//
//    - ok: TRUE if the row existed and had children.
//
func (treeView *TreeView) ExpandRow(path *TreePath, openAll bool) bool {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	if openAll {
		_arg2 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TreePath)(unsafe.Pointer(&args[2])) = _arg2

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("expand_row", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(openAll)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExpandToPath expands the row at path. This will also expand all parent rows
// of path as necessary.
//
// The function takes the following parameters:
//
//    - path to a row.
//
func (treeView *TreeView) ExpandToPath(path *TreePath) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("expand_to_path", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
}

// ActivateOnSingleClick gets the setting set by
// gtk_tree_view_set_activate_on_single_click().
//
// The function returns the following values:
//
//    - ok: TRUE if row-activated will be emitted on a single click.
//
func (treeView *TreeView) ActivateOnSingleClick() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_activate_on_single_click", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BinWindow returns the window that tree_view renders to. This is used
// primarily to compare to event->window to confirm that the event on tree_view
// is on the right window.
//
// The function returns the following values:
//
//    - window (optional) or NULL when tree_view hasn’t been realized yet.
//
func (treeView *TreeView) BinWindow() gdk.Windower {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_bin_window", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _window gdk.Windower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Windower)
				return ok
			})
			rv, ok := casted.(gdk.Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _window
}

// Column gets the TreeViewColumn at the given position in the #tree_view.
//
// The function takes the following parameters:
//
//    - n of the column, counting from 0.
//
// The function returns the following values:
//
//    - treeViewColumn (optional) or NULL if the position is outside the range of
//      columns.
//
func (treeView *TreeView) Column(n int) *TreeViewColumn {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.gint(n)
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_column", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(n)

	var _treeViewColumn *TreeViewColumn // out

	if _cret != nil {
		_treeViewColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeViewColumn
}

// Columns returns a #GList of all the TreeViewColumn s currently in tree_view.
// The returned list must be freed with g_list_free ().
//
// The function returns the following values:
//
//    - list of TreeViewColumn s.
//
func (treeView *TreeView) Columns() []*TreeViewColumn {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_columns", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _list []*TreeViewColumn // out

	_list = make([]*TreeViewColumn, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *TreeViewColumn // out
		dst = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Cursor fills in path and focus_column with the current path and focus column.
// If the cursor isn’t currently set, then *path will be NULL. If no column
// currently has focus, then *focus_column will be NULL.
//
// The returned TreePath must be freed with gtk_tree_path_free() when you are
// done with it.
//
// The function returns the following values:
//
//    - path (optional): pointer to be filled with the current cursor path, or
//      NULL.
//    - focusColumn (optional): a pointer to be filled with the current focus
//      column, or NULL.
//
func (treeView *TreeView) Cursor() (*TreePath, *TreeViewColumn) {
	var args [1]girepository.Argument
	var outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_cursor", args[:], outs[:])

	runtime.KeepAlive(treeView)

	var _path *TreePath              // out
	var _focusColumn *TreeViewColumn // out
	_out1 = *(**TreePath)(unsafe.Pointer(&outs[1]))

	if _out0 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_out0)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _out1 != nil {
		_focusColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_out1)))
	}

	return _path, _focusColumn
}

// EnableSearch returns whether or not the tree allows to start interactive
// searching by typing in text.
//
// The function returns the following values:
//
//    - ok: whether or not to let the user search interactively.
//
func (treeView *TreeView) EnableSearch() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_enable_search", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnableTreeLines returns whether or not tree lines are drawn in tree_view.
//
// The function returns the following values:
//
//    - ok: TRUE if tree lines are drawn in tree_view, FALSE otherwise.
//
func (treeView *TreeView) EnableTreeLines() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_enable_tree_lines", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExpanderColumn returns the column that is the current expander column. This
// column has the expander arrow drawn next to it.
//
// The function returns the following values:
//
//    - treeViewColumn: expander column.
//
func (treeView *TreeView) ExpanderColumn() *TreeViewColumn {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_expander_column", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _treeViewColumn *TreeViewColumn // out

	_treeViewColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeViewColumn
}

// FixedHeightMode returns whether fixed height mode is turned on for tree_view.
//
// The function returns the following values:
//
//    - ok: TRUE if tree_view is in fixed height mode.
//
func (treeView *TreeView) FixedHeightMode() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_fixed_height_mode", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HAdjustment gets the Adjustment currently being used for the horizontal
// aspect.
//
// Deprecated: Use gtk_scrollable_get_hadjustment().
//
// The function returns the following values:
//
//    - adjustment object, or NULL if none is currently being used.
//
func (treeView *TreeView) HAdjustment() *Adjustment {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_hadjustment", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// HeadersClickable returns whether all header columns are clickable.
//
// The function returns the following values:
//
//    - ok: TRUE if all header columns are clickable, otherwise FALSE.
//
func (treeView *TreeView) HeadersClickable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_headers_clickable", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HeadersVisible returns TRUE if the headers on the tree_view are visible.
//
// The function returns the following values:
//
//    - ok: whether the headers are visible or not.
//
func (treeView *TreeView) HeadersVisible() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_headers_visible", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HoverExpand returns whether hover expansion mode is turned on for tree_view.
//
// The function returns the following values:
//
//    - ok: TRUE if tree_view is in hover expansion mode.
//
func (treeView *TreeView) HoverExpand() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_hover_expand", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HoverSelection returns whether hover selection mode is turned on for
// tree_view.
//
// The function returns the following values:
//
//    - ok: TRUE if tree_view is in hover selection mode.
//
func (treeView *TreeView) HoverSelection() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_hover_selection", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LevelIndentation returns the amount, in pixels, of extra indentation for
// child levels in tree_view.
//
// The function returns the following values:
//
//    - gint: amount of extra indentation for child levels in tree_view. A return
//      value of 0 means that this feature is disabled.
//
func (treeView *TreeView) LevelIndentation() int {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_level_indentation", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Model returns the model the TreeView is based on. Returns NULL if the model
// is unset.
//
// The function returns the following values:
//
//    - treeModel (optional) or NULL if none is currently being used.
//
func (treeView *TreeView) Model() *TreeModel {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_model", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// NColumns queries the number of columns in the given tree_view.
//
// The function returns the following values:
//
//    - guint: number of columns in the tree_view.
//
func (treeView *TreeView) NColumns() uint {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.guint // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_n_columns", args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Reorderable retrieves whether the user can reorder the tree via
// drag-and-drop. See gtk_tree_view_set_reorderable().
//
// The function returns the following values:
//
//    - ok: TRUE if the tree can be reordered.
//
func (treeView *TreeView) Reorderable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_reorderable", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RubberBanding returns whether rubber banding is turned on for tree_view. If
// the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
//
// The function returns the following values:
//
//    - ok: TRUE if rubber banding in tree_view is enabled.
//
func (treeView *TreeView) RubberBanding() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_rubber_banding", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RulesHint gets the setting set by gtk_tree_view_set_rules_hint().
//
// Deprecated: since version 3.14.
//
// The function returns the following values:
//
//    - ok: TRUE if the hint is set.
//
func (treeView *TreeView) RulesHint() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_rules_hint", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SearchColumn gets the column searched on by the interactive search code.
//
// The function returns the following values:
//
//    - gint: column the interactive search code searches in.
//
func (treeView *TreeView) SearchColumn() int {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_search_column", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SearchEntry returns the Entry which is currently in use as interactive search
// entry for tree_view. In case the built-in entry is being used, NULL will be
// returned.
//
// The function returns the following values:
//
//    - entry currently in use as search entry.
//
func (treeView *TreeView) SearchEntry() *Entry {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_search_entry", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _entry *Entry // out

	_entry = wrapEntry(coreglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// Selection gets the TreeSelection associated with tree_view.
//
// The function returns the following values:
//
//    - treeSelection: TreeSelection object.
//
func (treeView *TreeView) Selection() *TreeSelection {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_selection", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _treeSelection *TreeSelection // out

	_treeSelection = wrapTreeSelection(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeSelection
}

// ShowExpanders returns whether or not expanders are drawn in tree_view.
//
// The function returns the following values:
//
//    - ok: TRUE if expanders are drawn in tree_view, FALSE otherwise.
//
func (treeView *TreeView) ShowExpanders() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_show_expanders", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TooltipColumn returns the column of tree_view’s model which is being used for
// displaying tooltips on tree_view’s rows.
//
// The function returns the following values:
//
//    - gint: index of the tooltip column that is currently being used, or -1 if
//      this is disabled.
//
func (treeView *TreeView) TooltipColumn() int {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_tooltip_column", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VAdjustment gets the Adjustment currently being used for the vertical aspect.
//
// Deprecated: Use gtk_scrollable_get_vadjustment().
//
// The function returns the following values:
//
//    - adjustment object, or NULL if none is currently being used.
//
func (treeView *TreeView) VAdjustment() *Adjustment {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_vadjustment", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// VisibleRange sets start_path and end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
//
// The paths should be freed with gtk_tree_path_free() after use.
//
// The function returns the following values:
//
//    - startPath (optional): return location for start of region, or NULL.
//    - endPath (optional): return location for end of region, or NULL.
//    - ok: TRUE, if valid paths were placed in start_path and end_path.
//
func (treeView *TreeView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
	var args [1]girepository.Argument
	var outs [2]girepository.Argument
	var _arg0 *C.void    // out
	var _out0 *C.void    // in
	var _out1 *C.void    // in
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("get_visible_range", args[:], outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _startPath *TreePath // out
	var _endPath *TreePath   // out
	var _ok bool             // out
	_out1 = *(**TreePath)(unsafe.Pointer(&outs[1]))

	if _out0 != nil {
		_startPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_out0)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_startPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _out1 != nil {
		_endPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_out1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_endPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// InsertColumn: this inserts the column into the tree_view at position. If
// position is -1, then the column is inserted at the end. If tree_view has
// “fixed_height” mode enabled, then column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
//
// The function takes the following parameters:
//
//    - column to be inserted.
//    - position to insert column in.
//
// The function returns the following values:
//
//    - gint: number of columns in tree_view after insertion.
//
func (treeView *TreeView) InsertColumn(column *TreeViewColumn, position int) int {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	_arg2 = C.gint(position)
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TreeViewColumn)(unsafe.Pointer(&args[2])) = _arg2

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("insert_column", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
	runtime.KeepAlive(position)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsRubberBandingActive returns whether a rubber banding operation is currently
// being done in tree_view.
//
// The function returns the following values:
//
//    - ok: TRUE if a rubber banding operation is currently being done in
//      tree_view.
//
func (treeView *TreeView) IsRubberBandingActive() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("is_rubber_banding_active", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveColumnAfter moves column to be after to base_column. If base_column is
// NULL, then column is placed in the first position.
//
// The function takes the following parameters:
//
//    - column to be moved.
//    - baseColumn (optional) to be moved relative to, or NULL.
//
func (treeView *TreeView) MoveColumnAfter(column, baseColumn *TreeViewColumn) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	if baseColumn != nil {
		_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(baseColumn).Native()))
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TreeViewColumn)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("move_column_after", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
	runtime.KeepAlive(baseColumn)
}

// RemoveColumn removes column from tree_view.
//
// The function takes the following parameters:
//
//    - column to remove.
//
// The function returns the following values:
//
//    - gint: number of columns in tree_view after removing.
//
func (treeView *TreeView) RemoveColumn(column *TreeViewColumn) int {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("remove_column", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RowActivated activates the cell determined by path and column.
//
// The function takes the following parameters:
//
//    - path to be activated.
//    - column to be activated.
//
func (treeView *TreeView) RowActivated(path *TreePath, column *TreeViewColumn) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TreePath)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("row_activated", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
}

// RowExpanded returns TRUE if the node pointed to by path is expanded in
// tree_view.
//
// The function takes the following parameters:
//
//    - path to test expansion state.
//
// The function returns the following values:
//
//    - ok: TRUE if #path is expanded.
//
func (treeView *TreeView) RowExpanded(path *TreePath) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TreeView").InvokeMethod("row_expanded", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToCell moves the alignments of tree_view to the position specified by
// column and path. If column is NULL, then no horizontal scrolling occurs.
// Likewise, if path is NULL no vertical scrolling occurs. At a minimum, one of
// column or path need to be non-NULL. row_align determines where the row is
// placed, and col_align determines where column is placed. Both are expected to
// be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom
// alignment, 0.5 means center.
//
// If use_align is FALSE, then the alignment arguments are ignored, and the tree
// does the minimum amount of work to scroll the cell onto the screen. This
// means that the cell will be scrolled to the edge closest to its current
// position. If the cell is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and path is a valid row on the
// model. If the model changes before the tree_view is realized, the centered
// path will be modified to reflect this change.
//
// The function takes the following parameters:
//
//    - path (optional) of the row to move to, or NULL.
//    - column (optional) to move horizontally to, or NULL.
//    - useAlign: whether to use alignment arguments, or FALSE.
//    - rowAlign: vertical alignment of the row specified by path.
//    - colAlign: horizontal alignment of the column specified by column.
//
func (treeView *TreeView) ScrollToCell(path *TreePath, column *TreeViewColumn, useAlign bool, rowAlign, colAlign float32) {
	var args [6]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 C.gboolean // out
	var _arg4 C.gfloat   // out
	var _arg5 C.gfloat   // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if path != nil {
		_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.gfloat(rowAlign)
	_arg5 = C.gfloat(colAlign)
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TreePath)(unsafe.Pointer(&args[2])) = _arg2
	*(**TreeViewColumn)(unsafe.Pointer(&args[3])) = _arg3
	*(*bool)(unsafe.Pointer(&args[4])) = _arg4
	*(*float32)(unsafe.Pointer(&args[5])) = _arg5

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("scroll_to_cell", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(rowAlign)
	runtime.KeepAlive(colAlign)
}

// ScrollToPoint scrolls the tree view such that the top-left corner of the
// visible area is tree_x, tree_y, where tree_x and tree_y are specified in tree
// coordinates. The tree_view must be realized before this function is called.
// If it isn't, you probably want to be using gtk_tree_view_scroll_to_cell().
//
// If either tree_x or tree_y are -1, then that direction isn’t scrolled.
//
// The function takes the following parameters:
//
//    - treeX: x coordinate of new top-left pixel of visible area, or -1.
//    - treeY: y coordinate of new top-left pixel of visible area, or -1.
//
func (treeView *TreeView) ScrollToPoint(treeX, treeY int) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.gint(treeX)
	_arg2 = C.gint(treeY)
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(*int)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("scroll_to_point", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(treeX)
	runtime.KeepAlive(treeY)
}

// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
// emitted on a single click instead of a double click.
//
// The function takes the following parameters:
//
//    - single: TRUE to emit row-activated on a single click.
//
func (treeView *TreeView) SetActivateOnSingleClick(single bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if single {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_activate_on_single_click", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(single)
}

// SetCursor sets the current keyboard focus to be at path, and selects it. This
// is useful when you want to focus the user’s attention on a particular row. If
// focus_column is not NULL, then focus is given to the column specified by it.
// Additionally, if focus_column is specified, and start_editing is TRUE, then
// editing should be started in the specified cell. This function is often
// followed by gtk_widget_grab_focus (tree_view) in order to give keyboard focus
// to the widget. Please note that editing can only happen when the widget is
// realized.
//
// If path is invalid for model, the current cursor (if any) will be unset and
// the function will return without failing.
//
// The function takes the following parameters:
//
//    - path: TreePath.
//    - focusColumn (optional) or NULL.
//    - startEditing: TRUE if the specified cell should start being edited.
//
func (treeView *TreeView) SetCursor(path *TreePath, focusColumn *TreeViewColumn, startEditing bool) {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	if focusColumn != nil {
		_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(focusColumn).Native()))
	}
	if startEditing {
		_arg3 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TreePath)(unsafe.Pointer(&args[2])) = _arg2
	*(**TreeViewColumn)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_cursor", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(focusColumn)
	runtime.KeepAlive(startEditing)
}

// SetCursorOnCell sets the current keyboard focus to be at path, and selects
// it. This is useful when you want to focus the user’s attention on a
// particular row. If focus_column is not NULL, then focus is given to the
// column specified by it. If focus_column and focus_cell are not NULL, and
// focus_column contains 2 or more editable or activatable cells, then focus is
// given to the cell specified by focus_cell. Additionally, if focus_column is
// specified, and start_editing is TRUE, then editing should be started in the
// specified cell. This function is often followed by gtk_widget_grab_focus
// (tree_view) in order to give keyboard focus to the widget. Please note that
// editing can only happen when the widget is realized.
//
// If path is invalid for model, the current cursor (if any) will be unset and
// the function will return without failing.
//
// The function takes the following parameters:
//
//    - path: TreePath.
//    - focusColumn (optional) or NULL.
//    - focusCell (optional) or NULL.
//    - startEditing: TRUE if the specified cell should start being edited.
//
func (treeView *TreeView) SetCursorOnCell(path *TreePath, focusColumn *TreeViewColumn, focusCell CellRendererer, startEditing bool) {
	var args [5]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 *C.void    // out
	var _arg4 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	if focusColumn != nil {
		_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(focusColumn).Native()))
	}
	if focusCell != nil {
		_arg3 = (*C.void)(unsafe.Pointer(coreglib.InternObject(focusCell).Native()))
	}
	if startEditing {
		_arg4 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**TreePath)(unsafe.Pointer(&args[2])) = _arg2
	*(**TreeViewColumn)(unsafe.Pointer(&args[3])) = _arg3
	*(*CellRendererer)(unsafe.Pointer(&args[4])) = _arg4

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_cursor_on_cell", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(focusColumn)
	runtime.KeepAlive(focusCell)
	runtime.KeepAlive(startEditing)
}

// SetEnableSearch: if enable_search is set, then the user can type in text to
// search through the tree interactively (this is sometimes called "typeahead
// find").
//
// Note that even if this is FALSE, the user can still initiate a search using
// the “start-interactive-search” key binding.
//
// The function takes the following parameters:
//
//    - enableSearch: TRUE, if the user can search interactively.
//
func (treeView *TreeView) SetEnableSearch(enableSearch bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enableSearch {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_enable_search", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enableSearch)
}

// SetEnableTreeLines sets whether to draw lines interconnecting the expanders
// in tree_view. This does not have any visible effects for lists.
//
// The function takes the following parameters:
//
//    - enabled: TRUE to enable tree line drawing, FALSE otherwise.
//
func (treeView *TreeView) SetEnableTreeLines(enabled bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enabled {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_enable_tree_lines", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enabled)
}

// SetExpanderColumn sets the column to draw the expander arrow at. It must be
// in tree_view. If column is NULL, then the expander arrow is always at the
// first visible column.
//
// If you do not want expander arrow to appear in your tree, set the expander
// column to a hidden column.
//
// The function takes the following parameters:
//
//    - column (optional): NULL, or the column to draw the expander arrow at.
//
func (treeView *TreeView) SetExpanderColumn(column *TreeViewColumn) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if column != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_expander_column", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetFixedHeightMode enables or disables the fixed height mode of tree_view.
// Fixed height mode speeds up TreeView by assuming that all rows have the same
// height. Only enable this option if all rows are the same height and all
// columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
//
// The function takes the following parameters:
//
//    - enable: TRUE to enable fixed height mode.
//
func (treeView *TreeView) SetFixedHeightMode(enable bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enable {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_fixed_height_mode", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enable)
}

// SetHAdjustment sets the Adjustment for the current horizontal aspect.
//
// Deprecated: Use gtk_scrollable_set_hadjustment().
//
// The function takes the following parameters:
//
//    - adjustment (optional) to set, or NULL.
//
func (treeView *TreeView) SetHAdjustment(adjustment *Adjustment) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if adjustment != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_hadjustment", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(adjustment)
}

// SetHeadersClickable: allow the column title buttons to be clicked.
//
// The function takes the following parameters:
//
//    - setting: TRUE if the columns are clickable.
//
func (treeView *TreeView) SetHeadersClickable(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_headers_clickable", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(setting)
}

// SetHeadersVisible sets the visibility state of the headers.
//
// The function takes the following parameters:
//
//    - headersVisible: TRUE if the headers are visible.
//
func (treeView *TreeView) SetHeadersVisible(headersVisible bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if headersVisible {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_headers_visible", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(headersVisible)
}

// SetHoverExpand enables or disables the hover expansion mode of tree_view.
// Hover expansion makes rows expand or collapse if the pointer moves over them.
//
// The function takes the following parameters:
//
//    - expand: TRUE to enable hover selection mode.
//
func (treeView *TreeView) SetHoverExpand(expand bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if expand {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_hover_expand", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(expand)
}

// SetHoverSelection enables or disables the hover selection mode of tree_view.
// Hover selection makes the selected row follow the pointer. Currently, this
// works only for the selection modes GTK_SELECTION_SINGLE and
// GTK_SELECTION_BROWSE.
//
// The function takes the following parameters:
//
//    - hover: TRUE to enable hover selection mode.
//
func (treeView *TreeView) SetHoverSelection(hover bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if hover {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_hover_selection", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(hover)
}

// SetLevelIndentation sets the amount of extra indentation for child levels to
// use in tree_view in addition to the default indentation. The value should be
// specified in pixels, a value of 0 disables this feature and in this case only
// the default indentation will be used. This does not have any visible effects
// for lists.
//
// The function takes the following parameters:
//
//    - indentation: amount, in pixels, of extra indentation in tree_view.
//
func (treeView *TreeView) SetLevelIndentation(indentation int) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.gint(indentation)
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_level_indentation", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(indentation)
}

// SetModel sets the model for a TreeView. If the tree_view already has a model
// set, it will remove it before setting the new model. If model is NULL, then
// it will unset the old model.
//
// The function takes the following parameters:
//
//    - model (optional): model.
//
func (treeView *TreeView) SetModel(model TreeModeller) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if model != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_model", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(model)
}

// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If reorderable
// is TRUE, then the user can reorder the model by dragging and dropping rows.
// The developer can listen to these changes by connecting to the model’s
// TreeModel::row-inserted and TreeModel::row-deleted signals. The reordering is
// implemented by setting up the tree view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any other
// purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
//
// The function takes the following parameters:
//
//    - reorderable: TRUE, if the tree can be reordered.
//
func (treeView *TreeView) SetReorderable(reorderable bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if reorderable {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_reorderable", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(reorderable)
}

// SetRubberBanding enables or disables rubber banding in tree_view. If the
// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the user to
// select multiple rows by dragging the mouse.
//
// The function takes the following parameters:
//
//    - enable: TRUE to enable rubber banding.
//
func (treeView *TreeView) SetRubberBanding(enable bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enable {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_rubber_banding", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enable)
}

// SetRulesHint sets a hint for the theme to draw even/odd rows in the tree_view
// with different colors, also known as "zebra striping".
//
// This function tells the GTK+ theme that the user interface for your
// application requires users to read across tree rows and associate cells with
// one another.
//
// Do not use it just because you prefer the appearance of the ruled tree;
// that’s a question for the theme. Some themes will draw tree rows in
// alternating colors even when rules are turned off, and users who prefer that
// appearance all the time can choose those themes. You should call this
// function only as a semantic hint to the theme engine that your tree makes
// alternating colors useful from a functional standpoint (since it has lots of
// columns, generally).
//
// Deprecated: since version 3.14.
//
// The function takes the following parameters:
//
//    - setting: TRUE if the tree requires reading across rows.
//
func (treeView *TreeView) SetRulesHint(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_rules_hint", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(setting)
}

// SetSearchColumn sets column as the column where the interactive search code
// should search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search” key
// binding to bring up search popup. The enable-search property controls whether
// simply typing text will also start an interactive search.
//
// Note that column refers to a column of the current model. The search column
// is reset to -1 when the model is changed.
//
// The function takes the following parameters:
//
//    - column of the model to search in, or -1 to disable searching.
//
func (treeView *TreeView) SetSearchColumn(column int) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.gint(column)
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_search_column", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetSearchEntry sets the entry which the interactive search code will use for
// this tree_view. This is useful when you want to provide a search entry in our
// interface at all time at a fixed position. Passing NULL for entry will make
// the interactive search code use the built-in popup entry again.
//
// The function takes the following parameters:
//
//    - entry (optional) the interactive search code of tree_view should use or
//      NULL.
//
func (treeView *TreeView) SetSearchEntry(entry *Entry) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if entry != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_search_entry", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(entry)
}

// SetShowExpanders sets whether to draw and enable expanders and indent child
// rows in tree_view. When disabled there will be no expanders visible in trees
// and there will be no way to expand and collapse rows by default. Also note
// that hiding the expanders will disable the default indentation. You can set a
// custom indentation in this case using gtk_tree_view_set_level_indentation().
// This does not have any visible effects for lists.
//
// The function takes the following parameters:
//
//    - enabled: TRUE to enable expander drawing, FALSE otherwise.
//
func (treeView *TreeView) SetShowExpanders(enabled bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enabled {
		_arg1 = C.TRUE
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_show_expanders", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enabled)
}

// SetTooltipCell sets the tip area of tooltip to the area path, column and cell
// have in common. For example if path is NULL and column is set, the tip area
// will be set to the full area covered by column. See also
// gtk_tooltip_set_tip_area().
//
// Note that if path is not specified and cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the correct
// position. In such cases path must be set to the current node under the mouse
// cursor for this function to operate correctly.
//
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
//
// The function takes the following parameters:
//
//    - tooltip: Tooltip.
//    - path (optional) or NULL.
//    - column (optional) or NULL.
//    - cell (optional) or NULL.
//
func (treeView *TreeView) SetTooltipCell(tooltip *Tooltip, path *TreePath, column *TreeViewColumn, cell CellRendererer) {
	var args [5]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 *C.void // out
	var _arg4 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	if path != nil {
		_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg3 = (*C.void)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}
	if cell != nil {
		_arg4 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**Tooltip)(unsafe.Pointer(&args[2])) = _arg2
	*(**TreePath)(unsafe.Pointer(&args[3])) = _arg3
	*(**TreeViewColumn)(unsafe.Pointer(&args[4])) = _arg4

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_tooltip_cell", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
	runtime.KeepAlive(cell)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full rows, you can use this function to have TreeView handle these
// automatically for you. column should be set to the column in tree_view’s
// model containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, Widget:has-tooltip will be set to TRUE and tree_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(), so
// &, <, etc have to be escaped in the text.
//
// The function takes the following parameters:
//
//    - column: integer, which is a valid column number for tree_view’s model.
//
func (treeView *TreeView) SetTooltipColumn(column int) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.gint(column)
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_tooltip_column", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetTooltipRow sets the tip area of tooltip to be the area covered by the row
// at path. See also gtk_tree_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
//
// The function takes the following parameters:
//
//    - tooltip: Tooltip.
//    - path: TreePath.
//
func (treeView *TreeView) SetTooltipRow(tooltip *Tooltip, path *TreePath) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1
	*(**Tooltip)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_tooltip_row", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
}

// SetVAdjustment sets the Adjustment for the current vertical aspect.
//
// Deprecated: Use gtk_scrollable_set_vadjustment().
//
// The function takes the following parameters:
//
//    - adjustment (optional) to set, or NULL.
//
func (treeView *TreeView) SetVAdjustment(adjustment *Adjustment) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if adjustment != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}
	*(**TreeView)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("set_vadjustment", args[:], nil)

	runtime.KeepAlive(treeView)
	runtime.KeepAlive(adjustment)
}

// UnsetRowsDragDest undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// TreeView:reorderable to FALSE.
func (treeView *TreeView) UnsetRowsDragDest() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("unset_rows_drag_dest", args[:], nil)

	runtime.KeepAlive(treeView)
}

// UnsetRowsDragSource undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// TreeView:reorderable to FALSE.
func (treeView *TreeView) UnsetRowsDragSource() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	*(**TreeView)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TreeView").InvokeMethod("unset_rows_drag_source", args[:], nil)

	runtime.KeepAlive(treeView)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// gboolean _gotk4_gtk3_Widget_virtual_keynav_failed(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   return ((gboolean (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
import "C"

// ErrorBell notifies the user about an input-related error on this widget. If
// the Settings:gtk-error-bell setting is TRUE, it calls gdk_window_beep(),
// otherwise it does nothing.
//
// Note that the effect of gdk_window_beep() can be configured in many ways,
// depending on the windowing backend and the desktop environment or window
// manager that is used.
func (widget *Widget) ErrorBell() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_error_bell(_arg0)
	runtime.KeepAlive(widget)
}

// HasTooltip returns the current value of the has-tooltip property. See
// Widget:has-tooltip for more information.
//
// The function returns the following values:
//
//    - ok: current value of has-tooltip on widget.
//
func (widget *Widget) HasTooltip() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_has_tooltip(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TooltipMarkup gets the contents of the tooltip for widget.
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip text, or NULL. You should free the returned
//      string with g_free() when done.
//
func (widget *Widget) TooltipMarkup() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_markup(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// TooltipText gets the contents of the tooltip for widget.
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip text, or NULL. You should free the returned
//      string with g_free() when done.
//
func (widget *Widget) TooltipText() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_text(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// TooltipWindow returns the Window of the current tooltip. This can be the
// GtkWindow created by default, or the custom tooltip window set using
// gtk_widget_set_tooltip_window().
//
// The function returns the following values:
//
//    - window of the current tooltip.
//
func (widget *Widget) TooltipWindow() *Window {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_window(_arg0)
	runtime.KeepAlive(widget)

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))

	return _window
}

// KeynavFailed: this function should be called whenever keyboard navigation
// within a single widget hits a boundary. The function emits the
// Widget::keynav-failed signal on the widget and its return value should be
// interpreted in a way similar to the return value of gtk_widget_child_focus():
//
// When TRUE is returned, stay in the widget, the failed keyboard navigation is
// OK and/or there is nowhere we can/should move the focus to.
//
// When FALSE is returned, the caller should continue with keyboard navigation
// outside the widget, e.g. by calling gtk_widget_child_focus() on the widget’s
// toplevel.
//
// The default ::keynav-failed handler returns FALSE for GTK_DIR_TAB_FORWARD and
// GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it returns TRUE.
//
// Whenever the default handler returns TRUE, it also calls
// gtk_widget_error_bell() to notify the user of the failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either by
// connecting to it or by overriding it) would be a row of Entry widgets where
// the user should be able to navigate the entire row with the cursor keys, as
// e.g. known from user interfaces that require entering license keys.
//
// The function takes the following parameters:
//
//    - direction of focus movement.
//
// The function returns the following values:
//
//    - ok: TRUE if stopping keyboard navigation is fine, FALSE if the emitting
//      widget should try to handle the keyboard navigation attempt in its parent
//      container(s).
//
func (widget *Widget) KeynavFailed(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_widget_keynav_failed(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetHasTooltip sets the has-tooltip property on widget to has_tooltip. See
// Widget:has-tooltip for more information.
//
// The function takes the following parameters:
//
//    - hasTooltip: whether or not widget has a tooltip.
//
func (widget *Widget) SetHasTooltip(hasTooltip bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if hasTooltip {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_tooltip(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(hasTooltip)
}

// SetTooltipMarkup sets markup as the contents of the tooltip, which is marked
// up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting Widget:has-tooltip to TRUE and of the
// default handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
//
// The function takes the following parameters:
//
//    - markup (optional) contents of the tooltip for widget, or NULL.
//
func (widget *Widget) SetTooltipMarkup(markup string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if markup != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(markup)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_tooltip_markup(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(markup)
}

// SetTooltipText sets text as the contents of the tooltip. This function will
// take care of setting Widget:has-tooltip to TRUE and of the default handler
// for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
//
// The function takes the following parameters:
//
//    - text (optional) contents of the tooltip for widget.
//
func (widget *Widget) SetTooltipText(text string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if text != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_tooltip_text(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(text)
}

// SetTooltipWindow replaces the default window used for displaying tooltips
// with custom_window. GTK+ will take care of showing and hiding custom_window
// at the right moment, to behave likewise as the default tooltip window. If
// custom_window is NULL, the default tooltip window will be used.
//
// The function takes the following parameters:
//
//    - customWindow (optional) or NULL.
//
func (widget *Widget) SetTooltipWindow(customWindow *Window) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if customWindow != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(customWindow).Native()))
	}

	C.gtk_widget_set_tooltip_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(customWindow)
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of widget is located. See gtk_tooltip_trigger_tooltip_query() for
// more information.
func (widget *Widget) TriggerTooltipQuery() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_trigger_tooltip_query(_arg0)
	runtime.KeepAlive(widget)
}

// keynavFailed: this function should be called whenever keyboard navigation
// within a single widget hits a boundary. The function emits the
// Widget::keynav-failed signal on the widget and its return value should be
// interpreted in a way similar to the return value of gtk_widget_child_focus():
//
// When TRUE is returned, stay in the widget, the failed keyboard navigation is
// OK and/or there is nowhere we can/should move the focus to.
//
// When FALSE is returned, the caller should continue with keyboard navigation
// outside the widget, e.g. by calling gtk_widget_child_focus() on the widget’s
// toplevel.
//
// The default ::keynav-failed handler returns FALSE for GTK_DIR_TAB_FORWARD and
// GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it returns TRUE.
//
// Whenever the default handler returns TRUE, it also calls
// gtk_widget_error_bell() to notify the user of the failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either by
// connecting to it or by overriding it) would be a row of Entry widgets where
// the user should be able to navigate the entire row with the cursor keys, as
// e.g. known from user interfaces that require entering license keys.
//
// The function takes the following parameters:
//
//    - direction of focus movement.
//
// The function returns the following values:
//
//    - ok: TRUE if stopping keyboard navigation is fine, FALSE if the emitting
//      widget should try to handle the keyboard navigation attempt in its parent
//      container(s).
//
func (widget *Widget) keynavFailed(direction DirectionType) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.keynav_failed

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C._gotk4_gtk3_Widget_virtual_keynav_failed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gtkimage.go.
var (
	GTypeImageType = coreglib.Type(C.gtk_image_type_get_type())
	GTypeImage     = coreglib.Type(C.gtk_image_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeImageType, F: marshalImageType},
		{T: GTypeImage, F: marshalImage},
	})
}

// ImageType describes the image data representation used by a Image. If you
// want to get the image from the widget, you can only get the currently-stored
// representation. e.g. if the gtk_image_get_storage_type() returns
// K_IMAGE_PIXBUF, then you can call gtk_image_get_pixbuf() but not
// gtk_image_get_stock(). For empty images, you can request any storage type
// (call any of the "get" functions), but they will all return NULL values.
type ImageType C.gint

const (
	// ImageEmpty: there is no image displayed by the widget.
	ImageEmpty ImageType = iota
	// ImagePixbuf: widget contains a Pixbuf.
	ImagePixbuf
	// ImageStock: widget contains a [stock item name][gtkstock].
	ImageStock
	// ImageIconSet: widget contains a IconSet.
	ImageIconSet
	// ImageAnimation: widget contains a PixbufAnimation.
	ImageAnimation
	// ImageIconName: widget contains a named icon. This image type was added in
	// GTK+ 2.6.
	ImageIconName
	// ImageGIcon: widget contains a #GIcon. This image type was added in GTK+
	// 2.14.
	ImageGIcon
	// ImageSurface: widget contains a #cairo_surface_t. This image type was
	// added in GTK+ 3.10.
	ImageSurface
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ImageType.
func (i ImageType) String() string {
	switch i {
	case ImageEmpty:
		return "Empty"
	case ImagePixbuf:
		return "Pixbuf"
	case ImageStock:
		return "Stock"
	case ImageIconSet:
		return "IconSet"
	case ImageAnimation:
		return "Animation"
	case ImageIconName:
		return "IconName"
	case ImageGIcon:
		return "GIcon"
	case ImageSurface:
		return "Surface"
	default:
		return fmt.Sprintf("ImageType(%d)", i)
	}
}

// ImageOverrider contains methods that are overridable.
type ImageOverrider interface {
}

// Image widget displays an image. Various kinds of object can be displayed as
// an image; most typically, you would load a Pixbuf ("pixel buffer") from a
// file, and then display that. There’s a convenience function to do this,
// gtk_image_new_from_file(), used as follows:
//
//      static gboolean
//      button_press_callback (GtkWidget      *event_box,
//                             GdkEventButton *event,
//                             gpointer        data)
//      {
//        g_print ("Event box clicked at coordinates f,f\n",
//                 event->x, event->y);
//
//        // Returning TRUE means we handled the event, so the signal
//        // emission should be stopped (don’t call any further callbacks
//        // that may be connected). Return FALSE to continue invoking callbacks.
//        return TRUE;
//      }
//
//      static GtkWidget*
//      create_image (void)
//      {
//        GtkWidget *image;
//        GtkWidget *event_box;
//
//        image = gtk_image_new_from_file ("myfile.png");
//
//        event_box = gtk_event_box_new ();
//
//        gtk_container_add (GTK_CONTAINER (event_box), image);
//
//        g_signal_connect (G_OBJECT (event_box),
//                          "button_press_event",
//                          G_CALLBACK (button_press_callback),
//                          image);
//
//        return image;
//      }
//
// When handling events on the event box, keep in mind that coordinates in the
// image may be different from event box coordinates due to the alignment and
// padding settings on the image (see Misc). The simplest way to solve this is
// to set the alignment to 0.0 (left/top), and set the padding to zero. Then the
// origin of the image will be the same as the origin of the event box.
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. GTK+ comes with a program to avoid this, called
// “gdk-pixbuf-csource”. This library allows you to convert an image into a C
// variable declaration, which can then be loaded into a Pixbuf using
// gdk_pixbuf_new_from_inline().
//
//
// CSS nodes
//
// GtkImage has a single CSS node with the name image. The style classes may
// appear on image CSS nodes: .icon-dropshadow, .lowres-icon.
type Image struct {
	_ [0]func() // equal guard
	Misc
}

var (
	_ Miscer = (*Image)(nil)
)

func classInitImager(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapImage(obj *coreglib.Object) *Image {
	return &Image{
		Misc: Misc{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalImage(p uintptr) (interface{}, error) {
	return wrapImage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewImage creates a new empty Image widget.
//
// The function returns the following values:
//
//    - image: newly created Image widget.
//
func NewImage() *Image {
	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("new_Image", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromAnimation creates a Image displaying the given animation. The
// Image does not assume a reference to the animation; you still need to unref
// it if you own references. Image will add its own reference rather than
// adopting yours.
//
// Note that the animation frames are shown using a timeout with
// PRIORITY_DEFAULT. When using animations to indicate busyness, keep in mind
// that the animation will only be shown if the main loop is not busy with
// something that has a higher priority.
//
// The function takes the following parameters:
//
//    - animation: animation.
//
// The function returns the following values:
//
//    - image: new Image widget.
//
func NewImageFromAnimation(animation *gdkpixbuf.PixbufAnimation) *Image {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(animation).Native()))

	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("new_Image_from_animation", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(animation)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromFile creates a new Image displaying the file filename. If the
// file isn’t found or can’t be loaded, the resulting Image will display a
// “broken image” icon. This function never returns NULL, it always returns a
// valid Image widget.
//
// If the file contains an animation, the image will contain an animation.
//
// If you need to detect failures to load the file, use
// gdk_pixbuf_new_from_file() to load the file yourself, then create the Image
// from the pixbuf. (Or for animations, use
// gdk_pixbuf_animation_new_from_file()).
//
// The storage type (gtk_image_get_storage_type()) of the returned image is not
// defined, it will be whatever is appropriate for displaying the file.
//
// The function takes the following parameters:
//
//    - filename: filename.
//
// The function returns the following values:
//
//    - image: new Image.
//
func NewImageFromFile(filename string) *Image {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("new_Image_from_file", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(filename)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromPixbuf creates a new Image displaying pixbuf. The Image does not
// assume a reference to the pixbuf; you still need to unref it if you own
// references. Image will add its own reference rather than adopting yours.
//
// Note that this function just creates an Image from the pixbuf. The Image
// created will not react to state changes. Should you want that, you should use
// gtk_image_new_from_icon_name().
//
// The function takes the following parameters:
//
//    - pixbuf (optional) or NULL.
//
// The function returns the following values:
//
//    - image: new Image.
//
func NewImageFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *Image {
	var _args [1]girepository.Argument

	if pixbuf != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	}

	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("new_Image_from_pixbuf", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(pixbuf)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromResource creates a new Image displaying the resource file
// resource_path. If the file isn’t found or can’t be loaded, the resulting
// Image will display a “broken image” icon. This function never returns NULL,
// it always returns a valid Image widget.
//
// If the file contains an animation, the image will contain an animation.
//
// If you need to detect failures to load the file, use
// gdk_pixbuf_new_from_file() to load the file yourself, then create the Image
// from the pixbuf. (Or for animations, use
// gdk_pixbuf_animation_new_from_file()).
//
// The storage type (gtk_image_get_storage_type()) of the returned image is not
// defined, it will be whatever is appropriate for displaying the file.
//
// The function takes the following parameters:
//
//    - resourcePath: resource path.
//
// The function returns the following values:
//
//    - image: new Image.
//
func NewImageFromResource(resourcePath string) *Image {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("new_Image_from_resource", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(resourcePath)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromSurface creates a new Image displaying surface. The Image does
// not assume a reference to the surface; you still need to unref it if you own
// references. Image will add its own reference rather than adopting yours.
//
// The function takes the following parameters:
//
//    - surface (optional) or NULL.
//
// The function returns the following values:
//
//    - image: new Image.
//
func NewImageFromSurface(surface *cairo.Surface) *Image {
	var _args [1]girepository.Argument

	if surface != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(surface.Native()))
	}

	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("new_Image_from_surface", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(surface)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// Clear resets the image to be empty.
func (image *Image) Clear() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	girepository.MustFind("Gtk", "Image").InvokeMethod("clear", _args[:], nil)

	runtime.KeepAlive(image)
}

// Animation gets the PixbufAnimation being displayed by the Image. The storage
// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ANIMATION (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned animation.
//
// The function returns the following values:
//
//    - pixbufAnimation (optional): displayed animation, or NULL if the image is
//      empty.
//
func (image *Image) Animation() *gdkpixbuf.PixbufAnimation {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("get_animation", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(image)

	var _pixbufAnimation *gdkpixbuf.PixbufAnimation // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_pixbufAnimation = &gdkpixbuf.PixbufAnimation{
				Object: obj,
			}
		}
	}

	return _pixbufAnimation
}

// GIcon gets the #GIcon and size being displayed by the Image. The storage type
// of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned #GIcon.
//
// The function returns the following values:
//
//    - gicon (optional): place to store a #GIcon, or NULL.
//    - size (optional): place to store an icon size (IconSize), or NULL.
//
func (image *Image) GIcon() (*gio.Icon, int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	girepository.MustFind("Gtk", "Image").InvokeMethod("get_gicon", _args[:], _outs[:])

	runtime.KeepAlive(image)

	var _gicon *gio.Icon // out
	var _size int32      // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_outs[0]))
			_gicon = &gio.Icon{
				Object: obj,
			}
		}
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_size = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _gicon, _size
}

// IconName gets the icon name and size being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME (see
// gtk_image_get_storage_type()). The returned string is owned by the Image and
// should not be freed.
//
// The function returns the following values:
//
//    - iconName (optional): place to store an icon name, or NULL.
//    - size (optional): place to store an icon size (IconSize), or NULL.
//
func (image *Image) IconName() (string, int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	girepository.MustFind("Gtk", "Image").InvokeMethod("get_icon_name", _args[:], _outs[:])

	runtime.KeepAlive(image)

	var _iconName string // out
	var _size int32      // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_iconName = C.GoString((*C.gchar)(unsafe.Pointer(_outs[0])))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_size = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _iconName, _size
}

// IconSet gets the icon set and size being displayed by the Image. The storage
// type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_SET (see
// gtk_image_get_storage_type()).
//
// Deprecated: Use gtk_image_get_icon_name() instead.
//
// The function returns the following values:
//
//    - iconSet (optional): location to store a IconSet, or NULL.
//    - size (optional): location to store a stock icon size (IconSize), or NULL.
//
func (image *Image) IconSet() (*IconSet, int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	girepository.MustFind("Gtk", "Image").InvokeMethod("get_icon_set", _args[:], _outs[:])

	runtime.KeepAlive(image)

	var _iconSet *IconSet // out
	var _size int32       // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
		C.gtk_icon_set_ref(_outs[0])
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iconSet)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_size = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _iconSet, _size
}

// Pixbuf gets the Pixbuf being displayed by the Image. The storage type of the
// image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
// gtk_image_get_storage_type()). The caller of this function does not own a
// reference to the returned pixbuf.
//
// The function returns the following values:
//
//    - pixbuf (optional): displayed pixbuf, or NULL if the image is empty.
//
func (image *Image) Pixbuf() *gdkpixbuf.Pixbuf {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("get_pixbuf", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(image)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// PixelSize gets the pixel size used for named icons.
//
// The function returns the following values:
//
//    - gint: pixel size used for named icons.
//
func (image *Image) PixelSize() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_gret := girepository.MustFind("Gtk", "Image").InvokeMethod("get_pixel_size", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(image)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Stock gets the stock icon name and size being displayed by the Image. The
// storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_STOCK (see
// gtk_image_get_storage_type()). The returned string is owned by the Image and
// should not be freed.
//
// Deprecated: Use gtk_image_get_icon_name() instead.
//
// The function returns the following values:
//
//    - stockId (optional): place to store a stock icon name, or NULL.
//    - size (optional): place to store a stock icon size (IconSize), or NULL.
//
func (image *Image) Stock() (string, int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	girepository.MustFind("Gtk", "Image").InvokeMethod("get_stock", _args[:], _outs[:])

	runtime.KeepAlive(image)

	var _stockId string // out
	var _size int32     // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_stockId = C.GoString((*C.gchar)(unsafe.Pointer(_outs[0])))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_size = *(*int32)(unsafe.Pointer(_outs[1]))
	}

	return _stockId, _size
}

// SetFromAnimation causes the Image to display the given animation (or display
// nothing, if you set the animation to NULL).
//
// The function takes the following parameters:
//
//    - animation: PixbufAnimation.
//
func (image *Image) SetFromAnimation(animation *gdkpixbuf.PixbufAnimation) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(animation).Native()))

	girepository.MustFind("Gtk", "Image").InvokeMethod("set_from_animation", _args[:], nil)

	runtime.KeepAlive(image)
	runtime.KeepAlive(animation)
}

// SetFromFile: see gtk_image_new_from_file() for details.
//
// The function takes the following parameters:
//
//    - filename (optional) or NULL.
//
func (image *Image) SetFromFile(filename string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if filename != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_args[1]))
	}

	girepository.MustFind("Gtk", "Image").InvokeMethod("set_from_file", _args[:], nil)

	runtime.KeepAlive(image)
	runtime.KeepAlive(filename)
}

// SetFromPixbuf: see gtk_image_new_from_pixbuf() for details.
//
// The function takes the following parameters:
//
//    - pixbuf (optional) or NULL.
//
func (image *Image) SetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if pixbuf != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	}

	girepository.MustFind("Gtk", "Image").InvokeMethod("set_from_pixbuf", _args[:], nil)

	runtime.KeepAlive(image)
	runtime.KeepAlive(pixbuf)
}

// SetFromResource: see gtk_image_new_from_resource() for details.
//
// The function takes the following parameters:
//
//    - resourcePath (optional): resource path or NULL.
//
func (image *Image) SetFromResource(resourcePath string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if resourcePath != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_args[1]))
	}

	girepository.MustFind("Gtk", "Image").InvokeMethod("set_from_resource", _args[:], nil)

	runtime.KeepAlive(image)
	runtime.KeepAlive(resourcePath)
}

// SetFromSurface: see gtk_image_new_from_surface() for details.
//
// The function takes the following parameters:
//
//    - surface (optional): cairo_surface_t or NULL.
//
func (image *Image) SetFromSurface(surface *cairo.Surface) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if surface != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(surface.Native()))
	}

	girepository.MustFind("Gtk", "Image").InvokeMethod("set_from_surface", _args[:], nil)

	runtime.KeepAlive(image)
	runtime.KeepAlive(surface)
}

// SetPixelSize sets the pixel size to use for named icons. If the pixel size is
// set to a value != -1, it is used instead of the icon size set by
// gtk_image_set_from_icon_name().
//
// The function takes the following parameters:
//
//    - pixelSize: new pixel size.
//
func (image *Image) SetPixelSize(pixelSize int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(pixelSize)

	girepository.MustFind("Gtk", "Image").InvokeMethod("set_pixel_size", _args[:], nil)

	runtime.KeepAlive(image)
	runtime.KeepAlive(pixelSize)
}

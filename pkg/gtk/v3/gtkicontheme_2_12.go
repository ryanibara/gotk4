// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// ChooseIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon()
// combines these two steps if all you need is the pixbuf.)
//
// If icon_names contains more than one name, this function tries them all in
// the given order before falling back to inherited icon themes.
//
// The function takes the following parameters:
//
//    - iconNames: NULL-terminated array of icon names to lookup.
//    - size: desired icon size.
//    - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//    - iconInfo (optional) object containing information about the icon, or NULL
//      if the icon wasnâ€™t found.
//
func (iconTheme *IconTheme) ChooseIcon(iconNames []string, size int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 **C.gchar            // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(iconNames) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(iconNames)+1)
			var zero *C.gchar
			out[len(iconNames)] = zero
			for i := range iconNames {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(iconNames[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_choose_icon(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconNames)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var _iconInfo *IconInfo // out

	if _cret != nil {
		_iconInfo = wrapIconInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _iconInfo
}

// ListContexts gets the list of contexts available within the current hierarchy
// of icon themes. See gtk_icon_theme_list_icons() for details about contexts.
//
// The function returns the following values:
//
//    - list list holding the names of all the contexts in the theme. You must
//      first free each element in the list with g_free(), then free the list
//      itself with g_list_free().
//
func (iconTheme *IconTheme) ListContexts() []string {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.GList        // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))

	_cret = C.gtk_icon_theme_list_contexts(_arg0)
	runtime.KeepAlive(iconTheme)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

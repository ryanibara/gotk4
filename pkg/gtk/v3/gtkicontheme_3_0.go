// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// LoadSymbolic loads an icon, modifying it to match the system colours for the
// foreground, success, warning and error colors provided. If the icon is not a
// symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// Unless you are implementing a widget, you will want to use
// g_themed_icon_new_with_default_fallbacks() to load the icon.
//
// As implementation details, the icon loaded needs to be of SVG type, contain
// the “symbolic” term as the last component of the icon name, and use the “fg”,
// “success”, “warning” and “error” CSS styles in the SVG file itself.
//
// See the Symbolic Icons Specification
// (http://www.freedesktop.org/wiki/SymbolicIcons) for more information about
// symbolic icons.
//
// The function takes the following parameters:
//
//    - fg representing the foreground color of the icon.
//    - successColor (optional) representing the warning color of the icon or
//      NULL to use the default color.
//    - warningColor (optional) representing the warning color of the icon or
//      NULL to use the default color.
//    - errorColor (optional) representing the error color of the icon or NULL to
//      use the default color (allow-none).
//
// The function returns the following values:
//
//    - wasSymbolic (optional) returns whether the loaded icon was a symbolic one
//      and whether the fg color was applied to it.
//    - pixbuf representing the loaded icon.
//
func (iconInfo *IconInfo) LoadSymbolic(fg, successColor, warningColor, errorColor *gdk.RGBA) (bool, *gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GdkRGBA     // out
	var _arg2 *C.GdkRGBA     // out
	var _arg3 *C.GdkRGBA     // out
	var _arg4 *C.GdkRGBA     // out
	var _arg5 C.gboolean     // in
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(fg)))
	if successColor != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(successColor)))
	}
	if warningColor != nil {
		_arg3 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(warningColor)))
	}
	if errorColor != nil {
		_arg4 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(errorColor)))
	}

	_cret = C.gtk_icon_info_load_symbolic(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_cerr)
	runtime.KeepAlive(iconInfo)
	runtime.KeepAlive(fg)
	runtime.KeepAlive(successColor)
	runtime.KeepAlive(warningColor)
	runtime.KeepAlive(errorColor)

	var _wasSymbolic bool         // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _arg5 != 0 {
		_wasSymbolic = true
	}
	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicForContext loads an icon, modifying it to match the system colors
// for the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon(). This function uses the regular foreground color
// and the symbolic colors with the names “success_color”, “warning_color” and
// “error_color” from the context.
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
//
// The function takes the following parameters:
//
//    - context: StyleContext.
//
// The function returns the following values:
//
//    - wasSymbolic (optional) returns whether the loaded icon was a symbolic one
//      and whether the fg color was applied to it.
//    - pixbuf representing the loaded icon.
//
func (iconInfo *IconInfo) LoadSymbolicForContext(context *StyleContext) (bool, *gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.gboolean         // in
	var _cret *C.GdkPixbuf       // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_icon_info_load_symbolic_for_context(_arg0, _arg1, &_arg2, &_cerr)
	runtime.KeepAlive(iconInfo)
	runtime.KeepAlive(context)

	var _wasSymbolic bool         // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _arg2 != 0 {
		_wasSymbolic = true
	}
	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _wasSymbolic, _pixbuf, _goerr
}

// LoadSymbolicForStyle loads an icon, modifying it to match the system colours
// for the foreground, success, warning and error colors provided. If the icon
// is not a symbolic one, the function will return the result from
// gtk_icon_info_load_icon().
//
// This allows loading symbolic icons that will match the system theme.
//
// See gtk_icon_info_load_symbolic() for more details.
//
// Deprecated: Use gtk_icon_info_load_symbolic_for_context() instead.
//
// The function takes the following parameters:
//
//    - style to take the colors from.
//    - state: widget state to use for colors.
//
// The function returns the following values:
//
//    - wasSymbolic (optional) returns whether the loaded icon was a symbolic one
//      and whether the fg color was applied to it.
//    - pixbuf representing the loaded icon.
//
func (iconInfo *IconInfo) LoadSymbolicForStyle(style *Style, state StateType) (bool, *gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GtkStyle    // out
	var _arg2 C.GtkStateType // out
	var _arg3 C.gboolean     // in
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	_arg1 = (*C.GtkStyle)(unsafe.Pointer(coreglib.InternObject(style).Native()))
	_arg2 = C.GtkStateType(state)

	_cret = C.gtk_icon_info_load_symbolic_for_style(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(iconInfo)
	runtime.KeepAlive(style)
	runtime.KeepAlive(state)

	var _wasSymbolic bool         // out
	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _arg3 != 0 {
		_wasSymbolic = true
	}
	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _wasSymbolic, _pixbuf, _goerr
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// Allocation retrieves the widget’s allocation.
//
// Note, when implementing a Container: a widget’s allocation will be its
// “adjusted” allocation, that is, the widget’s parent container typically calls
// gtk_widget_size_allocate() with an allocation, and that allocation is then
// adjusted (to handle margin and alignment for example) before assignment to
// the widget. gtk_widget_get_allocation() returns the adjusted allocation that
// was actually assigned to the widget. The adjusted allocation is guaranteed to
// be completely contained within the gtk_widget_size_allocate() allocation,
// however. So a Container is guaranteed that its children stay inside the
// assigned bounds, but not that they have exactly the bounds the container
// assigned. There is no way to get the original allocation assigned by
// gtk_widget_size_allocate(), since it isn’t stored; if a container
// implementation needs that information it will have to track it itself.
//
// The function returns the following values:
//
//    - allocation: pointer to a Allocation to copy to.
//
func (widget *Widget) Allocation() *Allocation {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkAllocation // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_allocation(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _allocation
}

// AppPaintable determines whether the application intends to draw on the widget
// in an Widget::draw handler.
//
// See gtk_widget_set_app_paintable().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is app paintable.
//
func (widget *Widget) AppPaintable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_app_paintable(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanDefault determines whether widget can be a default widget. See
// gtk_widget_set_can_default().
//
// The function returns the following values:
//
//    - ok: TRUE if widget can be a default widget, FALSE otherwise.
//
func (widget *Widget) CanDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_can_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanFocus determines whether widget can own the input focus. See
// gtk_widget_set_can_focus().
//
// The function returns the following values:
//
//    - ok: TRUE if widget can own the input focus, FALSE otherwise.
//
func (widget *Widget) CanFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_can_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DoubleBuffered determines whether the widget is double buffered.
//
// See gtk_widget_set_double_buffered().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is double buffered.
//
func (widget *Widget) DoubleBuffered() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_double_buffered(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasWindow determines whether widget has a Window of its own. See
// gtk_widget_set_has_window().
//
// The function returns the following values:
//
//    - ok: TRUE if widget has a window, FALSE otherwise.
//
func (widget *Widget) HasWindow() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_has_window(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReceivesDefault determines whether widget is always treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// See gtk_widget_set_receives_default().
//
// The function returns the following values:
//
//    - ok: TRUE if widget acts as the default widget when focused, FALSE
//      otherwise.
//
func (widget *Widget) ReceivesDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_receives_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Sensitive returns the widget’s sensitivity (in the sense of returning the
// value that has been set using gtk_widget_set_sensitive()).
//
// The effective sensitivity of a widget is however determined by both its own
// and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is sensitive.
//
func (widget *Widget) Sensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_sensitive(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// State returns the widget’s state. See gtk_widget_set_state().
//
// Deprecated: Use gtk_widget_get_state_flags() instead.
//
// The function returns the following values:
//
//    - stateType: state of widget.
//
func (widget *Widget) State() StateType {
	var _arg0 *C.GtkWidget   // out
	var _cret C.GtkStateType // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_state(_arg0)
	runtime.KeepAlive(widget)

	var _stateType StateType // out

	_stateType = StateType(_cret)

	return _stateType
}

// Visible determines whether the widget is visible. If you want to take into
// account whether the widget’s parent is also marked as visible, use
// gtk_widget_is_visible() instead.
//
// This function does not check if the widget is obscured in any way.
//
// See gtk_widget_set_visible().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is visible.
//
func (widget *Widget) Visible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasDefault determines whether widget is the current default widget within its
// toplevel. See gtk_widget_set_can_default().
//
// The function returns the following values:
//
//    - ok: TRUE if widget is the current default widget within its toplevel,
//      FALSE otherwise.
//
func (widget *Widget) HasDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasFocus determines if the widget has the global input focus. See
// gtk_widget_is_focus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget has the global input focus.
//
func (widget *Widget) HasFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasGrab determines whether the widget is currently grabbing events, so it is
// the only widget receiving input events (keyboard and mouse).
//
// See also gtk_grab_add().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is in the grab_widgets stack.
//
func (widget *Widget) HasGrab() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_grab(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDrawable determines whether widget can be drawn to. A widget can be drawn
// to if it is mapped and visible.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is drawable, FALSE otherwise.
//
func (widget *Widget) IsDrawable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_drawable(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSensitive returns the widget’s effective sensitivity, which means it is
// sensitive itself and also its parent widget is sensitive.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is effectively sensitive.
//
func (widget *Widget) IsSensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_sensitive(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsToplevel determines whether widget is a toplevel widget.
//
// Currently only Window and Invisible (and out-of-process Plugs) are toplevel
// widgets. Toplevel widgets have no parent widget.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is a toplevel, FALSE otherwise.
//
func (widget *Widget) IsToplevel() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_toplevel(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAllocation sets the widget’s allocation. This should not be used directly,
// but from within a widget’s size_allocate method.
//
// The allocation set should be the “adjusted” or actual allocation. If you’re
// implementing a Container, you want to use gtk_widget_size_allocate() instead
// of gtk_widget_set_allocation(). The GtkWidgetClass::adjust_size_allocation
// virtual method adjusts the allocation inside gtk_widget_size_allocate() to
// create an adjusted allocation.
//
// The function takes the following parameters:
//
//    - allocation: pointer to a Allocation to copy from.
//
func (widget *Widget) SetAllocation(allocation *Allocation) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))

	C.gtk_widget_set_allocation(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(allocation)
}

// SetCanDefault specifies whether widget can be a default widget. See
// gtk_widget_grab_default() for details about the meaning of “default”.
//
// The function takes the following parameters:
//
//    - canDefault: whether or not widget can be a default widget.
//
func (widget *Widget) SetCanDefault(canDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if canDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_default(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(canDefault)
}

// SetCanFocus specifies whether widget can own the input focus. See
// gtk_widget_grab_focus() for actually setting the input focus on a widget.
//
// The function takes the following parameters:
//
//    - canFocus: whether or not widget can own the input focus.
//
func (widget *Widget) SetCanFocus(canFocus bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if canFocus {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_focus(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(canFocus)
}

// SetHasWindow specifies whether widget has a Window of its own. Note that all
// realized widgets have a non-NULL “window” pointer (gtk_widget_get_window()
// never returns a NULL window when a widget is realized), but for many of them
// it’s actually the Window of one of its parent widgets. Widgets that do not
// create a window for themselves in Widget::realize must announce this by
// calling this function with has_window = FALSE.
//
// This function should only be called by widget implementations, and they
// should call it in their init() function.
//
// The function takes the following parameters:
//
//    - hasWindow: whether or not widget has a window.
//
func (widget *Widget) SetHasWindow(hasWindow bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if hasWindow {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(hasWindow)
}

// SetReceivesDefault specifies whether widget will be treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// See gtk_widget_grab_default() for details about the meaning of “default”.
//
// The function takes the following parameters:
//
//    - receivesDefault: whether or not widget can be a default widget.
//
func (widget *Widget) SetReceivesDefault(receivesDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if receivesDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_receives_default(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(receivesDefault)
}

// SetVisible sets the visibility state of widget. Note that setting this to
// TRUE doesn’t mean the widget is actually viewable, see
// gtk_widget_get_visible().
//
// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
// nicer to use when the visibility of the widget depends on some condition.
//
// The function takes the following parameters:
//
//    - visible: whether the widget should be shown or not.
//
func (widget *Widget) SetVisible(visible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_visible(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(visible)
}

// SetWindow sets a widget’s window. This function should only be used in a
// widget’s Widget::realize implementation. The window passed is usually either
// new window created with gdk_window_new(), or the window of its parent widget
// as returned by gtk_widget_get_parent_window().
//
// Widgets must indicate whether they will create their own Window by calling
// gtk_widget_set_has_window(). This is usually done in the widget’s init()
// function.
//
// Note that this function does not add any reference to window.
//
// The function takes the following parameters:
//
//    - window: Window.
//
func (widget *Widget) SetWindow(window gdk.Windower) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(window).Native()))

	C.gtk_widget_set_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(window)
}

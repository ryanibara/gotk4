// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gboolean _gotk4_gtk3_StatusIconClass_button_press_event(void*, void*);
// extern gboolean _gotk4_gtk3_StatusIconClass_button_release_event(void*, void*);
// extern gboolean _gotk4_gtk3_StatusIconClass_query_tooltip(void*, gint, gint, gboolean, void*);
// extern gboolean _gotk4_gtk3_StatusIconClass_scroll_event(void*, void*);
// extern gboolean _gotk4_gtk3_StatusIconClass_size_changed(void*, gint);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectButtonPressEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectQueryTooltip(gpointer, gint, gint, gboolean, void*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectScrollEvent(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectSizeChanged(gpointer, gint, guintptr);
// extern void _gotk4_gtk3_StatusIconClass_activate(void*);
// extern void _gotk4_gtk3_StatusIconClass_popup_menu(void*, guint, guint32);
// extern void _gotk4_gtk3_StatusIcon_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk3_StatusIcon_ConnectPopupMenu(gpointer, guint, guint, guintptr);
import "C"

// GTypeStatusIcon returns the GType for the type StatusIcon.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeStatusIcon() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "StatusIcon").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalStatusIcon)
	return gtype
}

// StatusIconOverrider contains methods that are overridable.
type StatusIconOverrider interface {
	Activate()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ButtonPressEvent(event *gdk.EventButton) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ButtonReleaseEvent(event *gdk.EventButton) bool
	// The function takes the following parameters:
	//
	//    - button
	//    - activateTime
	//
	PopupMenu(button, activateTime uint32)
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - keyboardMode
	//    - tooltip
	//
	// The function returns the following values:
	//
	QueryTooltip(x, y int32, keyboardMode bool, tooltip *Tooltip) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ScrollEvent(event *gdk.EventScroll) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SizeChanged(size int32) bool
}

// StatusIcon: “system tray” or notification area is normally used for transient
// icons that indicate some special state. For example, a system tray icon might
// appear to tell the user that they have new mail, or have an incoming instant
// message, or something along those lines. The basic idea is that creating an
// icon in the notification area is less annoying than popping up a dialog.
//
// A StatusIcon object can be used to display an icon in a “system tray”. The
// icon can have a tooltip, and the user can interact with it by activating it
// or popping up a context menu.
//
// It is very important to notice that status icons depend on the existence of a
// notification area being available to the user; you should not use status
// icons as the only way to convey critical information regarding your
// application, as the notification area may not exist on the user's
// environment, or may have been removed. You should always check that a status
// icon has been embedded into a notification area by using
// gtk_status_icon_is_embedded(), and gracefully recover if the function returns
// FALSE.
//
// On X11, the implementation follows the FreeDesktop System Tray Specification
// (http://www.freedesktop.org/wiki/Specifications/systemtray-spec).
// Implementations of the “tray” side of this specification can be found e.g. in
// the GNOME 2 and KDE panel applications.
//
// Note that a GtkStatusIcon is not a widget, but just a #GObject. Making it a
// widget would be impractical, since the system tray on Windows doesn’t allow
// to embed arbitrary widgets.
//
// GtkStatusIcon has been deprecated in 3.14. You should consider using
// notifications or more modern platform-specific APIs instead. GLib provides
// the #GNotification API which works well with Application on multiple
// platforms and environments, and should be the preferred mechanism to notify
// the users of transient status updates. See this HowDoI
// (https://wiki.gnome.org/HowDoI/GNotification) for code examples.
type StatusIcon struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*StatusIcon)(nil)
)

func classInitStatusIconner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "StatusIconClass")

	if _, ok := goval.(interface{ Activate() }); ok {
		o := pclass.StructFieldOffset("activate")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StatusIconClass_activate)
	}

	if _, ok := goval.(interface {
		ButtonPressEvent(event *gdk.EventButton) bool
	}); ok {
		o := pclass.StructFieldOffset("button_press_event")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StatusIconClass_button_press_event)
	}

	if _, ok := goval.(interface {
		ButtonReleaseEvent(event *gdk.EventButton) bool
	}); ok {
		o := pclass.StructFieldOffset("button_release_event")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StatusIconClass_button_release_event)
	}

	if _, ok := goval.(interface {
		PopupMenu(button, activateTime uint32)
	}); ok {
		o := pclass.StructFieldOffset("popup_menu")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StatusIconClass_popup_menu)
	}

	if _, ok := goval.(interface {
		QueryTooltip(x, y int32, keyboardMode bool, tooltip *Tooltip) bool
	}); ok {
		o := pclass.StructFieldOffset("query_tooltip")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StatusIconClass_query_tooltip)
	}

	if _, ok := goval.(interface {
		ScrollEvent(event *gdk.EventScroll) bool
	}); ok {
		o := pclass.StructFieldOffset("scroll_event")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StatusIconClass_scroll_event)
	}

	if _, ok := goval.(interface{ SizeChanged(size int32) bool }); ok {
		o := pclass.StructFieldOffset("size_changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StatusIconClass_size_changed)
	}
}

//export _gotk4_gtk3_StatusIconClass_activate
func _gotk4_gtk3_StatusIconClass_activate(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Activate() })

	iface.Activate()
}

//export _gotk4_gtk3_StatusIconClass_button_press_event
func _gotk4_gtk3_StatusIconClass_button_press_event(arg0 *C.void, arg1 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ButtonPressEvent(event *gdk.EventButton) bool
	})

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ButtonPressEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_button_release_event
func _gotk4_gtk3_StatusIconClass_button_release_event(arg0 *C.void, arg1 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ButtonReleaseEvent(event *gdk.EventButton) bool
	})

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ButtonReleaseEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_popup_menu
func _gotk4_gtk3_StatusIconClass_popup_menu(arg0 *C.void, arg1 C.guint, arg2 C.guint32) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PopupMenu(button, activateTime uint32)
	})

	var _button uint32       // out
	var _activateTime uint32 // out

	_button = uint32(arg1)
	_activateTime = uint32(arg2)

	iface.PopupMenu(_button, _activateTime)
}

//export _gotk4_gtk3_StatusIconClass_query_tooltip
func _gotk4_gtk3_StatusIconClass_query_tooltip(arg0 *C.void, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		QueryTooltip(x, y int32, keyboardMode bool, tooltip *Tooltip) bool
	})

	var _x int32           // out
	var _y int32           // out
	var _keyboardMode bool // out
	var _tooltip *Tooltip  // out

	_x = int32(arg1)
	_y = int32(arg2)
	if arg3 != 0 {
		_keyboardMode = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := iface.QueryTooltip(_x, _y, _keyboardMode, _tooltip)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_scroll_event
func _gotk4_gtk3_StatusIconClass_scroll_event(arg0 *C.void, arg1 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ScrollEvent(event *gdk.EventScroll) bool
	})

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ScrollEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_StatusIconClass_size_changed
func _gotk4_gtk3_StatusIconClass_size_changed(arg0 *C.void, arg1 C.gint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SizeChanged(size int32) bool })

	var _size int32 // out

	_size = int32(arg1)

	ok := iface.SizeChanged(_size)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapStatusIcon(obj *coreglib.Object) *StatusIcon {
	return &StatusIcon{
		Object: obj,
	}
}

func marshalStatusIcon(p uintptr) (interface{}, error) {
	return wrapStatusIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_StatusIcon_ConnectActivate
func _gotk4_gtk3_StatusIcon_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivate gets emitted when the user activates the status icon. If and
// how status icons can activated is platform-dependent.
//
// Unlike most G_SIGNAL_ACTION signals, this signal is meant to be used by
// applications and should be wrapped by language bindings.
func (statusIcon *StatusIcon) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "activate", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectActivate), f)
}

//export _gotk4_gtk3_StatusIcon_ConnectButtonPressEvent
func _gotk4_gtk3_StatusIcon_ConnectButtonPressEvent(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectButtonPressEvent signal will be emitted when a button (typically from
// a mouse) is pressed.
//
// Whether this event is emitted is platform-dependent. Use the ::activate and
// ::popup-menu signals in preference.
func (statusIcon *StatusIcon) ConnectButtonPressEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "button-press-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectButtonPressEvent), f)
}

//export _gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent
func _gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectButtonReleaseEvent signal will be emitted when a button (typically
// from a mouse) is released.
//
// Whether this event is emitted is platform-dependent. Use the ::activate and
// ::popup-menu signals in preference.
func (statusIcon *StatusIcon) ConnectButtonReleaseEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "button-release-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent), f)
}

//export _gotk4_gtk3_StatusIcon_ConnectPopupMenu
func _gotk4_gtk3_StatusIcon_ConnectPopupMenu(arg0 C.gpointer, arg1 C.guint, arg2 C.guint, arg3 C.guintptr) {
	var f func(button, activateTime uint32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(button, activateTime uint32))
	}

	var _button uint32       // out
	var _activateTime uint32 // out

	_button = uint32(arg1)
	_activateTime = uint32(arg2)

	f(_button, _activateTime)
}

// ConnectPopupMenu gets emitted when the user brings up the context menu of the
// status icon. Whether status icons can have context menus and how these are
// activated is platform-dependent.
//
// The button and activate_time parameters should be passed as the last to
// arguments to gtk_menu_popup().
//
// Unlike most G_SIGNAL_ACTION signals, this signal is meant to be used by
// applications and should be wrapped by language bindings.
func (statusIcon *StatusIcon) ConnectPopupMenu(f func(button, activateTime uint32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "popup-menu", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectPopupMenu), f)
}

//export _gotk4_gtk3_StatusIcon_ConnectQueryTooltip
func _gotk4_gtk3_StatusIcon_ConnectQueryTooltip(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.void, arg5 C.guintptr) (cret C.gboolean) {
	var f func(x, y int32, keyboardMode bool, tooltip *Tooltip) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y int32, keyboardMode bool, tooltip *Tooltip) (ok bool))
	}

	var _x int32           // out
	var _y int32           // out
	var _keyboardMode bool // out
	var _tooltip *Tooltip  // out

	_x = int32(arg1)
	_y = int32(arg2)
	if arg3 != 0 {
		_keyboardMode = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := f(_x, _y, _keyboardMode, _tooltip)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectQueryTooltip is emitted when the hover timeout has expired with the
// cursor hovering above status_icon; or emitted when status_icon got focus in
// keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether a
// tooltip should be shown for status_icon. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
//
// Whether this signal is emitted is platform-dependent. For plain text
// tooltips, use StatusIcon:tooltip-text in preference.
func (statusIcon *StatusIcon) ConnectQueryTooltip(f func(x, y int32, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectQueryTooltip), f)
}

//export _gotk4_gtk3_StatusIcon_ConnectScrollEvent
func _gotk4_gtk3_StatusIcon_ConnectScrollEvent(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventScroll) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventScroll) (ok bool))
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectScrollEvent signal is emitted when a button in the 4 to 7 range is
// pressed. Wheel mice are usually configured to generate button press events
// for buttons 4 and 5 when the wheel is turned.
//
// Whether this event is emitted is platform-dependent.
func (statusIcon *StatusIcon) ConnectScrollEvent(f func(event *gdk.EventScroll) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "scroll-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectScrollEvent), f)
}

//export _gotk4_gtk3_StatusIcon_ConnectSizeChanged
func _gotk4_gtk3_StatusIcon_ConnectSizeChanged(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(size int32) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(size int32) (ok bool))
	}

	var _size int32 // out

	_size = int32(arg1)

	ok := f(_size)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectSizeChanged gets emitted when the size available for the image
// changes, e.g. because the notification area got resized.
func (statusIcon *StatusIcon) ConnectSizeChanged(f func(size int32) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "size-changed", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectSizeChanged), f)
}

// NewStatusIcon creates an empty status icon object.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications.
//
// The function returns the following values:
//
//    - statusIcon: new StatusIcon.
//
func NewStatusIcon() *StatusIcon {
	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("new_StatusIcon", nil, nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	var _statusIcon *StatusIcon // out

	_statusIcon = wrapStatusIcon(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _statusIcon
}

// NewStatusIconFromFile creates a status icon displaying the file filename.
//
// The image will be scaled down to fit in the available space in the
// notification area, if necessary.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications.
//
// The function takes the following parameters:
//
//    - filename: filename.
//
// The function returns the following values:
//
//    - statusIcon: new StatusIcon.
//
func NewStatusIconFromFile(filename string) *StatusIcon {
	var _args [1]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("new_StatusIcon_from_file", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(filename)

	var _statusIcon *StatusIcon // out

	_statusIcon = wrapStatusIcon(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _statusIcon
}

// NewStatusIconFromGIcon creates a status icon displaying a #GIcon. If the icon
// is a themed icon, it will be updated when the theme changes.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications.
//
// The function takes the following parameters:
//
//    - icon: #GIcon.
//
// The function returns the following values:
//
//    - statusIcon: new StatusIcon.
//
func NewStatusIconFromGIcon(icon gio.Iconner) *StatusIcon {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("new_StatusIcon_from_gicon", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(icon)

	var _statusIcon *StatusIcon // out

	_statusIcon = wrapStatusIcon(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _statusIcon
}

// NewStatusIconFromIconName creates a status icon displaying an icon from the
// current icon theme. If the current icon theme is changed, the icon will be
// updated appropriately.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications.
//
// The function takes the following parameters:
//
//    - iconName: icon name.
//
// The function returns the following values:
//
//    - statusIcon: new StatusIcon.
//
func NewStatusIconFromIconName(iconName string) *StatusIcon {
	var _args [1]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("new_StatusIcon_from_icon_name", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconName)

	var _statusIcon *StatusIcon // out

	_statusIcon = wrapStatusIcon(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _statusIcon
}

// NewStatusIconFromPixbuf creates a status icon displaying pixbuf.
//
// The image will be scaled down to fit in the available space in the
// notification area, if necessary.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications.
//
// The function takes the following parameters:
//
//    - pixbuf: Pixbuf.
//
// The function returns the following values:
//
//    - statusIcon: new StatusIcon.
//
func NewStatusIconFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *StatusIcon {
	var _args [1]girepository.Argument

	*(**C.GdkPixbuf)(unsafe.Pointer(&_args[0])) = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("new_StatusIcon_from_pixbuf", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(pixbuf)

	var _statusIcon *StatusIcon // out

	_statusIcon = wrapStatusIcon(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _statusIcon
}

// NewStatusIconFromStock creates a status icon displaying a stock icon. Sample
// stock icon names are K_STOCK_OPEN, K_STOCK_QUIT. You can register your own
// stock icon names, see gtk_icon_factory_add_default() and
// gtk_icon_factory_add().
//
// Deprecated: Use #GNotification and Application to provide status
// notifications.
//
// The function takes the following parameters:
//
//    - stockId: stock icon id.
//
// The function returns the following values:
//
//    - statusIcon: new StatusIcon.
//
func NewStatusIconFromStock(stockId string) *StatusIcon {
	var _args [1]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(stockId)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("new_StatusIcon_from_stock", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(stockId)

	var _statusIcon *StatusIcon // out

	_statusIcon = wrapStatusIcon(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _statusIcon
}

// Geometry obtains information about the location of the status icon on screen.
// This information can be used to e.g. position popups like notification
// bubbles.
//
// See gtk_status_icon_position_menu() for a more convenient alternative for
// positioning menus.
//
// Note that some platforms do not allow GTK+ to provide this information, and
// even on platforms that do allow it, the information is not reliable unless
// the status icon is embedded in a notification area, see
// gtk_status_icon_is_embedded().
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function, as the
// platform is responsible for the presentation of notifications.
//
// The function returns the following values:
//
//    - screen (optional): return location for the screen, or NULL if the
//      information is not needed.
//    - area (optional): return location for the area occupied by the status
//      icon, or NULL.
//    - orientation (optional): return location for the orientation of the panel
//      in which the status icon is embedded, or NULL. A panel at the top or
//      bottom of the screen is horizontal, a panel at the left or right is
//      vertical.
//    - ok: TRUE if the location information has been filled in.
//
func (statusIcon *StatusIcon) Geometry() (*gdk.Screen, *gdk.Rectangle, Orientation, bool) {
	var _args [1]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_geometry", _args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _screen *gdk.Screen      // out
	var _area *gdk.Rectangle     // out
	var _orientation Orientation // out
	var _ok bool                 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0]))))
			_screen = &gdk.Screen{
				Object: obj,
			}
		}
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_area = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[1])))))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[2])) != nil {
		_orientation = *(*Orientation)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[2]))))
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _screen, _area, _orientation, _ok
}

// GIcon retrieves the #GIcon being displayed by the StatusIcon. The storage
// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_status_icon_get_storage_type()). The caller of this function does not own
// a reference to the returned #GIcon.
//
// If this function fails, icon is left unchanged;
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - icon (optional): displayed icon, or NULL if the image is empty.
//
func (statusIcon *StatusIcon) GIcon() *gio.Icon {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_gicon", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _icon *gio.Icon // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret))))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// HasTooltip returns the current value of the has-tooltip property. See
// StatusIcon:has-tooltip for more information.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - ok: current value of has-tooltip on status_icon.
//
func (statusIcon *StatusIcon) HasTooltip() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_has_tooltip", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IconName gets the name of the icon being displayed by the StatusIcon. The
// storage type of the status icon must be GTK_IMAGE_EMPTY or
// GTK_IMAGE_ICON_NAME (see gtk_status_icon_get_storage_type()). The returned
// string is owned by the StatusIcon and should not be freed or modified.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - utf8 (optional): name of the displayed icon, or NULL if the image is
//      empty.
//
func (statusIcon *StatusIcon) IconName() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_icon_name", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _utf8 string // out

	if *(**C.gchar)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
	}

	return _utf8
}

// Pixbuf gets the Pixbuf being displayed by the StatusIcon. The storage type of
// the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_PIXBUF (see
// gtk_status_icon_get_storage_type()). The caller of this function does not own
// a reference to the returned pixbuf.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - pixbuf (optional): displayed pixbuf, or NULL if the image is empty.
//
func (statusIcon *StatusIcon) Pixbuf() *gdkpixbuf.Pixbuf {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_pixbuf", _args[:], nil)
	_cret := *(**C.GdkPixbuf)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if *(**C.GdkPixbuf)(unsafe.Pointer(&_cret)) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(*(**C.GdkPixbuf)(unsafe.Pointer(&_cret))))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// Screen returns the Screen associated with status_icon.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function, as
// notifications are managed by the platform.
//
// The function returns the following values:
//
//    - screen: Screen.
//
func (statusIcon *StatusIcon) Screen() *gdk.Screen {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_screen", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _screen *gdk.Screen // out

	{
		obj := coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret))))
		_screen = &gdk.Screen{
			Object: obj,
		}
	}

	return _screen
}

// Size gets the size in pixels that is available for the image. Stock icons and
// named icons adapt their size automatically if the size of the notification
// area changes. For other storage types, the size-changed signal can be used to
// react to size changes.
//
// Note that the returned size is only meaningful while the status icon is
// embedded (see gtk_status_icon_is_embedded()).
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function, as the
// representation of a notification is left to the platform.
//
// The function returns the following values:
//
//    - gint: size that is available for the image.
//
func (statusIcon *StatusIcon) Size() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_size", _args[:], nil)
	_cret := *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Stock gets the id of the stock icon being displayed by the StatusIcon. The
// storage type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_STOCK
// (see gtk_status_icon_get_storage_type()). The returned string is owned by the
// StatusIcon and should not be freed or modified.
//
// Deprecated: Use gtk_status_icon_get_icon_name() instead.
//
// The function returns the following values:
//
//    - utf8 (optional): stock id of the displayed stock icon, or NULL if the
//      image is empty.
//
func (statusIcon *StatusIcon) Stock() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_stock", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _utf8 string // out

	if *(**C.gchar)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
	}

	return _utf8
}

// Title gets the title of this tray icon. See gtk_status_icon_set_title().
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - utf8: title of the status icon.
//
func (statusIcon *StatusIcon) Title() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_title", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// TooltipMarkup gets the contents of the tooltip for status_icon.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip text, or NULL. You should free the returned
//      string with g_free() when done.
//
func (statusIcon *StatusIcon) TooltipMarkup() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_tooltip_markup", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _utf8 string // out

	if *(**C.gchar)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret))))
	}

	return _utf8
}

// TooltipText gets the contents of the tooltip for status_icon.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip text, or NULL. You should free the returned
//      string with g_free() when done.
//
func (statusIcon *StatusIcon) TooltipText() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_tooltip_text", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _utf8 string // out

	if *(**C.gchar)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret))))
	}

	return _utf8
}

// Visible returns whether the status icon is visible or not. Note that being
// visible does not guarantee that the user can actually see the icon, see also
// gtk_status_icon_is_embedded().
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - ok: TRUE if the status icon is visible.
//
func (statusIcon *StatusIcon) Visible() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_visible", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// X11WindowID: this function is only useful on the X11/freedesktop.org
// platform.
//
// It returns a window ID for the widget in the underlying status icon
// implementation. This is useful for the Galago notification service, which can
// send a window ID in the protocol in order for the server to position
// notification windows pointing to a status icon reliably.
//
// This function is not intended for other use cases which are more likely to be
// met by one of the non-X11 specific methods, such as
// gtk_status_icon_position_menu().
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - guint32: 32 bit unsigned integer identifier for the underlying X11
//      Window.
//
func (statusIcon *StatusIcon) X11WindowID() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("get_x11_window_id", _args[:], nil)
	_cret := *(*C.guint32)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _guint32 uint32 // out

	_guint32 = uint32(*(*C.guint32)(unsafe.Pointer(&_cret)))

	return _guint32
}

// IsEmbedded returns whether the status icon is embedded in a notification
// area.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - ok: TRUE if the status icon is embedded in a notification area.
//
func (statusIcon *StatusIcon) IsEmbedded() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_gret := _info.InvokeClassMethod("is_embedded", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(statusIcon)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SetFromFile makes status_icon display the file filename. See
// gtk_status_icon_new_from_file() for details.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; you can use g_notification_set_icon() to associate a #GIcon
// with a notification.
//
// The function takes the following parameters:
//
//    - filename: filename.
//
func (statusIcon *StatusIcon) SetFromFile(filename string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_from_file", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(filename)
}

// SetFromGIcon makes status_icon display the #GIcon. See
// gtk_status_icon_new_from_gicon() for details.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; you can use g_notification_set_icon() to associate a #GIcon
// with a notification.
//
// The function takes the following parameters:
//
//    - icon: GIcon.
//
func (statusIcon *StatusIcon) SetFromGIcon(icon gio.Iconner) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_from_gicon", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(icon)
}

// SetFromIconName makes status_icon display the icon named icon_name from the
// current icon theme. See gtk_status_icon_new_from_icon_name() for details.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; you can use g_notification_set_icon() to associate a #GIcon
// with a notification.
//
// The function takes the following parameters:
//
//    - iconName: icon name.
//
func (statusIcon *StatusIcon) SetFromIconName(iconName string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_from_icon_name", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(iconName)
}

// SetFromPixbuf makes status_icon display pixbuf. See
// gtk_status_icon_new_from_pixbuf() for details.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; you can use g_notification_set_icon() to associate a #GIcon
// with a notification.
//
// The function takes the following parameters:
//
//    - pixbuf (optional) or NULL.
//
func (statusIcon *StatusIcon) SetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	if pixbuf != nil {
		*(**C.GdkPixbuf)(unsafe.Pointer(&_args[1])) = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	}

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_from_pixbuf", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(pixbuf)
}

// SetFromStock makes status_icon display the stock icon with the id stock_id.
// See gtk_status_icon_new_from_stock() for details.
//
// Deprecated: Use gtk_status_icon_set_from_icon_name() instead.
//
// The function takes the following parameters:
//
//    - stockId: stock icon id.
//
func (statusIcon *StatusIcon) SetFromStock(stockId string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(stockId)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_from_stock", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(stockId)
}

// SetHasTooltip sets the has-tooltip property on status_icon to has_tooltip.
// See StatusIcon:has-tooltip for more information.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function, but
// notifications can display an arbitrary amount of text using
// g_notification_set_body().
//
// The function takes the following parameters:
//
//    - hasTooltip: whether or not status_icon has a tooltip.
//
func (statusIcon *StatusIcon) SetHasTooltip(hasTooltip bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	if hasTooltip {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_has_tooltip", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(hasTooltip)
}

// SetName sets the name of this tray icon. This should be a string identifying
// this icon. It is may be used for sorting the icons in the tray and will not
// be shown to the user.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function, as
// notifications are associated with a unique application identifier by
// #GApplication.
//
// The function takes the following parameters:
//
//    - name: name.
//
func (statusIcon *StatusIcon) SetName(name string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_name", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(name)
}

// SetScreen sets the Screen where status_icon is displayed; if the icon is
// already mapped, it will be unmapped, and then remapped on the new screen.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function, as GTK
// typically only has one Screen and notifications are managed by the platform.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
func (statusIcon *StatusIcon) SetScreen(screen *gdk.Screen) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_screen", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(screen)
}

// SetTitle sets the title of this tray icon. This should be a short,
// human-readable, localized string describing the tray icon. It may be used by
// tools like screen readers to render the tray icon.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; you should use g_notification_set_title() and
// g_notification_set_body() to present text inside your notification.
//
// The function takes the following parameters:
//
//    - title: title.
//
func (statusIcon *StatusIcon) SetTitle(title string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_title", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(title)
}

// SetTooltipMarkup sets markup as the contents of the tooltip, which is marked
// up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting StatusIcon:has-tooltip to TRUE and of
// the default handler for the StatusIcon::query-tooltip signal.
//
// See also the StatusIcon:tooltip-markup property and gtk_tooltip_set_markup().
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function takes the following parameters:
//
//    - markup (optional) contents of the tooltip for status_icon, or NULL.
//
func (statusIcon *StatusIcon) SetTooltipMarkup(markup string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	if markup != "" {
		*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(markup)))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))
	}

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_tooltip_markup", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(markup)
}

// SetTooltipText sets text as the contents of the tooltip.
//
// This function will take care of setting StatusIcon:has-tooltip to TRUE and of
// the default handler for the StatusIcon::query-tooltip signal.
//
// See also the StatusIcon:tooltip-text property and gtk_tooltip_set_text().
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function takes the following parameters:
//
//    - text contents of the tooltip for status_icon.
//
func (statusIcon *StatusIcon) SetTooltipText(text string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_tooltip_text", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(text)
}

// SetVisible shows or hides a status icon.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function, as
// notifications are managed by the platform.
//
// The function takes the following parameters:
//
//    - visible: TRUE to show the status icon, FALSE to hide it.
//
func (statusIcon *StatusIcon) SetVisible(visible bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	if visible {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "StatusIcon")
	_info.InvokeClassMethod("set_visible", _args[:], nil)

	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(visible)
}

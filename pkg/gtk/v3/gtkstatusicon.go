// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_StatusIcon_ConnectPopupMenu(gpointer, guint, guint, guintptr);
// extern void _gotk4_gtk3_StatusIcon_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk3_StatusIconClass_popup_menu(GtkStatusIcon*, guint, guint32);
// extern void _gotk4_gtk3_StatusIconClass_activate(GtkStatusIcon*);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectSizeChanged(gpointer, gint, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectScrollEvent(gpointer, GdkEventScroll*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectQueryTooltip(gpointer, gint, gint, gboolean, GtkTooltip*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent(gpointer, GdkEventButton*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIcon_ConnectButtonPressEvent(gpointer, GdkEventButton*, guintptr);
// extern gboolean _gotk4_gtk3_StatusIconClass_size_changed(GtkStatusIcon*, gint);
// extern gboolean _gotk4_gtk3_StatusIconClass_scroll_event(GtkStatusIcon*, GdkEventScroll*);
// extern gboolean _gotk4_gtk3_StatusIconClass_query_tooltip(GtkStatusIcon*, gint, gint, gboolean, GtkTooltip*);
// extern gboolean _gotk4_gtk3_StatusIconClass_button_release_event(GtkStatusIcon*, GdkEventButton*);
// extern gboolean _gotk4_gtk3_StatusIconClass_button_press_event(GtkStatusIcon*, GdkEventButton*);
// gboolean _gotk4_gtk3_StatusIcon_virtual_button_press_event(void* fnptr, GtkStatusIcon* arg0, GdkEventButton* arg1) {
//   return ((gboolean (*)(GtkStatusIcon*, GdkEventButton*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_StatusIcon_virtual_button_release_event(void* fnptr, GtkStatusIcon* arg0, GdkEventButton* arg1) {
//   return ((gboolean (*)(GtkStatusIcon*, GdkEventButton*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_StatusIcon_virtual_query_tooltip(void* fnptr, GtkStatusIcon* arg0, gint arg1, gint arg2, gboolean arg3, GtkTooltip* arg4) {
//   return ((gboolean (*)(GtkStatusIcon*, gint, gint, gboolean, GtkTooltip*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gtk3_StatusIcon_virtual_scroll_event(void* fnptr, GtkStatusIcon* arg0, GdkEventScroll* arg1) {
//   return ((gboolean (*)(GtkStatusIcon*, GdkEventScroll*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_StatusIcon_virtual_size_changed(void* fnptr, GtkStatusIcon* arg0, gint arg1) {
//   return ((gboolean (*)(GtkStatusIcon*, gint))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_StatusIcon_virtual_activate(void* fnptr, GtkStatusIcon* arg0) {
//   ((void (*)(GtkStatusIcon*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_StatusIcon_virtual_popup_menu(void* fnptr, GtkStatusIcon* arg0, guint arg1, guint32 arg2) {
//   ((void (*)(GtkStatusIcon*, guint, guint32))(fnptr))(arg0, arg1, arg2);
// };
import "C"

// GType values.
var (
	GTypeStatusIcon = coreglib.Type(C.gtk_status_icon_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeStatusIcon, F: marshalStatusIcon},
	})
}

// StatusIconOverrides contains methods that are overridable.
type StatusIconOverrides struct {
	Activate func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ButtonPressEvent func(event *gdk.EventButton) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ButtonReleaseEvent func(event *gdk.EventButton) bool
	// The function takes the following parameters:
	//
	//    - button
	//    - activateTime
	//
	PopupMenu func(button uint, activateTime uint32)
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - keyboardMode
	//    - tooltip
	//
	// The function returns the following values:
	//
	QueryTooltip func(x, y int, keyboardMode bool, tooltip *Tooltip) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ScrollEvent func(event *gdk.EventScroll) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SizeChanged func(size int) bool
}

func defaultStatusIconOverrides(v *StatusIcon) StatusIconOverrides {
	return StatusIconOverrides{
		Activate:           v.activate,
		ButtonPressEvent:   v.buttonPressEvent,
		ButtonReleaseEvent: v.buttonReleaseEvent,
		PopupMenu:          v.popupMenu,
		QueryTooltip:       v.queryTooltip,
		ScrollEvent:        v.scrollEvent,
		SizeChanged:        v.sizeChanged,
	}
}

// StatusIcon: “system tray” or notification area is normally used for transient
// icons that indicate some special state. For example, a system tray icon might
// appear to tell the user that they have new mail, or have an incoming instant
// message, or something along those lines. The basic idea is that creating an
// icon in the notification area is less annoying than popping up a dialog.
//
// A StatusIcon object can be used to display an icon in a “system tray”. The
// icon can have a tooltip, and the user can interact with it by activating it
// or popping up a context menu.
//
// It is very important to notice that status icons depend on the existence of a
// notification area being available to the user; you should not use status
// icons as the only way to convey critical information regarding your
// application, as the notification area may not exist on the user's
// environment, or may have been removed. You should always check that a status
// icon has been embedded into a notification area by using
// gtk_status_icon_is_embedded(), and gracefully recover if the function returns
// FALSE.
//
// On X11, the implementation follows the FreeDesktop System Tray Specification
// (http://www.freedesktop.org/wiki/Specifications/systemtray-spec).
// Implementations of the “tray” side of this specification can be found e.g. in
// the GNOME 2 and KDE panel applications.
//
// Note that a GtkStatusIcon is not a widget, but just a #GObject. Making it a
// widget would be impractical, since the system tray on Windows doesn’t allow
// to embed arbitrary widgets.
//
// GtkStatusIcon has been deprecated in 3.14. You should consider using
// notifications or more modern platform-specific APIs instead. GLib provides
// the #GNotification API which works well with Application on multiple
// platforms and environments, and should be the preferred mechanism to notify
// the users of transient status updates. See this HowDoI
// (https://wiki.gnome.org/HowDoI/GNotification) for code examples.
type StatusIcon struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*StatusIcon)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StatusIcon, *StatusIconClass, StatusIconOverrides](
		GTypeStatusIcon,
		initStatusIconClass,
		wrapStatusIcon,
		defaultStatusIconOverrides,
	)
}

func initStatusIconClass(gclass unsafe.Pointer, overrides StatusIconOverrides, classInitFunc func(*StatusIconClass)) {
	pclass := (*C.GtkStatusIconClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeStatusIcon))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk3_StatusIconClass_activate)
	}

	if overrides.ButtonPressEvent != nil {
		pclass.button_press_event = (*[0]byte)(C._gotk4_gtk3_StatusIconClass_button_press_event)
	}

	if overrides.ButtonReleaseEvent != nil {
		pclass.button_release_event = (*[0]byte)(C._gotk4_gtk3_StatusIconClass_button_release_event)
	}

	if overrides.PopupMenu != nil {
		pclass.popup_menu = (*[0]byte)(C._gotk4_gtk3_StatusIconClass_popup_menu)
	}

	if overrides.QueryTooltip != nil {
		pclass.query_tooltip = (*[0]byte)(C._gotk4_gtk3_StatusIconClass_query_tooltip)
	}

	if overrides.ScrollEvent != nil {
		pclass.scroll_event = (*[0]byte)(C._gotk4_gtk3_StatusIconClass_scroll_event)
	}

	if overrides.SizeChanged != nil {
		pclass.size_changed = (*[0]byte)(C._gotk4_gtk3_StatusIconClass_size_changed)
	}

	if classInitFunc != nil {
		class := (*StatusIconClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStatusIcon(obj *coreglib.Object) *StatusIcon {
	return &StatusIcon{
		Object: obj,
	}
}

func marshalStatusIcon(p uintptr) (interface{}, error) {
	return wrapStatusIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate gets emitted when the user activates the status icon. If and
// how status icons can activated is platform-dependent.
//
// Unlike most G_SIGNAL_ACTION signals, this signal is meant to be used by
// applications and should be wrapped by language bindings.
func (statusIcon *StatusIcon) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "activate", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectActivate), f)
}

// ConnectButtonPressEvent signal will be emitted when a button (typically from
// a mouse) is pressed.
//
// Whether this event is emitted is platform-dependent. Use the ::activate and
// ::popup-menu signals in preference.
func (statusIcon *StatusIcon) ConnectButtonPressEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "button-press-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectButtonPressEvent), f)
}

// ConnectButtonReleaseEvent signal will be emitted when a button (typically
// from a mouse) is released.
//
// Whether this event is emitted is platform-dependent. Use the ::activate and
// ::popup-menu signals in preference.
func (statusIcon *StatusIcon) ConnectButtonReleaseEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "button-release-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectButtonReleaseEvent), f)
}

// ConnectPopupMenu gets emitted when the user brings up the context menu of the
// status icon. Whether status icons can have context menus and how these are
// activated is platform-dependent.
//
// The button and activate_time parameters should be passed as the last to
// arguments to gtk_menu_popup().
//
// Unlike most G_SIGNAL_ACTION signals, this signal is meant to be used by
// applications and should be wrapped by language bindings.
func (statusIcon *StatusIcon) ConnectPopupMenu(f func(button, activateTime uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "popup-menu", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectPopupMenu), f)
}

// ConnectQueryTooltip is emitted when the hover timeout has expired with the
// cursor hovering above status_icon; or emitted when status_icon got focus in
// keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether a
// tooltip should be shown for status_icon. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
//
// Whether this signal is emitted is platform-dependent. For plain text
// tooltips, use StatusIcon:tooltip-text in preference.
func (statusIcon *StatusIcon) ConnectQueryTooltip(f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectQueryTooltip), f)
}

// ConnectScrollEvent signal is emitted when a button in the 4 to 7 range is
// pressed. Wheel mice are usually configured to generate button press events
// for buttons 4 and 5 when the wheel is turned.
//
// Whether this event is emitted is platform-dependent.
func (statusIcon *StatusIcon) ConnectScrollEvent(f func(event *gdk.EventScroll) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "scroll-event", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectScrollEvent), f)
}

// ConnectSizeChanged gets emitted when the size available for the image
// changes, e.g. because the notification area got resized.
func (statusIcon *StatusIcon) ConnectSizeChanged(f func(size int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusIcon, "size-changed", false, unsafe.Pointer(C._gotk4_gtk3_StatusIcon_ConnectSizeChanged), f)
}

func (statusIcon *StatusIcon) activate() {
	gclass := (*C.GtkStatusIconClass)(coreglib.PeekParentClass(statusIcon))
	fnarg := gclass.activate

	var _arg0 *C.GtkStatusIcon // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	C._gotk4_gtk3_StatusIcon_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(statusIcon)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (statusIcon *StatusIcon) buttonPressEvent(event *gdk.EventButton) bool {
	gclass := (*C.GtkStatusIconClass)(coreglib.PeekParentClass(statusIcon))
	fnarg := gclass.button_press_event

	var _arg0 *C.GtkStatusIcon  // out
	var _arg1 *C.GdkEventButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	_arg1 = (*C.GdkEventButton)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_StatusIcon_virtual_button_press_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (statusIcon *StatusIcon) buttonReleaseEvent(event *gdk.EventButton) bool {
	gclass := (*C.GtkStatusIconClass)(coreglib.PeekParentClass(statusIcon))
	fnarg := gclass.button_release_event

	var _arg0 *C.GtkStatusIcon  // out
	var _arg1 *C.GdkEventButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	_arg1 = (*C.GdkEventButton)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_StatusIcon_virtual_button_release_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - button
//    - activateTime
//
func (statusIcon *StatusIcon) popupMenu(button uint, activateTime uint32) {
	gclass := (*C.GtkStatusIconClass)(coreglib.PeekParentClass(statusIcon))
	fnarg := gclass.popup_menu

	var _arg0 *C.GtkStatusIcon // out
	var _arg1 C.guint          // out
	var _arg2 C.guint32        // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	_arg1 = C.guint(button)
	_arg2 = C.guint32(activateTime)

	C._gotk4_gtk3_StatusIcon_virtual_popup_menu(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(button)
	runtime.KeepAlive(activateTime)
}

// The function takes the following parameters:
//
//    - x
//    - y
//    - keyboardMode
//    - tooltip
//
// The function returns the following values:
//
func (statusIcon *StatusIcon) queryTooltip(x, y int, keyboardMode bool, tooltip *Tooltip) bool {
	gclass := (*C.GtkStatusIconClass)(coreglib.PeekParentClass(statusIcon))
	fnarg := gclass.query_tooltip

	var _arg0 *C.GtkStatusIcon // out
	var _arg1 C.gint           // out
	var _arg2 C.gint           // out
	var _arg3 C.gboolean       // out
	var _arg4 *C.GtkTooltip    // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	if keyboardMode {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))

	_cret = C._gotk4_gtk3_StatusIcon_virtual_query_tooltip(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(keyboardMode)
	runtime.KeepAlive(tooltip)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (statusIcon *StatusIcon) scrollEvent(event *gdk.EventScroll) bool {
	gclass := (*C.GtkStatusIconClass)(coreglib.PeekParentClass(statusIcon))
	fnarg := gclass.scroll_event

	var _arg0 *C.GtkStatusIcon  // out
	var _arg1 *C.GdkEventScroll // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	_arg1 = (*C.GdkEventScroll)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_StatusIcon_virtual_scroll_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (statusIcon *StatusIcon) sizeChanged(size int) bool {
	gclass := (*C.GtkStatusIconClass)(coreglib.PeekParentClass(statusIcon))
	fnarg := gclass.size_changed

	var _arg0 *C.GtkStatusIcon // out
	var _arg1 C.gint           // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	_arg1 = C.gint(size)

	_cret = C._gotk4_gtk3_StatusIcon_virtual_size_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StatusIconClass: instance of this type is always passed by reference.
type StatusIconClass struct {
	*statusIconClass
}

// statusIconClass is the struct that's finalized.
type statusIconClass struct {
	native *C.GtkStatusIconClass
}

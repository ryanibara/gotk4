// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern AtkObject* _gotk4_gtk3_WidgetClass_get_accessible(GtkWidget*);
// extern GtkSizeRequestMode _gotk4_gtk3_WidgetClass_get_request_mode(GtkWidget*);
// extern gboolean _gotk4_gtk3_TickCallback(GtkWidget*, GdkFrameClock*, gpointer);
// extern gboolean _gotk4_gtk3_WidgetClass_button_press_event(GtkWidget*, GdkEventButton*);
// extern gboolean _gotk4_gtk3_WidgetClass_button_release_event(GtkWidget*, GdkEventButton*);
// extern gboolean _gotk4_gtk3_WidgetClass_can_activate_accel(GtkWidget*, guint);
// extern gboolean _gotk4_gtk3_WidgetClass_configure_event(GtkWidget*, GdkEventConfigure*);
// extern gboolean _gotk4_gtk3_WidgetClass_damage_event(GtkWidget*, GdkEventExpose*);
// extern gboolean _gotk4_gtk3_WidgetClass_delete_event(GtkWidget*, GdkEventAny*);
// extern gboolean _gotk4_gtk3_WidgetClass_destroy_event(GtkWidget*, GdkEventAny*);
// extern gboolean _gotk4_gtk3_WidgetClass_drag_drop(GtkWidget*, GdkDragContext*, gint, gint, guint);
// extern gboolean _gotk4_gtk3_WidgetClass_drag_failed(GtkWidget*, GdkDragContext*, GtkDragResult);
// extern gboolean _gotk4_gtk3_WidgetClass_drag_motion(GtkWidget*, GdkDragContext*, gint, gint, guint);
// extern gboolean _gotk4_gtk3_WidgetClass_draw(GtkWidget*, cairo_t*);
// extern gboolean _gotk4_gtk3_WidgetClass_enter_notify_event(GtkWidget*, GdkEventCrossing*);
// extern gboolean _gotk4_gtk3_WidgetClass_event(GtkWidget*, GdkEvent*);
// extern gboolean _gotk4_gtk3_WidgetClass_focus(GtkWidget*, GtkDirectionType);
// extern gboolean _gotk4_gtk3_WidgetClass_focus_in_event(GtkWidget*, GdkEventFocus*);
// extern gboolean _gotk4_gtk3_WidgetClass_focus_out_event(GtkWidget*, GdkEventFocus*);
// extern gboolean _gotk4_gtk3_WidgetClass_grab_broken_event(GtkWidget*, GdkEventGrabBroken*);
// extern gboolean _gotk4_gtk3_WidgetClass_key_press_event(GtkWidget*, GdkEventKey*);
// extern gboolean _gotk4_gtk3_WidgetClass_key_release_event(GtkWidget*, GdkEventKey*);
// extern gboolean _gotk4_gtk3_WidgetClass_keynav_failed(GtkWidget*, GtkDirectionType);
// extern gboolean _gotk4_gtk3_WidgetClass_leave_notify_event(GtkWidget*, GdkEventCrossing*);
// extern gboolean _gotk4_gtk3_WidgetClass_map_event(GtkWidget*, GdkEventAny*);
// extern gboolean _gotk4_gtk3_WidgetClass_mnemonic_activate(GtkWidget*, gboolean);
// extern gboolean _gotk4_gtk3_WidgetClass_motion_notify_event(GtkWidget*, GdkEventMotion*);
// extern gboolean _gotk4_gtk3_WidgetClass_popup_menu(GtkWidget*);
// extern gboolean _gotk4_gtk3_WidgetClass_property_notify_event(GtkWidget*, GdkEventProperty*);
// extern gboolean _gotk4_gtk3_WidgetClass_proximity_in_event(GtkWidget*, GdkEventProximity*);
// extern gboolean _gotk4_gtk3_WidgetClass_proximity_out_event(GtkWidget*, GdkEventProximity*);
// extern gboolean _gotk4_gtk3_WidgetClass_query_tooltip(GtkWidget*, gint, gint, gboolean, GtkTooltip*);
// extern gboolean _gotk4_gtk3_WidgetClass_scroll_event(GtkWidget*, GdkEventScroll*);
// extern gboolean _gotk4_gtk3_WidgetClass_selection_clear_event(GtkWidget*, GdkEventSelection*);
// extern gboolean _gotk4_gtk3_WidgetClass_selection_notify_event(GtkWidget*, GdkEventSelection*);
// extern gboolean _gotk4_gtk3_WidgetClass_selection_request_event(GtkWidget*, GdkEventSelection*);
// extern gboolean _gotk4_gtk3_WidgetClass_show_help(GtkWidget*, GtkWidgetHelpType);
// extern gboolean _gotk4_gtk3_WidgetClass_touch_event(GtkWidget*, GdkEventTouch*);
// extern gboolean _gotk4_gtk3_WidgetClass_unmap_event(GtkWidget*, GdkEventAny*);
// extern gboolean _gotk4_gtk3_WidgetClass_visibility_notify_event(GtkWidget*, GdkEventVisibility*);
// extern gboolean _gotk4_gtk3_WidgetClass_window_state_event(GtkWidget*, GdkEventWindowState*);
// extern gboolean _gotk4_gtk3_Widget_ConnectButtonPressEvent(gpointer, GdkEventButton*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectButtonReleaseEvent(gpointer, GdkEventButton*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectCanActivateAccel(gpointer, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectConfigureEvent(gpointer, GdkEventConfigure*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDamageEvent(gpointer, GdkEventExpose*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDeleteEvent(gpointer, GdkEvent, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDestroyEvent(gpointer, GdkEvent, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDragDrop(gpointer, GdkDragContext*, gint, gint, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDragFailed(gpointer, GdkDragContext*, GtkDragResult, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDragMotion(gpointer, GdkDragContext*, gint, gint, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDraw(gpointer, cairo_t*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectEnterNotifyEvent(gpointer, GdkEventCrossing*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectEvent(gpointer, GdkEvent, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectFocus(gpointer, GtkDirectionType, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectFocusInEvent(gpointer, GdkEventFocus*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectFocusOutEvent(gpointer, GdkEventFocus*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectGrabBrokenEvent(gpointer, GdkEventGrabBroken*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectKeyPressEvent(gpointer, GdkEventKey*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectKeyReleaseEvent(gpointer, GdkEventKey*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectKeynavFailed(gpointer, GtkDirectionType, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent(gpointer, GdkEventCrossing*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMapEvent(gpointer, GdkEventAny*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMnemonicActivate(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMotionNotifyEvent(gpointer, GdkEventMotion*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectPopupMenu(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent(gpointer, GdkEventProperty*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectProximityInEvent(gpointer, GdkEventProximity*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectProximityOutEvent(gpointer, GdkEventProximity*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectQueryTooltip(gpointer, gint, gint, gboolean, GtkTooltip*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectScrollEvent(gpointer, GdkEventScroll*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionClearEvent(gpointer, GdkEventSelection*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent(gpointer, GdkEventSelection*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionRequestEvent(gpointer, GdkEventSelection*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectShowHelp(gpointer, GtkWidgetHelpType, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectTouchEvent(gpointer, GdkEvent, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectUnmapEvent(gpointer, GdkEventAny*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent(gpointer, GdkEventVisibility*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectWindowStateEvent(gpointer, GdkEventWindowState*, guintptr);
// extern void _gotk4_gtk3_WidgetClass_adjust_baseline_allocation(GtkWidget*, gint*);
// extern void _gotk4_gtk3_WidgetClass_adjust_baseline_request(GtkWidget*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_adjust_size_allocation(GtkWidget*, GtkOrientation, gint*, gint*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_adjust_size_request(GtkWidget*, GtkOrientation, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_composited_changed(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_destroy(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_direction_changed(GtkWidget*, GtkTextDirection);
// extern void _gotk4_gtk3_WidgetClass_drag_begin(GtkWidget*, GdkDragContext*);
// extern void _gotk4_gtk3_WidgetClass_drag_data_delete(GtkWidget*, GdkDragContext*);
// extern void _gotk4_gtk3_WidgetClass_drag_data_get(GtkWidget*, GdkDragContext*, GtkSelectionData*, guint, guint);
// extern void _gotk4_gtk3_WidgetClass_drag_data_received(GtkWidget*, GdkDragContext*, gint, gint, GtkSelectionData*, guint, guint);
// extern void _gotk4_gtk3_WidgetClass_drag_end(GtkWidget*, GdkDragContext*);
// extern void _gotk4_gtk3_WidgetClass_drag_leave(GtkWidget*, GdkDragContext*, guint);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_height(GtkWidget*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width(GtkWidget*, gint, gint*, gint*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_height_for_width(GtkWidget*, gint, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_width(GtkWidget*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_width_for_height(GtkWidget*, gint, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_grab_focus(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_grab_notify(GtkWidget*, gboolean);
// extern void _gotk4_gtk3_WidgetClass_hide(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_hierarchy_changed(GtkWidget*, GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_map(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_move_focus(GtkWidget*, GtkDirectionType);
// extern void _gotk4_gtk3_WidgetClass_parent_set(GtkWidget*, GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_queue_draw_region(GtkWidget*, cairo_region_t*);
// extern void _gotk4_gtk3_WidgetClass_realize(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_screen_changed(GtkWidget*, GdkScreen*);
// extern void _gotk4_gtk3_WidgetClass_selection_get(GtkWidget*, GtkSelectionData*, guint, guint);
// extern void _gotk4_gtk3_WidgetClass_selection_received(GtkWidget*, GtkSelectionData*, guint);
// extern void _gotk4_gtk3_WidgetClass_show(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_show_all(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_size_allocate(GtkWidget*, GtkAllocation*);
// extern void _gotk4_gtk3_WidgetClass_state_changed(GtkWidget*, GtkStateType);
// extern void _gotk4_gtk3_WidgetClass_state_flags_changed(GtkWidget*, GtkStateFlags);
// extern void _gotk4_gtk3_WidgetClass_style_set(GtkWidget*, GtkStyle*);
// extern void _gotk4_gtk3_WidgetClass_style_updated(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_unmap(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_unrealize(GtkWidget*);
// extern void _gotk4_gtk3_Widget_ConnectAccelClosuresChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectCompositedChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDestroy(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDirectionChanged(gpointer, GtkTextDirection, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragBegin(gpointer, GdkDragContext*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataDelete(gpointer, GdkDragContext*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataGet(gpointer, GdkDragContext*, GtkSelectionData*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataReceived(gpointer, GdkDragContext*, gint, gint, GtkSelectionData*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragEnd(gpointer, GdkDragContext*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragLeave(gpointer, GdkDragContext*, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectEventAfter(gpointer, GdkEvent, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectGrabFocus(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectGrabNotify(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectHide(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectHierarchyChanged(gpointer, GtkWidget*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectMap(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectMoveFocus(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectParentSet(gpointer, GtkWidget*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectRealize(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectScreenChanged(gpointer, GdkScreen*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSelectionGet(gpointer, GtkSelectionData*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSelectionReceived(gpointer, GtkSelectionData*, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectShow(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSizeAllocate(gpointer, GtkAllocation*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStateChanged(gpointer, GtkStateType, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStateFlagsChanged(gpointer, GtkStateFlags, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStyleSet(gpointer, GtkStyle*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStyleUpdated(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectUnmap(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectUnrealize(gpointer, guintptr);
// extern void callbackDelete(gpointer);
import "C"

// GTypeWidgetHelpType returns the GType for the type WidgetHelpType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeWidgetHelpType() coreglib.Type {
	gtype := coreglib.Type(C.gtk_widget_help_type_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalWidgetHelpType)
	return gtype
}

// GTypeWidget returns the GType for the type Widget.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeWidget() coreglib.Type {
	gtype := coreglib.Type(C.gtk_widget_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalWidget)
	return gtype
}

// GTypeRequisition returns the GType for the type Requisition.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeRequisition() coreglib.Type {
	gtype := coreglib.Type(C.gtk_requisition_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalRequisition)
	return gtype
}

// Allocation of a widget represents region which has been allocated to the
// widget by its parent. It is a subregion of its parents allocation. See
// [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Allocation = gdk.Rectangle

// WidgetHelpType kinds of widget-specific help. Used by the ::show-help signal.
type WidgetHelpType C.gint

const (
	// WidgetHelpTooltip: tooltip.
	WidgetHelpTooltip WidgetHelpType = iota
	// WidgetHelpWhatsThis what’s this.
	WidgetHelpWhatsThis
)

func marshalWidgetHelpType(p uintptr) (interface{}, error) {
	return WidgetHelpType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WidgetHelpType.
func (w WidgetHelpType) String() string {
	switch w {
	case WidgetHelpTooltip:
		return "Tooltip"
	case WidgetHelpWhatsThis:
		return "WhatsThis"
	default:
		return fmt.Sprintf("WidgetHelpType(%d)", w)
	}
}

// Callback: type of the callback functions used for e.g. iterating over the
// children of a container, see gtk_container_foreach().
type Callback func(widget Widgetter)

//export _gotk4_gtk3_Callback
func _gotk4_gtk3_Callback(arg1 *C.GtkWidget, arg2 C.gpointer) {
	var fn Callback
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(Callback)
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	fn(_widget)
}

// TickCallback: callback type for adding a function to update animations. See
// gtk_widget_add_tick_callback().
type TickCallback func(widget Widgetter, frameClock gdk.FrameClocker) (ok bool)

//export _gotk4_gtk3_TickCallback
func _gotk4_gtk3_TickCallback(arg1 *C.GtkWidget, arg2 *C.GdkFrameClock, arg3 C.gpointer) (cret C.gboolean) {
	var fn TickCallback
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TickCallback)
	}

	var _widget Widgetter            // out
	var _frameClock gdk.FrameClocker // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gdk.FrameClocker is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.FrameClocker)
			return ok
		})
		rv, ok := casted.(gdk.FrameClocker)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.FrameClocker")
		}
		_frameClock = rv
	}

	ok := fn(_widget, _frameClock)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// CairoShouldDrawWindow: this function is supposed to be called in Widget::draw
// implementations for widgets that support multiple windows. cr must be
// untransformed from invoking of the draw function. This function will return
// TRUE if the contents of the given window are supposed to be drawn and FALSE
// otherwise. Note that when the drawing was not initiated by the windowing
// system this function will return TRUE for all windows, so you need to draw
// the bottommost window first. Also, do not use “else if” statements to check
// which window should be drawn.
//
// The function takes the following parameters:
//
//    - cr: cairo context.
//    - window to check. window may not be an input-only window.
//
// The function returns the following values:
//
//    - ok: TRUE if window should be drawn.
//
func CairoShouldDrawWindow(cr *cairo.Context, window gdk.Windower) bool {
	var _arg1 *C.cairo_t   // out
	var _arg2 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_cairo_should_draw_window(_arg1, _arg2)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CairoTransformToWindow transforms the given cairo context cr that from
// widget-relative coordinates to window-relative coordinates. If the widget’s
// window is not an ancestor of window, no modification will be applied.
//
// This is the inverse to the transformation GTK applies when preparing an
// expose event to be emitted with the Widget::draw signal. It is intended to
// help porting multiwindow widgets from GTK+ 2 to the rendering architecture of
// GTK+ 3.
//
// The function takes the following parameters:
//
//    - cr: cairo context to transform.
//    - widget the context is currently centered for.
//    - window to transform the context to.
//
func CairoTransformToWindow(cr *cairo.Context, widget Widgetter, window gdk.Windower) {
	var _arg1 *C.cairo_t   // out
	var _arg2 *C.GtkWidget // out
	var _arg3 *C.GdkWindow // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_cairo_transform_to_window(_arg1, _arg2, _arg3)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(window)
}

// WidgetOverrider contains methods that are overridable.
type WidgetOverrider interface {
	// The function takes the following parameters:
	//
	AdjustBaselineAllocation(baseline *int32)
	// The function takes the following parameters:
	//
	//    - minimumBaseline
	//    - naturalBaseline
	//
	AdjustBaselineRequest(minimumBaseline, naturalBaseline *int32)
	// The function takes the following parameters:
	//
	//    - orientation
	//    - minimumSize
	//    - naturalSize
	//    - allocatedPos
	//    - allocatedSize
	//
	AdjustSizeAllocation(orientation Orientation, minimumSize, naturalSize, allocatedPos, allocatedSize *int32)
	// The function takes the following parameters:
	//
	//    - orientation
	//    - minimumSize
	//    - naturalSize
	//
	AdjustSizeRequest(orientation Orientation, minimumSize, naturalSize *int32)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ButtonPressEvent(event *gdk.EventButton) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ButtonReleaseEvent(event *gdk.EventButton) bool
	// CanActivateAccel determines whether an accelerator that activates the
	// signal identified by signal_id can currently be activated. This is done
	// by emitting the Widget::can-activate-accel signal on widget; if the
	// signal isn’t overridden by a handler or in a derived widget, then the
	// default check is that the widget must be sensitive, and the widget and
	// all its ancestors mapped.
	//
	// The function takes the following parameters:
	//
	//    - signalId: ID of a signal installed on widget.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the accelerator can be activated.
	//
	CanActivateAccel(signalId uint32) bool
	CompositedChanged()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ConfigureEvent(event *gdk.EventConfigure) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DamageEvent(event *gdk.EventExpose) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DeleteEvent(event *gdk.EventAny) bool
	// Destroy destroys a widget.
	//
	// When a widget is destroyed all references it holds on other objects will
	// be released:
	//
	//    - if the widget is inside a container, it will be removed from its
	//    parent
	//    - if the widget is a container, all its children will be destroyed,
	//    recursively
	//    - if the widget is a top level, it will be removed from the list
	//    of top level widgets that GTK+ maintains internally
	//
	// It's expected that all references held on the widget will also be
	// released; you should connect to the Widget::destroy signal if you hold a
	// reference to widget and you wish to remove it when this function is
	// called. It is not necessary to do so if you are implementing a Container,
	// as you'll be able to use the ContainerClass.remove() virtual function for
	// that.
	//
	// It's important to notice that gtk_widget_destroy() will only cause the
	// widget to be finalized if no additional references, acquired using
	// g_object_ref(), are held on it. In case additional references are in
	// place, the widget will be in an "inert" state after calling this
	// function; widget will still point to valid memory, allowing you to
	// release the references you hold, but you may not query the widget's own
	// state.
	//
	// You should typically call this function on top level widgets, and rarely
	// on child widgets.
	//
	// See also: gtk_container_remove().
	Destroy()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DestroyEvent(event *gdk.EventAny) bool
	// The function takes the following parameters:
	//
	DirectionChanged(previousDirection TextDirection)
	// The function takes the following parameters:
	//
	DragBegin(context *gdk.DragContext)
	// The function takes the following parameters:
	//
	DragDataDelete(context *gdk.DragContext)
	// The function takes the following parameters:
	//
	//    - context
	//    - selectionData
	//    - info
	//    - time_
	//
	DragDataGet(context *gdk.DragContext, selectionData *SelectionData, info, time_ uint32)
	// The function takes the following parameters:
	//
	//    - context
	//    - x
	//    - y
	//    - selectionData
	//    - info
	//    - time_
	//
	DragDataReceived(context *gdk.DragContext, x, y int32, selectionData *SelectionData, info, time_ uint32)
	// The function takes the following parameters:
	//
	//    - context
	//    - x
	//    - y
	//    - time_
	//
	// The function returns the following values:
	//
	DragDrop(context *gdk.DragContext, x, y int32, time_ uint32) bool
	// The function takes the following parameters:
	//
	DragEnd(context *gdk.DragContext)
	// The function takes the following parameters:
	//
	//    - context
	//    - result
	//
	// The function returns the following values:
	//
	DragFailed(context *gdk.DragContext, result DragResult) bool
	// The function takes the following parameters:
	//
	//    - context
	//    - time_
	//
	DragLeave(context *gdk.DragContext, time_ uint32)
	// The function takes the following parameters:
	//
	//    - context
	//    - x
	//    - y
	//    - time_
	//
	// The function returns the following values:
	//
	DragMotion(context *gdk.DragContext, x, y int32, time_ uint32) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Draw(cr *cairo.Context) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	EnterNotifyEvent(event *gdk.EventCrossing) bool
	// Event: rarely-used function. This function is used to emit the event
	// signals on a widget (those signals should never be emitted without using
	// this function to do so). If you want to synthesize an event though, don’t
	// use this function; instead, use gtk_main_do_event() so the event will
	// behave as if it were in the event queue. Don’t synthesize expose events;
	// instead, use gdk_window_invalidate_rect() to invalidate a region of the
	// window.
	//
	// The function takes the following parameters:
	//
	//    - event: Event.
	//
	// The function returns the following values:
	//
	//    - ok: return from the event signal emission (TRUE if the event was
	//      handled).
	//
	Event(event *gdk.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Focus(direction DirectionType) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	FocusInEvent(event *gdk.EventFocus) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	FocusOutEvent(event *gdk.EventFocus) bool
	// Accessible returns the accessible object that describes the widget to an
	// assistive technology.
	//
	// If accessibility support is not available, this Object instance may be a
	// no-op. Likewise, if no class-specific Object implementation is available
	// for the widget instance in question, it will inherit an Object
	// implementation from the first ancestor class for which such an
	// implementation is defined.
	//
	// The documentation of the ATK (http://developer.gnome.org/atk/stable/)
	// library contains more information about accessible objects and their
	// uses.
	//
	// The function returns the following values:
	//
	//    - object associated with widget.
	//
	Accessible() *atk.ObjectClass
	// PreferredHeight retrieves a widget’s initial minimum and natural height.
	//
	// This call is specific to width-for-height requests.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location to store the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location to store the natural height, or
	//      NULL.
	//
	PreferredHeight() (minimumHeight, naturalHeight int32)
	// PreferredHeightAndBaselineForWidth retrieves a widget’s minimum and
	// natural height and the corresponding baselines if it would be given the
	// specified width, or the default height if width is -1. The baselines may
	// be -1 which means that no baseline is requested for this widget.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request and
	// GtkWidgetClass::adjust_baseline_request virtual methods and by any
	// SizeGroups that have been applied. That is, the returned request is the
	// one that should be used for layout, not necessarily the one returned by
	// the widget itself.
	//
	// The function takes the following parameters:
	//
	//    - width which is available for allocation, or -1 if none.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location for storing the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location for storing the natural height, or
	//      NULL.
	//    - minimumBaseline (optional): location for storing the baseline for the
	//      minimum height, or NULL.
	//    - naturalBaseline (optional): location for storing the baseline for the
	//      natural height, or NULL.
	//
	PreferredHeightAndBaselineForWidth(width int32) (minimumHeight, naturalHeight, minimumBaseline, naturalBaseline int32)
	// PreferredHeightForWidth retrieves a widget’s minimum and natural height
	// if it would be given the specified width.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	//
	// The function takes the following parameters:
	//
	//    - width which is available for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location for storing the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location for storing the natural height, or
	//      NULL.
	//
	PreferredHeightForWidth(width int32) (minimumHeight, naturalHeight int32)
	// PreferredWidth retrieves a widget’s initial minimum and natural width.
	//
	// This call is specific to height-for-width requests.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location to store the minimum width, or
	//      NULL.
	//    - naturalWidth (optional): location to store the natural width, or
	//      NULL.
	//
	PreferredWidth() (minimumWidth, naturalWidth int32)
	// PreferredWidthForHeight retrieves a widget’s minimum and natural width if
	// it would be given the specified height.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	//
	// The function takes the following parameters:
	//
	//    - height which is available for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location for storing the minimum width, or
	//      NULL.
	//    - naturalWidth (optional): location for storing the natural width, or
	//      NULL.
	//
	PreferredWidthForHeight(height int32) (minimumWidth, naturalWidth int32)
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Bin widgets generally propagate the preference of their child, container
	// widgets need to request something either in context of their children or
	// in context of their allocation capabilities.
	//
	// The function returns the following values:
	//
	//    - sizeRequestMode preferred by widget.
	//
	RequestMode() SizeRequestMode
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	GrabBrokenEvent(event *gdk.EventGrabBroken) bool
	// GrabFocus causes widget to have the keyboard focus for the Window it's
	// inside. widget must be a focusable widget, such as a Entry; something
	// like Frame won’t work.
	//
	// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
	// gtk_widget_set_can_focus() to modify that flag.
	//
	// The widget also needs to be realized and mapped. This is indicated by the
	// related signals. Grabbing the focus immediately after creating the widget
	// will likely fail and cause critical warnings.
	GrabFocus()
	// The function takes the following parameters:
	//
	GrabNotify(wasGrabbed bool)
	// Hide reverses the effects of gtk_widget_show(), causing the widget to be
	// hidden (invisible to the user).
	Hide()
	// The function takes the following parameters:
	//
	HierarchyChanged(previousToplevel Widgetter)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	KeyPressEvent(event *gdk.EventKey) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	KeyReleaseEvent(event *gdk.EventKey) bool
	// KeynavFailed: this function should be called whenever keyboard navigation
	// within a single widget hits a boundary. The function emits the
	// Widget::keynav-failed signal on the widget and its return value should be
	// interpreted in a way similar to the return value of
	// gtk_widget_child_focus():
	//
	// When TRUE is returned, stay in the widget, the failed keyboard navigation
	// is OK and/or there is nowhere we can/should move the focus to.
	//
	// When FALSE is returned, the caller should continue with keyboard
	// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
	// on the widget’s toplevel.
	//
	// The default ::keynav-failed handler returns FALSE for GTK_DIR_TAB_FORWARD
	// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
	// returns TRUE.
	//
	// Whenever the default handler returns TRUE, it also calls
	// gtk_widget_error_bell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of Entry widgets
	// where the user should be able to navigate the entire row with the cursor
	// keys, as e.g. known from user interfaces that require entering license
	// keys.
	//
	// The function takes the following parameters:
	//
	//    - direction of focus movement.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if stopping keyboard navigation is fine, FALSE if the
	//      emitting widget should try to handle the keyboard navigation attempt
	//      in its parent container(s).
	//
	KeynavFailed(direction DirectionType) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	LeaveNotifyEvent(event *gdk.EventCrossing) bool
	// Map: this function is only for use in widget implementations. Causes a
	// widget to be mapped if it isn’t already.
	Map()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	MapEvent(event *gdk.EventAny) bool
	// MnemonicActivate emits the Widget::mnemonic-activate signal.
	//
	// The function takes the following parameters:
	//
	//    - groupCycling: TRUE if there are other widgets with the same mnemonic.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the signal has been handled.
	//
	MnemonicActivate(groupCycling bool) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	MotionNotifyEvent(event *gdk.EventMotion) bool
	// The function takes the following parameters:
	//
	MoveFocus(direction DirectionType)
	// The function takes the following parameters:
	//
	ParentSet(previousParent Widgetter)
	// The function returns the following values:
	//
	PopupMenu() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	PropertyNotifyEvent(event *gdk.EventProperty) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProximityInEvent(event *gdk.EventProximity) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProximityOutEvent(event *gdk.EventProximity) bool
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - keyboardTooltip
	//    - tooltip
	//
	// The function returns the following values:
	//
	QueryTooltip(x, y int32, keyboardTooltip bool, tooltip *Tooltip) bool
	// QueueDrawRegion invalidates the area of widget defined by region by
	// calling gdk_window_invalidate_region() on the widget’s window and all its
	// child windows. Once the main loop becomes idle (after the current batch
	// of events has been processed, roughly), the window will receive expose
	// events for the union of all regions that have been invalidated.
	//
	// Normally you would only use this function in widget implementations. You
	// might also use it to schedule a redraw of a DrawingArea or some portion
	// thereof.
	//
	// The function takes the following parameters:
	//
	//    - region to draw.
	//
	QueueDrawRegion(region *cairo.Region)
	// Realize creates the GDK (windowing system) resources associated with a
	// widget. For example, widget->window will be created when a widget is
	// realized. Normally realization happens implicitly; if you show a widget
	// and all its parent containers, then the widget will be realized and
	// mapped automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling gtk_widget_realize() realizes the widget’s parents in
	// addition to widget itself. If a widget is not yet inside a toplevel
	// window when you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as Widget::draw. Or simply
	// g_signal_connect () to the Widget::realize signal.
	Realize()
	// The function takes the following parameters:
	//
	ScreenChanged(previousScreen *gdk.Screen)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ScrollEvent(event *gdk.EventScroll) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SelectionClearEvent(event *gdk.EventSelection) bool
	// The function takes the following parameters:
	//
	//    - selectionData
	//    - info
	//    - time_
	//
	SelectionGet(selectionData *SelectionData, info, time_ uint32)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SelectionNotifyEvent(event *gdk.EventSelection) bool
	// The function takes the following parameters:
	//
	//    - selectionData
	//    - time_
	//
	SelectionReceived(selectionData *SelectionData, time_ uint32)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SelectionRequestEvent(event *gdk.EventSelection) bool
	// Show flags a widget to be displayed. Any widget that isn’t shown will not
	// appear on the screen. If you want to show all the widgets in a container,
	// it’s easier to call gtk_widget_show_all() on the container, instead of
	// individually showing the widgets.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show()
	// ShowAll: recursively shows a widget, and any child widgets (if the widget
	// is a container).
	ShowAll()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ShowHelp(helpType WidgetHelpType) bool
	// SizeAllocate: this function is only used by Container subclasses, to
	// assign a size and position to their child widgets.
	//
	// In this function, the allocation may be adjusted. It will be forced to a
	// 1x1 minimum size, and the adjust_size_allocation virtual method on the
	// child will be used to adjust the allocation. Standard adjustments include
	// removing the widget’s margins, and applying the widget’s Widget:halign
	// and Widget:valign properties.
	//
	// For baseline support in containers you need to use
	// gtk_widget_size_allocate_with_baseline() instead.
	//
	// The function takes the following parameters:
	//
	//    - allocation: position and size to be allocated to widget.
	//
	SizeAllocate(allocation *Allocation)
	// The function takes the following parameters:
	//
	StateChanged(previousState StateType)
	// The function takes the following parameters:
	//
	StateFlagsChanged(previousStateFlags StateFlags)
	// The function takes the following parameters:
	//
	StyleSet(previousStyle *Style)
	StyleUpdated()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	TouchEvent(event *gdk.EventTouch) bool
	// Unmap: this function is only for use in widget implementations. Causes a
	// widget to be unmapped if it’s currently mapped.
	Unmap()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	UnmapEvent(event *gdk.EventAny) bool
	// Unrealize: this function is only useful in widget implementations. Causes
	// a widget to be unrealized (frees all GDK resources associated with the
	// widget, such as widget->window).
	Unrealize()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	VisibilityNotifyEvent(event *gdk.EventVisibility) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	WindowStateEvent(event *gdk.EventWindowState) bool
}

// Widget is the base class all widgets in GTK+ derive from. It manages the
// widget lifecycle, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK+ by way of five
// virtual methods:
//
// - WidgetClass.get_request_mode()
//
// - WidgetClass.get_preferred_width()
//
// - WidgetClass.get_preferred_height()
//
// - WidgetClass.get_preferred_height_for_width()
//
// - WidgetClass.get_preferred_width_for_height()
//
// - WidgetClass.get_preferred_height_and_baseline_for_width()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in container implementations.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_get_preferred_width(). Because
// the preferred widths for each container depend on the preferred widths of
// their children, this information propagates up the hierarchy, and finally a
// minimum and natural width is determined for the entire toplevel. Next, the
// toplevel will use the minimum width to query for the minimum height
// contextual to that width using gtk_widget_get_preferred_height_for_width(),
// which will also be a highly recursive operation. The minimum height for the
// minimum width is normally used to set the minimum size constraint on the
// toplevel (unless gtk_window_set_geometry_hints() is explicitly used instead).
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while container widgets allocate their children. Each
// container widget, once allocated a size, will go on to first share the space
// in one orientation among its children and then request each child's height
// for its target allocated width or its width for allocated height, depending.
// In this way a Widget will typically be requested its size a number of times
// before actually being allocated a size. The size a widget is finally
// allocated can of course differ from the size it has requested. For this
// reason, Widget caches a small number of results to avoid re-querying for the
// same sizes in one allocation cycle.
//
// See [GtkContainer’s geometry management
// section][container-geometry-management] to learn more about how
// height-for-width allocations are performed by container widgets.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.get_preferred_height() called because that call is
// specific to a width-for-height request. In this case the label must return
// the height required for its own minimum possible width. By following this
// rule any widget that handles height-for-width or width-for-height requests
// will always be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests, for
// WidgetClass.get_preferred_height() it will do:
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }.
type Widget struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned

	*coreglib.Object
	atk.ImplementorIface
	Buildable
}

var (
	_ coreglib.Objector = (*Widget)(nil)
)

// Widgetter describes types inherited from class Widget.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Widgetter interface {
	coreglib.Objector
	baseWidget() *Widget
}

var _ Widgetter = (*Widget)(nil)

func classInitWidgetter(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkWidgetClass)(unsafe.Pointer(gclassPtr))

	if _, ok := goval.(interface{ AdjustBaselineAllocation(baseline *int32) }); ok {
		pclass.adjust_baseline_allocation = (*[0]byte)(C._gotk4_gtk3_WidgetClass_adjust_baseline_allocation)
	}

	if _, ok := goval.(interface {
		AdjustBaselineRequest(minimumBaseline, naturalBaseline *int32)
	}); ok {
		pclass.adjust_baseline_request = (*[0]byte)(C._gotk4_gtk3_WidgetClass_adjust_baseline_request)
	}

	if _, ok := goval.(interface {
		AdjustSizeAllocation(orientation Orientation, minimumSize, naturalSize, allocatedPos, allocatedSize *int32)
	}); ok {
		pclass.adjust_size_allocation = (*[0]byte)(C._gotk4_gtk3_WidgetClass_adjust_size_allocation)
	}

	if _, ok := goval.(interface {
		AdjustSizeRequest(orientation Orientation, minimumSize, naturalSize *int32)
	}); ok {
		pclass.adjust_size_request = (*[0]byte)(C._gotk4_gtk3_WidgetClass_adjust_size_request)
	}

	if _, ok := goval.(interface {
		ButtonPressEvent(event *gdk.EventButton) bool
	}); ok {
		pclass.button_press_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_button_press_event)
	}

	if _, ok := goval.(interface {
		ButtonReleaseEvent(event *gdk.EventButton) bool
	}); ok {
		pclass.button_release_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_button_release_event)
	}

	if _, ok := goval.(interface{ CanActivateAccel(signalId uint32) bool }); ok {
		pclass.can_activate_accel = (*[0]byte)(C._gotk4_gtk3_WidgetClass_can_activate_accel)
	}

	if _, ok := goval.(interface{ CompositedChanged() }); ok {
		pclass.composited_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_composited_changed)
	}

	if _, ok := goval.(interface {
		ConfigureEvent(event *gdk.EventConfigure) bool
	}); ok {
		pclass.configure_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_configure_event)
	}

	if _, ok := goval.(interface {
		DamageEvent(event *gdk.EventExpose) bool
	}); ok {
		pclass.damage_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_damage_event)
	}

	if _, ok := goval.(interface {
		DeleteEvent(event *gdk.EventAny) bool
	}); ok {
		pclass.delete_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_delete_event)
	}

	if _, ok := goval.(interface{ Destroy() }); ok {
		pclass.destroy = (*[0]byte)(C._gotk4_gtk3_WidgetClass_destroy)
	}

	if _, ok := goval.(interface {
		DestroyEvent(event *gdk.EventAny) bool
	}); ok {
		pclass.destroy_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_destroy_event)
	}

	if _, ok := goval.(interface {
		DirectionChanged(previousDirection TextDirection)
	}); ok {
		pclass.direction_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_direction_changed)
	}

	if _, ok := goval.(interface {
		DragBegin(context *gdk.DragContext)
	}); ok {
		pclass.drag_begin = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_begin)
	}

	if _, ok := goval.(interface {
		DragDataDelete(context *gdk.DragContext)
	}); ok {
		pclass.drag_data_delete = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_data_delete)
	}

	if _, ok := goval.(interface {
		DragDataGet(context *gdk.DragContext, selectionData *SelectionData, info, time_ uint32)
	}); ok {
		pclass.drag_data_get = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_data_get)
	}

	if _, ok := goval.(interface {
		DragDataReceived(context *gdk.DragContext, x, y int32, selectionData *SelectionData, info, time_ uint32)
	}); ok {
		pclass.drag_data_received = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_data_received)
	}

	if _, ok := goval.(interface {
		DragDrop(context *gdk.DragContext, x, y int32, time_ uint32) bool
	}); ok {
		pclass.drag_drop = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_drop)
	}

	if _, ok := goval.(interface {
		DragEnd(context *gdk.DragContext)
	}); ok {
		pclass.drag_end = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_end)
	}

	if _, ok := goval.(interface {
		DragFailed(context *gdk.DragContext, result DragResult) bool
	}); ok {
		pclass.drag_failed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_failed)
	}

	if _, ok := goval.(interface {
		DragLeave(context *gdk.DragContext, time_ uint32)
	}); ok {
		pclass.drag_leave = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_leave)
	}

	if _, ok := goval.(interface {
		DragMotion(context *gdk.DragContext, x, y int32, time_ uint32) bool
	}); ok {
		pclass.drag_motion = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_motion)
	}

	if _, ok := goval.(interface{ Draw(cr *cairo.Context) bool }); ok {
		pclass.draw = (*[0]byte)(C._gotk4_gtk3_WidgetClass_draw)
	}

	if _, ok := goval.(interface {
		EnterNotifyEvent(event *gdk.EventCrossing) bool
	}); ok {
		pclass.enter_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_enter_notify_event)
	}

	if _, ok := goval.(interface{ Event(event *gdk.Event) bool }); ok {
		pclass.event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_event)
	}

	if _, ok := goval.(interface {
		Focus(direction DirectionType) bool
	}); ok {
		pclass.focus = (*[0]byte)(C._gotk4_gtk3_WidgetClass_focus)
	}

	if _, ok := goval.(interface {
		FocusInEvent(event *gdk.EventFocus) bool
	}); ok {
		pclass.focus_in_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_focus_in_event)
	}

	if _, ok := goval.(interface {
		FocusOutEvent(event *gdk.EventFocus) bool
	}); ok {
		pclass.focus_out_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_focus_out_event)
	}

	if _, ok := goval.(interface{ Accessible() *atk.ObjectClass }); ok {
		pclass.get_accessible = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_accessible)
	}

	if _, ok := goval.(interface {
		PreferredHeight() (minimumHeight, naturalHeight int32)
	}); ok {
		pclass.get_preferred_height = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_height)
	}

	if _, ok := goval.(interface {
		PreferredHeightAndBaselineForWidth(width int32) (minimumHeight, naturalHeight, minimumBaseline, naturalBaseline int32)
	}); ok {
		pclass.get_preferred_height_and_baseline_for_width = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width)
	}

	if _, ok := goval.(interface {
		PreferredHeightForWidth(width int32) (minimumHeight, naturalHeight int32)
	}); ok {
		pclass.get_preferred_height_for_width = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_height_for_width)
	}

	if _, ok := goval.(interface {
		PreferredWidth() (minimumWidth, naturalWidth int32)
	}); ok {
		pclass.get_preferred_width = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_width)
	}

	if _, ok := goval.(interface {
		PreferredWidthForHeight(height int32) (minimumWidth, naturalWidth int32)
	}); ok {
		pclass.get_preferred_width_for_height = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_width_for_height)
	}

	if _, ok := goval.(interface{ RequestMode() SizeRequestMode }); ok {
		pclass.get_request_mode = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_request_mode)
	}

	if _, ok := goval.(interface {
		GrabBrokenEvent(event *gdk.EventGrabBroken) bool
	}); ok {
		pclass.grab_broken_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_grab_broken_event)
	}

	if _, ok := goval.(interface{ GrabFocus() }); ok {
		pclass.grab_focus = (*[0]byte)(C._gotk4_gtk3_WidgetClass_grab_focus)
	}

	if _, ok := goval.(interface{ GrabNotify(wasGrabbed bool) }); ok {
		pclass.grab_notify = (*[0]byte)(C._gotk4_gtk3_WidgetClass_grab_notify)
	}

	if _, ok := goval.(interface{ Hide() }); ok {
		pclass.hide = (*[0]byte)(C._gotk4_gtk3_WidgetClass_hide)
	}

	if _, ok := goval.(interface {
		HierarchyChanged(previousToplevel Widgetter)
	}); ok {
		pclass.hierarchy_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_hierarchy_changed)
	}

	if _, ok := goval.(interface {
		KeyPressEvent(event *gdk.EventKey) bool
	}); ok {
		pclass.key_press_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_key_press_event)
	}

	if _, ok := goval.(interface {
		KeyReleaseEvent(event *gdk.EventKey) bool
	}); ok {
		pclass.key_release_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_key_release_event)
	}

	if _, ok := goval.(interface {
		KeynavFailed(direction DirectionType) bool
	}); ok {
		pclass.keynav_failed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_keynav_failed)
	}

	if _, ok := goval.(interface {
		LeaveNotifyEvent(event *gdk.EventCrossing) bool
	}); ok {
		pclass.leave_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_leave_notify_event)
	}

	if _, ok := goval.(interface{ Map() }); ok {
		pclass._map = (*[0]byte)(C._gotk4_gtk3_WidgetClass_map)
	}

	if _, ok := goval.(interface {
		MapEvent(event *gdk.EventAny) bool
	}); ok {
		pclass.map_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_map_event)
	}

	if _, ok := goval.(interface{ MnemonicActivate(groupCycling bool) bool }); ok {
		pclass.mnemonic_activate = (*[0]byte)(C._gotk4_gtk3_WidgetClass_mnemonic_activate)
	}

	if _, ok := goval.(interface {
		MotionNotifyEvent(event *gdk.EventMotion) bool
	}); ok {
		pclass.motion_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_motion_notify_event)
	}

	if _, ok := goval.(interface{ MoveFocus(direction DirectionType) }); ok {
		pclass.move_focus = (*[0]byte)(C._gotk4_gtk3_WidgetClass_move_focus)
	}

	if _, ok := goval.(interface {
		ParentSet(previousParent Widgetter)
	}); ok {
		pclass.parent_set = (*[0]byte)(C._gotk4_gtk3_WidgetClass_parent_set)
	}

	if _, ok := goval.(interface{ PopupMenu() bool }); ok {
		pclass.popup_menu = (*[0]byte)(C._gotk4_gtk3_WidgetClass_popup_menu)
	}

	if _, ok := goval.(interface {
		PropertyNotifyEvent(event *gdk.EventProperty) bool
	}); ok {
		pclass.property_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_property_notify_event)
	}

	if _, ok := goval.(interface {
		ProximityInEvent(event *gdk.EventProximity) bool
	}); ok {
		pclass.proximity_in_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_proximity_in_event)
	}

	if _, ok := goval.(interface {
		ProximityOutEvent(event *gdk.EventProximity) bool
	}); ok {
		pclass.proximity_out_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_proximity_out_event)
	}

	if _, ok := goval.(interface {
		QueryTooltip(x, y int32, keyboardTooltip bool, tooltip *Tooltip) bool
	}); ok {
		pclass.query_tooltip = (*[0]byte)(C._gotk4_gtk3_WidgetClass_query_tooltip)
	}

	if _, ok := goval.(interface{ QueueDrawRegion(region *cairo.Region) }); ok {
		pclass.queue_draw_region = (*[0]byte)(C._gotk4_gtk3_WidgetClass_queue_draw_region)
	}

	if _, ok := goval.(interface{ Realize() }); ok {
		pclass.realize = (*[0]byte)(C._gotk4_gtk3_WidgetClass_realize)
	}

	if _, ok := goval.(interface {
		ScreenChanged(previousScreen *gdk.Screen)
	}); ok {
		pclass.screen_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_screen_changed)
	}

	if _, ok := goval.(interface {
		ScrollEvent(event *gdk.EventScroll) bool
	}); ok {
		pclass.scroll_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_scroll_event)
	}

	if _, ok := goval.(interface {
		SelectionClearEvent(event *gdk.EventSelection) bool
	}); ok {
		pclass.selection_clear_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_clear_event)
	}

	if _, ok := goval.(interface {
		SelectionGet(selectionData *SelectionData, info, time_ uint32)
	}); ok {
		pclass.selection_get = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_get)
	}

	if _, ok := goval.(interface {
		SelectionNotifyEvent(event *gdk.EventSelection) bool
	}); ok {
		pclass.selection_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_notify_event)
	}

	if _, ok := goval.(interface {
		SelectionReceived(selectionData *SelectionData, time_ uint32)
	}); ok {
		pclass.selection_received = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_received)
	}

	if _, ok := goval.(interface {
		SelectionRequestEvent(event *gdk.EventSelection) bool
	}); ok {
		pclass.selection_request_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_request_event)
	}

	if _, ok := goval.(interface{ Show() }); ok {
		pclass.show = (*[0]byte)(C._gotk4_gtk3_WidgetClass_show)
	}

	if _, ok := goval.(interface{ ShowAll() }); ok {
		pclass.show_all = (*[0]byte)(C._gotk4_gtk3_WidgetClass_show_all)
	}

	if _, ok := goval.(interface {
		ShowHelp(helpType WidgetHelpType) bool
	}); ok {
		pclass.show_help = (*[0]byte)(C._gotk4_gtk3_WidgetClass_show_help)
	}

	if _, ok := goval.(interface{ SizeAllocate(allocation *Allocation) }); ok {
		pclass.size_allocate = (*[0]byte)(C._gotk4_gtk3_WidgetClass_size_allocate)
	}

	if _, ok := goval.(interface{ StateChanged(previousState StateType) }); ok {
		pclass.state_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_state_changed)
	}

	if _, ok := goval.(interface {
		StateFlagsChanged(previousStateFlags StateFlags)
	}); ok {
		pclass.state_flags_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_state_flags_changed)
	}

	if _, ok := goval.(interface{ StyleSet(previousStyle *Style) }); ok {
		pclass.style_set = (*[0]byte)(C._gotk4_gtk3_WidgetClass_style_set)
	}

	if _, ok := goval.(interface{ StyleUpdated() }); ok {
		pclass.style_updated = (*[0]byte)(C._gotk4_gtk3_WidgetClass_style_updated)
	}

	if _, ok := goval.(interface {
		TouchEvent(event *gdk.EventTouch) bool
	}); ok {
		pclass.touch_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_touch_event)
	}

	if _, ok := goval.(interface{ Unmap() }); ok {
		pclass.unmap = (*[0]byte)(C._gotk4_gtk3_WidgetClass_unmap)
	}

	if _, ok := goval.(interface {
		UnmapEvent(event *gdk.EventAny) bool
	}); ok {
		pclass.unmap_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_unmap_event)
	}

	if _, ok := goval.(interface{ Unrealize() }); ok {
		pclass.unrealize = (*[0]byte)(C._gotk4_gtk3_WidgetClass_unrealize)
	}

	if _, ok := goval.(interface {
		VisibilityNotifyEvent(event *gdk.EventVisibility) bool
	}); ok {
		pclass.visibility_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_visibility_notify_event)
	}

	if _, ok := goval.(interface {
		WindowStateEvent(event *gdk.EventWindowState) bool
	}); ok {
		pclass.window_state_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_window_state_event)
	}
}

//export _gotk4_gtk3_WidgetClass_adjust_baseline_allocation
func _gotk4_gtk3_WidgetClass_adjust_baseline_allocation(arg0 *C.GtkWidget, arg1 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ AdjustBaselineAllocation(baseline *int32) })

	var _baseline *int32 // out

	_baseline = (*int32)(unsafe.Pointer(arg1))

	iface.AdjustBaselineAllocation(_baseline)
}

//export _gotk4_gtk3_WidgetClass_adjust_baseline_request
func _gotk4_gtk3_WidgetClass_adjust_baseline_request(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		AdjustBaselineRequest(minimumBaseline, naturalBaseline *int32)
	})

	var _minimumBaseline *int32 // out
	var _naturalBaseline *int32 // out

	_minimumBaseline = (*int32)(unsafe.Pointer(arg1))
	_naturalBaseline = (*int32)(unsafe.Pointer(arg2))

	iface.AdjustBaselineRequest(_minimumBaseline, _naturalBaseline)
}

//export _gotk4_gtk3_WidgetClass_adjust_size_allocation
func _gotk4_gtk3_WidgetClass_adjust_size_allocation(arg0 *C.GtkWidget, arg1 C.GtkOrientation, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint, arg5 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		AdjustSizeAllocation(orientation Orientation, minimumSize, naturalSize, allocatedPos, allocatedSize *int32)
	})

	var _orientation Orientation // out
	var _minimumSize *int32      // out
	var _naturalSize *int32      // out
	var _allocatedPos *int32     // out
	var _allocatedSize *int32    // out

	_orientation = Orientation(arg1)
	_minimumSize = (*int32)(unsafe.Pointer(arg2))
	_naturalSize = (*int32)(unsafe.Pointer(arg3))
	_allocatedPos = (*int32)(unsafe.Pointer(arg4))
	_allocatedSize = (*int32)(unsafe.Pointer(arg5))

	iface.AdjustSizeAllocation(_orientation, _minimumSize, _naturalSize, _allocatedPos, _allocatedSize)
}

//export _gotk4_gtk3_WidgetClass_adjust_size_request
func _gotk4_gtk3_WidgetClass_adjust_size_request(arg0 *C.GtkWidget, arg1 C.GtkOrientation, arg2 *C.gint, arg3 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		AdjustSizeRequest(orientation Orientation, minimumSize, naturalSize *int32)
	})

	var _orientation Orientation // out
	var _minimumSize *int32      // out
	var _naturalSize *int32      // out

	_orientation = Orientation(arg1)
	_minimumSize = (*int32)(unsafe.Pointer(arg2))
	_naturalSize = (*int32)(unsafe.Pointer(arg3))

	iface.AdjustSizeRequest(_orientation, _minimumSize, _naturalSize)
}

//export _gotk4_gtk3_WidgetClass_button_press_event
func _gotk4_gtk3_WidgetClass_button_press_event(arg0 *C.GtkWidget, arg1 *C.GdkEventButton) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ButtonPressEvent(event *gdk.EventButton) bool
	})

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ButtonPressEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_button_release_event
func _gotk4_gtk3_WidgetClass_button_release_event(arg0 *C.GtkWidget, arg1 *C.GdkEventButton) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ButtonReleaseEvent(event *gdk.EventButton) bool
	})

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ButtonReleaseEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_can_activate_accel
func _gotk4_gtk3_WidgetClass_can_activate_accel(arg0 *C.GtkWidget, arg1 C.guint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CanActivateAccel(signalId uint32) bool })

	var _signalId uint32 // out

	_signalId = uint32(arg1)

	ok := iface.CanActivateAccel(_signalId)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_composited_changed
func _gotk4_gtk3_WidgetClass_composited_changed(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CompositedChanged() })

	iface.CompositedChanged()
}

//export _gotk4_gtk3_WidgetClass_configure_event
func _gotk4_gtk3_WidgetClass_configure_event(arg0 *C.GtkWidget, arg1 *C.GdkEventConfigure) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ConfigureEvent(event *gdk.EventConfigure) bool
	})

	var _event *gdk.EventConfigure // out

	_event = (*gdk.EventConfigure)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ConfigureEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_damage_event
func _gotk4_gtk3_WidgetClass_damage_event(arg0 *C.GtkWidget, arg1 *C.GdkEventExpose) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DamageEvent(event *gdk.EventExpose) bool
	})

	var _event *gdk.EventExpose // out

	_event = (*gdk.EventExpose)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.DamageEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_delete_event
func _gotk4_gtk3_WidgetClass_delete_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DeleteEvent(event *gdk.EventAny) bool
	})

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.DeleteEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_destroy
func _gotk4_gtk3_WidgetClass_destroy(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Destroy() })

	iface.Destroy()
}

//export _gotk4_gtk3_WidgetClass_destroy_event
func _gotk4_gtk3_WidgetClass_destroy_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DestroyEvent(event *gdk.EventAny) bool
	})

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.DestroyEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_direction_changed
func _gotk4_gtk3_WidgetClass_direction_changed(arg0 *C.GtkWidget, arg1 C.GtkTextDirection) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DirectionChanged(previousDirection TextDirection)
	})

	var _previousDirection TextDirection // out

	_previousDirection = TextDirection(arg1)

	iface.DirectionChanged(_previousDirection)
}

//export _gotk4_gtk3_WidgetClass_drag_begin
func _gotk4_gtk3_WidgetClass_drag_begin(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragBegin(context *gdk.DragContext)
	})

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	iface.DragBegin(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_data_delete
func _gotk4_gtk3_WidgetClass_drag_data_delete(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragDataDelete(context *gdk.DragContext)
	})

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	iface.DragDataDelete(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_data_get
func _gotk4_gtk3_WidgetClass_drag_data_get(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 *C.GtkSelectionData, arg3 C.guint, arg4 C.guint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragDataGet(context *gdk.DragContext, selectionData *SelectionData, info, time_ uint32)
	})

	var _context *gdk.DragContext     // out
	var _selectionData *SelectionData // out
	var _info uint32                  // out
	var _time_ uint32                 // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_info = uint32(arg3)
	_time_ = uint32(arg4)

	iface.DragDataGet(_context, _selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_data_received
func _gotk4_gtk3_WidgetClass_drag_data_received(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 *C.GtkSelectionData, arg5 C.guint, arg6 C.guint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragDataReceived(context *gdk.DragContext, x, y int32, selectionData *SelectionData, info, time_ uint32)
	})

	var _context *gdk.DragContext     // out
	var _x int32                      // out
	var _y int32                      // out
	var _selectionData *SelectionData // out
	var _info uint32                  // out
	var _time_ uint32                 // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int32(arg2)
	_y = int32(arg3)
	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_info = uint32(arg5)
	_time_ = uint32(arg6)

	iface.DragDataReceived(_context, _x, _y, _selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_drop
func _gotk4_gtk3_WidgetClass_drag_drop(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragDrop(context *gdk.DragContext, x, y int32, time_ uint32) bool
	})

	var _context *gdk.DragContext // out
	var _x int32                  // out
	var _y int32                  // out
	var _time_ uint32             // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int32(arg2)
	_y = int32(arg3)
	_time_ = uint32(arg4)

	ok := iface.DragDrop(_context, _x, _y, _time_)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_drag_end
func _gotk4_gtk3_WidgetClass_drag_end(arg0 *C.GtkWidget, arg1 *C.GdkDragContext) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragEnd(context *gdk.DragContext)
	})

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	iface.DragEnd(_context)
}

//export _gotk4_gtk3_WidgetClass_drag_failed
func _gotk4_gtk3_WidgetClass_drag_failed(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.GtkDragResult) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragFailed(context *gdk.DragContext, result DragResult) bool
	})

	var _context *gdk.DragContext // out
	var _result DragResult        // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_result = DragResult(arg2)

	ok := iface.DragFailed(_context, _result)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_drag_leave
func _gotk4_gtk3_WidgetClass_drag_leave(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.guint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragLeave(context *gdk.DragContext, time_ uint32)
	})

	var _context *gdk.DragContext // out
	var _time_ uint32             // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_time_ = uint32(arg2)

	iface.DragLeave(_context, _time_)
}

//export _gotk4_gtk3_WidgetClass_drag_motion
func _gotk4_gtk3_WidgetClass_drag_motion(arg0 *C.GtkWidget, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DragMotion(context *gdk.DragContext, x, y int32, time_ uint32) bool
	})

	var _context *gdk.DragContext // out
	var _x int32                  // out
	var _y int32                  // out
	var _time_ uint32             // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int32(arg2)
	_y = int32(arg3)
	_time_ = uint32(arg4)

	ok := iface.DragMotion(_context, _x, _y, _time_)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_draw
func _gotk4_gtk3_WidgetClass_draw(arg0 *C.GtkWidget, arg1 *C.cairo_t) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Draw(cr *cairo.Context) bool })

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	ok := iface.Draw(_cr)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_enter_notify_event
func _gotk4_gtk3_WidgetClass_enter_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventCrossing) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		EnterNotifyEvent(event *gdk.EventCrossing) bool
	})

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.EnterNotifyEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_event
func _gotk4_gtk3_WidgetClass_event(arg0 *C.GtkWidget, arg1 *C.GdkEvent) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Event(event *gdk.Event) bool })

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer(arg1)))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := iface.Event(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus
func _gotk4_gtk3_WidgetClass_focus(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Focus(direction DirectionType) bool
	})

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := iface.Focus(_direction)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus_in_event
func _gotk4_gtk3_WidgetClass_focus_in_event(arg0 *C.GtkWidget, arg1 *C.GdkEventFocus) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		FocusInEvent(event *gdk.EventFocus) bool
	})

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.FocusInEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_focus_out_event
func _gotk4_gtk3_WidgetClass_focus_out_event(arg0 *C.GtkWidget, arg1 *C.GdkEventFocus) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		FocusOutEvent(event *gdk.EventFocus) bool
	})

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.FocusOutEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_get_accessible
func _gotk4_gtk3_WidgetClass_get_accessible(arg0 *C.GtkWidget) (cret *C.AtkObject) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Accessible() *atk.ObjectClass })

	object := iface.Accessible()

	cret = (*C.AtkObject)(unsafe.Pointer(coreglib.InternObject(object).Native()))

	return cret
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height
func _gotk4_gtk3_WidgetClass_get_preferred_height(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeight() (minimumHeight, naturalHeight int32)
	})

	minimumHeight, naturalHeight := iface.PreferredHeight()

	*arg1 = C.gint(minimumHeight)
	*arg2 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width
func _gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint, arg4 *C.gint, arg5 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeightAndBaselineForWidth(width int32) (minimumHeight, naturalHeight, minimumBaseline, naturalBaseline int32)
	})

	var _width int32 // out

	_width = int32(arg1)

	minimumHeight, naturalHeight, minimumBaseline, naturalBaseline := iface.PreferredHeightAndBaselineForWidth(_width)

	*arg2 = C.gint(minimumHeight)
	*arg3 = C.gint(naturalHeight)
	*arg4 = C.gint(minimumBaseline)
	*arg5 = C.gint(naturalBaseline)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_height_for_width
func _gotk4_gtk3_WidgetClass_get_preferred_height_for_width(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeightForWidth(width int32) (minimumHeight, naturalHeight int32)
	})

	var _width int32 // out

	_width = int32(arg1)

	minimumHeight, naturalHeight := iface.PreferredHeightForWidth(_width)

	*arg2 = C.gint(minimumHeight)
	*arg3 = C.gint(naturalHeight)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_width
func _gotk4_gtk3_WidgetClass_get_preferred_width(arg0 *C.GtkWidget, arg1 *C.gint, arg2 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredWidth() (minimumWidth, naturalWidth int32)
	})

	minimumWidth, naturalWidth := iface.PreferredWidth()

	*arg1 = C.gint(minimumWidth)
	*arg2 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_WidgetClass_get_preferred_width_for_height
func _gotk4_gtk3_WidgetClass_get_preferred_width_for_height(arg0 *C.GtkWidget, arg1 C.gint, arg2 *C.gint, arg3 *C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredWidthForHeight(height int32) (minimumWidth, naturalWidth int32)
	})

	var _height int32 // out

	_height = int32(arg1)

	minimumWidth, naturalWidth := iface.PreferredWidthForHeight(_height)

	*arg2 = C.gint(minimumWidth)
	*arg3 = C.gint(naturalWidth)
}

//export _gotk4_gtk3_WidgetClass_get_request_mode
func _gotk4_gtk3_WidgetClass_get_request_mode(arg0 *C.GtkWidget) (cret C.GtkSizeRequestMode) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ RequestMode() SizeRequestMode })

	sizeRequestMode := iface.RequestMode()

	cret = C.GtkSizeRequestMode(sizeRequestMode)

	return cret
}

//export _gotk4_gtk3_WidgetClass_grab_broken_event
func _gotk4_gtk3_WidgetClass_grab_broken_event(arg0 *C.GtkWidget, arg1 *C.GdkEventGrabBroken) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		GrabBrokenEvent(event *gdk.EventGrabBroken) bool
	})

	var _event *gdk.EventGrabBroken // out

	_event = (*gdk.EventGrabBroken)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.GrabBrokenEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_grab_focus
func _gotk4_gtk3_WidgetClass_grab_focus(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ GrabFocus() })

	iface.GrabFocus()
}

//export _gotk4_gtk3_WidgetClass_grab_notify
func _gotk4_gtk3_WidgetClass_grab_notify(arg0 *C.GtkWidget, arg1 C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ GrabNotify(wasGrabbed bool) })

	var _wasGrabbed bool // out

	if arg1 != 0 {
		_wasGrabbed = true
	}

	iface.GrabNotify(_wasGrabbed)
}

//export _gotk4_gtk3_WidgetClass_hide
func _gotk4_gtk3_WidgetClass_hide(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Hide() })

	iface.Hide()
}

//export _gotk4_gtk3_WidgetClass_hierarchy_changed
func _gotk4_gtk3_WidgetClass_hierarchy_changed(arg0 *C.GtkWidget, arg1 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		HierarchyChanged(previousToplevel Widgetter)
	})

	var _previousToplevel Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_previousToplevel = rv
	}

	iface.HierarchyChanged(_previousToplevel)
}

//export _gotk4_gtk3_WidgetClass_key_press_event
func _gotk4_gtk3_WidgetClass_key_press_event(arg0 *C.GtkWidget, arg1 *C.GdkEventKey) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		KeyPressEvent(event *gdk.EventKey) bool
	})

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.KeyPressEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_key_release_event
func _gotk4_gtk3_WidgetClass_key_release_event(arg0 *C.GtkWidget, arg1 *C.GdkEventKey) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		KeyReleaseEvent(event *gdk.EventKey) bool
	})

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.KeyReleaseEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_keynav_failed
func _gotk4_gtk3_WidgetClass_keynav_failed(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		KeynavFailed(direction DirectionType) bool
	})

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := iface.KeynavFailed(_direction)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_leave_notify_event
func _gotk4_gtk3_WidgetClass_leave_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventCrossing) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		LeaveNotifyEvent(event *gdk.EventCrossing) bool
	})

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.LeaveNotifyEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_map
func _gotk4_gtk3_WidgetClass_map(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Map() })

	iface.Map()
}

//export _gotk4_gtk3_WidgetClass_map_event
func _gotk4_gtk3_WidgetClass_map_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		MapEvent(event *gdk.EventAny) bool
	})

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.MapEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_mnemonic_activate
func _gotk4_gtk3_WidgetClass_mnemonic_activate(arg0 *C.GtkWidget, arg1 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ MnemonicActivate(groupCycling bool) bool })

	var _groupCycling bool // out

	if arg1 != 0 {
		_groupCycling = true
	}

	ok := iface.MnemonicActivate(_groupCycling)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_motion_notify_event
func _gotk4_gtk3_WidgetClass_motion_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventMotion) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		MotionNotifyEvent(event *gdk.EventMotion) bool
	})

	var _event *gdk.EventMotion // out

	_event = (*gdk.EventMotion)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.MotionNotifyEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_move_focus
func _gotk4_gtk3_WidgetClass_move_focus(arg0 *C.GtkWidget, arg1 C.GtkDirectionType) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ MoveFocus(direction DirectionType) })

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	iface.MoveFocus(_direction)
}

//export _gotk4_gtk3_WidgetClass_parent_set
func _gotk4_gtk3_WidgetClass_parent_set(arg0 *C.GtkWidget, arg1 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ParentSet(previousParent Widgetter)
	})

	var _previousParent Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_previousParent = rv
	}

	iface.ParentSet(_previousParent)
}

//export _gotk4_gtk3_WidgetClass_popup_menu
func _gotk4_gtk3_WidgetClass_popup_menu(arg0 *C.GtkWidget) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ PopupMenu() bool })

	ok := iface.PopupMenu()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_property_notify_event
func _gotk4_gtk3_WidgetClass_property_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProperty) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PropertyNotifyEvent(event *gdk.EventProperty) bool
	})

	var _event *gdk.EventProperty // out

	_event = (*gdk.EventProperty)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.PropertyNotifyEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_proximity_in_event
func _gotk4_gtk3_WidgetClass_proximity_in_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProximity) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ProximityInEvent(event *gdk.EventProximity) bool
	})

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ProximityInEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_proximity_out_event
func _gotk4_gtk3_WidgetClass_proximity_out_event(arg0 *C.GtkWidget, arg1 *C.GdkEventProximity) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ProximityOutEvent(event *gdk.EventProximity) bool
	})

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ProximityOutEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_query_tooltip
func _gotk4_gtk3_WidgetClass_query_tooltip(arg0 *C.GtkWidget, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		QueryTooltip(x, y int32, keyboardTooltip bool, tooltip *Tooltip) bool
	})

	var _x int32              // out
	var _y int32              // out
	var _keyboardTooltip bool // out
	var _tooltip *Tooltip     // out

	_x = int32(arg1)
	_y = int32(arg2)
	if arg3 != 0 {
		_keyboardTooltip = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := iface.QueryTooltip(_x, _y, _keyboardTooltip, _tooltip)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_queue_draw_region
func _gotk4_gtk3_WidgetClass_queue_draw_region(arg0 *C.GtkWidget, arg1 *C.cairo_region_t) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ QueueDrawRegion(region *cairo.Region) })

	var _region *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(arg1)}
		_region = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	C.cairo_region_reference(arg1)
	runtime.SetFinalizer(_region, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
	})

	iface.QueueDrawRegion(_region)
}

//export _gotk4_gtk3_WidgetClass_realize
func _gotk4_gtk3_WidgetClass_realize(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Realize() })

	iface.Realize()
}

//export _gotk4_gtk3_WidgetClass_screen_changed
func _gotk4_gtk3_WidgetClass_screen_changed(arg0 *C.GtkWidget, arg1 *C.GdkScreen) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ScreenChanged(previousScreen *gdk.Screen)
	})

	var _previousScreen *gdk.Screen // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_previousScreen = &gdk.Screen{
			Object: obj,
		}
	}

	iface.ScreenChanged(_previousScreen)
}

//export _gotk4_gtk3_WidgetClass_scroll_event
func _gotk4_gtk3_WidgetClass_scroll_event(arg0 *C.GtkWidget, arg1 *C.GdkEventScroll) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ScrollEvent(event *gdk.EventScroll) bool
	})

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.ScrollEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_clear_event
func _gotk4_gtk3_WidgetClass_selection_clear_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		SelectionClearEvent(event *gdk.EventSelection) bool
	})

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.SelectionClearEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_get
func _gotk4_gtk3_WidgetClass_selection_get(arg0 *C.GtkWidget, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		SelectionGet(selectionData *SelectionData, info, time_ uint32)
	})

	var _selectionData *SelectionData // out
	var _info uint32                  // out
	var _time_ uint32                 // out

	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_info = uint32(arg2)
	_time_ = uint32(arg3)

	iface.SelectionGet(_selectionData, _info, _time_)
}

//export _gotk4_gtk3_WidgetClass_selection_notify_event
func _gotk4_gtk3_WidgetClass_selection_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		SelectionNotifyEvent(event *gdk.EventSelection) bool
	})

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.SelectionNotifyEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_selection_received
func _gotk4_gtk3_WidgetClass_selection_received(arg0 *C.GtkWidget, arg1 *C.GtkSelectionData, arg2 C.guint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		SelectionReceived(selectionData *SelectionData, time_ uint32)
	})

	var _selectionData *SelectionData // out
	var _time_ uint32                 // out

	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_time_ = uint32(arg2)

	iface.SelectionReceived(_selectionData, _time_)
}

//export _gotk4_gtk3_WidgetClass_selection_request_event
func _gotk4_gtk3_WidgetClass_selection_request_event(arg0 *C.GtkWidget, arg1 *C.GdkEventSelection) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		SelectionRequestEvent(event *gdk.EventSelection) bool
	})

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.SelectionRequestEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_show
func _gotk4_gtk3_WidgetClass_show(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Show() })

	iface.Show()
}

//export _gotk4_gtk3_WidgetClass_show_all
func _gotk4_gtk3_WidgetClass_show_all(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ShowAll() })

	iface.ShowAll()
}

//export _gotk4_gtk3_WidgetClass_show_help
func _gotk4_gtk3_WidgetClass_show_help(arg0 *C.GtkWidget, arg1 C.GtkWidgetHelpType) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ShowHelp(helpType WidgetHelpType) bool
	})

	var _helpType WidgetHelpType // out

	_helpType = WidgetHelpType(arg1)

	ok := iface.ShowHelp(_helpType)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_size_allocate
func _gotk4_gtk3_WidgetClass_size_allocate(arg0 *C.GtkWidget, arg1 *C.GtkAllocation) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SizeAllocate(allocation *Allocation) })

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	iface.SizeAllocate(_allocation)
}

//export _gotk4_gtk3_WidgetClass_state_changed
func _gotk4_gtk3_WidgetClass_state_changed(arg0 *C.GtkWidget, arg1 C.GtkStateType) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ StateChanged(previousState StateType) })

	var _previousState StateType // out

	_previousState = StateType(arg1)

	iface.StateChanged(_previousState)
}

//export _gotk4_gtk3_WidgetClass_state_flags_changed
func _gotk4_gtk3_WidgetClass_state_flags_changed(arg0 *C.GtkWidget, arg1 C.GtkStateFlags) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		StateFlagsChanged(previousStateFlags StateFlags)
	})

	var _previousStateFlags StateFlags // out

	_previousStateFlags = StateFlags(arg1)

	iface.StateFlagsChanged(_previousStateFlags)
}

//export _gotk4_gtk3_WidgetClass_style_set
func _gotk4_gtk3_WidgetClass_style_set(arg0 *C.GtkWidget, arg1 *C.GtkStyle) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ StyleSet(previousStyle *Style) })

	var _previousStyle *Style // out

	_previousStyle = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))

	iface.StyleSet(_previousStyle)
}

//export _gotk4_gtk3_WidgetClass_style_updated
func _gotk4_gtk3_WidgetClass_style_updated(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ StyleUpdated() })

	iface.StyleUpdated()
}

//export _gotk4_gtk3_WidgetClass_touch_event
func _gotk4_gtk3_WidgetClass_touch_event(arg0 *C.GtkWidget, arg1 *C.GdkEventTouch) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		TouchEvent(event *gdk.EventTouch) bool
	})

	var _event *gdk.EventTouch // out

	_event = (*gdk.EventTouch)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.TouchEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_unmap
func _gotk4_gtk3_WidgetClass_unmap(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Unmap() })

	iface.Unmap()
}

//export _gotk4_gtk3_WidgetClass_unmap_event
func _gotk4_gtk3_WidgetClass_unmap_event(arg0 *C.GtkWidget, arg1 *C.GdkEventAny) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		UnmapEvent(event *gdk.EventAny) bool
	})

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.UnmapEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_unrealize
func _gotk4_gtk3_WidgetClass_unrealize(arg0 *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Unrealize() })

	iface.Unrealize()
}

//export _gotk4_gtk3_WidgetClass_visibility_notify_event
func _gotk4_gtk3_WidgetClass_visibility_notify_event(arg0 *C.GtkWidget, arg1 *C.GdkEventVisibility) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		VisibilityNotifyEvent(event *gdk.EventVisibility) bool
	})

	var _event *gdk.EventVisibility // out

	_event = (*gdk.EventVisibility)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.VisibilityNotifyEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WidgetClass_window_state_event
func _gotk4_gtk3_WidgetClass_window_state_event(arg0 *C.GtkWidget, arg1 *C.GdkEventWindowState) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		WindowStateEvent(event *gdk.EventWindowState) bool
	})

	var _event *gdk.EventWindowState // out

	_event = (*gdk.EventWindowState)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.WindowStateEvent(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapWidget(obj *coreglib.Object) *Widget {
	return &Widget{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		ImplementorIface: atk.ImplementorIface{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	return wrapWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (widget *Widget) baseWidget() *Widget {
	return widget
}

// BaseWidget returns the underlying base object.
func BaseWidget(obj Widgetter) *Widget {
	return obj.baseWidget()
}

//export _gotk4_gtk3_Widget_ConnectAccelClosuresChanged
func _gotk4_gtk3_Widget_ConnectAccelClosuresChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

func (widget *Widget) ConnectAccelClosuresChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "accel-closures-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectAccelClosuresChanged), f)
}

//export _gotk4_gtk3_Widget_ConnectButtonPressEvent
func _gotk4_gtk3_Widget_ConnectButtonPressEvent(arg0 C.gpointer, arg1 *C.GdkEventButton, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectButtonPressEvent signal will be emitted when a button (typically from
// a mouse) is pressed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_BUTTON_PRESS_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectButtonPressEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "button-press-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectButtonPressEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectButtonReleaseEvent
func _gotk4_gtk3_Widget_ConnectButtonReleaseEvent(arg0 C.gpointer, arg1 *C.GdkEventButton, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectButtonReleaseEvent signal will be emitted when a button (typically
// from a mouse) is released.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_BUTTON_RELEASE_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectButtonReleaseEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "button-release-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectButtonReleaseEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectCanActivateAccel
func _gotk4_gtk3_Widget_ConnectCanActivateAccel(arg0 C.gpointer, arg1 C.guint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(signalId uint32) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(signalId uint32) (ok bool))
	}

	var _signalId uint32 // out

	_signalId = uint32(arg1)

	ok := f(_signalId)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectCanActivateAccel determines whether an accelerator that activates the
// signal identified by signal_id can currently be activated. This signal is
// present to allow applications and derived widgets to override the default
// Widget handling for determining whether an accelerator can be activated.
func (widget *Widget) ConnectCanActivateAccel(f func(signalId uint32) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "can-activate-accel", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectCanActivateAccel), f)
}

//export _gotk4_gtk3_Widget_ConnectCompositedChanged
func _gotk4_gtk3_Widget_ConnectCompositedChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCompositedChanged signal is emitted when the composited status of
// widgets screen changes. See gdk_screen_is_composited().
func (widget *Widget) ConnectCompositedChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "composited-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectCompositedChanged), f)
}

//export _gotk4_gtk3_Widget_ConnectConfigureEvent
func _gotk4_gtk3_Widget_ConnectConfigureEvent(arg0 C.gpointer, arg1 *C.GdkEventConfigure, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventConfigure) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventConfigure) (ok bool))
	}

	var _event *gdk.EventConfigure // out

	_event = (*gdk.EventConfigure)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectConfigureEvent signal will be emitted when the size, position or
// stacking of the widget's window has changed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectConfigureEvent(f func(event *gdk.EventConfigure) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "configure-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectConfigureEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectDamageEvent
func _gotk4_gtk3_Widget_ConnectDamageEvent(arg0 C.gpointer, arg1 *C.GdkEventExpose, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventExpose) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventExpose) (ok bool))
	}

	var _event *gdk.EventExpose // out

	_event = (*gdk.EventExpose)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectDamageEvent is emitted when a redirected window belonging to widget
// gets drawn into. The region/area members of the event shows what area of the
// redirected drawable was drawn into.
func (widget *Widget) ConnectDamageEvent(f func(event *gdk.EventExpose) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "damage-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDamageEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectDeleteEvent
func _gotk4_gtk3_Widget_ConnectDeleteEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectDeleteEvent signal is emitted if a user requests that a toplevel
// window is closed. The default handler for this signal destroys the window.
// Connecting gtk_widget_hide_on_delete() to this signal will cause the window
// to be hidden instead, so that it can later be shown again without
// reconstructing it.
func (widget *Widget) ConnectDeleteEvent(f func(event *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "delete-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDeleteEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectDestroy
func _gotk4_gtk3_Widget_ConnectDestroy(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectDestroy signals that all holders of a reference to the widget should
// release the reference that they hold. May result in finalization of the
// widget if all references are released.
//
// This signal is not suitable for saving widget state.
func (widget *Widget) ConnectDestroy(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "destroy", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDestroy), f)
}

//export _gotk4_gtk3_Widget_ConnectDestroyEvent
func _gotk4_gtk3_Widget_ConnectDestroyEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectDestroyEvent signal is emitted when a Window is destroyed. You rarely
// get this signal, because most widgets disconnect themselves from their window
// before they destroy it, so no widget owns the window at destroy time.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectDestroyEvent(f func(event *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "destroy-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDestroyEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectDirectionChanged
func _gotk4_gtk3_Widget_ConnectDirectionChanged(arg0 C.gpointer, arg1 C.GtkTextDirection, arg2 C.guintptr) {
	var f func(previousDirection TextDirection)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousDirection TextDirection))
	}

	var _previousDirection TextDirection // out

	_previousDirection = TextDirection(arg1)

	f(_previousDirection)
}

// ConnectDirectionChanged signal is emitted when the text direction of a widget
// changes.
func (widget *Widget) ConnectDirectionChanged(f func(previousDirection TextDirection)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "direction-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDirectionChanged), f)
}

//export _gotk4_gtk3_Widget_ConnectDragBegin
func _gotk4_gtk3_Widget_ConnectDragBegin(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

// ConnectDragBegin signal is emitted on the drag source when a drag is started.
// A typical reason to connect to this signal is to set up a custom drag icon
// with e.g. gtk_drag_source_set_icon_pixbuf().
//
// Note that some widgets set up a drag icon in the default handler of this
// signal, so you may have to use g_signal_connect_after() to override what the
// default handler did.
func (widget *Widget) ConnectDragBegin(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-begin", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragBegin), f)
}

//export _gotk4_gtk3_Widget_ConnectDragDataDelete
func _gotk4_gtk3_Widget_ConnectDragDataDelete(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

// ConnectDragDataDelete signal is emitted on the drag source when a drag with
// the action GDK_ACTION_MOVE is successfully completed. The signal handler is
// responsible for deleting the data that has been dropped. What "delete" means
// depends on the context of the drag operation.
func (widget *Widget) ConnectDragDataDelete(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-data-delete", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataDelete), f)
}

//export _gotk4_gtk3_Widget_ConnectDragDataGet
func _gotk4_gtk3_Widget_ConnectDragDataGet(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 *C.GtkSelectionData, arg3 C.guint, arg4 C.guint, arg5 C.guintptr) {
	var f func(context *gdk.DragContext, data *SelectionData, info, time uint32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, data *SelectionData, info, time uint32))
	}

	var _context *gdk.DragContext // out
	var _data *SelectionData      // out
	var _info uint32              // out
	var _time uint32              // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_info = uint32(arg3)
	_time = uint32(arg4)

	f(_context, _data, _info, _time)
}

// ConnectDragDataGet signal is emitted on the drag source when the drop site
// requests the data which is dragged. It is the responsibility of the signal
// handler to fill data with the data in the format which is indicated by info.
// See gtk_selection_data_set() and gtk_selection_data_set_text().
func (widget *Widget) ConnectDragDataGet(f func(context *gdk.DragContext, data *SelectionData, info, time uint32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-data-get", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataGet), f)
}

//export _gotk4_gtk3_Widget_ConnectDragDataReceived
func _gotk4_gtk3_Widget_ConnectDragDataReceived(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 *C.GtkSelectionData, arg5 C.guint, arg6 C.guint, arg7 C.guintptr) {
	var f func(context *gdk.DragContext, x, y int32, data *SelectionData, info, time uint32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg7))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int32, data *SelectionData, info, time uint32))
	}

	var _context *gdk.DragContext // out
	var _x int32                  // out
	var _y int32                  // out
	var _data *SelectionData      // out
	var _info uint32              // out
	var _time uint32              // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int32(arg2)
	_y = int32(arg3)
	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_info = uint32(arg5)
	_time = uint32(arg6)

	f(_context, _x, _y, _data, _info, _time)
}

// ConnectDragDataReceived signal is emitted on the drop site when the dragged
// data has been received. If the data was received in order to determine
// whether the drop will be accepted, the handler is expected to call
// gdk_drag_status() and not finish the drag. If the data was received in
// response to a Widget::drag-drop signal (and this is the last target to be
// received), the handler for this signal is expected to process the received
// data and then call gtk_drag_finish(), setting the success parameter depending
// on whether the data was processed successfully.
//
// Applications must create some means to determine why the signal was emitted
// and therefore whether to call gdk_drag_status() or gtk_drag_finish().
//
// The handler may inspect the selected action with
// gdk_drag_context_get_selected_action() before calling gtk_drag_finish(), e.g.
// to implement GDK_ACTION_ASK as shown in the following example:
//
//    void
//    drag_data_received (GtkWidget          *widget,
//                        GdkDragContext     *context,
//                        gint                x,
//                        gint                y,
//                        GtkSelectionData   *data,
//                        guint               info,
//                        guint               time)
//    {
//      if ((data->length >= 0) && (data->format == 8))
//        {
//          GdkDragAction action;
//
//          // handle data here
//
//          action = gdk_drag_context_get_selected_action (context);
//          if (action == GDK_ACTION_ASK)
//            {
//              GtkWidget *dialog;
//              gint response;
//
//              dialog = gtk_message_dialog_new (NULL,
//                                               GTK_DIALOG_MODAL |
//                                               GTK_DIALOG_DESTROY_WITH_PARENT,
//                                               GTK_MESSAGE_INFO,
//                                               GTK_BUTTONS_YES_NO,
//                                               "Move the data ?\n");
//              response = gtk_dialog_run (GTK_DIALOG (dialog));
//              gtk_widget_destroy (dialog);
//
//              if (response == GTK_RESPONSE_YES)
//                action = GDK_ACTION_MOVE;
//              else
//                action = GDK_ACTION_COPY;
//             }
//
//          gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
//        }
//      else
//        gtk_drag_finish (context, FALSE, FALSE, time);
//     }.
func (widget *Widget) ConnectDragDataReceived(f func(context *gdk.DragContext, x, y int32, data *SelectionData, info, time uint32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-data-received", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataReceived), f)
}

//export _gotk4_gtk3_Widget_ConnectDragDrop
func _gotk4_gtk3_Widget_ConnectDragDrop(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint, arg5 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, x, y int32, time uint32) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int32, time uint32) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _x int32                  // out
	var _y int32                  // out
	var _time uint32              // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int32(arg2)
	_y = int32(arg3)
	_time = uint32(arg4)

	ok := f(_context, _x, _y, _time)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectDragDrop signal is emitted on the drop site when the user drops the
// data onto the widget. The signal handler must determine whether the cursor
// position is in a drop zone or not. If it is not in a drop zone, it returns
// FALSE and no further processing is necessary. Otherwise, the handler returns
// TRUE. In this case, the handler must ensure that gtk_drag_finish() is called
// to let the source know that the drop is done. The call to gtk_drag_finish()
// can be done either directly or in a Widget::drag-data-received handler which
// gets triggered by calling gtk_drag_get_data() to receive the data for one or
// more of the supported targets.
func (widget *Widget) ConnectDragDrop(f func(context *gdk.DragContext, x, y int32, time uint32) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-drop", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDrop), f)
}

//export _gotk4_gtk3_Widget_ConnectDragEnd
func _gotk4_gtk3_Widget_ConnectDragEnd(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

// ConnectDragEnd signal is emitted on the drag source when a drag is finished.
// A typical reason to connect to this signal is to undo things done in
// Widget::drag-begin.
func (widget *Widget) ConnectDragEnd(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-end", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragEnd), f)
}

//export _gotk4_gtk3_Widget_ConnectDragFailed
func _gotk4_gtk3_Widget_ConnectDragFailed(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.GtkDragResult, arg3 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, result DragResult) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, result DragResult) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _result DragResult        // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_result = DragResult(arg2)

	ok := f(_context, _result)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectDragFailed signal is emitted on the drag source when a drag has
// failed. The signal handler may hook custom code to handle a failed DnD
// operation based on the type of error, it returns TRUE is the failure has been
// already handled (not showing the default "drag operation failed" animation),
// otherwise it returns FALSE.
func (widget *Widget) ConnectDragFailed(f func(context *gdk.DragContext, result DragResult) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-failed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragFailed), f)
}

//export _gotk4_gtk3_Widget_ConnectDragLeave
func _gotk4_gtk3_Widget_ConnectDragLeave(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guint, arg3 C.guintptr) {
	var f func(context *gdk.DragContext, time uint32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, time uint32))
	}

	var _context *gdk.DragContext // out
	var _time uint32              // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_time = uint32(arg2)

	f(_context, _time)
}

// ConnectDragLeave signal is emitted on the drop site when the cursor leaves
// the widget. A typical reason to connect to this signal is to undo things done
// in Widget::drag-motion, e.g. undo highlighting with gtk_drag_unhighlight().
//
//    Likewise, the Widget::drag-leave signal is also emitted before the ::drag-drop signal, for instance to allow cleaning up of a preview item created in the Widget::drag-motion signal handler.
func (widget *Widget) ConnectDragLeave(f func(context *gdk.DragContext, time uint32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-leave", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragLeave), f)
}

//export _gotk4_gtk3_Widget_ConnectDragMotion
func _gotk4_gtk3_Widget_ConnectDragMotion(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint, arg5 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, x, y int32, time uint32) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int32, time uint32) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _x int32                  // out
	var _y int32                  // out
	var _time uint32              // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int32(arg2)
	_y = int32(arg3)
	_time = uint32(arg4)

	ok := f(_context, _x, _y, _time)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectDragMotion signal is emitted on the drop site when the user moves the
// cursor over the widget during a drag. The signal handler must determine
// whether the cursor position is in a drop zone or not. If it is not in a drop
// zone, it returns FALSE and no further processing is necessary. Otherwise, the
// handler returns TRUE. In this case, the handler is responsible for providing
// the necessary information for displaying feedback to the user, by calling
// gdk_drag_status().
//
// If the decision whether the drop will be accepted or rejected can't be made
// based solely on the cursor position and the type of the data, the handler may
// inspect the dragged data by calling gtk_drag_get_data() and defer the
// gdk_drag_status() call to the Widget::drag-data-received handler. Note that
// you must pass K_DEST_DEFAULT_DROP, K_DEST_DEFAULT_MOTION or
// K_DEST_DEFAULT_ALL to gtk_drag_dest_set() when using the drag-motion signal
// that way.
//
// Also note that there is no drag-enter signal. The drag receiver has to keep
// track of whether he has received any drag-motion signals since the last
// Widget::drag-leave and if not, treat the drag-motion signal as an "enter"
// signal. Upon an "enter", the handler will typically highlight the drop site
// with gtk_drag_highlight().
//
//    static void
//    drag_motion (GtkWidget      *widget,
//                 GdkDragContext *context,
//                 gint            x,
//                 gint            y,
//                 guint           time)
//    {
//      GdkAtom target;
//
//      PrivateData *private_data = GET_PRIVATE_DATA (widget);
//
//      if (!private_data->drag_highlight)
//       {
//         private_data->drag_highlight = 1;
//         gtk_drag_highlight (widget);
//       }
//
//      target = gtk_drag_dest_find_target (widget, context, NULL);
//      if (target == GDK_NONE)
//        gdk_drag_status (context, 0, time);
//      else
//       {
//         private_data->pending_status
//            = gdk_drag_context_get_suggested_action (context);
//         gtk_drag_get_data (widget, context, target, time);
//       }
//
//      return TRUE;
//    }
//
//    static void
//    drag_data_received (GtkWidget        *widget,
//                        GdkDragContext   *context,
//                        gint              x,
//                        gint              y,
//                        GtkSelectionData *selection_data,
//                        guint             info,
//                        guint             time)
//    {
//      PrivateData *private_data = GET_PRIVATE_DATA (widget);
//
//      if (private_data->suggested_action)
//       {
//         private_data->suggested_action = 0;
//
//         // We are getting this data due to a request in drag_motion,
//         // rather than due to a request in drag_drop, so we are just
//         // supposed to call gdk_drag_status(), not actually paste in
//         // the data.
//
//         str = gtk_selection_data_get_text (selection_data);
//         if (!data_is_acceptable (str))
//           gdk_drag_status (context, 0, time);
//         else
//           gdk_drag_status (context,
//                            private_data->suggested_action,
//                            time);
//       }
//      else
//       {
//         // accept the drop
//       }
//    }.
func (widget *Widget) ConnectDragMotion(f func(context *gdk.DragContext, x, y int32, time uint32) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-motion", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragMotion), f)
}

//export _gotk4_gtk3_Widget_ConnectDraw
func _gotk4_gtk3_Widget_ConnectDraw(arg0 C.gpointer, arg1 *C.cairo_t, arg2 C.guintptr) (cret C.gboolean) {
	var f func(cr *cairo.Context) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(cr *cairo.Context) (ok bool))
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	ok := f(_cr)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectDraw: this signal is emitted when a widget is supposed to render
// itself. The widget's top left corner must be painted at the origin of the
// passed in context and be sized to the values returned by
// gtk_widget_get_allocated_width() and gtk_widget_get_allocated_height().
//
// Signal handlers connected to this signal can modify the cairo context passed
// as cr in any way they like and don't need to restore it. The signal emission
// takes care of calling cairo_save() before and cairo_restore() after invoking
// the handler.
//
// The signal handler will get a cr with a clip region already set to the
// widget's dirty region, i.e. to the area that needs repainting. Complicated
// widgets that want to avoid redrawing themselves completely can get the full
// extents of the clip region with gdk_cairo_get_clip_rectangle(), or they can
// get a finer-grained representation of the dirty region with
// cairo_copy_clip_rectangle_list().
func (widget *Widget) ConnectDraw(f func(cr *cairo.Context) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "draw", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDraw), f)
}

//export _gotk4_gtk3_Widget_ConnectEnterNotifyEvent
func _gotk4_gtk3_Widget_ConnectEnterNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventCrossing, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventCrossing) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventCrossing) (ok bool))
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectEnterNotifyEvent will be emitted when the pointer enters the widget's
// window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_ENTER_NOTIFY_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectEnterNotifyEvent(f func(event *gdk.EventCrossing) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "enter-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectEnterNotifyEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectEvent
func _gotk4_gtk3_Widget_ConnectEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectEvent: GTK+ main loop will emit three signals for each GDK event
// delivered to a widget: one generic ::event signal, another, more specific,
// signal that matches the type of event delivered (e.g.
// Widget::key-press-event) and finally a generic Widget::event-after signal.
func (widget *Widget) ConnectEvent(f func(event *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectEventAfter
func _gotk4_gtk3_Widget_ConnectEventAfter(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) {
	var f func(event *gdk.Event)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	f(_event)
}

// ConnectEventAfter: after the emission of the Widget::event signal and
// (optionally) the second more specific signal, ::event-after will be emitted
// regardless of the previous two signals handlers return values.
func (widget *Widget) ConnectEventAfter(f func(event *gdk.Event)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "event-after", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectEventAfter), f)
}

//export _gotk4_gtk3_Widget_ConnectFocus
func _gotk4_gtk3_Widget_ConnectFocus(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(direction DirectionType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType) (ok bool))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := f(_direction)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (widget *Widget) ConnectFocus(f func(direction DirectionType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "focus", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectFocus), f)
}

//export _gotk4_gtk3_Widget_ConnectFocusInEvent
func _gotk4_gtk3_Widget_ConnectFocusInEvent(arg0 C.gpointer, arg1 *C.GdkEventFocus, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventFocus) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventFocus) (ok bool))
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectFocusInEvent signal will be emitted when the keyboard focus enters the
// widget's window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_FOCUS_CHANGE_MASK mask.
func (widget *Widget) ConnectFocusInEvent(f func(event *gdk.EventFocus) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "focus-in-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectFocusInEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectFocusOutEvent
func _gotk4_gtk3_Widget_ConnectFocusOutEvent(arg0 C.gpointer, arg1 *C.GdkEventFocus, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventFocus) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventFocus) (ok bool))
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectFocusOutEvent signal will be emitted when the keyboard focus leaves
// the widget's window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_FOCUS_CHANGE_MASK mask.
func (widget *Widget) ConnectFocusOutEvent(f func(event *gdk.EventFocus) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "focus-out-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectFocusOutEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectGrabBrokenEvent
func _gotk4_gtk3_Widget_ConnectGrabBrokenEvent(arg0 C.gpointer, arg1 *C.GdkEventGrabBroken, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventGrabBroken) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventGrabBroken) (ok bool))
	}

	var _event *gdk.EventGrabBroken // out

	_event = (*gdk.EventGrabBroken)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectGrabBrokenEvent is emitted when a pointer or keyboard grab on a window
// belonging to widget gets broken.
//
// On X11, this happens when the grab window becomes unviewable (i.e. it or one
// of its ancestors is unmapped), or if the same application grabs the pointer
// or keyboard again.
func (widget *Widget) ConnectGrabBrokenEvent(f func(event *gdk.EventGrabBroken) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "grab-broken-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabBrokenEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectGrabFocus
func _gotk4_gtk3_Widget_ConnectGrabFocus(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

func (widget *Widget) ConnectGrabFocus(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "grab-focus", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabFocus), f)
}

//export _gotk4_gtk3_Widget_ConnectGrabNotify
func _gotk4_gtk3_Widget_ConnectGrabNotify(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(wasGrabbed bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(wasGrabbed bool))
	}

	var _wasGrabbed bool // out

	if arg1 != 0 {
		_wasGrabbed = true
	}

	f(_wasGrabbed)
}

// ConnectGrabNotify signal is emitted when a widget becomes shadowed by a GTK+
// grab (not a pointer or keyboard grab) on another widget, or when it becomes
// unshadowed due to a grab being removed.
//
// A widget is shadowed by a gtk_grab_add() when the topmost grab widget in the
// grab stack of its window group is not its ancestor.
func (widget *Widget) ConnectGrabNotify(f func(wasGrabbed bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "grab-notify", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabNotify), f)
}

//export _gotk4_gtk3_Widget_ConnectHide
func _gotk4_gtk3_Widget_ConnectHide(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectHide signal is emitted when widget is hidden, for example with
// gtk_widget_hide().
func (widget *Widget) ConnectHide(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "hide", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectHide), f)
}

//export _gotk4_gtk3_Widget_ConnectHierarchyChanged
func _gotk4_gtk3_Widget_ConnectHierarchyChanged(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(previousToplevel Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousToplevel Widgetter))
	}

	var _previousToplevel Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_previousToplevel = rv
		}
	}

	f(_previousToplevel)
}

// ConnectHierarchyChanged signal is emitted when the anchored state of a widget
// changes. A widget is “anchored” when its toplevel ancestor is a Window. This
// signal is emitted when a widget changes from un-anchored to anchored or
// vice-versa.
func (widget *Widget) ConnectHierarchyChanged(f func(previousToplevel Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "hierarchy-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectHierarchyChanged), f)
}

//export _gotk4_gtk3_Widget_ConnectKeyPressEvent
func _gotk4_gtk3_Widget_ConnectKeyPressEvent(arg0 C.gpointer, arg1 *C.GdkEventKey, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventKey) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventKey) (ok bool))
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectKeyPressEvent signal is emitted when a key is pressed. The signal
// emission will reoccur at the key-repeat rate when the key is kept pressed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_KEY_PRESS_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectKeyPressEvent(f func(event *gdk.EventKey) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "key-press-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectKeyPressEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectKeyReleaseEvent
func _gotk4_gtk3_Widget_ConnectKeyReleaseEvent(arg0 C.gpointer, arg1 *C.GdkEventKey, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventKey) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventKey) (ok bool))
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectKeyReleaseEvent signal is emitted when a key is released.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_KEY_RELEASE_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectKeyReleaseEvent(f func(event *gdk.EventKey) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "key-release-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectKeyReleaseEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectKeynavFailed
func _gotk4_gtk3_Widget_ConnectKeynavFailed(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(direction DirectionType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType) (ok bool))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := f(_direction)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectKeynavFailed gets emitted if keyboard navigation fails. See
// gtk_widget_keynav_failed() for details.
func (widget *Widget) ConnectKeynavFailed(f func(direction DirectionType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "keynav-failed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectKeynavFailed), f)
}

//export _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent
func _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventCrossing, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventCrossing) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventCrossing) (ok bool))
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectLeaveNotifyEvent will be emitted when the pointer leaves the widget's
// window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_LEAVE_NOTIFY_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectLeaveNotifyEvent(f func(event *gdk.EventCrossing) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "leave-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectLeaveNotifyEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectMap
func _gotk4_gtk3_Widget_ConnectMap(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectMap signal is emitted when widget is going to be mapped, that is when
// the widget is visible (which is controlled with gtk_widget_set_visible()) and
// all its parents up to the toplevel widget are also visible. Once the map has
// occurred, Widget::map-event will be emitted.
//
// The ::map signal can be used to determine whether a widget will be drawn, for
// instance it can resume an animation that was stopped during the emission of
// Widget::unmap.
func (widget *Widget) ConnectMap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "map", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMap), f)
}

//export _gotk4_gtk3_Widget_ConnectMapEvent
func _gotk4_gtk3_Widget_ConnectMapEvent(arg0 C.gpointer, arg1 *C.GdkEventAny, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventAny) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventAny) (ok bool))
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectMapEvent signal will be emitted when the widget's window is mapped. A
// window is mapped when it becomes visible on the screen.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectMapEvent(f func(event *gdk.EventAny) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "map-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMapEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectMnemonicActivate
func _gotk4_gtk3_Widget_ConnectMnemonicActivate(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(groupCycling bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(groupCycling bool) (ok bool))
	}

	var _groupCycling bool // out

	if arg1 != 0 {
		_groupCycling = true
	}

	ok := f(_groupCycling)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectMnemonicActivate: default handler for this signal activates widget if
// group_cycling is FALSE, or just makes widget grab focus if group_cycling is
// TRUE.
func (widget *Widget) ConnectMnemonicActivate(f func(groupCycling bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "mnemonic-activate", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMnemonicActivate), f)
}

//export _gotk4_gtk3_Widget_ConnectMotionNotifyEvent
func _gotk4_gtk3_Widget_ConnectMotionNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventMotion, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventMotion) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventMotion) (ok bool))
	}

	var _event *gdk.EventMotion // out

	_event = (*gdk.EventMotion)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectMotionNotifyEvent signal is emitted when the pointer moves over the
// widget's Window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_POINTER_MOTION_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectMotionNotifyEvent(f func(event *gdk.EventMotion) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "motion-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMotionNotifyEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectMoveFocus
func _gotk4_gtk3_Widget_ConnectMoveFocus(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(direction DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	f(_direction)
}

func (widget *Widget) ConnectMoveFocus(f func(direction DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "move-focus", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMoveFocus), f)
}

//export _gotk4_gtk3_Widget_ConnectParentSet
func _gotk4_gtk3_Widget_ConnectParentSet(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(oldParent Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(oldParent Widgetter))
	}

	var _oldParent Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_oldParent = rv
		}
	}

	f(_oldParent)
}

// ConnectParentSet signal is emitted when a new parent has been set on a
// widget.
func (widget *Widget) ConnectParentSet(f func(oldParent Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "parent-set", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectParentSet), f)
}

//export _gotk4_gtk3_Widget_ConnectPopupMenu
func _gotk4_gtk3_Widget_ConnectPopupMenu(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectPopupMenu: this signal gets emitted whenever a widget should pop up a
// context menu. This usually happens through the standard key binding
// mechanism; by pressing a certain key while a widget is focused, the user can
// cause the widget to pop up a menu. For example, the Entry widget creates a
// menu with clipboard commands. See the [Popup Menu Migration
// Checklist][checklist-popup-menu] for an example of how to use this signal.
func (widget *Widget) ConnectPopupMenu(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "popup-menu", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectPopupMenu), f)
}

//export _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent
func _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventProperty, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProperty) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProperty) (ok bool))
	}

	var _event *gdk.EventProperty // out

	_event = (*gdk.EventProperty)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectPropertyNotifyEvent signal will be emitted when a property on the
// widget's window has been changed or deleted.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_PROPERTY_CHANGE_MASK mask.
func (widget *Widget) ConnectPropertyNotifyEvent(f func(event *gdk.EventProperty) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "property-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectPropertyNotifyEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectProximityInEvent
func _gotk4_gtk3_Widget_ConnectProximityInEvent(arg0 C.gpointer, arg1 *C.GdkEventProximity, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProximity) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProximity) (ok bool))
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectProximityInEvent: to receive this signal the Window associated to the
// widget needs to enable the K_PROXIMITY_IN_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectProximityInEvent(f func(event *gdk.EventProximity) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "proximity-in-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectProximityInEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectProximityOutEvent
func _gotk4_gtk3_Widget_ConnectProximityOutEvent(arg0 C.gpointer, arg1 *C.GdkEventProximity, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProximity) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProximity) (ok bool))
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectProximityOutEvent: to receive this signal the Window associated to the
// widget needs to enable the K_PROXIMITY_OUT_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectProximityOutEvent(f func(event *gdk.EventProximity) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "proximity-out-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectProximityOutEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectQueryTooltip
func _gotk4_gtk3_Widget_ConnectQueryTooltip(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip, arg5 C.guintptr) (cret C.gboolean) {
	var f func(x, y int32, keyboardMode bool, tooltip *Tooltip) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y int32, keyboardMode bool, tooltip *Tooltip) (ok bool))
	}

	var _x int32           // out
	var _y int32           // out
	var _keyboardMode bool // out
	var _tooltip *Tooltip  // out

	_x = int32(arg1)
	_y = int32(arg2)
	if arg3 != 0 {
		_keyboardMode = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := f(_x, _y, _keyboardMode, _tooltip)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectQueryTooltip is emitted when Widget:has-tooltip is TRUE and the hover
// timeout has expired with the cursor hovering "above" widget; or emitted when
// widget got focus in keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether a
// tooltip should be shown for widget. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
func (widget *Widget) ConnectQueryTooltip(f func(x, y int32, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectQueryTooltip), f)
}

//export _gotk4_gtk3_Widget_ConnectRealize
func _gotk4_gtk3_Widget_ConnectRealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectRealize signal is emitted when widget is associated with a Window,
// which means that gtk_widget_realize() has been called or the widget has been
// mapped (that is, it is going to be drawn).
func (widget *Widget) ConnectRealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "realize", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectRealize), f)
}

//export _gotk4_gtk3_Widget_ConnectScreenChanged
func _gotk4_gtk3_Widget_ConnectScreenChanged(arg0 C.gpointer, arg1 *C.GdkScreen, arg2 C.guintptr) {
	var f func(previousScreen *gdk.Screen)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousScreen *gdk.Screen))
	}

	var _previousScreen *gdk.Screen // out

	if arg1 != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(arg1))
			_previousScreen = &gdk.Screen{
				Object: obj,
			}
		}
	}

	f(_previousScreen)
}

// ConnectScreenChanged signal gets emitted when the screen of a widget has
// changed.
func (widget *Widget) ConnectScreenChanged(f func(previousScreen *gdk.Screen)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "screen-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectScreenChanged), f)
}

//export _gotk4_gtk3_Widget_ConnectScrollEvent
func _gotk4_gtk3_Widget_ConnectScrollEvent(arg0 C.gpointer, arg1 *C.GdkEventScroll, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventScroll) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventScroll) (ok bool))
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectScrollEvent signal is emitted when a button in the 4 to 7 range is
// pressed. Wheel mice are usually configured to generate button press events
// for buttons 4 and 5 when the wheel is turned.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_SCROLL_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectScrollEvent(f func(event *gdk.EventScroll) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "scroll-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectScrollEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectSelectionClearEvent
func _gotk4_gtk3_Widget_ConnectSelectionClearEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectSelectionClearEvent signal will be emitted when the the widget's
// window has lost ownership of a selection.
func (widget *Widget) ConnectSelectionClearEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-clear-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionClearEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectSelectionGet
func _gotk4_gtk3_Widget_ConnectSelectionGet(arg0 C.gpointer, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guint, arg4 C.guintptr) {
	var f func(data *SelectionData, info, time uint32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(data *SelectionData, info, time uint32))
	}

	var _data *SelectionData // out
	var _info uint32         // out
	var _time uint32         // out

	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_info = uint32(arg2)
	_time = uint32(arg3)

	f(_data, _info, _time)
}

func (widget *Widget) ConnectSelectionGet(f func(data *SelectionData, info, time uint32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-get", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionGet), f)
}

//export _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent
func _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (widget *Widget) ConnectSelectionNotifyEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionNotifyEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectSelectionReceived
func _gotk4_gtk3_Widget_ConnectSelectionReceived(arg0 C.gpointer, arg1 *C.GtkSelectionData, arg2 C.guint, arg3 C.guintptr) {
	var f func(data *SelectionData, time uint32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(data *SelectionData, time uint32))
	}

	var _data *SelectionData // out
	var _time uint32         // out

	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_time = uint32(arg2)

	f(_data, _time)
}

func (widget *Widget) ConnectSelectionReceived(f func(data *SelectionData, time uint32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-received", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionReceived), f)
}

//export _gotk4_gtk3_Widget_ConnectSelectionRequestEvent
func _gotk4_gtk3_Widget_ConnectSelectionRequestEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectSelectionRequestEvent signal will be emitted when another client
// requests ownership of the selection owned by the widget's window.
func (widget *Widget) ConnectSelectionRequestEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-request-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionRequestEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectShow
func _gotk4_gtk3_Widget_ConnectShow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectShow signal is emitted when widget is shown, for example with
// gtk_widget_show().
func (widget *Widget) ConnectShow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "show", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectShow), f)
}

//export _gotk4_gtk3_Widget_ConnectShowHelp
func _gotk4_gtk3_Widget_ConnectShowHelp(arg0 C.gpointer, arg1 C.GtkWidgetHelpType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(helpType WidgetHelpType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(helpType WidgetHelpType) (ok bool))
	}

	var _helpType WidgetHelpType // out

	_helpType = WidgetHelpType(arg1)

	ok := f(_helpType)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (widget *Widget) ConnectShowHelp(f func(helpType WidgetHelpType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "show-help", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectShowHelp), f)
}

//export _gotk4_gtk3_Widget_ConnectSizeAllocate
func _gotk4_gtk3_Widget_ConnectSizeAllocate(arg0 C.gpointer, arg1 *C.GtkAllocation, arg2 C.guintptr) {
	var f func(allocation *Allocation)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(allocation *Allocation))
	}

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_allocation)
}

func (widget *Widget) ConnectSizeAllocate(f func(allocation *Allocation)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "size-allocate", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSizeAllocate), f)
}

//export _gotk4_gtk3_Widget_ConnectStateChanged
func _gotk4_gtk3_Widget_ConnectStateChanged(arg0 C.gpointer, arg1 C.GtkStateType, arg2 C.guintptr) {
	var f func(state StateType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(state StateType))
	}

	var _state StateType // out

	_state = StateType(arg1)

	f(_state)
}

// ConnectStateChanged signal is emitted when the widget state changes. See
// gtk_widget_get_state().
func (widget *Widget) ConnectStateChanged(f func(state StateType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "state-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStateChanged), f)
}

//export _gotk4_gtk3_Widget_ConnectStateFlagsChanged
func _gotk4_gtk3_Widget_ConnectStateFlagsChanged(arg0 C.gpointer, arg1 C.GtkStateFlags, arg2 C.guintptr) {
	var f func(flags StateFlags)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(flags StateFlags))
	}

	var _flags StateFlags // out

	_flags = StateFlags(arg1)

	f(_flags)
}

// ConnectStateFlagsChanged signal is emitted when the widget state changes, see
// gtk_widget_get_state_flags().
func (widget *Widget) ConnectStateFlagsChanged(f func(flags StateFlags)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "state-flags-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStateFlagsChanged), f)
}

//export _gotk4_gtk3_Widget_ConnectStyleSet
func _gotk4_gtk3_Widget_ConnectStyleSet(arg0 C.gpointer, arg1 *C.GtkStyle, arg2 C.guintptr) {
	var f func(previousStyle *Style)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousStyle *Style))
	}

	var _previousStyle *Style // out

	if arg1 != nil {
		_previousStyle = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))
	}

	f(_previousStyle)
}

// ConnectStyleSet signal is emitted when a new style has been set on a widget.
// Note that style-modifying functions like gtk_widget_modify_base() also cause
// this signal to be emitted.
//
// Note that this signal is emitted for changes to the deprecated Style. To
// track changes to the StyleContext associated with a widget, use the
// Widget::style-updated signal.
func (widget *Widget) ConnectStyleSet(f func(previousStyle *Style)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "style-set", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStyleSet), f)
}

//export _gotk4_gtk3_Widget_ConnectStyleUpdated
func _gotk4_gtk3_Widget_ConnectStyleUpdated(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectStyleUpdated signal is a convenience signal that is emitted when the
// StyleContext::changed signal is emitted on the widget's associated
// StyleContext as returned by gtk_widget_get_style_context().
//
// Note that style-modifying functions like gtk_widget_override_color() also
// cause this signal to be emitted.
func (widget *Widget) ConnectStyleUpdated(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "style-updated", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStyleUpdated), f)
}

//export _gotk4_gtk3_Widget_ConnectTouchEvent
func _gotk4_gtk3_Widget_ConnectTouchEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object *gdk.Event) (ok bool))
	}

	var _object *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_object = v
	}

	ok := f(_object)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (widget *Widget) ConnectTouchEvent(f func(object *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "touch-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectTouchEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectUnmap
func _gotk4_gtk3_Widget_ConnectUnmap(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectUnmap signal is emitted when widget is going to be unmapped, which
// means that either it or any of its parents up to the toplevel widget have
// been set as hidden.
//
// As ::unmap indicates that a widget will not be shown any longer, it can be
// used to, for example, stop an animation on the widget.
func (widget *Widget) ConnectUnmap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unmap", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnmap), f)
}

//export _gotk4_gtk3_Widget_ConnectUnmapEvent
func _gotk4_gtk3_Widget_ConnectUnmapEvent(arg0 C.gpointer, arg1 *C.GdkEventAny, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventAny) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventAny) (ok bool))
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectUnmapEvent signal will be emitted when the widget's window is
// unmapped. A window is unmapped when it becomes invisible on the screen.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectUnmapEvent(f func(event *gdk.EventAny) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unmap-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnmapEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectUnrealize
func _gotk4_gtk3_Widget_ConnectUnrealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectUnrealize signal is emitted when the Window associated with widget is
// destroyed, which means that gtk_widget_unrealize() has been called or the
// widget has been unmapped (that is, it is going to be hidden).
func (widget *Widget) ConnectUnrealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unrealize", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnrealize), f)
}

//export _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent
func _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventVisibility, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventVisibility) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventVisibility) (ok bool))
	}

	var _event *gdk.EventVisibility // out

	_event = (*gdk.EventVisibility)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectVisibilityNotifyEvent will be emitted when the widget's window is
// obscured or unobscured.
//
// To receive this signal the Window associated to the widget needs to enable
// the K_VISIBILITY_NOTIFY_MASK mask.
func (widget *Widget) ConnectVisibilityNotifyEvent(f func(event *gdk.EventVisibility) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "visibility-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent), f)
}

//export _gotk4_gtk3_Widget_ConnectWindowStateEvent
func _gotk4_gtk3_Widget_ConnectWindowStateEvent(arg0 C.gpointer, arg1 *C.GdkEventWindowState, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventWindowState) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventWindowState) (ok bool))
	}

	var _event *gdk.EventWindowState // out

	_event = (*gdk.EventWindowState)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectWindowStateEvent will be emitted when the state of the toplevel window
// associated to the widget changes.
//
// To receive this signal the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectWindowStateEvent(f func(event *gdk.EventWindowState) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "window-state-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectWindowStateEvent), f)
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them. Activation is what happens when you press Enter
// on a widget during key navigation. If widget isn't activatable, the function
// returns FALSE.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget was activatable.
//
func (widget *Widget) Activate() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_activate(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddAccelerator installs an accelerator for this widget in accel_group that
// causes accel_signal to be emitted if the accelerator is activated. The
// accel_group needs to be added to the widget’s toplevel via
// gtk_window_add_accel_group(), and the signal must be of type G_SIGNAL_ACTION.
// Accelerators added through this function are not user changeable during
// runtime. If you want to support accelerators that can be changed by the user,
// use gtk_accel_map_add_entry() and gtk_widget_set_accel_path() or
// gtk_menu_item_set_accel_path() instead.
//
// The function takes the following parameters:
//
//    - accelSignal: widget signal to emit on accelerator activation.
//    - accelGroup: accel group for this widget, added to its toplevel.
//    - accelKey: GDK keyval of the accelerator.
//    - accelMods: modifier key combination of the accelerator.
//    - accelFlags: flag accelerators, e.g. GTK_ACCEL_VISIBLE.
//
func (widget *Widget) AddAccelerator(accelSignal string, accelGroup *AccelGroup, accelKey uint32, accelMods gdk.ModifierType, accelFlags AccelFlags) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GtkAccelGroup  // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _arg5 C.GtkAccelFlags   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accelSignal)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	_arg3 = C.guint(accelKey)
	_arg4 = C.GdkModifierType(accelMods)
	_arg5 = C.GtkAccelFlags(accelFlags)

	C.gtk_widget_add_accelerator(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(accelSignal)
	runtime.KeepAlive(accelGroup)
	runtime.KeepAlive(accelKey)
	runtime.KeepAlive(accelMods)
	runtime.KeepAlive(accelFlags)
}

// AddDeviceEvents adds the device events in the bitfield events to the event
// mask for widget. See gtk_widget_set_device_events() for details.
//
// The function takes the following parameters:
//
//    - device: Device.
//    - events: event mask, see EventMask.
//
func (widget *Widget) AddDeviceEvents(device gdk.Devicer, events gdk.EventMask) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.GdkEventMask // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = C.GdkEventMask(events)

	C.gtk_widget_add_device_events(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)
	runtime.KeepAlive(events)
}

// AddEvents adds the events in the bitfield events to the event mask for
// widget. See gtk_widget_set_events() and the [input handling
// overview][event-masks] for details.
//
// The function takes the following parameters:
//
//    - events: event mask, see EventMask.
//
func (widget *Widget) AddEvents(events int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(events)

	C.gtk_widget_add_events(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(events)
}

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget. (See gtk_widget_list_mnemonic_labels()). Note the list of mnemonic
// labels for the widget is cleared when the widget is destroyed, so the caller
// must make sure to update its internal state at this point as well, by using a
// connection to the Widget::destroy signal or a weak notifier.
//
// The function takes the following parameters:
//
//    - label that acts as a mnemonic label for widget.
//
func (widget *Widget) AddMnemonicLabel(label Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(label).Native()))

	C.gtk_widget_add_mnemonic_label(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(label)
}

// AddTickCallback queues an animation frame update and adds a callback to be
// called before each frame. Until the tick callback is removed, it will be
// called frequently (usually at the frame rate of the output device or as
// quickly as the application can be repainted, whichever is slower). For this
// reason, is most suitable for handling graphics that change every frame or
// every few frames. The tick callback does not automatically imply a relayout
// or repaint. If you want a repaint or relayout, and aren’t changing widget
// properties that would trigger that (for example, changing the text of a
// Label), then you will have to call gtk_widget_queue_resize() or
// gtk_widget_queue_draw_area() yourself.
//
// gdk_frame_clock_get_frame_time() should generally be used for timing
// continuous animations and gdk_frame_timings_get_predicted_presentation_time()
// if you are trying to display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// FrameClock::update signal of FrameClock, since you don't have to worry about
// when a FrameClock is assigned to a widget.
//
// The function takes the following parameters:
//
//    - callback: function to call for updating animations.
//
// The function returns the following values:
//
//    - guint: id for the connection of this callback. Remove the callback by
//      passing it to gtk_widget_remove_tick_callback().
//
func (widget *Widget) AddTickCallback(callback TickCallback) uint32 {
	var _arg0 *C.GtkWidget      // out
	var _arg1 C.GtkTickCallback // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk3_TickCallback)
	_arg2 = C.gpointer(gbox.Assign(callback))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gtk_widget_add_tick_callback(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(callback)

	var _guint uint32 // out

	_guint = uint32(_cret)

	return _guint
}

// CanActivateAccel determines whether an accelerator that activates the signal
// identified by signal_id can currently be activated. This is done by emitting
// the Widget::can-activate-accel signal on widget; if the signal isn’t
// overridden by a handler or in a derived widget, then the default check is
// that the widget must be sensitive, and the widget and all its ancestors
// mapped.
//
// The function takes the following parameters:
//
//    - signalId: ID of a signal installed on widget.
//
// The function returns the following values:
//
//    - ok: TRUE if the accelerator can be activated.
//
func (widget *Widget) CanActivateAccel(signalId uint32) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.guint(signalId)

	_cret = C.gtk_widget_can_activate_accel(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(signalId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildFocus: this function is used by custom widget implementations; if you're
// writing an app, you’d use gtk_widget_grab_focus() to move the focus to a
// particular widget, and gtk_container_set_focus_chain() to change the focus
// tab order. So you may want to investigate those functions instead.
//
// gtk_widget_child_focus() is called by containers as the user moves around the
// window using keyboard shortcuts. direction indicates what kind of motion is
// taking place (up, down, left, right, tab forward, tab backward).
// gtk_widget_child_focus() emits the Widget::focus signal; widgets override the
// default handler for this signal in order to implement appropriate focus
// behavior.
//
// The default ::focus handler for a widget should return TRUE if moving in
// direction left the focus on a focusable location inside that widget, and
// FALSE if moving in direction moved the focus outside the widget. If returning
// TRUE, widgets normally call gtk_widget_grab_focus() to place the focus
// accordingly; if returning FALSE, they don’t modify the current focus
// location.
//
// The function takes the following parameters:
//
//    - direction of focus movement.
//
// The function returns the following values:
//
//    - ok: TRUE if focus ended up inside widget.
//
func (widget *Widget) ChildFocus(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_widget_child_focus(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildNotify emits a Widget::child-notify signal for the [child
// property][child-properties] child_property on widget.
//
// This is the analogue of g_object_notify() for child properties.
//
// Also see gtk_container_child_notify().
//
// The function takes the following parameters:
//
//    - childProperty: name of a child property installed on the class of
//      widget’s parent.
//
func (widget *Widget) ChildNotify(childProperty string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(childProperty)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_child_notify(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(childProperty)
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible. Containers should check this, rather than looking at
// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly set on
// the widget itself, or, if none has been explicitly set, the widget may expand
// if some of its children do.
//
// The function takes the following parameters:
//
//    - orientation: expand direction.
//
// The function returns the following values:
//
//    - ok: whether widget tree rooted here should be expanded.
//
func (widget *Widget) ComputeExpand(orientation Orientation) bool {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_widget_compute_expand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreatePangoContext creates a new Context with the appropriate font map, font
// options, font description, and base direction for drawing text for this
// widget. See also gtk_widget_get_pango_context().
//
// The function returns the following values:
//
//    - context: new Context.
//
func (widget *Widget) CreatePangoContext() *pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_create_pango_context(_arg0)
	runtime.KeepAlive(widget)

	var _context *pango.Context // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_context = &pango.Context{
			Object: obj,
		}
	}

	return _context
}

// CreatePangoLayout creates a new Layout with the appropriate font map, font
// description, and base direction for drawing text for this widget.
//
// If you keep a Layout created in this way around, you need to re-create it
// when the widget Context is replaced. This can be tracked by using the
// Widget::screen-changed signal on the widget.
//
// The function takes the following parameters:
//
//    - text (optional) to set on the layout (can be NULL).
//
// The function returns the following values:
//
//    - layout: new Layout.
//
func (widget *Widget) CreatePangoLayout(text string) *pango.Layout {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.gchar       // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if text != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_widget_create_pango_layout(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(text)

	var _layout *pango.Layout // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// Destroy destroys a widget.
//
// When a widget is destroyed all references it holds on other objects will be
// released:
//
//    - if the widget is inside a container, it will be removed from its
//    parent
//    - if the widget is a container, all its children will be destroyed,
//    recursively
//    - if the widget is a top level, it will be removed from the list
//    of top level widgets that GTK+ maintains internally
//
// It's expected that all references held on the widget will also be released;
// you should connect to the Widget::destroy signal if you hold a reference to
// widget and you wish to remove it when this function is called. It is not
// necessary to do so if you are implementing a Container, as you'll be able to
// use the ContainerClass.remove() virtual function for that.
//
// It's important to notice that gtk_widget_destroy() will only cause the widget
// to be finalized if no additional references, acquired using g_object_ref(),
// are held on it. In case additional references are in place, the widget will
// be in an "inert" state after calling this function; widget will still point
// to valid memory, allowing you to release the references you hold, but you may
// not query the widget's own state.
//
// You should typically call this function on top level widgets, and rarely on
// child widgets.
//
// See also: gtk_container_remove().
func (widget *Widget) Destroy() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_destroy(_arg0)
	runtime.KeepAlive(widget)
}

// DeviceIsShadowed returns TRUE if device has been shadowed by a GTK+ device
// grab on another widget, so it would stop sending events to widget. This may
// be used in the Widget::grab-notify signal to check for specific devices. See
// gtk_device_grab_add().
//
// The function takes the following parameters:
//
//    - device: Device.
//
// The function returns the following values:
//
//    - ok: TRUE if there is an ongoing grab on device by another Widget than
//      widget.
//
func (widget *Widget) DeviceIsShadowed(device gdk.Devicer) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gtk_widget_device_is_shadowed(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Draw draws widget to cr. The top left corner of the widget will be drawn to
// the currently set origin point of cr.
//
// You should pass a cairo context as cr argument that is in an original state.
// Otherwise the resulting drawing is undefined. For example changing the
// operator using cairo_set_operator() or the line width using
// cairo_set_line_width() might have unwanted side effects. You may however
// change the context’s transform matrix - like with cairo_scale(),
// cairo_translate() or cairo_set_matrix() and clip region with cairo_clip()
// prior to calling this function. Also, it is fine to modify the context with
// cairo_save() and cairo_push_group() prior to calling this function.
//
// Note that special-purpose widgets may contain special code for rendering to
// the screen and might appear differently on screen and when rendered using
// gtk_widget_draw().
//
// The function takes the following parameters:
//
//    - cr: cairo context to draw to.
//
func (widget *Widget) Draw(cr *cairo.Context) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.cairo_t   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gtk_widget_draw(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cr)
}

// ErrorBell notifies the user about an input-related error on this widget. If
// the Settings:gtk-error-bell setting is TRUE, it calls gdk_window_beep(),
// otherwise it does nothing.
//
// Note that the effect of gdk_window_beep() can be configured in many ways,
// depending on the windowing backend and the desktop environment or window
// manager that is used.
func (widget *Widget) ErrorBell() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_error_bell(_arg0)
	runtime.KeepAlive(widget)
}

// Event: rarely-used function. This function is used to emit the event signals
// on a widget (those signals should never be emitted without using this
// function to do so). If you want to synthesize an event though, don’t use this
// function; instead, use gtk_main_do_event() so the event will behave as if it
// were in the event queue. Don’t synthesize expose events; instead, use
// gdk_window_invalidate_rect() to invalidate a region of the window.
//
// The function takes the following parameters:
//
//    - event: Event.
//
// The function returns the following values:
//
//    - ok: return from the event signal emission (TRUE if the event was
//      handled).
//
func (widget *Widget) Event(event *gdk.Event) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkEvent  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_widget_event(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FreezeChildNotify stops emission of Widget::child-notify signals on widget.
// The signals are queued until gtk_widget_thaw_child_notify() is called on
// widget.
//
// This is the analogue of g_object_freeze_notify() for child properties.
func (widget *Widget) FreezeChildNotify() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_freeze_child_notify(_arg0)
	runtime.KeepAlive(widget)
}

// Accessible returns the accessible object that describes the widget to an
// assistive technology.
//
// If accessibility support is not available, this Object instance may be a
// no-op. Likewise, if no class-specific Object implementation is available for
// the widget instance in question, it will inherit an Object implementation
// from the first ancestor class for which such an implementation is defined.
//
// The documentation of the ATK (http://developer.gnome.org/atk/stable/) library
// contains more information about accessible objects and their uses.
//
// The function returns the following values:
//
//    - object associated with widget.
//
func (widget *Widget) Accessible() *atk.ObjectClass {
	var _arg0 *C.GtkWidget // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_accessible(_arg0)
	runtime.KeepAlive(widget)

	var _object *atk.ObjectClass // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_object = &atk.ObjectClass{
			Object: obj,
		}
	}

	return _object
}

// ActionGroup retrieves the Group that was registered using prefix. The
// resulting Group may have been registered to widget or any Widget in its
// ancestry.
//
// If no action group was found matching prefix, then NULL is returned.
//
// The function takes the following parameters:
//
//    - prefix: “prefix” of the action group.
//
// The function returns the following values:
//
//    - actionGroup (optional) or NULL.
//
func (widget *Widget) ActionGroup(prefix string) *gio.ActionGroup {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.gchar        // out
	var _cret *C.GActionGroup // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(prefix)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_widget_get_action_group(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(prefix)

	var _actionGroup *gio.ActionGroup // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_actionGroup = &gio.ActionGroup{
				Object: obj,
			}
		}
	}

	return _actionGroup
}

// AllocatedBaseline returns the baseline that has currently been allocated to
// widget. This function is intended to be used when implementing handlers for
// the Widget::draw function, and when allocating child widgets in
// Widget::size_allocate.
//
// The function returns the following values:
//
//    - gint: baseline of the widget, or -1 if none.
//
func (widget *Widget) AllocatedBaseline() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_baseline(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// AllocatedHeight returns the height that has currently been allocated to
// widget. This function is intended to be used when implementing handlers for
// the Widget::draw function.
//
// The function returns the following values:
//
//    - gint: height of the widget.
//
func (widget *Widget) AllocatedHeight() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_height(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// AllocatedSize retrieves the widget’s allocated size.
//
// This function returns the last values passed to
// gtk_widget_size_allocate_with_baseline(). The value differs from the size
// returned in gtk_widget_get_allocation() in that functions like
// gtk_widget_set_halign() can adjust the allocation, but not the value returned
// by this function.
//
// If a widget is not visible, its allocated size is 0.
//
// The function returns the following values:
//
//    - allocation: pointer to a Allocation to copy to.
//    - baseline (optional): pointer to an integer to copy to.
//
func (widget *Widget) AllocatedSize() (*Allocation, int32) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkAllocation // in
	var _arg2 C.int           // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_allocated_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _allocation *Allocation // out
	var _baseline int32         // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_baseline = int32(_arg2)

	return _allocation, _baseline
}

// AllocatedWidth returns the width that has currently been allocated to widget.
// This function is intended to be used when implementing handlers for the
// Widget::draw function.
//
// The function returns the following values:
//
//    - gint: width of the widget.
//
func (widget *Widget) AllocatedWidth() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_width(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Allocation retrieves the widget’s allocation.
//
// Note, when implementing a Container: a widget’s allocation will be its
// “adjusted” allocation, that is, the widget’s parent container typically calls
// gtk_widget_size_allocate() with an allocation, and that allocation is then
// adjusted (to handle margin and alignment for example) before assignment to
// the widget. gtk_widget_get_allocation() returns the adjusted allocation that
// was actually assigned to the widget. The adjusted allocation is guaranteed to
// be completely contained within the gtk_widget_size_allocate() allocation,
// however. So a Container is guaranteed that its children stay inside the
// assigned bounds, but not that they have exactly the bounds the container
// assigned. There is no way to get the original allocation assigned by
// gtk_widget_size_allocate(), since it isn’t stored; if a container
// implementation needs that information it will have to track it itself.
//
// The function returns the following values:
//
//    - allocation: pointer to a Allocation to copy to.
//
func (widget *Widget) Allocation() *Allocation {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkAllocation // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_allocation(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _allocation
}

// Ancestor gets the first ancestor of widget with type widget_type. For
// example, gtk_widget_get_ancestor (widget, GTK_TYPE_BOX) gets the first Box
// that’s an ancestor of widget. No reference will be added to the returned
// widget; it should not be unreferenced. See note about checking for a toplevel
// Window in the docs for gtk_widget_get_toplevel().
//
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers widget to be an ancestor of itself.
//
// The function takes the following parameters:
//
//    - widgetType: ancestor type.
//
// The function returns the following values:
//
//    - ret (optional): ancestor widget, or NULL if not found.
//
func (widget *Widget) Ancestor(widgetType coreglib.Type) Widgetter {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GType(widgetType)

	_cret = C.gtk_widget_get_ancestor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(widgetType)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// AppPaintable determines whether the application intends to draw on the widget
// in an Widget::draw handler.
//
// See gtk_widget_set_app_paintable().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is app paintable.
//
func (widget *Widget) AppPaintable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_app_paintable(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanDefault determines whether widget can be a default widget. See
// gtk_widget_set_can_default().
//
// The function returns the following values:
//
//    - ok: TRUE if widget can be a default widget, FALSE otherwise.
//
func (widget *Widget) CanDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_can_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanFocus determines whether widget can own the input focus. See
// gtk_widget_set_can_focus().
//
// The function returns the following values:
//
//    - ok: TRUE if widget can own the input focus, FALSE otherwise.
//
func (widget *Widget) CanFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_can_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildRequisition: this function is only for use in widget implementations.
// Obtains widget->requisition, unless someone has forced a particular geometry
// on the widget (e.g. with gtk_widget_set_size_request()), in which case it
// returns that geometry instead of the widget's requisition.
//
// This function differs from gtk_widget_size_request() in that it retrieves the
// last size request value from widget->requisition, while
// gtk_widget_size_request() actually calls the "size_request" method on widget
// to compute the size request and fill in widget->requisition, and only then
// returns widget->requisition.
//
// Because this function does not call the “size_request” method, it can only be
// used when you know that widget->requisition is up-to-date, that is,
// gtk_widget_size_request() has been called since the last time a resize was
// queued. In general, only container implementations have this information;
// applications should use gtk_widget_size_request().
//
// Deprecated: Use gtk_widget_get_preferred_size() instead.
//
// The function returns the following values:
//
//    - requisition to be filled in.
//
func (widget *Widget) ChildRequisition() *Requisition {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_child_requisition(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _requisition
}

// ChildVisible gets the value set with gtk_widget_set_child_visible(). If you
// feel a need to use this function, your code probably needs reorganization.
//
// This function is only useful for container implementations and never should
// be called by an application.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is mapped with the parent.
//
func (widget *Widget) ChildVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_child_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Clip retrieves the widget’s clip area.
//
// The clip area is the area in which all of widget's drawing will happen. Other
// toolkits call it the bounding box.
//
// Historically, in GTK+ the clip area has been equal to the allocation
// retrieved via gtk_widget_get_allocation().
//
// The function returns the following values:
//
//    - clip: pointer to a Allocation to copy to.
//
func (widget *Widget) Clip() *Allocation {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkAllocation // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_clip(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _clip *Allocation // out

	_clip = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _clip
}

// CompositeName obtains the composite name of a widget.
//
// Deprecated: Use gtk_widget_class_set_template(), or don’t use this API at
// all.
//
// The function returns the following values:
//
//    - utf8: composite name of widget, or NULL if widget is not a composite
//      child. The string should be freed when it is no longer needed.
//
func (widget *Widget) CompositeName() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_composite_name(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// DeviceEnabled returns whether device can interact with widget and its
// children. See gtk_widget_set_device_enabled().
//
// The function takes the following parameters:
//
//    - device: Device.
//
// The function returns the following values:
//
//    - ok: TRUE is device is enabled for widget.
//
func (widget *Widget) DeviceEnabled(device gdk.Devicer) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gtk_widget_get_device_enabled(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceEvents returns the events mask for the widget corresponding to an
// specific device. These are the events that the widget will receive when
// device operates on it.
//
// The function takes the following parameters:
//
//    - device: Device.
//
// The function returns the following values:
//
//    - eventMask: device event mask for widget.
//
func (widget *Widget) DeviceEvents(device gdk.Devicer) gdk.EventMask {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _cret C.GdkEventMask // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gtk_widget_get_device_events(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)

	var _eventMask gdk.EventMask // out

	_eventMask = gdk.EventMask(_cret)

	return _eventMask
}

// Direction gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
//
// The function returns the following values:
//
//    - textDirection: reading direction for the widget.
//
func (widget *Widget) Direction() TextDirection {
	var _arg0 *C.GtkWidget       // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_direction(_arg0)
	runtime.KeepAlive(widget)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// Display: get the Display for the toplevel window associated with this widget.
// This function can only be called after the widget has been added to a widget
// hierarchy with a Window at the top.
//
// In general, you should only create display specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
//
// The function returns the following values:
//
//    - display for the toplevel for this widget.
//
func (widget *Widget) Display() *gdk.Display {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_display(_arg0)
	runtime.KeepAlive(widget)

	var _display *gdk.Display // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_display = &gdk.Display{
			Object: obj,
		}
	}

	return _display
}

// DoubleBuffered determines whether the widget is double buffered.
//
// See gtk_widget_set_double_buffered().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is double buffered.
//
func (widget *Widget) DoubleBuffered() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_double_buffered(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Events returns the event mask (see EventMask) for the widget. These are the
// events that the widget will receive.
//
// Note: Internally, the widget event mask will be the logical OR of the event
// mask set through gtk_widget_set_events() or gtk_widget_add_events(), and the
// event mask necessary to cater for every EventController created for the
// widget.
//
// The function returns the following values:
//
//    - gint: event mask for widget.
//
func (widget *Widget) Events() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_events(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// FocusOnClick returns whether the widget should grab focus when it is clicked
// with the mouse. See gtk_widget_set_focus_on_click().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget should grab focus when it is clicked with the
//      mouse.
//
func (widget *Widget) FocusOnClick() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_focus_on_click(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FontMap gets the font map that has been set with gtk_widget_set_font_map().
//
// The function returns the following values:
//
//    - fontMap (optional) or NULL.
//
func (widget *Widget) FontMap() pango.FontMapper {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoFontMap // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_font_map(_arg0)
	runtime.KeepAlive(widget)

	var _fontMap pango.FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontMapper)
				return ok
			})
			rv, ok := casted.(pango.FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// FontOptions returns the #cairo_font_options_t used for Pango rendering. When
// not set, the defaults font options for the Screen will be used.
//
// The function returns the following values:
//
//    - fontOptions (optional) or NULL if not set.
//
func (widget *Widget) FontOptions() *cairo.FontOptions {
	var _arg0 *C.GtkWidget            // out
	var _cret *C.cairo_font_options_t // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_font_options(_arg0)
	runtime.KeepAlive(widget)

	var _fontOptions *cairo.FontOptions // out

	if _cret != nil {
		_fontOptions = (*cairo.FontOptions)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _fontOptions
}

// FrameClock obtains the frame clock for a widget. The frame clock is a global
// “ticker” that can be used to drive animations and repaints. The most common
// reason to get the frame clock is to call gdk_frame_clock_get_frame_time(), in
// order to get a time to use for animating. For example you might record the
// start of the animation with an initial value from
// gdk_frame_clock_get_frame_time(), and then update the animation by calling
// gdk_frame_clock_get_frame_time() again during each repaint.
//
// gdk_frame_clock_request_phase() will result in a new frame on the clock, but
// won’t necessarily repaint any widgets. To repaint a widget, you have to use
// gtk_widget_queue_draw() which invalidates the widget (thus scheduling it to
// receive a draw on the next frame). gtk_widget_queue_draw() will also end up
// requesting a frame on the appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
//
// The function returns the following values:
//
//    - frameClock (optional) NULL if widget is unrealized.
//
func (widget *Widget) FrameClock() gdk.FrameClocker {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GdkFrameClock // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_frame_clock(_arg0)
	runtime.KeepAlive(widget)

	var _frameClock gdk.FrameClocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.FrameClocker)
				return ok
			})
			rv, ok := casted.(gdk.FrameClocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.FrameClocker")
			}
			_frameClock = rv
		}
	}

	return _frameClock
}

// HAlign gets the value of the Widget:halign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
//
// The function returns the following values:
//
//    - align: horizontal alignment of widget.
//
func (widget *Widget) HAlign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_halign(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// HasTooltip returns the current value of the has-tooltip property. See
// Widget:has-tooltip for more information.
//
// The function returns the following values:
//
//    - ok: current value of has-tooltip on widget.
//
func (widget *Widget) HasTooltip() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_has_tooltip(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasWindow determines whether widget has a Window of its own. See
// gtk_widget_set_has_window().
//
// The function returns the following values:
//
//    - ok: TRUE if widget has a window, FALSE otherwise.
//
func (widget *Widget) HasWindow() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_has_window(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HExpand gets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or document
// in your window would often be set to expand.
//
// Containers should use gtk_widget_compute_expand() rather than this function,
// to see whether a widget, or any of its children, has the expand flag set. If
// any child of a widget wants to expand, the parent may ask to expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
//
// The function returns the following values:
//
//    - ok: whether hexpand flag is set.
//
func (widget *Widget) HExpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_hexpand(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HExpandSet gets whether gtk_widget_set_hexpand() has been used to explicitly
// set the expand flag on this widget.
//
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
//
// The function returns the following values:
//
//    - ok: whether hexpand has been explicitly set.
//
func (widget *Widget) HExpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_hexpand_set(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Mapped: whether the widget is mapped.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is mapped, FALSE otherwise.
//
func (widget *Widget) Mapped() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_mapped(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MarginBottom gets the value of the Widget:margin-bottom property.
//
// The function returns the following values:
//
//    - gint: bottom margin of widget.
//
func (widget *Widget) MarginBottom() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_bottom(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// MarginEnd gets the value of the Widget:margin-end property.
//
// The function returns the following values:
//
//    - gint: end margin of widget.
//
func (widget *Widget) MarginEnd() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_end(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// MarginLeft gets the value of the Widget:margin-left property.
//
// Deprecated: Use gtk_widget_get_margin_start() instead.
//
// The function returns the following values:
//
//    - gint: left margin of widget.
//
func (widget *Widget) MarginLeft() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_left(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// MarginRight gets the value of the Widget:margin-right property.
//
// Deprecated: Use gtk_widget_get_margin_end() instead.
//
// The function returns the following values:
//
//    - gint: right margin of widget.
//
func (widget *Widget) MarginRight() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_right(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// MarginStart gets the value of the Widget:margin-start property.
//
// The function returns the following values:
//
//    - gint: start margin of widget.
//
func (widget *Widget) MarginStart() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_start(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// MarginTop gets the value of the Widget:margin-top property.
//
// The function returns the following values:
//
//    - gint: top margin of widget.
//
func (widget *Widget) MarginTop() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_top(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// ModifierMask returns the modifier mask the widget’s windowing system backend
// uses for a particular purpose.
//
// See gdk_keymap_get_modifier_mask().
//
// The function takes the following parameters:
//
//    - intent: use case for the modifier mask.
//
// The function returns the following values:
//
//    - modifierType: modifier mask used for intent.
//
func (widget *Widget) ModifierMask(intent gdk.ModifierIntent) gdk.ModifierType {
	var _arg0 *C.GtkWidget        // out
	var _arg1 C.GdkModifierIntent // out
	var _cret C.GdkModifierType   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GdkModifierIntent(intent)

	_cret = C.gtk_widget_get_modifier_mask(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(intent)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// Name retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
//
// The function returns the following values:
//
//    - utf8: name of the widget. This string is owned by GTK+ and should not be
//      modified or freed.
//
func (widget *Widget) Name() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_name(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NoShowAll returns the current value of the Widget:no-show-all property, which
// determines whether calls to gtk_widget_show_all() will affect this widget.
//
// The function returns the following values:
//
//    - ok: current value of the “no-show-all” property.
//
func (widget *Widget) NoShowAll() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_no_show_all(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Opacity fetches the requested opacity for this widget. See
// gtk_widget_set_opacity().
//
// The function returns the following values:
//
//    - gdouble: requested opacity for this widget.
//
func (widget *Widget) Opacity() float64 {
	var _arg0 *C.GtkWidget // out
	var _cret C.double     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_opacity(_arg0)
	runtime.KeepAlive(widget)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PangoContext gets a Context with the appropriate font map, font description,
// and base direction for this widget. Unlike the context returned by
// gtk_widget_create_pango_context(), this context is owned by the widget (it
// can be used until the screen for the widget changes or the widget is removed
// from its toplevel), and will be updated to match any changes to the widget’s
// attributes. This can be tracked by using the Widget::screen-changed signal on
// the widget.
//
// The function returns the following values:
//
//    - context for the widget.
//
func (widget *Widget) PangoContext() *pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_pango_context(_arg0)
	runtime.KeepAlive(widget)

	var _context *pango.Context // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_context = &pango.Context{
			Object: obj,
		}
	}

	return _context
}

// Parent returns the parent container of widget.
//
// The function returns the following values:
//
//    - ret (optional): parent container of widget, or NULL.
//
func (widget *Widget) Parent() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_parent(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// ParentWindow gets widget’s parent window, or NULL if it does not have one.
//
// The function returns the following values:
//
//    - window (optional): parent window of widget, or NULL if it does not have a
//      parent window.
//
func (widget *Widget) ParentWindow() gdk.Windower {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_parent_window(_arg0)
	runtime.KeepAlive(widget)

	var _window gdk.Windower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Windower)
				return ok
			})
			rv, ok := casted.(gdk.Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _window
}

// GetPath returns the WidgetPath representing widget, if the widget is not
// connected to a toplevel widget, a partial path will be created.
//
// The function returns the following values:
//
//    - widgetPath representing widget.
//
func (widget *Widget) GetPath() *WidgetPath {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_path(_arg0)
	runtime.KeepAlive(widget)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_widget_path_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_widget_path_free((*C.GtkWidgetPath)(intern.C))
		},
	)

	return _widgetPath
}

// Pointer obtains the location of the mouse pointer in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are defined as
// widget->window coordinates for widgets that return TRUE for
// gtk_widget_get_has_window(); and are relative to widget->allocation.x,
// widget->allocation.y otherwise.
//
// Deprecated: Use gdk_window_get_device_position() instead.
//
// The function returns the following values:
//
//    - x (optional): return location for the X coordinate, or NULL.
//    - y (optional): return location for the Y coordinate, or NULL.
//
func (widget *Widget) Pointer() (x, y int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_pointer(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _x int32 // out
	var _y int32 // out

	_x = int32(_arg1)
	_y = int32(_arg2)

	return _x, _y
}

// PreferredHeight retrieves a widget’s initial minimum and natural height.
//
// This call is specific to width-for-height requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location to store the minimum height, or NULL.
//    - naturalHeight (optional): location to store the natural height, or NULL.
//
func (widget *Widget) PreferredHeight() (minimumHeight, naturalHeight int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_preferred_height(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumHeight int32 // out
	var _naturalHeight int32 // out

	_minimumHeight = int32(_arg1)
	_naturalHeight = int32(_arg2)

	return _minimumHeight, _naturalHeight
}

// PreferredHeightAndBaselineForWidth retrieves a widget’s minimum and natural
// height and the corresponding baselines if it would be given the specified
// width, or the default height if width is -1. The baselines may be -1 which
// means that no baseline is requested for this widget.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request and
// GtkWidgetClass::adjust_baseline_request virtual methods and by any SizeGroups
// that have been applied. That is, the returned request is the one that should
// be used for layout, not necessarily the one returned by the widget itself.
//
// The function takes the following parameters:
//
//    - width which is available for allocation, or -1 if none.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location for storing the minimum height, or
//      NULL.
//    - naturalHeight (optional): location for storing the natural height, or
//      NULL.
//    - minimumBaseline (optional): location for storing the baseline for the
//      minimum height, or NULL.
//    - naturalBaseline (optional): location for storing the baseline for the
//      natural height, or NULL.
//
func (widget *Widget) PreferredHeightAndBaselineForWidth(width int32) (minimumHeight, naturalHeight, minimumBaseline, naturalBaseline int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in
	var _arg4 C.gint       // in
	var _arg5 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(width)

	C.gtk_widget_get_preferred_height_and_baseline_for_width(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int32   // out
	var _naturalHeight int32   // out
	var _minimumBaseline int32 // out
	var _naturalBaseline int32 // out

	_minimumHeight = int32(_arg2)
	_naturalHeight = int32(_arg3)
	_minimumBaseline = int32(_arg4)
	_naturalBaseline = int32(_arg5)

	return _minimumHeight, _naturalHeight, _minimumBaseline, _naturalBaseline
}

// PreferredHeightForWidth retrieves a widget’s minimum and natural height if it
// would be given the specified width.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function takes the following parameters:
//
//    - width which is available for allocation.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location for storing the minimum height, or
//      NULL.
//    - naturalHeight (optional): location for storing the natural height, or
//      NULL.
//
func (widget *Widget) PreferredHeightForWidth(width int32) (minimumHeight, naturalHeight int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(width)

	C.gtk_widget_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int32 // out
	var _naturalHeight int32 // out

	_minimumHeight = int32(_arg2)
	_naturalHeight = int32(_arg3)

	return _minimumHeight, _naturalHeight
}

// PreferredSize retrieves the minimum and natural size of a widget, taking into
// account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do not
// impose any restrictions on the child placement. It can be used to deduce
// toplevel window and menu sizes as well as child widgets in free-form
// containers such as GtkLayout.
//
// Handle with care. Note that the natural height of a height-for-width widget
// will generally be a smaller size than the minimum height, since the required
// height for the natural width is generally smaller than the required height
// for the minimum width.
//
// Use gtk_widget_get_preferred_height_and_baseline_for_width() if you want to
// support baseline alignment.
//
// The function returns the following values:
//
//    - minimumSize (optional): location for storing the minimum size, or NULL.
//    - naturalSize (optional): location for storing the natural size, or NULL.
//
func (widget *Widget) PreferredSize() (minimumSize, naturalSize *Requisition) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in
	var _arg2 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_preferred_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumSize *Requisition // out
	var _naturalSize *Requisition // out

	_minimumSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_naturalSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _minimumSize, _naturalSize
}

// PreferredWidth retrieves a widget’s initial minimum and natural width.
//
// This call is specific to height-for-width requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location to store the minimum width, or NULL.
//    - naturalWidth (optional): location to store the natural width, or NULL.
//
func (widget *Widget) PreferredWidth() (minimumWidth, naturalWidth int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_preferred_width(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumWidth int32 // out
	var _naturalWidth int32 // out

	_minimumWidth = int32(_arg1)
	_naturalWidth = int32(_arg2)

	return _minimumWidth, _naturalWidth
}

// PreferredWidthForHeight retrieves a widget’s minimum and natural width if it
// would be given the specified height.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function takes the following parameters:
//
//    - height which is available for allocation.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location for storing the minimum width, or NULL.
//    - naturalWidth (optional): location for storing the natural width, or NULL.
//
func (widget *Widget) PreferredWidthForHeight(height int32) (minimumWidth, naturalWidth int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(height)

	C.gtk_widget_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int32 // out
	var _naturalWidth int32 // out

	_minimumWidth = int32(_arg2)
	_naturalWidth = int32(_arg3)

	return _minimumWidth, _naturalWidth
}

// Realized determines whether widget is realized.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is realized, FALSE otherwise.
//
func (widget *Widget) Realized() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_realized(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReceivesDefault determines whether widget is always treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// See gtk_widget_set_receives_default().
//
// The function returns the following values:
//
//    - ok: TRUE if widget acts as the default widget when focused, FALSE
//      otherwise.
//
func (widget *Widget) ReceivesDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_receives_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
//
// Bin widgets generally propagate the preference of their child, container
// widgets need to request something either in context of their children or in
// context of their allocation capabilities.
//
// The function returns the following values:
//
//    - sizeRequestMode preferred by widget.
//
func (widget *Widget) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_request_mode(_arg0)
	runtime.KeepAlive(widget)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Requisition retrieves the widget’s requisition.
//
// This function should only be used by widget implementations in order to
// figure whether the widget’s requisition has actually changed after some
// internal state change (so that they can call gtk_widget_queue_resize()
// instead of gtk_widget_queue_draw()).
//
// Normally, gtk_widget_size_request() should be used.
//
// Deprecated: The Requisition cache on the widget was removed, If you need to
// cache sizes across requests and allocations, add an explicit cache to the
// widget in question instead.
//
// The function returns the following values:
//
//    - requisition: pointer to a Requisition to copy to.
//
func (widget *Widget) Requisition() *Requisition {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_requisition(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _requisition
}

// RootWindow: get the root window where this widget is located. This function
// can only be called after the widget has been added to a widget hierarchy with
// Window at the top.
//
// The root window is useful for such purposes as creating a popup Window
// associated with the window. In general, you should only create display
// specific resources when a widget has been realized, and you should free those
// resources when the widget is unrealized.
//
// Deprecated: Use gdk_screen_get_root_window() instead.
//
// The function returns the following values:
//
//    - window root window for the toplevel for this widget.
//
func (widget *Widget) RootWindow() gdk.Windower {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_root_window(_arg0)
	runtime.KeepAlive(widget)

	var _window gdk.Windower // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Windower is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Windower)
			return ok
		})
		rv, ok := casted.(gdk.Windower)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
		}
		_window = rv
	}

	return _window
}

// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels. On traditional systems this is 1, on
// high density outputs, it can be a higher value (typically 2).
//
// See gdk_window_get_scale_factor().
//
// The function returns the following values:
//
//    - gint: scale factor for widget.
//
func (widget *Widget) ScaleFactor() int32 {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_scale_factor(_arg0)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Screen: get the Screen from the toplevel window associated with this widget.
// This function can only be called after the widget has been added to a widget
// hierarchy with a Window at the top.
//
// In general, you should only create screen specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
//
// The function returns the following values:
//
//    - screen for the toplevel for this widget.
//
func (widget *Widget) Screen() *gdk.Screen {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkScreen // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_screen(_arg0)
	runtime.KeepAlive(widget)

	var _screen *gdk.Screen // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_screen = &gdk.Screen{
			Object: obj,
		}
	}

	return _screen
}

// Sensitive returns the widget’s sensitivity (in the sense of returning the
// value that has been set using gtk_widget_set_sensitive()).
//
// The effective sensitivity of a widget is however determined by both its own
// and its parent widget’s sensitivity. See gtk_widget_is_sensitive().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is sensitive.
//
func (widget *Widget) Sensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_sensitive(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Settings gets the settings object holding the settings used for this widget.
//
// Note that this function can only be called when the Widget is attached to a
// toplevel, since the settings object is specific to a particular Screen.
//
// The function returns the following values:
//
//    - settings: relevant Settings object.
//
func (widget *Widget) Settings() *Settings {
	var _arg0 *C.GtkWidget   // out
	var _cret *C.GtkSettings // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_settings(_arg0)
	runtime.KeepAlive(widget)

	var _settings *Settings // out

	_settings = wrapSettings(coreglib.Take(unsafe.Pointer(_cret)))

	return _settings
}

// GetSizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request(). A value of -1 stored in width or height
// indicates that that dimension has not been set explicitly and the natural
// requisition of the widget will be used instead. See
// gtk_widget_set_size_request(). To get the size a widget will actually
// request, call gtk_widget_get_preferred_size() instead of this function.
//
// The function returns the following values:
//
//    - width (optional): return location for width, or NULL.
//    - height (optional): return location for height, or NULL.
//
func (widget *Widget) GetSizeRequest() (width, height int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_size_request(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _width int32  // out
	var _height int32 // out

	_width = int32(_arg1)
	_height = int32(_arg2)

	return _width, _height
}

// State returns the widget’s state. See gtk_widget_set_state().
//
// Deprecated: Use gtk_widget_get_state_flags() instead.
//
// The function returns the following values:
//
//    - stateType: state of widget.
//
func (widget *Widget) State() StateType {
	var _arg0 *C.GtkWidget   // out
	var _cret C.GtkStateType // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_state(_arg0)
	runtime.KeepAlive(widget)

	var _stateType StateType // out

	_stateType = StateType(_cret)

	return _stateType
}

// StateFlags returns the widget state as a flag set. It is worth mentioning
// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned, that
// is, also based on parent insensitivity, even if widget itself is sensitive.
//
// Also note that if you are looking for a way to obtain the StateFlags to pass
// to a StyleContext method, you should look at gtk_style_context_get_state().
//
// The function returns the following values:
//
//    - stateFlags: state flags for widget.
//
func (widget *Widget) StateFlags() StateFlags {
	var _arg0 *C.GtkWidget    // out
	var _cret C.GtkStateFlags // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_state_flags(_arg0)
	runtime.KeepAlive(widget)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// StyleContext returns the style context associated to widget. The returned
// object is guaranteed to be the same for the lifetime of widget.
//
// The function returns the following values:
//
//    - styleContext This memory is owned by widget and must not be freed.
//
func (widget *Widget) StyleContext() *StyleContext {
	var _arg0 *C.GtkWidget       // out
	var _cret *C.GtkStyleContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_style_context(_arg0)
	runtime.KeepAlive(widget)

	var _styleContext *StyleContext // out

	_styleContext = wrapStyleContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _styleContext
}

// SupportMultidevice returns TRUE if widget is multiple pointer aware. See
// gtk_widget_set_support_multidevice() for more information.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is multidevice aware.
//
func (widget *Widget) SupportMultidevice() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_support_multidevice(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TemplateChild: fetch an object build from the template XML for widget_type in
// this widget instance.
//
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its variants.
//
// This function is only meant to be called for code which is private to the
// widget_type which declared the child and is meant for language bindings which
// cannot easily make use of the GObject structure offsets.
//
// The function takes the following parameters:
//
//    - widgetType to get a template child for.
//    - name: “id” of the child defined in the template XML.
//
// The function returns the following values:
//
//    - object built in the template XML with the id name.
//
func (widget *Widget) TemplateChild(widgetType coreglib.Type, name string) *coreglib.Object {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _arg2 *C.gchar     // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GType(widgetType)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_get_template_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(widgetType)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// TooltipMarkup gets the contents of the tooltip for widget.
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip text, or NULL. You should free the returned
//      string with g_free() when done.
//
func (widget *Widget) TooltipMarkup() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_markup(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// TooltipText gets the contents of the tooltip for widget.
//
// The function returns the following values:
//
//    - utf8 (optional): tooltip text, or NULL. You should free the returned
//      string with g_free() when done.
//
func (widget *Widget) TooltipText() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_text(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// TooltipWindow returns the Window of the current tooltip. This can be the
// GtkWindow created by default, or the custom tooltip window set using
// gtk_widget_set_tooltip_window().
//
// The function returns the following values:
//
//    - window of the current tooltip.
//
func (widget *Widget) TooltipWindow() *Window {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_window(_arg0)
	runtime.KeepAlive(widget)

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))

	return _window
}

// Toplevel: this function returns the topmost widget in the container hierarchy
// widget is a part of. If widget has no parent widgets, it will be returned as
// the topmost widget. No reference will be added to the returned widget; it
// should not be unreferenced.
//
// Note the difference in behavior vs. gtk_widget_get_ancestor();
// gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW) would return NULL if widget
// wasn’t inside a toplevel window, and if the window was inside a
// Window-derived widget which was in turn inside the toplevel Window. While the
// second case may seem unlikely, it actually happens when a Plug is embedded
// inside a Socket within the same application.
//
// To reliably find the toplevel Window, use gtk_widget_get_toplevel() and call
// GTK_IS_WINDOW() on the result. For instance, to get the title of a widget's
// toplevel window, one might use:
//
//    static const char *
//    get_widget_toplevel_title (GtkWidget *widget)
//    {
//      GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
//      if (GTK_IS_WINDOW (toplevel))
//        {
//          return gtk_window_get_title (GTK_WINDOW (toplevel));
//        }
//
//      return NULL;
//    }.
//
// The function returns the following values:
//
//    - ret: topmost ancestor of widget, or widget itself if there’s no ancestor.
//
func (widget *Widget) Toplevel() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_toplevel(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_ret = rv
	}

	return _ret
}

// VAlign gets the value of the Widget:valign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL. If your
// widget want to support baseline aligned children it must use
// gtk_widget_get_valign_with_baseline(), or g_object_get (widget, "valign",
// &value, NULL), which will also report the true value.
//
// The function returns the following values:
//
//    - align: vertical alignment of widget, ignoring baseline alignment.
//
func (widget *Widget) VAlign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_valign(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// VAlignWithBaseline gets the value of the Widget:valign property, including
// GTK_ALIGN_BASELINE.
//
// The function returns the following values:
//
//    - align: vertical alignment of widget.
//
func (widget *Widget) VAlignWithBaseline() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_valign_with_baseline(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// VExpand gets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_get_hexpand() for more detail.
//
// The function returns the following values:
//
//    - ok: whether vexpand flag is set.
//
func (widget *Widget) VExpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_vexpand(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VExpandSet gets whether gtk_widget_set_vexpand() has been used to explicitly
// set the expand flag on this widget.
//
// See gtk_widget_get_hexpand_set() for more detail.
//
// The function returns the following values:
//
//    - ok: whether vexpand has been explicitly set.
//
func (widget *Widget) VExpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_vexpand_set(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visible determines whether the widget is visible. If you want to take into
// account whether the widget’s parent is also marked as visible, use
// gtk_widget_is_visible() instead.
//
// This function does not check if the widget is obscured in any way.
//
// See gtk_widget_set_visible().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is visible.
//
func (widget *Widget) Visible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visual gets the visual that will be used to render widget.
//
// The function returns the following values:
//
//    - visual for widget.
//
func (widget *Widget) Visual() *gdk.Visual {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkVisual // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_visual(_arg0)
	runtime.KeepAlive(widget)

	var _visual *gdk.Visual // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_visual = &gdk.Visual{
			Object: obj,
		}
	}

	return _visual
}

// Window returns the widget’s window if it is realized, NULL otherwise.
//
// The function returns the following values:
//
//    - window (optional) widget’s window.
//
func (widget *Widget) Window() gdk.Windower {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_window(_arg0)
	runtime.KeepAlive(widget)

	var _window gdk.Windower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Windower)
				return ok
			})
			rv, ok := casted.(gdk.Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _window
}

// GrabDefault causes widget to become the default widget. widget must be able
// to be a default widget; typically you would ensure this yourself by calling
// gtk_widget_set_can_default() with a TRUE value. The default widget is
// activated when the user presses Enter in a window. Default widgets must be
// activatable, that is, gtk_widget_activate() should affect them. Note that
// Entry widgets require the “activates-default” property set to TRUE before
// they activate the default widget when Enter is pressed and the Entry is
// focused.
func (widget *Widget) GrabDefault() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_grab_default(_arg0)
	runtime.KeepAlive(widget)
}

// GrabFocus causes widget to have the keyboard focus for the Window it's
// inside. widget must be a focusable widget, such as a Entry; something like
// Frame won’t work.
//
// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
// gtk_widget_set_can_focus() to modify that flag.
//
// The widget also needs to be realized and mapped. This is indicated by the
// related signals. Grabbing the focus immediately after creating the widget
// will likely fail and cause critical warnings.
func (widget *Widget) GrabFocus() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_grab_focus(_arg0)
	runtime.KeepAlive(widget)
}

// HasDefault determines whether widget is the current default widget within its
// toplevel. See gtk_widget_set_can_default().
//
// The function returns the following values:
//
//    - ok: TRUE if widget is the current default widget within its toplevel,
//      FALSE otherwise.
//
func (widget *Widget) HasDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasFocus determines if the widget has the global input focus. See
// gtk_widget_is_focus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget has the global input focus.
//
func (widget *Widget) HasFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasGrab determines whether the widget is currently grabbing events, so it is
// the only widget receiving input events (keyboard and mouse).
//
// See also gtk_grab_add().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is in the grab_widgets stack.
//
func (widget *Widget) HasGrab() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_grab(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasScreen checks whether there is a Screen is associated with this widget.
// All toplevel widgets have an associated screen, and all widgets added into a
// hierarchy with a toplevel window at the top.
//
// The function returns the following values:
//
//    - ok: TRUE if there is a Screen associated with the widget.
//
func (widget *Widget) HasScreen() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_screen(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus. This is a convenience function for use in
// ::draw handlers that takes into account whether focus indication should
// currently be shown in the toplevel window of widget. See
// gtk_window_get_focus_visible() for more information about focus indication.
//
// To find out if the widget has the global input focus, use
// gtk_widget_has_focus().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget should display a “focus rectangle”.
//
func (widget *Widget) HasVisibleFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_visible_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
func (widget *Widget) Hide() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_hide(_arg0)
	runtime.KeepAlive(widget)
}

// HideOnDelete: utility function; intended to be connected to the
// Widget::delete-event signal on a Window. The function calls gtk_widget_hide()
// on its argument, then returns TRUE. If connected to ::delete-event, the
// result is that clicking the close button for a window (on the window frame,
// top right corner usually) will hide but not destroy the window. By default,
// GTK+ destroys windows when ::delete-event is received.
//
// The function returns the following values:
//
//    - ok: TRUE.
//
func (widget *Widget) HideOnDelete() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_hide_on_delete(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InDestruction returns whether the widget is currently being destroyed. This
// information can sometimes be used to avoid doing unnecessary work.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is being destroyed.
//
func (widget *Widget) InDestruction() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_in_destruction(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InitTemplate creates and initializes child widgets defined in templates. This
// function must be called in the instance initializer for any class which
// assigned itself a template using gtk_widget_class_set_template()
//
// It is important to call this function in the instance initializer of a Widget
// subclass and not in #GObject.constructed() or #GObject.constructor() for two
// reasons.
//
// One reason is that generally derived widgets will assume that parent class
// composite widgets have been created in their instance initializers.
//
// Another reason is that when calling g_object_new() on a widget with composite
// templates, it’s important to build the composite widgets before the construct
// properties are set. Properties passed to g_object_new() should take
// precedence over properties set in the private template XML.
func (widget *Widget) InitTemplate() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_init_template(_arg0)
	runtime.KeepAlive(widget)
}

// InputShapeCombineRegion sets an input shape for this widget’s GDK window.
// This allows for windows which react to mouse click in a nonrectangular
// region, see gdk_window_input_shape_combine_region() for more information.
//
// The function takes the following parameters:
//
//    - region (optional): shape to be added, or NULL to remove an existing
//      shape.
//
func (widget *Widget) InputShapeCombineRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if region != nil {
		_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	}

	C.gtk_widget_input_shape_combine_region(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)
}

// InsertActionGroup inserts group into widget. Children of widget that
// implement Actionable can then be associated with actions in group by setting
// their “action-name” to prefix.action-name.
//
// If group is NULL, a previously inserted group for name is removed from
// widget.
//
// The function takes the following parameters:
//
//    - name: prefix for actions in group.
//    - group (optional) or NULL.
//
func (widget *Widget) InsertActionGroup(name string, group gio.ActionGrouper) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.gchar        // out
	var _arg2 *C.GActionGroup // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if group != nil {
		_arg2 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	}

	C.gtk_widget_insert_action_group(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
	runtime.KeepAlive(group)
}

// Intersect computes the intersection of a widget’s area and area, storing the
// intersection in intersection, and returns TRUE if there was an intersection.
// intersection may be NULL if you’re only interested in whether there was an
// intersection.
//
// The function takes the following parameters:
//
//    - area: rectangle.
//
// The function returns the following values:
//
//    - intersection (optional): rectangle to store intersection of widget and
//      area.
//    - ok: TRUE if there was an intersection.
//
func (widget *Widget) Intersect(area *gdk.Rectangle) (*gdk.Rectangle, bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.GdkRectangle // out
	var _arg2 C.GdkRectangle  // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))

	_cret = C.gtk_widget_intersect(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(area)

	var _intersection *gdk.Rectangle // out
	var _ok bool                     // out

	_intersection = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _intersection, _ok
}

// IsAncestor determines whether widget is somewhere inside ancestor, possibly
// with intermediate containers.
//
// The function takes the following parameters:
//
//    - ancestor: another Widget.
//
// The function returns the following values:
//
//    - ok: TRUE if ancestor contains widget as a child, grandchild, great
//      grandchild, etc.
//
func (widget *Widget) IsAncestor(ancestor Widgetter) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(ancestor).Native()))

	_cret = C.gtk_widget_is_ancestor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsComposited: whether widget can rely on having its alpha channel drawn
// correctly. On X11 this function returns whether a compositing manager is
// running for widget’s screen.
//
// Please note that the semantics of this call will change in the future if used
// on a widget that has a composited window in its hierarchy (as set by
// gdk_window_set_composited()).
//
// Deprecated: Use gdk_screen_is_composited() instead.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget can rely on its alpha channel being drawn
//      correctly.
//
func (widget *Widget) IsComposited() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_composited(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDrawable determines whether widget can be drawn to. A widget can be drawn
// to if it is mapped and visible.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is drawable, FALSE otherwise.
//
func (widget *Widget) IsDrawable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_drawable(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocus determines if the widget is the focus widget within its toplevel.
// (This does not mean that the Widget:has-focus property is necessarily set;
// Widget:has-focus will only be set if the toplevel widget additionally has the
// global input focus.).
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is the focus widget.
//
func (widget *Widget) IsFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSensitive returns the widget’s effective sensitivity, which means it is
// sensitive itself and also its parent widget is sensitive.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is effectively sensitive.
//
func (widget *Widget) IsSensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_sensitive(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsToplevel determines whether widget is a toplevel widget.
//
// Currently only Window and Invisible (and out-of-process Plugs) are toplevel
// widgets. Toplevel widgets have no parent widget.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is a toplevel, FALSE otherwise.
//
func (widget *Widget) IsToplevel() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_toplevel(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVisible determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also gtk_widget_get_visible() and gtk_widget_set_visible().
//
// The function returns the following values:
//
//    - ok: TRUE if the widget and all its parents are visible.
//
func (widget *Widget) IsVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeynavFailed: this function should be called whenever keyboard navigation
// within a single widget hits a boundary. The function emits the
// Widget::keynav-failed signal on the widget and its return value should be
// interpreted in a way similar to the return value of gtk_widget_child_focus():
//
// When TRUE is returned, stay in the widget, the failed keyboard navigation is
// OK and/or there is nowhere we can/should move the focus to.
//
// When FALSE is returned, the caller should continue with keyboard navigation
// outside the widget, e.g. by calling gtk_widget_child_focus() on the widget’s
// toplevel.
//
// The default ::keynav-failed handler returns FALSE for GTK_DIR_TAB_FORWARD and
// GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it returns TRUE.
//
// Whenever the default handler returns TRUE, it also calls
// gtk_widget_error_bell() to notify the user of the failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either by
// connecting to it or by overriding it) would be a row of Entry widgets where
// the user should be able to navigate the entire row with the cursor keys, as
// e.g. known from user interfaces that require entering license keys.
//
// The function takes the following parameters:
//
//    - direction of focus movement.
//
// The function returns the following values:
//
//    - ok: TRUE if stopping keyboard navigation is fine, FALSE if the emitting
//      widget should try to handle the keyboard navigation attempt in its parent
//      container(s).
//
func (widget *Widget) KeynavFailed(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_widget_keynav_failed(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListActionPrefixes retrieves a NULL-terminated array of strings containing
// the prefixes of Group's available to widget.
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated array of strings.
//
func (widget *Widget) ListActionPrefixes() []string {
	var _arg0 *C.GtkWidget // out
	var _cret **C.gchar    // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_list_action_prefixes(_arg0)
	runtime.KeepAlive(widget)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// ListMnemonicLabels returns a newly allocated list of the widgets, normally
// labels, for which this widget is the target of a mnemonic (see for example,
// gtk_label_set_mnemonic_widget()).
//
// The widgets in the list are not individually referenced. If you want to
// iterate through the list and perform actions involving callbacks that might
// destroy the widgets, you must call g_list_foreach (result,
// (GFunc)g_object_ref, NULL) first, and then unref all the widgets afterwards.
//
// The function returns the following values:
//
//    - list of mnemonic labels; free this list with g_list_free() when you are
//      done with it.
//
func (widget *Widget) ListMnemonicLabels() []Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GList     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_list_mnemonic_labels(_arg0)
	runtime.KeepAlive(widget)

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// Map: this function is only for use in widget implementations. Causes a widget
// to be mapped if it isn’t already.
func (widget *Widget) Map() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_map(_arg0)
	runtime.KeepAlive(widget)
}

// MnemonicActivate emits the Widget::mnemonic-activate signal.
//
// The function takes the following parameters:
//
//    - groupCycling: TRUE if there are other widgets with the same mnemonic.
//
// The function returns the following values:
//
//    - ok: TRUE if the signal has been handled.
//
func (widget *Widget) MnemonicActivate(groupCycling bool) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_widget_mnemonic_activate(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(groupCycling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// OverrideBackgroundColor sets the background color to use for a widget.
//
// All other style values are left untouched. See gtk_widget_override_color().
//
// Deprecated: This function is not useful in the context of CSS-based
// rendering. If you wish to change the way a widget renders its background you
// should use a custom CSS style, through an application-specific StyleProvider
// and a CSS style class. You can also override the default drawing of a widget
// through the Widget::draw signal, and use Cairo to draw a specific color,
// regardless of the CSS style.
//
// The function takes the following parameters:
//
//    - state for which to set the background color.
//    - color (optional) to assign, or NULL to undo the effect of previous calls
//      to gtk_widget_override_background_color().
//
func (widget *Widget) OverrideBackgroundColor(state StateFlags, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 *C.GdkRGBA      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(state)
	if color != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	}

	C.gtk_widget_override_background_color(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(state)
	runtime.KeepAlive(color)
}

// OverrideColor sets the color to use for a widget.
//
// All other style values are left untouched.
//
// This function does not act recursively. Setting the color of a container does
// not affect its children. Note that some widgets that you may not think of as
// containers, for instance Buttons, are actually containers.
//
// This API is mostly meant as a quick way for applications to change a widget
// appearance. If you are developing a widgets library and intend this change to
// be themeable, it is better done by setting meaningful CSS classes in your
// widget/container implementation through gtk_style_context_add_class().
//
// This way, your widget library can install a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority in order to provide a default
// styling for those widgets that need so, and this theming may fully overridden
// by the user’s theme.
//
// Note that for complex widgets this may bring in undesired results (such as
// uniform background color everywhere), in these cases it is better to fully
// style such widgets through a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority.
//
// Deprecated: Use a custom style provider and style classes instead.
//
// The function takes the following parameters:
//
//    - state for which to set the color.
//    - color (optional) to assign, or NULL to undo the effect of previous calls
//      to gtk_widget_override_color().
//
func (widget *Widget) OverrideColor(state StateFlags, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 *C.GdkRGBA      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(state)
	if color != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	}

	C.gtk_widget_override_color(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(state)
	runtime.KeepAlive(color)
}

// OverrideCursor sets the cursor color to use in a widget, overriding the
// cursor-color and secondary-cursor-color style properties. All other style
// values are left untouched. See also gtk_widget_modify_style().
//
// Note that the underlying properties have the Color type, so the alpha value
// in primary and secondary will be ignored.
//
// Deprecated: This function is not useful in the context of CSS-based
// rendering. If you wish to change the color used to render the primary and
// secondary cursors you should use a custom CSS style, through an
// application-specific StyleProvider and a CSS style class.
//
// The function takes the following parameters:
//
//    - cursor (optional): color to use for primary cursor (does not need to be
//      allocated), or NULL to undo the effect of previous calls to of
//      gtk_widget_override_cursor().
//    - secondaryCursor (optional): color to use for secondary cursor (does not
//      need to be allocated), or NULL to undo the effect of previous calls to of
//      gtk_widget_override_cursor().
//
func (widget *Widget) OverrideCursor(cursor, secondaryCursor *gdk.RGBA) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkRGBA   // out
	var _arg2 *C.GdkRGBA   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if cursor != nil {
		_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(cursor)))
	}
	if secondaryCursor != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(secondaryCursor)))
	}

	C.gtk_widget_override_cursor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cursor)
	runtime.KeepAlive(secondaryCursor)
}

// OverrideFont sets the font to use for a widget. All other style values are
// left untouched. See gtk_widget_override_color().
//
// Deprecated: This function is not useful in the context of CSS-based
// rendering. If you wish to change the font a widget uses to render its text
// you should use a custom CSS style, through an application-specific
// StyleProvider and a CSS style class.
//
// The function takes the following parameters:
//
//    - fontDesc (optional): font description to use, or NULL to undo the effect
//      of previous calls to gtk_widget_override_font().
//
func (widget *Widget) OverrideFont(fontDesc *pango.FontDescription) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if fontDesc != nil {
		_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(fontDesc)))
	}

	C.gtk_widget_override_font(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(fontDesc)
}

// OverrideSymbolicColor sets a symbolic color for a widget.
//
// All other style values are left untouched. See gtk_widget_override_color()
// for overriding the foreground or background color.
//
// Deprecated: This function is not useful in the context of CSS-based
// rendering. If you wish to change the color used to render symbolic icons you
// should use a custom CSS style, through an application-specific StyleProvider
// and a CSS style class.
//
// The function takes the following parameters:
//
//    - name of the symbolic color to modify.
//    - color (optional) to assign (does not need to be allocated), or NULL to
//      undo the effect of previous calls to
//      gtk_widget_override_symbolic_color().
//
func (widget *Widget) OverrideSymbolicColor(name string, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GdkRGBA   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if color != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	}

	C.gtk_widget_override_symbolic_color(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
	runtime.KeepAlive(color)
}

// QueueAllocate: this function is only for use in widget implementations.
//
// Flags the widget for a rerun of the GtkWidgetClass::size_allocate function.
// Use this function instead of gtk_widget_queue_resize() when the widget's size
// request didn't change but it wants to reposition its contents.
//
// An example user of this function is gtk_widget_set_halign().
func (widget *Widget) QueueAllocate() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_allocate(_arg0)
	runtime.KeepAlive(widget)
}

// QueueComputeExpand: mark widget as needing to recompute its expand flags.
// Call this function when setting legacy expand child properties on the child
// of a container.
//
// See gtk_widget_compute_expand().
func (widget *Widget) QueueComputeExpand() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_compute_expand(_arg0)
	runtime.KeepAlive(widget)
}

// QueueDraw: equivalent to calling gtk_widget_queue_draw_area() for the entire
// area of a widget.
func (widget *Widget) QueueDraw() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_draw(_arg0)
	runtime.KeepAlive(widget)
}

// QueueDrawArea: convenience function that calls gtk_widget_queue_draw_region()
// on the region created from the given coordinates.
//
// The region here is specified in widget coordinates. Widget coordinates are a
// bit odd; for historical reasons, they are defined as widget->window
// coordinates for widgets that return TRUE for gtk_widget_get_has_window(), and
// are relative to widget->allocation.x, widget->allocation.y otherwise.
//
// width or height may be 0, in this case this function does nothing. Negative
// values for width and height are not allowed.
//
// The function takes the following parameters:
//
//    - x coordinate of upper-left corner of rectangle to redraw.
//    - y coordinate of upper-left corner of rectangle to redraw.
//    - width of region to draw.
//    - height of region to draw.
//
func (widget *Widget) QueueDrawArea(x, y, width, height int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.gint(width)
	_arg4 = C.gint(height)

	C.gtk_widget_queue_draw_area(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// QueueDrawRegion invalidates the area of widget defined by region by calling
// gdk_window_invalidate_region() on the widget’s window and all its child
// windows. Once the main loop becomes idle (after the current batch of events
// has been processed, roughly), the window will receive expose events for the
// union of all regions that have been invalidated.
//
// Normally you would only use this function in widget implementations. You
// might also use it to schedule a redraw of a DrawingArea or some portion
// thereof.
//
// The function takes the following parameters:
//
//    - region to draw.
//
func (widget *Widget) QueueDrawRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gtk_widget_queue_draw_region(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)
}

// QueueResize: this function is only for use in widget implementations. Flags a
// widget to have its size renegotiated; should be called when a widget for some
// reason has a new size request. For example, when you change the text in a
// Label, Label queues a resize to ensure there’s enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from inside
// its implementation of the GtkWidgetClass::size_allocate virtual method. Calls
// to gtk_widget_queue_resize() from inside GtkWidgetClass::size_allocate will
// be silently ignored.
func (widget *Widget) QueueResize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_resize(_arg0)
	runtime.KeepAlive(widget)
}

// QueueResizeNoRedraw: this function works like gtk_widget_queue_resize(),
// except that the widget is not invalidated.
func (widget *Widget) QueueResizeNoRedraw() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_resize_no_redraw(_arg0)
	runtime.KeepAlive(widget)
}

// Realize creates the GDK (windowing system) resources associated with a
// widget. For example, widget->window will be created when a widget is
// realized. Normally realization happens implicitly; if you show a widget and
// all its parent containers, then the widget will be realized and mapped
// automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling gtk_widget_realize() realizes the widget’s parents in addition to
// widget itself. If a widget is not yet inside a toplevel window when you
// realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as Widget::draw. Or simply g_signal_connect ()
// to the Widget::realize signal.
func (widget *Widget) Realize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_realize(_arg0)
	runtime.KeepAlive(widget)
}

// RegionIntersect computes the intersection of a widget’s area and region,
// returning the intersection. The result may be empty, use
// cairo_region_is_empty() to check.
//
// Deprecated: Use gtk_widget_get_allocation() and
// cairo_region_intersect_rectangle() to get the same behavior.
//
// The function takes the following parameters:
//
//    - region in the same coordinate system as widget->allocation. That is,
//      relative to widget->window for widgets which return FALSE from
//      gtk_widget_get_has_window(); relative to the parent window of
//      widget->window otherwise.
//
// The function returns the following values:
//
//    - ret: newly allocated region holding the intersection of widget and
//      region.
//
func (widget *Widget) RegionIntersect(region *cairo.Region) *cairo.Region {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out
	var _cret *C.cairo_region_t // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	_cret = C.gtk_widget_region_intersect(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)

	var _ret *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
		_ret = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	runtime.SetFinalizer(_ret, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
	})

	return _ret
}

// RegisterWindow registers a Window with the widget and sets it up so that the
// widget receives events for it. Call gtk_widget_unregister_window() when
// destroying the window.
//
// Before 3.8 you needed to call gdk_window_set_user_data() directly to set this
// up. This is now deprecated and you should use gtk_widget_register_window()
// instead. Old code will keep working as is, although some new features like
// transparency might not work perfectly.
//
// The function takes the following parameters:
//
//    - window: Window.
//
func (widget *Widget) RegisterWindow(window gdk.Windower) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_widget_register_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(window)
}

// RemoveAccelerator removes an accelerator from widget, previously installed
// with gtk_widget_add_accelerator().
//
// The function takes the following parameters:
//
//    - accelGroup: accel group for this widget.
//    - accelKey: GDK keyval of the accelerator.
//    - accelMods: modifier key combination of the accelerator.
//
// The function returns the following values:
//
//    - ok: whether an accelerator was installed and could be removed.
//
func (widget *Widget) RemoveAccelerator(accelGroup *AccelGroup, accelKey uint32, accelMods gdk.ModifierType) bool {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GtkAccelGroup  // out
	var _arg2 C.guint           // out
	var _arg3 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	_arg2 = C.guint(accelKey)
	_arg3 = C.GdkModifierType(accelMods)

	_cret = C.gtk_widget_remove_accelerator(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(accelGroup)
	runtime.KeepAlive(accelKey)
	runtime.KeepAlive(accelMods)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget. (See gtk_widget_list_mnemonic_labels()). The widget must have
// previously been added to the list with gtk_widget_add_mnemonic_label().
//
// The function takes the following parameters:
//
//    - label that was previously set as a mnemonic label for widget with
//      gtk_widget_add_mnemonic_label().
//
func (widget *Widget) RemoveMnemonicLabel(label Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(label).Native()))

	C.gtk_widget_remove_mnemonic_label(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(label)
}

// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
//
// The function takes the following parameters:
//
//    - id returned by gtk_widget_add_tick_callback().
//
func (widget *Widget) RemoveTickCallback(id uint32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.guint(id)

	C.gtk_widget_remove_tick_callback(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(id)
}

// RenderIconPixbuf: convenience function that uses the theme engine and style
// settings for widget to look up stock_id and render it to a pixbuf. stock_id
// should be a stock icon ID such as K_STOCK_OPEN or K_STOCK_OK. size should be
// a size such as K_ICON_SIZE_MENU.
//
// The pixels in the returned Pixbuf are shared with the rest of the application
// and should not be modified. The pixbuf should be freed after use with
// g_object_unref().
//
// Deprecated: Use gtk_icon_theme_load_icon() instead.
//
// The function takes the following parameters:
//
//    - stockId: stock ID.
//    - size: stock size (IconSize). A size of (GtkIconSize)-1 means render at
//      the size of the source and don’t scale (if there are multiple source
//      sizes, GTK+ picks one of the available sizes).
//
// The function returns the following values:
//
//    - pixbuf (optional): new pixbuf, or NULL if the stock ID wasn’t known.
//
func (widget *Widget) RenderIconPixbuf(stockId string, size int32) *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkWidget  // out
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out
	var _cret *C.GdkPixbuf  // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(stockId)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GtkIconSize(size)

	_cret = C.gtk_widget_render_icon_pixbuf(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(stockId)
	runtime.KeepAlive(size)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// Reparent moves a widget from one Container to another, handling reference
// count issues to avoid destroying the widget.
//
// Deprecated: Use gtk_container_remove() and gtk_container_add().
//
// The function takes the following parameters:
//
//    - newParent to move the widget into.
//
func (widget *Widget) Reparent(newParent Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(newParent).Native()))

	C.gtk_widget_reparent(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(newParent)
}

// ResetStyle updates the style context of widget and all descendants by
// updating its widget path. Containers may want to use this on a child when
// reordering it in a way that a different style might apply to it. See also
// gtk_container_get_path_for_child().
func (widget *Widget) ResetStyle() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_reset_style(_arg0)
	runtime.KeepAlive(widget)
}

// SendExpose: very rarely-used function. This function is used to emit an
// expose event on a widget. This function is not normally used directly. The
// only time it is used is when propagating an expose event to a windowless
// child widget (gtk_widget_get_has_window() is FALSE), and that is normally
// done using gtk_container_propagate_draw().
//
// If you want to force an area of a window to be redrawn, use
// gdk_window_invalidate_rect() or gdk_window_invalidate_region(). To cause the
// redraw to be done immediately, follow that call with a call to
// gdk_window_process_updates().
//
// Deprecated: Application and widget code should not handle expose events
// directly; invalidation should use the Widget API, and drawing should only
// happen inside Widget::draw implementations.
//
// The function takes the following parameters:
//
//    - event: expose Event.
//
// The function returns the following values:
//
//    - gint: return from the event signal emission (TRUE if the event was
//      handled).
//
func (widget *Widget) SendExpose(event *gdk.Event) int32 {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkEvent  // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_widget_send_expose(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// SendFocusChange sends the focus change event to widget
//
// This function is not meant to be used by applications. The only time it
// should be used is when it is necessary for a Widget to assign focus to a
// widget that is semantically owned by the first widget even though it’s not a
// direct child - for instance, a search entry in a floating window similar to
// the quick search in TreeView.
//
// An example of its usage is:
//
//      GdkEvent *fevent = gdk_event_new (GDK_FOCUS_CHANGE);
//
//      fevent->focus_change.type = GDK_FOCUS_CHANGE;
//      fevent->focus_change.in = TRUE;
//      fevent->focus_change.window = _gtk_widget_get_window (widget);
//      if (fevent->focus_change.window != NULL)
//        g_object_ref (fevent->focus_change.window);
//
//      gtk_widget_send_focus_change (widget, fevent);
//
//      gdk_event_free (event);.
//
// The function takes the following parameters:
//
//    - event of type GDK_FOCUS_CHANGE.
//
// The function returns the following values:
//
//    - ok: return value from the event signal emission: TRUE if the event was
//      handled, and FALSE otherwise.
//
func (widget *Widget) SendFocusChange(event *gdk.Event) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkEvent  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_widget_send_focus_change(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAccelPath: given an accelerator group, accel_group, and an accelerator
// path, accel_path, sets up an accelerator in accel_group so whenever the key
// binding that is defined for accel_path is pressed, widget will be activated.
// This removes any accelerators (for any accelerator group) installed by
// previous calls to gtk_widget_set_accel_path(). Associating accelerators with
// paths allows them to be modified by the user and the modifications to be
// saved for future use. (See gtk_accel_map_save().)
//
// This function is a low level function that would most likely be used by a
// menu creation system like UIManager. If you use UIManager, setting up
// accelerator paths will be done automatically.
//
// Even when you you aren’t using UIManager, if you only want to set up
// accelerators on menu items gtk_menu_item_set_accel_path() provides a somewhat
// more convenient interface.
//
// Note that accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
//
// The function takes the following parameters:
//
//    - accelPath (optional): path used to look up the accelerator.
//    - accelGroup (optional): AccelGroup.
//
func (widget *Widget) SetAccelPath(accelPath string, accelGroup *AccelGroup) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if accelPath != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accelPath)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if accelGroup != nil {
		_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	}

	C.gtk_widget_set_accel_path(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(accelPath)
	runtime.KeepAlive(accelGroup)
}

// SetAllocation sets the widget’s allocation. This should not be used directly,
// but from within a widget’s size_allocate method.
//
// The allocation set should be the “adjusted” or actual allocation. If you’re
// implementing a Container, you want to use gtk_widget_size_allocate() instead
// of gtk_widget_set_allocation(). The GtkWidgetClass::adjust_size_allocation
// virtual method adjusts the allocation inside gtk_widget_size_allocate() to
// create an adjusted allocation.
//
// The function takes the following parameters:
//
//    - allocation: pointer to a Allocation to copy from.
//
func (widget *Widget) SetAllocation(allocation *Allocation) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))

	C.gtk_widget_set_allocation(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(allocation)
}

// SetAppPaintable sets whether the application intends to draw on the widget in
// an Widget::draw handler.
//
// This is a hint to the widget and does not affect the behavior of the GTK+
// core; many widgets ignore this flag entirely. For widgets that do pay
// attention to the flag, such as EventBox and Window, the effect is to suppress
// default themed drawing of the widget's background. (Children of the widget
// will still be drawn.) The application is then entirely responsible for
// drawing the widget background.
//
// Note that the background is still drawn when the widget is mapped.
//
// The function takes the following parameters:
//
//    - appPaintable: TRUE if the application will paint on the widget.
//
func (widget *Widget) SetAppPaintable(appPaintable bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if appPaintable {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_app_paintable(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(appPaintable)
}

// SetCanDefault specifies whether widget can be a default widget. See
// gtk_widget_grab_default() for details about the meaning of “default”.
//
// The function takes the following parameters:
//
//    - canDefault: whether or not widget can be a default widget.
//
func (widget *Widget) SetCanDefault(canDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if canDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_default(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(canDefault)
}

// SetCanFocus specifies whether widget can own the input focus. See
// gtk_widget_grab_focus() for actually setting the input focus on a widget.
//
// The function takes the following parameters:
//
//    - canFocus: whether or not widget can own the input focus.
//
func (widget *Widget) SetCanFocus(canFocus bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if canFocus {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_focus(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(canFocus)
}

// SetChildVisible sets whether widget should be mapped along with its when its
// parent is mapped and widget has been shown with gtk_widget_show().
//
// The child visibility can be set for widget before it is added to a container
// with gtk_widget_set_parent(), to avoid mapping children unnecessary before
// immediately unmapping them. However it will be reset to its default state of
// TRUE when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a resize
// on the widget. Most of the time, the size of a widget is computed from all
// visible children, whether or not they are mapped. If this is not the case,
// the container can queue a resize itself.
//
// This function is only useful for container implementations and never should
// be called by an application.
//
// The function takes the following parameters:
//
//    - isVisible: if TRUE, widget should be mapped along with its parent.
//
func (widget *Widget) SetChildVisible(isVisible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if isVisible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_child_visible(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(isVisible)
}

// SetClip sets the widget’s clip. This must not be used directly, but from
// within a widget’s size_allocate method. It must be called after
// gtk_widget_set_allocation() (or after chaining up to the parent class),
// because that function resets the clip.
//
// The clip set should be the area that widget draws on. If widget is a
// Container, the area must contain all children's clips.
//
// If this function is not called by widget during a ::size-allocate handler,
// the clip will be set to widget's allocation.
//
// The function takes the following parameters:
//
//    - clip: pointer to a Allocation to copy from.
//
func (widget *Widget) SetClip(clip *Allocation) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(clip)))

	C.gtk_widget_set_clip(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(clip)
}

// SetCompositeName sets a widgets composite name. The widget must be a
// composite child of its parent; see gtk_widget_push_composite_child().
//
// Deprecated: Use gtk_widget_class_set_template(), or don’t use this API at
// all.
//
// The function takes the following parameters:
//
//    - name to set.
//
func (widget *Widget) SetCompositeName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_composite_name(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
}

// SetDeviceEnabled enables or disables a Device to interact with widget and all
// its children.
//
// It does so by descending through the Window hierarchy and enabling the same
// mask that is has for core events (i.e. the one that gdk_window_get_events()
// returns).
//
// The function takes the following parameters:
//
//    - device: Device.
//    - enabled: whether to enable the device.
//
func (widget *Widget) SetDeviceEnabled(device gdk.Devicer, enabled bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	if enabled {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_device_enabled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)
	runtime.KeepAlive(enabled)
}

// SetDeviceEvents sets the device event mask (see EventMask) for a widget. The
// event mask determines which events a widget will receive from device. Keep in
// mind that different widgets have different default event masks, and by
// changing the event mask you may disrupt a widget’s functionality, so be
// careful. This function must be called while a widget is unrealized. Consider
// gtk_widget_add_device_events() for widgets that are already realized, or if
// you want to preserve the existing event mask. This function can’t be used
// with windowless widgets (which return FALSE from
// gtk_widget_get_has_window()); to get events on those widgets, place them
// inside a EventBox and receive events on the event box.
//
// The function takes the following parameters:
//
//    - device: Device.
//    - events: event mask.
//
func (widget *Widget) SetDeviceEvents(device gdk.Devicer, events gdk.EventMask) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.GdkEventMask // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = C.GdkEventMask(events)

	C.gtk_widget_set_device_events(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)
	runtime.KeepAlive(events)
}

// SetDirection sets the reading direction on a particular widget. This
// direction controls the primary direction for widgets containing text, and
// also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct localization
// into languages with right-to-left reading directions can be done. Generally,
// applications will let the default reading direction present, except for
// containers where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk_widget_set_default_direction() will be used.
//
// The function takes the following parameters:
//
//    - dir: new direction.
//
func (widget *Widget) SetDirection(dir TextDirection) {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkTextDirection(dir)

	C.gtk_widget_set_direction(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(dir)
}

// SetDoubleBuffered widgets are double buffered by default; you can use this
// function to turn off the buffering. “Double buffered” simply means that
// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are called
// automatically around expose events sent to the widget.
// gdk_window_begin_draw_frame() diverts all drawing to a widget's window to an
// offscreen buffer, and gdk_window_end_draw_frame() draws the buffer to the
// screen. The result is that users see the window update in one smooth step,
// and don’t see individual graphics primitives being rendered.
//
// In very simple terms, double buffered widgets don’t flicker, so you would
// only use this function to turn off double buffering if you had special needs
// and really knew what you were doing.
//
// Note: if you turn off double-buffering, you have to handle expose events,
// since even the clearing to the background color or pixmap will not happen
// automatically (as it is done in gdk_window_begin_draw_frame()).
//
// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
// then expose events for double-buffered widgets are culled into a single event
// to the toplevel GDK window. If you now unset double buffering, you will cause
// a separate rendering pass for every widget. This will likely cause rendering
// problems - in particular related to stacking - and usually increases
// rendering times significantly.
//
// Deprecated: This function does not work under non-X11 backends or with
// non-native windows. It should not be used in newly written code.
//
// The function takes the following parameters:
//
//    - doubleBuffered: TRUE to double-buffer a widget.
//
func (widget *Widget) SetDoubleBuffered(doubleBuffered bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if doubleBuffered {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_double_buffered(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(doubleBuffered)
}

// SetEvents sets the event mask (see EventMask) for a widget. The event mask
// determines which events a widget will receive. Keep in mind that different
// widgets have different default event masks, and by changing the event mask
// you may disrupt a widget’s functionality, so be careful. This function must
// be called while a widget is unrealized. Consider gtk_widget_add_events() for
// widgets that are already realized, or if you want to preserve the existing
// event mask. This function can’t be used with widgets that have no window.
// (See gtk_widget_get_has_window()). To get events on those widgets, place them
// inside a EventBox and receive events on the event box.
//
// The function takes the following parameters:
//
//    - events: event mask.
//
func (widget *Widget) SetEvents(events int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(events)

	C.gtk_widget_set_events(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(events)
}

// SetFocusOnClick sets whether the widget should grab focus when it is clicked
// with the mouse. Making mouse clicks not grab focus is useful in places like
// toolbars where you don’t want the keyboard focus removed from the main area
// of the application.
//
// The function takes the following parameters:
//
//    - focusOnClick: whether the widget should grab focus when clicked with the
//      mouse.
//
func (widget *Widget) SetFocusOnClick(focusOnClick bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if focusOnClick {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_focus_on_click(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(focusOnClick)
}

// SetFontMap sets the font map to use for Pango rendering. When not set, the
// widget will inherit the font map from its parent.
//
// The function takes the following parameters:
//
//    - fontMap (optional) or NULL to unset any previously set font map.
//
func (widget *Widget) SetFontMap(fontMap pango.FontMapper) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.PangoFontMap // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if fontMap != nil {
		_arg1 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontMap).Native()))
	}

	C.gtk_widget_set_font_map(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(fontMap)
}

// SetFontOptions sets the #cairo_font_options_t used for Pango rendering in
// this widget. When not set, the default font options for the Screen will be
// used.
//
// The function takes the following parameters:
//
//    - options (optional) or NULL to unset any previously set default font
//      options.
//
func (widget *Widget) SetFontOptions(options *cairo.FontOptions) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.cairo_font_options_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if options != nil {
		_arg1 = (*C.cairo_font_options_t)(gextras.StructNative(unsafe.Pointer(options)))
	}

	C.gtk_widget_set_font_options(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(options)
}

// SetHAlign sets the horizontal alignment of widget. See the Widget:halign
// property.
//
// The function takes the following parameters:
//
//    - align: horizontal alignment.
//
func (widget *Widget) SetHAlign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkAlign(align)

	C.gtk_widget_set_halign(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(align)
}

// SetHasTooltip sets the has-tooltip property on widget to has_tooltip. See
// Widget:has-tooltip for more information.
//
// The function takes the following parameters:
//
//    - hasTooltip: whether or not widget has a tooltip.
//
func (widget *Widget) SetHasTooltip(hasTooltip bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if hasTooltip {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_tooltip(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(hasTooltip)
}

// SetHasWindow specifies whether widget has a Window of its own. Note that all
// realized widgets have a non-NULL “window” pointer (gtk_widget_get_window()
// never returns a NULL window when a widget is realized), but for many of them
// it’s actually the Window of one of its parent widgets. Widgets that do not
// create a window for themselves in Widget::realize must announce this by
// calling this function with has_window = FALSE.
//
// This function should only be called by widget implementations, and they
// should call it in their init() function.
//
// The function takes the following parameters:
//
//    - hasWindow: whether or not widget has a window.
//
func (widget *Widget) SetHasWindow(hasWindow bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if hasWindow {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(hasWindow)
}

// SetHExpand sets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or document
// in your window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget to
// become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk_widget_compute_expand(). A container can decide
// how the expandability of children affects the expansion of the container by
// overriding the compute_expand virtual method on Widget.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because gtk_widget_set_hexpand() sets the
// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
// widget’s hexpand value to be used, rather than looking at children and widget
// state.
//
// The function takes the following parameters:
//
//    - expand: whether to expand.
//
func (widget *Widget) SetHExpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(expand)
}

// SetHExpandSet sets whether the hexpand flag (see gtk_widget_get_hexpand())
// will be used.
//
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
// this function would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
//
// The function takes the following parameters:
//
//    - set: value for hexpand-set property.
//
func (widget *Widget) SetHExpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand_set(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(set)
}

// SetMapped marks the widget as being mapped.
//
// This function should only ever be called in a derived widget's “map” or
// “unmap” implementation.
//
// The function takes the following parameters:
//
//    - mapped: TRUE to mark the widget as mapped.
//
func (widget *Widget) SetMapped(mapped bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if mapped {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_mapped(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(mapped)
}

// SetMarginBottom sets the bottom margin of widget. See the
// Widget:margin-bottom property.
//
// The function takes the following parameters:
//
//    - margin: bottom margin.
//
func (widget *Widget) SetMarginBottom(margin int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_bottom(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginEnd sets the end margin of widget. See the Widget:margin-end
// property.
//
// The function takes the following parameters:
//
//    - margin: end margin.
//
func (widget *Widget) SetMarginEnd(margin int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_end(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginLeft sets the left margin of widget. See the Widget:margin-left
// property.
//
// Deprecated: Use gtk_widget_set_margin_start() instead.
//
// The function takes the following parameters:
//
//    - margin: left margin.
//
func (widget *Widget) SetMarginLeft(margin int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_left(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginRight sets the right margin of widget. See the Widget:margin-right
// property.
//
// Deprecated: Use gtk_widget_set_margin_end() instead.
//
// The function takes the following parameters:
//
//    - margin: right margin.
//
func (widget *Widget) SetMarginRight(margin int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_right(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginStart sets the start margin of widget. See the Widget:margin-start
// property.
//
// The function takes the following parameters:
//
//    - margin: start margin.
//
func (widget *Widget) SetMarginStart(margin int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_start(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginTop sets the top margin of widget. See the Widget:margin-top
// property.
//
// The function takes the following parameters:
//
//    - margin: top margin.
//
func (widget *Widget) SetMarginTop(margin int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_top(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetName widgets can be named, which allows you to refer to them from a CSS
// file. You can apply a style to widgets with a particular name in the CSS
// file. See the documentation for the CSS syntax (on the same page as the docs
// for StyleContext).
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these will
// make your widget impossible to match by name. Any combination of alphanumeric
// symbols, dashes and underscores will suffice.
//
// The function takes the following parameters:
//
//    - name for the widget.
//
func (widget *Widget) SetName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_name(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
}

// SetNoShowAll sets the Widget:no-show-all property, which determines whether
// calls to gtk_widget_show_all() will affect this widget.
//
// This is mostly for use in constructing widget hierarchies with externally
// controlled visibility, see UIManager.
//
// The function takes the following parameters:
//
//    - noShowAll: new value for the “no-show-all” property.
//
func (widget *Widget) SetNoShowAll(noShowAll bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if noShowAll {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_no_show_all(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(noShowAll)
}

// SetOpacity: request the widget to be rendered partially transparent, with
// opacity 0 being fully transparent and 1 fully opaque. (Opacity values are
// clamped to the [0,1] range.). This works on both toplevel widget, and child
// widgets, although there are some limitations:
//
// For toplevel widgets this depends on the capabilities of the windowing
// system. On X11 this has any effect only on X screens with a compositing
// manager running. See gtk_widget_is_composited(). On Windows it should work
// always, although setting a window’s opacity after the window has been shown
// causes it to flicker once on Windows.
//
// For child widgets it doesn’t work if any affected widget has a native window,
// or disables double buffering.
//
// The function takes the following parameters:
//
//    - opacity: desired opacity, between 0 and 1.
//
func (widget *Widget) SetOpacity(opacity float64) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(opacity)

	C.gtk_widget_set_opacity(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(opacity)
}

// SetParent: this function is useful only when implementing subclasses of
// Container. Sets the container as the parent of widget, and takes care of some
// details such as updating the state and style of the child to reflect its new
// location. The opposite function is gtk_widget_unparent().
//
// The function takes the following parameters:
//
//    - parent container.
//
func (widget *Widget) SetParent(parent Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	C.gtk_widget_set_parent(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parent)
}

// SetParentWindow sets a non default parent window for widget.
//
// For Window classes, setting a parent_window effects whether the window is a
// toplevel window or can be embedded into other widgets.
//
// For Window classes, this needs to be called before the window is realized.
//
// The function takes the following parameters:
//
//    - parentWindow: new parent window.
//
func (widget *Widget) SetParentWindow(parentWindow gdk.Windower) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(parentWindow).Native()))

	C.gtk_widget_set_parent_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parentWindow)
}

// SetRealized marks the widget as being realized. This function must only be
// called after all Windows for the widget have been created and registered.
//
// This function should only ever be called in a derived widget's “realize” or
// “unrealize” implementation.
//
// The function takes the following parameters:
//
//    - realized: TRUE to mark the widget as realized.
//
func (widget *Widget) SetRealized(realized bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if realized {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_realized(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(realized)
}

// SetReceivesDefault specifies whether widget will be treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// See gtk_widget_grab_default() for details about the meaning of “default”.
//
// The function takes the following parameters:
//
//    - receivesDefault: whether or not widget can be a default widget.
//
func (widget *Widget) SetReceivesDefault(receivesDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if receivesDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_receives_default(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(receivesDefault)
}

// SetRedrawOnAllocate sets whether the entire widget is queued for drawing when
// its size allocation changes. By default, this setting is TRUE and the entire
// widget is redrawn on every size change. If your widget leaves the upper left
// unchanged when made bigger, turning this setting off will improve
// performance.
//
// Note that for widgets where gtk_widget_get_has_window() is FALSE setting this
// flag to FALSE turns off all allocation on resizing: the widget will not even
// redraw if its position changes; this is to allow containers that don’t draw
// anything to avoid excess invalidations. If you set this flag on a widget with
// no window that does draw on widget->window, you are responsible for
// invalidating both the old and new allocation of the widget when the widget is
// moved and responsible for invalidating regions newly when the widget
// increases size.
//
// The function takes the following parameters:
//
//    - redrawOnAllocate: if TRUE, the entire widget will be redrawn when it is
//      allocated to a new size. Otherwise, only the new portion of the widget
//      will be redrawn.
//
func (widget *Widget) SetRedrawOnAllocate(redrawOnAllocate bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if redrawOnAllocate {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_redraw_on_allocate(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(redrawOnAllocate)
}

// SetSensitive sets the sensitivity of a widget. A widget is sensitive if the
// user can interact with it. Insensitive widgets are “grayed out” and the user
// can’t interact with them. Insensitive widgets are known as “inactive”,
// “disabled”, or “ghosted” in some other toolkits.
//
// The function takes the following parameters:
//
//    - sensitive: TRUE to make the widget sensitive.
//
func (widget *Widget) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_sensitive(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(sensitive)
}

// SetSizeRequest sets the minimum size of a widget; that is, the widget’s size
// request will be at least width by height. You can use this function to force
// a widget to be larger than it normally would be.
//
// In most cases, gtk_window_set_default_size() is a better choice for toplevel
// windows than this function; setting the default size will still allow users
// to shrink the window. Setting the size request will force them to leave the
// window at least as large as the size request. When dealing with window sizes,
// gtk_window_set_geometry_hints() can be a useful function as well.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept while
// still functioning well and drawing itself correctly. However in some strange
// cases a widget may be allocated less than its requested size, and in many
// cases a widget may be allocated more space than it requested.
//
// If the size request in a given direction is -1 (unset), then the “natural”
// size request of the widget will be used instead.
//
// The size request set here does not include any margin from the Widget
// properties margin-left, margin-right, margin-top, and margin-bottom, but it
// does include pretty much all other padding or border properties set by any
// subclass of Widget.
//
// The function takes the following parameters:
//
//    - width widget should request, or -1 to unset.
//    - height widget should request, or -1 to unset.
//
func (widget *Widget) SetSizeRequest(width, height int32) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_widget_set_size_request(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetState: this function is for use in widget implementations. Sets the state
// of a widget (insensitive, prelighted, etc.) Usually you should set the state
// using wrapper functions such as gtk_widget_set_sensitive().
//
// Deprecated: Use gtk_widget_set_state_flags() instead.
//
// The function takes the following parameters:
//
//    - state: new state for widget.
//
func (widget *Widget) SetState(state StateType) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.GtkStateType // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateType(state)

	C.gtk_widget_set_state(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(state)
}

// SetStateFlags: this function is for use in widget implementations. Turns on
// flag values in the current widget state (insensitive, prelighted, etc.).
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk_widget_set_direction().
//
// It is worth mentioning that any other state than GTK_STATE_FLAG_INSENSITIVE,
// will be propagated down to all non-internal children if widget is a
// Container, while GTK_STATE_FLAG_INSENSITIVE itself will be propagated down to
// all Container children by different means than turning on the state flag down
// the hierarchy, both gtk_widget_get_state_flags() and
// gtk_widget_is_sensitive() will make use of these.
//
// The function takes the following parameters:
//
//    - flags: state flags to turn on.
//    - clear: whether to clear state before turning on flags.
//
func (widget *Widget) SetStateFlags(flags StateFlags, clear bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(flags)
	if clear {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_state_flags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(clear)
}

// SetSupportMultidevice enables or disables multiple pointer awareness. If this
// setting is TRUE, widget will start receiving multiple, per device enter/leave
// events. Note that if custom Windows are created in Widget::realize,
// gdk_window_set_support_multidevice() will have to be called manually on them.
//
// The function takes the following parameters:
//
//    - supportMultidevice: TRUE to support input from multiple devices.
//
func (widget *Widget) SetSupportMultidevice(supportMultidevice bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if supportMultidevice {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_support_multidevice(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(supportMultidevice)
}

// SetTooltipMarkup sets markup as the contents of the tooltip, which is marked
// up with the [Pango text markup language][PangoMarkupFormat].
//
// This function will take care of setting Widget:has-tooltip to TRUE and of the
// default handler for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-markup property and gtk_tooltip_set_markup().
//
// The function takes the following parameters:
//
//    - markup (optional) contents of the tooltip for widget, or NULL.
//
func (widget *Widget) SetTooltipMarkup(markup string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if markup != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(markup)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_tooltip_markup(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(markup)
}

// SetTooltipText sets text as the contents of the tooltip. This function will
// take care of setting Widget:has-tooltip to TRUE and of the default handler
// for the Widget::query-tooltip signal.
//
// See also the Widget:tooltip-text property and gtk_tooltip_set_text().
//
// The function takes the following parameters:
//
//    - text (optional) contents of the tooltip for widget.
//
func (widget *Widget) SetTooltipText(text string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if text != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_tooltip_text(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(text)
}

// SetTooltipWindow replaces the default window used for displaying tooltips
// with custom_window. GTK+ will take care of showing and hiding custom_window
// at the right moment, to behave likewise as the default tooltip window. If
// custom_window is NULL, the default tooltip window will be used.
//
// The function takes the following parameters:
//
//    - customWindow (optional) or NULL.
//
func (widget *Widget) SetTooltipWindow(customWindow *Window) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if customWindow != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(customWindow).Native()))
	}

	C.gtk_widget_set_tooltip_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(customWindow)
}

// SetVAlign sets the vertical alignment of widget. See the Widget:valign
// property.
//
// The function takes the following parameters:
//
//    - align: vertical alignment.
//
func (widget *Widget) SetVAlign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkAlign(align)

	C.gtk_widget_set_valign(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(align)
}

// SetVExpand sets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_set_hexpand() for more detail.
//
// The function takes the following parameters:
//
//    - expand: whether to expand.
//
func (widget *Widget) SetVExpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(expand)
}

// SetVExpandSet sets whether the vexpand flag (see gtk_widget_get_vexpand())
// will be used.
//
// See gtk_widget_set_hexpand_set() for more detail.
//
// The function takes the following parameters:
//
//    - set: value for vexpand-set property.
//
func (widget *Widget) SetVExpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand_set(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(set)
}

// SetVisible sets the visibility state of widget. Note that setting this to
// TRUE doesn’t mean the widget is actually viewable, see
// gtk_widget_get_visible().
//
// This function simply calls gtk_widget_show() or gtk_widget_hide() but is
// nicer to use when the visibility of the widget depends on some condition.
//
// The function takes the following parameters:
//
//    - visible: whether the widget should be shown or not.
//
func (widget *Widget) SetVisible(visible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_visible(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(visible)
}

// SetVisual sets the visual that should be used for by widget and its children
// for creating Windows. The visual must be on the same Screen as returned by
// gtk_widget_get_screen(), so handling the Widget::screen-changed signal is
// necessary.
//
// Setting a new visual will not cause widget to recreate its windows, so you
// should call this function before widget is realized.
//
// The function takes the following parameters:
//
//    - visual (optional) to be used or NULL to unset a previous one.
//
func (widget *Widget) SetVisual(visual *gdk.Visual) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkVisual // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if visual != nil {
		_arg1 = (*C.GdkVisual)(unsafe.Pointer(coreglib.InternObject(visual).Native()))
	}

	C.gtk_widget_set_visual(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(visual)
}

// SetWindow sets a widget’s window. This function should only be used in a
// widget’s Widget::realize implementation. The window passed is usually either
// new window created with gdk_window_new(), or the window of its parent widget
// as returned by gtk_widget_get_parent_window().
//
// Widgets must indicate whether they will create their own Window by calling
// gtk_widget_set_has_window(). This is usually done in the widget’s init()
// function.
//
// Note that this function does not add any reference to window.
//
// The function takes the following parameters:
//
//    - window: Window.
//
func (widget *Widget) SetWindow(window gdk.Windower) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(window).Native()))

	C.gtk_widget_set_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(window)
}

// ShapeCombineRegion sets a shape for this widget’s GDK window. This allows for
// transparent windows etc., see gdk_window_shape_combine_region() for more
// information.
//
// The function takes the following parameters:
//
//    - region (optional): shape to be added, or NULL to remove an existing
//      shape.
//
func (widget *Widget) ShapeCombineRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if region != nil {
		_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	}

	C.gtk_widget_shape_combine_region(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)
}

// Show flags a widget to be displayed. Any widget that isn’t shown will not
// appear on the screen. If you want to show all the widgets in a container,
// it’s easier to call gtk_widget_show_all() on the container, instead of
// individually showing the widgets.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
func (widget *Widget) Show() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_show(_arg0)
	runtime.KeepAlive(widget)
}

// ShowAll: recursively shows a widget, and any child widgets (if the widget is
// a container).
func (widget *Widget) ShowAll() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_show_all(_arg0)
	runtime.KeepAlive(widget)
}

// ShowNow shows a widget. If the widget is an unmapped toplevel widget (i.e. a
// Window that has not yet been shown), enter the main loop and wait for the
// window to actually be mapped. Be careful; because the main loop is running,
// anything can happen during this function.
func (widget *Widget) ShowNow() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_show_now(_arg0)
	runtime.KeepAlive(widget)
}

// SizeAllocate: this function is only used by Container subclasses, to assign a
// size and position to their child widgets.
//
// In this function, the allocation may be adjusted. It will be forced to a 1x1
// minimum size, and the adjust_size_allocation virtual method on the child will
// be used to adjust the allocation. Standard adjustments include removing the
// widget’s margins, and applying the widget’s Widget:halign and Widget:valign
// properties.
//
// For baseline support in containers you need to use
// gtk_widget_size_allocate_with_baseline() instead.
//
// The function takes the following parameters:
//
//    - allocation: position and size to be allocated to widget.
//
func (widget *Widget) SizeAllocate(allocation *Allocation) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))

	C.gtk_widget_size_allocate(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(allocation)
}

// SizeAllocateWithBaseline: this function is only used by Container subclasses,
// to assign a size, position and (optionally) baseline to their child widgets.
//
// In this function, the allocation and baseline may be adjusted. It will be
// forced to a 1x1 minimum size, and the adjust_size_allocation virtual and
// adjust_baseline_allocation methods on the child will be used to adjust the
// allocation and baseline. Standard adjustments include removing the widget's
// margins, and applying the widget’s Widget:halign and Widget:valign
// properties.
//
// If the child widget does not have a valign of GTK_ALIGN_BASELINE the baseline
// argument is ignored and -1 is used instead.
//
// The function takes the following parameters:
//
//    - allocation: position and size to be allocated to widget.
//    - baseline of the child, or -1.
//
func (widget *Widget) SizeAllocateWithBaseline(allocation *Allocation, baseline int32) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out
	var _arg2 C.gint           // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))
	_arg2 = C.gint(baseline)

	C.gtk_widget_size_allocate_with_baseline(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(allocation)
	runtime.KeepAlive(baseline)
}

// SizeRequest: this function is typically used when implementing a Container
// subclass. Obtains the preferred size of a widget. The container uses this
// information to arrange its child widgets and decide what size allocations to
// give them with gtk_widget_size_allocate().
//
// You can also call this function from an application, with some caveats. Most
// notably, getting a size request requires the widget to be associated with a
// screen, because font information may be needed. Multihead-aware applications
// should keep this in mind.
//
// Also remember that the size request is not necessarily the size a widget will
// actually be allocated.
//
// Deprecated: Use gtk_widget_get_preferred_size() instead.
//
// The function returns the following values:
//
//    - requisition to be filled in.
//
func (widget *Widget) SizeRequest() *Requisition {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_size_request(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _requisition
}

// StyleGetProperty gets the value of a style property of widget.
//
// The function takes the following parameters:
//
//    - propertyName: name of a style property.
//    - value: location to return the property value.
//
func (widget *Widget) StyleGetProperty(propertyName string, value *coreglib.Value) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GValue    // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_widget_style_get_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// ThawChildNotify reverts the effect of a previous call to
// gtk_widget_freeze_child_notify(). This causes all queued Widget::child-notify
// signals on widget to be emitted.
func (widget *Widget) ThawChildNotify() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_thaw_child_notify(_arg0)
	runtime.KeepAlive(widget)
}

// TranslateCoordinates: translate coordinates relative to src_widget’s
// allocation to coordinates relative to dest_widget’s allocations. In order to
// perform this operation, both widgets must be realized, and must share a
// common toplevel.
//
// The function takes the following parameters:
//
//    - destWidget: Widget.
//    - srcX: x position relative to src_widget.
//    - srcY: y position relative to src_widget.
//
// The function returns the following values:
//
//    - destX (optional): location to store X position relative to dest_widget.
//    - destY (optional): location to store Y position relative to dest_widget.
//    - ok: FALSE if either widget was not realized, or there was no common
//      ancestor. In this case, nothing is stored in *dest_x and *dest_y.
//      Otherwise TRUE.
//
func (srcWidget *Widget) TranslateCoordinates(destWidget Widgetter, srcX, srcY int32) (destX, destY int32, ok bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // in
	var _arg5 C.gint       // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(srcWidget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(destWidget).Native()))
	_arg2 = C.gint(srcX)
	_arg3 = C.gint(srcY)

	_cret = C.gtk_widget_translate_coordinates(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(srcWidget)
	runtime.KeepAlive(destWidget)
	runtime.KeepAlive(srcX)
	runtime.KeepAlive(srcY)

	var _destX int32 // out
	var _destY int32 // out
	var _ok bool     // out

	_destX = int32(_arg4)
	_destY = int32(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _destX, _destY, _ok
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of widget is located. See gtk_tooltip_trigger_tooltip_query() for
// more information.
func (widget *Widget) TriggerTooltipQuery() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_trigger_tooltip_query(_arg0)
	runtime.KeepAlive(widget)
}

// Unmap: this function is only for use in widget implementations. Causes a
// widget to be unmapped if it’s currently mapped.
func (widget *Widget) Unmap() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unmap(_arg0)
	runtime.KeepAlive(widget)
}

// Unparent: this function is only for use in widget implementations. Should be
// called by implementations of the remove method on Container, to dissociate a
// child from the container.
func (widget *Widget) Unparent() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unparent(_arg0)
	runtime.KeepAlive(widget)
}

// Unrealize: this function is only useful in widget implementations. Causes a
// widget to be unrealized (frees all GDK resources associated with the widget,
// such as widget->window).
func (widget *Widget) Unrealize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unrealize(_arg0)
	runtime.KeepAlive(widget)
}

// UnregisterWindow unregisters a Window from the widget that was previously set
// up with gtk_widget_register_window(). You need to call this when the window
// is no longer used by the widget, such as when you destroy it.
//
// The function takes the following parameters:
//
//    - window: Window.
//
func (widget *Widget) UnregisterWindow(window gdk.Windower) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_widget_unregister_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(window)
}

// UnsetStateFlags: this function is for use in widget implementations. Turns
// off flag values for the current widget state (insensitive, prelighted, etc.).
// See gtk_widget_set_state_flags().
//
// The function takes the following parameters:
//
//    - flags: state flags to turn off.
//
func (widget *Widget) UnsetStateFlags(flags StateFlags) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(flags)

	C.gtk_widget_unset_state_flags(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
}

// WidgetGetDefaultDirection obtains the current default reading direction. See
// gtk_widget_set_default_direction().
//
// The function returns the following values:
//
//    - textDirection: current default direction.
//
func WidgetGetDefaultDirection() TextDirection {
	var _cret C.GtkTextDirection // in

	_cret = C.gtk_widget_get_default_direction()

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// WidgetPopCompositeChild cancels the effect of a previous call to
// gtk_widget_push_composite_child().
//
// Deprecated: Use gtk_widget_class_set_template(), or don’t use this API at
// all.
func WidgetPopCompositeChild() {
	C.gtk_widget_pop_composite_child()
}

// WidgetPushCompositeChild makes all newly-created widgets as composite
// children until the corresponding gtk_widget_pop_composite_child() call.
//
// A composite child is a child that’s an implementation detail of the container
// it’s inside and should not be visible to people using the container.
// Composite children aren’t treated differently by GTK+ (but see
// gtk_container_foreach() vs. gtk_container_forall()), but e.g. GUI builders
// might want to treat them in a different way.
//
// Deprecated: This API never really worked well and was mostly unused, now we
// have a more complete mechanism for composite children, see
// gtk_widget_class_set_template().
func WidgetPushCompositeChild() {
	C.gtk_widget_push_composite_child()
}

// WidgetSetDefaultDirection sets the default reading direction for widgets
// where the direction has not been explicitly set by
// gtk_widget_set_direction().
//
// The function takes the following parameters:
//
//    - dir: new default direction. This cannot be GTK_TEXT_DIR_NONE.
//
func WidgetSetDefaultDirection(dir TextDirection) {
	var _arg1 C.GtkTextDirection // out

	_arg1 = C.GtkTextDirection(dir)

	C.gtk_widget_set_default_direction(_arg1)
	runtime.KeepAlive(dir)
}

// Requisition represents the desired size of a widget. See [GtkWidget’s
// geometry management section][geometry-management] for more information.
//
// An instance of this type is always passed by reference.
type Requisition struct {
	*requisition
}

// requisition is the struct that's finalized.
type requisition struct {
	native *C.GtkRequisition
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Requisition{&requisition{(*C.GtkRequisition)(b)}}, nil
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	var _cret *C.GtkRequisition // in

	_cret = C.gtk_requisition_new()

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_requisition)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_requisition_free((*C.GtkRequisition)(intern.C))
		},
	)

	return _requisition
}

// Width widget’s desired width.
func (r *Requisition) Width() int32 {
	valptr := &r.native.width
	var v int32 // out
	v = int32(*valptr)
	return v
}

// Height widget’s desired height.
func (r *Requisition) Height() int32 {
	valptr := &r.native.height
	var v int32 // out
	v = int32(*valptr)
	return v
}

// Width widget’s desired width.
func (r *Requisition) SetWidth(width int32) {
	valptr := &r.native.width
	*valptr = C.gint(width)
}

// Height widget’s desired height.
func (r *Requisition) SetHeight(height int32) {
	valptr := &r.native.height
	*valptr = C.gint(height)
}

// Copy copies a Requisition.
//
// The function returns the following values:
//
//    - ret: copy of requisition.
//
func (requisition *Requisition) Copy() *Requisition {
	var _arg0 *C.GtkRequisition // out
	var _cret *C.GtkRequisition // in

	_arg0 = (*C.GtkRequisition)(gextras.StructNative(unsafe.Pointer(requisition)))

	_cret = C.gtk_requisition_copy(_arg0)
	runtime.KeepAlive(requisition)

	var _ret *Requisition // out

	_ret = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_requisition_free((*C.GtkRequisition)(intern.C))
		},
	)

	return _ret
}

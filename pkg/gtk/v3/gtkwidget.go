// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_Widget_ConnectUnrealize(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectUnmap(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStyleUpdated(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStyleSet(gpointer, GtkStyle*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStateFlagsChanged(gpointer, GtkStateFlags, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectStateChanged(gpointer, GtkStateType, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSizeAllocate(gpointer, GtkAllocation*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectShow(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSelectionReceived(gpointer, GtkSelectionData*, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectSelectionGet(gpointer, GtkSelectionData*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectScreenChanged(gpointer, GdkScreen*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectRealize(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectParentSet(gpointer, GtkWidget*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectMoveFocus(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectMap(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectHierarchyChanged(gpointer, GtkWidget*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectHide(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectGrabNotify(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectGrabFocus(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectEventAfter(gpointer, GdkEvent, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragLeave(gpointer, GdkDragContext*, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragEnd(gpointer, GdkDragContext*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataReceived(gpointer, GdkDragContext*, gint, gint, GtkSelectionData*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataGet(gpointer, GdkDragContext*, GtkSelectionData*, guint, guint, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragDataDelete(gpointer, GdkDragContext*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDragBegin(gpointer, GdkDragContext*, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDirectionChanged(gpointer, GtkTextDirection, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectDestroy(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectCompositedChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_Widget_ConnectAccelClosuresChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_WidgetClass_unrealize(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_unmap(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_style_updated(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_style_set(GtkWidget*, GtkStyle*);
// extern void _gotk4_gtk3_WidgetClass_state_flags_changed(GtkWidget*, GtkStateFlags);
// extern void _gotk4_gtk3_WidgetClass_state_changed(GtkWidget*, GtkStateType);
// extern void _gotk4_gtk3_WidgetClass_size_allocate(GtkWidget*, GtkAllocation*);
// extern void _gotk4_gtk3_WidgetClass_show_all(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_show(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_selection_received(GtkWidget*, GtkSelectionData*, guint);
// extern void _gotk4_gtk3_WidgetClass_selection_get(GtkWidget*, GtkSelectionData*, guint, guint);
// extern void _gotk4_gtk3_WidgetClass_screen_changed(GtkWidget*, GdkScreen*);
// extern void _gotk4_gtk3_WidgetClass_realize(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_queue_draw_region(GtkWidget*, cairo_region_t*);
// extern void _gotk4_gtk3_WidgetClass_parent_set(GtkWidget*, GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_move_focus(GtkWidget*, GtkDirectionType);
// extern void _gotk4_gtk3_WidgetClass_map(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_hierarchy_changed(GtkWidget*, GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_hide(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_grab_notify(GtkWidget*, gboolean);
// extern void _gotk4_gtk3_WidgetClass_grab_focus(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_width_for_height(GtkWidget*, gint, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_width(GtkWidget*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_height_for_width(GtkWidget*, gint, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width(GtkWidget*, gint, gint*, gint*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_get_preferred_height(GtkWidget*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_drag_leave(GtkWidget*, GdkDragContext*, guint);
// extern void _gotk4_gtk3_WidgetClass_drag_end(GtkWidget*, GdkDragContext*);
// extern void _gotk4_gtk3_WidgetClass_drag_data_received(GtkWidget*, GdkDragContext*, gint, gint, GtkSelectionData*, guint, guint);
// extern void _gotk4_gtk3_WidgetClass_drag_data_get(GtkWidget*, GdkDragContext*, GtkSelectionData*, guint, guint);
// extern void _gotk4_gtk3_WidgetClass_drag_data_delete(GtkWidget*, GdkDragContext*);
// extern void _gotk4_gtk3_WidgetClass_drag_begin(GtkWidget*, GdkDragContext*);
// extern void _gotk4_gtk3_WidgetClass_direction_changed(GtkWidget*, GtkTextDirection);
// extern void _gotk4_gtk3_WidgetClass_destroy(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_composited_changed(GtkWidget*);
// extern void _gotk4_gtk3_WidgetClass_adjust_size_request(GtkWidget*, GtkOrientation, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_adjust_size_allocation(GtkWidget*, GtkOrientation, gint*, gint*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_adjust_baseline_request(GtkWidget*, gint*, gint*);
// extern void _gotk4_gtk3_WidgetClass_adjust_baseline_allocation(GtkWidget*, gint*);
// extern gboolean _gotk4_gtk3_Widget_ConnectWindowStateEvent(gpointer, GdkEventWindowState*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent(gpointer, GdkEventVisibility*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectUnmapEvent(gpointer, GdkEventAny*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectTouchEvent(gpointer, GdkEvent, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectShowHelp(gpointer, GtkWidgetHelpType, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionRequestEvent(gpointer, GdkEventSelection*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionNotifyEvent(gpointer, GdkEventSelection*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectSelectionClearEvent(gpointer, GdkEventSelection*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectScrollEvent(gpointer, GdkEventScroll*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectQueryTooltip(gpointer, gint, gint, gboolean, GtkTooltip*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectProximityOutEvent(gpointer, GdkEventProximity*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectProximityInEvent(gpointer, GdkEventProximity*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent(gpointer, GdkEventProperty*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectPopupMenu(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMotionNotifyEvent(gpointer, GdkEventMotion*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMnemonicActivate(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectMapEvent(gpointer, GdkEventAny*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent(gpointer, GdkEventCrossing*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectKeynavFailed(gpointer, GtkDirectionType, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectKeyReleaseEvent(gpointer, GdkEventKey*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectKeyPressEvent(gpointer, GdkEventKey*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectGrabBrokenEvent(gpointer, GdkEventGrabBroken*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectFocusOutEvent(gpointer, GdkEventFocus*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectFocusInEvent(gpointer, GdkEventFocus*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectFocus(gpointer, GtkDirectionType, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectEvent(gpointer, GdkEvent, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectEnterNotifyEvent(gpointer, GdkEventCrossing*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDraw(gpointer, cairo_t*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDragMotion(gpointer, GdkDragContext*, gint, gint, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDragFailed(gpointer, GdkDragContext*, GtkDragResult, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDragDrop(gpointer, GdkDragContext*, gint, gint, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDestroyEvent(gpointer, GdkEvent, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDeleteEvent(gpointer, GdkEvent, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectDamageEvent(gpointer, GdkEventExpose*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectConfigureEvent(gpointer, GdkEventConfigure*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectCanActivateAccel(gpointer, guint, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectButtonReleaseEvent(gpointer, GdkEventButton*, guintptr);
// extern gboolean _gotk4_gtk3_Widget_ConnectButtonPressEvent(gpointer, GdkEventButton*, guintptr);
// extern gboolean _gotk4_gtk3_WidgetClass_window_state_event(GtkWidget*, GdkEventWindowState*);
// extern gboolean _gotk4_gtk3_WidgetClass_visibility_notify_event(GtkWidget*, GdkEventVisibility*);
// extern gboolean _gotk4_gtk3_WidgetClass_unmap_event(GtkWidget*, GdkEventAny*);
// extern gboolean _gotk4_gtk3_WidgetClass_touch_event(GtkWidget*, GdkEventTouch*);
// extern gboolean _gotk4_gtk3_WidgetClass_show_help(GtkWidget*, GtkWidgetHelpType);
// extern gboolean _gotk4_gtk3_WidgetClass_selection_request_event(GtkWidget*, GdkEventSelection*);
// extern gboolean _gotk4_gtk3_WidgetClass_selection_notify_event(GtkWidget*, GdkEventSelection*);
// extern gboolean _gotk4_gtk3_WidgetClass_selection_clear_event(GtkWidget*, GdkEventSelection*);
// extern gboolean _gotk4_gtk3_WidgetClass_scroll_event(GtkWidget*, GdkEventScroll*);
// extern gboolean _gotk4_gtk3_WidgetClass_query_tooltip(GtkWidget*, gint, gint, gboolean, GtkTooltip*);
// extern gboolean _gotk4_gtk3_WidgetClass_proximity_out_event(GtkWidget*, GdkEventProximity*);
// extern gboolean _gotk4_gtk3_WidgetClass_proximity_in_event(GtkWidget*, GdkEventProximity*);
// extern gboolean _gotk4_gtk3_WidgetClass_property_notify_event(GtkWidget*, GdkEventProperty*);
// extern gboolean _gotk4_gtk3_WidgetClass_popup_menu(GtkWidget*);
// extern gboolean _gotk4_gtk3_WidgetClass_motion_notify_event(GtkWidget*, GdkEventMotion*);
// extern gboolean _gotk4_gtk3_WidgetClass_mnemonic_activate(GtkWidget*, gboolean);
// extern gboolean _gotk4_gtk3_WidgetClass_map_event(GtkWidget*, GdkEventAny*);
// extern gboolean _gotk4_gtk3_WidgetClass_leave_notify_event(GtkWidget*, GdkEventCrossing*);
// extern gboolean _gotk4_gtk3_WidgetClass_keynav_failed(GtkWidget*, GtkDirectionType);
// extern gboolean _gotk4_gtk3_WidgetClass_key_release_event(GtkWidget*, GdkEventKey*);
// extern gboolean _gotk4_gtk3_WidgetClass_key_press_event(GtkWidget*, GdkEventKey*);
// extern gboolean _gotk4_gtk3_WidgetClass_grab_broken_event(GtkWidget*, GdkEventGrabBroken*);
// extern gboolean _gotk4_gtk3_WidgetClass_focus_out_event(GtkWidget*, GdkEventFocus*);
// extern gboolean _gotk4_gtk3_WidgetClass_focus_in_event(GtkWidget*, GdkEventFocus*);
// extern gboolean _gotk4_gtk3_WidgetClass_focus(GtkWidget*, GtkDirectionType);
// extern gboolean _gotk4_gtk3_WidgetClass_event(GtkWidget*, GdkEvent*);
// extern gboolean _gotk4_gtk3_WidgetClass_enter_notify_event(GtkWidget*, GdkEventCrossing*);
// extern gboolean _gotk4_gtk3_WidgetClass_draw(GtkWidget*, cairo_t*);
// extern gboolean _gotk4_gtk3_WidgetClass_drag_motion(GtkWidget*, GdkDragContext*, gint, gint, guint);
// extern gboolean _gotk4_gtk3_WidgetClass_drag_failed(GtkWidget*, GdkDragContext*, GtkDragResult);
// extern gboolean _gotk4_gtk3_WidgetClass_drag_drop(GtkWidget*, GdkDragContext*, gint, gint, guint);
// extern gboolean _gotk4_gtk3_WidgetClass_destroy_event(GtkWidget*, GdkEventAny*);
// extern gboolean _gotk4_gtk3_WidgetClass_delete_event(GtkWidget*, GdkEventAny*);
// extern gboolean _gotk4_gtk3_WidgetClass_damage_event(GtkWidget*, GdkEventExpose*);
// extern gboolean _gotk4_gtk3_WidgetClass_configure_event(GtkWidget*, GdkEventConfigure*);
// extern gboolean _gotk4_gtk3_WidgetClass_can_activate_accel(GtkWidget*, guint);
// extern gboolean _gotk4_gtk3_WidgetClass_button_release_event(GtkWidget*, GdkEventButton*);
// extern gboolean _gotk4_gtk3_WidgetClass_button_press_event(GtkWidget*, GdkEventButton*);
// extern GtkSizeRequestMode _gotk4_gtk3_WidgetClass_get_request_mode(GtkWidget*);
// extern AtkObject* _gotk4_gtk3_WidgetClass_get_accessible(GtkWidget*);
// AtkObject* _gotk4_gtk3_Widget_virtual_get_accessible(void* fnptr, GtkWidget* arg0) {
//   return ((AtkObject* (*)(GtkWidget*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk3_Widget_virtual_button_press_event(void* fnptr, GtkWidget* arg0, GdkEventButton* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventButton*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_button_release_event(void* fnptr, GtkWidget* arg0, GdkEventButton* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventButton*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_configure_event(void* fnptr, GtkWidget* arg0, GdkEventConfigure* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventConfigure*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_damage_event(void* fnptr, GtkWidget* arg0, GdkEventExpose* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventExpose*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_delete_event(void* fnptr, GtkWidget* arg0, GdkEventAny* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventAny*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_destroy_event(void* fnptr, GtkWidget* arg0, GdkEventAny* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventAny*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_drag_drop(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1, gint arg2, gint arg3, guint arg4) {
//   return ((gboolean (*)(GtkWidget*, GdkDragContext*, gint, gint, guint))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gtk3_Widget_virtual_drag_failed(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1, GtkDragResult arg2) {
//   return ((gboolean (*)(GtkWidget*, GdkDragContext*, GtkDragResult))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk3_Widget_virtual_drag_motion(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1, gint arg2, gint arg3, guint arg4) {
//   return ((gboolean (*)(GtkWidget*, GdkDragContext*, gint, gint, guint))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gtk3_Widget_virtual_draw(void* fnptr, GtkWidget* arg0, cairo_t* arg1) {
//   return ((gboolean (*)(GtkWidget*, cairo_t*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_enter_notify_event(void* fnptr, GtkWidget* arg0, GdkEventCrossing* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventCrossing*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_event(void* fnptr, GtkWidget* arg0, GdkEvent* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_focus(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   return ((gboolean (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_focus_in_event(void* fnptr, GtkWidget* arg0, GdkEventFocus* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventFocus*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_focus_out_event(void* fnptr, GtkWidget* arg0, GdkEventFocus* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventFocus*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_grab_broken_event(void* fnptr, GtkWidget* arg0, GdkEventGrabBroken* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventGrabBroken*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_key_press_event(void* fnptr, GtkWidget* arg0, GdkEventKey* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventKey*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_key_release_event(void* fnptr, GtkWidget* arg0, GdkEventKey* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventKey*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_leave_notify_event(void* fnptr, GtkWidget* arg0, GdkEventCrossing* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventCrossing*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_map_event(void* fnptr, GtkWidget* arg0, GdkEventAny* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventAny*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_mnemonic_activate(void* fnptr, GtkWidget* arg0, gboolean arg1) {
//   return ((gboolean (*)(GtkWidget*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_motion_notify_event(void* fnptr, GtkWidget* arg0, GdkEventMotion* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventMotion*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_popup_menu(void* fnptr, GtkWidget* arg0) {
//   return ((gboolean (*)(GtkWidget*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk3_Widget_virtual_property_notify_event(void* fnptr, GtkWidget* arg0, GdkEventProperty* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventProperty*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_proximity_in_event(void* fnptr, GtkWidget* arg0, GdkEventProximity* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventProximity*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_proximity_out_event(void* fnptr, GtkWidget* arg0, GdkEventProximity* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventProximity*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_query_tooltip(void* fnptr, GtkWidget* arg0, gint arg1, gint arg2, gboolean arg3, GtkTooltip* arg4) {
//   return ((gboolean (*)(GtkWidget*, gint, gint, gboolean, GtkTooltip*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gtk3_Widget_virtual_scroll_event(void* fnptr, GtkWidget* arg0, GdkEventScroll* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventScroll*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_selection_clear_event(void* fnptr, GtkWidget* arg0, GdkEventSelection* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventSelection*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_selection_notify_event(void* fnptr, GtkWidget* arg0, GdkEventSelection* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventSelection*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_selection_request_event(void* fnptr, GtkWidget* arg0, GdkEventSelection* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventSelection*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_show_help(void* fnptr, GtkWidget* arg0, GtkWidgetHelpType arg1) {
//   return ((gboolean (*)(GtkWidget*, GtkWidgetHelpType))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_touch_event(void* fnptr, GtkWidget* arg0, GdkEventTouch* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventTouch*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_unmap_event(void* fnptr, GtkWidget* arg0, GdkEventAny* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventAny*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_visibility_notify_event(void* fnptr, GtkWidget* arg0, GdkEventVisibility* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventVisibility*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk3_Widget_virtual_window_state_event(void* fnptr, GtkWidget* arg0, GdkEventWindowState* arg1) {
//   return ((gboolean (*)(GtkWidget*, GdkEventWindowState*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_adjust_baseline_allocation(void* fnptr, GtkWidget* arg0, gint* arg1) {
//   ((void (*)(GtkWidget*, gint*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_adjust_baseline_request(void* fnptr, GtkWidget* arg0, gint* arg1, gint* arg2) {
//   ((void (*)(GtkWidget*, gint*, gint*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_Widget_virtual_adjust_size_allocation(void* fnptr, GtkWidget* arg0, GtkOrientation arg1, gint* arg2, gint* arg3, gint* arg4, gint* arg5) {
//   ((void (*)(GtkWidget*, GtkOrientation, gint*, gint*, gint*, gint*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gtk3_Widget_virtual_adjust_size_request(void* fnptr, GtkWidget* arg0, GtkOrientation arg1, gint* arg2, gint* arg3) {
//   ((void (*)(GtkWidget*, GtkOrientation, gint*, gint*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk3_Widget_virtual_composited_changed(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_destroy(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_direction_changed(void* fnptr, GtkWidget* arg0, GtkTextDirection arg1) {
//   ((void (*)(GtkWidget*, GtkTextDirection))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_drag_begin(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1) {
//   ((void (*)(GtkWidget*, GdkDragContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_drag_data_delete(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1) {
//   ((void (*)(GtkWidget*, GdkDragContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_drag_data_get(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1, GtkSelectionData* arg2, guint arg3, guint arg4) {
//   ((void (*)(GtkWidget*, GdkDragContext*, GtkSelectionData*, guint, guint))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk3_Widget_virtual_drag_data_received(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1, gint arg2, gint arg3, GtkSelectionData* arg4, guint arg5, guint arg6) {
//   ((void (*)(GtkWidget*, GdkDragContext*, gint, gint, GtkSelectionData*, guint, guint))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gtk3_Widget_virtual_drag_end(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1) {
//   ((void (*)(GtkWidget*, GdkDragContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_drag_leave(void* fnptr, GtkWidget* arg0, GdkDragContext* arg1, guint arg2) {
//   ((void (*)(GtkWidget*, GdkDragContext*, guint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_Widget_virtual_grab_focus(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_grab_notify(void* fnptr, GtkWidget* arg0, gboolean arg1) {
//   ((void (*)(GtkWidget*, gboolean))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_hide(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_hierarchy_changed(void* fnptr, GtkWidget* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkWidget*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_map(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_move_focus(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   ((void (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_parent_set(void* fnptr, GtkWidget* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkWidget*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_realize(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_screen_changed(void* fnptr, GtkWidget* arg0, GdkScreen* arg1) {
//   ((void (*)(GtkWidget*, GdkScreen*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_selection_get(void* fnptr, GtkWidget* arg0, GtkSelectionData* arg1, guint arg2, guint arg3) {
//   ((void (*)(GtkWidget*, GtkSelectionData*, guint, guint))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk3_Widget_virtual_selection_received(void* fnptr, GtkWidget* arg0, GtkSelectionData* arg1, guint arg2) {
//   ((void (*)(GtkWidget*, GtkSelectionData*, guint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_Widget_virtual_show(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_show_all(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_size_allocate(void* fnptr, GtkWidget* arg0, GtkAllocation* arg1) {
//   ((void (*)(GtkWidget*, GtkAllocation*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_state_changed(void* fnptr, GtkWidget* arg0, GtkStateType arg1) {
//   ((void (*)(GtkWidget*, GtkStateType))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_state_flags_changed(void* fnptr, GtkWidget* arg0, GtkStateFlags arg1) {
//   ((void (*)(GtkWidget*, GtkStateFlags))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_style_set(void* fnptr, GtkWidget* arg0, GtkStyle* arg1) {
//   ((void (*)(GtkWidget*, GtkStyle*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Widget_virtual_style_updated(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_unmap(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_unrealize(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeWidgetHelpType = coreglib.Type(C.gtk_widget_help_type_get_type())
	GTypeWidget         = coreglib.Type(C.gtk_widget_get_type())
	GTypeRequisition    = coreglib.Type(C.gtk_requisition_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeWidgetHelpType, F: marshalWidgetHelpType},
		coreglib.TypeMarshaler{T: GTypeWidget, F: marshalWidget},
		coreglib.TypeMarshaler{T: GTypeRequisition, F: marshalRequisition},
	})
}

// Allocation of a widget represents region which has been allocated to the
// widget by its parent. It is a subregion of its parents allocation. See
// [GtkWidget’s geometry management section][geometry-management] for more
// information.
type Allocation = gdk.Rectangle

// WidgetHelpType kinds of widget-specific help. Used by the ::show-help signal.
type WidgetHelpType C.gint

const (
	// WidgetHelpTooltip: tooltip.
	WidgetHelpTooltip WidgetHelpType = iota
	// WidgetHelpWhatsThis what’s this.
	WidgetHelpWhatsThis
)

func marshalWidgetHelpType(p uintptr) (interface{}, error) {
	return WidgetHelpType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WidgetHelpType.
func (w WidgetHelpType) String() string {
	switch w {
	case WidgetHelpTooltip:
		return "Tooltip"
	case WidgetHelpWhatsThis:
		return "WhatsThis"
	default:
		return fmt.Sprintf("WidgetHelpType(%d)", w)
	}
}

// Callback: type of the callback functions used for e.g. iterating over the
// children of a container, see gtk_container_foreach().
type Callback func(widget Widgetter)

// WidgetOverrides contains methods that are overridable.
type WidgetOverrides struct {
	// The function takes the following parameters:
	//
	AdjustBaselineAllocation func(baseline *int)
	// The function takes the following parameters:
	//
	//    - minimumBaseline
	//    - naturalBaseline
	//
	AdjustBaselineRequest func(minimumBaseline, naturalBaseline *int)
	// The function takes the following parameters:
	//
	//    - orientation
	//    - minimumSize
	//    - naturalSize
	//    - allocatedPos
	//    - allocatedSize
	//
	AdjustSizeAllocation func(orientation Orientation, minimumSize, naturalSize, allocatedPos, allocatedSize *int)
	// The function takes the following parameters:
	//
	//    - orientation
	//    - minimumSize
	//    - naturalSize
	//
	AdjustSizeRequest func(orientation Orientation, minimumSize, naturalSize *int)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ButtonPressEvent func(event *gdk.EventButton) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ButtonReleaseEvent func(event *gdk.EventButton) bool
	// CanActivateAccel determines whether an accelerator that activates the
	// signal identified by signal_id can currently be activated. This is done
	// by emitting the Widget::can-activate-accel signal on widget; if the
	// signal isn’t overridden by a handler or in a derived widget, then the
	// default check is that the widget must be sensitive, and the widget and
	// all its ancestors mapped.
	//
	// The function takes the following parameters:
	//
	//    - signalId: ID of a signal installed on widget.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the accelerator can be activated.
	//
	CanActivateAccel  func(signalId uint) bool
	CompositedChanged func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ConfigureEvent func(event *gdk.EventConfigure) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DamageEvent func(event *gdk.EventExpose) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DeleteEvent func(event *gdk.EventAny) bool
	// Destroy destroys a widget.
	//
	// When a widget is destroyed all references it holds on other objects will
	// be released:
	//
	//    - if the widget is inside a container, it will be removed from its
	//    parent
	//    - if the widget is a container, all its children will be destroyed,
	//    recursively
	//    - if the widget is a top level, it will be removed from the list
	//    of top level widgets that GTK+ maintains internally
	//
	// It's expected that all references held on the widget will also be
	// released; you should connect to the Widget::destroy signal if you hold a
	// reference to widget and you wish to remove it when this function is
	// called. It is not necessary to do so if you are implementing a Container,
	// as you'll be able to use the ContainerClass.remove() virtual function for
	// that.
	//
	// It's important to notice that gtk_widget_destroy() will only cause the
	// widget to be finalized if no additional references, acquired using
	// g_object_ref(), are held on it. In case additional references are in
	// place, the widget will be in an "inert" state after calling this
	// function; widget will still point to valid memory, allowing you to
	// release the references you hold, but you may not query the widget's own
	// state.
	//
	// You should typically call this function on top level widgets, and rarely
	// on child widgets.
	//
	// See also: gtk_container_remove().
	Destroy func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	DestroyEvent func(event *gdk.EventAny) bool
	// The function takes the following parameters:
	//
	DirectionChanged func(previousDirection TextDirection)
	// The function takes the following parameters:
	//
	DragBegin func(context *gdk.DragContext)
	// The function takes the following parameters:
	//
	DragDataDelete func(context *gdk.DragContext)
	// The function takes the following parameters:
	//
	//    - context
	//    - selectionData
	//    - info
	//    - time_
	//
	DragDataGet func(context *gdk.DragContext, selectionData *SelectionData, info, time_ uint)
	// The function takes the following parameters:
	//
	//    - context
	//    - x
	//    - y
	//    - selectionData
	//    - info
	//    - time_
	//
	DragDataReceived func(context *gdk.DragContext, x, y int, selectionData *SelectionData, info, time_ uint)
	// The function takes the following parameters:
	//
	//    - context
	//    - x
	//    - y
	//    - time_
	//
	// The function returns the following values:
	//
	DragDrop func(context *gdk.DragContext, x, y int, time_ uint) bool
	// The function takes the following parameters:
	//
	DragEnd func(context *gdk.DragContext)
	// The function takes the following parameters:
	//
	//    - context
	//    - result
	//
	// The function returns the following values:
	//
	DragFailed func(context *gdk.DragContext, result DragResult) bool
	// The function takes the following parameters:
	//
	//    - context
	//    - time_
	//
	DragLeave func(context *gdk.DragContext, time_ uint)
	// The function takes the following parameters:
	//
	//    - context
	//    - x
	//    - y
	//    - time_
	//
	// The function returns the following values:
	//
	DragMotion func(context *gdk.DragContext, x, y int, time_ uint) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Draw func(cr *cairo.Context) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	EnterNotifyEvent func(event *gdk.EventCrossing) bool
	// Event: rarely-used function. This function is used to emit the event
	// signals on a widget (those signals should never be emitted without using
	// this function to do so). If you want to synthesize an event though, don’t
	// use this function; instead, use gtk_main_do_event() so the event will
	// behave as if it were in the event queue. Don’t synthesize expose events;
	// instead, use gdk_window_invalidate_rect() to invalidate a region of the
	// window.
	//
	// The function takes the following parameters:
	//
	//    - event: Event.
	//
	// The function returns the following values:
	//
	//    - ok: return from the event signal emission (TRUE if the event was
	//      handled).
	//
	Event func(event *gdk.Event) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Focus func(direction DirectionType) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	FocusInEvent func(event *gdk.EventFocus) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	FocusOutEvent func(event *gdk.EventFocus) bool
	// Accessible returns the accessible object that describes the widget to an
	// assistive technology.
	//
	// If accessibility support is not available, this Object instance may be a
	// no-op. Likewise, if no class-specific Object implementation is available
	// for the widget instance in question, it will inherit an Object
	// implementation from the first ancestor class for which such an
	// implementation is defined.
	//
	// The documentation of the ATK (http://developer.gnome.org/atk/stable/)
	// library contains more information about accessible objects and their
	// uses.
	//
	// The function returns the following values:
	//
	//    - object associated with widget.
	//
	Accessible func() *atk.AtkObject
	// PreferredHeight retrieves a widget’s initial minimum and natural height.
	//
	// This call is specific to width-for-height requests.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location to store the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location to store the natural height, or
	//      NULL.
	//
	PreferredHeight func() (minimumHeight, naturalHeight int)
	// PreferredHeightAndBaselineForWidth retrieves a widget’s minimum and
	// natural height and the corresponding baselines if it would be given the
	// specified width, or the default height if width is -1. The baselines may
	// be -1 which means that no baseline is requested for this widget.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request and
	// GtkWidgetClass::adjust_baseline_request virtual methods and by any
	// SizeGroups that have been applied. That is, the returned request is the
	// one that should be used for layout, not necessarily the one returned by
	// the widget itself.
	//
	// The function takes the following parameters:
	//
	//    - width which is available for allocation, or -1 if none.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location for storing the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location for storing the natural height, or
	//      NULL.
	//    - minimumBaseline (optional): location for storing the baseline for the
	//      minimum height, or NULL.
	//    - naturalBaseline (optional): location for storing the baseline for the
	//      natural height, or NULL.
	//
	PreferredHeightAndBaselineForWidth func(width int) (minimumHeight, naturalHeight, minimumBaseline, naturalBaseline int)
	// PreferredHeightForWidth retrieves a widget’s minimum and natural height
	// if it would be given the specified width.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	//
	// The function takes the following parameters:
	//
	//    - width which is available for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location for storing the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location for storing the natural height, or
	//      NULL.
	//
	PreferredHeightForWidth func(width int) (minimumHeight, naturalHeight int)
	// PreferredWidth retrieves a widget’s initial minimum and natural width.
	//
	// This call is specific to height-for-width requests.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location to store the minimum width, or
	//      NULL.
	//    - naturalWidth (optional): location to store the natural width, or
	//      NULL.
	//
	PreferredWidth func() (minimumWidth, naturalWidth int)
	// PreferredWidthForHeight retrieves a widget’s minimum and natural width if
	// it would be given the specified height.
	//
	// The returned request will be modified by the
	// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups
	// that have been applied. That is, the returned request is the one that
	// should be used for layout, not necessarily the one returned by the widget
	// itself.
	//
	// The function takes the following parameters:
	//
	//    - height which is available for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location for storing the minimum width, or
	//      NULL.
	//    - naturalWidth (optional): location for storing the natural width, or
	//      NULL.
	//
	PreferredWidthForHeight func(height int) (minimumWidth, naturalWidth int)
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Bin widgets generally propagate the preference of their child, container
	// widgets need to request something either in context of their children or
	// in context of their allocation capabilities.
	//
	// The function returns the following values:
	//
	//    - sizeRequestMode preferred by widget.
	//
	RequestMode func() SizeRequestMode
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	GrabBrokenEvent func(event *gdk.EventGrabBroken) bool
	// GrabFocus causes widget to have the keyboard focus for the Window it's
	// inside. widget must be a focusable widget, such as a Entry; something
	// like Frame won’t work.
	//
	// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
	// gtk_widget_set_can_focus() to modify that flag.
	//
	// The widget also needs to be realized and mapped. This is indicated by the
	// related signals. Grabbing the focus immediately after creating the widget
	// will likely fail and cause critical warnings.
	GrabFocus func()
	// The function takes the following parameters:
	//
	GrabNotify func(wasGrabbed bool)
	// Hide reverses the effects of gtk_widget_show(), causing the widget to be
	// hidden (invisible to the user).
	Hide func()
	// The function takes the following parameters:
	//
	HierarchyChanged func(previousToplevel Widgetter)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	KeyPressEvent func(event *gdk.EventKey) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	KeyReleaseEvent func(event *gdk.EventKey) bool
	// KeynavFailed: this function should be called whenever keyboard navigation
	// within a single widget hits a boundary. The function emits the
	// Widget::keynav-failed signal on the widget and its return value should be
	// interpreted in a way similar to the return value of
	// gtk_widget_child_focus():
	//
	// When TRUE is returned, stay in the widget, the failed keyboard navigation
	// is OK and/or there is nowhere we can/should move the focus to.
	//
	// When FALSE is returned, the caller should continue with keyboard
	// navigation outside the widget, e.g. by calling gtk_widget_child_focus()
	// on the widget’s toplevel.
	//
	// The default ::keynav-failed handler returns FALSE for GTK_DIR_TAB_FORWARD
	// and GTK_DIR_TAB_BACKWARD. For the other values of DirectionType it
	// returns TRUE.
	//
	// Whenever the default handler returns TRUE, it also calls
	// gtk_widget_error_bell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of Entry widgets
	// where the user should be able to navigate the entire row with the cursor
	// keys, as e.g. known from user interfaces that require entering license
	// keys.
	//
	// The function takes the following parameters:
	//
	//    - direction of focus movement.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if stopping keyboard navigation is fine, FALSE if the
	//      emitting widget should try to handle the keyboard navigation attempt
	//      in its parent container(s).
	//
	KeynavFailed func(direction DirectionType) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	LeaveNotifyEvent func(event *gdk.EventCrossing) bool
	// Map: this function is only for use in widget implementations. Causes a
	// widget to be mapped if it isn’t already.
	Map func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	MapEvent func(event *gdk.EventAny) bool
	// MnemonicActivate emits the Widget::mnemonic-activate signal.
	//
	// The function takes the following parameters:
	//
	//    - groupCycling: TRUE if there are other widgets with the same mnemonic.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if the signal has been handled.
	//
	MnemonicActivate func(groupCycling bool) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	MotionNotifyEvent func(event *gdk.EventMotion) bool
	// The function takes the following parameters:
	//
	MoveFocus func(direction DirectionType)
	// The function takes the following parameters:
	//
	ParentSet func(previousParent Widgetter)
	// The function returns the following values:
	//
	PopupMenu func() bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	PropertyNotifyEvent func(event *gdk.EventProperty) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProximityInEvent func(event *gdk.EventProximity) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ProximityOutEvent func(event *gdk.EventProximity) bool
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - keyboardTooltip
	//    - tooltip
	//
	// The function returns the following values:
	//
	QueryTooltip func(x, y int, keyboardTooltip bool, tooltip *Tooltip) bool
	// QueueDrawRegion invalidates the area of widget defined by region by
	// calling gdk_window_invalidate_region() on the widget’s window and all its
	// child windows. Once the main loop becomes idle (after the current batch
	// of events has been processed, roughly), the window will receive expose
	// events for the union of all regions that have been invalidated.
	//
	// Normally you would only use this function in widget implementations. You
	// might also use it to schedule a redraw of a DrawingArea or some portion
	// thereof.
	//
	// The function takes the following parameters:
	//
	//    - region to draw.
	//
	QueueDrawRegion func(region *cairo.Region)
	// Realize creates the GDK (windowing system) resources associated with a
	// widget. For example, widget->window will be created when a widget is
	// realized. Normally realization happens implicitly; if you show a widget
	// and all its parent containers, then the widget will be realized and
	// mapped automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling gtk_widget_realize() realizes the widget’s parents in
	// addition to widget itself. If a widget is not yet inside a toplevel
	// window when you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t very
	// useful otherwise. Many times when you think you might need it, a better
	// approach is to connect to a signal that will be called after the widget
	// is realized automatically, such as Widget::draw. Or simply
	// g_signal_connect () to the Widget::realize signal.
	Realize func()
	// The function takes the following parameters:
	//
	ScreenChanged func(previousScreen *gdk.Screen)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ScrollEvent func(event *gdk.EventScroll) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SelectionClearEvent func(event *gdk.EventSelection) bool
	// The function takes the following parameters:
	//
	//    - selectionData
	//    - info
	//    - time_
	//
	SelectionGet func(selectionData *SelectionData, info, time_ uint)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SelectionNotifyEvent func(event *gdk.EventSelection) bool
	// The function takes the following parameters:
	//
	//    - selectionData
	//    - time_
	//
	SelectionReceived func(selectionData *SelectionData, time_ uint)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SelectionRequestEvent func(event *gdk.EventSelection) bool
	// Show flags a widget to be displayed. Any widget that isn’t shown will not
	// appear on the screen. If you want to show all the widgets in a container,
	// it’s easier to call gtk_widget_show_all() on the container, instead of
	// individually showing the widgets.
	//
	// Remember that you have to show the containers containing a widget, in
	// addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show func()
	// ShowAll: recursively shows a widget, and any child widgets (if the widget
	// is a container).
	ShowAll func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ShowHelp func(helpType WidgetHelpType) bool
	// SizeAllocate: this function is only used by Container subclasses, to
	// assign a size and position to their child widgets.
	//
	// In this function, the allocation may be adjusted. It will be forced to a
	// 1x1 minimum size, and the adjust_size_allocation virtual method on the
	// child will be used to adjust the allocation. Standard adjustments include
	// removing the widget’s margins, and applying the widget’s Widget:halign
	// and Widget:valign properties.
	//
	// For baseline support in containers you need to use
	// gtk_widget_size_allocate_with_baseline() instead.
	//
	// The function takes the following parameters:
	//
	//    - allocation: position and size to be allocated to widget.
	//
	SizeAllocate func(allocation *Allocation)
	// The function takes the following parameters:
	//
	StateChanged func(previousState StateType)
	// The function takes the following parameters:
	//
	StateFlagsChanged func(previousStateFlags StateFlags)
	// The function takes the following parameters:
	//
	StyleSet     func(previousStyle *Style)
	StyleUpdated func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	TouchEvent func(event *gdk.EventTouch) bool
	// Unmap: this function is only for use in widget implementations. Causes a
	// widget to be unmapped if it’s currently mapped.
	Unmap func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	UnmapEvent func(event *gdk.EventAny) bool
	// Unrealize: this function is only useful in widget implementations. Causes
	// a widget to be unrealized (frees all GDK resources associated with the
	// widget, such as widget->window).
	Unrealize func()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	VisibilityNotifyEvent func(event *gdk.EventVisibility) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	WindowStateEvent func(event *gdk.EventWindowState) bool
}

func defaultWidgetOverrides(v *Widget) WidgetOverrides {
	return WidgetOverrides{
		AdjustBaselineAllocation:           v.adjustBaselineAllocation,
		AdjustBaselineRequest:              v.adjustBaselineRequest,
		AdjustSizeAllocation:               v.adjustSizeAllocation,
		AdjustSizeRequest:                  v.adjustSizeRequest,
		ButtonPressEvent:                   v.buttonPressEvent,
		ButtonReleaseEvent:                 v.buttonReleaseEvent,
		CanActivateAccel:                   v.canActivateAccel,
		CompositedChanged:                  v.compositedChanged,
		ConfigureEvent:                     v.configureEvent,
		DamageEvent:                        v.damageEvent,
		DeleteEvent:                        v.deleteEvent,
		Destroy:                            v.destroy,
		DestroyEvent:                       v.destroyEvent,
		DirectionChanged:                   v.directionChanged,
		DragBegin:                          v.dragBegin,
		DragDataDelete:                     v.dragDataDelete,
		DragDataGet:                        v.dragDataGet,
		DragDataReceived:                   v.dragDataReceived,
		DragDrop:                           v.dragDrop,
		DragEnd:                            v.dragEnd,
		DragFailed:                         v.dragFailed,
		DragLeave:                          v.dragLeave,
		DragMotion:                         v.dragMotion,
		Draw:                               v.draw,
		EnterNotifyEvent:                   v.enterNotifyEvent,
		Event:                              v.event,
		Focus:                              v.focus,
		FocusInEvent:                       v.focusInEvent,
		FocusOutEvent:                      v.focusOutEvent,
		Accessible:                         v.accessible,
		PreferredHeight:                    v.preferredHeight,
		PreferredHeightAndBaselineForWidth: v.preferredHeightAndBaselineForWidth,
		PreferredHeightForWidth:            v.preferredHeightForWidth,
		PreferredWidth:                     v.preferredWidth,
		PreferredWidthForHeight:            v.preferredWidthForHeight,
		RequestMode:                        v.requestMode,
		GrabBrokenEvent:                    v.grabBrokenEvent,
		GrabFocus:                          v.grabFocus,
		GrabNotify:                         v.grabNotify,
		Hide:                               v.hide,
		HierarchyChanged:                   v.hierarchyChanged,
		KeyPressEvent:                      v.keyPressEvent,
		KeyReleaseEvent:                    v.keyReleaseEvent,
		KeynavFailed:                       v.keynavFailed,
		LeaveNotifyEvent:                   v.leaveNotifyEvent,
		Map:                                v._map,
		MapEvent:                           v.mapEvent,
		MnemonicActivate:                   v.mnemonicActivate,
		MotionNotifyEvent:                  v.motionNotifyEvent,
		MoveFocus:                          v.moveFocus,
		ParentSet:                          v.parentSet,
		PopupMenu:                          v.popupMenu,
		PropertyNotifyEvent:                v.propertyNotifyEvent,
		ProximityInEvent:                   v.proximityInEvent,
		ProximityOutEvent:                  v.proximityOutEvent,
		QueryTooltip:                       v.queryTooltip,
		QueueDrawRegion:                    v.queueDrawRegion,
		Realize:                            v.realize,
		ScreenChanged:                      v.screenChanged,
		ScrollEvent:                        v.scrollEvent,
		SelectionClearEvent:                v.selectionClearEvent,
		SelectionGet:                       v.selectionGet,
		SelectionNotifyEvent:               v.selectionNotifyEvent,
		SelectionReceived:                  v.selectionReceived,
		SelectionRequestEvent:              v.selectionRequestEvent,
		Show:                               v.show,
		ShowAll:                            v.showAll,
		ShowHelp:                           v.showHelp,
		SizeAllocate:                       v.sizeAllocate,
		StateChanged:                       v.stateChanged,
		StateFlagsChanged:                  v.stateFlagsChanged,
		StyleSet:                           v.styleSet,
		StyleUpdated:                       v.styleUpdated,
		TouchEvent:                         v.touchEvent,
		Unmap:                              v.unmap,
		UnmapEvent:                         v.unmapEvent,
		Unrealize:                          v.unrealize,
		VisibilityNotifyEvent:              v.visibilityNotifyEvent,
		WindowStateEvent:                   v.windowStateEvent,
	}
}

// Widget is the base class all widgets in GTK+ derive from. It manages the
// widget lifecycle, states and style.
//
//
// Height-for-width Geometry Management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK+ by way of five
// virtual methods:
//
// - WidgetClass.get_request_mode()
//
// - WidgetClass.get_preferred_width()
//
// - WidgetClass.get_preferred_height()
//
// - WidgetClass.get_preferred_height_for_width()
//
// - WidgetClass.get_preferred_width_for_height()
//
// - WidgetClass.get_preferred_height_and_baseline_for_width()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in container implementations.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode: First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_get_preferred_width(). Because
// the preferred widths for each container depend on the preferred widths of
// their children, this information propagates up the hierarchy, and finally a
// minimum and natural width is determined for the entire toplevel. Next, the
// toplevel will use the minimum width to query for the minimum height
// contextual to that width using gtk_widget_get_preferred_height_for_width(),
// which will also be a highly recursive operation. The minimum height for the
// minimum width is normally used to set the minimum size constraint on the
// toplevel (unless gtk_window_set_geometry_hints() is explicitly used instead).
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk_window_set_default_size()). During the recursive
// allocation process it’s important to note that request cycles will be
// recursively executed while container widgets allocate their children. Each
// container widget, once allocated a size, will go on to first share the space
// in one orientation among its children and then request each child's height
// for its target allocated width or its width for allocated height, depending.
// In this way a Widget will typically be requested its size a number of times
// before actually being allocated a size. The size a widget is finally
// allocated can of course differ from the size it has requested. For this
// reason, Widget caches a small number of results to avoid re-querying for the
// same sizes in one allocation cycle.
//
// See [GtkContainer’s geometry management
// section][container-geometry-management] to learn more about how
// height-for-width allocations are performed by container widgets.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both SizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a Label that does height-for-width word wrapping will not
// expect to have WidgetClass.get_preferred_height() called because that call is
// specific to a width-for-height request. In this case the label must return
// the height required for its own minimum possible width. By following this
// rule any widget that handles height-for-width or width-for-height requests
// will always be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests, for
// WidgetClass.get_preferred_height() it will do:
//
//    // the signal handler has the instance and user data swapped
//    // because of the swapped="yes" attribute in the template XML
//    static void
//    hello_button_clicked (FooWidget *self,
//                          GtkButton *button)
//    {
//      g_print ("Hello, world!\n");
//    }
//
//    static void
//    foo_widget_class_init (FooWidgetClass *klass)
//    {
//      // ...
//      gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                   "/com/example/ui/foowidget.ui");
//      gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//    }.
type Widget struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned

	*coreglib.Object
	atk.ImplementorIface
	Buildable
}

var (
	_ coreglib.Objector = (*Widget)(nil)
)

// Widgetter describes types inherited from class Widget.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Widgetter interface {
	coreglib.Objector
	baseWidget() *Widget
}

var _ Widgetter = (*Widget)(nil)

func init() {
	coreglib.RegisterClassInfo[*Widget, *WidgetClass, WidgetOverrides](
		GTypeWidget,
		initWidgetClass,
		wrapWidget,
		defaultWidgetOverrides,
	)
}

func initWidgetClass(gclass unsafe.Pointer, overrides WidgetOverrides, classInitFunc func(*WidgetClass)) {
	pclass := (*C.GtkWidgetClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeWidget))))

	if overrides.AdjustBaselineAllocation != nil {
		pclass.adjust_baseline_allocation = (*[0]byte)(C._gotk4_gtk3_WidgetClass_adjust_baseline_allocation)
	}

	if overrides.AdjustBaselineRequest != nil {
		pclass.adjust_baseline_request = (*[0]byte)(C._gotk4_gtk3_WidgetClass_adjust_baseline_request)
	}

	if overrides.AdjustSizeAllocation != nil {
		pclass.adjust_size_allocation = (*[0]byte)(C._gotk4_gtk3_WidgetClass_adjust_size_allocation)
	}

	if overrides.AdjustSizeRequest != nil {
		pclass.adjust_size_request = (*[0]byte)(C._gotk4_gtk3_WidgetClass_adjust_size_request)
	}

	if overrides.ButtonPressEvent != nil {
		pclass.button_press_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_button_press_event)
	}

	if overrides.ButtonReleaseEvent != nil {
		pclass.button_release_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_button_release_event)
	}

	if overrides.CanActivateAccel != nil {
		pclass.can_activate_accel = (*[0]byte)(C._gotk4_gtk3_WidgetClass_can_activate_accel)
	}

	if overrides.CompositedChanged != nil {
		pclass.composited_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_composited_changed)
	}

	if overrides.ConfigureEvent != nil {
		pclass.configure_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_configure_event)
	}

	if overrides.DamageEvent != nil {
		pclass.damage_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_damage_event)
	}

	if overrides.DeleteEvent != nil {
		pclass.delete_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_delete_event)
	}

	if overrides.Destroy != nil {
		pclass.destroy = (*[0]byte)(C._gotk4_gtk3_WidgetClass_destroy)
	}

	if overrides.DestroyEvent != nil {
		pclass.destroy_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_destroy_event)
	}

	if overrides.DirectionChanged != nil {
		pclass.direction_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_direction_changed)
	}

	if overrides.DragBegin != nil {
		pclass.drag_begin = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_begin)
	}

	if overrides.DragDataDelete != nil {
		pclass.drag_data_delete = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_data_delete)
	}

	if overrides.DragDataGet != nil {
		pclass.drag_data_get = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_data_get)
	}

	if overrides.DragDataReceived != nil {
		pclass.drag_data_received = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_data_received)
	}

	if overrides.DragDrop != nil {
		pclass.drag_drop = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_drop)
	}

	if overrides.DragEnd != nil {
		pclass.drag_end = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_end)
	}

	if overrides.DragFailed != nil {
		pclass.drag_failed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_failed)
	}

	if overrides.DragLeave != nil {
		pclass.drag_leave = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_leave)
	}

	if overrides.DragMotion != nil {
		pclass.drag_motion = (*[0]byte)(C._gotk4_gtk3_WidgetClass_drag_motion)
	}

	if overrides.Draw != nil {
		pclass.draw = (*[0]byte)(C._gotk4_gtk3_WidgetClass_draw)
	}

	if overrides.EnterNotifyEvent != nil {
		pclass.enter_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_enter_notify_event)
	}

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_event)
	}

	if overrides.Focus != nil {
		pclass.focus = (*[0]byte)(C._gotk4_gtk3_WidgetClass_focus)
	}

	if overrides.FocusInEvent != nil {
		pclass.focus_in_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_focus_in_event)
	}

	if overrides.FocusOutEvent != nil {
		pclass.focus_out_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_focus_out_event)
	}

	if overrides.Accessible != nil {
		pclass.get_accessible = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_accessible)
	}

	if overrides.PreferredHeight != nil {
		pclass.get_preferred_height = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_height)
	}

	if overrides.PreferredHeightAndBaselineForWidth != nil {
		pclass.get_preferred_height_and_baseline_for_width = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_height_and_baseline_for_width)
	}

	if overrides.PreferredHeightForWidth != nil {
		pclass.get_preferred_height_for_width = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_height_for_width)
	}

	if overrides.PreferredWidth != nil {
		pclass.get_preferred_width = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_width)
	}

	if overrides.PreferredWidthForHeight != nil {
		pclass.get_preferred_width_for_height = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_preferred_width_for_height)
	}

	if overrides.RequestMode != nil {
		pclass.get_request_mode = (*[0]byte)(C._gotk4_gtk3_WidgetClass_get_request_mode)
	}

	if overrides.GrabBrokenEvent != nil {
		pclass.grab_broken_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_grab_broken_event)
	}

	if overrides.GrabFocus != nil {
		pclass.grab_focus = (*[0]byte)(C._gotk4_gtk3_WidgetClass_grab_focus)
	}

	if overrides.GrabNotify != nil {
		pclass.grab_notify = (*[0]byte)(C._gotk4_gtk3_WidgetClass_grab_notify)
	}

	if overrides.Hide != nil {
		pclass.hide = (*[0]byte)(C._gotk4_gtk3_WidgetClass_hide)
	}

	if overrides.HierarchyChanged != nil {
		pclass.hierarchy_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_hierarchy_changed)
	}

	if overrides.KeyPressEvent != nil {
		pclass.key_press_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_key_press_event)
	}

	if overrides.KeyReleaseEvent != nil {
		pclass.key_release_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_key_release_event)
	}

	if overrides.KeynavFailed != nil {
		pclass.keynav_failed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_keynav_failed)
	}

	if overrides.LeaveNotifyEvent != nil {
		pclass.leave_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_leave_notify_event)
	}

	if overrides.Map != nil {
		pclass._map = (*[0]byte)(C._gotk4_gtk3_WidgetClass_map)
	}

	if overrides.MapEvent != nil {
		pclass.map_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_map_event)
	}

	if overrides.MnemonicActivate != nil {
		pclass.mnemonic_activate = (*[0]byte)(C._gotk4_gtk3_WidgetClass_mnemonic_activate)
	}

	if overrides.MotionNotifyEvent != nil {
		pclass.motion_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_motion_notify_event)
	}

	if overrides.MoveFocus != nil {
		pclass.move_focus = (*[0]byte)(C._gotk4_gtk3_WidgetClass_move_focus)
	}

	if overrides.ParentSet != nil {
		pclass.parent_set = (*[0]byte)(C._gotk4_gtk3_WidgetClass_parent_set)
	}

	if overrides.PopupMenu != nil {
		pclass.popup_menu = (*[0]byte)(C._gotk4_gtk3_WidgetClass_popup_menu)
	}

	if overrides.PropertyNotifyEvent != nil {
		pclass.property_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_property_notify_event)
	}

	if overrides.ProximityInEvent != nil {
		pclass.proximity_in_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_proximity_in_event)
	}

	if overrides.ProximityOutEvent != nil {
		pclass.proximity_out_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_proximity_out_event)
	}

	if overrides.QueryTooltip != nil {
		pclass.query_tooltip = (*[0]byte)(C._gotk4_gtk3_WidgetClass_query_tooltip)
	}

	if overrides.QueueDrawRegion != nil {
		pclass.queue_draw_region = (*[0]byte)(C._gotk4_gtk3_WidgetClass_queue_draw_region)
	}

	if overrides.Realize != nil {
		pclass.realize = (*[0]byte)(C._gotk4_gtk3_WidgetClass_realize)
	}

	if overrides.ScreenChanged != nil {
		pclass.screen_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_screen_changed)
	}

	if overrides.ScrollEvent != nil {
		pclass.scroll_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_scroll_event)
	}

	if overrides.SelectionClearEvent != nil {
		pclass.selection_clear_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_clear_event)
	}

	if overrides.SelectionGet != nil {
		pclass.selection_get = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_get)
	}

	if overrides.SelectionNotifyEvent != nil {
		pclass.selection_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_notify_event)
	}

	if overrides.SelectionReceived != nil {
		pclass.selection_received = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_received)
	}

	if overrides.SelectionRequestEvent != nil {
		pclass.selection_request_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_selection_request_event)
	}

	if overrides.Show != nil {
		pclass.show = (*[0]byte)(C._gotk4_gtk3_WidgetClass_show)
	}

	if overrides.ShowAll != nil {
		pclass.show_all = (*[0]byte)(C._gotk4_gtk3_WidgetClass_show_all)
	}

	if overrides.ShowHelp != nil {
		pclass.show_help = (*[0]byte)(C._gotk4_gtk3_WidgetClass_show_help)
	}

	if overrides.SizeAllocate != nil {
		pclass.size_allocate = (*[0]byte)(C._gotk4_gtk3_WidgetClass_size_allocate)
	}

	if overrides.StateChanged != nil {
		pclass.state_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_state_changed)
	}

	if overrides.StateFlagsChanged != nil {
		pclass.state_flags_changed = (*[0]byte)(C._gotk4_gtk3_WidgetClass_state_flags_changed)
	}

	if overrides.StyleSet != nil {
		pclass.style_set = (*[0]byte)(C._gotk4_gtk3_WidgetClass_style_set)
	}

	if overrides.StyleUpdated != nil {
		pclass.style_updated = (*[0]byte)(C._gotk4_gtk3_WidgetClass_style_updated)
	}

	if overrides.TouchEvent != nil {
		pclass.touch_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_touch_event)
	}

	if overrides.Unmap != nil {
		pclass.unmap = (*[0]byte)(C._gotk4_gtk3_WidgetClass_unmap)
	}

	if overrides.UnmapEvent != nil {
		pclass.unmap_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_unmap_event)
	}

	if overrides.Unrealize != nil {
		pclass.unrealize = (*[0]byte)(C._gotk4_gtk3_WidgetClass_unrealize)
	}

	if overrides.VisibilityNotifyEvent != nil {
		pclass.visibility_notify_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_visibility_notify_event)
	}

	if overrides.WindowStateEvent != nil {
		pclass.window_state_event = (*[0]byte)(C._gotk4_gtk3_WidgetClass_window_state_event)
	}

	if classInitFunc != nil {
		class := (*WidgetClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWidget(obj *coreglib.Object) *Widget {
	return &Widget{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		ImplementorIface: atk.ImplementorIface{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	return wrapWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (widget *Widget) baseWidget() *Widget {
	return widget
}

// BaseWidget returns the underlying base object.
func BaseWidget(obj Widgetter) *Widget {
	return obj.baseWidget()
}

func (widget *Widget) ConnectAccelClosuresChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "accel-closures-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectAccelClosuresChanged), f)
}

// ConnectButtonPressEvent signal will be emitted when a button (typically from
// a mouse) is pressed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_BUTTON_PRESS_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectButtonPressEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "button-press-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectButtonPressEvent), f)
}

// ConnectButtonReleaseEvent signal will be emitted when a button (typically
// from a mouse) is released.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_BUTTON_RELEASE_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectButtonReleaseEvent(f func(event *gdk.EventButton) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "button-release-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectButtonReleaseEvent), f)
}

// ConnectCanActivateAccel determines whether an accelerator that activates the
// signal identified by signal_id can currently be activated. This signal is
// present to allow applications and derived widgets to override the default
// Widget handling for determining whether an accelerator can be activated.
func (widget *Widget) ConnectCanActivateAccel(f func(signalId uint) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "can-activate-accel", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectCanActivateAccel), f)
}

// ConnectCompositedChanged signal is emitted when the composited status of
// widgets screen changes. See gdk_screen_is_composited().
func (widget *Widget) ConnectCompositedChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "composited-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectCompositedChanged), f)
}

// ConnectConfigureEvent signal will be emitted when the size, position or
// stacking of the widget's window has changed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectConfigureEvent(f func(event *gdk.EventConfigure) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "configure-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectConfigureEvent), f)
}

// ConnectDamageEvent is emitted when a redirected window belonging to widget
// gets drawn into. The region/area members of the event shows what area of the
// redirected drawable was drawn into.
func (widget *Widget) ConnectDamageEvent(f func(event *gdk.EventExpose) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "damage-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDamageEvent), f)
}

// ConnectDeleteEvent signal is emitted if a user requests that a toplevel
// window is closed. The default handler for this signal destroys the window.
// Connecting gtk_widget_hide_on_delete() to this signal will cause the window
// to be hidden instead, so that it can later be shown again without
// reconstructing it.
func (widget *Widget) ConnectDeleteEvent(f func(event *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "delete-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDeleteEvent), f)
}

// ConnectDestroy signals that all holders of a reference to the widget should
// release the reference that they hold. May result in finalization of the
// widget if all references are released.
//
// This signal is not suitable for saving widget state.
func (widget *Widget) ConnectDestroy(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "destroy", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDestroy), f)
}

// ConnectDestroyEvent signal is emitted when a Window is destroyed. You rarely
// get this signal, because most widgets disconnect themselves from their window
// before they destroy it, so no widget owns the window at destroy time.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectDestroyEvent(f func(event *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "destroy-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDestroyEvent), f)
}

// ConnectDirectionChanged signal is emitted when the text direction of a widget
// changes.
func (widget *Widget) ConnectDirectionChanged(f func(previousDirection TextDirection)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "direction-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDirectionChanged), f)
}

// ConnectDragBegin signal is emitted on the drag source when a drag is started.
// A typical reason to connect to this signal is to set up a custom drag icon
// with e.g. gtk_drag_source_set_icon_pixbuf().
//
// Note that some widgets set up a drag icon in the default handler of this
// signal, so you may have to use g_signal_connect_after() to override what the
// default handler did.
func (widget *Widget) ConnectDragBegin(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-begin", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragBegin), f)
}

// ConnectDragDataDelete signal is emitted on the drag source when a drag with
// the action GDK_ACTION_MOVE is successfully completed. The signal handler is
// responsible for deleting the data that has been dropped. What "delete" means
// depends on the context of the drag operation.
func (widget *Widget) ConnectDragDataDelete(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-data-delete", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataDelete), f)
}

// ConnectDragDataGet signal is emitted on the drag source when the drop site
// requests the data which is dragged. It is the responsibility of the signal
// handler to fill data with the data in the format which is indicated by info.
// See gtk_selection_data_set() and gtk_selection_data_set_text().
func (widget *Widget) ConnectDragDataGet(f func(context *gdk.DragContext, data *SelectionData, info, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-data-get", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataGet), f)
}

// ConnectDragDataReceived signal is emitted on the drop site when the dragged
// data has been received. If the data was received in order to determine
// whether the drop will be accepted, the handler is expected to call
// gdk_drag_status() and not finish the drag. If the data was received in
// response to a Widget::drag-drop signal (and this is the last target to be
// received), the handler for this signal is expected to process the received
// data and then call gtk_drag_finish(), setting the success parameter depending
// on whether the data was processed successfully.
//
// Applications must create some means to determine why the signal was emitted
// and therefore whether to call gdk_drag_status() or gtk_drag_finish().
//
// The handler may inspect the selected action with
// gdk_drag_context_get_selected_action() before calling gtk_drag_finish(), e.g.
// to implement GDK_ACTION_ASK as shown in the following example:
//
//    void
//    drag_data_received (GtkWidget          *widget,
//                        GdkDragContext     *context,
//                        gint                x,
//                        gint                y,
//                        GtkSelectionData   *data,
//                        guint               info,
//                        guint               time)
//    {
//      if ((data->length >= 0) && (data->format == 8))
//        {
//          GdkDragAction action;
//
//          // handle data here
//
//          action = gdk_drag_context_get_selected_action (context);
//          if (action == GDK_ACTION_ASK)
//            {
//              GtkWidget *dialog;
//              gint response;
//
//              dialog = gtk_message_dialog_new (NULL,
//                                               GTK_DIALOG_MODAL |
//                                               GTK_DIALOG_DESTROY_WITH_PARENT,
//                                               GTK_MESSAGE_INFO,
//                                               GTK_BUTTONS_YES_NO,
//                                               "Move the data ?\n");
//              response = gtk_dialog_run (GTK_DIALOG (dialog));
//              gtk_widget_destroy (dialog);
//
//              if (response == GTK_RESPONSE_YES)
//                action = GDK_ACTION_MOVE;
//              else
//                action = GDK_ACTION_COPY;
//             }
//
//          gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
//        }
//      else
//        gtk_drag_finish (context, FALSE, FALSE, time);
//     }.
func (widget *Widget) ConnectDragDataReceived(f func(context *gdk.DragContext, x, y int, data *SelectionData, info, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-data-received", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDataReceived), f)
}

// ConnectDragDrop signal is emitted on the drop site when the user drops the
// data onto the widget. The signal handler must determine whether the cursor
// position is in a drop zone or not. If it is not in a drop zone, it returns
// FALSE and no further processing is necessary. Otherwise, the handler returns
// TRUE. In this case, the handler must ensure that gtk_drag_finish() is called
// to let the source know that the drop is done. The call to gtk_drag_finish()
// can be done either directly or in a Widget::drag-data-received handler which
// gets triggered by calling gtk_drag_get_data() to receive the data for one or
// more of the supported targets.
func (widget *Widget) ConnectDragDrop(f func(context *gdk.DragContext, x, y int, time uint) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-drop", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragDrop), f)
}

// ConnectDragEnd signal is emitted on the drag source when a drag is finished.
// A typical reason to connect to this signal is to undo things done in
// Widget::drag-begin.
func (widget *Widget) ConnectDragEnd(f func(context *gdk.DragContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-end", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragEnd), f)
}

// ConnectDragFailed signal is emitted on the drag source when a drag has
// failed. The signal handler may hook custom code to handle a failed DnD
// operation based on the type of error, it returns TRUE is the failure has been
// already handled (not showing the default "drag operation failed" animation),
// otherwise it returns FALSE.
func (widget *Widget) ConnectDragFailed(f func(context *gdk.DragContext, result DragResult) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-failed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragFailed), f)
}

// ConnectDragLeave signal is emitted on the drop site when the cursor leaves
// the widget. A typical reason to connect to this signal is to undo things done
// in Widget::drag-motion, e.g. undo highlighting with gtk_drag_unhighlight().
//
//    Likewise, the Widget::drag-leave signal is also emitted before the ::drag-drop signal, for instance to allow cleaning up of a preview item created in the Widget::drag-motion signal handler.
func (widget *Widget) ConnectDragLeave(f func(context *gdk.DragContext, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-leave", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragLeave), f)
}

// ConnectDragMotion signal is emitted on the drop site when the user moves the
// cursor over the widget during a drag. The signal handler must determine
// whether the cursor position is in a drop zone or not. If it is not in a drop
// zone, it returns FALSE and no further processing is necessary. Otherwise, the
// handler returns TRUE. In this case, the handler is responsible for providing
// the necessary information for displaying feedback to the user, by calling
// gdk_drag_status().
//
// If the decision whether the drop will be accepted or rejected can't be made
// based solely on the cursor position and the type of the data, the handler may
// inspect the dragged data by calling gtk_drag_get_data() and defer the
// gdk_drag_status() call to the Widget::drag-data-received handler. Note that
// you must pass K_DEST_DEFAULT_DROP, K_DEST_DEFAULT_MOTION or
// K_DEST_DEFAULT_ALL to gtk_drag_dest_set() when using the drag-motion signal
// that way.
//
// Also note that there is no drag-enter signal. The drag receiver has to keep
// track of whether he has received any drag-motion signals since the last
// Widget::drag-leave and if not, treat the drag-motion signal as an "enter"
// signal. Upon an "enter", the handler will typically highlight the drop site
// with gtk_drag_highlight().
//
//    static void
//    drag_motion (GtkWidget      *widget,
//                 GdkDragContext *context,
//                 gint            x,
//                 gint            y,
//                 guint           time)
//    {
//      GdkAtom target;
//
//      PrivateData *private_data = GET_PRIVATE_DATA (widget);
//
//      if (!private_data->drag_highlight)
//       {
//         private_data->drag_highlight = 1;
//         gtk_drag_highlight (widget);
//       }
//
//      target = gtk_drag_dest_find_target (widget, context, NULL);
//      if (target == GDK_NONE)
//        gdk_drag_status (context, 0, time);
//      else
//       {
//         private_data->pending_status
//            = gdk_drag_context_get_suggested_action (context);
//         gtk_drag_get_data (widget, context, target, time);
//       }
//
//      return TRUE;
//    }
//
//    static void
//    drag_data_received (GtkWidget        *widget,
//                        GdkDragContext   *context,
//                        gint              x,
//                        gint              y,
//                        GtkSelectionData *selection_data,
//                        guint             info,
//                        guint             time)
//    {
//      PrivateData *private_data = GET_PRIVATE_DATA (widget);
//
//      if (private_data->suggested_action)
//       {
//         private_data->suggested_action = 0;
//
//         // We are getting this data due to a request in drag_motion,
//         // rather than due to a request in drag_drop, so we are just
//         // supposed to call gdk_drag_status(), not actually paste in
//         // the data.
//
//         str = gtk_selection_data_get_text (selection_data);
//         if (!data_is_acceptable (str))
//           gdk_drag_status (context, 0, time);
//         else
//           gdk_drag_status (context,
//                            private_data->suggested_action,
//                            time);
//       }
//      else
//       {
//         // accept the drop
//       }
//    }.
func (widget *Widget) ConnectDragMotion(f func(context *gdk.DragContext, x, y int, time uint) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "drag-motion", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDragMotion), f)
}

// ConnectDraw: this signal is emitted when a widget is supposed to render
// itself. The widget's top left corner must be painted at the origin of the
// passed in context and be sized to the values returned by
// gtk_widget_get_allocated_width() and gtk_widget_get_allocated_height().
//
// Signal handlers connected to this signal can modify the cairo context passed
// as cr in any way they like and don't need to restore it. The signal emission
// takes care of calling cairo_save() before and cairo_restore() after invoking
// the handler.
//
// The signal handler will get a cr with a clip region already set to the
// widget's dirty region, i.e. to the area that needs repainting. Complicated
// widgets that want to avoid redrawing themselves completely can get the full
// extents of the clip region with gdk_cairo_get_clip_rectangle(), or they can
// get a finer-grained representation of the dirty region with
// cairo_copy_clip_rectangle_list().
func (widget *Widget) ConnectDraw(f func(cr *cairo.Context) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "draw", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectDraw), f)
}

// ConnectEnterNotifyEvent will be emitted when the pointer enters the widget's
// window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_ENTER_NOTIFY_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectEnterNotifyEvent(f func(event *gdk.EventCrossing) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "enter-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectEnterNotifyEvent), f)
}

// ConnectEvent: GTK+ main loop will emit three signals for each GDK event
// delivered to a widget: one generic ::event signal, another, more specific,
// signal that matches the type of event delivered (e.g.
// Widget::key-press-event) and finally a generic Widget::event-after signal.
func (widget *Widget) ConnectEvent(f func(event *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectEvent), f)
}

// ConnectEventAfter: after the emission of the Widget::event signal and
// (optionally) the second more specific signal, ::event-after will be emitted
// regardless of the previous two signals handlers return values.
func (widget *Widget) ConnectEventAfter(f func(event *gdk.Event)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "event-after", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectEventAfter), f)
}

func (widget *Widget) ConnectFocus(f func(direction DirectionType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "focus", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectFocus), f)
}

// ConnectFocusInEvent signal will be emitted when the keyboard focus enters the
// widget's window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_FOCUS_CHANGE_MASK mask.
func (widget *Widget) ConnectFocusInEvent(f func(event *gdk.EventFocus) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "focus-in-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectFocusInEvent), f)
}

// ConnectFocusOutEvent signal will be emitted when the keyboard focus leaves
// the widget's window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_FOCUS_CHANGE_MASK mask.
func (widget *Widget) ConnectFocusOutEvent(f func(event *gdk.EventFocus) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "focus-out-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectFocusOutEvent), f)
}

// ConnectGrabBrokenEvent is emitted when a pointer or keyboard grab on a window
// belonging to widget gets broken.
//
// On X11, this happens when the grab window becomes unviewable (i.e. it or one
// of its ancestors is unmapped), or if the same application grabs the pointer
// or keyboard again.
func (widget *Widget) ConnectGrabBrokenEvent(f func(event *gdk.EventGrabBroken) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "grab-broken-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabBrokenEvent), f)
}

func (widget *Widget) ConnectGrabFocus(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "grab-focus", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabFocus), f)
}

// ConnectGrabNotify signal is emitted when a widget becomes shadowed by a GTK+
// grab (not a pointer or keyboard grab) on another widget, or when it becomes
// unshadowed due to a grab being removed.
//
// A widget is shadowed by a gtk_grab_add() when the topmost grab widget in the
// grab stack of its window group is not its ancestor.
func (widget *Widget) ConnectGrabNotify(f func(wasGrabbed bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "grab-notify", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectGrabNotify), f)
}

// ConnectHide signal is emitted when widget is hidden, for example with
// gtk_widget_hide().
func (widget *Widget) ConnectHide(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "hide", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectHide), f)
}

// ConnectHierarchyChanged signal is emitted when the anchored state of a widget
// changes. A widget is “anchored” when its toplevel ancestor is a Window. This
// signal is emitted when a widget changes from un-anchored to anchored or
// vice-versa.
func (widget *Widget) ConnectHierarchyChanged(f func(previousToplevel Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "hierarchy-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectHierarchyChanged), f)
}

// ConnectKeyPressEvent signal is emitted when a key is pressed. The signal
// emission will reoccur at the key-repeat rate when the key is kept pressed.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_KEY_PRESS_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectKeyPressEvent(f func(event *gdk.EventKey) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "key-press-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectKeyPressEvent), f)
}

// ConnectKeyReleaseEvent signal is emitted when a key is released.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_KEY_RELEASE_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectKeyReleaseEvent(f func(event *gdk.EventKey) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "key-release-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectKeyReleaseEvent), f)
}

// ConnectKeynavFailed gets emitted if keyboard navigation fails. See
// gtk_widget_keynav_failed() for details.
func (widget *Widget) ConnectKeynavFailed(f func(direction DirectionType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "keynav-failed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectKeynavFailed), f)
}

// ConnectLeaveNotifyEvent will be emitted when the pointer leaves the widget's
// window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_LEAVE_NOTIFY_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectLeaveNotifyEvent(f func(event *gdk.EventCrossing) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "leave-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectLeaveNotifyEvent), f)
}

// ConnectMap signal is emitted when widget is going to be mapped, that is when
// the widget is visible (which is controlled with gtk_widget_set_visible()) and
// all its parents up to the toplevel widget are also visible. Once the map has
// occurred, Widget::map-event will be emitted.
//
// The ::map signal can be used to determine whether a widget will be drawn, for
// instance it can resume an animation that was stopped during the emission of
// Widget::unmap.
func (widget *Widget) ConnectMap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "map", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMap), f)
}

// ConnectMapEvent signal will be emitted when the widget's window is mapped. A
// window is mapped when it becomes visible on the screen.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectMapEvent(f func(event *gdk.EventAny) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "map-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMapEvent), f)
}

// ConnectMnemonicActivate: default handler for this signal activates widget if
// group_cycling is FALSE, or just makes widget grab focus if group_cycling is
// TRUE.
func (widget *Widget) ConnectMnemonicActivate(f func(groupCycling bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "mnemonic-activate", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMnemonicActivate), f)
}

// ConnectMotionNotifyEvent signal is emitted when the pointer moves over the
// widget's Window.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_POINTER_MOTION_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectMotionNotifyEvent(f func(event *gdk.EventMotion) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "motion-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMotionNotifyEvent), f)
}

func (widget *Widget) ConnectMoveFocus(f func(direction DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "move-focus", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectMoveFocus), f)
}

// ConnectParentSet signal is emitted when a new parent has been set on a
// widget.
func (widget *Widget) ConnectParentSet(f func(oldParent Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "parent-set", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectParentSet), f)
}

// ConnectPopupMenu: this signal gets emitted whenever a widget should pop up a
// context menu. This usually happens through the standard key binding
// mechanism; by pressing a certain key while a widget is focused, the user can
// cause the widget to pop up a menu. For example, the Entry widget creates a
// menu with clipboard commands. See the [Popup Menu Migration
// Checklist][checklist-popup-menu] for an example of how to use this signal.
func (widget *Widget) ConnectPopupMenu(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "popup-menu", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectPopupMenu), f)
}

// ConnectPropertyNotifyEvent signal will be emitted when a property on the
// widget's window has been changed or deleted.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_PROPERTY_CHANGE_MASK mask.
func (widget *Widget) ConnectPropertyNotifyEvent(f func(event *gdk.EventProperty) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "property-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectPropertyNotifyEvent), f)
}

// ConnectProximityInEvent: to receive this signal the Window associated to the
// widget needs to enable the K_PROXIMITY_IN_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectProximityInEvent(f func(event *gdk.EventProximity) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "proximity-in-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectProximityInEvent), f)
}

// ConnectProximityOutEvent: to receive this signal the Window associated to the
// widget needs to enable the K_PROXIMITY_OUT_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectProximityOutEvent(f func(event *gdk.EventProximity) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "proximity-out-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectProximityOutEvent), f)
}

// ConnectQueryTooltip is emitted when Widget:has-tooltip is TRUE and the hover
// timeout has expired with the cursor hovering "above" widget; or emitted when
// widget got focus in keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether a
// tooltip should be shown for widget. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
func (widget *Widget) ConnectQueryTooltip(f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectQueryTooltip), f)
}

// ConnectRealize signal is emitted when widget is associated with a Window,
// which means that gtk_widget_realize() has been called or the widget has been
// mapped (that is, it is going to be drawn).
func (widget *Widget) ConnectRealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "realize", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectRealize), f)
}

// ConnectScreenChanged signal gets emitted when the screen of a widget has
// changed.
func (widget *Widget) ConnectScreenChanged(f func(previousScreen *gdk.Screen)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "screen-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectScreenChanged), f)
}

// ConnectScrollEvent signal is emitted when a button in the 4 to 7 range is
// pressed. Wheel mice are usually configured to generate button press events
// for buttons 4 and 5 when the wheel is turned.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_SCROLL_MASK mask.
//
// This signal will be sent to the grab widget if there is one.
func (widget *Widget) ConnectScrollEvent(f func(event *gdk.EventScroll) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "scroll-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectScrollEvent), f)
}

// ConnectSelectionClearEvent signal will be emitted when the the widget's
// window has lost ownership of a selection.
func (widget *Widget) ConnectSelectionClearEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-clear-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionClearEvent), f)
}

func (widget *Widget) ConnectSelectionGet(f func(data *SelectionData, info, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-get", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionGet), f)
}

func (widget *Widget) ConnectSelectionNotifyEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionNotifyEvent), f)
}

func (widget *Widget) ConnectSelectionReceived(f func(data *SelectionData, time uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-received", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionReceived), f)
}

// ConnectSelectionRequestEvent signal will be emitted when another client
// requests ownership of the selection owned by the widget's window.
func (widget *Widget) ConnectSelectionRequestEvent(f func(event *gdk.EventSelection) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "selection-request-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSelectionRequestEvent), f)
}

// ConnectShow signal is emitted when widget is shown, for example with
// gtk_widget_show().
func (widget *Widget) ConnectShow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "show", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectShow), f)
}

func (widget *Widget) ConnectShowHelp(f func(helpType WidgetHelpType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "show-help", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectShowHelp), f)
}

func (widget *Widget) ConnectSizeAllocate(f func(allocation *Allocation)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "size-allocate", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectSizeAllocate), f)
}

// ConnectStateChanged signal is emitted when the widget state changes. See
// gtk_widget_get_state().
func (widget *Widget) ConnectStateChanged(f func(state StateType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "state-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStateChanged), f)
}

// ConnectStateFlagsChanged signal is emitted when the widget state changes, see
// gtk_widget_get_state_flags().
func (widget *Widget) ConnectStateFlagsChanged(f func(flags StateFlags)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "state-flags-changed", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStateFlagsChanged), f)
}

// ConnectStyleSet signal is emitted when a new style has been set on a widget.
// Note that style-modifying functions like gtk_widget_modify_base() also cause
// this signal to be emitted.
//
// Note that this signal is emitted for changes to the deprecated Style. To
// track changes to the StyleContext associated with a widget, use the
// Widget::style-updated signal.
func (widget *Widget) ConnectStyleSet(f func(previousStyle *Style)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "style-set", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStyleSet), f)
}

// ConnectStyleUpdated signal is a convenience signal that is emitted when the
// StyleContext::changed signal is emitted on the widget's associated
// StyleContext as returned by gtk_widget_get_style_context().
//
// Note that style-modifying functions like gtk_widget_override_color() also
// cause this signal to be emitted.
func (widget *Widget) ConnectStyleUpdated(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "style-updated", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectStyleUpdated), f)
}

func (widget *Widget) ConnectTouchEvent(f func(object *gdk.Event) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "touch-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectTouchEvent), f)
}

// ConnectUnmap signal is emitted when widget is going to be unmapped, which
// means that either it or any of its parents up to the toplevel widget have
// been set as hidden.
//
// As ::unmap indicates that a widget will not be shown any longer, it can be
// used to, for example, stop an animation on the widget.
func (widget *Widget) ConnectUnmap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unmap", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnmap), f)
}

// ConnectUnmapEvent signal will be emitted when the widget's window is
// unmapped. A window is unmapped when it becomes invisible on the screen.
//
// To receive this signal, the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectUnmapEvent(f func(event *gdk.EventAny) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unmap-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnmapEvent), f)
}

// ConnectUnrealize signal is emitted when the Window associated with widget is
// destroyed, which means that gtk_widget_unrealize() has been called or the
// widget has been unmapped (that is, it is going to be hidden).
func (widget *Widget) ConnectUnrealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unrealize", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectUnrealize), f)
}

// ConnectVisibilityNotifyEvent will be emitted when the widget's window is
// obscured or unobscured.
//
// To receive this signal the Window associated to the widget needs to enable
// the K_VISIBILITY_NOTIFY_MASK mask.
func (widget *Widget) ConnectVisibilityNotifyEvent(f func(event *gdk.EventVisibility) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "visibility-notify-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent), f)
}

// ConnectWindowStateEvent will be emitted when the state of the toplevel window
// associated to the widget changes.
//
// To receive this signal the Window associated to the widget needs to enable
// the K_STRUCTURE_MASK mask. GDK will enable this mask automatically for all
// new windows.
func (widget *Widget) ConnectWindowStateEvent(f func(event *gdk.EventWindowState) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "window-state-event", false, unsafe.Pointer(C._gotk4_gtk3_Widget_ConnectWindowStateEvent), f)
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them. Activation is what happens when you press Enter
// on a widget during key navigation. If widget isn't activatable, the function
// returns FALSE.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget was activatable.
//
func (widget *Widget) Activate() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_activate(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddAccelerator installs an accelerator for this widget in accel_group that
// causes accel_signal to be emitted if the accelerator is activated. The
// accel_group needs to be added to the widget’s toplevel via
// gtk_window_add_accel_group(), and the signal must be of type G_SIGNAL_ACTION.
// Accelerators added through this function are not user changeable during
// runtime. If you want to support accelerators that can be changed by the user,
// use gtk_accel_map_add_entry() and gtk_widget_set_accel_path() or
// gtk_menu_item_set_accel_path() instead.
//
// The function takes the following parameters:
//
//    - accelSignal: widget signal to emit on accelerator activation.
//    - accelGroup: accel group for this widget, added to its toplevel.
//    - accelKey: GDK keyval of the accelerator.
//    - accelMods: modifier key combination of the accelerator.
//    - accelFlags: flag accelerators, e.g. GTK_ACCEL_VISIBLE.
//
func (widget *Widget) AddAccelerator(accelSignal string, accelGroup *AccelGroup, accelKey uint, accelMods gdk.ModifierType, accelFlags AccelFlags) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GtkAccelGroup  // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _arg5 C.GtkAccelFlags   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accelSignal)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	_arg3 = C.guint(accelKey)
	_arg4 = C.GdkModifierType(accelMods)
	_arg5 = C.GtkAccelFlags(accelFlags)

	C.gtk_widget_add_accelerator(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(accelSignal)
	runtime.KeepAlive(accelGroup)
	runtime.KeepAlive(accelKey)
	runtime.KeepAlive(accelMods)
	runtime.KeepAlive(accelFlags)
}

// AddEvents adds the events in the bitfield events to the event mask for
// widget. See gtk_widget_set_events() and the [input handling
// overview][event-masks] for details.
//
// The function takes the following parameters:
//
//    - events: event mask, see EventMask.
//
func (widget *Widget) AddEvents(events int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(events)

	C.gtk_widget_add_events(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(events)
}

// ChildFocus: this function is used by custom widget implementations; if you're
// writing an app, you’d use gtk_widget_grab_focus() to move the focus to a
// particular widget, and gtk_container_set_focus_chain() to change the focus
// tab order. So you may want to investigate those functions instead.
//
// gtk_widget_child_focus() is called by containers as the user moves around the
// window using keyboard shortcuts. direction indicates what kind of motion is
// taking place (up, down, left, right, tab forward, tab backward).
// gtk_widget_child_focus() emits the Widget::focus signal; widgets override the
// default handler for this signal in order to implement appropriate focus
// behavior.
//
// The default ::focus handler for a widget should return TRUE if moving in
// direction left the focus on a focusable location inside that widget, and
// FALSE if moving in direction moved the focus outside the widget. If returning
// TRUE, widgets normally call gtk_widget_grab_focus() to place the focus
// accordingly; if returning FALSE, they don’t modify the current focus
// location.
//
// The function takes the following parameters:
//
//    - direction of focus movement.
//
// The function returns the following values:
//
//    - ok: TRUE if focus ended up inside widget.
//
func (widget *Widget) ChildFocus(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_widget_child_focus(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildNotify emits a Widget::child-notify signal for the [child
// property][child-properties] child_property on widget.
//
// This is the analogue of g_object_notify() for child properties.
//
// Also see gtk_container_child_notify().
//
// The function takes the following parameters:
//
//    - childProperty: name of a child property installed on the class of
//      widget’s parent.
//
func (widget *Widget) ChildNotify(childProperty string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(childProperty)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_child_notify(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(childProperty)
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible. Containers should check this, rather than looking at
// gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly set on
// the widget itself, or, if none has been explicitly set, the widget may expand
// if some of its children do.
//
// The function takes the following parameters:
//
//    - orientation: expand direction.
//
// The function returns the following values:
//
//    - ok: whether widget tree rooted here should be expanded.
//
func (widget *Widget) ComputeExpand(orientation Orientation) bool {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_widget_compute_expand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreatePangoContext creates a new Context with the appropriate font map, font
// options, font description, and base direction for drawing text for this
// widget. See also gtk_widget_get_pango_context().
//
// The function returns the following values:
//
//    - context: new Context.
//
func (widget *Widget) CreatePangoContext() *pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_create_pango_context(_arg0)
	runtime.KeepAlive(widget)

	var _context *pango.Context // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_context = &pango.Context{
			Object: obj,
		}
	}

	return _context
}

// CreatePangoLayout creates a new Layout with the appropriate font map, font
// description, and base direction for drawing text for this widget.
//
// If you keep a Layout created in this way around, you need to re-create it
// when the widget Context is replaced. This can be tracked by using the
// Widget::screen-changed signal on the widget.
//
// The function takes the following parameters:
//
//    - text (optional) to set on the layout (can be NULL).
//
// The function returns the following values:
//
//    - layout: new Layout.
//
func (widget *Widget) CreatePangoLayout(text string) *pango.Layout {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.gchar       // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if text != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_widget_create_pango_layout(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(text)

	var _layout *pango.Layout // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// Destroy destroys a widget.
//
// When a widget is destroyed all references it holds on other objects will be
// released:
//
//    - if the widget is inside a container, it will be removed from its
//    parent
//    - if the widget is a container, all its children will be destroyed,
//    recursively
//    - if the widget is a top level, it will be removed from the list
//    of top level widgets that GTK+ maintains internally
//
// It's expected that all references held on the widget will also be released;
// you should connect to the Widget::destroy signal if you hold a reference to
// widget and you wish to remove it when this function is called. It is not
// necessary to do so if you are implementing a Container, as you'll be able to
// use the ContainerClass.remove() virtual function for that.
//
// It's important to notice that gtk_widget_destroy() will only cause the widget
// to be finalized if no additional references, acquired using g_object_ref(),
// are held on it. In case additional references are in place, the widget will
// be in an "inert" state after calling this function; widget will still point
// to valid memory, allowing you to release the references you hold, but you may
// not query the widget's own state.
//
// You should typically call this function on top level widgets, and rarely on
// child widgets.
//
// See also: gtk_container_remove().
func (widget *Widget) Destroy() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_destroy(_arg0)
	runtime.KeepAlive(widget)
}

// Event: rarely-used function. This function is used to emit the event signals
// on a widget (those signals should never be emitted without using this
// function to do so). If you want to synthesize an event though, don’t use this
// function; instead, use gtk_main_do_event() so the event will behave as if it
// were in the event queue. Don’t synthesize expose events; instead, use
// gdk_window_invalidate_rect() to invalidate a region of the window.
//
// The function takes the following parameters:
//
//    - event: Event.
//
// The function returns the following values:
//
//    - ok: return from the event signal emission (TRUE if the event was
//      handled).
//
func (widget *Widget) Event(event *gdk.Event) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkEvent  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_widget_event(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FreezeChildNotify stops emission of Widget::child-notify signals on widget.
// The signals are queued until gtk_widget_thaw_child_notify() is called on
// widget.
//
// This is the analogue of g_object_freeze_notify() for child properties.
func (widget *Widget) FreezeChildNotify() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_freeze_child_notify(_arg0)
	runtime.KeepAlive(widget)
}

// Accessible returns the accessible object that describes the widget to an
// assistive technology.
//
// If accessibility support is not available, this Object instance may be a
// no-op. Likewise, if no class-specific Object implementation is available for
// the widget instance in question, it will inherit an Object implementation
// from the first ancestor class for which such an implementation is defined.
//
// The documentation of the ATK (http://developer.gnome.org/atk/stable/) library
// contains more information about accessible objects and their uses.
//
// The function returns the following values:
//
//    - object associated with widget.
//
func (widget *Widget) Accessible() *atk.AtkObject {
	var _arg0 *C.GtkWidget // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_accessible(_arg0)
	runtime.KeepAlive(widget)

	var _object *atk.AtkObject // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_object = &atk.AtkObject{
			Object: obj,
		}
	}

	return _object
}

// AllocatedHeight returns the height that has currently been allocated to
// widget. This function is intended to be used when implementing handlers for
// the Widget::draw function.
//
// The function returns the following values:
//
//    - gint: height of the widget.
//
func (widget *Widget) AllocatedHeight() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_height(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AllocatedWidth returns the width that has currently been allocated to widget.
// This function is intended to be used when implementing handlers for the
// Widget::draw function.
//
// The function returns the following values:
//
//    - gint: width of the widget.
//
func (widget *Widget) AllocatedWidth() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_width(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Ancestor gets the first ancestor of widget with type widget_type. For
// example, gtk_widget_get_ancestor (widget, GTK_TYPE_BOX) gets the first Box
// that’s an ancestor of widget. No reference will be added to the returned
// widget; it should not be unreferenced. See note about checking for a toplevel
// Window in the docs for gtk_widget_get_toplevel().
//
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers widget to be an ancestor of itself.
//
// The function takes the following parameters:
//
//    - widgetType: ancestor type.
//
// The function returns the following values:
//
//    - ret (optional): ancestor widget, or NULL if not found.
//
func (widget *Widget) Ancestor(widgetType coreglib.Type) Widgetter {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GType(widgetType)

	_cret = C.gtk_widget_get_ancestor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(widgetType)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// ChildRequisition: this function is only for use in widget implementations.
// Obtains widget->requisition, unless someone has forced a particular geometry
// on the widget (e.g. with gtk_widget_set_size_request()), in which case it
// returns that geometry instead of the widget's requisition.
//
// This function differs from gtk_widget_size_request() in that it retrieves the
// last size request value from widget->requisition, while
// gtk_widget_size_request() actually calls the "size_request" method on widget
// to compute the size request and fill in widget->requisition, and only then
// returns widget->requisition.
//
// Because this function does not call the “size_request” method, it can only be
// used when you know that widget->requisition is up-to-date, that is,
// gtk_widget_size_request() has been called since the last time a resize was
// queued. In general, only container implementations have this information;
// applications should use gtk_widget_size_request().
//
// Deprecated: Use gtk_widget_get_preferred_size() instead.
//
// The function returns the following values:
//
//    - requisition to be filled in.
//
func (widget *Widget) ChildRequisition() *Requisition {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_child_requisition(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _requisition
}

// ChildVisible gets the value set with gtk_widget_set_child_visible(). If you
// feel a need to use this function, your code probably needs reorganization.
//
// This function is only useful for container implementations and never should
// be called by an application.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is mapped with the parent.
//
func (widget *Widget) ChildVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_child_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CompositeName obtains the composite name of a widget.
//
// Deprecated: Use gtk_widget_class_set_template(), or don’t use this API at
// all.
//
// The function returns the following values:
//
//    - utf8: composite name of widget, or NULL if widget is not a composite
//      child. The string should be freed when it is no longer needed.
//
func (widget *Widget) CompositeName() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_composite_name(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Direction gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
//
// The function returns the following values:
//
//    - textDirection: reading direction for the widget.
//
func (widget *Widget) Direction() TextDirection {
	var _arg0 *C.GtkWidget       // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_direction(_arg0)
	runtime.KeepAlive(widget)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// Events returns the event mask (see EventMask) for the widget. These are the
// events that the widget will receive.
//
// Note: Internally, the widget event mask will be the logical OR of the event
// mask set through gtk_widget_set_events() or gtk_widget_add_events(), and the
// event mask necessary to cater for every EventController created for the
// widget.
//
// The function returns the following values:
//
//    - gint: event mask for widget.
//
func (widget *Widget) Events() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_events(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// HAlign gets the value of the Widget:halign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
//
// The function returns the following values:
//
//    - align: horizontal alignment of widget.
//
func (widget *Widget) HAlign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_halign(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// HExpand gets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or document
// in your window would often be set to expand.
//
// Containers should use gtk_widget_compute_expand() rather than this function,
// to see whether a widget, or any of its children, has the expand flag set. If
// any child of a widget wants to expand, the parent may ask to expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
//
// The function returns the following values:
//
//    - ok: whether hexpand flag is set.
//
func (widget *Widget) HExpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_hexpand(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HExpandSet gets whether gtk_widget_set_hexpand() has been used to explicitly
// set the expand flag on this widget.
//
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
//
// The function returns the following values:
//
//    - ok: whether hexpand has been explicitly set.
//
func (widget *Widget) HExpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_hexpand_set(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
//
// The function returns the following values:
//
//    - utf8: name of the widget. This string is owned by GTK+ and should not be
//      modified or freed.
//
func (widget *Widget) Name() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_name(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PangoContext gets a Context with the appropriate font map, font description,
// and base direction for this widget. Unlike the context returned by
// gtk_widget_create_pango_context(), this context is owned by the widget (it
// can be used until the screen for the widget changes or the widget is removed
// from its toplevel), and will be updated to match any changes to the widget’s
// attributes. This can be tracked by using the Widget::screen-changed signal on
// the widget.
//
// The function returns the following values:
//
//    - context for the widget.
//
func (widget *Widget) PangoContext() *pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_pango_context(_arg0)
	runtime.KeepAlive(widget)

	var _context *pango.Context // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_context = &pango.Context{
			Object: obj,
		}
	}

	return _context
}

// Parent returns the parent container of widget.
//
// The function returns the following values:
//
//    - ret (optional): parent container of widget, or NULL.
//
func (widget *Widget) Parent() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_parent(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// ParentWindow gets widget’s parent window, or NULL if it does not have one.
//
// The function returns the following values:
//
//    - window (optional): parent window of widget, or NULL if it does not have a
//      parent window.
//
func (widget *Widget) ParentWindow() gdk.Windower {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkWindow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_parent_window(_arg0)
	runtime.KeepAlive(widget)

	var _window gdk.Windower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Windower)
				return ok
			})
			rv, ok := casted.(gdk.Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _window
}

// GetPath returns the WidgetPath representing widget, if the widget is not
// connected to a toplevel widget, a partial path will be created.
//
// The function returns the following values:
//
//    - widgetPath representing widget.
//
func (widget *Widget) GetPath() *WidgetPath {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_path(_arg0)
	runtime.KeepAlive(widget)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_widget_path_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_widget_path_unref((*C.GtkWidgetPath)(intern.C))
		},
	)

	return _widgetPath
}

// Pointer obtains the location of the mouse pointer in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are defined as
// widget->window coordinates for widgets that return TRUE for
// gtk_widget_get_has_window(); and are relative to widget->allocation.x,
// widget->allocation.y otherwise.
//
// Deprecated: Use gdk_window_get_device_position() instead.
//
// The function returns the following values:
//
//    - x (optional): return location for the X coordinate, or NULL.
//    - y (optional): return location for the Y coordinate, or NULL.
//
func (widget *Widget) Pointer() (x, y int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_pointer(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// Settings gets the settings object holding the settings used for this widget.
//
// Note that this function can only be called when the Widget is attached to a
// toplevel, since the settings object is specific to a particular Screen.
//
// The function returns the following values:
//
//    - settings: relevant Settings object.
//
func (widget *Widget) Settings() *Settings {
	var _arg0 *C.GtkWidget   // out
	var _cret *C.GtkSettings // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_settings(_arg0)
	runtime.KeepAlive(widget)

	var _settings *Settings // out

	_settings = wrapSettings(coreglib.Take(unsafe.Pointer(_cret)))

	return _settings
}

// GetSizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request(). A value of -1 stored in width or height
// indicates that that dimension has not been set explicitly and the natural
// requisition of the widget will be used instead. See
// gtk_widget_set_size_request(). To get the size a widget will actually
// request, call gtk_widget_get_preferred_size() instead of this function.
//
// The function returns the following values:
//
//    - width (optional): return location for width, or NULL.
//    - height (optional): return location for height, or NULL.
//
func (widget *Widget) GetSizeRequest() (width, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_size_request(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// StyleContext returns the style context associated to widget. The returned
// object is guaranteed to be the same for the lifetime of widget.
//
// The function returns the following values:
//
//    - styleContext This memory is owned by widget and must not be freed.
//
func (widget *Widget) StyleContext() *StyleContext {
	var _arg0 *C.GtkWidget       // out
	var _cret *C.GtkStyleContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_style_context(_arg0)
	runtime.KeepAlive(widget)

	var _styleContext *StyleContext // out

	_styleContext = wrapStyleContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _styleContext
}

// SupportMultidevice returns TRUE if widget is multiple pointer aware. See
// gtk_widget_set_support_multidevice() for more information.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is multidevice aware.
//
func (widget *Widget) SupportMultidevice() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_support_multidevice(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TemplateChild: fetch an object build from the template XML for widget_type in
// this widget instance.
//
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its variants.
//
// This function is only meant to be called for code which is private to the
// widget_type which declared the child and is meant for language bindings which
// cannot easily make use of the GObject structure offsets.
//
// The function takes the following parameters:
//
//    - widgetType to get a template child for.
//    - name: “id” of the child defined in the template XML.
//
// The function returns the following values:
//
//    - object built in the template XML with the id name.
//
func (widget *Widget) TemplateChild(widgetType coreglib.Type, name string) *coreglib.Object {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _arg2 *C.gchar     // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GType(widgetType)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_get_template_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(widgetType)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// Toplevel: this function returns the topmost widget in the container hierarchy
// widget is a part of. If widget has no parent widgets, it will be returned as
// the topmost widget. No reference will be added to the returned widget; it
// should not be unreferenced.
//
// Note the difference in behavior vs. gtk_widget_get_ancestor();
// gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW) would return NULL if widget
// wasn’t inside a toplevel window, and if the window was inside a
// Window-derived widget which was in turn inside the toplevel Window. While the
// second case may seem unlikely, it actually happens when a Plug is embedded
// inside a Socket within the same application.
//
// To reliably find the toplevel Window, use gtk_widget_get_toplevel() and call
// GTK_IS_WINDOW() on the result. For instance, to get the title of a widget's
// toplevel window, one might use:
//
//    static const char *
//    get_widget_toplevel_title (GtkWidget *widget)
//    {
//      GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
//      if (GTK_IS_WINDOW (toplevel))
//        {
//          return gtk_window_get_title (GTK_WINDOW (toplevel));
//        }
//
//      return NULL;
//    }.
//
// The function returns the following values:
//
//    - ret: topmost ancestor of widget, or widget itself if there’s no ancestor.
//
func (widget *Widget) Toplevel() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_toplevel(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_ret = rv
	}

	return _ret
}

// VAlign gets the value of the Widget:valign property.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL. If your
// widget want to support baseline aligned children it must use
// gtk_widget_get_valign_with_baseline(), or g_object_get (widget, "valign",
// &value, NULL), which will also report the true value.
//
// The function returns the following values:
//
//    - align: vertical alignment of widget, ignoring baseline alignment.
//
func (widget *Widget) VAlign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_valign(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// VExpand gets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_get_hexpand() for more detail.
//
// The function returns the following values:
//
//    - ok: whether vexpand flag is set.
//
func (widget *Widget) VExpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_vexpand(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VExpandSet gets whether gtk_widget_set_vexpand() has been used to explicitly
// set the expand flag on this widget.
//
// See gtk_widget_get_hexpand_set() for more detail.
//
// The function returns the following values:
//
//    - ok: whether vexpand has been explicitly set.
//
func (widget *Widget) VExpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_vexpand_set(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visual gets the visual that will be used to render widget.
//
// The function returns the following values:
//
//    - visual for widget.
//
func (widget *Widget) Visual() *gdk.Visual {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkVisual // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_visual(_arg0)
	runtime.KeepAlive(widget)

	var _visual *gdk.Visual // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_visual = &gdk.Visual{
			Object: obj,
		}
	}

	return _visual
}

// GrabDefault causes widget to become the default widget. widget must be able
// to be a default widget; typically you would ensure this yourself by calling
// gtk_widget_set_can_default() with a TRUE value. The default widget is
// activated when the user presses Enter in a window. Default widgets must be
// activatable, that is, gtk_widget_activate() should affect them. Note that
// Entry widgets require the “activates-default” property set to TRUE before
// they activate the default widget when Enter is pressed and the Entry is
// focused.
func (widget *Widget) GrabDefault() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_grab_default(_arg0)
	runtime.KeepAlive(widget)
}

// GrabFocus causes widget to have the keyboard focus for the Window it's
// inside. widget must be a focusable widget, such as a Entry; something like
// Frame won’t work.
//
// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
// gtk_widget_set_can_focus() to modify that flag.
//
// The widget also needs to be realized and mapped. This is indicated by the
// related signals. Grabbing the focus immediately after creating the widget
// will likely fail and cause critical warnings.
func (widget *Widget) GrabFocus() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_grab_focus(_arg0)
	runtime.KeepAlive(widget)
}

// Hide reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
func (widget *Widget) Hide() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_hide(_arg0)
	runtime.KeepAlive(widget)
}

// HideOnDelete: utility function; intended to be connected to the
// Widget::delete-event signal on a Window. The function calls gtk_widget_hide()
// on its argument, then returns TRUE. If connected to ::delete-event, the
// result is that clicking the close button for a window (on the window frame,
// top right corner usually) will hide but not destroy the window. By default,
// GTK+ destroys windows when ::delete-event is received.
//
// The function returns the following values:
//
//    - ok: TRUE.
//
func (widget *Widget) HideOnDelete() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_hide_on_delete(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InDestruction returns whether the widget is currently being destroyed. This
// information can sometimes be used to avoid doing unnecessary work.
//
// The function returns the following values:
//
//    - ok: TRUE if widget is being destroyed.
//
func (widget *Widget) InDestruction() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_in_destruction(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Intersect computes the intersection of a widget’s area and area, storing the
// intersection in intersection, and returns TRUE if there was an intersection.
// intersection may be NULL if you’re only interested in whether there was an
// intersection.
//
// The function takes the following parameters:
//
//    - area: rectangle.
//
// The function returns the following values:
//
//    - intersection (optional): rectangle to store intersection of widget and
//      area.
//    - ok: TRUE if there was an intersection.
//
func (widget *Widget) Intersect(area *gdk.Rectangle) (*gdk.Rectangle, bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.GdkRectangle // out
	var _arg2 C.GdkRectangle  // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))

	_cret = C.gtk_widget_intersect(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(area)

	var _intersection *gdk.Rectangle // out
	var _ok bool                     // out

	_intersection = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _intersection, _ok
}

// IsAncestor determines whether widget is somewhere inside ancestor, possibly
// with intermediate containers.
//
// The function takes the following parameters:
//
//    - ancestor: another Widget.
//
// The function returns the following values:
//
//    - ok: TRUE if ancestor contains widget as a child, grandchild, great
//      grandchild, etc.
//
func (widget *Widget) IsAncestor(ancestor Widgetter) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(ancestor).Native()))

	_cret = C.gtk_widget_is_ancestor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocus determines if the widget is the focus widget within its toplevel.
// (This does not mean that the Widget:has-focus property is necessarily set;
// Widget:has-focus will only be set if the toplevel widget additionally has the
// global input focus.).
//
// The function returns the following values:
//
//    - ok: TRUE if the widget is the focus widget.
//
func (widget *Widget) IsFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Map: this function is only for use in widget implementations. Causes a widget
// to be mapped if it isn’t already.
func (widget *Widget) Map() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_map(_arg0)
	runtime.KeepAlive(widget)
}

// MnemonicActivate emits the Widget::mnemonic-activate signal.
//
// The function takes the following parameters:
//
//    - groupCycling: TRUE if there are other widgets with the same mnemonic.
//
// The function returns the following values:
//
//    - ok: TRUE if the signal has been handled.
//
func (widget *Widget) MnemonicActivate(groupCycling bool) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_widget_mnemonic_activate(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(groupCycling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// QueueComputeExpand: mark widget as needing to recompute its expand flags.
// Call this function when setting legacy expand child properties on the child
// of a container.
//
// See gtk_widget_compute_expand().
func (widget *Widget) QueueComputeExpand() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_compute_expand(_arg0)
	runtime.KeepAlive(widget)
}

// QueueDraw: equivalent to calling gtk_widget_queue_draw_area() for the entire
// area of a widget.
func (widget *Widget) QueueDraw() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_draw(_arg0)
	runtime.KeepAlive(widget)
}

// QueueDrawArea: convenience function that calls gtk_widget_queue_draw_region()
// on the region created from the given coordinates.
//
// The region here is specified in widget coordinates. Widget coordinates are a
// bit odd; for historical reasons, they are defined as widget->window
// coordinates for widgets that return TRUE for gtk_widget_get_has_window(), and
// are relative to widget->allocation.x, widget->allocation.y otherwise.
//
// width or height may be 0, in this case this function does nothing. Negative
// values for width and height are not allowed.
//
// The function takes the following parameters:
//
//    - x coordinate of upper-left corner of rectangle to redraw.
//    - y coordinate of upper-left corner of rectangle to redraw.
//    - width of region to draw.
//    - height of region to draw.
//
func (widget *Widget) QueueDrawArea(x, y, width, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	_arg3 = C.gint(width)
	_arg4 = C.gint(height)

	C.gtk_widget_queue_draw_area(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// QueueResize: this function is only for use in widget implementations. Flags a
// widget to have its size renegotiated; should be called when a widget for some
// reason has a new size request. For example, when you change the text in a
// Label, Label queues a resize to ensure there’s enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from inside
// its implementation of the GtkWidgetClass::size_allocate virtual method. Calls
// to gtk_widget_queue_resize() from inside GtkWidgetClass::size_allocate will
// be silently ignored.
func (widget *Widget) QueueResize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_resize(_arg0)
	runtime.KeepAlive(widget)
}

// Realize creates the GDK (windowing system) resources associated with a
// widget. For example, widget->window will be created when a widget is
// realized. Normally realization happens implicitly; if you show a widget and
// all its parent containers, then the widget will be realized and mapped
// automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling gtk_widget_realize() realizes the widget’s parents in addition to
// widget itself. If a widget is not yet inside a toplevel window when you
// realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as Widget::draw. Or simply g_signal_connect ()
// to the Widget::realize signal.
func (widget *Widget) Realize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_realize(_arg0)
	runtime.KeepAlive(widget)
}

// RegionIntersect computes the intersection of a widget’s area and region,
// returning the intersection. The result may be empty, use
// cairo_region_is_empty() to check.
//
// Deprecated: Use gtk_widget_get_allocation() and
// cairo_region_intersect_rectangle() to get the same behavior.
//
// The function takes the following parameters:
//
//    - region in the same coordinate system as widget->allocation. That is,
//      relative to widget->window for widgets which return FALSE from
//      gtk_widget_get_has_window(); relative to the parent window of
//      widget->window otherwise.
//
// The function returns the following values:
//
//    - ret: newly allocated region holding the intersection of widget and
//      region.
//
func (widget *Widget) RegionIntersect(region *cairo.Region) *cairo.Region {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out
	var _cret *C.cairo_region_t // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	_cret = C.gtk_widget_region_intersect(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)

	var _ret *cairo.Region // out

	{
		_pp := &struct{ p unsafe.Pointer }{unsafe.Pointer(_cret)}
		_ret = (*cairo.Region)(unsafe.Pointer(_pp))
	}
	runtime.SetFinalizer(_ret, func(v *cairo.Region) {
		C.cairo_region_destroy((*C.cairo_region_t)(unsafe.Pointer(v.Native())))
	})

	return _ret
}

// RemoveAccelerator removes an accelerator from widget, previously installed
// with gtk_widget_add_accelerator().
//
// The function takes the following parameters:
//
//    - accelGroup: accel group for this widget.
//    - accelKey: GDK keyval of the accelerator.
//    - accelMods: modifier key combination of the accelerator.
//
// The function returns the following values:
//
//    - ok: whether an accelerator was installed and could be removed.
//
func (widget *Widget) RemoveAccelerator(accelGroup *AccelGroup, accelKey uint, accelMods gdk.ModifierType) bool {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GtkAccelGroup  // out
	var _arg2 C.guint           // out
	var _arg3 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	_arg2 = C.guint(accelKey)
	_arg3 = C.GdkModifierType(accelMods)

	_cret = C.gtk_widget_remove_accelerator(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(accelGroup)
	runtime.KeepAlive(accelKey)
	runtime.KeepAlive(accelMods)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reparent moves a widget from one Container to another, handling reference
// count issues to avoid destroying the widget.
//
// Deprecated: Use gtk_container_remove() and gtk_container_add().
//
// The function takes the following parameters:
//
//    - newParent to move the widget into.
//
func (widget *Widget) Reparent(newParent Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(newParent).Native()))

	C.gtk_widget_reparent(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(newParent)
}

// SendExpose: very rarely-used function. This function is used to emit an
// expose event on a widget. This function is not normally used directly. The
// only time it is used is when propagating an expose event to a windowless
// child widget (gtk_widget_get_has_window() is FALSE), and that is normally
// done using gtk_container_propagate_draw().
//
// If you want to force an area of a window to be redrawn, use
// gdk_window_invalidate_rect() or gdk_window_invalidate_region(). To cause the
// redraw to be done immediately, follow that call with a call to
// gdk_window_process_updates().
//
// Deprecated: Application and widget code should not handle expose events
// directly; invalidation should use the Widget API, and drawing should only
// happen inside Widget::draw implementations.
//
// The function takes the following parameters:
//
//    - event: expose Event.
//
// The function returns the following values:
//
//    - gint: return from the event signal emission (TRUE if the event was
//      handled).
//
func (widget *Widget) SendExpose(event *gdk.Event) int {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkEvent  // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_widget_send_expose(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SetAccelPath: given an accelerator group, accel_group, and an accelerator
// path, accel_path, sets up an accelerator in accel_group so whenever the key
// binding that is defined for accel_path is pressed, widget will be activated.
// This removes any accelerators (for any accelerator group) installed by
// previous calls to gtk_widget_set_accel_path(). Associating accelerators with
// paths allows them to be modified by the user and the modifications to be
// saved for future use. (See gtk_accel_map_save().)
//
// This function is a low level function that would most likely be used by a
// menu creation system like UIManager. If you use UIManager, setting up
// accelerator paths will be done automatically.
//
// Even when you you aren’t using UIManager, if you only want to set up
// accelerators on menu items gtk_menu_item_set_accel_path() provides a somewhat
// more convenient interface.
//
// Note that accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
//
// The function takes the following parameters:
//
//    - accelPath (optional): path used to look up the accelerator.
//    - accelGroup (optional): AccelGroup.
//
func (widget *Widget) SetAccelPath(accelPath string, accelGroup *AccelGroup) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if accelPath != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accelPath)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if accelGroup != nil {
		_arg2 = (*C.GtkAccelGroup)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	}

	C.gtk_widget_set_accel_path(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(accelPath)
	runtime.KeepAlive(accelGroup)
}

// SetAppPaintable sets whether the application intends to draw on the widget in
// an Widget::draw handler.
//
// This is a hint to the widget and does not affect the behavior of the GTK+
// core; many widgets ignore this flag entirely. For widgets that do pay
// attention to the flag, such as EventBox and Window, the effect is to suppress
// default themed drawing of the widget's background. (Children of the widget
// will still be drawn.) The application is then entirely responsible for
// drawing the widget background.
//
// Note that the background is still drawn when the widget is mapped.
//
// The function takes the following parameters:
//
//    - appPaintable: TRUE if the application will paint on the widget.
//
func (widget *Widget) SetAppPaintable(appPaintable bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if appPaintable {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_app_paintable(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(appPaintable)
}

// SetChildVisible sets whether widget should be mapped along with its when its
// parent is mapped and widget has been shown with gtk_widget_show().
//
// The child visibility can be set for widget before it is added to a container
// with gtk_widget_set_parent(), to avoid mapping children unnecessary before
// immediately unmapping them. However it will be reset to its default state of
// TRUE when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a resize
// on the widget. Most of the time, the size of a widget is computed from all
// visible children, whether or not they are mapped. If this is not the case,
// the container can queue a resize itself.
//
// This function is only useful for container implementations and never should
// be called by an application.
//
// The function takes the following parameters:
//
//    - isVisible: if TRUE, widget should be mapped along with its parent.
//
func (widget *Widget) SetChildVisible(isVisible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if isVisible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_child_visible(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(isVisible)
}

// SetCompositeName sets a widgets composite name. The widget must be a
// composite child of its parent; see gtk_widget_push_composite_child().
//
// Deprecated: Use gtk_widget_class_set_template(), or don’t use this API at
// all.
//
// The function takes the following parameters:
//
//    - name to set.
//
func (widget *Widget) SetCompositeName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_composite_name(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
}

// SetDirection sets the reading direction on a particular widget. This
// direction controls the primary direction for widgets containing text, and
// also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct localization
// into languages with right-to-left reading directions can be done. Generally,
// applications will let the default reading direction present, except for
// containers where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk_widget_set_default_direction() will be used.
//
// The function takes the following parameters:
//
//    - dir: new direction.
//
func (widget *Widget) SetDirection(dir TextDirection) {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkTextDirection(dir)

	C.gtk_widget_set_direction(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(dir)
}

// SetDoubleBuffered widgets are double buffered by default; you can use this
// function to turn off the buffering. “Double buffered” simply means that
// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are called
// automatically around expose events sent to the widget.
// gdk_window_begin_draw_frame() diverts all drawing to a widget's window to an
// offscreen buffer, and gdk_window_end_draw_frame() draws the buffer to the
// screen. The result is that users see the window update in one smooth step,
// and don’t see individual graphics primitives being rendered.
//
// In very simple terms, double buffered widgets don’t flicker, so you would
// only use this function to turn off double buffering if you had special needs
// and really knew what you were doing.
//
// Note: if you turn off double-buffering, you have to handle expose events,
// since even the clearing to the background color or pixmap will not happen
// automatically (as it is done in gdk_window_begin_draw_frame()).
//
// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
// then expose events for double-buffered widgets are culled into a single event
// to the toplevel GDK window. If you now unset double buffering, you will cause
// a separate rendering pass for every widget. This will likely cause rendering
// problems - in particular related to stacking - and usually increases
// rendering times significantly.
//
// Deprecated: This function does not work under non-X11 backends or with
// non-native windows. It should not be used in newly written code.
//
// The function takes the following parameters:
//
//    - doubleBuffered: TRUE to double-buffer a widget.
//
func (widget *Widget) SetDoubleBuffered(doubleBuffered bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if doubleBuffered {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_double_buffered(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(doubleBuffered)
}

// SetEvents sets the event mask (see EventMask) for a widget. The event mask
// determines which events a widget will receive. Keep in mind that different
// widgets have different default event masks, and by changing the event mask
// you may disrupt a widget’s functionality, so be careful. This function must
// be called while a widget is unrealized. Consider gtk_widget_add_events() for
// widgets that are already realized, or if you want to preserve the existing
// event mask. This function can’t be used with widgets that have no window.
// (See gtk_widget_get_has_window()). To get events on those widgets, place them
// inside a EventBox and receive events on the event box.
//
// The function takes the following parameters:
//
//    - events: event mask.
//
func (widget *Widget) SetEvents(events int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(events)

	C.gtk_widget_set_events(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(events)
}

// SetHAlign sets the horizontal alignment of widget. See the Widget:halign
// property.
//
// The function takes the following parameters:
//
//    - align: horizontal alignment.
//
func (widget *Widget) SetHAlign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkAlign(align)

	C.gtk_widget_set_halign(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(align)
}

// SetHExpand sets whether the widget would like any available extra horizontal
// space. When a user resizes a Window, widgets with expand=TRUE generally
// receive the extra space. For example, a list or scrollable area or document
// in your window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget to
// become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk_widget_compute_expand(). A container can decide
// how the expandability of children affects the expansion of the container by
// overriding the compute_expand virtual method on Widget.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because gtk_widget_set_hexpand() sets the
// hexpand-set property (see gtk_widget_set_hexpand_set()) which causes the
// widget’s hexpand value to be used, rather than looking at children and widget
// state.
//
// The function takes the following parameters:
//
//    - expand: whether to expand.
//
func (widget *Widget) SetHExpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(expand)
}

// SetHExpandSet sets whether the hexpand flag (see gtk_widget_get_hexpand())
// will be used.
//
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely reason to use
// this function would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
//
// The function takes the following parameters:
//
//    - set: value for hexpand-set property.
//
func (widget *Widget) SetHExpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand_set(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(set)
}

// SetName widgets can be named, which allows you to refer to them from a CSS
// file. You can apply a style to widgets with a particular name in the CSS
// file. See the documentation for the CSS syntax (on the same page as the docs
// for StyleContext).
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these will
// make your widget impossible to match by name. Any combination of alphanumeric
// symbols, dashes and underscores will suffice.
//
// The function takes the following parameters:
//
//    - name for the widget.
//
func (widget *Widget) SetName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_name(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
}

// SetParent: this function is useful only when implementing subclasses of
// Container. Sets the container as the parent of widget, and takes care of some
// details such as updating the state and style of the child to reflect its new
// location. The opposite function is gtk_widget_unparent().
//
// The function takes the following parameters:
//
//    - parent container.
//
func (widget *Widget) SetParent(parent Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	C.gtk_widget_set_parent(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parent)
}

// SetParentWindow sets a non default parent window for widget.
//
// For Window classes, setting a parent_window effects whether the window is a
// toplevel window or can be embedded into other widgets.
//
// For Window classes, this needs to be called before the window is realized.
//
// The function takes the following parameters:
//
//    - parentWindow: new parent window.
//
func (widget *Widget) SetParentWindow(parentWindow gdk.Windower) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkWindow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(parentWindow).Native()))

	C.gtk_widget_set_parent_window(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parentWindow)
}

// SetRedrawOnAllocate sets whether the entire widget is queued for drawing when
// its size allocation changes. By default, this setting is TRUE and the entire
// widget is redrawn on every size change. If your widget leaves the upper left
// unchanged when made bigger, turning this setting off will improve
// performance.
//
// Note that for widgets where gtk_widget_get_has_window() is FALSE setting this
// flag to FALSE turns off all allocation on resizing: the widget will not even
// redraw if its position changes; this is to allow containers that don’t draw
// anything to avoid excess invalidations. If you set this flag on a widget with
// no window that does draw on widget->window, you are responsible for
// invalidating both the old and new allocation of the widget when the widget is
// moved and responsible for invalidating regions newly when the widget
// increases size.
//
// The function takes the following parameters:
//
//    - redrawOnAllocate: if TRUE, the entire widget will be redrawn when it is
//      allocated to a new size. Otherwise, only the new portion of the widget
//      will be redrawn.
//
func (widget *Widget) SetRedrawOnAllocate(redrawOnAllocate bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if redrawOnAllocate {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_redraw_on_allocate(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(redrawOnAllocate)
}

// SetSensitive sets the sensitivity of a widget. A widget is sensitive if the
// user can interact with it. Insensitive widgets are “grayed out” and the user
// can’t interact with them. Insensitive widgets are known as “inactive”,
// “disabled”, or “ghosted” in some other toolkits.
//
// The function takes the following parameters:
//
//    - sensitive: TRUE to make the widget sensitive.
//
func (widget *Widget) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_sensitive(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(sensitive)
}

// SetSizeRequest sets the minimum size of a widget; that is, the widget’s size
// request will be at least width by height. You can use this function to force
// a widget to be larger than it normally would be.
//
// In most cases, gtk_window_set_default_size() is a better choice for toplevel
// windows than this function; setting the default size will still allow users
// to shrink the window. Setting the size request will force them to leave the
// window at least as large as the size request. When dealing with window sizes,
// gtk_window_set_geometry_hints() can be a useful function as well.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept while
// still functioning well and drawing itself correctly. However in some strange
// cases a widget may be allocated less than its requested size, and in many
// cases a widget may be allocated more space than it requested.
//
// If the size request in a given direction is -1 (unset), then the “natural”
// size request of the widget will be used instead.
//
// The size request set here does not include any margin from the Widget
// properties margin-left, margin-right, margin-top, and margin-bottom, but it
// does include pretty much all other padding or border properties set by any
// subclass of Widget.
//
// The function takes the following parameters:
//
//    - width widget should request, or -1 to unset.
//    - height widget should request, or -1 to unset.
//
func (widget *Widget) SetSizeRequest(width, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_widget_set_size_request(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetState: this function is for use in widget implementations. Sets the state
// of a widget (insensitive, prelighted, etc.) Usually you should set the state
// using wrapper functions such as gtk_widget_set_sensitive().
//
// Deprecated: Use gtk_widget_set_state_flags() instead.
//
// The function takes the following parameters:
//
//    - state: new state for widget.
//
func (widget *Widget) SetState(state StateType) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.GtkStateType // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateType(state)

	C.gtk_widget_set_state(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(state)
}

// SetVAlign sets the vertical alignment of widget. See the Widget:valign
// property.
//
// The function takes the following parameters:
//
//    - align: vertical alignment.
//
func (widget *Widget) SetVAlign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkAlign(align)

	C.gtk_widget_set_valign(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(align)
}

// SetVExpand sets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_set_hexpand() for more detail.
//
// The function takes the following parameters:
//
//    - expand: whether to expand.
//
func (widget *Widget) SetVExpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(expand)
}

// SetVExpandSet sets whether the vexpand flag (see gtk_widget_get_vexpand())
// will be used.
//
// See gtk_widget_set_hexpand_set() for more detail.
//
// The function takes the following parameters:
//
//    - set: value for vexpand-set property.
//
func (widget *Widget) SetVExpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand_set(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(set)
}

// SetVisual sets the visual that should be used for by widget and its children
// for creating Windows. The visual must be on the same Screen as returned by
// gtk_widget_get_screen(), so handling the Widget::screen-changed signal is
// necessary.
//
// Setting a new visual will not cause widget to recreate its windows, so you
// should call this function before widget is realized.
//
// The function takes the following parameters:
//
//    - visual (optional) to be used or NULL to unset a previous one.
//
func (widget *Widget) SetVisual(visual *gdk.Visual) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkVisual // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if visual != nil {
		_arg1 = (*C.GdkVisual)(unsafe.Pointer(coreglib.InternObject(visual).Native()))
	}

	C.gtk_widget_set_visual(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(visual)
}

// Show flags a widget to be displayed. Any widget that isn’t shown will not
// appear on the screen. If you want to show all the widgets in a container,
// it’s easier to call gtk_widget_show_all() on the container, instead of
// individually showing the widgets.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
func (widget *Widget) Show() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_show(_arg0)
	runtime.KeepAlive(widget)
}

// ShowAll: recursively shows a widget, and any child widgets (if the widget is
// a container).
func (widget *Widget) ShowAll() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_show_all(_arg0)
	runtime.KeepAlive(widget)
}

// ShowNow shows a widget. If the widget is an unmapped toplevel widget (i.e. a
// Window that has not yet been shown), enter the main loop and wait for the
// window to actually be mapped. Be careful; because the main loop is running,
// anything can happen during this function.
func (widget *Widget) ShowNow() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_show_now(_arg0)
	runtime.KeepAlive(widget)
}

// SizeAllocate: this function is only used by Container subclasses, to assign a
// size and position to their child widgets.
//
// In this function, the allocation may be adjusted. It will be forced to a 1x1
// minimum size, and the adjust_size_allocation virtual method on the child will
// be used to adjust the allocation. Standard adjustments include removing the
// widget’s margins, and applying the widget’s Widget:halign and Widget:valign
// properties.
//
// For baseline support in containers you need to use
// gtk_widget_size_allocate_with_baseline() instead.
//
// The function takes the following parameters:
//
//    - allocation: position and size to be allocated to widget.
//
func (widget *Widget) SizeAllocate(allocation *Allocation) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))

	C.gtk_widget_size_allocate(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(allocation)
}

// SizeRequest: this function is typically used when implementing a Container
// subclass. Obtains the preferred size of a widget. The container uses this
// information to arrange its child widgets and decide what size allocations to
// give them with gtk_widget_size_allocate().
//
// You can also call this function from an application, with some caveats. Most
// notably, getting a size request requires the widget to be associated with a
// screen, because font information may be needed. Multihead-aware applications
// should keep this in mind.
//
// Also remember that the size request is not necessarily the size a widget will
// actually be allocated.
//
// Deprecated: Use gtk_widget_get_preferred_size() instead.
//
// The function returns the following values:
//
//    - requisition to be filled in.
//
func (widget *Widget) SizeRequest() *Requisition {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_size_request(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _requisition
}

// StyleGetProperty gets the value of a style property of widget.
//
// The function takes the following parameters:
//
//    - propertyName: name of a style property.
//    - value: location to return the property value.
//
func (widget *Widget) StyleGetProperty(propertyName string, value *coreglib.Value) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GValue    // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_widget_style_get_property(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// ThawChildNotify reverts the effect of a previous call to
// gtk_widget_freeze_child_notify(). This causes all queued Widget::child-notify
// signals on widget to be emitted.
func (widget *Widget) ThawChildNotify() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_thaw_child_notify(_arg0)
	runtime.KeepAlive(widget)
}

// TranslateCoordinates: translate coordinates relative to src_widget’s
// allocation to coordinates relative to dest_widget’s allocations. In order to
// perform this operation, both widgets must be realized, and must share a
// common toplevel.
//
// The function takes the following parameters:
//
//    - destWidget: Widget.
//    - srcX: x position relative to src_widget.
//    - srcY: y position relative to src_widget.
//
// The function returns the following values:
//
//    - destX (optional): location to store X position relative to dest_widget.
//    - destY (optional): location to store Y position relative to dest_widget.
//    - ok: FALSE if either widget was not realized, or there was no common
//      ancestor. In this case, nothing is stored in *dest_x and *dest_y.
//      Otherwise TRUE.
//
func (srcWidget *Widget) TranslateCoordinates(destWidget Widgetter, srcX, srcY int) (destX, destY int, ok bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // in
	var _arg5 C.gint       // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(srcWidget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(destWidget).Native()))
	_arg2 = C.gint(srcX)
	_arg3 = C.gint(srcY)

	_cret = C.gtk_widget_translate_coordinates(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(srcWidget)
	runtime.KeepAlive(destWidget)
	runtime.KeepAlive(srcX)
	runtime.KeepAlive(srcY)

	var _destX int // out
	var _destY int // out
	var _ok bool   // out

	_destX = int(_arg4)
	_destY = int(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _destX, _destY, _ok
}

// Unmap: this function is only for use in widget implementations. Causes a
// widget to be unmapped if it’s currently mapped.
func (widget *Widget) Unmap() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unmap(_arg0)
	runtime.KeepAlive(widget)
}

// Unparent: this function is only for use in widget implementations. Should be
// called by implementations of the remove method on Container, to dissociate a
// child from the container.
func (widget *Widget) Unparent() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unparent(_arg0)
	runtime.KeepAlive(widget)
}

// Unrealize: this function is only useful in widget implementations. Causes a
// widget to be unrealized (frees all GDK resources associated with the widget,
// such as widget->window).
func (widget *Widget) Unrealize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unrealize(_arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
func (widget *Widget) adjustBaselineAllocation(baseline *int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.adjust_baseline_allocation

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gint      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gint)(unsafe.Pointer(baseline))

	C._gotk4_gtk3_Widget_virtual_adjust_baseline_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(baseline)
}

// The function takes the following parameters:
//
//    - minimumBaseline
//    - naturalBaseline
//
func (widget *Widget) adjustBaselineRequest(minimumBaseline, naturalBaseline *int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.adjust_baseline_request

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gint      // out
	var _arg2 *C.gint      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gint)(unsafe.Pointer(minimumBaseline))
	_arg2 = (*C.gint)(unsafe.Pointer(naturalBaseline))

	C._gotk4_gtk3_Widget_virtual_adjust_baseline_request(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(minimumBaseline)
	runtime.KeepAlive(naturalBaseline)
}

// The function takes the following parameters:
//
//    - orientation
//    - minimumSize
//    - naturalSize
//    - allocatedPos
//    - allocatedSize
//
func (widget *Widget) adjustSizeAllocation(orientation Orientation, minimumSize, naturalSize, allocatedPos, allocatedSize *int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.adjust_size_allocation

	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.gint          // out
	var _arg3 *C.gint          // out
	var _arg4 *C.gint          // out
	var _arg5 *C.gint          // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)
	_arg2 = (*C.gint)(unsafe.Pointer(minimumSize))
	_arg3 = (*C.gint)(unsafe.Pointer(naturalSize))
	_arg4 = (*C.gint)(unsafe.Pointer(allocatedPos))
	_arg5 = (*C.gint)(unsafe.Pointer(allocatedSize))

	C._gotk4_gtk3_Widget_virtual_adjust_size_allocation(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(minimumSize)
	runtime.KeepAlive(naturalSize)
	runtime.KeepAlive(allocatedPos)
	runtime.KeepAlive(allocatedSize)
}

// The function takes the following parameters:
//
//    - orientation
//    - minimumSize
//    - naturalSize
//
func (widget *Widget) adjustSizeRequest(orientation Orientation, minimumSize, naturalSize *int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.adjust_size_request

	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.gint          // out
	var _arg3 *C.gint          // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)
	_arg2 = (*C.gint)(unsafe.Pointer(minimumSize))
	_arg3 = (*C.gint)(unsafe.Pointer(naturalSize))

	C._gotk4_gtk3_Widget_virtual_adjust_size_request(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(minimumSize)
	runtime.KeepAlive(naturalSize)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) buttonPressEvent(event *gdk.EventButton) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.button_press_event

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkEventButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventButton)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_button_press_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) buttonReleaseEvent(event *gdk.EventButton) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.button_release_event

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkEventButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventButton)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_button_release_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (widget *Widget) compositedChanged() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.composited_changed

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_composited_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) configureEvent(event *gdk.EventConfigure) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.configure_event

	var _arg0 *C.GtkWidget         // out
	var _arg1 *C.GdkEventConfigure // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventConfigure)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_configure_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) damageEvent(event *gdk.EventExpose) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.damage_event

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkEventExpose // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventExpose)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_damage_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) deleteEvent(event *gdk.EventAny) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.delete_event

	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkEventAny // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventAny)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_delete_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Destroy destroys a widget.
//
// When a widget is destroyed all references it holds on other objects will be
// released:
//
//    - if the widget is inside a container, it will be removed from its
//    parent
//    - if the widget is a container, all its children will be destroyed,
//    recursively
//    - if the widget is a top level, it will be removed from the list
//    of top level widgets that GTK+ maintains internally
//
// It's expected that all references held on the widget will also be released;
// you should connect to the Widget::destroy signal if you hold a reference to
// widget and you wish to remove it when this function is called. It is not
// necessary to do so if you are implementing a Container, as you'll be able to
// use the ContainerClass.remove() virtual function for that.
//
// It's important to notice that gtk_widget_destroy() will only cause the widget
// to be finalized if no additional references, acquired using g_object_ref(),
// are held on it. In case additional references are in place, the widget will
// be in an "inert" state after calling this function; widget will still point
// to valid memory, allowing you to release the references you hold, but you may
// not query the widget's own state.
//
// You should typically call this function on top level widgets, and rarely on
// child widgets.
//
// See also: gtk_container_remove().
func (widget *Widget) destroy() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.destroy

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_destroy(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) destroyEvent(event *gdk.EventAny) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.destroy_event

	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkEventAny // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventAny)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_destroy_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (widget *Widget) directionChanged(previousDirection TextDirection) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.direction_changed

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkTextDirection(previousDirection)

	C._gotk4_gtk3_Widget_virtual_direction_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousDirection)
}

// The function takes the following parameters:
//
func (widget *Widget) dragBegin(context *gdk.DragContext) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_begin

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk3_Widget_virtual_drag_begin(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
}

// The function takes the following parameters:
//
func (widget *Widget) dragDataDelete(context *gdk.DragContext) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_data_delete

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk3_Widget_virtual_drag_data_delete(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
}

// The function takes the following parameters:
//
//    - context
//    - selectionData
//    - info
//    - time_
//
func (widget *Widget) dragDataGet(context *gdk.DragContext, selectionData *SelectionData, info, time_ uint) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_data_get

	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GdkDragContext   // out
	var _arg2 *C.GtkSelectionData // out
	var _arg3 C.guint             // out
	var _arg4 C.guint             // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg3 = C.guint(info)
	_arg4 = C.guint(time_)

	C._gotk4_gtk3_Widget_virtual_drag_data_get(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(info)
	runtime.KeepAlive(time_)
}

// The function takes the following parameters:
//
//    - context
//    - x
//    - y
//    - selectionData
//    - info
//    - time_
//
func (widget *Widget) dragDataReceived(context *gdk.DragContext, x, y int, selectionData *SelectionData, info, time_ uint) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_data_received

	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GdkDragContext   // out
	var _arg2 C.gint              // out
	var _arg3 C.gint              // out
	var _arg4 *C.GtkSelectionData // out
	var _arg5 C.guint             // out
	var _arg6 C.guint             // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.gint(x)
	_arg3 = C.gint(y)
	_arg4 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg5 = C.guint(info)
	_arg6 = C.guint(time_)

	C._gotk4_gtk3_Widget_virtual_drag_data_received(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(info)
	runtime.KeepAlive(time_)
}

// The function takes the following parameters:
//
//    - context
//    - x
//    - y
//    - time_
//
// The function returns the following values:
//
func (widget *Widget) dragDrop(context *gdk.DragContext, x, y int, time_ uint) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_drop

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gint            // out
	var _arg3 C.gint            // out
	var _arg4 C.guint           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.gint(x)
	_arg3 = C.gint(y)
	_arg4 = C.guint(time_)

	_cret = C._gotk4_gtk3_Widget_virtual_drag_drop(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(time_)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (widget *Widget) dragEnd(context *gdk.DragContext) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_end

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk3_Widget_virtual_drag_end(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
}

// The function takes the following parameters:
//
//    - context
//    - result
//
// The function returns the following values:
//
func (widget *Widget) dragFailed(context *gdk.DragContext, result DragResult) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_failed

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.GtkDragResult   // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GtkDragResult(result)

	_cret = C._gotk4_gtk3_Widget_virtual_drag_failed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
	runtime.KeepAlive(result)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - context
//    - time_
//
func (widget *Widget) dragLeave(context *gdk.DragContext, time_ uint) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_leave

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.guint           // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.guint(time_)

	C._gotk4_gtk3_Widget_virtual_drag_leave(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
	runtime.KeepAlive(time_)
}

// The function takes the following parameters:
//
//    - context
//    - x
//    - y
//    - time_
//
// The function returns the following values:
//
func (widget *Widget) dragMotion(context *gdk.DragContext, x, y int, time_ uint) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.drag_motion

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkDragContext // out
	var _arg2 C.gint            // out
	var _arg3 C.gint            // out
	var _arg4 C.guint           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDragContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.gint(x)
	_arg3 = C.gint(y)
	_arg4 = C.guint(time_)

	_cret = C._gotk4_gtk3_Widget_virtual_drag_motion(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(time_)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) draw(cr *cairo.Context) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.draw

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.cairo_t   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	_cret = C._gotk4_gtk3_Widget_virtual_draw(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cr)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) enterNotifyEvent(event *gdk.EventCrossing) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.enter_notify_event

	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GdkEventCrossing // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventCrossing)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_enter_notify_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Event: rarely-used function. This function is used to emit the event signals
// on a widget (those signals should never be emitted without using this
// function to do so). If you want to synthesize an event though, don’t use this
// function; instead, use gtk_main_do_event() so the event will behave as if it
// were in the event queue. Don’t synthesize expose events; instead, use
// gdk_window_invalidate_rect() to invalidate a region of the window.
//
// The function takes the following parameters:
//
//    - event: Event.
//
// The function returns the following values:
//
//    - ok: return from the event signal emission (TRUE if the event was
//      handled).
//
func (widget *Widget) event(event *gdk.Event) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.event

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkEvent  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEvent)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) focus(direction DirectionType) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.focus

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C._gotk4_gtk3_Widget_virtual_focus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) focusInEvent(event *gdk.EventFocus) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.focus_in_event

	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GdkEventFocus // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventFocus)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_focus_in_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) focusOutEvent(event *gdk.EventFocus) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.focus_out_event

	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GdkEventFocus // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventFocus)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_focus_out_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Accessible returns the accessible object that describes the widget to an
// assistive technology.
//
// If accessibility support is not available, this Object instance may be a
// no-op. Likewise, if no class-specific Object implementation is available for
// the widget instance in question, it will inherit an Object implementation
// from the first ancestor class for which such an implementation is defined.
//
// The documentation of the ATK (http://developer.gnome.org/atk/stable/) library
// contains more information about accessible objects and their uses.
//
// The function returns the following values:
//
//    - object associated with widget.
//
func (widget *Widget) accessible() *atk.AtkObject {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.get_accessible

	var _arg0 *C.GtkWidget // out
	var _cret *C.AtkObject // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C._gotk4_gtk3_Widget_virtual_get_accessible(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)

	var _object *atk.AtkObject // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_object = &atk.AtkObject{
			Object: obj,
		}
	}

	return _object
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) grabBrokenEvent(event *gdk.EventGrabBroken) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.grab_broken_event

	var _arg0 *C.GtkWidget          // out
	var _arg1 *C.GdkEventGrabBroken // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventGrabBroken)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_grab_broken_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// grabFocus causes widget to have the keyboard focus for the Window it's
// inside. widget must be a focusable widget, such as a Entry; something like
// Frame won’t work.
//
// More precisely, it must have the GTK_CAN_FOCUS flag set. Use
// gtk_widget_set_can_focus() to modify that flag.
//
// The widget also needs to be realized and mapped. This is indicated by the
// related signals. Grabbing the focus immediately after creating the widget
// will likely fail and cause critical warnings.
func (widget *Widget) grabFocus() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.grab_focus

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_grab_focus(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
func (widget *Widget) grabNotify(wasGrabbed bool) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.grab_notify

	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if wasGrabbed {
		_arg1 = C.TRUE
	}

	C._gotk4_gtk3_Widget_virtual_grab_notify(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(wasGrabbed)
}

// Hide reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
func (widget *Widget) hide() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.hide

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_hide(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
func (widget *Widget) hierarchyChanged(previousToplevel Widgetter) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.hierarchy_changed

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(previousToplevel).Native()))

	C._gotk4_gtk3_Widget_virtual_hierarchy_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousToplevel)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) keyPressEvent(event *gdk.EventKey) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.key_press_event

	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventKey)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_key_press_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) keyReleaseEvent(event *gdk.EventKey) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.key_release_event

	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventKey)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_key_release_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) leaveNotifyEvent(event *gdk.EventCrossing) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.leave_notify_event

	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GdkEventCrossing // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventCrossing)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_leave_notify_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Map: this function is only for use in widget implementations. Causes a widget
// to be mapped if it isn’t already.
func (widget *Widget) _map() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass._map

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_map(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) mapEvent(event *gdk.EventAny) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.map_event

	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkEventAny // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventAny)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_map_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// mnemonicActivate emits the Widget::mnemonic-activate signal.
//
// The function takes the following parameters:
//
//    - groupCycling: TRUE if there are other widgets with the same mnemonic.
//
// The function returns the following values:
//
//    - ok: TRUE if the signal has been handled.
//
func (widget *Widget) mnemonicActivate(groupCycling bool) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.mnemonic_activate

	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gtk3_Widget_virtual_mnemonic_activate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(groupCycling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) motionNotifyEvent(event *gdk.EventMotion) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.motion_notify_event

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkEventMotion // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventMotion)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_motion_notify_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
func (widget *Widget) moveFocus(direction DirectionType) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.move_focus

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	C._gotk4_gtk3_Widget_virtual_move_focus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)
}

// The function takes the following parameters:
//
func (widget *Widget) parentSet(previousParent Widgetter) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.parent_set

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(previousParent).Native()))

	C._gotk4_gtk3_Widget_virtual_parent_set(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousParent)
}

// The function returns the following values:
//
func (widget *Widget) popupMenu() bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.popup_menu

	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C._gotk4_gtk3_Widget_virtual_popup_menu(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) propertyNotifyEvent(event *gdk.EventProperty) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.property_notify_event

	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GdkEventProperty // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventProperty)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_property_notify_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) proximityInEvent(event *gdk.EventProximity) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.proximity_in_event

	var _arg0 *C.GtkWidget         // out
	var _arg1 *C.GdkEventProximity // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventProximity)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_proximity_in_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) proximityOutEvent(event *gdk.EventProximity) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.proximity_out_event

	var _arg0 *C.GtkWidget         // out
	var _arg1 *C.GdkEventProximity // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventProximity)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_proximity_out_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - x
//    - y
//    - keyboardTooltip
//    - tooltip
//
// The function returns the following values:
//
func (widget *Widget) queryTooltip(x, y int, keyboardTooltip bool, tooltip *Tooltip) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.query_tooltip

	var _arg0 *C.GtkWidget  // out
	var _arg1 C.gint        // out
	var _arg2 C.gint        // out
	var _arg3 C.gboolean    // out
	var _arg4 *C.GtkTooltip // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)
	if keyboardTooltip {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))

	_cret = C._gotk4_gtk3_Widget_virtual_query_tooltip(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(keyboardTooltip)
	runtime.KeepAlive(tooltip)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Realize creates the GDK (windowing system) resources associated with a
// widget. For example, widget->window will be created when a widget is
// realized. Normally realization happens implicitly; if you show a widget and
// all its parent containers, then the widget will be realized and mapped
// automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling gtk_widget_realize() realizes the widget’s parents in addition to
// widget itself. If a widget is not yet inside a toplevel window when you
// realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as Widget::draw. Or simply g_signal_connect ()
// to the Widget::realize signal.
func (widget *Widget) realize() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.realize

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_realize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
func (widget *Widget) screenChanged(previousScreen *gdk.Screen) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.screen_changed

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkScreen // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(coreglib.InternObject(previousScreen).Native()))

	C._gotk4_gtk3_Widget_virtual_screen_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousScreen)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) scrollEvent(event *gdk.EventScroll) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.scroll_event

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GdkEventScroll // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventScroll)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_scroll_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) selectionClearEvent(event *gdk.EventSelection) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.selection_clear_event

	var _arg0 *C.GtkWidget         // out
	var _arg1 *C.GdkEventSelection // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventSelection)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_selection_clear_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - selectionData
//    - info
//    - time_
//
func (widget *Widget) selectionGet(selectionData *SelectionData, info, time_ uint) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.selection_get

	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkSelectionData // out
	var _arg2 C.guint             // out
	var _arg3 C.guint             // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg2 = C.guint(info)
	_arg3 = C.guint(time_)

	C._gotk4_gtk3_Widget_virtual_selection_get(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(info)
	runtime.KeepAlive(time_)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) selectionNotifyEvent(event *gdk.EventSelection) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.selection_notify_event

	var _arg0 *C.GtkWidget         // out
	var _arg1 *C.GdkEventSelection // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventSelection)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_selection_notify_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - selectionData
//    - time_
//
func (widget *Widget) selectionReceived(selectionData *SelectionData, time_ uint) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.selection_received

	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkSelectionData // out
	var _arg2 C.guint             // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg2 = C.guint(time_)

	C._gotk4_gtk3_Widget_virtual_selection_received(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(time_)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) selectionRequestEvent(event *gdk.EventSelection) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.selection_request_event

	var _arg0 *C.GtkWidget         // out
	var _arg1 *C.GdkEventSelection // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventSelection)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_selection_request_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Show flags a widget to be displayed. Any widget that isn’t shown will not
// appear on the screen. If you want to show all the widgets in a container,
// it’s easier to call gtk_widget_show_all() on the container, instead of
// individually showing the widgets.
//
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
func (widget *Widget) show() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.show

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_show(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// showAll: recursively shows a widget, and any child widgets (if the widget is
// a container).
func (widget *Widget) showAll() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.show_all

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_show_all(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) showHelp(helpType WidgetHelpType) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.show_help

	var _arg0 *C.GtkWidget        // out
	var _arg1 C.GtkWidgetHelpType // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkWidgetHelpType(helpType)

	_cret = C._gotk4_gtk3_Widget_virtual_show_help(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(helpType)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// sizeAllocate: this function is only used by Container subclasses, to assign a
// size and position to their child widgets.
//
// In this function, the allocation may be adjusted. It will be forced to a 1x1
// minimum size, and the adjust_size_allocation virtual method on the child will
// be used to adjust the allocation. Standard adjustments include removing the
// widget’s margins, and applying the widget’s Widget:halign and Widget:valign
// properties.
//
// For baseline support in containers you need to use
// gtk_widget_size_allocate_with_baseline() instead.
//
// The function takes the following parameters:
//
//    - allocation: position and size to be allocated to widget.
//
func (widget *Widget) sizeAllocate(allocation *Allocation) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.size_allocate

	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))

	C._gotk4_gtk3_Widget_virtual_size_allocate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(allocation)
}

// The function takes the following parameters:
//
func (widget *Widget) stateChanged(previousState StateType) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.state_changed

	var _arg0 *C.GtkWidget   // out
	var _arg1 C.GtkStateType // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateType(previousState)

	C._gotk4_gtk3_Widget_virtual_state_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousState)
}

// The function takes the following parameters:
//
func (widget *Widget) stateFlagsChanged(previousStateFlags StateFlags) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.state_flags_changed

	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(previousStateFlags)

	C._gotk4_gtk3_Widget_virtual_state_flags_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousStateFlags)
}

// The function takes the following parameters:
//
func (widget *Widget) styleSet(previousStyle *Style) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.style_set

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkStyle  // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkStyle)(unsafe.Pointer(coreglib.InternObject(previousStyle).Native()))

	C._gotk4_gtk3_Widget_virtual_style_set(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousStyle)
}

func (widget *Widget) styleUpdated() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.style_updated

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_style_updated(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) touchEvent(event *gdk.EventTouch) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.touch_event

	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GdkEventTouch // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventTouch)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_touch_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unmap: this function is only for use in widget implementations. Causes a
// widget to be unmapped if it’s currently mapped.
func (widget *Widget) unmap() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unmap

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_unmap(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) unmapEvent(event *gdk.EventAny) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unmap_event

	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkEventAny // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventAny)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_unmap_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unrealize: this function is only useful in widget implementations. Causes a
// widget to be unrealized (frees all GDK resources associated with the widget,
// such as widget->window).
func (widget *Widget) unrealize() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unrealize

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_unrealize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) visibilityNotifyEvent(event *gdk.EventVisibility) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.visibility_notify_event

	var _arg0 *C.GtkWidget          // out
	var _arg1 *C.GdkEventVisibility // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventVisibility)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_visibility_notify_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (widget *Widget) windowStateEvent(event *gdk.EventWindowState) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.window_state_event

	var _arg0 *C.GtkWidget           // out
	var _arg1 *C.GdkEventWindowState // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkEventWindowState)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C._gotk4_gtk3_Widget_virtual_window_state_event(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidgetGetDefaultDirection obtains the current default reading direction. See
// gtk_widget_set_default_direction().
//
// The function returns the following values:
//
//    - textDirection: current default direction.
//
func WidgetGetDefaultDirection() TextDirection {
	var _cret C.GtkTextDirection // in

	_cret = C.gtk_widget_get_default_direction()

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// WidgetPopCompositeChild cancels the effect of a previous call to
// gtk_widget_push_composite_child().
//
// Deprecated: Use gtk_widget_class_set_template(), or don’t use this API at
// all.
func WidgetPopCompositeChild() {
	C.gtk_widget_pop_composite_child()
}

// WidgetPushCompositeChild makes all newly-created widgets as composite
// children until the corresponding gtk_widget_pop_composite_child() call.
//
// A composite child is a child that’s an implementation detail of the container
// it’s inside and should not be visible to people using the container.
// Composite children aren’t treated differently by GTK+ (but see
// gtk_container_foreach() vs. gtk_container_forall()), but e.g. GUI builders
// might want to treat them in a different way.
//
// Deprecated: This API never really worked well and was mostly unused, now we
// have a more complete mechanism for composite children, see
// gtk_widget_class_set_template().
func WidgetPushCompositeChild() {
	C.gtk_widget_push_composite_child()
}

// WidgetSetDefaultDirection sets the default reading direction for widgets
// where the direction has not been explicitly set by
// gtk_widget_set_direction().
//
// The function takes the following parameters:
//
//    - dir: new default direction. This cannot be GTK_TEXT_DIR_NONE.
//
func WidgetSetDefaultDirection(dir TextDirection) {
	var _arg1 C.GtkTextDirection // out

	_arg1 = C.GtkTextDirection(dir)

	C.gtk_widget_set_default_direction(_arg1)
	runtime.KeepAlive(dir)
}

// Requisition represents the desired size of a widget. See [GtkWidget’s
// geometry management section][geometry-management] for more information.
//
// An instance of this type is always passed by reference.
type Requisition struct {
	*requisition
}

// requisition is the struct that's finalized.
type requisition struct {
	native *C.GtkRequisition
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Requisition{&requisition{(*C.GtkRequisition)(b)}}, nil
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	var _cret *C.GtkRequisition // in

	_cret = C.gtk_requisition_new()

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_requisition)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_requisition_free((*C.GtkRequisition)(intern.C))
		},
	)

	return _requisition
}

// Width widget’s desired width.
func (r *Requisition) Width() int {
	valptr := &r.native.width
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Height widget’s desired height.
func (r *Requisition) Height() int {
	valptr := &r.native.height
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width widget’s desired width.
func (r *Requisition) SetWidth(width int) {
	valptr := &r.native.width
	*valptr = C.gint(width)
}

// Height widget’s desired height.
func (r *Requisition) SetHeight(height int) {
	valptr := &r.native.height
	*valptr = C.gint(height)
}

// Copy copies a Requisition.
//
// The function returns the following values:
//
//    - ret: copy of requisition.
//
func (requisition *Requisition) Copy() *Requisition {
	var _arg0 *C.GtkRequisition // out
	var _cret *C.GtkRequisition // in

	_arg0 = (*C.GtkRequisition)(gextras.StructNative(unsafe.Pointer(requisition)))

	_cret = C.gtk_requisition_copy(_arg0)
	runtime.KeepAlive(requisition)

	var _ret *Requisition // out

	_ret = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_requisition_free((*C.GtkRequisition)(intern.C))
		},
	)

	return _ret
}

// WidgetClass: instance of this type is always passed by reference.
type WidgetClass struct {
	*widgetClass
}

// widgetClass is the struct that's finalized.
type widgetClass struct {
	native *C.GtkWidgetClass
}

// ActivateSignal: signal to emit when a widget of this class is activated,
// gtk_widget_activate() handles the emission. Implementation of this signal is
// optional.
func (w *WidgetClass) ActivateSignal() uint {
	valptr := &w.native.activate_signal
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// BindTemplateChildFull: automatically assign an object declared in the class
// template XML to be set to a location on a freshly built instance’s private
// data, or alternatively accessible via gtk_widget_get_template_child().
//
// The struct can point either into the public instance, then you should use
// G_STRUCT_OFFSET(WidgetType, member) for struct_offset, or in the private
// struct, then you should use G_PRIVATE_OFFSET(WidgetType, member).
//
// An explicit strong reference will be held automatically for the duration of
// your instance’s life cycle, it will be released automatically when
// Class.dispose() runs on your instance and if a struct_offset that is != 0 is
// specified, then the automatic location in your instance public or private
// data will be set to NULL. You can however access an automated child pointer
// the first time your classes Class.dispose() runs, or alternatively in
// WidgetClass.destroy().
//
// If internal_child is specified, BuildableIface.get_internal_child() will be
// automatically implemented by the Widget class so there is no need to
// implement it manually.
//
// The wrapper macros gtk_widget_class_bind_template_child(),
// gtk_widget_class_bind_template_child_internal(),
// gtk_widget_class_bind_template_child_private() and
// gtk_widget_class_bind_template_child_internal_private() might be more
// convenient to use.
//
// Note that this must be called from a composite widget classes class
// initializer after calling gtk_widget_class_set_template().
//
// The function takes the following parameters:
//
//    - name: “id” of the child defined in the template XML.
//    - internalChild: whether the child should be accessible as an
//      “internal-child” when this class is used in GtkBuilder XML.
//    - structOffset: structure offset into the composite widget’s instance
//      public or private structure where the automated child pointer should be
//      set, or 0 to not assign the pointer.
//
func (widgetClass *WidgetClass) BindTemplateChildFull(name string, internalChild bool, structOffset int) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.gchar          // out
	var _arg2 C.gboolean        // out
	var _arg3 C.gssize          // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if internalChild {
		_arg2 = C.TRUE
	}
	_arg3 = C.gssize(structOffset)

	C.gtk_widget_class_bind_template_child_full(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(name)
	runtime.KeepAlive(internalChild)
	runtime.KeepAlive(structOffset)
}

// CSSName gets the name used by this class for matching in CSS code. See
// gtk_widget_class_set_css_name() for details.
//
// The function returns the following values:
//
//    - utf8: CSS name of the given class.
//
func (widgetClass *WidgetClass) CSSName() string {
	var _arg0 *C.GtkWidgetClass // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_css_name(_arg0)
	runtime.KeepAlive(widgetClass)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetAccessibleRole sets the default Role to be set on accessibles created for
// widgets of widget_class. Accessibles may decide to not honor this setting if
// their role reporting is more refined. Calls to
// gtk_widget_class_set_accessible_type() will reset this value.
//
// In cases where you want more fine-grained control over the role of
// accessibles created for widget_class, you should provide your own accessible
// type and use gtk_widget_class_set_accessible_type() instead.
//
// If role is K_ROLE_INVALID, the default role will not be changed and the
// accessible’s default role will be used instead.
//
// This function should only be called from class init functions of widgets.
//
// The function takes the following parameters:
//
//    - role to use for accessibles created for widget_class.
//
func (widgetClass *WidgetClass) SetAccessibleRole(role atk.Role) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 C.AtkRole         // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.AtkRole(role)

	C.gtk_widget_class_set_accessible_role(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(role)
}

// SetAccessibleType sets the type to be used for creating accessibles for
// widgets of widget_class. The given type must be a subtype of the type used
// for accessibles of the parent class.
//
// This function should only be called from class init functions of widgets.
//
// The function takes the following parameters:
//
//    - typ: object type that implements the accessible for widget_class.
//
func (widgetClass *WidgetClass) SetAccessibleType(typ coreglib.Type) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 C.GType           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.GType(typ)

	C.gtk_widget_class_set_accessible_type(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(typ)
}

// SetCSSName sets the name to be used for CSS matching of widgets.
//
// If this function is not called for a given class, the name of the parent
// class is used.
//
// The function takes the following parameters:
//
//    - name to use.
//
func (widgetClass *WidgetClass) SetCSSName(name string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_class_set_css_name(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(name)
}

// SetTemplate: this should be called at class initialization time to specify
// the GtkBuilder XML to be used to extend a widget.
//
// For convenience, gtk_widget_class_set_template_from_resource() is also
// provided.
//
// Note that any class that installs templates must call
// gtk_widget_init_template() in the widget’s instance initializer.
//
// The function takes the following parameters:
//
//    - templateBytes holding the Builder XML.
//
func (widgetClass *WidgetClass) SetTemplate(templateBytes *glib.Bytes) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.GBytes         // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(templateBytes)))

	C.gtk_widget_class_set_template(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(templateBytes)
}

// SetTemplateFromResource: convenience function to call
// gtk_widget_class_set_template().
//
// Note that any class that installs templates must call
// gtk_widget_init_template() in the widget’s instance initializer.
//
// The function takes the following parameters:
//
//    - resourceName: name of the resource to load the template from.
//
func (widgetClass *WidgetClass) SetTemplateFromResource(resourceName string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.gchar          // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(resourceName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_class_set_template_from_resource(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(resourceName)
}

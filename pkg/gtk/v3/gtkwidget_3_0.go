// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// GtkSizeRequestMode _gotk4_gtk3_Widget_virtual_get_request_mode(void* fnptr, GtkWidget* arg0) {
//   return ((GtkSizeRequestMode (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Widget_virtual_get_preferred_height(void* fnptr, GtkWidget* arg0, gint* arg1, gint* arg2) {
//   ((void (*)(GtkWidget*, gint*, gint*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_Widget_virtual_get_preferred_height_for_width(void* fnptr, GtkWidget* arg0, gint arg1, gint* arg2, gint* arg3) {
//   ((void (*)(GtkWidget*, gint, gint*, gint*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk3_Widget_virtual_get_preferred_width(void* fnptr, GtkWidget* arg0, gint* arg1, gint* arg2) {
//   ((void (*)(GtkWidget*, gint*, gint*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_Widget_virtual_get_preferred_width_for_height(void* fnptr, GtkWidget* arg0, gint arg1, gint* arg2, gint* arg3) {
//   ((void (*)(GtkWidget*, gint, gint*, gint*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk3_Widget_virtual_queue_draw_region(void* fnptr, GtkWidget* arg0, cairo_region_t* arg1) {
//   ((void (*)(GtkWidget*, cairo_region_t*))(fnptr))(arg0, arg1);
// };
import "C"

// CairoShouldDrawWindow: this function is supposed to be called in Widget::draw
// implementations for widgets that support multiple windows. cr must be
// untransformed from invoking of the draw function. This function will return
// TRUE if the contents of the given window are supposed to be drawn and FALSE
// otherwise. Note that when the drawing was not initiated by the windowing
// system this function will return TRUE for all windows, so you need to draw
// the bottommost window first. Also, do not use “else if” statements to check
// which window should be drawn.
//
// The function takes the following parameters:
//
//    - cr: cairo context.
//    - window to check. window may not be an input-only window.
//
// The function returns the following values:
//
//    - ok: TRUE if window should be drawn.
//
func CairoShouldDrawWindow(cr *cairo.Context, window gdk.Windower) bool {
	var _arg1 *C.cairo_t   // out
	var _arg2 *C.GdkWindow // out
	var _cret C.gboolean   // in

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_cairo_should_draw_window(_arg1, _arg2)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CairoTransformToWindow transforms the given cairo context cr that from
// widget-relative coordinates to window-relative coordinates. If the widget’s
// window is not an ancestor of window, no modification will be applied.
//
// This is the inverse to the transformation GTK applies when preparing an
// expose event to be emitted with the Widget::draw signal. It is intended to
// help porting multiwindow widgets from GTK+ 2 to the rendering architecture of
// GTK+ 3.
//
// The function takes the following parameters:
//
//    - cr: cairo context to transform.
//    - widget the context is currently centered for.
//    - window to transform the context to.
//
func CairoTransformToWindow(cr *cairo.Context, widget Widgetter, window gdk.Windower) {
	var _arg1 *C.cairo_t   // out
	var _arg2 *C.GtkWidget // out
	var _arg3 *C.GdkWindow // out

	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_cairo_transform_to_window(_arg1, _arg2, _arg3)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(window)
}

// AddDeviceEvents adds the device events in the bitfield events to the event
// mask for widget. See gtk_widget_set_device_events() for details.
//
// The function takes the following parameters:
//
//    - device: Device.
//    - events: event mask, see EventMask.
//
func (widget *Widget) AddDeviceEvents(device gdk.Devicer, events gdk.EventMask) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.GdkEventMask // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = C.GdkEventMask(events)

	C.gtk_widget_add_device_events(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)
	runtime.KeepAlive(events)
}

// DeviceIsShadowed returns TRUE if device has been shadowed by a GTK+ device
// grab on another widget, so it would stop sending events to widget. This may
// be used in the Widget::grab-notify signal to check for specific devices. See
// gtk_device_grab_add().
//
// The function takes the following parameters:
//
//    - device: Device.
//
// The function returns the following values:
//
//    - ok: TRUE if there is an ongoing grab on device by another Widget than
//      widget.
//
func (widget *Widget) DeviceIsShadowed(device gdk.Devicer) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gtk_widget_device_is_shadowed(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Draw draws widget to cr. The top left corner of the widget will be drawn to
// the currently set origin point of cr.
//
// You should pass a cairo context as cr argument that is in an original state.
// Otherwise the resulting drawing is undefined. For example changing the
// operator using cairo_set_operator() or the line width using
// cairo_set_line_width() might have unwanted side effects. You may however
// change the context’s transform matrix - like with cairo_scale(),
// cairo_translate() or cairo_set_matrix() and clip region with cairo_clip()
// prior to calling this function. Also, it is fine to modify the context with
// cairo_save() and cairo_push_group() prior to calling this function.
//
// Note that special-purpose widgets may contain special code for rendering to
// the screen and might appear differently on screen and when rendered using
// gtk_widget_draw().
//
// The function takes the following parameters:
//
//    - cr: cairo context to draw to.
//
func (widget *Widget) Draw(cr *cairo.Context) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.cairo_t   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gtk_widget_draw(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cr)
}

// DeviceEnabled returns whether device can interact with widget and its
// children. See gtk_widget_set_device_enabled().
//
// The function takes the following parameters:
//
//    - device: Device.
//
// The function returns the following values:
//
//    - ok: TRUE is device is enabled for widget.
//
func (widget *Widget) DeviceEnabled(device gdk.Devicer) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gtk_widget_get_device_enabled(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeviceEvents returns the events mask for the widget corresponding to an
// specific device. These are the events that the widget will receive when
// device operates on it.
//
// The function takes the following parameters:
//
//    - device: Device.
//
// The function returns the following values:
//
//    - eventMask: device event mask for widget.
//
func (widget *Widget) DeviceEvents(device gdk.Devicer) gdk.EventMask {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _cret C.GdkEventMask // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	_cret = C.gtk_widget_get_device_events(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)

	var _eventMask gdk.EventMask // out

	_eventMask = gdk.EventMask(_cret)

	return _eventMask
}

// MarginBottom gets the value of the Widget:margin-bottom property.
//
// The function returns the following values:
//
//    - gint: bottom margin of widget.
//
func (widget *Widget) MarginBottom() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_bottom(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginLeft gets the value of the Widget:margin-left property.
//
// Deprecated: Use gtk_widget_get_margin_start() instead.
//
// The function returns the following values:
//
//    - gint: left margin of widget.
//
func (widget *Widget) MarginLeft() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_left(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginRight gets the value of the Widget:margin-right property.
//
// Deprecated: Use gtk_widget_get_margin_end() instead.
//
// The function returns the following values:
//
//    - gint: right margin of widget.
//
func (widget *Widget) MarginRight() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_right(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginTop gets the value of the Widget:margin-top property.
//
// The function returns the following values:
//
//    - gint: top margin of widget.
//
func (widget *Widget) MarginTop() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_top(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PreferredHeight retrieves a widget’s initial minimum and natural height.
//
// This call is specific to width-for-height requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location to store the minimum height, or NULL.
//    - naturalHeight (optional): location to store the natural height, or NULL.
//
func (widget *Widget) PreferredHeight() (minimumHeight, naturalHeight int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_preferred_height(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg1)
	_naturalHeight = int(_arg2)

	return _minimumHeight, _naturalHeight
}

// PreferredHeightForWidth retrieves a widget’s minimum and natural height if it
// would be given the specified width.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function takes the following parameters:
//
//    - width which is available for allocation.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location for storing the minimum height, or
//      NULL.
//    - naturalHeight (optional): location for storing the natural height, or
//      NULL.
//
func (widget *Widget) PreferredHeightForWidth(width int) (minimumHeight, naturalHeight int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(width)

	C.gtk_widget_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg2)
	_naturalHeight = int(_arg3)

	return _minimumHeight, _naturalHeight
}

// PreferredSize retrieves the minimum and natural size of a widget, taking into
// account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do not
// impose any restrictions on the child placement. It can be used to deduce
// toplevel window and menu sizes as well as child widgets in free-form
// containers such as GtkLayout.
//
// Handle with care. Note that the natural height of a height-for-width widget
// will generally be a smaller size than the minimum height, since the required
// height for the natural width is generally smaller than the required height
// for the minimum width.
//
// Use gtk_widget_get_preferred_height_and_baseline_for_width() if you want to
// support baseline alignment.
//
// The function returns the following values:
//
//    - minimumSize (optional): location for storing the minimum size, or NULL.
//    - naturalSize (optional): location for storing the natural size, or NULL.
//
func (widget *Widget) PreferredSize() (minimumSize, naturalSize *Requisition) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in
	var _arg2 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_preferred_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumSize *Requisition // out
	var _naturalSize *Requisition // out

	_minimumSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_naturalSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _minimumSize, _naturalSize
}

// PreferredWidth retrieves a widget’s initial minimum and natural width.
//
// This call is specific to height-for-width requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location to store the minimum width, or NULL.
//    - naturalWidth (optional): location to store the natural width, or NULL.
//
func (widget *Widget) PreferredWidth() (minimumWidth, naturalWidth int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_preferred_width(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg1)
	_naturalWidth = int(_arg2)

	return _minimumWidth, _naturalWidth
}

// PreferredWidthForHeight retrieves a widget’s minimum and natural width if it
// would be given the specified height.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function takes the following parameters:
//
//    - height which is available for allocation.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location for storing the minimum width, or NULL.
//    - naturalWidth (optional): location for storing the natural width, or NULL.
//
func (widget *Widget) PreferredWidthForHeight(height int) (minimumWidth, naturalWidth int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(height)

	C.gtk_widget_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg2)
	_naturalWidth = int(_arg3)

	return _minimumWidth, _naturalWidth
}

// RequestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
//
// Bin widgets generally propagate the preference of their child, container
// widgets need to request something either in context of their children or in
// context of their allocation capabilities.
//
// The function returns the following values:
//
//    - sizeRequestMode preferred by widget.
//
func (widget *Widget) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_request_mode(_arg0)
	runtime.KeepAlive(widget)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// StateFlags returns the widget state as a flag set. It is worth mentioning
// that the effective GTK_STATE_FLAG_INSENSITIVE state will be returned, that
// is, also based on parent insensitivity, even if widget itself is sensitive.
//
// Also note that if you are looking for a way to obtain the StateFlags to pass
// to a StyleContext method, you should look at gtk_style_context_get_state().
//
// The function returns the following values:
//
//    - stateFlags: state flags for widget.
//
func (widget *Widget) StateFlags() StateFlags {
	var _arg0 *C.GtkWidget    // out
	var _cret C.GtkStateFlags // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_state_flags(_arg0)
	runtime.KeepAlive(widget)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// InputShapeCombineRegion sets an input shape for this widget’s GDK window.
// This allows for windows which react to mouse click in a nonrectangular
// region, see gdk_window_input_shape_combine_region() for more information.
//
// The function takes the following parameters:
//
//    - region (optional): shape to be added, or NULL to remove an existing
//      shape.
//
func (widget *Widget) InputShapeCombineRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if region != nil {
		_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	}

	C.gtk_widget_input_shape_combine_region(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)
}

// OverrideBackgroundColor sets the background color to use for a widget.
//
// All other style values are left untouched. See gtk_widget_override_color().
//
// Deprecated: This function is not useful in the context of CSS-based
// rendering. If you wish to change the way a widget renders its background you
// should use a custom CSS style, through an application-specific StyleProvider
// and a CSS style class. You can also override the default drawing of a widget
// through the Widget::draw signal, and use Cairo to draw a specific color,
// regardless of the CSS style.
//
// The function takes the following parameters:
//
//    - state for which to set the background color.
//    - color (optional) to assign, or NULL to undo the effect of previous calls
//      to gtk_widget_override_background_color().
//
func (widget *Widget) OverrideBackgroundColor(state StateFlags, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 *C.GdkRGBA      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(state)
	if color != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	}

	C.gtk_widget_override_background_color(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(state)
	runtime.KeepAlive(color)
}

// OverrideColor sets the color to use for a widget.
//
// All other style values are left untouched.
//
// This function does not act recursively. Setting the color of a container does
// not affect its children. Note that some widgets that you may not think of as
// containers, for instance Buttons, are actually containers.
//
// This API is mostly meant as a quick way for applications to change a widget
// appearance. If you are developing a widgets library and intend this change to
// be themeable, it is better done by setting meaningful CSS classes in your
// widget/container implementation through gtk_style_context_add_class().
//
// This way, your widget library can install a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority in order to provide a default
// styling for those widgets that need so, and this theming may fully overridden
// by the user’s theme.
//
// Note that for complex widgets this may bring in undesired results (such as
// uniform background color everywhere), in these cases it is better to fully
// style such widgets through a CssProvider with the
// GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority.
//
// Deprecated: Use a custom style provider and style classes instead.
//
// The function takes the following parameters:
//
//    - state for which to set the color.
//    - color (optional) to assign, or NULL to undo the effect of previous calls
//      to gtk_widget_override_color().
//
func (widget *Widget) OverrideColor(state StateFlags, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 *C.GdkRGBA      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(state)
	if color != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	}

	C.gtk_widget_override_color(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(state)
	runtime.KeepAlive(color)
}

// OverrideCursor sets the cursor color to use in a widget, overriding the
// cursor-color and secondary-cursor-color style properties. All other style
// values are left untouched. See also gtk_widget_modify_style().
//
// Note that the underlying properties have the Color type, so the alpha value
// in primary and secondary will be ignored.
//
// Deprecated: This function is not useful in the context of CSS-based
// rendering. If you wish to change the color used to render the primary and
// secondary cursors you should use a custom CSS style, through an
// application-specific StyleProvider and a CSS style class.
//
// The function takes the following parameters:
//
//    - cursor (optional): color to use for primary cursor (does not need to be
//      allocated), or NULL to undo the effect of previous calls to of
//      gtk_widget_override_cursor().
//    - secondaryCursor (optional): color to use for secondary cursor (does not
//      need to be allocated), or NULL to undo the effect of previous calls to of
//      gtk_widget_override_cursor().
//
func (widget *Widget) OverrideCursor(cursor, secondaryCursor *gdk.RGBA) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkRGBA   // out
	var _arg2 *C.GdkRGBA   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if cursor != nil {
		_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(cursor)))
	}
	if secondaryCursor != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(secondaryCursor)))
	}

	C.gtk_widget_override_cursor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cursor)
	runtime.KeepAlive(secondaryCursor)
}

// OverrideFont sets the font to use for a widget. All other style values are
// left untouched. See gtk_widget_override_color().
//
// Deprecated: This function is not useful in the context of CSS-based
// rendering. If you wish to change the font a widget uses to render its text
// you should use a custom CSS style, through an application-specific
// StyleProvider and a CSS style class.
//
// The function takes the following parameters:
//
//    - fontDesc (optional): font description to use, or NULL to undo the effect
//      of previous calls to gtk_widget_override_font().
//
func (widget *Widget) OverrideFont(fontDesc *pango.FontDescription) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if fontDesc != nil {
		_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(fontDesc)))
	}

	C.gtk_widget_override_font(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(fontDesc)
}

// OverrideSymbolicColor sets a symbolic color for a widget.
//
// All other style values are left untouched. See gtk_widget_override_color()
// for overriding the foreground or background color.
//
// Deprecated: This function is not useful in the context of CSS-based
// rendering. If you wish to change the color used to render symbolic icons you
// should use a custom CSS style, through an application-specific StyleProvider
// and a CSS style class.
//
// The function takes the following parameters:
//
//    - name of the symbolic color to modify.
//    - color (optional) to assign (does not need to be allocated), or NULL to
//      undo the effect of previous calls to
//      gtk_widget_override_symbolic_color().
//
func (widget *Widget) OverrideSymbolicColor(name string, color *gdk.RGBA) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.GdkRGBA   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if color != nil {
		_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	}

	C.gtk_widget_override_symbolic_color(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
	runtime.KeepAlive(color)
}

// QueueDrawRegion invalidates the area of widget defined by region by calling
// gdk_window_invalidate_region() on the widget’s window and all its child
// windows. Once the main loop becomes idle (after the current batch of events
// has been processed, roughly), the window will receive expose events for the
// union of all regions that have been invalidated.
//
// Normally you would only use this function in widget implementations. You
// might also use it to schedule a redraw of a DrawingArea or some portion
// thereof.
//
// The function takes the following parameters:
//
//    - region to draw.
//
func (widget *Widget) QueueDrawRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C.gtk_widget_queue_draw_region(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)
}

// RenderIconPixbuf: convenience function that uses the theme engine and style
// settings for widget to look up stock_id and render it to a pixbuf. stock_id
// should be a stock icon ID such as K_STOCK_OPEN or K_STOCK_OK. size should be
// a size such as K_ICON_SIZE_MENU.
//
// The pixels in the returned Pixbuf are shared with the rest of the application
// and should not be modified. The pixbuf should be freed after use with
// g_object_unref().
//
// Deprecated: Use gtk_icon_theme_load_icon() instead.
//
// The function takes the following parameters:
//
//    - stockId: stock ID.
//    - size: stock size (IconSize). A size of (GtkIconSize)-1 means render at
//      the size of the source and don’t scale (if there are multiple source
//      sizes, GTK+ picks one of the available sizes).
//
// The function returns the following values:
//
//    - pixbuf (optional): new pixbuf, or NULL if the stock ID wasn’t known.
//
func (widget *Widget) RenderIconPixbuf(stockId string, size int) *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkWidget  // out
	var _arg1 *C.gchar      // out
	var _arg2 C.GtkIconSize // out
	var _cret *C.GdkPixbuf  // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(stockId)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GtkIconSize(size)

	_cret = C.gtk_widget_render_icon_pixbuf(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(stockId)
	runtime.KeepAlive(size)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// ResetStyle updates the style context of widget and all descendants by
// updating its widget path. Containers may want to use this on a child when
// reordering it in a way that a different style might apply to it. See also
// gtk_container_get_path_for_child().
func (widget *Widget) ResetStyle() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_reset_style(_arg0)
	runtime.KeepAlive(widget)
}

// SetDeviceEnabled enables or disables a Device to interact with widget and all
// its children.
//
// It does so by descending through the Window hierarchy and enabling the same
// mask that is has for core events (i.e. the one that gdk_window_get_events()
// returns).
//
// The function takes the following parameters:
//
//    - device: Device.
//    - enabled: whether to enable the device.
//
func (widget *Widget) SetDeviceEnabled(device gdk.Devicer, enabled bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkDevice // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	if enabled {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_device_enabled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)
	runtime.KeepAlive(enabled)
}

// SetDeviceEvents sets the device event mask (see EventMask) for a widget. The
// event mask determines which events a widget will receive from device. Keep in
// mind that different widgets have different default event masks, and by
// changing the event mask you may disrupt a widget’s functionality, so be
// careful. This function must be called while a widget is unrealized. Consider
// gtk_widget_add_device_events() for widgets that are already realized, or if
// you want to preserve the existing event mask. This function can’t be used
// with windowless widgets (which return FALSE from
// gtk_widget_get_has_window()); to get events on those widgets, place them
// inside a EventBox and receive events on the event box.
//
// The function takes the following parameters:
//
//    - device: Device.
//    - events: event mask.
//
func (widget *Widget) SetDeviceEvents(device gdk.Devicer, events gdk.EventMask) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GdkDevice   // out
	var _arg2 C.GdkEventMask // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg2 = C.GdkEventMask(events)

	C.gtk_widget_set_device_events(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(device)
	runtime.KeepAlive(events)
}

// SetMarginBottom sets the bottom margin of widget. See the
// Widget:margin-bottom property.
//
// The function takes the following parameters:
//
//    - margin: bottom margin.
//
func (widget *Widget) SetMarginBottom(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_bottom(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginLeft sets the left margin of widget. See the Widget:margin-left
// property.
//
// Deprecated: Use gtk_widget_set_margin_start() instead.
//
// The function takes the following parameters:
//
//    - margin: left margin.
//
func (widget *Widget) SetMarginLeft(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_left(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginRight sets the right margin of widget. See the Widget:margin-right
// property.
//
// Deprecated: Use gtk_widget_set_margin_end() instead.
//
// The function takes the following parameters:
//
//    - margin: right margin.
//
func (widget *Widget) SetMarginRight(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_right(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginTop sets the top margin of widget. See the Widget:margin-top
// property.
//
// The function takes the following parameters:
//
//    - margin: top margin.
//
func (widget *Widget) SetMarginTop(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(margin)

	C.gtk_widget_set_margin_top(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetStateFlags: this function is for use in widget implementations. Turns on
// flag values in the current widget state (insensitive, prelighted, etc.).
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk_widget_set_direction().
//
// It is worth mentioning that any other state than GTK_STATE_FLAG_INSENSITIVE,
// will be propagated down to all non-internal children if widget is a
// Container, while GTK_STATE_FLAG_INSENSITIVE itself will be propagated down to
// all Container children by different means than turning on the state flag down
// the hierarchy, both gtk_widget_get_state_flags() and
// gtk_widget_is_sensitive() will make use of these.
//
// The function takes the following parameters:
//
//    - flags: state flags to turn on.
//    - clear: whether to clear state before turning on flags.
//
func (widget *Widget) SetStateFlags(flags StateFlags, clear bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(flags)
	if clear {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_state_flags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(clear)
}

// SetSupportMultidevice enables or disables multiple pointer awareness. If this
// setting is TRUE, widget will start receiving multiple, per device enter/leave
// events. Note that if custom Windows are created in Widget::realize,
// gdk_window_set_support_multidevice() will have to be called manually on them.
//
// The function takes the following parameters:
//
//    - supportMultidevice: TRUE to support input from multiple devices.
//
func (widget *Widget) SetSupportMultidevice(supportMultidevice bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if supportMultidevice {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_support_multidevice(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(supportMultidevice)
}

// ShapeCombineRegion sets a shape for this widget’s GDK window. This allows for
// transparent windows etc., see gdk_window_shape_combine_region() for more
// information.
//
// The function takes the following parameters:
//
//    - region (optional): shape to be added, or NULL to remove an existing
//      shape.
//
func (widget *Widget) ShapeCombineRegion(region *cairo.Region) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if region != nil {
		_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))
	}

	C.gtk_widget_shape_combine_region(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)
}

// UnsetStateFlags: this function is for use in widget implementations. Turns
// off flag values for the current widget state (insensitive, prelighted, etc.).
// See gtk_widget_set_state_flags().
//
// The function takes the following parameters:
//
//    - flags: state flags to turn off.
//
func (widget *Widget) UnsetStateFlags(flags StateFlags) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(flags)

	C.gtk_widget_unset_state_flags(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
}

// preferredHeight retrieves a widget’s initial minimum and natural height.
//
// This call is specific to width-for-height requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location to store the minimum height, or NULL.
//    - naturalHeight (optional): location to store the natural height, or NULL.
//
func (widget *Widget) preferredHeight() (minimumHeight, naturalHeight int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.get_preferred_height

	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_get_preferred_height(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg1)
	_naturalHeight = int(_arg2)

	return _minimumHeight, _naturalHeight
}

// preferredHeightForWidth retrieves a widget’s minimum and natural height if it
// would be given the specified width.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function takes the following parameters:
//
//    - width which is available for allocation.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location for storing the minimum height, or
//      NULL.
//    - naturalHeight (optional): location for storing the natural height, or
//      NULL.
//
func (widget *Widget) preferredHeightForWidth(width int) (minimumHeight, naturalHeight int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.get_preferred_height_for_width

	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(width)

	C._gotk4_gtk3_Widget_virtual_get_preferred_height_for_width(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg2)
	_naturalHeight = int(_arg3)

	return _minimumHeight, _naturalHeight
}

// preferredWidth retrieves a widget’s initial minimum and natural width.
//
// This call is specific to height-for-width requests.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location to store the minimum width, or NULL.
//    - naturalWidth (optional): location to store the natural width, or NULL.
//
func (widget *Widget) preferredWidth() (minimumWidth, naturalWidth int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.get_preferred_width

	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk3_Widget_virtual_get_preferred_width(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg1)
	_naturalWidth = int(_arg2)

	return _minimumWidth, _naturalWidth
}

// preferredWidthForHeight retrieves a widget’s minimum and natural width if it
// would be given the specified height.
//
// The returned request will be modified by the
// GtkWidgetClass::adjust_size_request virtual method and by any SizeGroups that
// have been applied. That is, the returned request is the one that should be
// used for layout, not necessarily the one returned by the widget itself.
//
// The function takes the following parameters:
//
//    - height which is available for allocation.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location for storing the minimum width, or NULL.
//    - naturalWidth (optional): location for storing the natural width, or NULL.
//
func (widget *Widget) preferredWidthForHeight(height int) (minimumWidth, naturalWidth int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.get_preferred_width_for_height

	var _arg0 *C.GtkWidget // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // in
	var _arg3 C.gint       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(height)

	C._gotk4_gtk3_Widget_virtual_get_preferred_width_for_height(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg2)
	_naturalWidth = int(_arg3)

	return _minimumWidth, _naturalWidth
}

// requestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
//
// Bin widgets generally propagate the preference of their child, container
// widgets need to request something either in context of their children or in
// context of their allocation capabilities.
//
// The function returns the following values:
//
//    - sizeRequestMode preferred by widget.
//
func (widget *Widget) requestMode() SizeRequestMode {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.get_request_mode

	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C._gotk4_gtk3_Widget_virtual_get_request_mode(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// queueDrawRegion invalidates the area of widget defined by region by calling
// gdk_window_invalidate_region() on the widget’s window and all its child
// windows. Once the main loop becomes idle (after the current batch of events
// has been processed, roughly), the window will receive expose events for the
// union of all regions that have been invalidated.
//
// Normally you would only use this function in widget implementations. You
// might also use it to schedule a redraw of a DrawingArea or some portion
// thereof.
//
// The function takes the following parameters:
//
//    - region to draw.
//
func (widget *Widget) queueDrawRegion(region *cairo.Region) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.queue_draw_region

	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.cairo_region_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.cairo_region_t)(unsafe.Pointer(region.Native()))

	C._gotk4_gtk3_Widget_virtual_queue_draw_region(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(region)
}

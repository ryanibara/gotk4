// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// GtkAction* _gotk4_gtk3_UIManager_virtual_get_action(void* fnptr, GtkUIManager* arg0, gchar* arg1) {
//   return ((GtkAction* (*)(GtkUIManager*, gchar*))(fnptr))(arg0, arg1);
// };
// GtkWidget* _gotk4_gtk3_UIManager_virtual_get_widget(void* fnptr, GtkUIManager* arg0, gchar* arg1) {
//   return ((GtkWidget* (*)(GtkUIManager*, gchar*))(fnptr))(arg0, arg1);
// };
import "C"

// NewUIManager creates a new ui manager object.
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - uiManager: new ui manager object.
//
func NewUIManager() *UIManager {
	var _cret *C.GtkUIManager // in

	_cret = C.gtk_ui_manager_new()

	var _uiManager *UIManager // out

	_uiManager = wrapUIManager(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _uiManager
}

// AddUi adds a UI element to the current contents of manager.
//
// If type is GTK_UI_MANAGER_AUTO, GTK+ inserts a menuitem, toolitem or
// separator if such an element can be inserted at the place determined by path.
// Otherwise type must indicate an element that can be inserted at the place
// determined by path.
//
// If path points to a menuitem or toolitem, the new element will be inserted
// before or after this item, depending on top.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - mergeId: merge id for the merged UI, see gtk_ui_manager_new_merge_id().
//    - path: path.
//    - name for the added UI element.
//    - action (optional): name of the action to be proxied, or NULL to add a
//      separator.
//    - typ: type of UI element to add.
//    - top: if TRUE, the UI element is added before its siblings, otherwise it
//      is added after its siblings.
//
func (manager *UIManager) AddUi(mergeId uint, path, name, action string, typ UIManagerItemType, top bool) {
	var _arg0 *C.GtkUIManager        // out
	var _arg1 C.guint                // out
	var _arg2 *C.gchar               // out
	var _arg3 *C.gchar               // out
	var _arg4 *C.gchar               // out
	var _arg5 C.GtkUIManagerItemType // out
	var _arg6 C.gboolean             // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = C.guint(mergeId)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	if action != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(action)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	_arg5 = C.GtkUIManagerItemType(typ)
	if top {
		_arg6 = C.TRUE
	}

	C.gtk_ui_manager_add_ui(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(mergeId)
	runtime.KeepAlive(path)
	runtime.KeepAlive(name)
	runtime.KeepAlive(action)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(top)
}

// AddUiFromFile parses a file containing a [UI definition][XML-UI] and merges
// it with the current contents of manager.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - filename: name of the file to parse.
//
// The function returns the following values:
//
//    - guint: merge id for the merged UI. The merge id can be used to unmerge
//      the UI with gtk_ui_manager_remove_ui(). If an error occurred, the return
//      value is 0.
//
func (manager *UIManager) AddUiFromFile(filename string) (uint, error) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret C.guint         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_ui_manager_add_ui_from_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(filename)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// AddUiFromString parses a string containing a [UI definition][XML-UI] and
// merges it with the current contents of manager. An enclosing <ui> element is
// added if it is missing.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - buffer: string to parse.
//    - length of buffer (may be -1 if buffer is nul-terminated).
//
// The function returns the following values:
//
//    - guint: merge id for the merged UI. The merge id can be used to unmerge
//      the UI with gtk_ui_manager_remove_ui(). If an error occurred, the return
//      value is 0.
//
func (manager *UIManager) AddUiFromString(buffer string, length int) (uint, error) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _arg2 C.gssize        // out
	var _cret C.guint         // in
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)

	_cret = C.gtk_ui_manager_add_ui_from_string(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(length)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// EnsureUpdate makes sure that all pending updates to the UI have been
// completed.
//
// This may occasionally be necessary, since UIManager updates the UI in an idle
// function. A typical example where this function is useful is to enforce that
// the menubar and toolbar have been added to the main window before showing it:
//
//    gtk_container_add (GTK_CONTAINER (window), vbox);
//    g_signal_connect (merge, "add-widget",
//                      G_CALLBACK (add_widget), vbox);
//    gtk_ui_manager_add_ui_from_file (merge, "my-menus");
//    gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
//    gtk_ui_manager_ensure_update (merge);
//    gtk_widget_show (window);
//
// Deprecated: since version 3.10.
func (manager *UIManager) EnsureUpdate() {
	var _arg0 *C.GtkUIManager // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	C.gtk_ui_manager_ensure_update(_arg0)
	runtime.KeepAlive(manager)
}

// AccelGroup returns the AccelGroup associated with manager.
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - accelGroup: AccelGroup.
//
func (manager *UIManager) AccelGroup() *AccelGroup {
	var _arg0 *C.GtkUIManager  // out
	var _cret *C.GtkAccelGroup // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_ui_manager_get_accel_group(_arg0)
	runtime.KeepAlive(manager)

	var _accelGroup *AccelGroup // out

	_accelGroup = wrapAccelGroup(coreglib.Take(unsafe.Pointer(_cret)))

	return _accelGroup
}

// Action looks up an action by following a path. See
// gtk_ui_manager_get_widget() for more information about paths.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - path: path.
//
// The function returns the following values:
//
//    - action whose proxy widget is found by following the path, or NULL if no
//      widget was found.
//
func (manager *UIManager) Action(path string) *Action {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret *C.GtkAction    // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_ui_manager_get_action(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(path)

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(_cret)))

	return _action
}

// ActionGroups returns the list of action groups associated with manager.
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - list of action groups. The list is owned by GTK+ and should not be
//      modified.
//
func (manager *UIManager) ActionGroups() []*ActionGroup {
	var _arg0 *C.GtkUIManager // out
	var _cret *C.GList        // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_ui_manager_get_action_groups(_arg0)
	runtime.KeepAlive(manager)

	var _list []*ActionGroup // out

	_list = make([]*ActionGroup, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkActionGroup)(v)
		var dst *ActionGroup // out
		dst = wrapActionGroup(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// AddTearoffs returns whether menus generated by this UIManager will have
// tearoff menu items.
//
// Deprecated: Tearoff menus are deprecated and should not be used in newly
// written code.
//
// The function returns the following values:
//
//    - ok: whether tearoff menu items are added.
//
func (manager *UIManager) AddTearoffs() bool {
	var _arg0 *C.GtkUIManager // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_ui_manager_get_add_tearoffs(_arg0)
	runtime.KeepAlive(manager)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Toplevels obtains a list of all toplevel widgets of the requested types.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - types specifies the types of toplevel widgets to include. Allowed types
//      are K_UI_MANAGER_MENUBAR, K_UI_MANAGER_TOOLBAR and K_UI_MANAGER_POPUP.
//
// The function returns the following values:
//
//    - sList: newly-allocated List of all toplevel widgets of the requested
//      types. Free the returned list with g_slist_free().
//
func (manager *UIManager) Toplevels(types UIManagerItemType) []Widgetter {
	var _arg0 *C.GtkUIManager        // out
	var _arg1 C.GtkUIManagerItemType // out
	var _cret *C.GSList              // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = C.GtkUIManagerItemType(types)

	_cret = C.gtk_ui_manager_get_toplevels(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(types)

	var _sList []Widgetter // out

	_sList = make([]Widgetter, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// Ui creates a [UI definition][XML-UI] of the merged UI.
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - utf8: newly allocated string containing an XML representation of the
//      merged UI.
//
func (manager *UIManager) Ui() string {
	var _arg0 *C.GtkUIManager // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_ui_manager_get_ui(_arg0)
	runtime.KeepAlive(manager)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Widget looks up a widget by following a path. The path consists of the names
// specified in the XML description of the UI. separated by “/”. Elements which
// don’t have a name or action attribute in the XML (e.g. <popup>) can be
// addressed by their XML element name (e.g. "popup"). The root element ("/ui")
// can be omitted in the path.
//
// Note that the widget found by following a path that ends in a <menu>; element
// is the menuitem to which the menu is attached, not the menu it manages.
//
// Also note that the widgets constructed by a ui manager are not tied to the
// lifecycle of the ui manager. If you add the widgets returned by this function
// to some container or explicitly ref them, they will survive the destruction
// of the ui manager.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - path: path.
//
// The function returns the following values:
//
//    - widget found by following the path, or NULL if no widget was found.
//
func (manager *UIManager) Widget(path string) Widgetter {
	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_ui_manager_get_widget(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(path)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// InsertActionGroup inserts an action group into the list of action groups
// associated with manager. Actions in earlier groups hide actions with the same
// name in later groups.
//
// If pos is larger than the number of action groups in manager, or negative,
// action_group will be inserted at the end of the internal list.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - actionGroup: action group to be inserted.
//    - pos: position at which the group will be inserted.
//
func (manager *UIManager) InsertActionGroup(actionGroup *ActionGroup, pos int) {
	var _arg0 *C.GtkUIManager   // out
	var _arg1 *C.GtkActionGroup // out
	var _arg2 C.gint            // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))
	_arg2 = C.gint(pos)

	C.gtk_ui_manager_insert_action_group(_arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(actionGroup)
	runtime.KeepAlive(pos)
}

// NewMergeID returns an unused merge id, suitable for use with
// gtk_ui_manager_add_ui().
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - guint: unused merge id.
//
func (manager *UIManager) NewMergeID() uint {
	var _arg0 *C.GtkUIManager // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_ui_manager_new_merge_id(_arg0)
	runtime.KeepAlive(manager)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RemoveActionGroup removes an action group from the list of action groups
// associated with manager.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - actionGroup: action group to be removed.
//
func (manager *UIManager) RemoveActionGroup(actionGroup *ActionGroup) {
	var _arg0 *C.GtkUIManager   // out
	var _arg1 *C.GtkActionGroup // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkActionGroup)(unsafe.Pointer(coreglib.InternObject(actionGroup).Native()))

	C.gtk_ui_manager_remove_action_group(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(actionGroup)
}

// RemoveUi unmerges the part of manager's content identified by merge_id.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - mergeId: merge id as returned by gtk_ui_manager_add_ui_from_string().
//
func (manager *UIManager) RemoveUi(mergeId uint) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = C.guint(mergeId)

	C.gtk_ui_manager_remove_ui(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(mergeId)
}

// SetAddTearoffs sets the “add_tearoffs” property, which controls whether menus
// generated by this UIManager will have tearoff menu items.
//
// Note that this only affects regular menus. Generated popup menus never have
// tearoff menu items.
//
// Deprecated: Tearoff menus are deprecated and should not be used in newly
// written code.
//
// The function takes the following parameters:
//
//    - addTearoffs: whether tearoff menu items are added.
//
func (manager *UIManager) SetAddTearoffs(addTearoffs bool) {
	var _arg0 *C.GtkUIManager // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	if addTearoffs {
		_arg1 = C.TRUE
	}

	C.gtk_ui_manager_set_add_tearoffs(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(addTearoffs)
}

// Action looks up an action by following a path. See
// gtk_ui_manager_get_widget() for more information about paths.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - path: path.
//
// The function returns the following values:
//
//    - action whose proxy widget is found by following the path, or NULL if no
//      widget was found.
//
func (manager *UIManager) action(path string) *Action {
	gclass := (*C.GtkUIManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.get_action

	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret *C.GtkAction    // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gtk3_UIManager_virtual_get_action(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(path)

	var _action *Action // out

	_action = wrapAction(coreglib.Take(unsafe.Pointer(_cret)))

	return _action
}

// Widget looks up a widget by following a path. The path consists of the names
// specified in the XML description of the UI. separated by “/”. Elements which
// don’t have a name or action attribute in the XML (e.g. <popup>) can be
// addressed by their XML element name (e.g. "popup"). The root element ("/ui")
// can be omitted in the path.
//
// Note that the widget found by following a path that ends in a <menu>; element
// is the menuitem to which the menu is attached, not the menu it manages.
//
// Also note that the widgets constructed by a ui manager are not tied to the
// lifecycle of the ui manager. If you add the widgets returned by this function
// to some container or explicitly ref them, they will survive the destruction
// of the ui manager.
//
// Deprecated: since version 3.10.
//
// The function takes the following parameters:
//
//    - path: path.
//
// The function returns the following values:
//
//    - widget found by following the path, or NULL if no widget was found.
//
func (manager *UIManager) widget(path string) Widgetter {
	gclass := (*C.GtkUIManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.get_widget

	var _arg0 *C.GtkUIManager // out
	var _arg1 *C.gchar        // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkUIManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gtk3_UIManager_virtual_get_widget(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(path)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

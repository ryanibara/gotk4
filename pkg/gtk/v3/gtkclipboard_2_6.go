// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_ClipboardImageReceivedFunc(GtkClipboard*, GdkPixbuf*, gpointer);
import "C"

// ClipboardImageReceivedFunc: function to be called when the results of
// gtk_clipboard_request_image() are received, or when the request fails.
type ClipboardImageReceivedFunc func(clipboard *Clipboard, pixbuf *gdkpixbuf.Pixbuf)

// RequestImage requests the contents of the clipboard as image. When the image
// is later received, it will be converted to a Pixbuf, and callback will be
// called.
//
// The pixbuf parameter to callback will contain the resulting Pixbuf if the
// request succeeded, or NULL if it failed. This could happen for various
// reasons, in particular if the clipboard was empty or if the contents of the
// clipboard could not be converted into an image.
//
// The function takes the following parameters:
//
//    - callback: function to call when the image is received, or the retrieval
//      fails. (It will always be called one way or the other.).
//
func (clipboard *Clipboard) RequestImage(callback ClipboardImageReceivedFunc) {
	var _arg0 *C.GtkClipboard                 // out
	var _arg1 C.GtkClipboardImageReceivedFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk3_ClipboardImageReceivedFunc)
	_arg2 = C.gpointer(gbox.AssignOnce(callback))

	C.gtk_clipboard_request_image(_arg0, _arg1, _arg2)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(callback)
}

// SetCanStore hints that the clipboard data should be stored somewhere when the
// application exits or when gtk_clipboard_store () is called.
//
// This value is reset when the clipboard owner changes. Where the clipboard
// data is stored is platform dependent, see gdk_display_store_clipboard () for
// more information.
//
// The function takes the following parameters:
//
//    - targets (optional): array containing information about which forms should
//      be stored or NULL to indicate that all forms should be stored.
//
func (clipboard *Clipboard) SetCanStore(targets []TargetEntry) {
	var _arg0 *C.GtkClipboard   // out
	var _arg1 *C.GtkTargetEntry // out
	var _arg2 C.gint

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg2 = (C.gint)(len(targets))
	_arg1 = (*C.GtkTargetEntry)(C.calloc(C.size_t(len(targets)), C.size_t(C.sizeof_GtkTargetEntry)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GtkTargetEntry)(_arg1), len(targets))
		for i := range targets {
			out[i] = *(*C.GtkTargetEntry)(gextras.StructNative(unsafe.Pointer((&targets[i]))))
		}
	}

	C.gtk_clipboard_set_can_store(_arg0, _arg1, _arg2)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(targets)
}

// SetImage sets the contents of the clipboard to the given Pixbuf. GTK+ will
// take responsibility for responding for requests for the image, and for
// converting the image into the requested format.
//
// The function takes the following parameters:
//
//    - pixbuf: Pixbuf.
//
func (clipboard *Clipboard) SetImage(pixbuf *gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkClipboard // out
	var _arg1 *C.GdkPixbuf    // out

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	C.gtk_clipboard_set_image(_arg0, _arg1)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(pixbuf)
}

// Store stores the current clipboard data somewhere so that it will stay around
// after the application has quit.
func (clipboard *Clipboard) Store() {
	var _arg0 *C.GtkClipboard // out

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C.gtk_clipboard_store(_arg0)
	runtime.KeepAlive(clipboard)
}

// WaitForImage requests the contents of the clipboard as image and converts the
// result to a Pixbuf. This function waits for the data to be received using the
// main loop, so events, timeouts, etc, may be dispatched during the wait.
//
// The function returns the following values:
//
//    - pixbuf (optional): newly-allocated Pixbuf object which must be disposed
//      with g_object_unref(), or NULL if retrieving the selection data failed.
//      (This could happen for various reasons, in particular if the clipboard
//      was empty or if the contents of the clipboard could not be converted into
//      an image.).
//
func (clipboard *Clipboard) WaitForImage() *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkClipboard // out
	var _cret *C.GdkPixbuf    // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	_cret = C.gtk_clipboard_wait_for_image(_arg0)
	runtime.KeepAlive(clipboard)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// WaitIsImageAvailable: test to see if there is an image available to be pasted
// This is done by requesting the TARGETS atom and checking if it contains any
// of the supported image targets. This function waits for the data to be
// received using the main loop, so events, timeouts, etc, may be dispatched
// during the wait.
//
// This function is a little faster than calling gtk_clipboard_wait_for_image()
// since it doesnâ€™t need to retrieve the actual image data.
//
// The function returns the following values:
//
//    - ok: TRUE is there is an image available, FALSE otherwise.
//
func (clipboard *Clipboard) WaitIsImageAvailable() bool {
	var _arg0 *C.GtkClipboard // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	_cret = C.gtk_clipboard_wait_is_image_available(_arg0)
	runtime.KeepAlive(clipboard)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

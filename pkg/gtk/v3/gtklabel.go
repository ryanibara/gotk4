// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_gtk3_LabelClass_activate_link(GtkLabel*, gchar*);
// extern gboolean _gotk4_gtk3_Label_ConnectActivateLink(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk3_LabelClass_copy_clipboard(GtkLabel*);
// extern void _gotk4_gtk3_LabelClass_populate_popup(GtkLabel*, GtkMenu*);
// extern void _gotk4_gtk3_Label_ConnectActivateCurrentLink(gpointer, guintptr);
// extern void _gotk4_gtk3_Label_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Label_ConnectPopulatePopup(gpointer, GtkMenu*, guintptr);
import "C"

// glib.Type values for gtklabel.go.
var GTypeLabel = coreglib.Type(C.gtk_label_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeLabel, F: marshalLabel},
	})
}

// LabelOverrider contains methods that are overridable.
type LabelOverrider interface {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ActivateLink(uri string) bool
	CopyClipboard()
	// The function takes the following parameters:
	//
	PopulatePopup(menu *Menu)
}

// Label widget displays a small amount of text. As the name implies, most
// labels are used to label another widget such as a Button, a MenuItem, or a
// ComboBox.
//
// CSS nodes
//
//    const gchar *text =
//    "Go to the"
//    "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//    "GTK+ website</a> for more...";
//    GtkWidget *label = gtk_label_new (NULL);
//    gtk_label_set_markup (GTK_LABEL (label), text);
//
// It is possible to implement custom handling for links and their tooltips with
// the Label::activate-link signal and the gtk_label_get_current_uri() function.
type Label struct {
	_ [0]func() // equal guard
	Misc
}

var (
	_ Miscer = (*Label)(nil)
)

func classInitLabeller(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkLabelClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkLabelClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ ActivateLink(uri string) bool }); ok {
		pclass.activate_link = (*[0]byte)(C._gotk4_gtk3_LabelClass_activate_link)
	}

	if _, ok := goval.(interface{ CopyClipboard() }); ok {
		pclass.copy_clipboard = (*[0]byte)(C._gotk4_gtk3_LabelClass_copy_clipboard)
	}

	if _, ok := goval.(interface{ PopulatePopup(menu *Menu) }); ok {
		pclass.populate_popup = (*[0]byte)(C._gotk4_gtk3_LabelClass_populate_popup)
	}
}

//export _gotk4_gtk3_LabelClass_activate_link
func _gotk4_gtk3_LabelClass_activate_link(arg0 *C.GtkLabel, arg1 *C.gchar) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ActivateLink(uri string) bool })

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := iface.ActivateLink(_uri)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_LabelClass_copy_clipboard
func _gotk4_gtk3_LabelClass_copy_clipboard(arg0 *C.GtkLabel) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CopyClipboard() })

	iface.CopyClipboard()
}

//export _gotk4_gtk3_LabelClass_populate_popup
func _gotk4_gtk3_LabelClass_populate_popup(arg0 *C.GtkLabel, arg1 *C.GtkMenu) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ PopulatePopup(menu *Menu) })

	var _menu *Menu // out

	_menu = wrapMenu(coreglib.Take(unsafe.Pointer(arg1)))

	iface.PopulatePopup(_menu)
}

func wrapLabel(obj *coreglib.Object) *Label {
	return &Label{
		Misc: Misc{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalLabel(p uintptr) (interface{}, error) {
	return wrapLabel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_Label_ConnectActivateCurrentLink
func _gotk4_gtk3_Label_ConnectActivateCurrentLink(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivateCurrentLink: [keybinding signal][GtkBindingSignal] which gets
// emitted when the user activates a link in the label.
//
// Applications may also emit the signal with g_signal_emit_by_name() if they
// need to control activation of URIs programmatically.
//
// The default bindings for this signal are all forms of the Enter key.
func (label *Label) ConnectActivateCurrentLink(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(label, "activate-current-link", false, unsafe.Pointer(C._gotk4_gtk3_Label_ConnectActivateCurrentLink), f)
}

//export _gotk4_gtk3_Label_ConnectActivateLink
func _gotk4_gtk3_Label_ConnectActivateLink(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) (cret C.gboolean) {
	var f func(uri string) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(uri string) (ok bool))
	}

	var _uri string // out

	_uri = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	ok := f(_uri)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectActivateLink: signal which gets emitted to activate a URI.
// Applications may connect to it to override the default behaviour, which is to
// call gtk_show_uri_on_window().
func (label *Label) ConnectActivateLink(f func(uri string) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(label, "activate-link", false, unsafe.Pointer(C._gotk4_gtk3_Label_ConnectActivateLink), f)
}

//export _gotk4_gtk3_Label_ConnectCopyClipboard
func _gotk4_gtk3_Label_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCopyClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to copy the selection to the clipboard.
//
// The default binding for this signal is Ctrl-c.
func (label *Label) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(label, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Label_ConnectCopyClipboard), f)
}

//export _gotk4_gtk3_Label_ConnectPopulatePopup
func _gotk4_gtk3_Label_ConnectPopulatePopup(arg0 C.gpointer, arg1 *C.GtkMenu, arg2 C.guintptr) {
	var f func(menu *Menu)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(menu *Menu))
	}

	var _menu *Menu // out

	_menu = wrapMenu(coreglib.Take(unsafe.Pointer(arg1)))

	f(_menu)
}

// ConnectPopulatePopup signal gets emitted before showing the context menu of
// the label. Note that only selectable labels have context menus.
//
// If you need to add items to the context menu, connect to this signal and
// append your menuitems to the menu.
func (label *Label) ConnectPopulatePopup(f func(menu *Menu)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(label, "populate-popup", false, unsafe.Pointer(C._gotk4_gtk3_Label_ConnectPopulatePopup), f)
}

// NewLabel creates a new label with the given text inside it. You can pass NULL
// to get an empty label widget.
//
// The function takes the following parameters:
//
//    - str (optional): text of the label.
//
// The function returns the following values:
//
//    - label: new Label.
//
func NewLabel(str string) *Label {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	if str != "" {
		_arg0 = (*C.void)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg0))
	}
	*(*string)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("new_Label", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _label *Label // out

	_label = wrapLabel(coreglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// NewLabelWithMnemonic creates a new Label, containing the text in str.
//
// If characters in str are preceded by an underscore, they are underlined. If
// you need a literal underscore character in a label, use '__' (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. The mnemonic key can be used to activate
// another widget, chosen automatically, or explicitly using
// gtk_label_set_mnemonic_widget().
//
// If gtk_label_set_mnemonic_widget() is not called, then the first activatable
// ancestor of the Label will be chosen as the mnemonic widget. For instance, if
// the label is inside a button or menu item, the button or menu item will
// automatically become the mnemonic widget and be activated by the mnemonic.
//
// The function takes the following parameters:
//
//    - str (optional): text of the label, with an underscore in front of the
//      mnemonic character.
//
// The function returns the following values:
//
//    - label: new Label.
//
func NewLabelWithMnemonic(str string) *Label {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	if str != "" {
		_arg0 = (*C.void)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg0))
	}
	*(*string)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("new_Label_with_mnemonic", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(str)

	var _label *Label // out

	_label = wrapLabel(coreglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// Angle gets the angle of rotation for the label. See gtk_label_set_angle().
//
// The function returns the following values:
//
//    - gdouble: angle of rotation for the label.
//
func (label *Label) Angle() float64 {
	var args [1]girepository.Argument
	var _arg0 *C.void   // out
	var _cret C.gdouble // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_angle", args[:], nil)
	_cret = *(*C.gdouble)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Attributes gets the attribute list that was set on the label using
// gtk_label_set_attributes(), if any. This function does not reflect attributes
// that come from the labels markup (see gtk_label_set_markup()). If you want to
// get the effective attributes for the label, use pango_layout_get_attribute
// (gtk_label_get_layout (label)).
//
// The function returns the following values:
//
//    - attrList (optional): attribute list, or NULL if none was set.
//
func (label *Label) Attributes() *pango.AttrList {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_attributes", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _attrList *pango.AttrList // out

	if _cret != nil {
		_attrList = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// CurrentURI returns the URI for the currently active link in the label. The
// active link is the one under the mouse pointer or, in a selectable label, the
// link in which the text cursor is currently positioned.
//
// This function is intended for use in a Label::activate-link handler or for
// use in a Widget::query-tooltip handler.
//
// The function returns the following values:
//
//    - utf8: currently active URI. The string is owned by GTK+ and must not be
//      freed or modified.
//
func (label *Label) CurrentURI() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_current_uri", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Label fetches the text from a label widget including any embedded underlines
// indicating mnemonics and Pango markup. (See gtk_label_get_text()).
//
// The function returns the following values:
//
//    - utf8: text of the label widget. This string is owned by the widget and
//      must not be modified or freed.
//
func (label *Label) Label() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_label", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Layout gets the Layout used to display the label. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_label_get_layout_offsets(). The returned layout is owned by the label so
// need not be freed by the caller. The label is free to recreate its layout at
// any time, so it should be considered read-only.
//
// The function returns the following values:
//
//    - layout for this label.
//
func (label *Label) Layout() *pango.Layout {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_layout", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _layout *pango.Layout // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// LineWrap returns whether lines in the label are automatically wrapped. See
// gtk_label_set_line_wrap().
//
// The function returns the following values:
//
//    - ok: TRUE if the lines of the label are automatically wrapped.
//
func (label *Label) LineWrap() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_line_wrap", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Lines gets the number of lines to which an ellipsized, wrapping label should
// be limited. See gtk_label_set_lines().
//
// The function returns the following values:
//
//    - gint: number of lines.
//
func (label *Label) Lines() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_lines", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// MaxWidthChars retrieves the desired maximum width of label, in characters.
// See gtk_label_set_width_chars().
//
// The function returns the following values:
//
//    - gint: maximum width of the label in characters.
//
func (label *Label) MaxWidthChars() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_max_width_chars", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// MnemonicKeyval: if the label has been set so that it has an mnemonic key this
// function returns the keyval used for the mnemonic accelerator. If there is no
// mnemonic set up it returns K_KEY_VoidSymbol.
//
// The function returns the following values:
//
//    - guint: GDK keyval usable for accelerators, or K_KEY_VoidSymbol.
//
func (label *Label) MnemonicKeyval() uint32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.guint // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_mnemonic_keyval", args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _guint uint32 // out

	_guint = uint32(_cret)

	return _guint
}

// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut) of
// this label. See gtk_label_set_mnemonic_widget().
//
// The function returns the following values:
//
//    - widget (optional): target of the label’s mnemonic, or NULL if none has
//      been set and the default algorithm will be used.
//
func (label *Label) MnemonicWidget() Widgetter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_mnemonic_widget", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Selectable gets the value set by gtk_label_set_selectable().
//
// The function returns the following values:
//
//    - ok: TRUE if the user can copy text from the label.
//
func (label *Label) Selectable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_selectable", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SingleLineMode returns whether the label is in single line mode.
//
// The function returns the following values:
//
//    - ok: TRUE when the label is in single line mode.
//
func (label *Label) SingleLineMode() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_single_line_mode", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Text fetches the text from a label widget, as displayed on the screen. This
// does not include any embedded underlines indicating mnemonics or Pango
// markup. (See gtk_label_get_label()).
//
// The function returns the following values:
//
//    - utf8: text in the label widget. This is the internal string used by the
//      label, and must not be modified.
//
func (label *Label) Text() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_text", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TrackVisitedLinks returns whether the label is currently keeping track of
// clicked links.
//
// The function returns the following values:
//
//    - ok: TRUE if clicked links are remembered.
//
func (label *Label) TrackVisitedLinks() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_track_visited_links", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseMarkup returns whether the label’s text is interpreted as marked up with
// the [Pango text markup language][PangoMarkupFormat]. See
// gtk_label_set_use_markup ().
//
// The function returns the following values:
//
//    - ok: TRUE if the label’s text will be parsed for markup.
//
func (label *Label) UseMarkup() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_use_markup", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an embedded underline in the label indicates a
// mnemonic. See gtk_label_set_use_underline().
//
// The function returns the following values:
//
//    - ok: TRUE whether an embedded underline in the label indicates the
//      mnemonic accelerator keys.
//
func (label *Label) UseUnderline() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_use_underline", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidthChars retrieves the desired width of label, in characters. See
// gtk_label_set_width_chars().
//
// The function returns the following values:
//
//    - gint: width of the label in characters.
//
func (label *Label) WidthChars() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_width_chars", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// XAlign gets the Label:xalign property for label.
//
// The function returns the following values:
//
//    - gfloat: xalign property.
//
func (label *Label) XAlign() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void  // out
	var _cret C.gfloat // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_xalign", args[:], nil)
	_cret = *(*C.gfloat)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// YAlign gets the Label:yalign property for label.
//
// The function returns the following values:
//
//    - gfloat: yalign property.
//
func (label *Label) YAlign() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void  // out
	var _cret C.gfloat // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	*(**Label)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Label").InvokeMethod("get_yalign", args[:], nil)
	_cret = *(*C.gfloat)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// SelectRegion selects a range of characters in the label, if the label is
// selectable. See gtk_label_set_selectable(). If the label is not selectable,
// this function has no effect. If start_offset or end_offset are -1, then the
// end of the label will be substituted.
//
// The function takes the following parameters:
//
//    - startOffset: start offset (in characters not bytes).
//    - endOffset: end offset (in characters not bytes).
//
func (label *Label) SelectRegion(startOffset, endOffset int32) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = C.gint(startOffset)
	_arg2 = C.gint(endOffset)
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "Label").InvokeMethod("select_region", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)
}

// SetAngle sets the angle of rotation for the label. An angle of 90 reads from
// from bottom to top, an angle of 270, from top to bottom. The angle setting
// for the label is ignored if the label is selectable, wrapped, or ellipsized.
//
// The function takes the following parameters:
//
//    - angle that the baseline of the label makes with the horizontal, in
//      degrees, measured counterclockwise.
//
func (label *Label) SetAngle(angle float64) {
	var args [2]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.gdouble // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = C.gdouble(angle)
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_angle", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(angle)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to the
// label text.
//
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the Label:use-underline or
// Label:use-markup properties. While it is not recommended to mix markup
// strings with manually set attributes, if you must; know that the attributes
// will be applied to the label after the markup string is parsed.
//
// The function takes the following parameters:
//
//    - attrs (optional) or NULL.
//
func (label *Label) SetAttributes(attrs *pango.AttrList) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	if attrs != nil {
		_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(attrs)))
	}
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_attributes", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(attrs)
}

// SetLabel sets the text of the label. The label is interpreted as including
// embedded underlines and/or Pango markup depending on the values of the
// Label:use-underline and Label:use-markup properties.
//
// The function takes the following parameters:
//
//    - str: new text to set for the label.
//
func (label *Label) SetLabel(str string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_label", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(str)
}

// SetLineWrap toggles line wrapping within the Label widget. TRUE makes it
// break lines if text exceeds the widget’s size. FALSE lets the text get cut
// off by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to TRUE does not make the label wrap at its
// parent container’s width, because GTK+ widgets conceptually can’t make their
// requisition depend on the parent container’s size. For a label that wraps at
// a specific position, set the label’s width using
// gtk_widget_set_size_request().
//
// The function takes the following parameters:
//
//    - wrap: setting.
//
func (label *Label) SetLineWrap(wrap bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	if wrap {
		_arg1 = C.TRUE
	}
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_line_wrap", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(wrap)
}

// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited. This has no effect if the label is not wrapping or
// ellipsized. Set this to -1 if you don’t want to limit the number of lines.
//
// The function takes the following parameters:
//
//    - lines: desired number of lines, or -1.
//
func (label *Label) SetLines(lines int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = C.gint(lines)
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_lines", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(lines)
}

// SetMarkup parses str which is marked up with the [Pango text markup
// language][PangoMarkupFormat], setting the label’s text and attribute list
// based on the parse results.
//
// If the str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
//    GtkWidget *label = gtk_label_new (NULL);
//    const char *str = "some text";
//    const char *format = "<span style=\"italic\">\s</span>";
//    char *markup;
//
//    markup = g_markup_printf_escaped (format, str);
//    gtk_label_set_markup (GTK_LABEL (label), markup);
//    g_free (markup);
//
// This function will set the Label:use-markup property to TRUE as a side
// effect.
//
// If you set the label contents using the Label:label property you should also
// ensure that you set the Label:use-markup property accordingly.
//
// See also: gtk_label_set_text().
//
// The function takes the following parameters:
//
//    - str: markup string (see [Pango markup format][PangoMarkupFormat]).
//
func (label *Label) SetMarkup(str string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_markup", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(str)
}

// SetMarkupWithMnemonic parses str which is marked up with the [Pango text
// markup language][PangoMarkupFormat], setting the label’s text and attribute
// list based on the parse results. If characters in str are preceded by an
// underscore, they are underlined indicating that they represent a keyboard
// accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
//
// The function takes the following parameters:
//
//    - str: markup string (see [Pango markup format][PangoMarkupFormat]).
//
func (label *Label) SetMarkupWithMnemonic(str string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_markup_with_mnemonic", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(str)
}

// SetMaxWidthChars sets the desired maximum width in characters of label to
// n_chars.
//
// The function takes the following parameters:
//
//    - nChars: new desired maximum width, in characters.
//
func (label *Label) SetMaxWidthChars(nChars int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = C.gint(nChars)
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_max_width_chars", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(nChars)
}

// SetMnemonicWidget: if the label has been set so that it has an mnemonic key
// (using i.e. gtk_label_set_markup_with_mnemonic(),
// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic() or the
// “use_underline” property) the label can be associated with a widget that is
// the target of the mnemonic. When the label is inside a widget (like a Button
// or a Notebook tab) it is automatically associated with the correct widget,
// but sometimes (i.e. when the target is a Entry next to the label) you need to
// set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// GtkWidget::mnemonic-activate signal on it. The default handler for this
// signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
//
// The function takes the following parameters:
//
//    - widget (optional): target Widget, or NULL to unset.
//
func (label *Label) SetMnemonicWidget(widget Widgetter) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	if widget != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_mnemonic_widget", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(widget)
}

// SetPattern: pattern of underlines you want under the existing text within the
// Label widget. For example if the current text of the label says “FooBarBaz”
// passing a pattern of “___ ___” will underline “Foo” and “Baz” but not “Bar”.
//
// The function takes the following parameters:
//
//    - pattern as described above.
//
func (label *Label) SetPattern(pattern string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_pattern", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(pattern)
}

// SetSelectable: selectable labels allow the user to select text from the
// label, for copy-and-paste.
//
// The function takes the following parameters:
//
//    - setting: TRUE to allow selecting text in the label.
//
func (label *Label) SetSelectable(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_selectable", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(setting)
}

// SetSingleLineMode sets whether the label is in single line mode.
//
// The function takes the following parameters:
//
//    - singleLineMode: TRUE if the label should be in single line mode.
//
func (label *Label) SetSingleLineMode(singleLineMode bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	if singleLineMode {
		_arg1 = C.TRUE
	}
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_single_line_mode", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(singleLineMode)
}

// SetText sets the text within the Label widget. It overwrites any text that
// was there before.
//
// This function will clear any previously set mnemonic accelerators, and set
// the Label:use-underline property to FALSE as a side effect.
//
// This function will set the Label:use-markup property to FALSE as a side
// effect.
//
// See also: gtk_label_set_markup().
//
// The function takes the following parameters:
//
//    - str: text you want to set.
//
func (label *Label) SetText(str string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_text", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(str)
}

// SetTextWithMnemonic sets the label’s text from the string str. If characters
// in str are preceded by an underscore, they are underlined indicating that
// they represent a keyboard accelerator called a mnemonic. The mnemonic key can
// be used to activate another widget, chosen automatically, or explicitly using
// gtk_label_set_mnemonic_widget().
//
// The function takes the following parameters:
//
//    - str: string.
//
func (label *Label) SetTextWithMnemonic(str string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_text_with_mnemonic", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(str)
}

// SetTrackVisitedLinks sets whether the label should keep track of clicked
// links (and use a different color for them).
//
// The function takes the following parameters:
//
//    - trackLinks: TRUE to track visited links.
//
func (label *Label) SetTrackVisitedLinks(trackLinks bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	if trackLinks {
		_arg1 = C.TRUE
	}
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_track_visited_links", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(trackLinks)
}

// SetUseMarkup sets whether the text of the label contains markup in [Pango’s
// text markup language][PangoMarkupFormat]. See gtk_label_set_markup().
//
// The function takes the following parameters:
//
//    - setting: TRUE if the label’s text should be parsed for markup.
//
func (label *Label) SetUseMarkup(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_use_markup", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(setting)
}

// SetUseUnderline: if true, an underline in the text indicates the next
// character should be used for the mnemonic accelerator key.
//
// The function takes the following parameters:
//
//    - setting: TRUE if underlines in the text indicate mnemonics.
//
func (label *Label) SetUseUnderline(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_use_underline", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(setting)
}

// SetWidthChars sets the desired width in characters of label to n_chars.
//
// The function takes the following parameters:
//
//    - nChars: new desired width, in characters.
//
func (label *Label) SetWidthChars(nChars int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = C.gint(nChars)
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_width_chars", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(nChars)
}

// SetXAlign sets the Label:xalign property for label.
//
// The function takes the following parameters:
//
//    - xalign: new xalign value, between 0 and 1.
//
func (label *Label) SetXAlign(xalign float32) {
	var args [2]girepository.Argument
	var _arg0 *C.void  // out
	var _arg1 C.gfloat // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = C.gfloat(xalign)
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_xalign", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(xalign)
}

// SetYAlign sets the Label:yalign property for label.
//
// The function takes the following parameters:
//
//    - yalign: new yalign value, between 0 and 1.
//
func (label *Label) SetYAlign(yalign float32) {
	var args [2]girepository.Argument
	var _arg0 *C.void  // out
	var _arg1 C.gfloat // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(label).Native()))
	_arg1 = C.gfloat(yalign)
	*(**Label)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Label").InvokeMethod("set_yalign", args[:], nil)

	runtime.KeepAlive(label)
	runtime.KeepAlive(yalign)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// GType values.
var (
	GTypeIconSet       = coreglib.Type(C.gtk_icon_set_get_type())
	GTypeIconSource    = coreglib.Type(C.gtk_icon_source_get_type())
	GTypeSelectionData = coreglib.Type(C.gtk_selection_data_get_type())
	GTypeWidgetPath    = coreglib.Type(C.gtk_widget_path_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIconSet, F: marshalIconSet},
		coreglib.TypeMarshaler{T: GTypeIconSource, F: marshalIconSource},
		coreglib.TypeMarshaler{T: GTypeSelectionData, F: marshalSelectionData},
		coreglib.TypeMarshaler{T: GTypeWidgetPath, F: marshalWidgetPath},
	})
}

// IconSet: instance of this type is always passed by reference.
type IconSet struct {
	*iconSet
}

// iconSet is the struct that's finalized.
type iconSet struct {
	native *C.GtkIconSet
}

func marshalIconSet(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &IconSet{&iconSet{(*C.GtkIconSet)(b)}}, nil
}

// NewIconSet constructs a struct IconSet.
func NewIconSet() *IconSet {
	var _cret *C.GtkIconSet // in

	_cret = C.gtk_icon_set_new()

	var _iconSet *IconSet // out

	_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSet)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _iconSet
}

// NewIconSetFromPixbuf constructs a struct IconSet.
func NewIconSetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *IconSet {
	var _arg1 *C.GdkPixbuf  // out
	var _cret *C.GtkIconSet // in

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	_cret = C.gtk_icon_set_new_from_pixbuf(_arg1)
	runtime.KeepAlive(pixbuf)

	var _iconSet *IconSet // out

	_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSet)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _iconSet
}

// AddSource: icon sets have a list of IconSource, which they use as base icons
// for rendering icons in different states and sizes. Icons are scaled, made to
// look insensitive, etc. in gtk_icon_set_render_icon(), but IconSet needs base
// images to work with. The base images and when to use them are described by a
// IconSource.
//
// This function copies source, so you can reuse the same source immediately
// without affecting the icon set.
//
// An example of when you’d use this function: a web browser’s "Back to Previous
// Page" icon might point in a different direction in Hebrew and in English; it
// might look different when insensitive; and it might change size depending on
// toolbar mode (small/large icons). So a single icon set would contain all
// those variants of the icon, and you might add a separate source for each one.
//
// You should nearly always add a “default” icon source with all fields
// wildcarded, which will be used as a fallback if no more specific source
// matches. IconSet always prefers more specific icon sources to more generic
// icon sources. The order in which you add the sources to the icon set does not
// matter.
//
// gtk_icon_set_new_from_pixbuf() creates a new icon set with a default icon
// source based on the given pixbuf.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - source: IconSource.
//
func (iconSet *IconSet) AddSource(source *IconSource) {
	var _arg0 *C.GtkIconSet    // out
	var _arg1 *C.GtkIconSource // out

	_arg0 = (*C.GtkIconSet)(gextras.StructNative(unsafe.Pointer(iconSet)))
	_arg1 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	C.gtk_icon_set_add_source(_arg0, _arg1)
	runtime.KeepAlive(iconSet)
	runtime.KeepAlive(source)
}

// Copy copies icon_set by value.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - iconSet: new IconSet identical to the first.
//
func (iconSet *IconSet) Copy() *IconSet {
	var _arg0 *C.GtkIconSet // out
	var _cret *C.GtkIconSet // in

	_arg0 = (*C.GtkIconSet)(gextras.StructNative(unsafe.Pointer(iconSet)))

	_cret = C.gtk_icon_set_copy(_arg0)
	runtime.KeepAlive(iconSet)

	var _iconSet *IconSet // out

	_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSet)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _iconSet
}

// Sizes obtains a list of icon sizes this icon set can render. The returned
// array must be freed with g_free().
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - sizes: return location for array of sizes (IconSize).
//
func (iconSet *IconSet) Sizes() []int {
	var _arg0 *C.GtkIconSet  // out
	var _arg1 *C.GtkIconSize // in
	var _arg2 C.gint         // in

	_arg0 = (*C.GtkIconSet)(gextras.StructNative(unsafe.Pointer(iconSet)))

	C.gtk_icon_set_get_sizes(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconSet)

	var _sizes []int // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice((*C.GtkIconSize)(_arg1), _arg2)
		_sizes = make([]int, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_sizes[i] = int(src[i])
		}
	}

	return _sizes
}

// RenderIcon renders an icon using gtk_style_render_icon(). In most cases,
// gtk_widget_render_icon() is better, since it automatically provides most of
// the arguments from the current widget settings. This function never returns
// NULL; if the icon can’t be rendered (perhaps because an image file fails to
// load), a default "missing image" icon will be returned instead.
//
// Deprecated: Use gtk_icon_set_render_icon_pixbuf() instead.
//
// The function takes the following parameters:
//
//    - style (optional) associated with widget, or NULL.
//    - direction: text direction.
//    - state: widget state.
//    - size: icon size (IconSize). A size of (GtkIconSize)-1 means render at the
//      size of the source and don’t scale.
//    - widget (optional) that will display the icon, or NULL. The only use that
//      is typically made of this is to determine the appropriate Screen.
//    - detail (optional) to pass to the theme engine, or NULL. Note that passing
//      a detail of anything but NULL will disable caching.
//
// The function returns the following values:
//
//    - pixbuf to be displayed.
//
func (iconSet *IconSet) RenderIcon(style *Style, direction TextDirection, state StateType, size int, widget Widgetter, detail string) *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconSet      // out
	var _arg1 *C.GtkStyle        // out
	var _arg2 C.GtkTextDirection // out
	var _arg3 C.GtkStateType     // out
	var _arg4 C.GtkIconSize      // out
	var _arg5 *C.GtkWidget       // out
	var _arg6 *C.gchar           // out
	var _cret *C.GdkPixbuf       // in

	_arg0 = (*C.GtkIconSet)(gextras.StructNative(unsafe.Pointer(iconSet)))
	if style != nil {
		_arg1 = (*C.GtkStyle)(unsafe.Pointer(coreglib.InternObject(style).Native()))
	}
	_arg2 = C.GtkTextDirection(direction)
	_arg3 = C.GtkStateType(state)
	_arg4 = C.GtkIconSize(size)
	if widget != nil {
		_arg5 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}
	if detail != "" {
		_arg6 = (*C.gchar)(unsafe.Pointer(C.CString(detail)))
		defer C.free(unsafe.Pointer(_arg6))
	}

	_cret = C.gtk_icon_set_render_icon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(iconSet)
	runtime.KeepAlive(style)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(state)
	runtime.KeepAlive(size)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(detail)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	return _pixbuf
}

// RenderIconPixbuf renders an icon using gtk_render_icon_pixbuf(). In most
// cases, gtk_widget_render_icon_pixbuf() is better, since it automatically
// provides most of the arguments from the current widget settings. This
// function never returns NULL; if the icon can’t be rendered (perhaps because
// an image file fails to load), a default "missing image" icon will be returned
// instead.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - context: StyleContext.
//    - size: icon size (IconSize). A size of (GtkIconSize)-1 means render at the
//      size of the source and don’t scale.
//
// The function returns the following values:
//
//    - pixbuf to be displayed.
//
func (iconSet *IconSet) RenderIconPixbuf(context *StyleContext, size int) *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconSet      // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.GtkIconSize      // out
	var _cret *C.GdkPixbuf       // in

	_arg0 = (*C.GtkIconSet)(gextras.StructNative(unsafe.Pointer(iconSet)))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GtkIconSize(size)

	_cret = C.gtk_icon_set_render_icon_pixbuf(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iconSet)
	runtime.KeepAlive(context)
	runtime.KeepAlive(size)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	return _pixbuf
}

// RenderIconSurface renders an icon using gtk_render_icon_pixbuf() and converts
// it to a cairo surface.
//
// This function never returns NULL; if the icon can’t be rendered (perhaps
// because an image file fails to load), a default "missing image" icon will be
// returned instead.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - context: StyleContext.
//    - size: icon size (IconSize). A size of (GtkIconSize)-1 means render at the
//      size of the source and don’t scale.
//    - scale: window scale to render for.
//    - forWindow (optional) to optimize drawing for, or NULL.
//
// The function returns the following values:
//
//    - surface to be displayed.
//
func (iconSet *IconSet) RenderIconSurface(context *StyleContext, size int, scale int, forWindow gdk.Windower) *cairo.Surface {
	var _arg0 *C.GtkIconSet      // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.GtkIconSize      // out
	var _arg3 C.int              // out
	var _arg4 *C.GdkWindow       // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GtkIconSet)(gextras.StructNative(unsafe.Pointer(iconSet)))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.GtkIconSize(size)
	_arg3 = C.int(scale)
	if forWindow != nil {
		_arg4 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(forWindow).Native()))
	}

	_cret = C.gtk_icon_set_render_icon_surface(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iconSet)
	runtime.KeepAlive(context)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(forWindow)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// IconSource: instance of this type is always passed by reference.
type IconSource struct {
	*iconSource
}

// iconSource is the struct that's finalized.
type iconSource struct {
	native *C.GtkIconSource
}

func marshalIconSource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &IconSource{&iconSource{(*C.GtkIconSource)(b)}}, nil
}

// NewIconSource constructs a struct IconSource.
func NewIconSource() *IconSource {
	var _cret *C.GtkIconSource // in

	_cret = C.gtk_icon_source_new()

	var _iconSource *IconSource // out

	_iconSource = (*IconSource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_icon_source_free((*C.GtkIconSource)(intern.C))
		},
	)

	return _iconSource
}

// Copy creates a copy of source; mostly useful for language bindings.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - iconSource: new IconSource.
//
func (source *IconSource) Copy() *IconSource {
	var _arg0 *C.GtkIconSource // out
	var _cret *C.GtkIconSource // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_copy(_arg0)
	runtime.KeepAlive(source)

	var _iconSource *IconSource // out

	_iconSource = (*IconSource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_icon_source_free((*C.GtkIconSource)(intern.C))
		},
	)

	return _iconSource
}

// Direction obtains the text direction this icon source applies to. The return
// value is only useful/meaningful if the text direction is not wildcarded.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - textDirection: text direction this source matches.
//
func (source *IconSource) Direction() TextDirection {
	var _arg0 *C.GtkIconSource   // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_direction(_arg0)
	runtime.KeepAlive(source)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// DirectionWildcarded gets the value set by
// gtk_icon_source_set_direction_wildcarded().
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - ok: TRUE if this icon source is a base for any text direction variant.
//
func (source *IconSource) DirectionWildcarded() bool {
	var _arg0 *C.GtkIconSource // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_direction_wildcarded(_arg0)
	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Filename retrieves the source filename, or NULL if none is set. The filename
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - filename: image filename. This string must not be modified or freed.
//
func (source *IconSource) Filename() string {
	var _arg0 *C.GtkIconSource // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_filename(_arg0)
	runtime.KeepAlive(source)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// IconName retrieves the source icon name, or NULL if none is set. The
// icon_name is not a copy, and should not be modified or expected to persist
// beyond the lifetime of the icon source.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - utf8: icon name. This string must not be modified or freed.
//
func (source *IconSource) IconName() string {
	var _arg0 *C.GtkIconSource // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_icon_name(_arg0)
	runtime.KeepAlive(source)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Pixbuf retrieves the source pixbuf, or NULL if none is set. In addition, if a
// filename source is in use, this function in some cases will return the pixbuf
// from loaded from the filename. This is, for example, true for the
// GtkIconSource passed to the Style render_icon() virtual function. The
// reference count on the pixbuf is not incremented.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - pixbuf: source pixbuf.
//
func (source *IconSource) Pixbuf() *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconSource // out
	var _cret *C.GdkPixbuf     // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_pixbuf(_arg0)
	runtime.KeepAlive(source)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	return _pixbuf
}

// Size obtains the icon size this source applies to. The return value is only
// useful/meaningful if the icon size is not wildcarded.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - gint: icon size (IconSize) this source matches.
//
func (source *IconSource) Size() int {
	var _arg0 *C.GtkIconSource // out
	var _cret C.GtkIconSize    // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_size(_arg0)
	runtime.KeepAlive(source)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SizeWildcarded gets the value set by gtk_icon_source_set_size_wildcarded().
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - ok: TRUE if this icon source is a base for any icon size variant.
//
func (source *IconSource) SizeWildcarded() bool {
	var _arg0 *C.GtkIconSource // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_size_wildcarded(_arg0)
	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// State obtains the widget state this icon source applies to. The return value
// is only useful/meaningful if the widget state is not wildcarded.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - stateType: widget state this source matches.
//
func (source *IconSource) State() StateType {
	var _arg0 *C.GtkIconSource // out
	var _cret C.GtkStateType   // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_state(_arg0)
	runtime.KeepAlive(source)

	var _stateType StateType // out

	_stateType = StateType(_cret)

	return _stateType
}

// StateWildcarded gets the value set by gtk_icon_source_set_state_wildcarded().
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - ok: TRUE if this icon source is a base for any widget state variant.
//
func (source *IconSource) StateWildcarded() bool {
	var _arg0 *C.GtkIconSource // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))

	_cret = C.gtk_icon_source_get_state_wildcarded(_arg0)
	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDirection sets the text direction this icon source is intended to be used
// with.
//
// Setting the text direction on an icon source makes no difference if the text
// direction is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_direction_wildcarded() to un-wildcard it in addition to
// calling this function.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - direction: text direction this source applies to.
//
func (source *IconSource) SetDirection(direction TextDirection) {
	var _arg0 *C.GtkIconSource   // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = C.GtkTextDirection(direction)

	C.gtk_icon_source_set_direction(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(direction)
}

// SetDirectionWildcarded: if the text direction is wildcarded, this source can
// be used as the base image for an icon in any TextDirection. If the text
// direction is not wildcarded, then the text direction the icon source applies
// to should be set with gtk_icon_source_set_direction(), and the icon source
// will only be used with that text direction.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - setting: TRUE to wildcard the text direction.
//
func (source *IconSource) SetDirectionWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_icon_source_set_direction_wildcarded(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(setting)
}

// SetFilename sets the name of an image file to use as a base image when
// creating icon variants for IconSet. The filename must be absolute.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - filename: image file to use.
//
func (source *IconSource) SetFilename(filename string) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_source_set_filename(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(filename)
}

// SetIconName sets the name of an icon to look up in the current icon theme to
// use as a base image when creating icon variants for IconSet.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - iconName (optional): name of icon to use.
//
func (source *IconSource) SetIconName(iconName string) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	if iconName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_icon_source_set_icon_name(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(iconName)
}

// SetPixbuf sets a pixbuf to use as a base image when creating icon variants
// for IconSet.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - pixbuf to use as a source.
//
func (source *IconSource) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 *C.GdkPixbuf     // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	C.gtk_icon_source_set_pixbuf(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(pixbuf)
}

// SetSize sets the icon size this icon source is intended to be used with.
//
// Setting the icon size on an icon source makes no difference if the size is
// wildcarded. Therefore, you should usually call
// gtk_icon_source_set_size_wildcarded() to un-wildcard it in addition to
// calling this function.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - size: icon size (IconSize) this source applies to.
//
func (source *IconSource) SetSize(size int) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.GtkIconSize    // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = C.GtkIconSize(size)

	C.gtk_icon_source_set_size(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(size)
}

// SetSizeWildcarded: if the icon size is wildcarded, this source can be used as
// the base image for an icon of any size. If the size is not wildcarded, then
// the size the source applies to should be set with gtk_icon_source_set_size()
// and the icon source will only be used with that specific size.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally scale wildcarded source images to produce an
// appropriate icon at a given size, but will not change the size of source
// images that match exactly.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - setting: TRUE to wildcard the widget state.
//
func (source *IconSource) SetSizeWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_icon_source_set_size_wildcarded(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(setting)
}

// SetState sets the widget state this icon source is intended to be used with.
//
// Setting the widget state on an icon source makes no difference if the state
// is wildcarded. Therefore, you should usually call
// gtk_icon_source_set_state_wildcarded() to un-wildcard it in addition to
// calling this function.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - state: widget state this source applies to.
//
func (source *IconSource) SetState(state StateType) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.GtkStateType   // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = C.GtkStateType(state)

	C.gtk_icon_source_set_state(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(state)
}

// SetStateWildcarded: if the widget state is wildcarded, this source can be
// used as the base image for an icon in any StateType. If the widget state is
// not wildcarded, then the state the source applies to should be set with
// gtk_icon_source_set_state() and the icon source will only be used with that
// specific state.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally transform wildcarded source images to produce an
// appropriate icon for a given state, for example lightening an image on
// prelight, but will not modify source images that match exactly.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - setting: TRUE to wildcard the widget state.
//
func (source *IconSource) SetStateWildcarded(setting bool) {
	var _arg0 *C.GtkIconSource // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkIconSource)(gextras.StructNative(unsafe.Pointer(source)))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_icon_source_set_state_wildcarded(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(setting)
}

// SelectionData: instance of this type is always passed by reference.
type SelectionData struct {
	*selectionData
}

// selectionData is the struct that's finalized.
type selectionData struct {
	native *C.GtkSelectionData
}

func marshalSelectionData(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SelectionData{&selectionData{(*C.GtkSelectionData)(b)}}, nil
}

// Copy makes a copy of a SelectionData-struct and its data.
//
// The function returns the following values:
//
//    - selectionData: pointer to a copy of data.
//
func (data *SelectionData) Copy() *SelectionData {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.GtkSelectionData // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(data)))

	_cret = C.gtk_selection_data_copy(_arg0)
	runtime.KeepAlive(data)

	var _selectionData *SelectionData // out

	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_selectionData)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_selection_data_free((*C.GtkSelectionData)(intern.C))
		},
	)

	return _selectionData
}

// Data retrieves the raw data of the selection along with its length.
//
// The function returns the following values:
//
//    - guint8s: raw data of the selection.
//
func (selectionData *SelectionData) Data() []byte {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.guchar           // in
	var _arg1 C.gint              // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_get_data_with_length(_arg0, &_arg1)
	runtime.KeepAlive(selectionData)

	var _guint8s []byte // out

	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))

	return _guint8s
}

// Display retrieves the display of the selection.
//
// The function returns the following values:
//
//    - display of the selection.
//
func (selectionData *SelectionData) Display() *gdk.Display {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.GdkDisplay       // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_get_display(_arg0)
	runtime.KeepAlive(selectionData)

	var _display *gdk.Display // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_display = &gdk.Display{
			Object: obj,
		}
	}

	return _display
}

// Format retrieves the format of the selection.
//
// The function returns the following values:
//
//    - gint: format of the selection.
//
func (selectionData *SelectionData) Format() int {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_get_format(_arg0)
	runtime.KeepAlive(selectionData)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Length retrieves the length of the raw data of the selection.
//
// The function returns the following values:
//
//    - gint: length of the data of the selection.
//
func (selectionData *SelectionData) Length() int {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_get_length(_arg0)
	runtime.KeepAlive(selectionData)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Pixbuf gets the contents of the selection data as a Pixbuf.
//
// The function returns the following values:
//
//    - pixbuf (optional): if the selection data contained a recognized image
//      type and it could be converted to a Pixbuf, a newly allocated pixbuf is
//      returned, otherwise NULL. If the result is non-NULL it must be freed with
//      g_object_unref().
//
func (selectionData *SelectionData) Pixbuf() *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.GdkPixbuf        // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_get_pixbuf(_arg0)
	runtime.KeepAlive(selectionData)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// Text gets the contents of the selection data as a UTF-8 string.
//
// The function returns the following values:
//
//    - utf8 (optional): if the selection data contained a recognized text type
//      and it could be converted to UTF-8, a newly allocated string containing
//      the converted text, otherwise NULL. If the result is non-NULL it must be
//      freed with g_free().
//
func (selectionData *SelectionData) Text() string {
	var _arg0 *C.GtkSelectionData // out
	var _cret *C.guchar           // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_get_text(_arg0)
	runtime.KeepAlive(selectionData)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIs gets the contents of the selection data as array of URIs.
//
// The function returns the following values:
//
//    - utf8s: if the selection data contains a list of URIs, a newly allocated
//      NULL-terminated string array containing the URIs, otherwise NULL. If the
//      result is non-NULL it must be freed with g_strfreev().
//
func (selectionData *SelectionData) URIs() []string {
	var _arg0 *C.GtkSelectionData // out
	var _cret **C.gchar           // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_get_uris(_arg0)
	runtime.KeepAlive(selectionData)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// SetPixbuf sets the contents of the selection from a Pixbuf The pixbuf is
// converted to the form determined by selection_data->target.
//
// The function takes the following parameters:
//
//    - pixbuf: Pixbuf.
//
// The function returns the following values:
//
//    - ok: TRUE if the selection was successfully set, otherwise FALSE.
//
func (selectionData *SelectionData) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 *C.GdkPixbuf        // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	_cret = C.gtk_selection_data_set_pixbuf(_arg0, _arg1)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(pixbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetText sets the contents of the selection from a UTF-8 encoded string. The
// string is converted to the form determined by selection_data->target.
//
// The function takes the following parameters:
//
//    - str: UTF-8 string.
//    - len: length of str, or -1 if str is nul-terminated.
//
// The function returns the following values:
//
//    - ok: TRUE if the selection was successfully set, otherwise FALSE.
//
func (selectionData *SelectionData) SetText(str string, len int) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 *C.gchar            // out
	var _arg2 C.gint              // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(len)

	_cret = C.gtk_selection_data_set_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetURIs sets the contents of the selection from a list of URIs. The string is
// converted to the form determined by selection_data->target.
//
// The function takes the following parameters:
//
//    - uris: NULL-terminated array of strings holding URIs.
//
// The function returns the following values:
//
//    - ok: TRUE if the selection was successfully set, otherwise FALSE.
//
func (selectionData *SelectionData) SetURIs(uris []string) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 **C.gchar           // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(uris) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(uris)+1)
			var zero *C.gchar
			out[len(uris)] = zero
			for i := range uris {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(uris[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gtk_selection_data_set_uris(_arg0, _arg1)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(uris)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeImage: given a SelectionData object holding a list of targets,
// determines if any of the targets in targets can be used to provide a Pixbuf.
//
// The function takes the following parameters:
//
//    - writable: whether to accept only targets for which GTK+ knows how to
//      convert a pixbuf into the format.
//
// The function returns the following values:
//
//    - ok: TRUE if selection_data holds a list of targets, and a suitable target
//      for images is included, otherwise FALSE.
//
func (selectionData *SelectionData) TargetsIncludeImage(writable bool) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 C.gboolean          // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	if writable {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_selection_data_targets_include_image(_arg0, _arg1)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(writable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeRichText: given a SelectionData object holding a list of
// targets, determines if any of the targets in targets can be used to provide
// rich text.
//
// The function takes the following parameters:
//
//    - buffer: TextBuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if selection_data holds a list of targets, and a suitable target
//      for rich text is included, otherwise FALSE.
//
func (selectionData *SelectionData) TargetsIncludeRichText(buffer *TextBuffer) bool {
	var _arg0 *C.GtkSelectionData // out
	var _arg1 *C.GtkTextBuffer    // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_selection_data_targets_include_rich_text(_arg0, _arg1)
	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeText: given a SelectionData object holding a list of targets,
// determines if any of the targets in targets can be used to provide text.
//
// The function returns the following values:
//
//    - ok: TRUE if selection_data holds a list of targets, and a suitable target
//      for text is included, otherwise FALSE.
//
func (selectionData *SelectionData) TargetsIncludeText() bool {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_targets_include_text(_arg0)
	runtime.KeepAlive(selectionData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeURI: given a SelectionData object holding a list of targets,
// determines if any of the targets in targets can be used to provide a list or
// URIs.
//
// The function returns the following values:
//
//    - ok: TRUE if selection_data holds a list of targets, and a suitable target
//      for URI lists is included, otherwise FALSE.
//
func (selectionData *SelectionData) TargetsIncludeURI() bool {
	var _arg0 *C.GtkSelectionData // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSelectionData)(gextras.StructNative(unsafe.Pointer(selectionData)))

	_cret = C.gtk_selection_data_targets_include_uri(_arg0)
	runtime.KeepAlive(selectionData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidgetPath is a boxed type that represents a widget hierarchy from the
// topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
//
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
//
// The widget path generation is generally simple:
//
// Defining a button within a window
//
//    {
//      GtkWidgetPath *path;
//      guint pos;
//
//      path = gtk_widget_path_new ();
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
//
// All this information will be used to match the style information that applies
// to the described widget.
//
// An instance of this type is always passed by reference.
type WidgetPath struct {
	*widgetPath
}

// widgetPath is the struct that's finalized.
type widgetPath struct {
	native *C.GtkWidgetPath
}

func marshalWidgetPath(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &WidgetPath{&widgetPath{(*C.GtkWidgetPath)(b)}}, nil
}

// NewWidgetPath constructs a struct WidgetPath.
func NewWidgetPath() *WidgetPath {
	var _cret *C.GtkWidgetPath // in

	_cret = C.gtk_widget_path_new()

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_widget_path_free((*C.GtkWidgetPath)(intern.C))
		},
	)

	return _widgetPath
}

// AppendForWidget appends the data from widget to the widget hierarchy
// represented by path. This function is a shortcut for adding information from
// widget to the given path. This includes setting the name or adding the style
// classes from widget.
//
// The function takes the following parameters:
//
//    - widget to append to the widget path.
//
// The function returns the following values:
//
//    - gint: position where the data was inserted.
//
func (path *WidgetPath) AppendForWidget(widget Widgetter) int {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 *C.GtkWidget     // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_path_append_for_widget(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AppendType appends a widget type to the widget hierarchy represented by path.
//
// The function takes the following parameters:
//
//    - typ: widget type to append.
//
// The function returns the following values:
//
//    - gint: position where the element was inserted.
//
func (path *WidgetPath) AppendType(typ coreglib.Type) int {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.GType          // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.GType(typ)

	_cret = C.gtk_widget_path_append_type(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(typ)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AppendWithSiblings appends a widget type with all its siblings to the widget
// hierarchy represented by path. Using this function instead of
// gtk_widget_path_append_type() will allow the CSS theming to use sibling
// matches in selectors and apply :nth-child() pseudo classes. In turn, it
// requires a lot more care in widget implementations as widgets need to make
// sure to call gtk_widget_reset_style() on all involved widgets when the
// siblings path changes.
//
// The function takes the following parameters:
//
//    - siblings: widget path describing a list of siblings. This path may not
//      contain any siblings itself and it must not be modified afterwards.
//    - siblingIndex: index into siblings for where the added element is
//      positioned.
//
// The function returns the following values:
//
//    - gint: position where the element was inserted.
//
func (path *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint) int {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 *C.GtkWidgetPath // out
	var _arg2 C.guint          // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(siblings)))
	_arg2 = C.guint(siblingIndex)

	_cret = C.gtk_widget_path_append_with_siblings(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(siblings)
	runtime.KeepAlive(siblingIndex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Copy returns a copy of path.
//
// The function returns the following values:
//
//    - widgetPath: copy of path.
//
func (path *WidgetPath) Copy() *WidgetPath {
	var _arg0 *C.GtkWidgetPath // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_widget_path_copy(_arg0)
	runtime.KeepAlive(path)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_widget_path_free((*C.GtkWidgetPath)(intern.C))
		},
	)

	return _widgetPath
}

// ObjectType returns the topmost object type, that is, the object type this
// path is representing.
//
// The function returns the following values:
//
//    - gType: object type.
//
func (path *WidgetPath) ObjectType() coreglib.Type {
	var _arg0 *C.GtkWidgetPath // out
	var _cret C.GType          // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_widget_path_get_object_type(_arg0)
	runtime.KeepAlive(path)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// HasParent returns TRUE if any of the parents of the widget represented in
// path is of type type, or any subtype of it.
//
// The function takes the following parameters:
//
//    - typ: widget type to check in parents.
//
// The function returns the following values:
//
//    - ok: TRUE if any parent is of type type.
//
func (path *WidgetPath) HasParent(typ coreglib.Type) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.GType          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.GType(typ)

	_cret = C.gtk_widget_path_has_parent(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsType returns TRUE if the widget type represented by this path is type, or a
// subtype of it.
//
// The function takes the following parameters:
//
//    - typ: widget type to match.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget represented by path is of type type.
//
func (path *WidgetPath) IsType(typ coreglib.Type) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.GType          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.GType(typ)

	_cret = C.gtk_widget_path_is_type(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(typ)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterAddClass adds the class name to the widget at position pos in the
// hierarchy defined in path. See gtk_style_context_add_class().
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name class name.
//
func (path *WidgetPath) IterAddClass(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_add_class(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterAddRegion adds the region name to the widget at position pos in the
// hierarchy defined in path. See gtk_style_context_add_region().
//
// Region names must only contain lowercase letters and “-”, starting always
// with a lowercase letter.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name: region name.
//    - flags affecting the region.
//
func (path *WidgetPath) IterAddRegion(pos int, name string, flags RegionFlags) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out
	var _arg3 C.GtkRegionFlags // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.GtkRegionFlags(flags)

	C.gtk_widget_path_iter_add_region(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
	runtime.KeepAlive(flags)
}

// IterClearClasses removes all classes from the widget at position pos in the
// hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//
func (path *WidgetPath) IterClearClasses(pos int) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_classes(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
}

// IterClearRegions removes all regions from the widget at position pos in the
// hierarchy defined in path.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//
func (path *WidgetPath) IterClearRegions(pos int) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	C.gtk_widget_path_iter_clear_regions(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
}

// IterGetName returns the name corresponding to the widget found at the
// position pos in the widget hierarchy defined by path.
//
// The function takes the following parameters:
//
//    - pos: position to get the widget name for, -1 for the path head.
//
// The function returns the following values:
//
//    - utf8 (optional): widget name, or NULL if none was set.
//
func (path *WidgetPath) IterGetName(pos int) string {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	_cret = C.gtk_widget_path_iter_get_name(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IterGetObjectName returns the object name that is at position pos in the
// widget hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to get the object name for, -1 for the path head.
//
// The function returns the following values:
//
//    - utf8 (optional): name or NULL.
//
func (path *WidgetPath) IterGetObjectName(pos int) string {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	_cret = C.gtk_widget_path_iter_get_object_name(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IterGetObjectType returns the object #GType that is at position pos in the
// widget hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to get the object type for, -1 for the path head.
//
// The function returns the following values:
//
//    - gType: widget type.
//
func (path *WidgetPath) IterGetObjectType(pos int) coreglib.Type {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret C.GType          // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	_cret = C.gtk_widget_path_iter_get_object_type(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// IterGetSiblingIndex returns the index into the list of siblings for the
// element at pos as returned by gtk_widget_path_iter_get_siblings(). If that
// function would return NULL because the element at pos has no siblings, this
// function will return 0.
//
// The function takes the following parameters:
//
//    - pos: position to get the sibling index for, -1 for the path head.
//
// The function returns the following values:
//
//    - guint: 0 or the index into the list of siblings for the element at pos.
//
func (path *WidgetPath) IterGetSiblingIndex(pos int) uint {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	_cret = C.gtk_widget_path_iter_get_sibling_index(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IterGetSiblings returns the list of siblings for the element at pos. If the
// element was not added with siblings, NULL is returned.
//
// The function takes the following parameters:
//
//    - pos: position to get the siblings for, -1 for the path head.
//
// The function returns the following values:
//
//    - widgetPath: NULL or the list of siblings for the element at pos.
//
func (path *WidgetPath) IterGetSiblings(pos int) *WidgetPath {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret *C.GtkWidgetPath // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	_cret = C.gtk_widget_path_iter_get_siblings(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_widget_path_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_widget_path_free((*C.GtkWidgetPath)(intern.C))
		},
	)

	return _widgetPath
}

// IterGetState returns the state flags corresponding to the widget found at the
// position pos in the widget hierarchy defined by path.
//
// The function takes the following parameters:
//
//    - pos: position to get the state for, -1 for the path head.
//
// The function returns the following values:
//
//    - stateFlags: state flags.
//
func (path *WidgetPath) IterGetState(pos int) StateFlags {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret C.GtkStateFlags  // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	_cret = C.gtk_widget_path_iter_get_state(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// IterHasClass returns TRUE if the widget at position pos has the class name
// defined, FALSE otherwise.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//    - name class name.
//
// The function returns the following values:
//
//    - ok: TRUE if the class name is defined for the widget at pos.
//
func (path *WidgetPath) IterHasClass(pos int, name string) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_path_iter_has_class(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterHasName returns TRUE if the widget at position pos has the name name,
// FALSE otherwise.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//    - name: widget name.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget at pos has this name.
//
func (path *WidgetPath) IterHasName(pos int, name string) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_path_iter_has_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterHasQclass: see gtk_widget_path_iter_has_class(). This is a version that
// operates with GQuarks.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//    - qname class name as a #GQuark.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget at pos has the class defined.
//
func (path *WidgetPath) IterHasQclass(pos int, qname glib.Quark) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 C.GQuark         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = C.guint32(qname)

	_cret = C.gtk_widget_path_iter_has_qclass(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(qname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterHasQname: see gtk_widget_path_iter_has_name(). This is a version that
// operates on #GQuarks.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//    - qname: widget name as a #GQuark.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget at pos has this name.
//
func (path *WidgetPath) IterHasQname(pos int, qname glib.Quark) bool {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 C.GQuark         // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = C.guint32(qname)

	_cret = C.gtk_widget_path_iter_has_qname(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(qname)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterHasQregion: see gtk_widget_path_iter_has_region(). This is a version that
// operates with GQuarks.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//    - qname: region name as a #GQuark.
//
// The function returns the following values:
//
//    - flags: return location for the region flags.
//    - ok: TRUE if the widget at pos has the region defined.
//
func (path *WidgetPath) IterHasQregion(pos int, qname glib.Quark) (RegionFlags, bool) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 C.GQuark         // out
	var _arg3 C.GtkRegionFlags // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = C.guint32(qname)

	_cret = C.gtk_widget_path_iter_has_qregion(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(qname)

	var _flags RegionFlags // out
	var _ok bool           // out

	_flags = RegionFlags(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _flags, _ok
}

// IterHasRegion returns TRUE if the widget at position pos has the class name
// defined, FALSE otherwise.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//    - name: region name.
//
// The function returns the following values:
//
//    - flags: return location for the region flags.
//    - ok: TRUE if the class name is defined for the widget at pos.
//
func (path *WidgetPath) IterHasRegion(pos int, name string) (RegionFlags, bool) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out
	var _arg3 C.GtkRegionFlags // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_path_iter_has_region(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)

	var _flags RegionFlags // out
	var _ok bool           // out

	_flags = RegionFlags(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _flags, _ok
}

// IterListClasses returns a list with all the class names defined for the
// widget at position pos in the hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//
// The function returns the following values:
//
//    - sList: list of classes, This is a list of strings, the List contents are
//      owned by GTK+, but you should use g_slist_free() to free the list itself.
//
func (path *WidgetPath) IterListClasses(pos int) []string {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret *C.GSList        // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	_cret = C.gtk_widget_path_iter_list_classes(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _sList []string // out

	_sList = make([]string, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// IterListRegions returns a list with all the region names defined for the
// widget at position pos in the hierarchy defined in path.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//
// The function returns the following values:
//
//    - sList: list of regions, This is a list of strings, the List contents are
//      owned by GTK+, but you should use g_slist_free() to free the list itself.
//
func (path *WidgetPath) IterListRegions(pos int) []string {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _cret *C.GSList        // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)

	_cret = C.gtk_widget_path_iter_list_regions(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _sList []string // out

	_sList = make([]string, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// IterRemoveClass removes the class name from the widget at position pos in the
// hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name class name.
//
func (path *WidgetPath) IterRemoveClass(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_remove_class(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterRemoveRegion removes the region name from the widget at position pos in
// the hierarchy defined in path.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name: region name.
//
func (path *WidgetPath) IterRemoveRegion(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_remove_region(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterSetName sets the widget name for the widget found at position pos in the
// widget hierarchy defined by path.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name: widget name.
//
func (path *WidgetPath) IterSetName(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.gchar         // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_path_iter_set_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterSetObjectName sets the object name for a given position in the widget
// hierarchy defined by path.
//
// When set, the object name overrides the object type when matching CSS.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name (optional): object name to set or NULL to unset.
//
func (path *WidgetPath) IterSetObjectName(pos int, name string) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 *C.char          // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	if name != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_widget_path_iter_set_object_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterSetObjectType sets the object type for a given position in the widget
// hierarchy defined by path.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - typ: object type to set.
//
func (path *WidgetPath) IterSetObjectType(pos int, typ coreglib.Type) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 C.GType          // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = C.GType(typ)

	C.gtk_widget_path_iter_set_object_type(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(typ)
}

// IterSetState sets the widget name for the widget found at position pos in the
// widget hierarchy defined by path.
//
// If you want to update just a single state flag, you need to do this manually,
// as this function updates all state flags.
//
// Setting a flag
//
//    gtk_widget_path_iter_set_state (path, pos, gtk_widget_path_iter_get_state (path, pos) & ~flag);.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - state flags.
//
func (path *WidgetPath) IterSetState(pos int, state StateFlags) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.gint           // out
	var _arg2 C.GtkStateFlags  // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = C.GtkStateFlags(state)

	C.gtk_widget_path_iter_set_state(_arg0, _arg1, _arg2)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(state)
}

// Length returns the number of Widget #GTypes between the represented widget
// and its topmost container.
//
// The function returns the following values:
//
//    - gint: number of elements in the path.
//
func (path *WidgetPath) Length() int {
	var _arg0 *C.GtkWidgetPath // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_widget_path_length(_arg0)
	runtime.KeepAlive(path)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PrependType prepends a widget type to the widget hierachy represented by
// path.
//
// The function takes the following parameters:
//
//    - typ: widget type to prepend.
//
func (path *WidgetPath) PrependType(typ coreglib.Type) {
	var _arg0 *C.GtkWidgetPath // out
	var _arg1 C.GType          // out

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.GType(typ)

	C.gtk_widget_path_prepend_type(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(typ)
}

// String dumps the widget path into a string representation. It tries to match
// the CSS style as closely as possible (Note that there might be paths that
// cannot be represented in CSS).
//
// The main use of this code is for debugging purposes, so that you can
// g_print() the path or dump it in a gdb session.
//
// The function returns the following values:
//
//    - utf8: new string describing path.
//
func (path *WidgetPath) String() string {
	var _arg0 *C.GtkWidgetPath // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkWidgetPath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_widget_path_to_string(_arg0)
	runtime.KeepAlive(path)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

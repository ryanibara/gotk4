// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gtktypes.go.
var (
	GTypeIconSet       = coreglib.Type(C.gtk_icon_set_get_type())
	GTypeIconSource    = coreglib.Type(C.gtk_icon_source_get_type())
	GTypeSelectionData = coreglib.Type(C.gtk_selection_data_get_type())
	GTypeWidgetPath    = coreglib.Type(C.gtk_widget_path_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeIconSet, F: marshalIconSet},
		{T: GTypeIconSource, F: marshalIconSource},
		{T: GTypeSelectionData, F: marshalSelectionData},
		{T: GTypeWidgetPath, F: marshalWidgetPath},
	})
}

// IconSet: instance of this type is always passed by reference.
type IconSet struct {
	*iconSet
}

// iconSet is the struct that's finalized.
type iconSet struct {
	native *C.GtkIconSet
}

func marshalIconSet(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &IconSet{&iconSet{(*C.GtkIconSet)(b)}}, nil
}

// NewIconSet constructs a struct IconSet.
func NewIconSet() *IconSet {
	var _cret *C.void // in

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _iconSet *IconSet // out

	_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSet)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_icon_set_unref((*C.GtkIconSet)(intern.C))
		},
	)

	return _iconSet
}

// NewIconSetFromPixbuf constructs a struct IconSet.
func NewIconSetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *IconSet {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	*(**gdkpixbuf.Pixbuf)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(pixbuf)

	var _iconSet *IconSet // out

	_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSet)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_icon_set_unref((*C.GtkIconSet)(intern.C))
		},
	)

	return _iconSet
}

// AddSource: icon sets have a list of IconSource, which they use as base icons
// for rendering icons in different states and sizes. Icons are scaled, made to
// look insensitive, etc. in gtk_icon_set_render_icon(), but IconSet needs base
// images to work with. The base images and when to use them are described by a
// IconSource.
//
// This function copies source, so you can reuse the same source immediately
// without affecting the icon set.
//
// An example of when you’d use this function: a web browser’s "Back to Previous
// Page" icon might point in a different direction in Hebrew and in English; it
// might look different when insensitive; and it might change size depending on
// toolbar mode (small/large icons). So a single icon set would contain all
// those variants of the icon, and you might add a separate source for each one.
//
// You should nearly always add a “default” icon source with all fields
// wildcarded, which will be used as a fallback if no more specific source
// matches. IconSet always prefers more specific icon sources to more generic
// icon sources. The order in which you add the sources to the icon set does not
// matter.
//
// gtk_icon_set_new_from_pixbuf() creates a new icon set with a default icon
// source based on the given pixbuf.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - source: IconSource.
//
func (iconSet *IconSet) AddSource(source *IconSource) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(iconSet)))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	*(**IconSet)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(iconSet)
	runtime.KeepAlive(source)
}

// Copy copies icon_set by value.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - iconSet: new IconSet identical to the first.
//
func (iconSet *IconSet) Copy() *IconSet {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(iconSet)))
	*(**IconSet)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconSet)

	var _iconSet *IconSet // out

	_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSet)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_icon_set_unref((*C.GtkIconSet)(intern.C))
		},
	)

	return _iconSet
}

// IconSource: instance of this type is always passed by reference.
type IconSource struct {
	*iconSource
}

// iconSource is the struct that's finalized.
type iconSource struct {
	native *C.GtkIconSource
}

func marshalIconSource(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &IconSource{&iconSource{(*C.GtkIconSource)(b)}}, nil
}

// NewIconSource constructs a struct IconSource.
func NewIconSource() *IconSource {
	var _cret *C.void // in

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _iconSource *IconSource // out

	_iconSource = (*IconSource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_icon_source_free((*C.GtkIconSource)(intern.C))
		},
	)

	return _iconSource
}

// Copy creates a copy of source; mostly useful for language bindings.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - iconSource: new IconSource.
//
func (source *IconSource) Copy() *IconSource {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	*(**IconSource)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(source)

	var _iconSource *IconSource // out

	_iconSource = (*IconSource)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_iconSource)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_icon_source_free((*C.GtkIconSource)(intern.C))
		},
	)

	return _iconSource
}

// DirectionWildcarded gets the value set by
// gtk_icon_source_set_direction_wildcarded().
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - ok: TRUE if this icon source is a base for any text direction variant.
//
func (source *IconSource) DirectionWildcarded() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	*(**IconSource)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Filename retrieves the source filename, or NULL if none is set. The filename
// is not a copy, and should not be modified or expected to persist beyond the
// lifetime of the icon source.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - filename: image filename. This string must not be modified or freed.
//
func (source *IconSource) Filename() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	*(**IconSource)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(source)

	var _filename string // out

	_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _filename
}

// IconName retrieves the source icon name, or NULL if none is set. The
// icon_name is not a copy, and should not be modified or expected to persist
// beyond the lifetime of the icon source.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - utf8: icon name. This string must not be modified or freed.
//
func (source *IconSource) IconName() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	*(**IconSource)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(source)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Pixbuf retrieves the source pixbuf, or NULL if none is set. In addition, if a
// filename source is in use, this function in some cases will return the pixbuf
// from loaded from the filename. This is, for example, true for the
// GtkIconSource passed to the Style render_icon() virtual function. The
// reference count on the pixbuf is not incremented.
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - pixbuf: source pixbuf.
//
func (source *IconSource) Pixbuf() *gdkpixbuf.Pixbuf {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	*(**IconSource)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(source)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	return _pixbuf
}

// SizeWildcarded gets the value set by gtk_icon_source_set_size_wildcarded().
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - ok: TRUE if this icon source is a base for any icon size variant.
//
func (source *IconSource) SizeWildcarded() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	*(**IconSource)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StateWildcarded gets the value set by gtk_icon_source_set_state_wildcarded().
//
// Deprecated: Use IconTheme instead.
//
// The function returns the following values:
//
//    - ok: TRUE if this icon source is a base for any widget state variant.
//
func (source *IconSource) StateWildcarded() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	*(**IconSource)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(source)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDirectionWildcarded: if the text direction is wildcarded, this source can
// be used as the base image for an icon in any TextDirection. If the text
// direction is not wildcarded, then the text direction the icon source applies
// to should be set with gtk_icon_source_set_direction(), and the icon source
// will only be used with that text direction.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - setting: TRUE to wildcard the text direction.
//
func (source *IconSource) SetDirectionWildcarded(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	if setting {
		_arg1 = C.TRUE
	}
	*(**IconSource)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(source)
	runtime.KeepAlive(setting)
}

// SetFilename sets the name of an image file to use as a base image when
// creating icon variants for IconSet. The filename must be absolute.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - filename: image file to use.
//
func (source *IconSource) SetFilename(filename string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**IconSource)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(source)
	runtime.KeepAlive(filename)
}

// SetIconName sets the name of an icon to look up in the current icon theme to
// use as a base image when creating icon variants for IconSet.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - iconName (optional): name of icon to use.
//
func (source *IconSource) SetIconName(iconName string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	if iconName != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	*(**IconSource)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(source)
	runtime.KeepAlive(iconName)
}

// SetPixbuf sets a pixbuf to use as a base image when creating icon variants
// for IconSet.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - pixbuf to use as a source.
//
func (source *IconSource) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	*(**IconSource)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(source)
	runtime.KeepAlive(pixbuf)
}

// SetSizeWildcarded: if the icon size is wildcarded, this source can be used as
// the base image for an icon of any size. If the size is not wildcarded, then
// the size the source applies to should be set with gtk_icon_source_set_size()
// and the icon source will only be used with that specific size.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally scale wildcarded source images to produce an
// appropriate icon at a given size, but will not change the size of source
// images that match exactly.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - setting: TRUE to wildcard the widget state.
//
func (source *IconSource) SetSizeWildcarded(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	if setting {
		_arg1 = C.TRUE
	}
	*(**IconSource)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(source)
	runtime.KeepAlive(setting)
}

// SetStateWildcarded: if the widget state is wildcarded, this source can be
// used as the base image for an icon in any StateType. If the widget state is
// not wildcarded, then the state the source applies to should be set with
// gtk_icon_source_set_state() and the icon source will only be used with that
// specific state.
//
// IconSet prefers non-wildcarded sources (exact matches) over wildcarded
// sources, and will use an exact match when possible.
//
// IconSet will normally transform wildcarded source images to produce an
// appropriate icon for a given state, for example lightening an image on
// prelight, but will not modify source images that match exactly.
//
// Deprecated: Use IconTheme instead.
//
// The function takes the following parameters:
//
//    - setting: TRUE to wildcard the widget state.
//
func (source *IconSource) SetStateWildcarded(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(source)))
	if setting {
		_arg1 = C.TRUE
	}
	*(**IconSource)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(source)
	runtime.KeepAlive(setting)
}

// SelectionData: instance of this type is always passed by reference.
type SelectionData struct {
	*selectionData
}

// selectionData is the struct that's finalized.
type selectionData struct {
	native *C.GtkSelectionData
}

func marshalSelectionData(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &SelectionData{&selectionData{(*C.GtkSelectionData)(b)}}, nil
}

// Copy makes a copy of a SelectionData-struct and its data.
//
// The function returns the following values:
//
//    - selectionData: pointer to a copy of data.
//
func (data *SelectionData) Copy() *SelectionData {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(data)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(data)

	var _selectionData *SelectionData // out

	_selectionData = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_selectionData)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_selection_data_free((*C.GtkSelectionData)(intern.C))
		},
	)

	return _selectionData
}

// Display retrieves the display of the selection.
//
// The function returns the following values:
//
//    - display of the selection.
//
func (selectionData *SelectionData) Display() *gdk.Display {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)

	var _display *gdk.Display // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_display = &gdk.Display{
			Object: obj,
		}
	}

	return _display
}

// Format retrieves the format of the selection.
//
// The function returns the following values:
//
//    - gint: format of the selection.
//
func (selectionData *SelectionData) Format() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Length retrieves the length of the raw data of the selection.
//
// The function returns the following values:
//
//    - gint: length of the data of the selection.
//
func (selectionData *SelectionData) Length() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Pixbuf gets the contents of the selection data as a Pixbuf.
//
// The function returns the following values:
//
//    - pixbuf (optional): if the selection data contained a recognized image
//      type and it could be converted to a Pixbuf, a newly allocated pixbuf is
//      returned, otherwise NULL. If the result is non-NULL it must be freed with
//      g_object_unref().
//
func (selectionData *SelectionData) Pixbuf() *gdkpixbuf.Pixbuf {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// Text gets the contents of the selection data as a UTF-8 string.
//
// The function returns the following values:
//
//    - utf8 (optional): if the selection data contained a recognized text type
//      and it could be converted to UTF-8, a newly allocated string containing
//      the converted text, otherwise NULL. If the result is non-NULL it must be
//      freed with g_free().
//
func (selectionData *SelectionData) Text() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// URIs gets the contents of the selection data as array of URIs.
//
// The function returns the following values:
//
//    - utf8s: if the selection data contains a list of URIs, a newly allocated
//      NULL-terminated string array containing the URIs, otherwise NULL. If the
//      result is non-NULL it must be freed with g_strfreev().
//
func (selectionData *SelectionData) URIs() []string {
	var args [1]girepository.Argument
	var _arg0 *C.void   // out
	var _cret **C.gchar // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(***C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.void
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// SetPixbuf sets the contents of the selection from a Pixbuf The pixbuf is
// converted to the form determined by selection_data->target.
//
// The function takes the following parameters:
//
//    - pixbuf: Pixbuf.
//
// The function returns the following values:
//
//    - ok: TRUE if the selection was successfully set, otherwise FALSE.
//
func (selectionData *SelectionData) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	*(**SelectionData)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(pixbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetText sets the contents of the selection from a UTF-8 encoded string. The
// string is converted to the form determined by selection_data->target.
//
// The function takes the following parameters:
//
//    - str: UTF-8 string.
//    - len: length of str, or -1 if str is nul-terminated.
//
// The function returns the following values:
//
//    - ok: TRUE if the selection was successfully set, otherwise FALSE.
//
func (selectionData *SelectionData) SetText(str string, len int32) bool {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(len)
	*(**SelectionData)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(str)
	runtime.KeepAlive(len)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetURIs sets the contents of the selection from a list of URIs. The string is
// converted to the form determined by selection_data->target.
//
// The function takes the following parameters:
//
//    - uris: NULL-terminated array of strings holding URIs.
//
// The function returns the following values:
//
//    - ok: TRUE if the selection was successfully set, otherwise FALSE.
//
func (selectionData *SelectionData) SetURIs(uris []string) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 **C.void   // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	{
		_arg1 = (**C.void)(C.calloc(C.size_t((len(uris) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(uris)+1)
			var zero *C.void
			out[len(uris)] = zero
			for i := range uris {
				out[i] = (*C.void)(unsafe.Pointer(C.CString(uris[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	*(**SelectionData)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(uris)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeImage: given a SelectionData object holding a list of targets,
// determines if any of the targets in targets can be used to provide a Pixbuf.
//
// The function takes the following parameters:
//
//    - writable: whether to accept only targets for which GTK+ knows how to
//      convert a pixbuf into the format.
//
// The function returns the following values:
//
//    - ok: TRUE if selection_data holds a list of targets, and a suitable target
//      for images is included, otherwise FALSE.
//
func (selectionData *SelectionData) TargetsIncludeImage(writable bool) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	if writable {
		_arg1 = C.TRUE
	}
	*(**SelectionData)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(writable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeRichText: given a SelectionData object holding a list of
// targets, determines if any of the targets in targets can be used to provide
// rich text.
//
// The function takes the following parameters:
//
//    - buffer: TextBuffer.
//
// The function returns the following values:
//
//    - ok: TRUE if selection_data holds a list of targets, and a suitable target
//      for rich text is included, otherwise FALSE.
//
func (selectionData *SelectionData) TargetsIncludeRichText(buffer *TextBuffer) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**SelectionData)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeText: given a SelectionData object holding a list of targets,
// determines if any of the targets in targets can be used to provide text.
//
// The function returns the following values:
//
//    - ok: TRUE if selection_data holds a list of targets, and a suitable target
//      for text is included, otherwise FALSE.
//
func (selectionData *SelectionData) TargetsIncludeText() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TargetsIncludeURI: given a SelectionData object holding a list of targets,
// determines if any of the targets in targets can be used to provide a list or
// URIs.
//
// The function returns the following values:
//
//    - ok: TRUE if selection_data holds a list of targets, and a suitable target
//      for URI lists is included, otherwise FALSE.
//
func (selectionData *SelectionData) TargetsIncludeURI() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(selectionData)))
	*(**SelectionData)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(selectionData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidgetPath is a boxed type that represents a widget hierarchy from the
// topmost widget, typically a toplevel, to any child. This widget path
// abstraction is used in StyleContext on behalf of the real widget in order to
// query style information.
//
// If you are using GTK+ widgets, you probably will not need to use this API
// directly, as there is gtk_widget_get_path(), and the style context returned
// by gtk_widget_get_style_context() will be automatically updated on widget
// hierarchy changes.
//
// The widget path generation is generally simple:
//
// Defining a button within a window
//
//    {
//      GtkWidgetPath *path;
//      guint pos;
//
//      path = gtk_widget_path_new ();
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_NOTEBOOK);
//      gtk_widget_path_iter_add_region (path, pos, "tab", GTK_REGION_EVEN | GTK_REGION_FIRST);
//
//      pos = gtk_widget_path_append_type (path, GTK_TYPE_LABEL);
//      gtk_widget_path_iter_set_name (path, pos, "first tab label");
//    }
//
// All this information will be used to match the style information that applies
// to the described widget.
//
// An instance of this type is always passed by reference.
type WidgetPath struct {
	*widgetPath
}

// widgetPath is the struct that's finalized.
type widgetPath struct {
	native *C.GtkWidgetPath
}

func marshalWidgetPath(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &WidgetPath{&widgetPath{(*C.GtkWidgetPath)(b)}}, nil
}

// NewWidgetPath constructs a struct WidgetPath.
func NewWidgetPath() *WidgetPath {
	var _cret *C.void // in

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_widget_path_unref((*C.GtkWidgetPath)(intern.C))
		},
	)

	return _widgetPath
}

// AppendForWidget appends the data from widget to the widget hierarchy
// represented by path. This function is a shortcut for adding information from
// widget to the given path. This includes setting the name or adding the style
// classes from widget.
//
// The function takes the following parameters:
//
//    - widget to append to the widget path.
//
// The function returns the following values:
//
//    - gint: position where the data was inserted.
//
func (path *WidgetPath) AppendForWidget(widget Widgetter) int32 {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(widget)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// AppendWithSiblings appends a widget type with all its siblings to the widget
// hierarchy represented by path. Using this function instead of
// gtk_widget_path_append_type() will allow the CSS theming to use sibling
// matches in selectors and apply :nth-child() pseudo classes. In turn, it
// requires a lot more care in widget implementations as widgets need to make
// sure to call gtk_widget_reset_style() on all involved widgets when the
// siblings path changes.
//
// The function takes the following parameters:
//
//    - siblings: widget path describing a list of siblings. This path may not
//      contain any siblings itself and it must not be modified afterwards.
//    - siblingIndex: index into siblings for where the added element is
//      positioned.
//
// The function returns the following values:
//
//    - gint: position where the element was inserted.
//
func (path *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint32) int32 {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.guint // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(siblings)))
	_arg2 = C.guint(siblingIndex)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1
	*(**WidgetPath)(unsafe.Pointer(&args[2])) = _arg2

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(siblings)
	runtime.KeepAlive(siblingIndex)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Copy returns a copy of path.
//
// The function returns the following values:
//
//    - widgetPath: copy of path.
//
func (path *WidgetPath) Copy() *WidgetPath {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**WidgetPath)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_widget_path_unref((*C.GtkWidgetPath)(intern.C))
		},
	)

	return _widgetPath
}

// IterAddClass adds the class name to the widget at position pos in the
// hierarchy defined in path. See gtk_style_context_add_class().
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name class name.
//
func (path *WidgetPath) IterAddClass(pos int32, name string) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterClearClasses removes all classes from the widget at position pos in the
// hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//
func (path *WidgetPath) IterClearClasses(pos int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
}

// IterClearRegions removes all regions from the widget at position pos in the
// hierarchy defined in path.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//
func (path *WidgetPath) IterClearRegions(pos int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
}

// IterGetName returns the name corresponding to the widget found at the
// position pos in the widget hierarchy defined by path.
//
// The function takes the following parameters:
//
//    - pos: position to get the widget name for, -1 for the path head.
//
// The function returns the following values:
//
//    - utf8 (optional): widget name, or NULL if none was set.
//
func (path *WidgetPath) IterGetName(pos int32) string {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IterGetObjectName returns the object name that is at position pos in the
// widget hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to get the object name for, -1 for the path head.
//
// The function returns the following values:
//
//    - utf8 (optional): name or NULL.
//
func (path *WidgetPath) IterGetObjectName(pos int32) string {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IterGetSiblingIndex returns the index into the list of siblings for the
// element at pos as returned by gtk_widget_path_iter_get_siblings(). If that
// function would return NULL because the element at pos has no siblings, this
// function will return 0.
//
// The function takes the following parameters:
//
//    - pos: position to get the sibling index for, -1 for the path head.
//
// The function returns the following values:
//
//    - guint: 0 or the index into the list of siblings for the element at pos.
//
func (path *WidgetPath) IterGetSiblingIndex(pos int32) uint32 {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret C.guint // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _guint uint32 // out

	_guint = uint32(_cret)

	return _guint
}

// IterGetSiblings returns the list of siblings for the element at pos. If the
// element was not added with siblings, NULL is returned.
//
// The function takes the following parameters:
//
//    - pos: position to get the siblings for, -1 for the path head.
//
// The function returns the following values:
//
//    - widgetPath: NULL or the list of siblings for the element at pos.
//
func (path *WidgetPath) IterGetSiblings(pos int32) *WidgetPath {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_widget_path_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_widget_path_unref((*C.GtkWidgetPath)(intern.C))
		},
	)

	return _widgetPath
}

// IterHasClass returns TRUE if the widget at position pos has the class name
// defined, FALSE otherwise.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//    - name class name.
//
// The function returns the following values:
//
//    - ok: TRUE if the class name is defined for the widget at pos.
//
func (path *WidgetPath) IterHasClass(pos int32, name string) bool {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gint     // out
	var _arg2 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterHasName returns TRUE if the widget at position pos has the name name,
// FALSE otherwise.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//    - name: widget name.
//
// The function returns the following values:
//
//    - ok: TRUE if the widget at pos has this name.
//
func (path *WidgetPath) IterHasName(pos int32, name string) bool {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gint     // out
	var _arg2 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterListClasses returns a list with all the class names defined for the
// widget at position pos in the hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//
// The function returns the following values:
//
//    - sList: list of classes, This is a list of strings, the List contents are
//      owned by GTK+, but you should use g_slist_free() to free the list itself.
//
func (path *WidgetPath) IterListClasses(pos int32) []string {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _sList []string // out

	_sList = make([]string, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// IterListRegions returns a list with all the region names defined for the
// widget at position pos in the hierarchy defined in path.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to query, -1 for the path head.
//
// The function returns the following values:
//
//    - sList: list of regions, This is a list of strings, the List contents are
//      owned by GTK+, but you should use g_slist_free() to free the list itself.
//
func (path *WidgetPath) IterListRegions(pos int32) []string {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)

	var _sList []string // out

	_sList = make([]string, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// IterRemoveClass removes the class name from the widget at position pos in the
// hierarchy defined in path.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name class name.
//
func (path *WidgetPath) IterRemoveClass(pos int32, name string) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterRemoveRegion removes the region name from the widget at position pos in
// the hierarchy defined in path.
//
// Deprecated: The use of regions is deprecated.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name: region name.
//
func (path *WidgetPath) IterRemoveRegion(pos int32, name string) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterSetName sets the widget name for the widget found at position pos in the
// widget hierarchy defined by path.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name: widget name.
//
func (path *WidgetPath) IterSetName(pos int32, name string) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	_arg2 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// IterSetObjectName sets the object name for a given position in the widget
// hierarchy defined by path.
//
// When set, the object name overrides the object type when matching CSS.
//
// The function takes the following parameters:
//
//    - pos: position to modify, -1 for the path head.
//    - name (optional): object name to set or NULL to unset.
//
func (path *WidgetPath) IterSetObjectName(pos int32, name string) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(pos)
	if name != "" {
		_arg2 = (*C.void)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	*(**WidgetPath)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2

	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(name)
}

// Length returns the number of Widget #GTypes between the represented widget
// and its topmost container.
//
// The function returns the following values:
//
//    - gint: number of elements in the path.
//
func (path *WidgetPath) Length() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**WidgetPath)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// String dumps the widget path into a string representation. It tries to match
// the CSS style as closely as possible (Note that there might be paths that
// cannot be represented in CSS).
//
// The main use of this code is for debugging purposes, so that you can
// g_print() the path or dump it in a gdb session.
//
// The function returns the following values:
//
//    - utf8: new string describing path.
//
func (path *WidgetPath) String() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))
	*(**WidgetPath)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(path)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

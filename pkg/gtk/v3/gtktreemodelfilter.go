// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_TreeModelFilterClass_modify(GtkTreeModelFilter*, GtkTreeModel*, GtkTreeIter*, GValue*, gint);
// extern gboolean _gotk4_gtk3_TreeModelFilterClass_visible(GtkTreeModelFilter*, GtkTreeModel*, GtkTreeIter*);
// gboolean _gotk4_gtk3_TreeModelFilter_virtual_visible(void* fnptr, GtkTreeModelFilter* arg0, GtkTreeModel* arg1, GtkTreeIter* arg2) {
//   return ((gboolean (*)(GtkTreeModelFilter*, GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_TreeModelFilter_virtual_modify(void* fnptr, GtkTreeModelFilter* arg0, GtkTreeModel* arg1, GtkTreeIter* arg2, GValue* arg3, gint arg4) {
//   ((void (*)(GtkTreeModelFilter*, GtkTreeModel*, GtkTreeIter*, GValue*, gint))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
import "C"

// GType values.
var (
	GTypeTreeModelFilter = coreglib.Type(C.gtk_tree_model_filter_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTreeModelFilter, F: marshalTreeModelFilter},
	})
}

// TreeModelFilterModifyFunc: function which calculates display values from raw
// values in the model. It must fill value with the display value for the column
// column in the row indicated by iter.
//
// Since this function is called for each data access, it’s not a particularly
// efficient operation.
type TreeModelFilterModifyFunc func(model TreeModeller, iter *TreeIter, column int) (value coreglib.Value)

// TreeModelFilterVisibleFunc: function which decides whether the row indicated
// by iter is visible.
type TreeModelFilterVisibleFunc func(model TreeModeller, iter *TreeIter) (ok bool)

// TreeModelFilterOverrides contains methods that are overridable.
type TreeModelFilterOverrides struct {
	// The function takes the following parameters:
	//
	//    - childModel
	//    - iter
	//    - value
	//    - column
	//
	Modify func(childModel TreeModeller, iter *TreeIter, value *coreglib.Value, column int)
	// The function takes the following parameters:
	//
	//    - childModel
	//    - iter
	//
	// The function returns the following values:
	//
	Visible func(childModel TreeModeller, iter *TreeIter) bool
}

func defaultTreeModelFilterOverrides(v *TreeModelFilter) TreeModelFilterOverrides {
	return TreeModelFilterOverrides{
		Modify:  v.modify,
		Visible: v.visible,
	}
}

// TreeModelFilter is a tree model which wraps another tree model, and can do
// the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference couting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter struct {
	_ [0]func() // equal guard
	*coreglib.Object

	TreeDragSource
	TreeModel
}

var (
	_ coreglib.Objector = (*TreeModelFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeModelFilter, *TreeModelFilterClass, TreeModelFilterOverrides](
		GTypeTreeModelFilter,
		initTreeModelFilterClass,
		wrapTreeModelFilter,
		defaultTreeModelFilterOverrides,
	)
}

func initTreeModelFilterClass(gclass unsafe.Pointer, overrides TreeModelFilterOverrides, classInitFunc func(*TreeModelFilterClass)) {
	pclass := (*C.GtkTreeModelFilterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTreeModelFilter))))

	if overrides.Modify != nil {
		pclass.modify = (*[0]byte)(C._gotk4_gtk3_TreeModelFilterClass_modify)
	}

	if overrides.Visible != nil {
		pclass.visible = (*[0]byte)(C._gotk4_gtk3_TreeModelFilterClass_visible)
	}

	if classInitFunc != nil {
		class := (*TreeModelFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeModelFilter(obj *coreglib.Object) *TreeModelFilter {
	return &TreeModelFilter{
		Object: obj,
		TreeDragSource: TreeDragSource{
			Object: obj,
		},
		TreeModel: TreeModel{
			Object: obj,
		},
	}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	return wrapTreeModelFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// The function takes the following parameters:
//
//    - childModel
//    - iter
//    - value
//    - column
//
func (self *TreeModelFilter) modify(childModel TreeModeller, iter *TreeIter, value *coreglib.Value, column int) {
	gclass := (*C.GtkTreeModelFilterClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.modify

	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreeModel       // out
	var _arg2 *C.GtkTreeIter        // out
	var _arg3 *C.GValue             // out
	var _arg4 C.gint                // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(childModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg4 = C.gint(column)

	C._gotk4_gtk3_TreeModelFilter_virtual_modify(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(childModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(value)
	runtime.KeepAlive(column)
}

// The function takes the following parameters:
//
//    - childModel
//    - iter
//
// The function returns the following values:
//
func (self *TreeModelFilter) visible(childModel TreeModeller, iter *TreeIter) bool {
	gclass := (*C.GtkTreeModelFilterClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.visible

	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreeModel       // out
	var _arg2 *C.GtkTreeIter        // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(childModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C._gotk4_gtk3_TreeModelFilter_virtual_visible(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(childModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeModelFilterClass: instance of this type is always passed by reference.
type TreeModelFilterClass struct {
	*treeModelFilterClass
}

// treeModelFilterClass is the struct that's finalized.
type treeModelFilterClass struct {
	native *C.GtkTreeModelFilterClass
}

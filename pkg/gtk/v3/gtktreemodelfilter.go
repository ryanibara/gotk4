// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_gtk3_TreeModelFilterClass_visible(void*, void*, void*);
// extern gboolean _gotk4_gtk3_TreeModelFilterVisibleFunc(void*, void*, gpointer);
// extern void _gotk4_gtk3_TreeModelFilterClass_modify(void*, void*, void*, void*, gint);
// extern void callbackDelete(gpointer);
import "C"

// GTypeTreeModelFilter returns the GType for the type TreeModelFilter.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTreeModelFilter() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "TreeModelFilter").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTreeModelFilter)
	return gtype
}

// TreeModelFilterModifyFunc: function which calculates display values from raw
// values in the model. It must fill value with the display value for the column
// column in the row indicated by iter.
//
// Since this function is called for each data access, it’s not a particularly
// efficient operation.
type TreeModelFilterModifyFunc func(model TreeModeller, iter *TreeIter, column int32) (value coreglib.Value)

//export _gotk4_gtk3_TreeModelFilterModifyFunc
func _gotk4_gtk3_TreeModelFilterModifyFunc(arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 C.gint, arg5 C.gpointer) {
	var fn TreeModelFilterModifyFunc
	{
		v := gbox.Get(uintptr(arg5))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeModelFilterModifyFunc)
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out
	var _column int32       // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_column = int32(arg4)

	value := fn(_model, _iter, _column)

	*arg3 = (*C.void)(unsafe.Pointer((&value).Native()))
}

// TreeModelFilterVisibleFunc: function which decides whether the row indicated
// by iter is visible.
type TreeModelFilterVisibleFunc func(model TreeModeller, iter *TreeIter) (ok bool)

//export _gotk4_gtk3_TreeModelFilterVisibleFunc
func _gotk4_gtk3_TreeModelFilterVisibleFunc(arg1 *C.void, arg2 *C.void, arg3 C.gpointer) (cret C.gboolean) {
	var fn TreeModelFilterVisibleFunc
	{
		v := gbox.Get(uintptr(arg3))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeModelFilterVisibleFunc)
	}

	var _model TreeModeller // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := fn(_model, _iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// NewFilter creates a new TreeModel, with child_model as the child_model and
// root as the virtual root.
//
// The function takes the following parameters:
//
//    - root (optional) or NULL.
//
// The function returns the following values:
//
//    - treeModel: new TreeModel.
//
func (childModel *TreeModel) NewFilter(root *TreePath) *TreeModel {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(childModel).Native()))
	if root != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(root)))
	}

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(childModel)
	runtime.KeepAlive(root)

	var _treeModel *TreeModel // out

	_treeModel = wrapTreeModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeModel
}

// TreeModelFilterOverrider contains methods that are overridable.
type TreeModelFilterOverrider interface {
	// The function takes the following parameters:
	//
	//    - childModel
	//    - iter
	//    - value
	//    - column
	//
	Modify(childModel TreeModeller, iter *TreeIter, value *coreglib.Value, column int32)
	// The function takes the following parameters:
	//
	//    - childModel
	//    - iter
	//
	// The function returns the following values:
	//
	Visible(childModel TreeModeller, iter *TreeIter) bool
}

// TreeModelFilter is a tree model which wraps another tree model, and can do
// the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a “visible function”, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
//
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference couting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter struct {
	_ [0]func() // equal guard
	*coreglib.Object

	TreeDragSource
	TreeModel
}

var (
	_ coreglib.Objector = (*TreeModelFilter)(nil)
)

func classInitTreeModelFilterer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "TreeModelFilterClass")

	if _, ok := goval.(interface {
		Modify(childModel TreeModeller, iter *TreeIter, value *coreglib.Value, column int32)
	}); ok {
		o := pclass.StructFieldOffset("modify")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_TreeModelFilterClass_modify)
	}

	if _, ok := goval.(interface {
		Visible(childModel TreeModeller, iter *TreeIter) bool
	}); ok {
		o := pclass.StructFieldOffset("visible")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_TreeModelFilterClass_visible)
	}
}

//export _gotk4_gtk3_TreeModelFilterClass_modify
func _gotk4_gtk3_TreeModelFilterClass_modify(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Modify(childModel TreeModeller, iter *TreeIter, value *coreglib.Value, column int32)
	})

	var _childModel TreeModeller // out
	var _iter *TreeIter          // out
	var _value *coreglib.Value   // out
	var _column int32            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_childModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_value = coreglib.ValueFromNative(unsafe.Pointer(arg3))
	_column = int32(arg4)

	iface.Modify(_childModel, _iter, _value, _column)
}

//export _gotk4_gtk3_TreeModelFilterClass_visible
func _gotk4_gtk3_TreeModelFilterClass_visible(arg0 *C.void, arg1 *C.void, arg2 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Visible(childModel TreeModeller, iter *TreeIter) bool
	})

	var _childModel TreeModeller // out
	var _iter *TreeIter          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_childModel = rv
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	ok := iface.Visible(_childModel, _iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapTreeModelFilter(obj *coreglib.Object) *TreeModelFilter {
	return &TreeModelFilter{
		Object: obj,
		TreeDragSource: TreeDragSource{
			Object: obj,
		},
		TreeModel: TreeModel{
			Object: obj,
		},
	}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	return wrapTreeModelFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ClearCache: this function should almost never be called. It clears the filter
// of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// filtered is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (filter *TreeModelFilter) ClearCache() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("clear_cache", _args[:], nil)

	runtime.KeepAlive(filter)
}

// ConvertChildIterToIter sets filter_iter to point to the row in filter that
// corresponds to the row pointed at by child_iter. If filter_iter was not set,
// FALSE is returned.
//
// The function takes the following parameters:
//
//    - childIter: valid TreeIter pointing to a row on the child model.
//
// The function returns the following values:
//
//    - filterIter: uninitialized TreeIter.
//    - ok: TRUE, if filter_iter was set, i.e. if child_iter is a valid iterator
//      pointing to a visible row in child model.
//
func (filter *TreeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (*TreeIter, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(childIter)))

	_gret := girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("convert_child_iter_to_iter", _args[:], _outs[:])
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(filter)
	runtime.KeepAlive(childIter)

	var _filterIter *TreeIter // out
	var _ok bool              // out

	_filterIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _filterIter, _ok
}

// ConvertChildPathToPath converts child_path to a path relative to filter. That
// is, child_path points to a path in the child model. The rerturned path will
// point to the same row in the filtered model. If child_path isn’t a valid path
// on the child model or points to a row which is not visible in filter, then
// NULL is returned.
//
// The function takes the following parameters:
//
//    - childPath to convert.
//
// The function returns the following values:
//
//    - treePath (optional): newly allocated TreePath, or NULL.
//
func (filter *TreeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(childPath)))

	_gret := girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("convert_child_path_to_path", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(filter)
	runtime.KeepAlive(childPath)

	var _treePath *TreePath // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Gtk", "TreePath").InvokeMethod("free", args[:], nil)
				}
			},
		)
	}

	return _treePath
}

// ConvertIterToChildIter sets child_iter to point to the row pointed to by
// filter_iter.
//
// The function takes the following parameters:
//
//    - filterIter: valid TreeIter pointing to a row on filter.
//
// The function returns the following values:
//
//    - childIter: uninitialized TreeIter.
//
func (filter *TreeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) *TreeIter {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(filterIter)))

	girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("convert_iter_to_child_iter", _args[:], _outs[:])

	runtime.KeepAlive(filter)
	runtime.KeepAlive(filterIter)

	var _childIter *TreeIter // out

	_childIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))

	return _childIter
}

// ConvertPathToChildPath converts filter_path to a path on the child model of
// filter. That is, filter_path points to a location in filter. The returned
// path will point to the same location in the model not being filtered. If
// filter_path does not point to a location in the child model, NULL is
// returned.
//
// The function takes the following parameters:
//
//    - filterPath to convert.
//
// The function returns the following values:
//
//    - treePath (optional): newly allocated TreePath, or NULL.
//
func (filter *TreeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(filterPath)))

	_gret := girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("convert_path_to_child_path", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(filter)
	runtime.KeepAlive(filterPath)

	var _treePath *TreePath // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				{
					args := [1]girepository.Argument{(*C.void)(intern.C)}
					girepository.MustFind("Gtk", "TreePath").InvokeMethod("free", args[:], nil)
				}
			},
		)
	}

	return _treePath
}

// Model returns a pointer to the child model of filter.
//
// The function returns the following values:
//
//    - treeModel: pointer to a TreeModel.
//
func (filter *TreeModelFilter) Model() *TreeModel {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_gret := girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("get_model", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(filter)

	var _treeModel *TreeModel // out

	_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeModel
}

// Refilter emits ::row_changed for each row in the child model, which causes
// the filter to re-evaluate whether a row is visible or not.
func (filter *TreeModelFilter) Refilter() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("refilter", _args[:], nil)

	runtime.KeepAlive(filter)
}

// SetVisibleColumn sets column of the child_model to be the column where filter
// should look for visibility information. columns should be a column of type
// G_TYPE_BOOLEAN, where TRUE means that a row is visible, and FALSE if not.
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
//
// The function takes the following parameters:
//
//    - column which is the column containing the visible information.
//
func (filter *TreeModelFilter) SetVisibleColumn(column int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(column)

	girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("set_visible_column", _args[:], nil)

	runtime.KeepAlive(filter)
	runtime.KeepAlive(column)
}

// SetVisibleFunc sets the visible function used when filtering the filter to be
// func. The function should return TRUE if the given row should be visible and
// FALSE otherwise.
//
// If the condition calculated by the function changes over time (e.g. because
// it depends on some global parameters), you must call
// gtk_tree_model_filter_refilter() to keep the visibility information of the
// model up-to-date.
//
// Note that func is called whenever a row is inserted, when it may still be
// empty. The visible function should therefore take special care of empty rows,
// like in the example below.
//
//    static gboolean
//    visible_func (GtkTreeModel *model,
//                  GtkTreeIter  *iter,
//                  gpointer      data)
//    {
//      // Visible if row is non-empty and first column is “HI”
//      gchar *str;
//      gboolean visible = FALSE;
//
//      gtk_tree_model_get (model, iter, 0, &str, -1);
//      if (str && strcmp (str, "HI") == 0)
//        visible = TRUE;
//      g_free (str);
//
//      return visible;
//    }
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
//
// The function takes the following parameters:
//
//    - fn the visible function.
//
func (filter *TreeModelFilter) SetVisibleFunc(fn TreeModelFilterVisibleFunc) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_gtk3_TreeModelFilterVisibleFunc)
	_args[2] = C.gpointer(gbox.Assign(fn))
	_args[3] = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	girepository.MustFind("Gtk", "TreeModelFilter").InvokeMethod("set_visible_func", _args[:], nil)

	runtime.KeepAlive(filter)
	runtime.KeepAlive(fn)
}

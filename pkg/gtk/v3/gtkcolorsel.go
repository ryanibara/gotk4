// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gtk3_ColorSelectionClass_color_changed(GtkColorSelection*);
// extern void _gotk4_gtk3_ColorSelection_ConnectColorChanged(gpointer, guintptr);
import "C"

// glib.Type values for gtkcolorsel.go.
var GTypeColorSelection = coreglib.Type(C.gtk_color_selection_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeColorSelection, F: marshalColorSelection},
	})
}

// ColorSelectionOverrider contains methods that are overridable.
type ColorSelectionOverrider interface {
	ColorChanged()
}

type ColorSelection struct {
	_ [0]func() // equal guard
	Box
}

var (
	_ Containerer       = (*ColorSelection)(nil)
	_ coreglib.Objector = (*ColorSelection)(nil)
)

func classInitColorSelectioner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkColorSelectionClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkColorSelectionClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ ColorChanged() }); ok {
		pclass.color_changed = (*[0]byte)(C._gotk4_gtk3_ColorSelectionClass_color_changed)
	}
}

//export _gotk4_gtk3_ColorSelectionClass_color_changed
func _gotk4_gtk3_ColorSelectionClass_color_changed(arg0 *C.GtkColorSelection) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ColorChanged() })

	iface.ColorChanged()
}

func wrapColorSelection(obj *coreglib.Object) *ColorSelection {
	return &ColorSelection{
		Box: Box{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
		},
	}
}

func marshalColorSelection(p uintptr) (interface{}, error) {
	return wrapColorSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_ColorSelection_ConnectColorChanged
func _gotk4_gtk3_ColorSelection_ConnectColorChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectColorChanged: this signal is emitted when the color changes in the
// ColorSelection according to its update policy.
func (colorsel *ColorSelection) ConnectColorChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(colorsel, "color-changed", false, unsafe.Pointer(C._gotk4_gtk3_ColorSelection_ConnectColorChanged), f)
}

// NewColorSelection creates a new GtkColorSelection.
//
// The function returns the following values:
//
//    - colorSelection: new ColorSelection.
//
func NewColorSelection() *ColorSelection {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("new_ColorSelection", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _colorSelection *ColorSelection // out

	_colorSelection = wrapColorSelection(coreglib.Take(unsafe.Pointer(_cret)))

	return _colorSelection
}

// CurrentAlpha returns the current alpha value.
//
// The function returns the following values:
//
//    - guint16: integer between 0 and 65535.
//
func (colorsel *ColorSelection) CurrentAlpha() uint16 {
	var args [1]girepository.Argument
	var _arg0 *C.void   // out
	var _cret C.guint16 // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	*(**ColorSelection)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("get_current_alpha", args[:], nil)
	_cret = *(*C.guint16)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(colorsel)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// HasOpacityControl determines whether the colorsel has an opacity control.
//
// The function returns the following values:
//
//    - ok: TRUE if the colorsel has an opacity control, FALSE if it does't.
//
func (colorsel *ColorSelection) HasOpacityControl() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	*(**ColorSelection)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("get_has_opacity_control", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(colorsel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasPalette determines whether the color selector has a color palette.
//
// The function returns the following values:
//
//    - ok: TRUE if the selector has a palette, FALSE if it hasn't.
//
func (colorsel *ColorSelection) HasPalette() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	*(**ColorSelection)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("get_has_palette", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(colorsel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PreviousAlpha returns the previous alpha value.
//
// The function returns the following values:
//
//    - guint16: integer between 0 and 65535.
//
func (colorsel *ColorSelection) PreviousAlpha() uint16 {
	var args [1]girepository.Argument
	var _arg0 *C.void   // out
	var _cret C.guint16 // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	*(**ColorSelection)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("get_previous_alpha", args[:], nil)
	_cret = *(*C.guint16)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(colorsel)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// IsAdjusting gets the current state of the colorsel.
//
// The function returns the following values:
//
//    - ok: TRUE if the user is currently dragging a color around, and FALSE if
//      the selection has stopped.
//
func (colorsel *ColorSelection) IsAdjusting() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	*(**ColorSelection)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("is_adjusting", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(colorsel)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCurrentAlpha sets the current opacity to be alpha.
//
// The first time this is called, it will also set the original opacity to be
// alpha too.
//
// The function takes the following parameters:
//
//    - alpha: integer between 0 and 65535.
//
func (colorsel *ColorSelection) SetCurrentAlpha(alpha uint16) {
	var args [2]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.guint16 // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	_arg1 = C.guint16(alpha)
	*(**ColorSelection)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("set_current_alpha", args[:], nil)

	runtime.KeepAlive(colorsel)
	runtime.KeepAlive(alpha)
}

// SetCurrentColor sets the current color to be color.
//
// The first time this is called, it will also set the original color to be
// color too.
//
// Deprecated: Use gtk_color_selection_set_current_rgba() instead.
//
// The function takes the following parameters:
//
//    - color to set the current color with.
//
func (colorsel *ColorSelection) SetCurrentColor(color *gdk.Color) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(**ColorSelection)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("set_current_color", args[:], nil)

	runtime.KeepAlive(colorsel)
	runtime.KeepAlive(color)
}

// SetCurrentRGBA sets the current color to be rgba.
//
// The first time this is called, it will also set the original color to be rgba
// too.
//
// The function takes the following parameters:
//
//    - rgba to set the current color with.
//
func (colorsel *ColorSelection) SetCurrentRGBA(rgba *gdk.RGBA) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(rgba)))
	*(**ColorSelection)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("set_current_rgba", args[:], nil)

	runtime.KeepAlive(colorsel)
	runtime.KeepAlive(rgba)
}

// SetHasOpacityControl sets the colorsel to use or not use opacity.
//
// The function takes the following parameters:
//
//    - hasOpacity: TRUE if colorsel can set the opacity, FALSE otherwise.
//
func (colorsel *ColorSelection) SetHasOpacityControl(hasOpacity bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	if hasOpacity {
		_arg1 = C.TRUE
	}
	*(**ColorSelection)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("set_has_opacity_control", args[:], nil)

	runtime.KeepAlive(colorsel)
	runtime.KeepAlive(hasOpacity)
}

// SetHasPalette shows and hides the palette based upon the value of
// has_palette.
//
// The function takes the following parameters:
//
//    - hasPalette: TRUE if palette is to be visible, FALSE otherwise.
//
func (colorsel *ColorSelection) SetHasPalette(hasPalette bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	if hasPalette {
		_arg1 = C.TRUE
	}
	*(**ColorSelection)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("set_has_palette", args[:], nil)

	runtime.KeepAlive(colorsel)
	runtime.KeepAlive(hasPalette)
}

// SetPreviousAlpha sets the “previous” alpha to be alpha.
//
// This function should be called with some hesitations, as it might seem
// confusing to have that alpha change.
//
// The function takes the following parameters:
//
//    - alpha: integer between 0 and 65535.
//
func (colorsel *ColorSelection) SetPreviousAlpha(alpha uint16) {
	var args [2]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.guint16 // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	_arg1 = C.guint16(alpha)
	*(**ColorSelection)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("set_previous_alpha", args[:], nil)

	runtime.KeepAlive(colorsel)
	runtime.KeepAlive(alpha)
}

// SetPreviousColor sets the “previous” color to be color.
//
// This function should be called with some hesitations, as it might seem
// confusing to have that color change. Calling
// gtk_color_selection_set_current_color() will also set this color the first
// time it is called.
//
// Deprecated: Use gtk_color_selection_set_previous_rgba() instead.
//
// The function takes the following parameters:
//
//    - color to set the previous color with.
//
func (colorsel *ColorSelection) SetPreviousColor(color *gdk.Color) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(**ColorSelection)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("set_previous_color", args[:], nil)

	runtime.KeepAlive(colorsel)
	runtime.KeepAlive(color)
}

// SetPreviousRGBA sets the “previous” color to be rgba.
//
// This function should be called with some hesitations, as it might seem
// confusing to have that color change. Calling
// gtk_color_selection_set_current_rgba() will also set this color the first
// time it is called.
//
// The function takes the following parameters:
//
//    - rgba to set the previous color with.
//
func (colorsel *ColorSelection) SetPreviousRGBA(rgba *gdk.RGBA) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(colorsel).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(rgba)))
	*(**ColorSelection)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "ColorSelection").InvokeMethod("set_previous_rgba", args[:], nil)

	runtime.KeepAlive(colorsel)
	runtime.KeepAlive(rgba)
}

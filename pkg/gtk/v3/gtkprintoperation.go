// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern GObject _gotk4_gtk3_PrintOperation_ConnectCreateCustomWidget(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_PrintOperationClass_paginate(void*, void*);
// extern gboolean _gotk4_gtk3_PrintOperationClass_preview(void*, void*, void*, void*);
// extern gboolean _gotk4_gtk3_PrintOperation_ConnectPaginate(gpointer, void*, guintptr);
// extern gboolean _gotk4_gtk3_PrintOperation_ConnectPreview(gpointer, void*, void*, void*, guintptr);
// extern void _gotk4_gtk3_PageSetupDoneFunc(void*, gpointer);
// extern void _gotk4_gtk3_PrintOperationClass_begin_print(void*, void*);
// extern void _gotk4_gtk3_PrintOperationClass_custom_widget_apply(void*, void*);
// extern void _gotk4_gtk3_PrintOperationClass_draw_page(void*, void*, gint);
// extern void _gotk4_gtk3_PrintOperationClass_end_print(void*, void*);
// extern void _gotk4_gtk3_PrintOperationClass_request_page_setup(void*, void*, gint, void*);
// extern void _gotk4_gtk3_PrintOperationClass_status_changed(void*);
// extern void _gotk4_gtk3_PrintOperationClass_update_custom_widget(void*, void*, void*, void*);
// extern void _gotk4_gtk3_PrintOperation_ConnectBeginPrint(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_PrintOperation_ConnectCustomWidgetApply(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_PrintOperation_ConnectDrawPage(gpointer, void*, gint, guintptr);
// extern void _gotk4_gtk3_PrintOperation_ConnectEndPrint(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_PrintOperation_ConnectRequestPageSetup(gpointer, void*, gint, void*, guintptr);
// extern void _gotk4_gtk3_PrintOperation_ConnectStatusChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_PrintOperation_ConnectUpdateCustomWidget(gpointer, void*, void*, void*, guintptr);
import "C"

// GTypePrintError returns the GType for the type PrintError.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypePrintError() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "PrintError").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalPrintError)
	return gtype
}

// GTypePrintOperationAction returns the GType for the type PrintOperationAction.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypePrintOperationAction() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "PrintOperationAction").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalPrintOperationAction)
	return gtype
}

// GTypePrintOperationResult returns the GType for the type PrintOperationResult.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypePrintOperationResult() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "PrintOperationResult").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalPrintOperationResult)
	return gtype
}

// GTypePrintStatus returns the GType for the type PrintStatus.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypePrintStatus() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "PrintStatus").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalPrintStatus)
	return gtype
}

// GTypePrintOperation returns the GType for the type PrintOperation.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypePrintOperation() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "PrintOperation").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalPrintOperation)
	return gtype
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK+ printing support.
type PrintError C.gint

const (
	// PrintErrorGeneral: unspecified error occurred.
	PrintErrorGeneral PrintError = iota
	// PrintErrorInternalError: internal error occurred.
	PrintErrorInternalError
	// PrintErrorNOMEM: memory allocation failed.
	PrintErrorNOMEM
	// PrintErrorInvalidFile: error occurred while loading a page setup or paper
	// size from a key file.
	PrintErrorInvalidFile
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintError.
func (p PrintError) String() string {
	switch p {
	case PrintErrorGeneral:
		return "General"
	case PrintErrorInternalError:
		return "InternalError"
	case PrintErrorNOMEM:
		return "NOMEM"
	case PrintErrorInvalidFile:
		return "InvalidFile"
	default:
		return fmt.Sprintf("PrintError(%d)", p)
	}
}

// PrintErrorQuark registers an error quark for PrintOperation if necessary.
//
// The function returns the following values:
//
//    - quark: error quark used for PrintOperation errors.
//
func PrintErrorQuark() glib.Quark {
	_info := girepository.MustFind("Gtk", "quark")
	_gret := _info.InvokeFunction(nil, nil)
	_cret := *(*C.GQuark)(unsafe.Pointer(&_gret))

	var _quark glib.Quark // out

	_quark = uint32(*(*C.guint32)(unsafe.Pointer(&*(*C.GQuark)(unsafe.Pointer(&_cret)))))

	return _quark
}

// PrintOperationAction: action parameter to gtk_print_operation_run()
// determines what action the print operation should perform.
type PrintOperationAction C.gint

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = iota
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintOperationAction.
func (p PrintOperationAction) String() string {
	switch p {
	case PrintOperationActionPrintDialog:
		return "PrintDialog"
	case PrintOperationActionPrint:
		return "Print"
	case PrintOperationActionPreview:
		return "Preview"
	case PrintOperationActionExport:
		return "Export"
	default:
		return fmt.Sprintf("PrintOperationAction(%d)", p)
	}
}

// PrintOperationResult: value of this type is returned by
// gtk_print_operation_run().
type PrintOperationResult C.gint

const (
	// PrintOperationResultError: error has occurred.
	PrintOperationResultError PrintOperationResult = iota
	// PrintOperationResultApply: print settings should be stored.
	PrintOperationResultApply
	// PrintOperationResultCancel: print operation has been canceled, the print
	// settings should not be stored.
	PrintOperationResultCancel
	// PrintOperationResultInProgress: print operation is not complete yet. This
	// value will only be returned when running asynchronously.
	PrintOperationResultInProgress
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintOperationResult.
func (p PrintOperationResult) String() string {
	switch p {
	case PrintOperationResultError:
		return "Error"
	case PrintOperationResultApply:
		return "Apply"
	case PrintOperationResultCancel:
		return "Cancel"
	case PrintOperationResultInProgress:
		return "InProgress"
	default:
		return fmt.Sprintf("PrintOperationResult(%d)", p)
	}
}

// PrintStatus status gives a rough indication of the completion of a running
// print operation.
type PrintStatus C.gint

const (
	// PrintStatusInitial: printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = iota
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData
	// PrintStatusSendingData: print job is being sent off to the printer.
	PrintStatusSendingData
	// PrintStatusPending: print job has been sent to the printer, but is not
	// printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue
	// PrintStatusPrinting: printer is processing the print job.
	PrintStatusPrinting
	// PrintStatusFinished: printing has been completed successfully.
	PrintStatusFinished
	// PrintStatusFinishedAborted: printing has been aborted.
	PrintStatusFinishedAborted
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintStatus.
func (p PrintStatus) String() string {
	switch p {
	case PrintStatusInitial:
		return "Initial"
	case PrintStatusPreparing:
		return "Preparing"
	case PrintStatusGeneratingData:
		return "GeneratingData"
	case PrintStatusSendingData:
		return "SendingData"
	case PrintStatusPending:
		return "Pending"
	case PrintStatusPendingIssue:
		return "PendingIssue"
	case PrintStatusPrinting:
		return "Printing"
	case PrintStatusFinished:
		return "Finished"
	case PrintStatusFinishedAborted:
		return "FinishedAborted"
	default:
		return fmt.Sprintf("PrintStatus(%d)", p)
	}
}

// PageSetupDoneFunc: type of function that is passed to
// gtk_print_run_page_setup_dialog_async().
//
// This function will be called when the page setup dialog is dismissed, and
// also serves as destroy notify for data.
type PageSetupDoneFunc func(pageSetup *PageSetup)

//export _gotk4_gtk3_PageSetupDoneFunc
func _gotk4_gtk3_PageSetupDoneFunc(arg1 *C.void, arg2 C.gpointer) {
	var fn PageSetupDoneFunc
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(PageSetupDoneFunc)
	}

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg1)))

	fn(_pageSetup)
}

// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify the
// values from page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in page_setup, otherwise it contains the
// modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
//
// The function takes the following parameters:
//
//    - parent (optional): transient parent.
//    - pageSetup (optional): existing PageSetup.
//    - settings: PrintSettings.
//
// The function returns the following values:
//
//    - pageSetup: new PageSetup.
//
func PrintRunPageSetupDialog(parent *Window, pageSetup *PageSetup, settings *PrintSettings) *PageSetup {
	var _args [3]girepository.Argument

	if parent != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	if pageSetup != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(pageSetup).Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_info := girepository.MustFind("Gtk", "print_run_page_setup_dialog")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(parent)
	runtime.KeepAlive(pageSetup)
	runtime.KeepAlive(settings)

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _pageSetup
}

// PrintRunPageSetupDialogAsync runs a page setup dialog, letting the user
// modify the values from page_setup.
//
// In contrast to gtk_print_run_page_setup_dialog(), this function returns after
// showing the page setup dialog on platforms that support this, and calls
// done_cb from a signal handler for the ::response signal of the dialog.
//
// The function takes the following parameters:
//
//    - parent (optional): transient parent, or NULL.
//    - pageSetup (optional): existing PageSetup, or NULL.
//    - settings: PrintSettings.
//    - doneCb: function to call when the user saves the modified page setup.
//
func PrintRunPageSetupDialogAsync(parent *Window, pageSetup *PageSetup, settings *PrintSettings, doneCb PageSetupDoneFunc) {
	var _args [5]girepository.Argument

	if parent != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	if pageSetup != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(pageSetup).Native()))
	}
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	*(*C.gpointer)(unsafe.Pointer(&_args[3])) = (*[0]byte)(C._gotk4_gtk3_PageSetupDoneFunc)
	_args[4] = C.gpointer(gbox.AssignOnce(doneCb))

	_info := girepository.MustFind("Gtk", "print_run_page_setup_dialog_async")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(parent)
	runtime.KeepAlive(pageSetup)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(doneCb)
}

// PrintOperationOverrider contains methods that are overridable.
type PrintOperationOverrider interface {
	// The function takes the following parameters:
	//
	BeginPrint(context *PrintContext)
	// The function takes the following parameters:
	//
	CustomWidgetApply(widget Widgetter)
	// The function takes the following parameters:
	//
	//    - context
	//    - pageNr
	//
	DrawPage(context *PrintContext, pageNr int32)
	// The function takes the following parameters:
	//
	EndPrint(context *PrintContext)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	Paginate(context *PrintContext) bool
	// The function takes the following parameters:
	//
	//    - preview
	//    - context
	//    - parent
	//
	// The function returns the following values:
	//
	Preview(preview PrintOperationPreviewer, context *PrintContext, parent *Window) bool
	// The function takes the following parameters:
	//
	//    - context
	//    - pageNr
	//    - setup
	//
	RequestPageSetup(context *PrintContext, pageNr int32, setup *PageSetup)
	StatusChanged()
	// The function takes the following parameters:
	//
	//    - widget
	//    - setup
	//    - settings
	//
	UpdateCustomWidget(widget Widgetter, setup *PageSetup, settings *PrintSettings)
}

// PrintOperation is the high-level, portable printing API. It looks a bit
// different than other GTK+ dialogs such as the FileChooser, since some
// platforms don’t expose enough infrastructure to implement a good print
// dialog. On such platforms, GtkPrintOperation uses the native print dialog. On
// platforms which do not provide a native print dialog, GTK+ uses its own, see
// PrintUnixDialog.
//
// The typical way to use the high-level printing API is to create a
// GtkPrintOperation object with gtk_print_operation_new() when the user selects
// to print. Then you set some properties on it, e.g. the page size, any
// PrintSettings from previous print operations, the number of pages, the
// current page, etc.
//
// Then you start the print operation by calling gtk_print_operation_run(). It
// will then show a dialog, let the user select a printer and options. When the
// user finished the dialog various signals will be emitted on the
// PrintOperation, the main one being PrintOperation::draw-page, which you are
// supposed to catch and render the page on the provided PrintContext using
// Cairo.
//
// The high-level printing API
//
//    static GtkPrintSettings *settings = NULL;
//
//    static void
//    do_print (void)
//    {
//      GtkPrintOperation *print;
//      GtkPrintOperationResult res;
//
//      print = gtk_print_operation_new ();
//
//      if (settings != NULL)
//        gtk_print_operation_set_print_settings (print, settings);
//
//      g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//      g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//      res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                     GTK_WINDOW (main_window), NULL);
//
//      if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//        {
//          if (settings != NULL)
//            g_object_unref (settings);
//          settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//        }
//
//      g_object_unref (print);
//    }
//
// By default GtkPrintOperation uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions gtk_print_operation_preview_render_page(),
// gtk_print_operation_preview_end_preview() and
// gtk_print_operation_preview_is_selected() are useful when implementing a
// print preview.
type PrintOperation struct {
	_ [0]func() // equal guard
	*coreglib.Object

	PrintOperationPreview
}

var (
	_ coreglib.Objector = (*PrintOperation)(nil)
)

func classInitPrintOperationer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "PrintOperationClass")

	if _, ok := goval.(interface{ BeginPrint(context *PrintContext) }); ok {
		o := pclass.StructFieldOffset("begin_print")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_begin_print)
	}

	if _, ok := goval.(interface{ CustomWidgetApply(widget Widgetter) }); ok {
		o := pclass.StructFieldOffset("custom_widget_apply")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_custom_widget_apply)
	}

	if _, ok := goval.(interface {
		DrawPage(context *PrintContext, pageNr int32)
	}); ok {
		o := pclass.StructFieldOffset("draw_page")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_draw_page)
	}

	if _, ok := goval.(interface{ EndPrint(context *PrintContext) }); ok {
		o := pclass.StructFieldOffset("end_print")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_end_print)
	}

	if _, ok := goval.(interface {
		Paginate(context *PrintContext) bool
	}); ok {
		o := pclass.StructFieldOffset("paginate")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_paginate)
	}

	if _, ok := goval.(interface {
		Preview(preview PrintOperationPreviewer, context *PrintContext, parent *Window) bool
	}); ok {
		o := pclass.StructFieldOffset("preview")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_preview)
	}

	if _, ok := goval.(interface {
		RequestPageSetup(context *PrintContext, pageNr int32, setup *PageSetup)
	}); ok {
		o := pclass.StructFieldOffset("request_page_setup")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_request_page_setup)
	}

	if _, ok := goval.(interface{ StatusChanged() }); ok {
		o := pclass.StructFieldOffset("status_changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_status_changed)
	}

	if _, ok := goval.(interface {
		UpdateCustomWidget(widget Widgetter, setup *PageSetup, settings *PrintSettings)
	}); ok {
		o := pclass.StructFieldOffset("update_custom_widget")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_PrintOperationClass_update_custom_widget)
	}
}

//export _gotk4_gtk3_PrintOperationClass_begin_print
func _gotk4_gtk3_PrintOperationClass_begin_print(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ BeginPrint(context *PrintContext) })

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	iface.BeginPrint(_context)
}

//export _gotk4_gtk3_PrintOperationClass_custom_widget_apply
func _gotk4_gtk3_PrintOperationClass_custom_widget_apply(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CustomWidgetApply(widget Widgetter) })

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	iface.CustomWidgetApply(_widget)
}

//export _gotk4_gtk3_PrintOperationClass_draw_page
func _gotk4_gtk3_PrintOperationClass_draw_page(arg0 *C.void, arg1 *C.void, arg2 C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DrawPage(context *PrintContext, pageNr int32)
	})

	var _context *PrintContext // out
	var _pageNr int32          // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int32(arg2)

	iface.DrawPage(_context, _pageNr)
}

//export _gotk4_gtk3_PrintOperationClass_end_print
func _gotk4_gtk3_PrintOperationClass_end_print(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ EndPrint(context *PrintContext) })

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	iface.EndPrint(_context)
}

//export _gotk4_gtk3_PrintOperationClass_paginate
func _gotk4_gtk3_PrintOperationClass_paginate(arg0 *C.void, arg1 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Paginate(context *PrintContext) bool
	})

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	ok := iface.Paginate(_context)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PrintOperationClass_preview
func _gotk4_gtk3_PrintOperationClass_preview(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Preview(preview PrintOperationPreviewer, context *PrintContext, parent *Window) bool
	})

	var _preview PrintOperationPreviewer // out
	var _context *PrintContext           // out
	var _parent *Window                  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.PrintOperationPreviewer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PrintOperationPreviewer)
			return ok
		})
		rv, ok := casted.(PrintOperationPreviewer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.PrintOperationPreviewer")
		}
		_preview = rv
	}
	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg2)))
	_parent = wrapWindow(coreglib.Take(unsafe.Pointer(arg3)))

	ok := iface.Preview(_preview, _context, _parent)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_PrintOperationClass_request_page_setup
func _gotk4_gtk3_PrintOperationClass_request_page_setup(arg0 *C.void, arg1 *C.void, arg2 C.gint, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		RequestPageSetup(context *PrintContext, pageNr int32, setup *PageSetup)
	})

	var _context *PrintContext // out
	var _pageNr int32          // out
	var _setup *PageSetup      // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int32(arg2)
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg3)))

	iface.RequestPageSetup(_context, _pageNr, _setup)
}

//export _gotk4_gtk3_PrintOperationClass_status_changed
func _gotk4_gtk3_PrintOperationClass_status_changed(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ StatusChanged() })

	iface.StatusChanged()
}

//export _gotk4_gtk3_PrintOperationClass_update_custom_widget
func _gotk4_gtk3_PrintOperationClass_update_custom_widget(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		UpdateCustomWidget(widget Widgetter, setup *PageSetup, settings *PrintSettings)
	})

	var _widget Widgetter        // out
	var _setup *PageSetup        // out
	var _settings *PrintSettings // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg2)))
	_settings = wrapPrintSettings(coreglib.Take(unsafe.Pointer(arg3)))

	iface.UpdateCustomWidget(_widget, _setup, _settings)
}

func wrapPrintOperation(obj *coreglib.Object) *PrintOperation {
	return &PrintOperation{
		Object: obj,
		PrintOperationPreview: PrintOperationPreview{
			Object: obj,
		},
	}
}

func marshalPrintOperation(p uintptr) (interface{}, error) {
	return wrapPrintOperation(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_PrintOperation_ConnectBeginPrint
func _gotk4_gtk3_PrintOperation_ConnectBeginPrint(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(context *PrintContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext))
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	f(_context)
}

// ConnectBeginPrint is emitted after the user has finished changing print
// settings in the dialog, before the actual rendering starts.
//
// A typical use for ::begin-print is to use the parameters from the
// PrintContext and paginate the document accordingly, and then set the number
// of pages with gtk_print_operation_set_n_pages().
func (op *PrintOperation) ConnectBeginPrint(f func(context *PrintContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "begin-print", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectBeginPrint), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectCreateCustomWidget
func _gotk4_gtk3_PrintOperation_ConnectCreateCustomWidget(arg0 C.gpointer, arg1 C.guintptr) (cret C.GObject) {
	var f func() (object *coreglib.Object)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (object *coreglib.Object))
	}

	object := f()

	cret = *(*C.GObject)(unsafe.Pointer(object.Native()))

	return cret
}

// ConnectCreateCustomWidget is emitted when displaying the print dialog. If you
// return a widget in a handler for this signal it will be added to a custom tab
// in the print dialog. You typically return a container widget with multiple
// widgets in it.
//
// The print dialog owns the returned widget, and its lifetime is not controlled
// by the application. However, the widget is guaranteed to stay around until
// the PrintOperation::custom-widget-apply signal is emitted on the operation.
// Then you can read out any information you need from the widgets.
func (op *PrintOperation) ConnectCreateCustomWidget(f func() (object *coreglib.Object)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "create-custom-widget", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectCreateCustomWidget), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectCustomWidgetApply
func _gotk4_gtk3_PrintOperation_ConnectCustomWidgetApply(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	f(_widget)
}

// ConnectCustomWidgetApply is emitted right before PrintOperation::begin-print
// if you added a custom widget in the PrintOperation::create-custom-widget
// handler. When you get this signal you should read the information from the
// custom widgets, as the widgets are not guaraneed to be around at a later
// time.
func (op *PrintOperation) ConnectCustomWidgetApply(f func(widget Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "custom-widget-apply", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectCustomWidgetApply), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectDrawPage
func _gotk4_gtk3_PrintOperation_ConnectDrawPage(arg0 C.gpointer, arg1 *C.void, arg2 C.gint, arg3 C.guintptr) {
	var f func(context *PrintContext, pageNr int32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext, pageNr int32))
	}

	var _context *PrintContext // out
	var _pageNr int32          // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int32(arg2)

	f(_context, _pageNr)
}

// ConnectDrawPage is emitted for every page that is printed. The signal handler
// must render the page_nr's page onto the cairo context obtained from context
// using gtk_print_context_get_cairo_context().
//
//    static void
//    draw_page (GtkPrintOperation *operation,
//               GtkPrintContext   *context,
//               gint               page_nr,
//               gpointer           user_data)
//    {
//      cairo_t *cr;
//      PangoLayout *layout;
//      gdouble width, text_height;
//      gint layout_height;
//      PangoFontDescription *desc;
//
//      cr = gtk_print_context_get_cairo_context (context);
//      width = gtk_print_context_get_width (context);
//
//      cairo_rectangle (cr, 0, 0, width, HEADER_HEIGHT);
//
//      cairo_set_source_rgb (cr, 0.8, 0.8, 0.8);
//      cairo_fill (cr);
//
//      layout = gtk_print_context_create_pango_layout (context);
//
//      desc = pango_font_description_from_string ("sans 14");
//      pango_layout_set_font_description (layout, desc);
//      pango_font_description_free (desc);
//
//      pango_layout_set_text (layout, "some text", -1);
//      pango_layout_set_width (layout, width * PANGO_SCALE);
//      pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
//
//      pango_layout_get_size (layout, NULL, &layout_height);
//      text_height = (gdouble)layout_height / PANGO_SCALE;
//
//      cairo_move_to (cr, width / 2,  (HEADER_HEIGHT - text_height) / 2);
//      pango_cairo_show_layout (cr, layout);
//
//      g_object_unref (layout);
//    }
//
// Use gtk_print_operation_set_use_full_page() and
// gtk_print_operation_set_unit() before starting the print operation to set up
// the transformation of the cairo context according to your needs.
func (op *PrintOperation) ConnectDrawPage(f func(context *PrintContext, pageNr int32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "draw-page", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectDrawPage), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectEndPrint
func _gotk4_gtk3_PrintOperation_ConnectEndPrint(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(context *PrintContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext))
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	f(_context)
}

// ConnectEndPrint is emitted after all pages have been rendered. A handler for
// this signal can clean up any resources that have been allocated in the
// PrintOperation::begin-print handler.
func (op *PrintOperation) ConnectEndPrint(f func(context *PrintContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "end-print", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectEndPrint), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectPaginate
func _gotk4_gtk3_PrintOperation_ConnectPaginate(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) (cret C.gboolean) {
	var f func(context *PrintContext) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext) (ok bool))
	}

	var _context *PrintContext // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))

	ok := f(_context)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectPaginate is emitted after the PrintOperation::begin-print signal, but
// before the actual rendering starts. It keeps getting emitted until a
// connected signal handler returns TRUE.
//
// The ::paginate signal is intended to be used for paginating a document in
// small chunks, to avoid blocking the user interface for a long time. The
// signal handler should update the number of pages using
// gtk_print_operation_set_n_pages(), and return TRUE if the document has been
// completely paginated.
//
// If you don't need to do pagination in chunks, you can simply do it all in the
// ::begin-print handler, and set the number of pages from there.
func (op *PrintOperation) ConnectPaginate(f func(context *PrintContext) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "paginate", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectPaginate), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectPreview
func _gotk4_gtk3_PrintOperation_ConnectPreview(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 C.guintptr) (cret C.gboolean) {
	var f func(preview PrintOperationPreviewer, context *PrintContext, parent *Window) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(preview PrintOperationPreviewer, context *PrintContext, parent *Window) (ok bool))
	}

	var _preview PrintOperationPreviewer // out
	var _context *PrintContext           // out
	var _parent *Window                  // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.PrintOperationPreviewer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(PrintOperationPreviewer)
			return ok
		})
		rv, ok := casted.(PrintOperationPreviewer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.PrintOperationPreviewer")
		}
		_preview = rv
	}
	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg2)))
	if arg3 != nil {
		_parent = wrapWindow(coreglib.Take(unsafe.Pointer(arg3)))
	}

	ok := f(_preview, _context, _parent)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectPreview gets emitted when a preview is requested from the native
// dialog.
//
// The default handler for this signal uses an external viewer application to
// preview.
//
// To implement a custom print preview, an application must return TRUE from its
// handler for this signal. In order to use the provided context for the preview
// implementation, it must be given a suitable cairo context with
// gtk_print_context_set_cairo_context().
//
// The custom preview implementation can use
// gtk_print_operation_preview_is_selected() and
// gtk_print_operation_preview_render_page() to find pages which are selected
// for print and render them. The preview must be finished by calling
// gtk_print_operation_preview_end_preview() (typically in response to the user
// clicking a close button).
func (op *PrintOperation) ConnectPreview(f func(preview PrintOperationPreviewer, context *PrintContext, parent *Window) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "preview", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectPreview), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectRequestPageSetup
func _gotk4_gtk3_PrintOperation_ConnectRequestPageSetup(arg0 C.gpointer, arg1 *C.void, arg2 C.gint, arg3 *C.void, arg4 C.guintptr) {
	var f func(context *PrintContext, pageNr int32, setup *PageSetup)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *PrintContext, pageNr int32, setup *PageSetup))
	}

	var _context *PrintContext // out
	var _pageNr int32          // out
	var _setup *PageSetup      // out

	_context = wrapPrintContext(coreglib.Take(unsafe.Pointer(arg1)))
	_pageNr = int32(arg2)
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg3)))

	f(_context, _pageNr, _setup)
}

// ConnectRequestPageSetup is emitted once for every page that is printed, to
// give the application a chance to modify the page setup. Any changes done to
// setup will be in force only for printing this page.
func (op *PrintOperation) ConnectRequestPageSetup(f func(context *PrintContext, pageNr int32, setup *PageSetup)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "request-page-setup", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectRequestPageSetup), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectStatusChanged
func _gotk4_gtk3_PrintOperation_ConnectStatusChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectStatusChanged is emitted at between the various phases of the print
// operation. See PrintStatus for the phases that are being discriminated. Use
// gtk_print_operation_get_status() to find out the current status.
func (op *PrintOperation) ConnectStatusChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "status-changed", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectStatusChanged), f)
}

//export _gotk4_gtk3_PrintOperation_ConnectUpdateCustomWidget
func _gotk4_gtk3_PrintOperation_ConnectUpdateCustomWidget(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 C.guintptr) {
	var f func(widget Widgetter, setup *PageSetup, settings *PrintSettings)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter, setup *PageSetup, settings *PrintSettings))
	}

	var _widget Widgetter        // out
	var _setup *PageSetup        // out
	var _settings *PrintSettings // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_setup = wrapPageSetup(coreglib.Take(unsafe.Pointer(arg2)))
	_settings = wrapPrintSettings(coreglib.Take(unsafe.Pointer(arg3)))

	f(_widget, _setup, _settings)
}

// ConnectUpdateCustomWidget is emitted after change of selected printer. The
// actual page setup and print settings are passed to the custom widget, which
// can actualize itself according to this change.
func (op *PrintOperation) ConnectUpdateCustomWidget(f func(widget Widgetter, setup *PageSetup, settings *PrintSettings)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "update-custom-widget", false, unsafe.Pointer(C._gotk4_gtk3_PrintOperation_ConnectUpdateCustomWidget), f)
}

// NewPrintOperation creates a new PrintOperation.
//
// The function returns the following values:
//
//    - printOperation: new PrintOperation.
//
func NewPrintOperation() *PrintOperation {
	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("new_PrintOperation", nil, nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	var _printOperation *PrintOperation // out

	_printOperation = wrapPrintOperation(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _printOperation
}

// Cancel cancels a running print operation. This function may be called from a
// PrintOperation::begin-print, PrintOperation::paginate or
// PrintOperation::draw-page signal handler to stop the currently running print
// operation.
func (op *PrintOperation) Cancel() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("cancel", _args[:], nil)

	runtime.KeepAlive(op)
}

// DrawPageFinish: signalize that drawing of particular page is complete.
//
// It is called after completion of page drawing (e.g. drawing in another
// thread). If gtk_print_operation_set_defer_drawing() was called before, then
// this function has to be called by application. In another case it is called
// by the library itself.
func (op *PrintOperation) DrawPageFinish() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("draw_page_finish", _args[:], nil)

	runtime.KeepAlive(op)
}

// DefaultPageSetup returns the default page setup, see
// gtk_print_operation_set_default_page_setup().
//
// The function returns the following values:
//
//    - pageSetup: default page setup.
//
func (op *PrintOperation) DefaultPageSetup() *PageSetup {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("get_default_page_setup", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(op)

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _pageSetup
}

// EmbedPageSetup gets the value of PrintOperation:embed-page-setup property.
//
// The function returns the following values:
//
//    - ok: whether page setup selection combos are embedded.
//
func (op *PrintOperation) EmbedPageSetup() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("get_embed_page_setup", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(op)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Error: call this when the result of a print operation is
// GTK_PRINT_OPERATION_RESULT_ERROR, either as returned by
// gtk_print_operation_run(), or in the PrintOperation::done signal handler. The
// returned #GError will contain more details on what went wrong.
func (op *PrintOperation) Error() error {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("get_error", _args[:], nil)

	runtime.KeepAlive(op)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// HasSelection gets the value of PrintOperation:has-selection property.
//
// The function returns the following values:
//
//    - ok: whether there is a selection.
//
func (op *PrintOperation) HasSelection() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("get_has_selection", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(op)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// NPagesToPrint returns the number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (GTK_PRINT_STATUS_PREPARING), so this function should never be called before
// the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You can connect
// to the PrintOperation::status-changed signal and call
// gtk_print_operation_get_n_pages_to_print() when print status is
// GTK_PRINT_STATUS_GENERATING_DATA. This is typically used to track the
// progress of print operation.
//
// The function returns the following values:
//
//    - gint: number of pages that will be printed.
//
func (op *PrintOperation) NPagesToPrint() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("get_n_pages_to_print", _args[:], nil)
	_cret := *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(op)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// PrintSettings returns the current print settings.
//
// Note that the return value is NULL until either
// gtk_print_operation_set_print_settings() or gtk_print_operation_run() have
// been called.
//
// The function returns the following values:
//
//    - printSettings: current print settings of op.
//
func (op *PrintOperation) PrintSettings() *PrintSettings {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("get_print_settings", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(op)

	var _printSettings *PrintSettings // out

	_printSettings = wrapPrintSettings(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _printSettings
}

// StatusString returns a string representation of the status of the print
// operation. The string is translated and suitable for displaying the print
// status e.g. in a Statusbar.
//
// Use gtk_print_operation_get_status() to obtain a status value that is
// suitable for programmatic use.
//
// The function returns the following values:
//
//    - utf8: string representation of the status of the print operation.
//
func (op *PrintOperation) StatusString() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("get_status_string", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(op)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// SupportSelection gets the value of PrintOperation:support-selection property.
//
// The function returns the following values:
//
//    - ok: whether the application supports print of selection.
//
func (op *PrintOperation) SupportSelection() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("get_support_selection", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(op)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsFinished: convenience function to find out if the print operation is
// finished, either successfully (GTK_PRINT_STATUS_FINISHED) or unsuccessfully
// (GTK_PRINT_STATUS_FINISHED_ABORTED).
//
// Note: when you enable print status tracking the print operation can be in a
// non-finished state even after done has been called, as the operation status
// then tracks the print job status on the printer.
//
// The function returns the following values:
//
//    - ok: TRUE, if the print operation is finished.
//
func (op *PrintOperation) IsFinished() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_gret := _info.InvokeClassMethod("is_finished", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(op)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SetAllowAsync sets whether the gtk_print_operation_run() may return before
// the print operation is completed. Note that some platforms may not allow
// asynchronous operation.
//
// The function takes the following parameters:
//
//    - allowAsync: TRUE to allow asynchronous operation.
//
func (op *PrintOperation) SetAllowAsync(allowAsync bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if allowAsync {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_allow_async", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(allowAsync)
}

// SetCurrentPage sets the current page.
//
// If this is called before gtk_print_operation_run(), the user will be able to
// select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
//
// The function takes the following parameters:
//
//    - currentPage: current page, 0-based.
//
func (op *PrintOperation) SetCurrentPage(currentPage int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(currentPage)

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_current_page", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(currentPage)
}

// SetCustomTabLabel sets the label for the tab holding custom widgets.
//
// The function takes the following parameters:
//
//    - label (optional) to use, or NULL to use the default label.
//
func (op *PrintOperation) SetCustomTabLabel(label string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if label != "" {
		*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_custom_tab_label", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(label)
}

// SetDefaultPageSetup makes default_page_setup the default page setup for op.
//
// This page setup will be used by gtk_print_operation_run(), but it can be
// overridden on a per-page basis by connecting to the
// PrintOperation::request-page-setup signal.
//
// The function takes the following parameters:
//
//    - defaultPageSetup (optional) or NULL.
//
func (op *PrintOperation) SetDefaultPageSetup(defaultPageSetup *PageSetup) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if defaultPageSetup != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(defaultPageSetup).Native()))
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_default_page_setup", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(defaultPageSetup)
}

// SetDeferDrawing sets up the PrintOperation to wait for calling of
// gtk_print_operation_draw_page_finish() from application. It can be used for
// drawing page in another thread.
//
// This function must be called in the callback of “draw-page” signal.
func (op *PrintOperation) SetDeferDrawing() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_defer_drawing", _args[:], nil)

	runtime.KeepAlive(op)
}

// SetEmbedPageSetup: embed page size combo box and orientation combo box into
// page setup page. Selected page setup is stored as default page setup in
// PrintOperation.
//
// The function takes the following parameters:
//
//    - embed: TRUE to embed page setup selection in the PrintUnixDialog.
//
func (op *PrintOperation) SetEmbedPageSetup(embed bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if embed {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_embed_page_setup", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(embed)
}

// SetExportFilename sets up the PrintOperation to generate a file instead of
// showing the print dialog. The indended use of this function is for
// implementing “Export to PDF” actions. Currently, PDF is the only supported
// format.
//
// “Print to PDF” support is independent of this and is done by letting the user
// pick the “Print to PDF” item from the list of printers in the print dialog.
//
// The function takes the following parameters:
//
//    - filename for the exported file.
//
func (op *PrintOperation) SetExportFilename(filename string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_export_filename", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(filename)
}

// SetHasSelection sets whether there is a selection to print.
//
// Application has to set number of pages to which the selection will draw by
// gtk_print_operation_set_n_pages() in a callback of
// PrintOperation::begin-print.
//
// The function takes the following parameters:
//
//    - hasSelection: TRUE indicates that a selection exists.
//
func (op *PrintOperation) SetHasSelection(hasSelection bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if hasSelection {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_has_selection", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(hasSelection)
}

// SetJobName sets the name of the print job. The name is used to identify the
// job (e.g. in monitoring applications like eggcups).
//
// If you don’t set a job name, GTK+ picks a default one by numbering successive
// print jobs.
//
// The function takes the following parameters:
//
//    - jobName: string that identifies the print job.
//
func (op *PrintOperation) SetJobName(jobName string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(jobName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_job_name", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(jobName)
}

// SetNPages sets the number of pages in the document.
//
// This must be set to a positive number before the rendering starts. It may be
// set in a PrintOperation::begin-print signal hander.
//
// Note that the page numbers passed to the PrintOperation::request-page-setup
// and PrintOperation::draw-page signals are 0-based, i.e. if the user chooses
// to print all pages, the last ::draw-page signal will be for page n_pages - 1.
//
// The function takes the following parameters:
//
//    - nPages: number of pages.
//
func (op *PrintOperation) SetNPages(nPages int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(nPages)

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_n_pages", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(nPages)
}

// SetPrintSettings sets the print settings for op. This is typically used to
// re-establish print settings from a previous print operation, see
// gtk_print_operation_run().
//
// The function takes the following parameters:
//
//    - printSettings (optional): PrintSettings.
//
func (op *PrintOperation) SetPrintSettings(printSettings *PrintSettings) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if printSettings != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(printSettings).Native()))
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_print_settings", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(printSettings)
}

// SetShowProgress: if show_progress is TRUE, the print operation will show a
// progress dialog during the print operation.
//
// The function takes the following parameters:
//
//    - showProgress: TRUE to show a progress dialog.
//
func (op *PrintOperation) SetShowProgress(showProgress bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if showProgress {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_show_progress", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(showProgress)
}

// SetSupportSelection sets whether selection is supported by PrintOperation.
//
// The function takes the following parameters:
//
//    - supportSelection: TRUE to support selection.
//
func (op *PrintOperation) SetSupportSelection(supportSelection bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if supportSelection {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_support_selection", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(supportSelection)
}

// SetTrackPrintStatus: if track_status is TRUE, the print operation will try to
// continue report on the status of the print job in the printer queues and
// printer. This can allow your application to show things like “out of paper”
// issues, and when the print job actually reaches the printer.
//
// This function is often implemented using some form of polling, so it should
// not be enabled unless needed.
//
// The function takes the following parameters:
//
//    - trackStatus: TRUE to track status after printing.
//
func (op *PrintOperation) SetTrackPrintStatus(trackStatus bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if trackStatus {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_track_print_status", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(trackStatus)
}

// SetUseFullPage: if full_page is TRUE, the transformation for the cairo
// context obtained from PrintContext puts the origin at the top left corner of
// the page (which may not be the top left corner of the sheet, depending on
// page orientation and the number of pages per sheet). Otherwise, the origin is
// at the top left corner of the imageable area (i.e. inside the margins).
//
// The function takes the following parameters:
//
//    - fullPage: TRUE to set up the PrintContext for the full page.
//
func (op *PrintOperation) SetUseFullPage(fullPage bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if fullPage {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "PrintOperation")
	_info.InvokeClassMethod("set_use_full_page", _args[:], nil)

	runtime.KeepAlive(op)
	runtime.KeepAlive(fullPage)
}

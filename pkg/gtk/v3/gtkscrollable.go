// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// GType values.
var (
	GTypeScrollable = coreglib.Type(C.gtk_scrollable_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeScrollable, F: marshalScrollable},
	})
}

// Scrollable is an interface that is implemented by widgets with native
// scrolling ability.
//
// To implement this interface you should override the Scrollable:hadjustment
// and Scrollable:vadjustment properties.
//
//
// Creating a scrollable widget
//
// All scrollable widgets should do the following.
//
// - When a parent widget sets the scrollable child widget’s adjustments, the
// widget should populate the adjustments’ Adjustment:lower, Adjustment:upper,
// Adjustment:step-increment, Adjustment:page-increment and Adjustment:page-size
// properties and connect to the Adjustment::value-changed signal.
//
// - Because its preferred size is the size for a fully expanded widget, the
// scrollable widget must be able to cope with underallocations. This means that
// it must accept any value passed to its WidgetClass.size_allocate() function.
//
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments’ properties with new values.
//
// - When any of the adjustments emits the Adjustment::value-changed signal, the
// scrollable widget should scroll its contents.
//
// Scrollable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Scrollable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Scrollable)(nil)
)

// Scrollabler describes Scrollable's interface methods.
type Scrollabler interface {
	coreglib.Objector

	// Border returns the size of a non-scrolling border around the outside of
	// the scrollable.
	Border() (*Border, bool)
	// HAdjustment retrieves the Adjustment used for horizontal scrolling.
	HAdjustment() *Adjustment
	// HScrollPolicy gets the horizontal ScrollablePolicy.
	HScrollPolicy() ScrollablePolicy
	// VAdjustment retrieves the Adjustment used for vertical scrolling.
	VAdjustment() *Adjustment
	// VScrollPolicy gets the vertical ScrollablePolicy.
	VScrollPolicy() ScrollablePolicy
	// SetHAdjustment sets the horizontal adjustment of the Scrollable.
	SetHAdjustment(hadjustment *Adjustment)
	// SetHScrollPolicy sets the ScrollablePolicy to determine whether
	// horizontal scrolling should start below the minimum width or below the
	// natural width.
	SetHScrollPolicy(policy ScrollablePolicy)
	// SetVAdjustment sets the vertical adjustment of the Scrollable.
	SetVAdjustment(vadjustment *Adjustment)
	// SetVScrollPolicy sets the ScrollablePolicy to determine whether vertical
	// scrolling should start below the minimum height or below the natural
	// height.
	SetVScrollPolicy(policy ScrollablePolicy)
}

var _ Scrollabler = (*Scrollable)(nil)

func wrapScrollable(obj *coreglib.Object) *Scrollable {
	return &Scrollable{
		Object: obj,
	}
}

func marshalScrollable(p uintptr) (interface{}, error) {
	return wrapScrollable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ScrollableInterface: instance of this type is always passed by reference.
type ScrollableInterface struct {
	*scrollableInterface
}

// scrollableInterface is the struct that's finalized.
type scrollableInterface struct {
	native *C.GtkScrollableInterface
}

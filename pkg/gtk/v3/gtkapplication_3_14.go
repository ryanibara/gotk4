// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// ActionsForAccel returns the list of actions (possibly empty) that accel maps
// to. Each item in the list is a detailed action name in the usual form.
//
// This might be useful to discover if an accel already exists in order to
// prevent installation of a conflicting accelerator (from an accelerator editor
// or a plugin system, for example). Note that having more than one action per
// accelerator may not be a bad thing and might make sense in cases where the
// actions never appear in the same context.
//
// In case there are no actions for a given accelerator, an empty array is
// returned. NULL is never returned.
//
// It is a programmer error to pass an invalid accelerator string. If you are
// unsure, check it with gtk_accelerator_parse() first.
//
// The function takes the following parameters:
//
//    - accel: accelerator that can be parsed by gtk_accelerator_parse().
//
// The function returns the following values:
//
//    - utf8s: NULL-terminated array of actions for accel.
//
func (application *Application) ActionsForAccel(accel string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _cret **C.gchar         // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accel)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_actions_for_accel(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(accel)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.gchar
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// MenuByID gets a menu from automatically loaded resources. See [Automatic
// resources][automatic-resources] for more information.
//
// The function takes the following parameters:
//
//    - id of the menu to look up.
//
// The function returns the following values:
//
//    - menu gets the menu with the given id from the automatically loaded
//      resources.
//
func (application *Application) MenuByID(id string) *gio.Menu {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _cret *C.GMenu          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_menu_by_id(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)

	var _menu *gio.Menu // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_menu = &gio.Menu{
			MenuModel: gio.MenuModel{
				Object: obj,
			},
		}
	}

	return _menu
}

// PrefersAppMenu determines if the desktop environment in which the application
// is running would prefer an application menu be shown.
//
// If this function returns TRUE then the application should call
// gtk_application_set_app_menu() with the contents of an application menu,
// which will be shown by the desktop environment. If it returns FALSE then you
// should consider using an alternate approach, such as a menubar.
//
// The value returned by this function is purely advisory and you are free to
// ignore it. If you call gtk_application_set_app_menu() even if the desktop
// environment doesn't support app menus, then a fallback will be provided.
//
// Applications are similarly free not to set an app menu even if the desktop
// environment wants to show one. In that case, a fallback will also be created
// by the desktop environment (GNOME, for example, uses a menu with only a
// "Quit" item in it).
//
// The value returned by this function never changes. Once it returns a
// particular value, it is guaranteed to always return the same value.
//
// You may only call this function after the application has been registered and
// after the base startup handler has run. You're most likely to want to use
// this from your own startup handler. It may also make sense to consult this
// function while constructing UI (in activate, open or an action activation
// handler) in order to determine if you should show a gear menu or not.
//
// This function will return FALSE on Mac OS and a default app menu will be
// created automatically with the "usual" contents of that menu typical to most
// Mac OS applications. If you call gtk_application_set_app_menu() anyway, then
// this menu will be replaced with your own.
//
// The function returns the following values:
//
//    - ok: TRUE if you should set an app menu.
//
func (application *Application) PrefersAppMenu() bool {
	var _arg0 *C.GtkApplication // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_prefers_app_menu(_arg0)
	runtime.KeepAlive(application)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

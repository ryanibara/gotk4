// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// GtkWidget* _gotk4_gtk3_Action_virtual_create_menu_item(void* fnptr, GtkAction* arg0) {
//   return ((GtkWidget* (*)(GtkAction*))(fnptr))(arg0);
// };
// GtkWidget* _gotk4_gtk3_Action_virtual_create_tool_item(void* fnptr, GtkAction* arg0) {
//   return ((GtkWidget* (*)(GtkAction*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Action_virtual_activate(void* fnptr, GtkAction* arg0) {
//   ((void (*)(GtkAction*))(fnptr))(arg0);
// };
import "C"

// NewAction creates a new Action object. To add the action to a ActionGroup and
// set the accelerator for the action, call
// gtk_action_group_add_action_with_accel(). See the [UI Definition
// section][XML-UI] for information on allowed action names.
//
// Deprecated: Use #GAction instead, associating it to a widget with Actionable
// or creating a Menu with gtk_menu_new_from_model().
//
// The function takes the following parameters:
//
//    - name: unique name for the action.
//    - label (optional) displayed in menu items and on buttons, or NULL.
//    - tooltip (optional) for the action, or NULL.
//    - stockId (optional): stock icon to display in widgets representing the
//      action, or NULL.
//
// The function returns the following values:
//
//    - action: new Action.
//
func NewAction(name, label, tooltip, stockId string) *Action {
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _arg3 *C.gchar     // out
	var _arg4 *C.gchar     // out
	var _cret *C.GtkAction // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if label != "" {
		_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if tooltip != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(tooltip)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if stockId != "" {
		_arg4 = (*C.gchar)(unsafe.Pointer(C.CString(stockId)))
		defer C.free(unsafe.Pointer(_arg4))
	}

	_cret = C.gtk_action_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(name)
	runtime.KeepAlive(label)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(stockId)

	var _action *Action // out

	_action = wrapAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _action
}

// Activate emits the “activate” signal on the specified action, if it isn't
// insensitive. This gets called by the proxy widgets when they get activated.
//
// It can also be used to manually activate an action.
//
// Deprecated: Use g_action_group_activate_action() on a #GAction instead.
func (action *Action) Activate() {
	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	C.gtk_action_activate(_arg0)
	runtime.KeepAlive(action)
}

// ConnectAccelerator installs the accelerator for action if action has an accel
// path and group. See gtk_action_set_accel_path() and
// gtk_action_set_accel_group()
//
// Since multiple proxies may independently trigger the installation of the
// accelerator, the action counts the number of times this function has been
// called and doesn’t remove the accelerator until
// gtk_action_disconnect_accelerator() has been called as many times.
//
// Deprecated: Use #GAction and the accelerator group on an associated Menu
// instead.
func (action *Action) ConnectAccelerator() {
	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	C.gtk_action_connect_accelerator(_arg0)
	runtime.KeepAlive(action)
}

// CreateIcon: this function is intended for use by action implementations to
// create icons displayed in the proxy widgets.
//
// Deprecated: Use g_menu_item_set_icon() to set an icon on a Item, or
// gtk_container_add() to add a Image to a Button.
//
// The function takes the following parameters:
//
//    - iconSize: size of the icon (IconSize) that should be created.
//
// The function returns the following values:
//
//    - widget that displays the icon for this action.
//
func (action *Action) CreateIcon(iconSize int) Widgetter {
	var _arg0 *C.GtkAction  // out
	var _arg1 C.GtkIconSize // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	_arg1 = C.GtkIconSize(iconSize)

	_cret = C.gtk_action_create_icon(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(iconSize)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// CreateMenuItem creates a menu item widget that proxies for the given action.
//
// Deprecated: Use g_menu_item_new() and associate it with a #GAction instead.
//
// The function returns the following values:
//
//    - widget: menu item connected to the action.
//
func (action *Action) CreateMenuItem() Widgetter {
	var _arg0 *C.GtkAction // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.gtk_action_create_menu_item(_arg0)
	runtime.KeepAlive(action)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// CreateToolItem creates a toolbar item widget that proxies for the given
// action.
//
// Deprecated: Use a ToolItem and associate it with a #GAction using
// gtk_actionable_set_action_name() instead.
//
// The function returns the following values:
//
//    - widget: toolbar item connected to the action.
//
func (action *Action) CreateToolItem() Widgetter {
	var _arg0 *C.GtkAction // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.gtk_action_create_tool_item(_arg0)
	runtime.KeepAlive(action)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// DisconnectAccelerator undoes the effect of one call to
// gtk_action_connect_accelerator().
//
// Deprecated: Use #GAction and the accelerator group on an associated Menu
// instead.
func (action *Action) DisconnectAccelerator() {
	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	C.gtk_action_disconnect_accelerator(_arg0)
	runtime.KeepAlive(action)
}

// Name returns the name of the action.
//
// Deprecated: Use g_action_get_name() on a #GAction instead.
//
// The function returns the following values:
//
//    - utf8: name of the action. The string belongs to GTK+ and should not be
//      freed.
//
func (action *Action) Name() string {
	var _arg0 *C.GtkAction // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.gtk_action_get_name(_arg0)
	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Proxies returns the proxy widgets for an action. See also
// gtk_activatable_get_related_action().
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - sList of proxy widgets. The list is owned by GTK+ and must not be
//      modified.
//
func (action *Action) Proxies() []Widgetter {
	var _arg0 *C.GtkAction // out
	var _cret *C.GSList    // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.gtk_action_get_proxies(_arg0)
	runtime.KeepAlive(action)

	var _sList []Widgetter // out

	_sList = make([]Widgetter, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// Sensitive returns whether the action itself is sensitive. Note that this
// doesn’t necessarily mean effective sensitivity. See gtk_action_is_sensitive()
// for that.
//
// Deprecated: Use g_action_get_enabled() on a #GAction instead.
//
// The function returns the following values:
//
//    - ok: TRUE if the action itself is sensitive.
//
func (action *Action) Sensitive() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.gtk_action_get_sensitive(_arg0)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visible returns whether the action itself is visible. Note that this doesn’t
// necessarily mean effective visibility. See gtk_action_is_sensitive() for
// that.
//
// Deprecated: Use #GAction instead, and control and monitor the state of
// Actionable widgets directly.
//
// The function returns the following values:
//
//    - ok: TRUE if the action itself is visible.
//
func (action *Action) Visible() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.gtk_action_get_visible(_arg0)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSensitive returns whether the action is effectively sensitive.
//
// Deprecated: Use g_action_get_enabled() on a #GAction instead.
//
// The function returns the following values:
//
//    - ok: TRUE if the action and its associated action group are both
//      sensitive.
//
func (action *Action) IsSensitive() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.gtk_action_is_sensitive(_arg0)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVisible returns whether the action is effectively visible.
//
// Deprecated: Use #GAction instead, and control and monitor the state of
// Actionable widgets directly.
//
// The function returns the following values:
//
//    - ok: TRUE if the action and its associated action group are both visible.
//
func (action *Action) IsVisible() bool {
	var _arg0 *C.GtkAction // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C.gtk_action_is_visible(_arg0)
	runtime.KeepAlive(action)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAccelGroup sets the AccelGroup in which the accelerator for this action
// will be installed.
//
// Deprecated: Use #GAction and the accelerator group on an associated Menu
// instead.
//
// The function takes the following parameters:
//
//    - accelGroup (optional) or NULL.
//
func (action *Action) SetAccelGroup(accelGroup *AccelGroup) {
	var _arg0 *C.GtkAction     // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if accelGroup != nil {
		_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	}

	C.gtk_action_set_accel_group(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(accelGroup)
}

// SetAccelPath sets the accel path for this action. All proxy widgets
// associated with the action will have this accel path, so that their
// accelerators are consistent.
//
// Note that accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
//
// Deprecated: Use #GAction and the accelerator path on an associated Menu
// instead.
//
// The function takes the following parameters:
//
//    - accelPath: accelerator path.
//
func (action *Action) SetAccelPath(accelPath string) {
	var _arg0 *C.GtkAction // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accelPath)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_action_set_accel_path(_arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(accelPath)
}

// Activate emits the “activate” signal on the specified action, if it isn't
// insensitive. This gets called by the proxy widgets when they get activated.
//
// It can also be used to manually activate an action.
//
// Deprecated: Use g_action_group_activate_action() on a #GAction instead.
func (action *Action) activate() {
	gclass := (*C.GtkActionClass)(coreglib.PeekParentClass(action))
	fnarg := gclass.activate

	var _arg0 *C.GtkAction // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	C._gotk4_gtk3_Action_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)
}

// createMenuItem creates a menu item widget that proxies for the given action.
//
// Deprecated: Use g_menu_item_new() and associate it with a #GAction instead.
//
// The function returns the following values:
//
//    - widget: menu item connected to the action.
//
func (action *Action) createMenuItem() Widgetter {
	gclass := (*C.GtkActionClass)(coreglib.PeekParentClass(action))
	fnarg := gclass.create_menu_item

	var _arg0 *C.GtkAction // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gtk3_Action_virtual_create_menu_item(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// createToolItem creates a toolbar item widget that proxies for the given
// action.
//
// Deprecated: Use a ToolItem and associate it with a #GAction using
// gtk_actionable_set_action_name() instead.
//
// The function returns the following values:
//
//    - widget: toolbar item connected to the action.
//
func (action *Action) createToolItem() Widgetter {
	gclass := (*C.GtkActionClass)(coreglib.PeekParentClass(action))
	fnarg := gclass.create_tool_item

	var _arg0 *C.GtkAction // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_cret = C._gotk4_gtk3_Action_virtual_create_tool_item(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(action)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gboolean _gotk4_gtk3_WindowClass_enable_debugging(void*, gboolean);
// extern gboolean _gotk4_gtk3_Window_ConnectEnableDebugging(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk3_WindowClass_activate_default(void*);
// extern void _gotk4_gtk3_WindowClass_activate_focus(void*);
// extern void _gotk4_gtk3_WindowClass_keys_changed(void*);
// extern void _gotk4_gtk3_WindowClass_set_focus(void*, void*);
// extern void _gotk4_gtk3_Window_ConnectActivateDefault(gpointer, guintptr);
// extern void _gotk4_gtk3_Window_ConnectActivateFocus(gpointer, guintptr);
// extern void _gotk4_gtk3_Window_ConnectKeysChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_Window_ConnectSetFocus(gpointer, void*, guintptr);
import "C"

// GTypeWindowPosition returns the GType for the type WindowPosition.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeWindowPosition() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "WindowPosition").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalWindowPosition)
	return gtype
}

// GTypeWindowType returns the GType for the type WindowType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeWindowType() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "WindowType").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalWindowType)
	return gtype
}

// GTypeWindow returns the GType for the type Window.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeWindow() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "Window").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalWindow)
	return gtype
}

// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
type WindowPosition C.gint

const (
	// WinPosNone: no influence is made on placement.
	WinPosNone WindowPosition = iota
	// WinPosCenter windows should be placed in the center of the screen.
	WinPosCenter
	// WinPosMouse windows should be placed at the current mouse position.
	WinPosMouse
	// WinPosCenterAlways: keep window centered as it changes size, etc.
	WinPosCenterAlways
	// WinPosCenterOnParent: center the window on its transient parent (see
	// gtk_window_set_transient_for()).
	WinPosCenterOnParent
)

func marshalWindowPosition(p uintptr) (interface{}, error) {
	return WindowPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowPosition.
func (w WindowPosition) String() string {
	switch w {
	case WinPosNone:
		return "None"
	case WinPosCenter:
		return "Center"
	case WinPosMouse:
		return "Mouse"
	case WinPosCenterAlways:
		return "CenterAlways"
	case WinPosCenterOnParent:
		return "CenterOnParent"
	default:
		return fmt.Sprintf("WindowPosition(%d)", w)
	}
}

// WindowType can be one of these types. Most things you’d consider a “window”
// should have type K_WINDOW_TOPLEVEL; windows with this type are managed by the
// window manager and have a frame by default (call gtk_window_set_decorated()
// to toggle the frame). Windows with type K_WINDOW_POPUP are ignored by the
// window manager; window manager keybindings won’t work on them, the window
// manager won’t decorate the window with a frame, many GTK+ features that rely
// on the window manager will not work (e.g. resize grips and
// maximization/minimization). K_WINDOW_POPUP is used to implement widgets such
// as Menu or tooltips that you normally don’t think of as windows per se.
// Nearly all windows should be K_WINDOW_TOPLEVEL. In particular, do not use
// K_WINDOW_POPUP just to turn off the window borders; use
// gtk_window_set_decorated() for that.
type WindowType C.gint

const (
	// WindowToplevel: regular window, such as a dialog.
	WindowToplevel WindowType = iota
	// WindowPopup: special window such as a tooltip.
	WindowPopup
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowType.
func (w WindowType) String() string {
	switch w {
	case WindowToplevel:
		return "Toplevel"
	case WindowPopup:
		return "Popup"
	default:
		return fmt.Sprintf("WindowType(%d)", w)
	}
}

// WindowOverrider contains methods that are overridable.
type WindowOverrider interface {
	ActivateDefault()
	ActivateFocus()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	EnableDebugging(toggle bool) bool
	KeysChanged()
	// SetFocus: if focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the window. If focus is NULL, unsets the
	// focus widget for this window. To set the focus to a particular widget in
	// the toplevel, it is usually more convenient to use
	// gtk_widget_grab_focus() instead of this function.
	//
	// The function takes the following parameters:
	//
	//    - focus (optional): widget to be the new focus widget, or NULL to unset
	//      any focus widget for the toplevel window.
	//
	SetFocus(focus Widgetter)
}

// Window is a toplevel window which can contain other widgets. Windows normally
// have decorations that are under the control of the windowing system and allow
// the user to manipulate the window (resize it, move it, close it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the Buildable interface supports a custom
// <accel-groups> element, which supports any number of <group> elements
// representing the AccelGroup objects you want to add to your window
// (synonymous with gtk_window_add_accel_group().
//
// It also supports the <initial-focus> element, whose name property names the
// widget to receive the focus when the window is mapped.
//
// An example of a UI definition fragment with accel groups:
//
//    <object class="GtkWindow">
//      <accel-groups>
//        <group name="accelgroup1"/>
//      </accel-groups>
//      <initial-focus name="thunderclap"/>
//    </object>
//
//    ...
//
//    <object class="GtkAccelGroup" id="accelgroup1"/>
//
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background
//    ├── decoration
//    ├── <titlebar child>.titlebar [.default-decoration]
//    ╰── <child>
//
// GtkWindow has a main CSS node with name window and style class .background,
// and a subnode with name decoration.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
type Window struct {
	_ [0]func() // equal guard
	Bin
}

var (
	_ Binner = (*Window)(nil)
)

func classInitWindower(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "WindowClass")

	if _, ok := goval.(interface{ ActivateDefault() }); ok {
		o := pclass.StructFieldOffset("activate_default")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_WindowClass_activate_default)
	}

	if _, ok := goval.(interface{ ActivateFocus() }); ok {
		o := pclass.StructFieldOffset("activate_focus")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_WindowClass_activate_focus)
	}

	if _, ok := goval.(interface{ EnableDebugging(toggle bool) bool }); ok {
		o := pclass.StructFieldOffset("enable_debugging")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_WindowClass_enable_debugging)
	}

	if _, ok := goval.(interface{ KeysChanged() }); ok {
		o := pclass.StructFieldOffset("keys_changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_WindowClass_keys_changed)
	}

	if _, ok := goval.(interface{ SetFocus(focus Widgetter) }); ok {
		o := pclass.StructFieldOffset("set_focus")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_WindowClass_set_focus)
	}
}

//export _gotk4_gtk3_WindowClass_activate_default
func _gotk4_gtk3_WindowClass_activate_default(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ActivateDefault() })

	iface.ActivateDefault()
}

//export _gotk4_gtk3_WindowClass_activate_focus
func _gotk4_gtk3_WindowClass_activate_focus(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ActivateFocus() })

	iface.ActivateFocus()
}

//export _gotk4_gtk3_WindowClass_enable_debugging
func _gotk4_gtk3_WindowClass_enable_debugging(arg0 *C.void, arg1 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ EnableDebugging(toggle bool) bool })

	var _toggle bool // out

	if arg1 != 0 {
		_toggle = true
	}

	ok := iface.EnableDebugging(_toggle)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_WindowClass_keys_changed
func _gotk4_gtk3_WindowClass_keys_changed(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ KeysChanged() })

	iface.KeysChanged()
}

//export _gotk4_gtk3_WindowClass_set_focus
func _gotk4_gtk3_WindowClass_set_focus(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SetFocus(focus Widgetter) })

	var _focus Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_focus = rv
		}
	}

	iface.SetFocus(_focus)
}

func wrapWindow(obj *coreglib.Object) *Window {
	return &Window{
		Bin: Bin{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	return wrapWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_Window_ConnectActivateDefault
func _gotk4_gtk3_Window_ConnectActivateDefault(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivateDefault signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted when the user activates the default widget of window.
func (window *Window) ConnectActivateDefault(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "activate-default", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectActivateDefault), f)
}

//export _gotk4_gtk3_Window_ConnectActivateFocus
func _gotk4_gtk3_Window_ConnectActivateFocus(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivateFocus signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user activates the currently focused widget of window.
func (window *Window) ConnectActivateFocus(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "activate-focus", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectActivateFocus), f)
}

//export _gotk4_gtk3_Window_ConnectEnableDebugging
func _gotk4_gtk3_Window_ConnectEnableDebugging(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(toggle bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(toggle bool) (ok bool))
	}

	var _toggle bool // out

	if arg1 != 0 {
		_toggle = true
	}

	ok := f(_toggle)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectEnableDebugging signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted when the user enables or disables interactive debugging.
// When toggle is TRUE, interactive debugging is toggled on or off, when it is
// FALSE, the debugger will be pointed at the widget under the pointer.
//
// The default bindings for this signal are Ctrl-Shift-I and Ctrl-Shift-D.
func (window *Window) ConnectEnableDebugging(f func(toggle bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "enable-debugging", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectEnableDebugging), f)
}

//export _gotk4_gtk3_Window_ConnectKeysChanged
func _gotk4_gtk3_Window_ConnectKeysChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectKeysChanged signal gets emitted when the set of accelerators or
// mnemonics that are associated with window changes.
func (window *Window) ConnectKeysChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "keys-changed", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectKeysChanged), f)
}

//export _gotk4_gtk3_Window_ConnectSetFocus
func _gotk4_gtk3_Window_ConnectSetFocus(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	f(_widget)
}

// ConnectSetFocus: this signal is emitted whenever the currently focused widget
// in this window changes.
func (window *Window) ConnectSetFocus(f func(widget Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "set-focus", false, unsafe.Pointer(C._gotk4_gtk3_Window_ConnectSetFocus), f)
}

// ActivateDefault activates the default widget for the window, unless the
// current focused widget has been configured to receive the default action (see
// gtk_widget_set_receives_default()), in which case the focused widget is
// activated.
//
// The function returns the following values:
//
//    - ok: TRUE if a widget got activated.
//
func (window *Window) ActivateDefault() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("activate_default", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ActivateFocus activates the current focused widget within the window.
//
// The function returns the following values:
//
//    - ok: TRUE if a widget got activated.
//
func (window *Window) ActivateFocus() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("activate_focus", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ActivateKey activates mnemonics and accelerators for this Window. This is
// normally called by the default ::key_press_event handler for toplevel
// windows, however in some cases it may be useful to call this directly when
// overriding the standard key handling for a toplevel window.
//
// The function takes the following parameters:
//
//    - event: EventKey.
//
// The function returns the following values:
//
//    - ok: TRUE if a mnemonic or accelerator was found and activated.
//
func (window *Window) ActivateKey(event *gdk.EventKey) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(event)))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("activate_key", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)
	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// AddAccelGroup: associate accel_group with window, such that calling
// gtk_accel_groups_activate() on window will activate accelerators in
// accel_group.
//
// The function takes the following parameters:
//
//    - accelGroup: AccelGroup.
//
func (window *Window) AddAccelGroup(accelGroup *AccelGroup) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("add_accel_group", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(accelGroup)
}

// AddMnemonic adds a mnemonic to this window.
//
// The function takes the following parameters:
//
//    - keyval: mnemonic.
//    - target: widget that gets activated by the mnemonic.
//
func (window *Window) AddMnemonic(keyval uint32, target Widgetter) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(keyval)
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("add_mnemonic", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(target)
}

// BeginMoveDrag starts moving a window. This function is used if an application
// has window movement grips. When GDK can support it, the window movement will
// be done using the standard mechanism for the [window manager][gtk-X11-arch]
// or windowing system. Otherwise, GDK will try to emulate window movement,
// potentially not all that well, depending on the windowing system.
//
// The function takes the following parameters:
//
//    - button: mouse button that initiated the drag.
//    - rootX: x position where the user clicked to initiate the drag, in root
//      window coordinates.
//    - rootY: y position where the user clicked to initiate the drag.
//    - timestamp from the click event that initiated the drag.
//
func (window *Window) BeginMoveDrag(button, rootX, rootY int32, timestamp uint32) {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(button)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(rootX)
	*(*C.gint)(unsafe.Pointer(&_args[3])) = C.gint(rootY)
	*(*C.guint32)(unsafe.Pointer(&_args[4])) = C.guint32(timestamp)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("begin_move_drag", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(button)
	runtime.KeepAlive(rootX)
	runtime.KeepAlive(rootY)
	runtime.KeepAlive(timestamp)
}

// Close requests that the window is closed, similar to what happens when a
// window manager close button is clicked.
//
// This function can be used with close buttons in custom titlebars.
func (window *Window) Close() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("close", _args[:], nil)

	runtime.KeepAlive(window)
}

// Deiconify asks to deiconify (i.e. unminimize) the specified window. Note that
// you shouldn’t assume the window is definitely deiconified afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch])) could
// iconify it again before your code which assumes deiconification gets to run.
//
// You can track iconification via the “window-state-event” signal on Widget.
func (window *Window) Deiconify() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("deiconify", _args[:], nil)

	runtime.KeepAlive(window)
}

// Fullscreen asks to place window in the fullscreen state. Note that you
// shouldn’t assume the window is definitely full screen afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unfullscreen it again, and not all window managers honor requests to
// fullscreen windows. But normally the window will end up fullscreen. Just
// don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (window *Window) Fullscreen() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("fullscreen", _args[:], nil)

	runtime.KeepAlive(window)
}

// FullscreenOnMonitor asks to place window in the fullscreen state. Note that
// you shouldn't assume the window is definitely full screen afterward.
//
// You can track the fullscreen state via the "window-state-event" signal on
// Widget.
//
// The function takes the following parameters:
//
//    - screen to draw to.
//    - monitor: which monitor to go fullscreen on.
//
func (window *Window) FullscreenOnMonitor(screen *gdk.Screen, monitor int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(monitor)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("fullscreen_on_monitor", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(monitor)
}

// AcceptFocus gets the value set by gtk_window_set_accept_focus().
//
// The function returns the following values:
//
//    - ok: TRUE if window should receive the input focus.
//
func (window *Window) AcceptFocus() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_accept_focus", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Application gets the Application associated with the window (if any).
//
// The function returns the following values:
//
//    - application (optional) or NULL.
//
func (window *Window) Application() *Application {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_application", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _application *Application // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_application = wrapApplication(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	}

	return _application
}

// AttachedTo fetches the attach widget for this window. See
// gtk_window_set_attached_to().
//
// The function returns the following values:
//
//    - widget (optional) where the window is attached, or NULL if the window is
//      not attached to any widget.
//
func (window *Window) AttachedTo() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_attached_to", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Decorated returns whether the window has been set to have decorations such as
// a title bar via gtk_window_set_decorated().
//
// The function returns the following values:
//
//    - ok: TRUE if the window has been set to have decorations.
//
func (window *Window) Decorated() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_decorated", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DefaultSize gets the default size of the window. A value of -1 for the width
// or height indicates that a default size has not been explicitly set for that
// dimension, so the “natural” size of the window will be used.
//
// The function returns the following values:
//
//    - width (optional): location to store the default width, or NULL.
//    - height (optional): location to store the default height, or NULL.
//
func (window *Window) DefaultSize() (width, height int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("get_default_size", _args[:], _outs[:])

	runtime.KeepAlive(window)

	var _width int32  // out
	var _height int32 // out

	_width = int32(*(*C.gint)(unsafe.Pointer(&_outs[0])))
	_height = int32(*(*C.gint)(unsafe.Pointer(&_outs[1])))

	return _width, _height
}

// DefaultWidget returns the default widget for window. See
// gtk_window_set_default() for more details.
//
// The function returns the following values:
//
//    - widget (optional): default widget, or NULL if there is none.
//
func (window *Window) DefaultWidget() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_default_widget", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Deletable returns whether the window has been set to have a close button via
// gtk_window_set_deletable().
//
// The function returns the following values:
//
//    - ok: TRUE if the window has been set to have a close button.
//
func (window *Window) Deletable() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_deletable", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DestroyWithParent returns whether the window will be destroyed with its
// transient parent. See gtk_window_set_destroy_with_parent ().
//
// The function returns the following values:
//
//    - ok: TRUE if the window will be destroyed with its transient parent.
//
func (window *Window) DestroyWithParent() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_destroy_with_parent", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Focus retrieves the current focused widget within the window. Note that this
// is the widget that would have the focus if the toplevel window focused; if
// the toplevel window is not focused then gtk_widget_has_focus (widget) will
// not be TRUE for the widget.
//
// The function returns the following values:
//
//    - widget (optional): currently focused widget, or NULL if there is none.
//
func (window *Window) Focus() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_focus", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
//
// The function returns the following values:
//
//    - ok: TRUE if window should receive the input focus when mapped.
//
func (window *Window) FocusOnMap() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_focus_on_map", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// FocusVisible gets the value of the Window:focus-visible property.
//
// The function returns the following values:
//
//    - ok: TRUE if “focus rectangles” are supposed to be visible in this window.
//
func (window *Window) FocusVisible() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_focus_visible", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Group returns the group for window or the default group, if window is NULL or
// if window does not have an explicit window group.
//
// The function returns the following values:
//
//    - windowGroup for a window or the default group.
//
func (window *Window) Group() *WindowGroup {
	var _args [1]girepository.Argument

	if window != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_group", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _windowGroup *WindowGroup // out

	_windowGroup = wrapWindowGroup(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _windowGroup
}

// HasResizeGrip determines whether the window may have a resize grip.
//
// Deprecated: Resize grips have been removed.
//
// The function returns the following values:
//
//    - ok: TRUE if the window has a resize grip.
//
func (window *Window) HasResizeGrip() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_has_resize_grip", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// HideTitlebarWhenMaximized returns whether the window has requested to have
// its titlebar hidden when maximized. See
// gtk_window_set_hide_titlebar_when_maximized ().
//
// The function returns the following values:
//
//    - ok: TRUE if the window has requested to have its titlebar hidden when
//      maximized.
//
func (window *Window) HideTitlebarWhenMaximized() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_hide_titlebar_when_maximized", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Icon gets the value set by gtk_window_set_icon() (or if you've called
// gtk_window_set_icon_list(), gets the first icon in the icon list).
//
// The function returns the following values:
//
//    - pixbuf (optional): icon for window or NULL if none.
//
func (window *Window) Icon() *gdkpixbuf.Pixbuf {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_icon", _args[:], nil)
	_cret := *(**C.GdkPixbuf)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if *(**C.GdkPixbuf)(unsafe.Pointer(&_cret)) != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(*(**C.GdkPixbuf)(unsafe.Pointer(&_cret))))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// IconList retrieves the list of icons set by gtk_window_set_icon_list(). The
// list is copied, but the reference count on each member won’t be incremented.
//
// The function returns the following values:
//
//    - list: copy of window’s icon list.
//
func (window *Window) IconList() []*gdkpixbuf.Pixbuf {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_icon_list", _args[:], nil)
	_cret := *(**C.GList)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _list []*gdkpixbuf.Pixbuf // out

	_list = make([]*gdkpixbuf.Pixbuf, 0, gextras.ListSize(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret)))))
	gextras.MoveList(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret))), true, func(v unsafe.Pointer) {
		src := (*C.GdkPixbuf)(v)
		var dst *gdkpixbuf.Pixbuf // out
		{
			obj := coreglib.Take(unsafe.Pointer(*(**C.GdkPixbuf)(unsafe.Pointer(&src))))
			dst = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
		_list = append(_list, dst)
	})

	return _list
}

// IconName returns the name of the themed icon for the window, see
// gtk_window_set_icon_name().
//
// The function returns the following values:
//
//    - utf8 (optional): icon name or NULL if the window has no themed icon.
//
func (window *Window) IconName() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_icon_name", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _utf8 string // out

	if *(**C.gchar)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
	}

	return _utf8
}

// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
//
// The function returns the following values:
//
//    - ok: TRUE if mnemonics are supposed to be visible in this window.
//
func (window *Window) MnemonicsVisible() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_mnemonics_visible", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Modal returns whether the window is modal. See gtk_window_set_modal().
//
// The function returns the following values:
//
//    - ok: TRUE if the window is set to be modal and establishes a grab when
//      shown.
//
func (window *Window) Modal() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_modal", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Opacity fetches the requested opacity for this window. See
// gtk_window_set_opacity().
//
// Deprecated: Use gtk_widget_get_opacity instead.
//
// The function returns the following values:
//
//    - gdouble: requested opacity for this window.
//
func (window *Window) Opacity() float64 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_opacity", _args[:], nil)
	_cret := *(*C.gdouble)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _gdouble float64 // out

	_gdouble = float64(*(*C.gdouble)(unsafe.Pointer(&_cret)))

	return _gdouble
}

// Position: this function returns the position you need to pass to
// gtk_window_move() to keep window in its current position. This means that the
// meaning of the returned value varies with window gravity. See
// gtk_window_move() for more details.
//
// The reliability of this function depends on the windowing system currently in
// use. Some windowing systems, such as Wayland, do not support a global
// coordinate system, and thus the position of the window will always be (0, 0).
// Others, like X11, do not have a reliable way to obtain the geometry of the
// decorations of a window if they are provided by the window manager.
// Additionally, on X11, window manager have been known to mismanage window
// gravity, which result in windows moving even if you use the coordinates of
// the current position as returned by this function.
//
// If you haven’t changed the window gravity, its gravity will be
// K_GRAVITY_NORTH_WEST. This means that gtk_window_get_position() gets the
// position of the top-left corner of the window manager frame for the window.
// gtk_window_move() sets the position of this same top-left corner.
//
// If a window has gravity K_GRAVITY_STATIC the window manager frame is not
// relevant, and thus gtk_window_get_position() will always produce accurate
// results. However you can’t use static gravity to do things like place a
// window in a corner of the screen, because static gravity ignores the window
// manager decorations.
//
// Ideally, this function should return appropriate values if the window has
// client side decorations, assuming that the windowing system supports global
// coordinates.
//
// In practice, saving the window position should not be left to applications,
// as they lack enough knowledge of the windowing system and the window manager
// state to effectively do so. The appropriate way to implement saving the
// window position is to use a platform-specific protocol, wherever that is
// available.
//
// The function returns the following values:
//
//    - rootX (optional): return location for X coordinate of gravity-determined
//      reference point, or NULL.
//    - rootY (optional): return location for Y coordinate of gravity-determined
//      reference point, or NULL.
//
func (window *Window) Position() (rootX, rootY int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("get_position", _args[:], _outs[:])

	runtime.KeepAlive(window)

	var _rootX int32 // out
	var _rootY int32 // out

	_rootX = int32(*(*C.gint)(unsafe.Pointer(&_outs[0])))
	_rootY = int32(*(*C.gint)(unsafe.Pointer(&_outs[1])))

	return _rootX, _rootY
}

// Resizable gets the value set by gtk_window_set_resizable().
//
// The function returns the following values:
//
//    - ok: TRUE if the user can resize the window.
//
func (window *Window) Resizable() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_resizable", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ResizeGripArea: if a window has a resize grip, this will retrieve the grip
// position, width and height into the specified Rectangle.
//
// Deprecated: Resize grips have been removed.
//
// The function returns the following values:
//
//    - rect: pointer to a Rectangle which we should store the resize grip area.
//    - ok: TRUE if the resize grip’s area was retrieved.
//
func (window *Window) ResizeGripArea() (*gdk.Rectangle, bool) {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_resize_grip_area", _args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _rect *gdk.Rectangle // out
	var _ok bool             // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0])))))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _rect, _ok
}

// Role returns the role of the window. See gtk_window_set_role() for further
// explanation.
//
// The function returns the following values:
//
//    - utf8 (optional): role of the window if set, or NULL. The returned is
//      owned by the widget and must not be modified or freed.
//
func (window *Window) Role() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_role", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _utf8 string // out

	if *(**C.gchar)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
	}

	return _utf8
}

// Screen returns the Screen associated with window.
//
// The function returns the following values:
//
//    - screen: Screen.
//
func (window *Window) Screen() *gdk.Screen {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_screen", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _screen *gdk.Screen // out

	{
		obj := coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret))))
		_screen = &gdk.Screen{
			Object: obj,
		}
	}

	return _screen
}

// Size obtains the current size of window.
//
// If window is not visible on screen, this function return the size GTK+ will
// suggest to the [window manager][gtk-X11-arch] for the initial window size
// (but this is not reliably the same as the size the window manager will
// actually select). See: gtk_window_set_default_size().
//
// Depending on the windowing system and the window manager constraints, the
// size returned by this function may not match the size set using
// gtk_window_resize(); additionally, since gtk_window_resize() may be
// implemented as an asynchronous operation, GTK+ cannot guarantee in any way
// that this code:
//
//    static void
//    on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
//    {
//      int new_width, new_height;
//
//      gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
//
//      ...
//    }
//
// Note that, if you connect to the Widget::size-allocate signal, you should not
// use the dimensions of the Allocation passed to the signal handler, as the
// allocation may contain client side decorations added by GTK+, depending on
// the windowing system in use.
//
// If you are getting a window size in order to position the window on the
// screen, you should, instead, simply set the window’s semantic type with
// gtk_window_set_type_hint(), which allows the window manager to e.g. center
// dialogs. Also, if you set the transient parent of dialogs with
// gtk_window_set_transient_for() window managers will often center the dialog
// over its parent window. It's much preferred to let the window manager handle
// these cases rather than doing it yourself, because all apps will behave
// consistently and according to user or system preferences, if the window
// manager handles it. Also, the window manager can take into account the size
// of the window decorations and border that it may add, and of which GTK+ has
// no knowledge. Additionally, positioning windows in global screen coordinates
// may not be allowed by the windowing system. For more information, see:
// gtk_window_set_position().
//
// The function returns the following values:
//
//    - width (optional): return location for width, or NULL.
//    - height (optional): return location for height, or NULL.
//
func (window *Window) Size() (width, height int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("get_size", _args[:], _outs[:])

	runtime.KeepAlive(window)

	var _width int32  // out
	var _height int32 // out

	_width = int32(*(*C.gint)(unsafe.Pointer(&_outs[0])))
	_height = int32(*(*C.gint)(unsafe.Pointer(&_outs[1])))

	return _width, _height
}

// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
//
// The function returns the following values:
//
//    - ok: TRUE if window shouldn’t be in pager.
//
func (window *Window) SkipPagerHint() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_skip_pager_hint", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint().
//
// The function returns the following values:
//
//    - ok: TRUE if window shouldn’t be in taskbar.
//
func (window *Window) SkipTaskbarHint() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_skip_taskbar_hint", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the window. See gtk_window_set_title().
//
// The function returns the following values:
//
//    - utf8 (optional): title of the window, or NULL if none has been set
//      explicitly. The returned string is owned by the widget and must not be
//      modified or freed.
//
func (window *Window) Title() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_title", _args[:], nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _utf8 string // out

	if *(**C.gchar)(unsafe.Pointer(&_cret)) != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))
	}

	return _utf8
}

// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
//
// The function returns the following values:
//
//    - widget (optional): custom titlebar, or NULL.
//
func (window *Window) Titlebar() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_titlebar", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// TransientFor fetches the transient parent for this window. See
// gtk_window_set_transient_for().
//
// The function returns the following values:
//
//    - ret (optional): transient parent for this window, or NULL if no transient
//      parent has been set.
//
func (window *Window) TransientFor() *Window {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_transient_for", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ret *Window // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_ret = wrapWindow(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	}

	return _ret
}

// UrgencyHint gets the value set by gtk_window_set_urgency_hint().
//
// The function returns the following values:
//
//    - ok: TRUE if window is urgent.
//
func (window *Window) UrgencyHint() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("get_urgency_hint", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// HasGroup returns whether window has an explicit window group.
//
// The function returns the following values:
//
//    - ok: TRUE if window has an explicit window group.
//
//      Since 2.22.
//
func (window *Window) HasGroup() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("has_group", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// HasToplevelFocus returns whether the input focus is within this GtkWindow.
// For real toplevel windows, this is identical to gtk_window_is_active(), but
// for embedded windows, like Plug, the results will differ.
//
// The function returns the following values:
//
//    - ok: TRUE if the input focus is within this GtkWindow.
//
func (window *Window) HasToplevelFocus() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("has_toplevel_focus", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Iconify asks to iconify (i.e. minimize) the specified window. Note that you
// shouldn’t assume the window is definitely iconified afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could deiconify it
// again, or there may not be a window manager in which case iconification isn’t
// possible, etc. But normally the window will end up iconified. Just don’t
// write code that crashes if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be iconified before it ever appears onscreen.
//
// You can track iconification via the “window-state-event” signal on Widget.
func (window *Window) Iconify() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("iconify", _args[:], nil)

	runtime.KeepAlive(window)
}

// IsActive returns whether the window is part of the current active toplevel.
// (That is, the toplevel window receiving keystrokes.) The return value is TRUE
// if the window is active toplevel itself, but also if it is, say, a Plug
// embedded in the active toplevel. You might use this function if you wanted to
// draw a widget differently in an active window from a widget in an inactive
// window. See gtk_window_has_toplevel_focus().
//
// The function returns the following values:
//
//    - ok: TRUE if the window part of the current active window.
//
func (window *Window) IsActive() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("is_active", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsMaximized retrieves the current maximized state of window.
//
// Note that since maximization is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk_window_maximize() or gtk_window_unmaximize().
//
// The function returns the following values:
//
//    - ok: whether the window has a maximized state.
//
func (window *Window) IsMaximized() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("is_maximized", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Maximize asks to maximize window, so that it becomes full-screen. Note that
// you shouldn’t assume the window is definitely maximized afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unmaximize it again, and not all window managers support maximization. But
// normally the window will end up maximized. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be maximized when it appears onscreen initially.
//
// You can track maximization via the “window-state-event” signal on Widget, or
// by listening to notifications on the Window:is-maximized property.
func (window *Window) Maximize() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("maximize", _args[:], nil)

	runtime.KeepAlive(window)
}

// Move asks the [window manager][gtk-X11-arch] to move window to the given
// position. Window managers are free to ignore this; most window managers
// ignore requests for initial window positions (instead using a user-defined
// placement algorithm) and honor requests after the window has already been
// shown.
//
// Note: the position is the position of the gravity-determined reference point
// for the window. The gravity determines two things: first, the location of the
// reference point in root window coordinates; and second, which point on the
// window is positioned at the reference point.
//
// By default the gravity is K_GRAVITY_NORTH_WEST, so the reference point is
// simply the x, y supplied to gtk_window_move(). The top-left corner of the
// window decorations (aka window frame or border) will be placed at x, y.
// Therefore, to position a window at the top left of the screen, you want to
// use the default gravity (which is K_GRAVITY_NORTH_WEST) and move the window
// to 0,0.
//
// To position a window at the bottom right corner of the screen, you would set
// K_GRAVITY_SOUTH_EAST, which means that the reference point is at x + the
// window width and y + the window height, and the bottom-right corner of the
// window border will be placed at that reference point. So, to place a window
// in the bottom right corner you would first set gravity to south east, then
// write: gtk_window_move (window, gdk_screen_width () - window_width,
// gdk_screen_height () - window_height) (note that this example does not take
// multi-head scenarios into account).
//
// The Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec) has a nice table of gravities
// in the “implementation notes” section.
//
// The gtk_window_get_position() documentation may also be relevant.
//
// The function takes the following parameters:
//
//    - x: x coordinate to move window to.
//    - y: y coordinate to move window to.
//
func (window *Window) Move(x, y int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(x)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(y)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("move", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// ParseGeometry parses a standard X Window System geometry string - see the
// manual page for X (type “man X”) for details on this.
// gtk_window_parse_geometry() does work on all GTK+ ports including Win32 but
// is primarily intended for an X environment.
//
// If either a size or a position can be extracted from the geometry string,
// gtk_window_parse_geometry() returns TRUE and calls
// gtk_window_set_default_size() and/or gtk_window_move() to resize/move the
// window.
//
// If gtk_window_parse_geometry() returns TRUE, it will also set the
// K_HINT_USER_POS and/or K_HINT_USER_SIZE hints indicating to the window
// manager that the size/position of the window was user-specified. This causes
// most window managers to honor the geometry.
//
// Note that for gtk_window_parse_geometry() to work as expected, it has to be
// called when the window has its “final” size, i.e. after calling
// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints() on
// the window.
//
//    #include <gtk/gtk.h>
//
//    static void
//    fill_with_content (GtkWidget *vbox)
//    {
//      // fill with content...
//    }
//
//    int
//    main (int argc, char *argv[])
//    {
//      GtkWidget *window, *vbox;
//      GdkGeometry size_hints = {
//        100, 50, 0, 0, 100, 50, 10,
//        10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
//      };
//
//      gtk_init (&argc, &argv);
//
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
//
//      gtk_container_add (GTK_CONTAINER (window), vbox);
//      fill_with_content (vbox);
//      gtk_widget_show_all (vbox);
//
//      gtk_window_set_geometry_hints (GTK_WINDOW (window),
//    	  			    NULL,
//    				    &size_hints,
//    				    GDK_HINT_MIN_SIZE |
//    				    GDK_HINT_BASE_SIZE |
//    				    GDK_HINT_RESIZE_INC);
//
//      if (argc > 1)
//        {
//          gboolean res;
//          res = gtk_window_parse_geometry (GTK_WINDOW (window),
//                                           argv[1]);
//          if (! res)
//            fprintf (stderr,
//                     "Failed to parse “s”\n",
//                     argv[1]);
//        }
//
//      gtk_widget_show_all (window);
//      gtk_main ();
//
//      return 0;
//    }
//
// Deprecated: Geometry handling in GTK is deprecated.
//
// The function takes the following parameters:
//
//    - geometry string.
//
// The function returns the following values:
//
//    - ok: TRUE if string was parsed successfully.
//
func (window *Window) ParseGeometry(geometry string) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(geometry)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("parse_geometry", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)
	runtime.KeepAlive(geometry)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Present presents a window to the user. This function should not be used as
// when it is called, it is too late to gather a valid timestamp to allow focus
// stealing prevention to work correctly.
func (window *Window) Present() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("present", _args[:], nil)

	runtime.KeepAlive(window)
}

// PresentWithTime presents a window to the user. This may mean raising the
// window in the stacking order, deiconifying it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent on the
// user’s platform, window manager, and preferences.
//
// If window is hidden, this function calls gtk_widget_show() as well.
//
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open, and
// the user chooses Preferences from the menu a second time; use
// gtk_window_present() to move the already-open dialog where the user can see
// it.
//
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown (when
// clicking a link for example), rather than once the window is ready to be
// shown.
//
// The function takes the following parameters:
//
//    - timestamp of the user interaction (typically a button or key press event)
//      which triggered this call.
//
func (window *Window) PresentWithTime(timestamp uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.guint32)(unsafe.Pointer(&_args[1])) = C.guint32(timestamp)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("present_with_time", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(timestamp)
}

// PropagateKeyEvent: propagate a key press or release event to the focus widget
// and up the focus container chain until a widget handles event. This is
// normally called by the default ::key_press_event and ::key_release_event
// handlers for toplevel windows, however in some cases it may be useful to call
// this directly when overriding the standard key handling for a toplevel
// window.
//
// The function takes the following parameters:
//
//    - event: EventKey.
//
// The function returns the following values:
//
//    - ok: TRUE if a widget in the focus chain handled the event.
//
func (window *Window) PropagateKeyEvent(event *gdk.EventKey) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(event)))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("propagate_key_event", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)
	runtime.KeepAlive(event)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
//
// The function takes the following parameters:
//
//    - accelGroup: AccelGroup.
//
func (window *Window) RemoveAccelGroup(accelGroup *AccelGroup) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("remove_accel_group", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(accelGroup)
}

// RemoveMnemonic removes a mnemonic from this window.
//
// The function takes the following parameters:
//
//    - keyval: mnemonic.
//    - target: widget that gets activated by the mnemonic.
//
func (window *Window) RemoveMnemonic(keyval uint32, target Widgetter) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(keyval)
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("remove_mnemonic", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(target)
}

// ReshowWithInitialSize hides window, then reshows it, resetting the default
// size and position of the window. Used by GUI builders only.
//
// Deprecated: GUI builders can call gtk_widget_hide(), gtk_widget_unrealize()
// and then gtk_widget_show() on window themselves, if they still need this
// functionality.
func (window *Window) ReshowWithInitialSize() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("reshow_with_initial_size", _args[:], nil)

	runtime.KeepAlive(window)
}

// Resize resizes the window as if the user had done so, obeying geometry
// constraints. The default geometry constraint is that windows may not be
// smaller than their size request; to override this constraint, call
// gtk_widget_set_size_request() to set the window's request to a smaller value.
//
// If gtk_window_resize() is called before showing a window for the first time,
// it overrides any default size set with gtk_window_set_default_size().
//
// Windows may not be resized smaller than 1 by 1 pixels.
//
// When using client side decorations, GTK+ will do its best to adjust the given
// size so that the resulting window size matches the requested size without the
// title bar, borders and shadows added for the client side decorations, but
// there is no guarantee that the result will be totally accurate because these
// widgets added for client side decorations depend on the theme and may not be
// realized or visible at the time gtk_window_resize() is issued.
//
// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()), then
// typically, gtk_window_resize() will compensate for the height of the titlebar
// widget only if the height is known when the resulting GtkWindow configuration
// is issued. For example, if new widgets are added after the GtkWindow
// configuration and cause the titlebar widget to grow in height, this will
// result in a window content smaller that specified by gtk_window_resize() and
// not a larger window.
//
// The function takes the following parameters:
//
//    - width in pixels to resize the window to.
//    - height in pixels to resize the window to.
//
func (window *Window) Resize(width, height int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(width)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(height)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("resize", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// ResizeGripIsVisible determines whether a resize grip is visible for the
// specified window.
//
// Deprecated: Resize grips have been removed.
//
// The function returns the following values:
//
//    - ok: TRUE if a resize grip exists and is visible.
//
func (window *Window) ResizeGripIsVisible() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_gret := _info.InvokeClassMethod("resize_grip_is_visible", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(window)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ResizeToGeometry: like gtk_window_resize(), but width and height are
// interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
//
// Deprecated: This function does nothing. Use gtk_window_resize() and compute
// the geometry yourself.
//
// The function takes the following parameters:
//
//    - width in resize increments to resize the window to.
//    - height in resize increments to resize the window to.
//
func (window *Window) ResizeToGeometry(width, height int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(width)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(height)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("resize_to_geometry", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetAcceptFocus windows may set a hint asking the desktop environment not to
// receive the input focus. This function sets this hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to let this window receive input focus.
//
func (window *Window) SetAcceptFocus(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_accept_focus", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetApplication sets or unsets the Application associated with the window.
//
// The application will be kept alive for at least as long as it has any windows
// associated with it (see g_application_hold() for a way to keep it alive
// without windows).
//
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it by setting
// the application to NULL.
//
// This is equivalent to calling gtk_application_remove_window() and/or
// gtk_application_add_window() on the old/new applications as relevant.
//
// The function takes the following parameters:
//
//    - application (optional) or NULL to unset.
//
func (window *Window) SetApplication(application *Application) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if application != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_application", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(application)
}

// SetAttachedTo marks window as attached to attach_widget. This creates a
// logical binding between the window and the widget it belongs to, which is
// used by GTK+ to propagate information such as styling or accessibility to
// window as if it was a children of attach_widget.
//
// Examples of places where specifying this relation is useful are for instance
// a Menu created by a ComboBox, a completion popup window created by Entry or a
// typeahead search entry created by TreeView.
//
// Note that this function should not be confused with
// gtk_window_set_transient_for(), which specifies a window manager relation
// between two toplevels instead.
//
// Passing NULL for attach_widget detaches the window.
//
// The function takes the following parameters:
//
//    - attachWidget (optional) or NULL.
//
func (window *Window) SetAttachedTo(attachWidget Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if attachWidget != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(attachWidget).Native()))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_attached_to", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(attachWidget)
}

// SetDecorated: by default, windows are decorated with a title bar, resize
// controls, etc. Some [window managers][gtk-X11-arch] allow GTK+ to disable
// these decorations, creating a borderless window. If you set the decorated
// property to FALSE using this function, GTK+ will do its best to convince the
// window manager not to decorate the window. Depending on the system, this
// function may not have any effect when called on a window that is already
// visible, so you should call it before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
//
// The function takes the following parameters:
//
//    - setting: TRUE to decorate the window.
//
func (window *Window) SetDecorated(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_decorated", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDefault: default widget is the widget that’s activated when the user
// presses Enter in a dialog (for example). This function sets or unsets the
// default widget for a Window. When setting (rather than unsetting) the default
// widget it’s generally easier to call gtk_widget_grab_default() on the widget.
// Before making a widget the default widget, you must call
// gtk_widget_set_can_default() on the widget you’d like to make the default.
//
// The function takes the following parameters:
//
//    - defaultWidget (optional): widget to be the default, or NULL to unset the
//      default widget for the toplevel.
//
func (window *Window) SetDefault(defaultWidget Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if defaultWidget != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(defaultWidget).Native()))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_default", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(defaultWidget)
}

// SetDefaultGeometry: like gtk_window_set_default_size(), but width and height
// are interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
//
// Deprecated: This function does nothing. If you want to set a default size,
// use gtk_window_set_default_size() instead.
//
// The function takes the following parameters:
//
//    - width in resize increments, or -1 to unset the default width.
//    - height in resize increments, or -1 to unset the default height.
//
func (window *Window) SetDefaultGeometry(width, height int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(width)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(height)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_default_geometry", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetDefaultSize sets the default size of a window. If the window’s “natural”
// size (its size request) is larger than the default, the default will be
// ignored. More generally, if the default size does not obey the geometry hints
// for the window (gtk_window_set_geometry_hints() can be used to set these
// explicitly), the default size will be clamped to the nearest permitted size.
//
// Unlike gtk_widget_set_size_request(), which sets a size request for a widget
// and thus would keep users from shrinking the window, this function only sets
// the initial size, just as if the user had resized the window themselves.
// Users can still shrink the window again as they normally would. Setting a
// default size of -1 means to use the “natural” default size (the size request
// of the window).
//
// For more control over a window’s initial size and how resizing works,
// investigate gtk_window_set_geometry_hints().
//
// For some uses, gtk_window_resize() is a more appropriate function.
// gtk_window_resize() changes the current size of the window, rather than the
// size to be used on initial display. gtk_window_resize() always affects the
// window itself, not the geometry widget.
//
// The default size of a window only affects the first time a window is shown;
// if a window is hidden and re-shown, it will remember the size it had prior to
// hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but passing
// 0 for width and height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size, note
// that the appropriate size to save is the one returned by
// gtk_window_get_size(). Using the window allocation directly will not work in
// all circumstances and can lead to growing or shrinking windows.
//
// The function takes the following parameters:
//
//    - width in pixels, or -1 to unset the default width.
//    - height in pixels, or -1 to unset the default height.
//
func (window *Window) SetDefaultSize(width, height int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(width)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(height)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_default_size", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetDeletable: by default, windows have a close button in the window frame.
// Some [window managers][gtk-X11-arch] allow GTK+ to disable this button. If
// you set the deletable property to FALSE using this function, GTK+ will do its
// best to convince the window manager not to show a close button. Depending on
// the system, this function may not have any effect when called on a window
// that is already visible, so you should call it before calling
// gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
//
// The function takes the following parameters:
//
//    - setting: TRUE to decorate the window as deletable.
//
func (window *Window) SetDeletable(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_deletable", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDestroyWithParent: if setting is TRUE, then destroying the transient
// parent of window will also destroy window itself. This is useful for dialogs
// that shouldn’t persist beyond the lifetime of the main window they're
// associated with, for example.
//
// The function takes the following parameters:
//
//    - setting: whether to destroy window with its transient parent.
//
func (window *Window) SetDestroyWithParent(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_destroy_with_parent", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetFocus: if focus is not the current focus widget, and is focusable, sets it
// as the focus widget for the window. If focus is NULL, unsets the focus widget
// for this window. To set the focus to a particular widget in the toplevel, it
// is usually more convenient to use gtk_widget_grab_focus() instead of this
// function.
//
// The function takes the following parameters:
//
//    - focus (optional): widget to be the new focus widget, or NULL to unset any
//      focus widget for the toplevel window.
//
func (window *Window) SetFocus(focus Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if focus != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(focus).Native()))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_focus", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(focus)
}

// SetFocusOnMap windows may set a hint asking the desktop environment not to
// receive the input focus when the window is mapped. This function sets this
// hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to let this window receive input focus on map.
//
func (window *Window) SetFocusOnMap(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_focus_on_map", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetFocusVisible sets the Window:focus-visible property.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (window *Window) SetFocusVisible(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_focus_visible", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetHasResizeGrip sets whether window has a corner resize grip.
//
// Note that the resize grip is only shown if the window is actually resizable
// and not maximized. Use gtk_window_resize_grip_is_visible() to find out if the
// resize grip is currently shown.
//
// Deprecated: Resize grips have been removed.
//
// The function takes the following parameters:
//
//    - value: TRUE to allow a resize grip.
//
func (window *Window) SetHasResizeGrip(value bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if value {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_has_resize_grip", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(value)
}

// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
// window when gtk_widget_destroy() is called.
//
// This function is only exported for the benefit of language bindings which may
// need to keep the window alive until their wrapper object is garbage
// collected. There is no justification for ever calling this function in an
// application.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (window *Window) SetHasUserRefCount(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_has_user_ref_count", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetHideTitlebarWhenMaximized: if setting is TRUE, then window will request
// that it’s titlebar should be hidden when maximized. This is useful for
// windows that don’t convey any information other than the application name in
// the titlebar, to put the available screen space to better use. If the
// underlying window system does not support the request, the setting will not
// have any effect.
//
// Note that custom titlebars set with gtk_window_set_titlebar() are not
// affected by this. The application is in full control of their content and
// visibility anyway.
//
// The function takes the following parameters:
//
//    - setting: whether to hide the titlebar when window is maximized.
//
func (window *Window) SetHideTitlebarWhenMaximized(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_hide_titlebar_when_maximized", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetIcon sets up the icon representing a Window. This icon is used when the
// window is minimized (also known as iconified). Some window managers or
// desktop environments may also place it in the window frame, or display it in
// other contexts. On others, the icon is not used at all, so your mileage may
// vary.
//
// The icon should be provided in whatever size it was naturally drawn; that is,
// don’t scale the image before passing it to GTK+. Scaling is postponed until
// the last minute, when the desired final size is known, to allow best quality.
//
// If you have your icon hand-drawn in multiple sizes, use
// gtk_window_set_icon_list(). Then the best size will be used.
//
// This function is equivalent to calling gtk_window_set_icon_list() with a
// 1-element list.
//
// See also gtk_window_set_default_icon_list() to set the icon for all windows
// in your application in one go.
//
// The function takes the following parameters:
//
//    - icon (optional) image, or NULL.
//
func (window *Window) SetIcon(icon *gdkpixbuf.Pixbuf) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if icon != nil {
		*(**C.GdkPixbuf)(unsafe.Pointer(&_args[1])) = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_icon", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(icon)
}

// SetIconFromFile sets the icon for window. Warns on failure if err is NULL.
//
// This function is equivalent to calling gtk_window_set_icon() with a pixbuf
// created by loading the image from filename.
//
// The function takes the following parameters:
//
//    - filename: location of icon file.
//
func (window *Window) SetIconFromFile(filename string) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_icon_from_file", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// SetIconList sets up the icon representing a Window. The icon is used when the
// window is minimized (also known as iconified). Some window managers or
// desktop environments may also place it in the window frame, or display it in
// other contexts. On others, the icon is not used at all, so your mileage may
// vary.
//
// gtk_window_set_icon_list() allows you to pass in the same icon in several
// hand-drawn sizes. The list should contain the natural sizes your icon is
// available in; that is, don’t scale the image before passing it to GTK+.
// Scaling is postponed until the last minute, when the desired final size is
// known, to allow best quality.
//
// By passing several sizes, you may improve the final image quality of the
// icon, by reducing or eliminating automatic image scaling.
//
// Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and larger
// images (64x64, 128x128) if you have them.
//
// See also gtk_window_set_default_icon_list() to set the icon for all windows
// in your application in one go.
//
// Note that transient windows (those who have been set transient for another
// window using gtk_window_set_transient_for()) will inherit their icon from
// their transient parent. So there’s no need to explicitly set the icon on
// transient windows.
//
// The function takes the following parameters:
//
//    - list of Pixbuf.
//
func (window *Window) SetIconList(list []*gdkpixbuf.Pixbuf) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GdkPixbuf // out
		*(**C.GdkPixbuf)(unsafe.Pointer(&dst)) = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		*(**C.GList)(unsafe.Pointer(&_args[1])) = C.g_list_prepend(*(**C.GList)(unsafe.Pointer(&_args[1])), C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_args[1])

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_icon_list", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(list)
}

// SetIconName sets the icon for the window from a named themed icon. See the
// docs for IconTheme for more details. On some platforms, the window icon is
// not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
//
// The function takes the following parameters:
//
//    - name (optional) of the themed icon.
//
func (window *Window) SetIconName(name string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if name != "" {
		*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_icon_name", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(name)
}

// SetKeepAbove asks to keep window above, so that it stays on top. Note that
// you shouldn’t assume the window is definitely above afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// above, and not all window managers support keeping windows above. But
// normally the window will end kept above. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept above when it appears onscreen initially.
//
// You can track the above state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window above other windows.
//
func (window *Window) SetKeepAbove(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_keep_above", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetKeepBelow asks to keep window below, so that it stays in bottom. Note that
// you shouldn’t assume the window is definitely below afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// below, and not all window managers support putting windows below. But
// normally the window will be kept below. Just don’t write code that crashes if
// not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept below when it appears onscreen initially.
//
// You can track the below state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window below other windows.
//
func (window *Window) SetKeepBelow(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_keep_below", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetMnemonicsVisible sets the Window:mnemonics-visible property.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (window *Window) SetMnemonicsVisible(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_mnemonics_visible", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetModal sets a window modal or non-modal. Modal windows prevent interaction
// with other windows in the same application. To keep modal dialogs on top of
// main application windows, use gtk_window_set_transient_for() to make the
// dialog transient for the parent; most [window managers][gtk-X11-arch] will
// then disallow lowering the dialog below the parent.
//
// The function takes the following parameters:
//
//    - modal: whether the window is modal.
//
func (window *Window) SetModal(modal bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if modal {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_modal", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(modal)
}

// SetOpacity: request the windowing system to make window partially
// transparent, with opacity 0 being fully transparent and 1 fully opaque.
// (Values of the opacity parameter are clamped to the [0,1] range.) On X11 this
// has any effect only on X screens with a compositing manager running. See
// gtk_widget_is_composited(). On Windows it should work always.
//
// Note that setting a window’s opacity after the window has been shown causes
// it to flicker once on Windows.
//
// Deprecated: Use gtk_widget_set_opacity instead.
//
// The function takes the following parameters:
//
//    - opacity: desired opacity, between 0 and 1.
//
func (window *Window) SetOpacity(opacity float64) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.gdouble)(unsafe.Pointer(&_args[1])) = C.gdouble(opacity)

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_opacity", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(opacity)
}

// SetResizable sets whether the user can resize a window. Windows are user
// resizable by default.
//
// The function takes the following parameters:
//
//    - resizable: TRUE if the user can resize this window.
//
func (window *Window) SetResizable(resizable bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if resizable {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_resizable", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(resizable)
}

// SetRole: this function is only useful on X11, not with other GTK+ targets.
//
// In combination with the window title, the window role allows a [window
// manager][gtk-X11-arch] to identify "the same" window when an application is
// restarted. So for example you might set the “toolbox” role on your app’s
// toolbox window, so that when the user restarts their session, the window
// manager can put the toolbox back in the same place.
//
// If a window already has a unique title, you don’t need to set the role, since
// the WM can use the title to identify the window when restoring the session.
//
// The function takes the following parameters:
//
//    - role: unique identifier for the window to be used when restoring a
//      session.
//
func (window *Window) SetRole(role string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(role)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_role", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(role)
}

// SetScreen sets the Screen where the window is displayed; if the window is
// already mapped, it will be unmapped, and then remapped on the new screen.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
func (window *Window) SetScreen(screen *gdk.Screen) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_screen", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(screen)
}

// SetSkipPagerHint windows may set a hint asking the desktop environment not to
// display the window in the pager. This function sets this hint. (A "pager" is
// any desktop navigation tool such as a workspace switcher that displays a
// thumbnail representation of the windows on the screen.).
//
// The function takes the following parameters:
//
//    - setting: TRUE to keep this window from appearing in the pager.
//
func (window *Window) SetSkipPagerHint(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_skip_pager_hint", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetSkipTaskbarHint windows may set a hint asking the desktop environment not
// to display the window in the task bar. This function sets this hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to keep this window from appearing in the task bar.
//
func (window *Window) SetSkipTaskbarHint(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_skip_taskbar_hint", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetStartupID: startup notification identifiers are used by desktop
// environment to track application startup, to provide user feedback and other
// features. This function changes the corresponding property on the underlying
// GdkWindow. Normally, startup identifier is managed automatically and you
// should only use this function in special cases like transferring focus from
// other processes. You should use this function before calling
// gtk_window_present() or any equivalent function generating a window map
// event.
//
// This function is only useful on X11, not with other GTK+ targets.
//
// The function takes the following parameters:
//
//    - startupId: string with startup-notification identifier.
//
func (window *Window) SetStartupID(startupId string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_startup_id", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(startupId)
}

// SetTitle sets the title of the Window. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar is rendered
// by the [window manager][gtk-X11-arch], so exactly how the title appears to
// users may vary according to a user’s exact configuration. The title should
// help a user distinguish this window from other windows they may have open. A
// good title might include the application name and current document filename,
// for example.
//
// The function takes the following parameters:
//
//    - title of the window.
//
func (window *Window) SetTitle(title string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_title", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(title)
}

// SetTitlebar sets a custom titlebar for window.
//
// A typical widget used here is HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to it.
//
// If you set a custom titlebar, GTK+ will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the system,
// this function may not work for a window that is already visible, so you set
// the titlebar before calling gtk_widget_show().
//
// The function takes the following parameters:
//
//    - titlebar (optional): widget to use as titlebar.
//
func (window *Window) SetTitlebar(titlebar Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if titlebar != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(titlebar).Native()))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_titlebar", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(titlebar)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main window, or
// center the dialog over the main window. gtk_dialog_new_with_buttons() and
// other convenience functions in GTK+ will sometimes call
// gtk_window_set_transient_for() on your behalf.
//
// Passing NULL for parent unsets the current transient window.
//
// On Wayland, this function can also be used to attach a new K_WINDOW_POPUP to
// a K_WINDOW_TOPLEVEL parent already mapped on screen so that the
// K_WINDOW_POPUP will be created as a subsurface-based window
// K_WINDOW_SUBSURFACE which can be positioned at will relatively to the
// K_WINDOW_TOPLEVEL surface.
//
// On Windows, this function puts the child window on top of the parent, much as
// the window manager would have done on X.
//
// The function takes the following parameters:
//
//    - parent (optional) window, or NULL.
//
func (window *Window) SetTransientFor(parent *Window) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if parent != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_transient_for", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(parent)
}

// SetUrgencyHint windows may set a hint asking the desktop environment to draw
// the users attention to the window. This function sets this hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to mark this window as urgent.
//
func (window *Window) SetUrgencyHint(setting bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_urgency_hint", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetWmclass: don’t use this function. It sets the X Window System “class” and
// “name” hints for a window. According to the ICCCM, you should always set
// these to the same value for all windows in an application, and GTK+ sets them
// to that value by default, so calling this function is sort of pointless.
// However, you may want to call gtk_window_set_role() on each window in your
// application, for the benefit of the session manager. Setting the role allows
// the window manager to restore window positions when loading a saved session.
//
// Deprecated: since version 3.22.
//
// The function takes the following parameters:
//
//    - wmclassName: window name hint.
//    - wmclassClass: window class hint.
//
func (window *Window) SetWmclass(wmclassName, wmclassClass string) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(wmclassName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))
	*(**C.gchar)(unsafe.Pointer(&_args[2])) = (*C.gchar)(unsafe.Pointer(C.CString(wmclassClass)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[2]))))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("set_wmclass", _args[:], nil)

	runtime.KeepAlive(window)
	runtime.KeepAlive(wmclassName)
	runtime.KeepAlive(wmclassClass)
}

// Stick asks to stick window, which means that it will appear on all user
// desktops. Note that you shouldn’t assume the window is definitely stuck
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch] could unstick it again, and some window managers do
// not support sticking windows. But normally the window will end up stuck. Just
// don't write code that crashes if not.
//
// It’s permitted to call this function before showing a window.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (window *Window) Stick() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("stick", _args[:], nil)

	runtime.KeepAlive(window)
}

// Unfullscreen asks to toggle off the fullscreen state for window. Note that
// you shouldn’t assume the window is definitely not full screen afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could fullscreen it again, and not all window managers honor requests to
// unfullscreen windows. But normally the window will end up restored to its
// normal state. Just don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (window *Window) Unfullscreen() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("unfullscreen", _args[:], nil)

	runtime.KeepAlive(window)
}

// Unmaximize asks to unmaximize window. Note that you shouldn’t assume the
// window is definitely unmaximized afterward, because other entities (e.g. the
// user or [window manager][gtk-X11-arch]) could maximize it again, and not all
// window managers honor requests to unmaximize. But normally the window will
// end up unmaximized. Just don’t write code that crashes if not.
//
// You can track maximization via the “window-state-event” signal on Widget.
func (window *Window) Unmaximize() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("unmaximize", _args[:], nil)

	runtime.KeepAlive(window)
}

// Unstick asks to unstick window, which means that it will appear on only one
// of the user’s desktops. Note that you shouldn’t assume the window is
// definitely unstuck afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could stick it again. But normally the window
// will end up stuck. Just don’t write code that crashes if not.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (window *Window) Unstick() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "Window")
	_info.InvokeClassMethod("unstick", _args[:], nil)

	runtime.KeepAlive(window)
}

// WindowGetDefaultIconList gets the value set by
// gtk_window_set_default_icon_list(). The list is a copy and should be freed
// with g_list_free(), but the pixbufs in the list have not had their reference
// count incremented.
//
// The function returns the following values:
//
//    - list: copy of default icon list.
//
func WindowGetDefaultIconList() []*gdkpixbuf.Pixbuf {
	_info := girepository.MustFind("Gtk", "get_default_icon_list")
	_gret := _info.InvokeFunction(nil, nil)
	_cret := *(**C.GList)(unsafe.Pointer(&_gret))

	var _list []*gdkpixbuf.Pixbuf // out

	_list = make([]*gdkpixbuf.Pixbuf, 0, gextras.ListSize(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret)))))
	gextras.MoveList(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret))), true, func(v unsafe.Pointer) {
		src := (*C.GdkPixbuf)(v)
		var dst *gdkpixbuf.Pixbuf // out
		{
			obj := coreglib.Take(unsafe.Pointer(*(**C.GdkPixbuf)(unsafe.Pointer(&src))))
			dst = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
		_list = append(_list, dst)
	})

	return _list
}

// WindowGetDefaultIconName returns the fallback icon name for windows that has
// been set with gtk_window_set_default_icon_name(). The returned string is
// owned by GTK+ and should not be modified. It is only valid until the next
// call to gtk_window_set_default_icon_name().
//
// The function returns the following values:
//
//    - utf8: fallback icon name for windows.
//
func WindowGetDefaultIconName() string {
	_info := girepository.MustFind("Gtk", "get_default_icon_name")
	_gret := _info.InvokeFunction(nil, nil)
	_cret := *(**C.gchar)(unsafe.Pointer(&_gret))

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// WindowListToplevels returns a list of all existing toplevel windows. The
// widgets in the list are not individually referenced. If you want to iterate
// through the list and perform actions involving callbacks that might destroy
// the widgets, you must call g_list_foreach (result, (GFunc)g_object_ref, NULL)
// first, and then unref all the widgets afterwards.
//
// The function returns the following values:
//
//    - list of toplevel widgets.
//
func WindowListToplevels() []Widgetter {
	_info := girepository.MustFind("Gtk", "list_toplevels")
	_gret := _info.InvokeFunction(nil, nil)
	_cret := *(**C.GList)(unsafe.Pointer(&_gret))

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret)))))
	gextras.MoveList(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret))), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&src)))
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// WindowSetAutoStartupNotification: by default, after showing the first Window,
// GTK+ calls gdk_notify_startup_complete(). Call this function to disable the
// automatic startup notification. You might do this if your first window is a
// splash screen, and you want to delay notification until after your real main
// window has been shown, for example.
//
// In that example, you would disable startup notification temporarily, show
// your splash screen, then re-enable it so that showing the main window would
// automatically result in notification.
//
// The function takes the following parameters:
//
//    - setting: TRUE to automatically do startup notification.
//
func WindowSetAutoStartupNotification(setting bool) {
	var _args [1]girepository.Argument

	if setting {
		*(*C.gboolean)(unsafe.Pointer(&_args[0])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "set_auto_startup_notification")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(setting)
}

// WindowSetDefaultIcon sets an icon to be used as fallback for windows that
// haven't had gtk_window_set_icon() called on them from a pixbuf.
//
// The function takes the following parameters:
//
//    - icon: icon.
//
func WindowSetDefaultIcon(icon *gdkpixbuf.Pixbuf) {
	var _args [1]girepository.Argument

	*(**C.GdkPixbuf)(unsafe.Pointer(&_args[0])) = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_info := girepository.MustFind("Gtk", "set_default_icon")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(icon)
}

// WindowSetDefaultIconFromFile sets an icon to be used as fallback for windows
// that haven't had gtk_window_set_icon_list() called on them from a file on
// disk. Warns on failure if err is NULL.
//
// The function takes the following parameters:
//
//    - filename: location of icon file.
//
func WindowSetDefaultIconFromFile(filename string) error {
	var _args [1]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gtk", "set_default_icon_from_file")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(filename)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// WindowSetDefaultIconList sets an icon list to be used as fallback for windows
// that haven't had gtk_window_set_icon_list() called on them to set up a
// window-specific icon list. This function allows you to set up the icon for
// all windows in your app at once.
//
// See gtk_window_set_icon_list() for more details.
//
// The function takes the following parameters:
//
//    - list of Pixbuf.
//
func WindowSetDefaultIconList(list []*gdkpixbuf.Pixbuf) {
	var _args [1]girepository.Argument

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GdkPixbuf // out
		*(**C.GdkPixbuf)(unsafe.Pointer(&dst)) = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		*(**C.GList)(unsafe.Pointer(&_args[0])) = C.g_list_prepend(*(**C.GList)(unsafe.Pointer(&_args[0])), C.gpointer(unsafe.Pointer(dst)))
	}

	_info := girepository.MustFind("Gtk", "set_default_icon_list")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(list)
}

// WindowSetDefaultIconName sets an icon to be used as fallback for windows that
// haven't had gtk_window_set_icon_list() called on them from a named themed
// icon, see gtk_window_set_icon_name().
//
// The function takes the following parameters:
//
//    - name of the themed icon.
//
func WindowSetDefaultIconName(name string) {
	var _args [1]girepository.Argument

	*(**C.gchar)(unsafe.Pointer(&_args[0])) = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[0]))))

	_info := girepository.MustFind("Gtk", "set_default_icon_name")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(name)
}

// WindowSetInteractiveDebugging opens or closes the [interactive
// debugger][interactive-debugging], which offers access to the widget hierarchy
// of the application and to useful debugging tools.
//
// The function takes the following parameters:
//
//    - enable: TRUE to enable interactive debugging.
//
func WindowSetInteractiveDebugging(enable bool) {
	var _args [1]girepository.Argument

	if enable {
		*(*C.gboolean)(unsafe.Pointer(&_args[0])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "set_interactive_debugging")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(enable)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_window_position_get_type()), F: marshalWindowPosition},
		{T: externglib.Type(C.gtk_window_type_get_type()), F: marshalWindowType},
		{T: externglib.Type(C.gtk_window_get_type()), F: marshalWindower},
	})
}

// WindowPosition: window placement can be influenced using this enumeration.
// Note that using K_WIN_POS_CENTER_ALWAYS is almost always a bad idea. It won’t
// necessarily work well with all window managers or on all windowing systems.
type WindowPosition int

const (
	// WinPosNone: no influence is made on placement.
	WinPosNone WindowPosition = iota
	// WinPosCenter windows should be placed in the center of the screen.
	WinPosCenter
	// WinPosMouse windows should be placed at the current mouse position.
	WinPosMouse
	// WinPosCenterAlways: keep window centered as it changes size, etc.
	WinPosCenterAlways
	// WinPosCenterOnParent: center the window on its transient parent (see
	// gtk_window_set_transient_for()).
	WinPosCenterOnParent
)

func marshalWindowPosition(p uintptr) (interface{}, error) {
	return WindowPosition(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowPosition.
func (w WindowPosition) String() string {
	switch w {
	case WinPosNone:
		return "None"
	case WinPosCenter:
		return "Center"
	case WinPosMouse:
		return "Mouse"
	case WinPosCenterAlways:
		return "CenterAlways"
	case WinPosCenterOnParent:
		return "CenterOnParent"
	default:
		return fmt.Sprintf("WindowPosition(%d)", w)
	}
}

// WindowType can be one of these types. Most things you’d consider a “window”
// should have type K_WINDOW_TOPLEVEL; windows with this type are managed by the
// window manager and have a frame by default (call gtk_window_set_decorated()
// to toggle the frame). Windows with type K_WINDOW_POPUP are ignored by the
// window manager; window manager keybindings won’t work on them, the window
// manager won’t decorate the window with a frame, many GTK+ features that rely
// on the window manager will not work (e.g. resize grips and
// maximization/minimization). K_WINDOW_POPUP is used to implement widgets such
// as Menu or tooltips that you normally don’t think of as windows per se.
// Nearly all windows should be K_WINDOW_TOPLEVEL. In particular, do not use
// K_WINDOW_POPUP just to turn off the window borders; use
// gtk_window_set_decorated() for that.
type WindowType int

const (
	// WindowToplevel: regular window, such as a dialog.
	WindowToplevel WindowType = iota
	// WindowPopup: special window such as a tooltip.
	WindowPopup
)

func marshalWindowType(p uintptr) (interface{}, error) {
	return WindowType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WindowType.
func (w WindowType) String() string {
	switch w {
	case WindowToplevel:
		return "Toplevel"
	case WindowPopup:
		return "Popup"
	default:
		return fmt.Sprintf("WindowType(%d)", w)
	}
}

// WindowOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type WindowOverrider interface {
	ActivateDefault()
	ActivateFocus()
	EnableDebugging(toggle bool) bool
	KeysChanged()
	// SetFocus: if focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the window. If focus is NULL, unsets the
	// focus widget for this window. To set the focus to a particular widget in
	// the toplevel, it is usually more convenient to use
	// gtk_widget_grab_focus() instead of this function.
	SetFocus(focus Widgetter)
}

// Window is a toplevel window which can contain other widgets. Windows normally
// have decorations that are under the control of the windowing system and allow
// the user to manipulate the window (resize it, move it, close it,...).
//
//
// GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the Buildable interface supports a custom
// <accel-groups> element, which supports any number of <group> elements
// representing the AccelGroup objects you want to add to your window
// (synonymous with gtk_window_add_accel_group().
//
// It also supports the <initial-focus> element, whose name property names the
// widget to receive the focus when the window is mapped.
//
// An example of a UI definition fragment with accel groups:
//
//    <object class="GtkWindow">
//      <accel-groups>
//        <group name="accelgroup1"/>
//      </accel-groups>
//      <initial-focus name="thunderclap"/>
//    </object>
//
//    ...
//
//    <object class="GtkAccelGroup" id="accelgroup1"/>
//
// The GtkWindow implementation of the Buildable interface supports setting a
// child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//    window.background
//    ├── decoration
//    ├── <titlebar child>.titlebar [.default-decoration]
//    ╰── <child>
//
// GtkWindow has a main CSS node with name window and style class .background,
// and a subnode with name decoration.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
type Window struct {
	Bin
}

func wrapWindow(obj *externglib.Object) *Window {
	return &Window{
		Bin: Bin{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: externglib.InitiallyUnowned{
						Object: obj,
					},
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					Object: obj,
				},
			},
		},
	}
}

func marshalWindower(p uintptr) (interface{}, error) {
	return wrapWindow(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWindow creates a new Window, which is a toplevel window that can contain
// other widgets. Nearly always, the type of the window should be
// K_WINDOW_TOPLEVEL. If you’re implementing something like a popup menu from
// scratch (which is a bad idea, just use Menu), you might use K_WINDOW_POPUP.
// K_WINDOW_POPUP is not for dialogs, though in some other toolkits dialogs are
// called “popups”. In GTK+, K_WINDOW_POPUP means a pop-up menu or pop-up
// tooltip. On X11, popup windows are not controlled by the [window
// manager][gtk-X11-arch].
//
// If you simply want an undecorated window (no window borders), use
// gtk_window_set_decorated(), don’t use K_WINDOW_POPUP.
//
// All top-level windows created by gtk_window_new() are stored in an internal
// top-level window list. This list can be obtained from
// gtk_window_list_toplevels(). Due to Gtk+ keeping a reference to the window
// internally, gtk_window_new() does not return a reference to the caller.
//
// To delete a Window, call gtk_widget_destroy().
//
// The function takes the following parameters:
//
//    - typ: type of window.
//
func NewWindow(typ WindowType) *Window {
	var _arg1 C.GtkWindowType // out
	var _cret *C.GtkWidget    // in

	_arg1 = C.GtkWindowType(typ)

	_cret = C.gtk_window_new(_arg1)
	runtime.KeepAlive(typ)

	var _window *Window // out

	_window = wrapWindow(externglib.Take(unsafe.Pointer(_cret)))

	return _window
}

// ActivateDefault activates the default widget for the window, unless the
// current focused widget has been configured to receive the default action (see
// gtk_widget_set_receives_default()), in which case the focused widget is
// activated.
func (window *Window) ActivateDefault() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_activate_default(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateFocus activates the current focused widget within the window.
func (window *Window) ActivateFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_activate_focus(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateKey activates mnemonics and accelerators for this Window. This is
// normally called by the default ::key_press_event handler for toplevel
// windows, however in some cases it may be useful to call this directly when
// overriding the standard key handling for a toplevel window.
//
// The function takes the following parameters:
//
//    - event: EventKey.
//
func (window *Window) ActivateKey(event *gdk.EventKey) bool {
	var _arg0 *C.GtkWindow   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkEventKey)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_window_activate_key(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddAccelGroup: associate accel_group with window, such that calling
// gtk_accel_groups_activate() on window will activate accelerators in
// accel_group.
//
// The function takes the following parameters:
//
//    - accelGroup: AccelGroup.
//
func (window *Window) AddAccelGroup(accelGroup *AccelGroup) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_window_add_accel_group(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(accelGroup)
}

// AddMnemonic adds a mnemonic to this window.
//
// The function takes the following parameters:
//
//    - keyval: mnemonic.
//    - target: widget that gets activated by the mnemonic.
//
func (window *Window) AddMnemonic(keyval uint, target Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint      // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.guint(keyval)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	C.gtk_window_add_mnemonic(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(target)
}

// BeginMoveDrag starts moving a window. This function is used if an application
// has window movement grips. When GDK can support it, the window movement will
// be done using the standard mechanism for the [window manager][gtk-X11-arch]
// or windowing system. Otherwise, GDK will try to emulate window movement,
// potentially not all that well, depending on the windowing system.
//
// The function takes the following parameters:
//
//    - button: mouse button that initiated the drag.
//    - rootX: x position where the user clicked to initiate the drag, in root
//    window coordinates.
//    - rootY: y position where the user clicked to initiate the drag.
//    - timestamp from the click event that initiated the drag.
//
func (window *Window) BeginMoveDrag(button, rootX, rootY int, timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(button)
	_arg2 = C.gint(rootX)
	_arg3 = C.gint(rootY)
	_arg4 = C.guint32(timestamp)

	C.gtk_window_begin_move_drag(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(window)
	runtime.KeepAlive(button)
	runtime.KeepAlive(rootX)
	runtime.KeepAlive(rootY)
	runtime.KeepAlive(timestamp)
}

// BeginResizeDrag starts resizing a window. This function is used if an
// application has window resizing controls. When GDK can support it, the resize
// will be done using the standard mechanism for the [window
// manager][gtk-X11-arch] or windowing system. Otherwise, GDK will try to
// emulate window resizing, potentially not all that well, depending on the
// windowing system.
//
// The function takes the following parameters:
//
//    - edge: position of the resize control.
//    - button: mouse button that initiated the drag.
//    - rootX: x position where the user clicked to initiate the drag, in root
//    window coordinates.
//    - rootY: y position where the user clicked to initiate the drag.
//    - timestamp from the click event that initiated the drag.
//
func (window *Window) BeginResizeDrag(edge gdk.WindowEdge, button, rootX, rootY int, timestamp uint32) {
	var _arg0 *C.GtkWindow    // out
	var _arg1 C.GdkWindowEdge // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out
	var _arg4 C.gint          // out
	var _arg5 C.guint32       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GdkWindowEdge(edge)
	_arg2 = C.gint(button)
	_arg3 = C.gint(rootX)
	_arg4 = C.gint(rootY)
	_arg5 = C.guint32(timestamp)

	C.gtk_window_begin_resize_drag(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(window)
	runtime.KeepAlive(edge)
	runtime.KeepAlive(button)
	runtime.KeepAlive(rootX)
	runtime.KeepAlive(rootY)
	runtime.KeepAlive(timestamp)
}

// Close requests that the window is closed, similar to what happens when a
// window manager close button is clicked.
//
// This function can be used with close buttons in custom titlebars.
func (window *Window) Close() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_close(_arg0)
	runtime.KeepAlive(window)
}

// Deiconify asks to deiconify (i.e. unminimize) the specified window. Note that
// you shouldn’t assume the window is definitely deiconified afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch])) could
// iconify it again before your code which assumes deiconification gets to run.
//
// You can track iconification via the “window-state-event” signal on Widget.
func (window *Window) Deiconify() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_deiconify(_arg0)
	runtime.KeepAlive(window)
}

// Fullscreen asks to place window in the fullscreen state. Note that you
// shouldn’t assume the window is definitely full screen afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unfullscreen it again, and not all window managers honor requests to
// fullscreen windows. But normally the window will end up fullscreen. Just
// don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (window *Window) Fullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_fullscreen(_arg0)
	runtime.KeepAlive(window)
}

// FullscreenOnMonitor asks to place window in the fullscreen state. Note that
// you shouldn't assume the window is definitely full screen afterward.
//
// You can track the fullscreen state via the "window-state-event" signal on
// Widget.
//
// The function takes the following parameters:
//
//    - screen to draw to.
//    - monitor: which monitor to go fullscreen on.
//
func (window *Window) FullscreenOnMonitor(screen *gdk.Screen, monitor int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkScreen // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))
	_arg2 = C.gint(monitor)

	C.gtk_window_fullscreen_on_monitor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(screen)
	runtime.KeepAlive(monitor)
}

// AcceptFocus gets the value set by gtk_window_set_accept_focus().
func (window *Window) AcceptFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_accept_focus(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Application gets the Application associated with the window (if any).
func (window *Window) Application() *Application {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkApplication // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_application(_arg0)
	runtime.KeepAlive(window)

	var _application *Application // out

	if _cret != nil {
		_application = wrapApplication(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _application
}

// AttachedTo fetches the attach widget for this window. See
// gtk_window_set_attached_to().
func (window *Window) AttachedTo() Widgetter {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_attached_to(_arg0)
	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(Widgetter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Decorated returns whether the window has been set to have decorations such as
// a title bar via gtk_window_set_decorated().
func (window *Window) Decorated() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_decorated(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultSize gets the default size of the window. A value of -1 for the width
// or height indicates that a default size has not been explicitly set for that
// dimension, so the “natural” size of the window will be used.
func (window *Window) DefaultSize() (width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_get_default_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(window)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// DefaultWidget returns the default widget for window. See
// gtk_window_set_default() for more details.
func (window *Window) DefaultWidget() Widgetter {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_default_widget(_arg0)
	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(Widgetter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Deletable returns whether the window has been set to have a close button via
// gtk_window_set_deletable().
func (window *Window) Deletable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_deletable(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DestroyWithParent returns whether the window will be destroyed with its
// transient parent. See gtk_window_set_destroy_with_parent ().
func (window *Window) DestroyWithParent() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_destroy_with_parent(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Focus retrieves the current focused widget within the window. Note that this
// is the widget that would have the focus if the toplevel window focused; if
// the toplevel window is not focused then gtk_widget_has_focus (widget) will
// not be TRUE for the widget.
func (window *Window) Focus() Widgetter {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_focus(_arg0)
	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(Widgetter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// FocusOnMap gets the value set by gtk_window_set_focus_on_map().
func (window *Window) FocusOnMap() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_focus_on_map(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FocusVisible gets the value of the Window:focus-visible property.
func (window *Window) FocusVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_focus_visible(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Gravity gets the value set by gtk_window_set_gravity().
func (window *Window) Gravity() gdk.Gravity {
	var _arg0 *C.GtkWindow // out
	var _cret C.GdkGravity // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_gravity(_arg0)
	runtime.KeepAlive(window)

	var _gravity gdk.Gravity // out

	_gravity = gdk.Gravity(_cret)

	return _gravity
}

// Group returns the group for window or the default group, if window is NULL or
// if window does not have an explicit window group.
func (window *Window) Group() *WindowGroup {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkWindowGroup // in

	if window != nil {
		_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	}

	_cret = C.gtk_window_get_group(_arg0)
	runtime.KeepAlive(window)

	var _windowGroup *WindowGroup // out

	_windowGroup = wrapWindowGroup(externglib.Take(unsafe.Pointer(_cret)))

	return _windowGroup
}

// HasResizeGrip determines whether the window may have a resize grip.
//
// Deprecated: Resize grips have been removed.
func (window *Window) HasResizeGrip() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_has_resize_grip(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HideTitlebarWhenMaximized returns whether the window has requested to have
// its titlebar hidden when maximized. See
// gtk_window_set_hide_titlebar_when_maximized ().
func (window *Window) HideTitlebarWhenMaximized() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_hide_titlebar_when_maximized(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Icon gets the value set by gtk_window_set_icon() (or if you've called
// gtk_window_set_icon_list(), gets the first icon in the icon list).
func (window *Window) Icon() *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_icon(_arg0)
	runtime.KeepAlive(window)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := externglib.Take(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// IconList retrieves the list of icons set by gtk_window_set_icon_list(). The
// list is copied, but the reference count on each member won’t be incremented.
func (window *Window) IconList() []gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GList     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_icon_list(_arg0)
	runtime.KeepAlive(window)

	var _list []gdkpixbuf.Pixbuf // out

	_list = make([]gdkpixbuf.Pixbuf, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GdkPixbuf)(v)
		var dst gdkpixbuf.Pixbuf // out
		{
			obj := externglib.Take(unsafe.Pointer(src))
			dst = gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
		_list = append(_list, dst)
	})

	return _list
}

// IconName returns the name of the themed icon for the window, see
// gtk_window_set_icon_name().
func (window *Window) IconName() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_icon_name(_arg0)
	runtime.KeepAlive(window)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MnemonicModifier returns the mnemonic modifier for this window. See
// gtk_window_set_mnemonic_modifier().
func (window *Window) MnemonicModifier() gdk.ModifierType {
	var _arg0 *C.GtkWindow      // out
	var _cret C.GdkModifierType // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_mnemonic_modifier(_arg0)
	runtime.KeepAlive(window)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// MnemonicsVisible gets the value of the Window:mnemonics-visible property.
func (window *Window) MnemonicsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_mnemonics_visible(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modal returns whether the window is modal. See gtk_window_set_modal().
func (window *Window) Modal() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_modal(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Opacity fetches the requested opacity for this window. See
// gtk_window_set_opacity().
//
// Deprecated: Use gtk_widget_get_opacity instead.
func (window *Window) Opacity() float64 {
	var _arg0 *C.GtkWindow // out
	var _cret C.gdouble    // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_opacity(_arg0)
	runtime.KeepAlive(window)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Position: this function returns the position you need to pass to
// gtk_window_move() to keep window in its current position. This means that the
// meaning of the returned value varies with window gravity. See
// gtk_window_move() for more details.
//
// The reliability of this function depends on the windowing system currently in
// use. Some windowing systems, such as Wayland, do not support a global
// coordinate system, and thus the position of the window will always be (0, 0).
// Others, like X11, do not have a reliable way to obtain the geometry of the
// decorations of a window if they are provided by the window manager.
// Additionally, on X11, window manager have been known to mismanage window
// gravity, which result in windows moving even if you use the coordinates of
// the current position as returned by this function.
//
// If you haven’t changed the window gravity, its gravity will be
// K_GRAVITY_NORTH_WEST. This means that gtk_window_get_position() gets the
// position of the top-left corner of the window manager frame for the window.
// gtk_window_move() sets the position of this same top-left corner.
//
// If a window has gravity K_GRAVITY_STATIC the window manager frame is not
// relevant, and thus gtk_window_get_position() will always produce accurate
// results. However you can’t use static gravity to do things like place a
// window in a corner of the screen, because static gravity ignores the window
// manager decorations.
//
// Ideally, this function should return appropriate values if the window has
// client side decorations, assuming that the windowing system supports global
// coordinates.
//
// In practice, saving the window position should not be left to applications,
// as they lack enough knowledge of the windowing system and the window manager
// state to effectively do so. The appropriate way to implement saving the
// window position is to use a platform-specific protocol, wherever that is
// available.
func (window *Window) Position() (rootX int, rootY int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_get_position(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(window)

	var _rootX int // out
	var _rootY int // out

	_rootX = int(_arg1)
	_rootY = int(_arg2)

	return _rootX, _rootY
}

// Resizable gets the value set by gtk_window_set_resizable().
func (window *Window) Resizable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_resizable(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResizeGripArea: if a window has a resize grip, this will retrieve the grip
// position, width and height into the specified Rectangle.
//
// Deprecated: Resize grips have been removed.
func (window *Window) ResizeGripArea() (gdk.Rectangle, bool) {
	var _arg0 *C.GtkWindow   // out
	var _arg1 C.GdkRectangle // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_resize_grip_area(_arg0, &_arg1)
	runtime.KeepAlive(window)

	var _rect gdk.Rectangle // out
	var _ok bool            // out

	_rect = *(*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// Role returns the role of the window. See gtk_window_set_role() for further
// explanation.
func (window *Window) Role() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_role(_arg0)
	runtime.KeepAlive(window)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Screen returns the Screen associated with window.
func (window *Window) Screen() *gdk.Screen {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GdkScreen // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_screen(_arg0)
	runtime.KeepAlive(window)

	var _screen *gdk.Screen // out

	{
		obj := externglib.Take(unsafe.Pointer(_cret))
		_screen = &gdk.Screen{
			Object: obj,
		}
	}

	return _screen
}

// Size obtains the current size of window.
//
// If window is not visible on screen, this function return the size GTK+ will
// suggest to the [window manager][gtk-X11-arch] for the initial window size
// (but this is not reliably the same as the size the window manager will
// actually select). See: gtk_window_set_default_size().
//
// Depending on the windowing system and the window manager constraints, the
// size returned by this function may not match the size set using
// gtk_window_resize(); additionally, since gtk_window_resize() may be
// implemented as an asynchronous operation, GTK+ cannot guarantee in any way
// that this code:
//
//    static void
//    on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
//    {
//      int new_width, new_height;
//
//      gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
//
//      ...
//    }
//
// Note that, if you connect to the Widget::size-allocate signal, you should not
// use the dimensions of the Allocation passed to the signal handler, as the
// allocation may contain client side decorations added by GTK+, depending on
// the windowing system in use.
//
// If you are getting a window size in order to position the window on the
// screen, you should, instead, simply set the window’s semantic type with
// gtk_window_set_type_hint(), which allows the window manager to e.g. center
// dialogs. Also, if you set the transient parent of dialogs with
// gtk_window_set_transient_for() window managers will often center the dialog
// over its parent window. It's much preferred to let the window manager handle
// these cases rather than doing it yourself, because all apps will behave
// consistently and according to user or system preferences, if the window
// manager handles it. Also, the window manager can take into account the size
// of the window decorations and border that it may add, and of which GTK+ has
// no knowledge. Additionally, positioning windows in global screen coordinates
// may not be allowed by the windowing system. For more information, see:
// gtk_window_set_position().
func (window *Window) Size() (width int, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // in
	var _arg2 C.gint       // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_get_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(window)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// SkipPagerHint gets the value set by gtk_window_set_skip_pager_hint().
func (window *Window) SkipPagerHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_skip_pager_hint(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SkipTaskbarHint gets the value set by gtk_window_set_skip_taskbar_hint().
func (window *Window) SkipTaskbarHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_skip_taskbar_hint(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the window. See gtk_window_set_title().
func (window *Window) Title() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_title(_arg0)
	runtime.KeepAlive(window)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
func (window *Window) Titlebar() Widgetter {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_titlebar(_arg0)
	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(Widgetter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// TransientFor fetches the transient parent for this window. See
// gtk_window_set_transient_for().
func (window *Window) TransientFor() *Window {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_transient_for(_arg0)
	runtime.KeepAlive(window)

	var _ret *Window // out

	if _cret != nil {
		_ret = wrapWindow(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _ret
}

// TypeHint gets the type hint for this window. See gtk_window_set_type_hint().
func (window *Window) TypeHint() gdk.WindowTypeHint {
	var _arg0 *C.GtkWindow        // out
	var _cret C.GdkWindowTypeHint // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_type_hint(_arg0)
	runtime.KeepAlive(window)

	var _windowTypeHint gdk.WindowTypeHint // out

	_windowTypeHint = gdk.WindowTypeHint(_cret)

	return _windowTypeHint
}

// UrgencyHint gets the value set by gtk_window_set_urgency_hint().
func (window *Window) UrgencyHint() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_urgency_hint(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WindowType gets the type of the window. See WindowType.
func (window *Window) WindowType() WindowType {
	var _arg0 *C.GtkWindow    // out
	var _cret C.GtkWindowType // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_get_window_type(_arg0)
	runtime.KeepAlive(window)

	var _windowType WindowType // out

	_windowType = WindowType(_cret)

	return _windowType
}

// HasGroup returns whether window has an explicit window group.
func (window *Window) HasGroup() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_has_group(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasToplevelFocus returns whether the input focus is within this GtkWindow.
// For real toplevel windows, this is identical to gtk_window_is_active(), but
// for embedded windows, like Plug, the results will differ.
func (window *Window) HasToplevelFocus() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_has_toplevel_focus(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iconify asks to iconify (i.e. minimize) the specified window. Note that you
// shouldn’t assume the window is definitely iconified afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could deiconify it
// again, or there may not be a window manager in which case iconification isn’t
// possible, etc. But normally the window will end up iconified. Just don’t
// write code that crashes if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be iconified before it ever appears onscreen.
//
// You can track iconification via the “window-state-event” signal on Widget.
func (window *Window) Iconify() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_iconify(_arg0)
	runtime.KeepAlive(window)
}

// IsActive returns whether the window is part of the current active toplevel.
// (That is, the toplevel window receiving keystrokes.) The return value is TRUE
// if the window is active toplevel itself, but also if it is, say, a Plug
// embedded in the active toplevel. You might use this function if you wanted to
// draw a widget differently in an active window from a widget in an inactive
// window. See gtk_window_has_toplevel_focus().
func (window *Window) IsActive() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_is_active(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMaximized retrieves the current maximized state of window.
//
// Note that since maximization is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk_window_maximize() or gtk_window_unmaximize().
func (window *Window) IsMaximized() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_is_maximized(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Maximize asks to maximize window, so that it becomes full-screen. Note that
// you shouldn’t assume the window is definitely maximized afterward, because
// other entities (e.g. the user or [window manager][gtk-X11-arch]) could
// unmaximize it again, and not all window managers support maximization. But
// normally the window will end up maximized. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be maximized when it appears onscreen initially.
//
// You can track maximization via the “window-state-event” signal on Widget, or
// by listening to notifications on the Window:is-maximized property.
func (window *Window) Maximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_maximize(_arg0)
	runtime.KeepAlive(window)
}

// MnemonicActivate activates the targets associated with the mnemonic.
//
// The function takes the following parameters:
//
//    - keyval: mnemonic.
//    - modifier: modifiers.
//
func (window *Window) MnemonicActivate(keyval uint, modifier gdk.ModifierType) bool {
	var _arg0 *C.GtkWindow      // out
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.guint(keyval)
	_arg2 = C.GdkModifierType(modifier)

	_cret = C.gtk_window_mnemonic_activate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(modifier)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Move asks the [window manager][gtk-X11-arch] to move window to the given
// position. Window managers are free to ignore this; most window managers
// ignore requests for initial window positions (instead using a user-defined
// placement algorithm) and honor requests after the window has already been
// shown.
//
// Note: the position is the position of the gravity-determined reference point
// for the window. The gravity determines two things: first, the location of the
// reference point in root window coordinates; and second, which point on the
// window is positioned at the reference point.
//
// By default the gravity is K_GRAVITY_NORTH_WEST, so the reference point is
// simply the x, y supplied to gtk_window_move(). The top-left corner of the
// window decorations (aka window frame or border) will be placed at x, y.
// Therefore, to position a window at the top left of the screen, you want to
// use the default gravity (which is K_GRAVITY_NORTH_WEST) and move the window
// to 0,0.
//
// To position a window at the bottom right corner of the screen, you would set
// K_GRAVITY_SOUTH_EAST, which means that the reference point is at x + the
// window width and y + the window height, and the bottom-right corner of the
// window border will be placed at that reference point. So, to place a window
// in the bottom right corner you would first set gravity to south east, then
// write: gtk_window_move (window, gdk_screen_width () - window_width,
// gdk_screen_height () - window_height) (note that this example does not take
// multi-head scenarios into account).
//
// The Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec) has a nice table of gravities
// in the “implementation notes” section.
//
// The gtk_window_get_position() documentation may also be relevant.
//
// The function takes the following parameters:
//
//    - x: x coordinate to move window to.
//    - y: y coordinate to move window to.
//
func (window *Window) Move(x, y int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)

	C.gtk_window_move(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// ParseGeometry parses a standard X Window System geometry string - see the
// manual page for X (type “man X”) for details on this.
// gtk_window_parse_geometry() does work on all GTK+ ports including Win32 but
// is primarily intended for an X environment.
//
// If either a size or a position can be extracted from the geometry string,
// gtk_window_parse_geometry() returns TRUE and calls
// gtk_window_set_default_size() and/or gtk_window_move() to resize/move the
// window.
//
// If gtk_window_parse_geometry() returns TRUE, it will also set the
// K_HINT_USER_POS and/or K_HINT_USER_SIZE hints indicating to the window
// manager that the size/position of the window was user-specified. This causes
// most window managers to honor the geometry.
//
// Note that for gtk_window_parse_geometry() to work as expected, it has to be
// called when the window has its “final” size, i.e. after calling
// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints() on
// the window.
//
//    #include <gtk/gtk.h>
//
//    static void
//    fill_with_content (GtkWidget *vbox)
//    {
//      // fill with content...
//    }
//
//    int
//    main (int argc, char *argv[])
//    {
//      GtkWidget *window, *vbox;
//      GdkGeometry size_hints = {
//        100, 50, 0, 0, 100, 50, 10,
//        10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
//      };
//
//      gtk_init (&argc, &argv);
//
//      window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
//      vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
//
//      gtk_container_add (GTK_CONTAINER (window), vbox);
//      fill_with_content (vbox);
//      gtk_widget_show_all (vbox);
//
//      gtk_window_set_geometry_hints (GTK_WINDOW (window),
//    	  			    NULL,
//    				    &size_hints,
//    				    GDK_HINT_MIN_SIZE |
//    				    GDK_HINT_BASE_SIZE |
//    				    GDK_HINT_RESIZE_INC);
//
//      if (argc > 1)
//        {
//          gboolean res;
//          res = gtk_window_parse_geometry (GTK_WINDOW (window),
//                                           argv[1]);
//          if (! res)
//            fprintf (stderr,
//                     "Failed to parse “s”\n",
//                     argv[1]);
//        }
//
//      gtk_widget_show_all (window);
//      gtk_main ();
//
//      return 0;
//    }
//
// Deprecated: Geometry handling in GTK is deprecated.
//
// The function takes the following parameters:
//
//    - geometry string.
//
func (window *Window) ParseGeometry(geometry string) bool {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(geometry)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_window_parse_geometry(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(geometry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Present presents a window to the user. This function should not be used as
// when it is called, it is too late to gather a valid timestamp to allow focus
// stealing prevention to work correctly.
func (window *Window) Present() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_present(_arg0)
	runtime.KeepAlive(window)
}

// PresentWithTime presents a window to the user. This may mean raising the
// window in the stacking order, deiconifying it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent on the
// user’s platform, window manager, and preferences.
//
// If window is hidden, this function calls gtk_widget_show() as well.
//
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open, and
// the user chooses Preferences from the menu a second time; use
// gtk_window_present() to move the already-open dialog where the user can see
// it.
//
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown (when
// clicking a link for example), rather than once the window is ready to be
// shown.
//
// The function takes the following parameters:
//
//    - timestamp of the user interaction (typically a button or key press
//    event) which triggered this call.
//
func (window *Window) PresentWithTime(timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.guint32(timestamp)

	C.gtk_window_present_with_time(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(timestamp)
}

// PropagateKeyEvent: propagate a key press or release event to the focus widget
// and up the focus container chain until a widget handles event. This is
// normally called by the default ::key_press_event and ::key_release_event
// handlers for toplevel windows, however in some cases it may be useful to call
// this directly when overriding the standard key handling for a toplevel
// window.
//
// The function takes the following parameters:
//
//    - event: EventKey.
//
func (window *Window) PropagateKeyEvent(event *gdk.EventKey) bool {
	var _arg0 *C.GtkWindow   // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkEventKey)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_window_propagate_key_event(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAccelGroup reverses the effects of gtk_window_add_accel_group().
//
// The function takes the following parameters:
//
//    - accelGroup: AccelGroup.
//
func (window *Window) RemoveAccelGroup(accelGroup *AccelGroup) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkAccelGroup // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GtkAccelGroup)(unsafe.Pointer(accelGroup.Native()))

	C.gtk_window_remove_accel_group(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(accelGroup)
}

// RemoveMnemonic removes a mnemonic from this window.
//
// The function takes the following parameters:
//
//    - keyval: mnemonic.
//    - target: widget that gets activated by the mnemonic.
//
func (window *Window) RemoveMnemonic(keyval uint, target Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint      // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.guint(keyval)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

	C.gtk_window_remove_mnemonic(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(target)
}

// ReshowWithInitialSize hides window, then reshows it, resetting the default
// size and position of the window. Used by GUI builders only.
//
// Deprecated: GUI builders can call gtk_widget_hide(), gtk_widget_unrealize()
// and then gtk_widget_show() on window themselves, if they still need this
// functionality.
func (window *Window) ReshowWithInitialSize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_reshow_with_initial_size(_arg0)
	runtime.KeepAlive(window)
}

// Resize resizes the window as if the user had done so, obeying geometry
// constraints. The default geometry constraint is that windows may not be
// smaller than their size request; to override this constraint, call
// gtk_widget_set_size_request() to set the window's request to a smaller value.
//
// If gtk_window_resize() is called before showing a window for the first time,
// it overrides any default size set with gtk_window_set_default_size().
//
// Windows may not be resized smaller than 1 by 1 pixels.
//
// When using client side decorations, GTK+ will do its best to adjust the given
// size so that the resulting window size matches the requested size without the
// title bar, borders and shadows added for the client side decorations, but
// there is no guarantee that the result will be totally accurate because these
// widgets added for client side decorations depend on the theme and may not be
// realized or visible at the time gtk_window_resize() is issued.
//
// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()), then
// typically, gtk_window_resize() will compensate for the height of the titlebar
// widget only if the height is known when the resulting GtkWindow configuration
// is issued. For example, if new widgets are added after the GtkWindow
// configuration and cause the titlebar widget to grow in height, this will
// result in a window content smaller that specified by gtk_window_resize() and
// not a larger window.
//
// The function takes the following parameters:
//
//    - width in pixels to resize the window to.
//    - height in pixels to resize the window to.
//
func (window *Window) Resize(width, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_window_resize(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// ResizeGripIsVisible determines whether a resize grip is visible for the
// specified window.
//
// Deprecated: Resize grips have been removed.
func (window *Window) ResizeGripIsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	_cret = C.gtk_window_resize_grip_is_visible(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResizeToGeometry: like gtk_window_resize(), but width and height are
// interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
//
// Deprecated: This function does nothing. Use gtk_window_resize() and compute
// the geometry yourself.
//
// The function takes the following parameters:
//
//    - width in resize increments to resize the window to.
//    - height in resize increments to resize the window to.
//
func (window *Window) ResizeToGeometry(width, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_window_resize_to_geometry(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetAcceptFocus windows may set a hint asking the desktop environment not to
// receive the input focus. This function sets this hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to let this window receive input focus.
//
func (window *Window) SetAcceptFocus(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_accept_focus(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetApplication sets or unsets the Application associated with the window.
//
// The application will be kept alive for at least as long as it has any windows
// associated with it (see g_application_hold() for a way to keep it alive
// without windows).
//
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it by setting
// the application to NULL.
//
// This is equivalent to calling gtk_application_remove_window() and/or
// gtk_application_add_window() on the old/new applications as relevant.
//
// The function takes the following parameters:
//
//    - application or NULL to unset.
//
func (window *Window) SetApplication(application *Application) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 *C.GtkApplication // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if application != nil {
		_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))
	}

	C.gtk_window_set_application(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(application)
}

// SetAttachedTo marks window as attached to attach_widget. This creates a
// logical binding between the window and the widget it belongs to, which is
// used by GTK+ to propagate information such as styling or accessibility to
// window as if it was a children of attach_widget.
//
// Examples of places where specifying this relation is useful are for instance
// a Menu created by a ComboBox, a completion popup window created by Entry or a
// typeahead search entry created by TreeView.
//
// Note that this function should not be confused with
// gtk_window_set_transient_for(), which specifies a window manager relation
// between two toplevels instead.
//
// Passing NULL for attach_widget detaches the window.
//
// The function takes the following parameters:
//
//    - attachWidget or NULL.
//
func (window *Window) SetAttachedTo(attachWidget Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if attachWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(attachWidget.Native()))
	}

	C.gtk_window_set_attached_to(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(attachWidget)
}

// SetDecorated: by default, windows are decorated with a title bar, resize
// controls, etc. Some [window managers][gtk-X11-arch] allow GTK+ to disable
// these decorations, creating a borderless window. If you set the decorated
// property to FALSE using this function, GTK+ will do its best to convince the
// window manager not to decorate the window. Depending on the system, this
// function may not have any effect when called on a window that is already
// visible, so you should call it before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
//
// The function takes the following parameters:
//
//    - setting: TRUE to decorate the window.
//
func (window *Window) SetDecorated(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_decorated(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDefault: default widget is the widget that’s activated when the user
// presses Enter in a dialog (for example). This function sets or unsets the
// default widget for a Window. When setting (rather than unsetting) the default
// widget it’s generally easier to call gtk_widget_grab_default() on the widget.
// Before making a widget the default widget, you must call
// gtk_widget_set_can_default() on the widget you’d like to make the default.
//
// The function takes the following parameters:
//
//    - defaultWidget: widget to be the default, or NULL to unset the default
//    widget for the toplevel.
//
func (window *Window) SetDefault(defaultWidget Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if defaultWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(defaultWidget.Native()))
	}

	C.gtk_window_set_default(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(defaultWidget)
}

// SetDefaultGeometry: like gtk_window_set_default_size(), but width and height
// are interpreted in terms of the base size and increment set with
// gtk_window_set_geometry_hints.
//
// Deprecated: This function does nothing. If you want to set a default size,
// use gtk_window_set_default_size() instead.
//
// The function takes the following parameters:
//
//    - width in resize increments, or -1 to unset the default width.
//    - height in resize increments, or -1 to unset the default height.
//
func (window *Window) SetDefaultGeometry(width, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_window_set_default_geometry(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetDefaultSize sets the default size of a window. If the window’s “natural”
// size (its size request) is larger than the default, the default will be
// ignored. More generally, if the default size does not obey the geometry hints
// for the window (gtk_window_set_geometry_hints() can be used to set these
// explicitly), the default size will be clamped to the nearest permitted size.
//
// Unlike gtk_widget_set_size_request(), which sets a size request for a widget
// and thus would keep users from shrinking the window, this function only sets
// the initial size, just as if the user had resized the window themselves.
// Users can still shrink the window again as they normally would. Setting a
// default size of -1 means to use the “natural” default size (the size request
// of the window).
//
// For more control over a window’s initial size and how resizing works,
// investigate gtk_window_set_geometry_hints().
//
// For some uses, gtk_window_resize() is a more appropriate function.
// gtk_window_resize() changes the current size of the window, rather than the
// size to be used on initial display. gtk_window_resize() always affects the
// window itself, not the geometry widget.
//
// The default size of a window only affects the first time a window is shown;
// if a window is hidden and re-shown, it will remember the size it had prior to
// hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but passing
// 0 for width and height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size, note
// that the appropriate size to save is the one returned by
// gtk_window_get_size(). Using the window allocation directly will not work in
// all circumstances and can lead to growing or shrinking windows.
//
// The function takes the following parameters:
//
//    - width in pixels, or -1 to unset the default width.
//    - height in pixels, or -1 to unset the default height.
//
func (window *Window) SetDefaultSize(width, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gint       // out
	var _arg2 C.gint       // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_window_set_default_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetDeletable: by default, windows have a close button in the window frame.
// Some [window managers][gtk-X11-arch] allow GTK+ to disable this button. If
// you set the deletable property to FALSE using this function, GTK+ will do its
// best to convince the window manager not to show a close button. Depending on
// the system, this function may not have any effect when called on a window
// that is already visible, so you should call it before calling
// gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
//
// The function takes the following parameters:
//
//    - setting: TRUE to decorate the window as deletable.
//
func (window *Window) SetDeletable(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_deletable(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDestroyWithParent: if setting is TRUE, then destroying the transient
// parent of window will also destroy window itself. This is useful for dialogs
// that shouldn’t persist beyond the lifetime of the main window they're
// associated with, for example.
//
// The function takes the following parameters:
//
//    - setting: whether to destroy window with its transient parent.
//
func (window *Window) SetDestroyWithParent(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_destroy_with_parent(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetFocus: if focus is not the current focus widget, and is focusable, sets it
// as the focus widget for the window. If focus is NULL, unsets the focus widget
// for this window. To set the focus to a particular widget in the toplevel, it
// is usually more convenient to use gtk_widget_grab_focus() instead of this
// function.
//
// The function takes the following parameters:
//
//    - focus: widget to be the new focus widget, or NULL to unset any focus
//    widget for the toplevel window.
//
func (window *Window) SetFocus(focus Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if focus != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))
	}

	C.gtk_window_set_focus(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(focus)
}

// SetFocusOnMap windows may set a hint asking the desktop environment not to
// receive the input focus when the window is mapped. This function sets this
// hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to let this window receive input focus on map.
//
func (window *Window) SetFocusOnMap(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_on_map(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetFocusVisible sets the Window:focus-visible property.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (window *Window) SetFocusVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_visible(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetGeometryHints: this function sets up hints about how a window can be
// resized by the user. You can set a minimum and maximum size; allowed resize
// increments (e.g. for xterm, you can only resize by the size of a character);
// aspect ratios; and more. See the Geometry struct.
//
// The function takes the following parameters:
//
//    - geometryWidget: widget the geometry hints used to be applied to or
//    NULL. Since 3.20 this argument is ignored and GTK behaves as if NULL was
//    set.
//    - geometry: struct containing geometry information or NULL.
//    - geomMask: mask indicating which struct fields should be paid attention
//    to.
//
func (window *Window) SetGeometryHints(geometryWidget Widgetter, geometry *gdk.Geometry, geomMask gdk.WindowHints) {
	var _arg0 *C.GtkWindow     // out
	var _arg1 *C.GtkWidget     // out
	var _arg2 *C.GdkGeometry   // out
	var _arg3 C.GdkWindowHints // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if geometryWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(geometryWidget.Native()))
	}
	if geometry != nil {
		_arg2 = (*C.GdkGeometry)(gextras.StructNative(unsafe.Pointer(geometry)))
	}
	_arg3 = C.GdkWindowHints(geomMask)

	C.gtk_window_set_geometry_hints(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(window)
	runtime.KeepAlive(geometryWidget)
	runtime.KeepAlive(geometry)
	runtime.KeepAlive(geomMask)
}

// SetGravity: window gravity defines the meaning of coordinates passed to
// gtk_window_move(). See gtk_window_move() and Gravity for more details.
//
// The default window gravity is K_GRAVITY_NORTH_WEST which will typically “do
// what you mean.”.
//
// The function takes the following parameters:
//
//    - gravity: window gravity.
//
func (window *Window) SetGravity(gravity gdk.Gravity) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.GdkGravity // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GdkGravity(gravity)

	C.gtk_window_set_gravity(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(gravity)
}

// SetHasResizeGrip sets whether window has a corner resize grip.
//
// Note that the resize grip is only shown if the window is actually resizable
// and not maximized. Use gtk_window_resize_grip_is_visible() to find out if the
// resize grip is currently shown.
//
// Deprecated: Resize grips have been removed.
//
// The function takes the following parameters:
//
//    - value: TRUE to allow a resize grip.
//
func (window *Window) SetHasResizeGrip(value bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_has_resize_grip(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(value)
}

// SetHasUserRefCount tells GTK+ whether to drop its extra reference to the
// window when gtk_widget_destroy() is called.
//
// This function is only exported for the benefit of language bindings which may
// need to keep the window alive until their wrapper object is garbage
// collected. There is no justification for ever calling this function in an
// application.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (window *Window) SetHasUserRefCount(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_has_user_ref_count(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetHideTitlebarWhenMaximized: if setting is TRUE, then window will request
// that it’s titlebar should be hidden when maximized. This is useful for
// windows that don’t convey any information other than the application name in
// the titlebar, to put the available screen space to better use. If the
// underlying window system does not support the request, the setting will not
// have any effect.
//
// Note that custom titlebars set with gtk_window_set_titlebar() are not
// affected by this. The application is in full control of their content and
// visibility anyway.
//
// The function takes the following parameters:
//
//    - setting: whether to hide the titlebar when window is maximized.
//
func (window *Window) SetHideTitlebarWhenMaximized(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_hide_titlebar_when_maximized(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetIcon sets up the icon representing a Window. This icon is used when the
// window is minimized (also known as iconified). Some window managers or
// desktop environments may also place it in the window frame, or display it in
// other contexts. On others, the icon is not used at all, so your mileage may
// vary.
//
// The icon should be provided in whatever size it was naturally drawn; that is,
// don’t scale the image before passing it to GTK+. Scaling is postponed until
// the last minute, when the desired final size is known, to allow best quality.
//
// If you have your icon hand-drawn in multiple sizes, use
// gtk_window_set_icon_list(). Then the best size will be used.
//
// This function is equivalent to calling gtk_window_set_icon_list() with a
// 1-element list.
//
// See also gtk_window_set_default_icon_list() to set the icon for all windows
// in your application in one go.
//
// The function takes the following parameters:
//
//    - icon image, or NULL.
//
func (window *Window) SetIcon(icon *gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if icon != nil {
		_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(icon.Native()))
	}

	C.gtk_window_set_icon(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(icon)
}

// SetIconFromFile sets the icon for window. Warns on failure if err is NULL.
//
// This function is equivalent to calling gtk_window_set_icon() with a pixbuf
// created by loading the image from filename.
//
// The function takes the following parameters:
//
//    - filename: location of icon file.
//
func (window *Window) SetIconFromFile(filename string) error {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _cerr *C.GError    // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_icon_from_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(window)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetIconList sets up the icon representing a Window. The icon is used when the
// window is minimized (also known as iconified). Some window managers or
// desktop environments may also place it in the window frame, or display it in
// other contexts. On others, the icon is not used at all, so your mileage may
// vary.
//
// gtk_window_set_icon_list() allows you to pass in the same icon in several
// hand-drawn sizes. The list should contain the natural sizes your icon is
// available in; that is, don’t scale the image before passing it to GTK+.
// Scaling is postponed until the last minute, when the desired final size is
// known, to allow best quality.
//
// By passing several sizes, you may improve the final image quality of the
// icon, by reducing or eliminating automatic image scaling.
//
// Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and larger
// images (64x64, 128x128) if you have them.
//
// See also gtk_window_set_default_icon_list() to set the icon for all windows
// in your application in one go.
//
// Note that transient windows (those who have been set transient for another
// window using gtk_window_set_transient_for()) will inherit their icon from
// their transient parent. So there’s no need to explicitly set the icon on
// transient windows.
//
// The function takes the following parameters:
//
//    - list of Pixbuf.
//
func (window *Window) SetIconList(list []gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GList     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GdkPixbuf // out
		dst = (*C.GdkPixbuf)(unsafe.Pointer((&src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_arg1)

	C.gtk_window_set_icon_list(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(list)
}

// SetIconName sets the icon for the window from a named themed icon. See the
// docs for IconTheme for more details. On some platforms, the window icon is
// not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
//
// The function takes the following parameters:
//
//    - name of the themed icon.
//
func (window *Window) SetIconName(name string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if name != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_window_set_icon_name(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(name)
}

// SetKeepAbove asks to keep window above, so that it stays on top. Note that
// you shouldn’t assume the window is definitely above afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// above, and not all window managers support keeping windows above. But
// normally the window will end kept above. Just don’t write code that crashes
// if not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept above when it appears onscreen initially.
//
// You can track the above state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window above other windows.
//
func (window *Window) SetKeepAbove(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_keep_above(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetKeepBelow asks to keep window below, so that it stays in bottom. Note that
// you shouldn’t assume the window is definitely below afterward, because other
// entities (e.g. the user or [window manager][gtk-X11-arch]) could not keep it
// below, and not all window managers support putting windows below. But
// normally the window will be kept below. Just don’t write code that crashes if
// not.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be kept below when it appears onscreen initially.
//
// You can track the below state via the “window-state-event” signal on Widget.
//
// Note that, according to the Extended Window Manager Hints Specification
// (http://www.freedesktop.org/Standards/wm-spec), the above state is mainly
// meant for user preferences and should not be used by applications e.g. for
// drawing attention to their dialogs.
//
// The function takes the following parameters:
//
//    - setting: whether to keep window below other windows.
//
func (window *Window) SetKeepBelow(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_keep_below(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetMnemonicModifier sets the mnemonic modifier for this window.
//
// The function takes the following parameters:
//
//    - modifier mask used to activate mnemonics on this window.
//
func (window *Window) SetMnemonicModifier(modifier gdk.ModifierType) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 C.GdkModifierType // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GdkModifierType(modifier)

	C.gtk_window_set_mnemonic_modifier(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(modifier)
}

// SetMnemonicsVisible sets the Window:mnemonics-visible property.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (window *Window) SetMnemonicsVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_mnemonics_visible(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetModal sets a window modal or non-modal. Modal windows prevent interaction
// with other windows in the same application. To keep modal dialogs on top of
// main application windows, use gtk_window_set_transient_for() to make the
// dialog transient for the parent; most [window managers][gtk-X11-arch] will
// then disallow lowering the dialog below the parent.
//
// The function takes the following parameters:
//
//    - modal: whether the window is modal.
//
func (window *Window) SetModal(modal bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_modal(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(modal)
}

// SetOpacity: request the windowing system to make window partially
// transparent, with opacity 0 being fully transparent and 1 fully opaque.
// (Values of the opacity parameter are clamped to the [0,1] range.) On X11 this
// has any effect only on X screens with a compositing manager running. See
// gtk_widget_is_composited(). On Windows it should work always.
//
// Note that setting a window’s opacity after the window has been shown causes
// it to flicker once on Windows.
//
// Deprecated: Use gtk_widget_set_opacity instead.
//
// The function takes the following parameters:
//
//    - opacity: desired opacity, between 0 and 1.
//
func (window *Window) SetOpacity(opacity float64) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gdouble    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.gdouble(opacity)

	C.gtk_window_set_opacity(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(opacity)
}

// SetPosition sets a position constraint for this window. If the old or new
// constraint is GTK_WIN_POS_CENTER_ALWAYS, this will also cause the window to
// be repositioned to satisfy the new constraint.
//
// The function takes the following parameters:
//
//    - position constraint.
//
func (window *Window) SetPosition(position WindowPosition) {
	var _arg0 *C.GtkWindow        // out
	var _arg1 C.GtkWindowPosition // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GtkWindowPosition(position)

	C.gtk_window_set_position(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(position)
}

// SetResizable sets whether the user can resize a window. Windows are user
// resizable by default.
//
// The function takes the following parameters:
//
//    - resizable: TRUE if the user can resize this window.
//
func (window *Window) SetResizable(resizable bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_resizable(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(resizable)
}

// SetRole: this function is only useful on X11, not with other GTK+ targets.
//
// In combination with the window title, the window role allows a [window
// manager][gtk-X11-arch] to identify "the same" window when an application is
// restarted. So for example you might set the “toolbox” role on your app’s
// toolbox window, so that when the user restarts their session, the window
// manager can put the toolbox back in the same place.
//
// If a window already has a unique title, you don’t need to set the role, since
// the WM can use the title to identify the window when restoring the session.
//
// The function takes the following parameters:
//
//    - role: unique identifier for the window to be used when restoring a
//    session.
//
func (window *Window) SetRole(role string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(role)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_role(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(role)
}

// SetScreen sets the Screen where the window is displayed; if the window is
// already mapped, it will be unmapped, and then remapped on the new screen.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
func (window *Window) SetScreen(screen *gdk.Screen) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GdkScreen // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(screen.Native()))

	C.gtk_window_set_screen(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(screen)
}

// SetSkipPagerHint windows may set a hint asking the desktop environment not to
// display the window in the pager. This function sets this hint. (A "pager" is
// any desktop navigation tool such as a workspace switcher that displays a
// thumbnail representation of the windows on the screen.).
//
// The function takes the following parameters:
//
//    - setting: TRUE to keep this window from appearing in the pager.
//
func (window *Window) SetSkipPagerHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_skip_pager_hint(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetSkipTaskbarHint windows may set a hint asking the desktop environment not
// to display the window in the task bar. This function sets this hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to keep this window from appearing in the task bar.
//
func (window *Window) SetSkipTaskbarHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_skip_taskbar_hint(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetStartupID: startup notification identifiers are used by desktop
// environment to track application startup, to provide user feedback and other
// features. This function changes the corresponding property on the underlying
// GdkWindow. Normally, startup identifier is managed automatically and you
// should only use this function in special cases like transferring focus from
// other processes. You should use this function before calling
// gtk_window_present() or any equivalent function generating a window map
// event.
//
// This function is only useful on X11, not with other GTK+ targets.
//
// The function takes the following parameters:
//
//    - startupId: string with startup-notification identifier.
//
func (window *Window) SetStartupID(startupId string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_startup_id(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(startupId)
}

// SetTitle sets the title of the Window. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar is rendered
// by the [window manager][gtk-X11-arch], so exactly how the title appears to
// users may vary according to a user’s exact configuration. The title should
// help a user distinguish this window from other windows they may have open. A
// good title might include the application name and current document filename,
// for example.
//
// The function takes the following parameters:
//
//    - title of the window.
//
func (window *Window) SetTitle(title string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_title(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(title)
}

// SetTitlebar sets a custom titlebar for window.
//
// A typical widget used here is HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to it.
//
// If you set a custom titlebar, GTK+ will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the system,
// this function may not work for a window that is already visible, so you set
// the titlebar before calling gtk_widget_show().
//
// The function takes the following parameters:
//
//    - titlebar: widget to use as titlebar.
//
func (window *Window) SetTitlebar(titlebar Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if titlebar != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(titlebar.Native()))
	}

	C.gtk_window_set_titlebar(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(titlebar)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows [window
// managers][gtk-X11-arch] to e.g. keep the dialog on top of the main window, or
// center the dialog over the main window. gtk_dialog_new_with_buttons() and
// other convenience functions in GTK+ will sometimes call
// gtk_window_set_transient_for() on your behalf.
//
// Passing NULL for parent unsets the current transient window.
//
// On Wayland, this function can also be used to attach a new K_WINDOW_POPUP to
// a K_WINDOW_TOPLEVEL parent already mapped on screen so that the
// K_WINDOW_POPUP will be created as a subsurface-based window
// K_WINDOW_SUBSURFACE which can be positioned at will relatively to the
// K_WINDOW_TOPLEVEL surface.
//
// On Windows, this function puts the child window on top of the parent, much as
// the window manager would have done on X.
//
// The function takes the following parameters:
//
//    - parent window, or NULL.
//
func (window *Window) SetTransientFor(parent *Window) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
	}

	C.gtk_window_set_transient_for(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(parent)
}

// SetTypeHint: by setting the type hint for the window, you allow the window
// manager to decorate and handle the window in a way which is suitable to the
// function of the window in your application.
//
// This function should be called before the window becomes visible.
//
// gtk_dialog_new_with_buttons() and other convenience functions in GTK+ will
// sometimes call gtk_window_set_type_hint() on your behalf.
//
// The function takes the following parameters:
//
//    - hint: window type.
//
func (window *Window) SetTypeHint(hint gdk.WindowTypeHint) {
	var _arg0 *C.GtkWindow        // out
	var _arg1 C.GdkWindowTypeHint // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = C.GdkWindowTypeHint(hint)

	C.gtk_window_set_type_hint(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(hint)
}

// SetUrgencyHint windows may set a hint asking the desktop environment to draw
// the users attention to the window. This function sets this hint.
//
// The function takes the following parameters:
//
//    - setting: TRUE to mark this window as urgent.
//
func (window *Window) SetUrgencyHint(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_urgency_hint(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetWmclass: don’t use this function. It sets the X Window System “class” and
// “name” hints for a window. According to the ICCCM, you should always set
// these to the same value for all windows in an application, and GTK+ sets them
// to that value by default, so calling this function is sort of pointless.
// However, you may want to call gtk_window_set_role() on each window in your
// application, for the benefit of the session manager. Setting the role allows
// the window manager to restore window positions when loading a saved session.
//
// Deprecated: since version 3.22.
//
// The function takes the following parameters:
//
//    - wmclassName: window name hint.
//    - wmclassClass: window class hint.
//
func (window *Window) SetWmclass(wmclassName, wmclassClass string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(wmclassName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(wmclassClass)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_window_set_wmclass(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(wmclassName)
	runtime.KeepAlive(wmclassClass)
}

// Stick asks to stick window, which means that it will appear on all user
// desktops. Note that you shouldn’t assume the window is definitely stuck
// afterward, because other entities (e.g. the user or [window
// manager][gtk-X11-arch] could unstick it again, and some window managers do
// not support sticking windows. But normally the window will end up stuck. Just
// don't write code that crashes if not.
//
// It’s permitted to call this function before showing a window.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (window *Window) Stick() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_stick(_arg0)
	runtime.KeepAlive(window)
}

// Unfullscreen asks to toggle off the fullscreen state for window. Note that
// you shouldn’t assume the window is definitely not full screen afterward,
// because other entities (e.g. the user or [window manager][gtk-X11-arch])
// could fullscreen it again, and not all window managers honor requests to
// unfullscreen windows. But normally the window will end up restored to its
// normal state. Just don’t write code that crashes if not.
//
// You can track the fullscreen state via the “window-state-event” signal on
// Widget.
func (window *Window) Unfullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_unfullscreen(_arg0)
	runtime.KeepAlive(window)
}

// Unmaximize asks to unmaximize window. Note that you shouldn’t assume the
// window is definitely unmaximized afterward, because other entities (e.g. the
// user or [window manager][gtk-X11-arch]) could maximize it again, and not all
// window managers honor requests to unmaximize. But normally the window will
// end up unmaximized. Just don’t write code that crashes if not.
//
// You can track maximization via the “window-state-event” signal on Widget.
func (window *Window) Unmaximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_unmaximize(_arg0)
	runtime.KeepAlive(window)
}

// Unstick asks to unstick window, which means that it will appear on only one
// of the user’s desktops. Note that you shouldn’t assume the window is
// definitely unstuck afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could stick it again. But normally the window
// will end up stuck. Just don’t write code that crashes if not.
//
// You can track stickiness via the “window-state-event” signal on Widget.
func (window *Window) Unstick() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

	C.gtk_window_unstick(_arg0)
	runtime.KeepAlive(window)
}

// ConnectActivateDefault signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted when the user activates the default widget of window.
func (window *Window) ConnectActivateDefault(f func()) externglib.SignalHandle {
	return window.Connect("activate-default", f)
}

// ConnectActivateFocus signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user activates the currently focused widget of window.
func (window *Window) ConnectActivateFocus(f func()) externglib.SignalHandle {
	return window.Connect("activate-focus", f)
}

// ConnectEnableDebugging signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted when the user enables or disables interactive debugging.
// When toggle is TRUE, interactive debugging is toggled on or off, when it is
// FALSE, the debugger will be pointed at the widget under the pointer.
//
// The default bindings for this signal are Ctrl-Shift-I and Ctrl-Shift-D.
func (window *Window) ConnectEnableDebugging(f func(toggle bool) bool) externglib.SignalHandle {
	return window.Connect("enable-debugging", f)
}

// ConnectKeysChanged signal gets emitted when the set of accelerators or
// mnemonics that are associated with window changes.
func (window *Window) ConnectKeysChanged(f func()) externglib.SignalHandle {
	return window.Connect("keys-changed", f)
}

// ConnectSetFocus: this signal is emitted whenever the currently focused widget
// in this window changes.
func (window *Window) ConnectSetFocus(f func(widget Widgetter)) externglib.SignalHandle {
	return window.Connect("set-focus", f)
}

// WindowGetDefaultIconList gets the value set by
// gtk_window_set_default_icon_list(). The list is a copy and should be freed
// with g_list_free(), but the pixbufs in the list have not had their reference
// count incremented.
func WindowGetDefaultIconList() []gdkpixbuf.Pixbuf {
	var _cret *C.GList // in

	_cret = C.gtk_window_get_default_icon_list()

	var _list []gdkpixbuf.Pixbuf // out

	_list = make([]gdkpixbuf.Pixbuf, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GdkPixbuf)(v)
		var dst gdkpixbuf.Pixbuf // out
		{
			obj := externglib.Take(unsafe.Pointer(src))
			dst = gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
		_list = append(_list, dst)
	})

	return _list
}

// WindowGetDefaultIconName returns the fallback icon name for windows that has
// been set with gtk_window_set_default_icon_name(). The returned string is
// owned by GTK+ and should not be modified. It is only valid until the next
// call to gtk_window_set_default_icon_name().
func WindowGetDefaultIconName() string {
	var _cret *C.gchar // in

	_cret = C.gtk_window_get_default_icon_name()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// WindowListToplevels returns a list of all existing toplevel windows. The
// widgets in the list are not individually referenced. If you want to iterate
// through the list and perform actions involving callbacks that might destroy
// the widgets, you must call g_list_foreach (result, (GFunc)g_object_ref, NULL)
// first, and then unref all the widgets afterwards.
func WindowListToplevels() []Widgetter {
	var _cret *C.GList // in

	_cret = C.gtk_window_list_toplevels()

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(Widgetter)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// WindowSetAutoStartupNotification: by default, after showing the first Window,
// GTK+ calls gdk_notify_startup_complete(). Call this function to disable the
// automatic startup notification. You might do this if your first window is a
// splash screen, and you want to delay notification until after your real main
// window has been shown, for example.
//
// In that example, you would disable startup notification temporarily, show
// your splash screen, then re-enable it so that showing the main window would
// automatically result in notification.
//
// The function takes the following parameters:
//
//    - setting: TRUE to automatically do startup notification.
//
func WindowSetAutoStartupNotification(setting bool) {
	var _arg1 C.gboolean // out

	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_auto_startup_notification(_arg1)
	runtime.KeepAlive(setting)
}

// WindowSetDefaultIcon sets an icon to be used as fallback for windows that
// haven't had gtk_window_set_icon() called on them from a pixbuf.
//
// The function takes the following parameters:
//
//    - icon: icon.
//
func WindowSetDefaultIcon(icon *gdkpixbuf.Pixbuf) {
	var _arg1 *C.GdkPixbuf // out

	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(icon.Native()))

	C.gtk_window_set_default_icon(_arg1)
	runtime.KeepAlive(icon)
}

// WindowSetDefaultIconFromFile sets an icon to be used as fallback for windows
// that haven't had gtk_window_set_icon_list() called on them from a file on
// disk. Warns on failure if err is NULL.
//
// The function takes the following parameters:
//
//    - filename: location of icon file.
//
func WindowSetDefaultIconFromFile(filename string) error {
	var _arg1 *C.gchar  // out
	var _cerr *C.GError // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_default_icon_from_file(_arg1, &_cerr)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// WindowSetDefaultIconList sets an icon list to be used as fallback for windows
// that haven't had gtk_window_set_icon_list() called on them to set up a
// window-specific icon list. This function allows you to set up the icon for
// all windows in your app at once.
//
// See gtk_window_set_icon_list() for more details.
//
// The function takes the following parameters:
//
//    - list of Pixbuf.
//
func WindowSetDefaultIconList(list []gdkpixbuf.Pixbuf) {
	var _arg1 *C.GList // out

	for i := len(list) - 1; i >= 0; i-- {
		src := list[i]
		var dst *C.GdkPixbuf // out
		dst = (*C.GdkPixbuf)(unsafe.Pointer((&src).Native()))
		_arg1 = C.g_list_prepend(_arg1, C.gpointer(unsafe.Pointer(dst)))
	}

	C.gtk_window_set_default_icon_list(_arg1)
	runtime.KeepAlive(list)
}

// WindowSetDefaultIconName sets an icon to be used as fallback for windows that
// haven't had gtk_window_set_icon_list() called on them from a named themed
// icon, see gtk_window_set_icon_name().
//
// The function takes the following parameters:
//
//    - name of the themed icon.
//
func WindowSetDefaultIconName(name string) {
	var _arg1 *C.gchar // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_default_icon_name(_arg1)
	runtime.KeepAlive(name)
}

// WindowSetInteractiveDebugging opens or closes the [interactive
// debugger][interactive-debugging], which offers access to the widget hierarchy
// of the application and to useful debugging tools.
//
// The function takes the following parameters:
//
//    - enable: TRUE to enable interactive debugging.
//
func WindowSetInteractiveDebugging(enable bool) {
	var _arg1 C.gboolean // out

	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_interactive_debugging(_arg1)
	runtime.KeepAlive(enable)
}

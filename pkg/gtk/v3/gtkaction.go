// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_Action_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk3_ActionClass_disconnect_proxy(GtkAction*, GtkWidget*);
// extern void _gotk4_gtk3_ActionClass_connect_proxy(GtkAction*, GtkWidget*);
// extern void _gotk4_gtk3_ActionClass_activate(GtkAction*);
// extern GtkWidget* _gotk4_gtk3_ActionClass_create_tool_item(GtkAction*);
// extern GtkWidget* _gotk4_gtk3_ActionClass_create_menu_item(GtkAction*);
// extern GtkWidget* _gotk4_gtk3_ActionClass_create_menu(GtkAction*);
// void _gotk4_gtk3_Action_virtual_connect_proxy(void* fnptr, GtkAction* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkAction*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Action_virtual_disconnect_proxy(void* fnptr, GtkAction* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkAction*, GtkWidget*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeAction = coreglib.Type(C.gtk_action_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAction, F: marshalAction},
	})
}

// ActionOverrides contains methods that are overridable.
type ActionOverrides struct {
	// Activate emits the “activate” signal on the specified action, if it isn't
	// insensitive. This gets called by the proxy widgets when they get
	// activated.
	//
	// It can also be used to manually activate an action.
	//
	// Deprecated: Use g_action_group_activate_action() on a #GAction instead.
	Activate func()
	// The function takes the following parameters:
	//
	ConnectProxy func(proxy Widgetter)
	// CreateMenu: if action provides a Menu widget as a submenu for the menu
	// item or the toolbar item it creates, this function returns an instance of
	// that menu.
	//
	// Deprecated: Use #GAction and Model instead, and create a Menu with
	// gtk_menu_new_from_model().
	//
	// The function returns the following values:
	//
	//    - widget: menu item provided by the action, or NULL.
	//
	CreateMenu func() Widgetter
	// CreateMenuItem creates a menu item widget that proxies for the given
	// action.
	//
	// Deprecated: Use g_menu_item_new() and associate it with a #GAction
	// instead.
	//
	// The function returns the following values:
	//
	//    - widget: menu item connected to the action.
	//
	CreateMenuItem func() Widgetter
	// CreateToolItem creates a toolbar item widget that proxies for the given
	// action.
	//
	// Deprecated: Use a ToolItem and associate it with a #GAction using
	// gtk_actionable_set_action_name() instead.
	//
	// The function returns the following values:
	//
	//    - widget: toolbar item connected to the action.
	//
	CreateToolItem func() Widgetter
	// The function takes the following parameters:
	//
	DisconnectProxy func(proxy Widgetter)
}

func defaultActionOverrides(v *Action) ActionOverrides {
	return ActionOverrides{
		Activate:        v.activate,
		ConnectProxy:    v.connectProxy,
		CreateMenu:      v.createMenu,
		CreateMenuItem:  v.createMenuItem,
		CreateToolItem:  v.createToolItem,
		DisconnectProxy: v.disconnectProxy,
	}
}

// Action: > In GTK+ 3.10, GtkAction has been deprecated. Use #GAction >
// instead, and associate actions with Actionable widgets. Use > Model for
// creating menus with gtk_menu_new_from_model().
//
// Actions represent operations that the user can be perform, along with some
// information how it should be presented in the interface. Each action provides
// methods to create icons, menu items and toolbar items representing itself.
//
// As well as the callback that is called when the action gets activated, the
// following also gets associated with the action:
//
// - a name (not translated, for path lookup)
//
// - a label (translated, for display)
//
// - an accelerator
//
// - whether label indicates a stock id
//
// - a tooltip (optional, translated)
//
// - a toolbar label (optional, shorter than label)
//
//    The action will also have some state information:
//
// - visible (shown/hidden)
//
// - sensitive (enabled/disabled)
//
// Apart from regular actions, there are [toggle actions][GtkToggleAction],
// which can be toggled between two states and [radio actions][GtkRadioAction],
// of which only one in a group can be in the “active” state. Other actions can
// be implemented as Action subclasses.
//
// Each action can have one or more proxy widgets. To act as an action proxy,
// widget needs to implement Activatable interface. Proxies mirror the state of
// the action and should change when the action’s state changes. Properties that
// are always mirrored by proxies are Action:sensitive and Action:visible.
// Action:gicon, Action:icon-name, Action:label, Action:short-label and
// Action:stock-id properties are only mirorred if proxy widget has
// Activatable:use-action-appearance property set to TRUE.
//
// When the proxy is activated, it should activate its action.
type Action struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
}

var (
	_ coreglib.Objector = (*Action)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Action, *ActionClass, ActionOverrides](
		GTypeAction,
		initActionClass,
		wrapAction,
		defaultActionOverrides,
	)
}

func initActionClass(gclass unsafe.Pointer, overrides ActionOverrides, classInitFunc func(*ActionClass)) {
	pclass := (*C.GtkActionClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAction))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk3_ActionClass_activate)
	}

	if overrides.ConnectProxy != nil {
		pclass.connect_proxy = (*[0]byte)(C._gotk4_gtk3_ActionClass_connect_proxy)
	}

	if overrides.CreateMenu != nil {
		pclass.create_menu = (*[0]byte)(C._gotk4_gtk3_ActionClass_create_menu)
	}

	if overrides.CreateMenuItem != nil {
		pclass.create_menu_item = (*[0]byte)(C._gotk4_gtk3_ActionClass_create_menu_item)
	}

	if overrides.CreateToolItem != nil {
		pclass.create_tool_item = (*[0]byte)(C._gotk4_gtk3_ActionClass_create_tool_item)
	}

	if overrides.DisconnectProxy != nil {
		pclass.disconnect_proxy = (*[0]byte)(C._gotk4_gtk3_ActionClass_disconnect_proxy)
	}

	if classInitFunc != nil {
		class := (*ActionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAction(obj *coreglib.Object) *Action {
	return &Action{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalAction(p uintptr) (interface{}, error) {
	return wrapAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate: "activate" signal is emitted when the action is activated.
func (action *Action) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(action, "activate", false, unsafe.Pointer(C._gotk4_gtk3_Action_ConnectActivate), f)
}

// The function takes the following parameters:
//
func (action *Action) connectProxy(proxy Widgetter) {
	gclass := (*C.GtkActionClass)(coreglib.PeekParentClass(action))
	fnarg := gclass.connect_proxy

	var _arg0 *C.GtkAction // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	C._gotk4_gtk3_Action_virtual_connect_proxy(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(proxy)
}

// The function takes the following parameters:
//
func (action *Action) disconnectProxy(proxy Widgetter) {
	gclass := (*C.GtkActionClass)(coreglib.PeekParentClass(action))
	fnarg := gclass.disconnect_proxy

	var _arg0 *C.GtkAction // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(proxy).Native()))

	C._gotk4_gtk3_Action_virtual_disconnect_proxy(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(action)
	runtime.KeepAlive(proxy)
}

// ActionClass: instance of this type is always passed by reference.
type ActionClass struct {
	*actionClass
}

// actionClass is the struct that's finalized.
type actionClass struct {
	native *C.GtkActionClass
}

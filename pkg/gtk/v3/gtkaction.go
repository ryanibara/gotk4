// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern GtkWidget* _gotk4_gtk3_ActionClass_create_menu(void*);
// extern GtkWidget* _gotk4_gtk3_ActionClass_create_menu_item(void*);
// extern GtkWidget* _gotk4_gtk3_ActionClass_create_tool_item(void*);
// extern void _gotk4_gtk3_ActionClass_activate(void*);
// extern void _gotk4_gtk3_ActionClass_connect_proxy(void*, void*);
// extern void _gotk4_gtk3_ActionClass_disconnect_proxy(void*, void*);
// extern void _gotk4_gtk3_Action_ConnectActivate(gpointer, guintptr);
import "C"

// glib.Type values for gtkaction.go.
var GTypeAction = coreglib.Type(C.gtk_action_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeAction, F: marshalAction},
	})
}

// ActionOverrider contains methods that are overridable.
type ActionOverrider interface {
	// Activate emits the “activate” signal on the specified action, if it isn't
	// insensitive. This gets called by the proxy widgets when they get
	// activated.
	//
	// It can also be used to manually activate an action.
	//
	// Deprecated: Use g_action_group_activate_action() on a #GAction instead.
	Activate()
	// The function takes the following parameters:
	//
	ConnectProxy(proxy Widgetter)
	// CreateMenu: if action provides a Menu widget as a submenu for the menu
	// item or the toolbar item it creates, this function returns an instance of
	// that menu.
	//
	// Deprecated: Use #GAction and Model instead, and create a Menu with
	// gtk_menu_new_from_model().
	//
	// The function returns the following values:
	//
	//    - widget: menu item provided by the action, or NULL.
	//
	CreateMenu() Widgetter
	// CreateMenuItem creates a menu item widget that proxies for the given
	// action.
	//
	// Deprecated: Use g_menu_item_new() and associate it with a #GAction
	// instead.
	//
	// The function returns the following values:
	//
	//    - widget: menu item connected to the action.
	//
	CreateMenuItem() Widgetter
	// CreateToolItem creates a toolbar item widget that proxies for the given
	// action.
	//
	// Deprecated: Use a ToolItem and associate it with a #GAction using
	// gtk_actionable_set_action_name() instead.
	//
	// The function returns the following values:
	//
	//    - widget: toolbar item connected to the action.
	//
	CreateToolItem() Widgetter
	// The function takes the following parameters:
	//
	DisconnectProxy(proxy Widgetter)
}

// Action: > In GTK+ 3.10, GtkAction has been deprecated. Use #GAction >
// instead, and associate actions with Actionable widgets. Use > Model for
// creating menus with gtk_menu_new_from_model().
//
// Actions represent operations that the user can be perform, along with some
// information how it should be presented in the interface. Each action provides
// methods to create icons, menu items and toolbar items representing itself.
//
// As well as the callback that is called when the action gets activated, the
// following also gets associated with the action:
//
// - a name (not translated, for path lookup)
//
// - a label (translated, for display)
//
// - an accelerator
//
// - whether label indicates a stock id
//
// - a tooltip (optional, translated)
//
// - a toolbar label (optional, shorter than label)
//
//    The action will also have some state information:
//
// - visible (shown/hidden)
//
// - sensitive (enabled/disabled)
//
// Apart from regular actions, there are [toggle actions][GtkToggleAction],
// which can be toggled between two states and [radio actions][GtkRadioAction],
// of which only one in a group can be in the “active” state. Other actions can
// be implemented as Action subclasses.
//
// Each action can have one or more proxy widgets. To act as an action proxy,
// widget needs to implement Activatable interface. Proxies mirror the state of
// the action and should change when the action’s state changes. Properties that
// are always mirrored by proxies are Action:sensitive and Action:visible.
// Action:gicon, Action:icon-name, Action:label, Action:short-label and
// Action:stock-id properties are only mirorred if proxy widget has
// Activatable:use-action-appearance property set to TRUE.
//
// When the proxy is activated, it should activate its action.
type Action struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
}

var (
	_ coreglib.Objector = (*Action)(nil)
)

func classInitActioner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkActionClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkActionClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ Activate() }); ok {
		pclass.activate = (*[0]byte)(C._gotk4_gtk3_ActionClass_activate)
	}

	if _, ok := goval.(interface{ ConnectProxy(proxy Widgetter) }); ok {
		pclass.connect_proxy = (*[0]byte)(C._gotk4_gtk3_ActionClass_connect_proxy)
	}

	if _, ok := goval.(interface{ CreateMenu() Widgetter }); ok {
		pclass.create_menu = (*[0]byte)(C._gotk4_gtk3_ActionClass_create_menu)
	}

	if _, ok := goval.(interface{ CreateMenuItem() Widgetter }); ok {
		pclass.create_menu_item = (*[0]byte)(C._gotk4_gtk3_ActionClass_create_menu_item)
	}

	if _, ok := goval.(interface{ CreateToolItem() Widgetter }); ok {
		pclass.create_tool_item = (*[0]byte)(C._gotk4_gtk3_ActionClass_create_tool_item)
	}

	if _, ok := goval.(interface{ DisconnectProxy(proxy Widgetter) }); ok {
		pclass.disconnect_proxy = (*[0]byte)(C._gotk4_gtk3_ActionClass_disconnect_proxy)
	}
}

//export _gotk4_gtk3_ActionClass_activate
func _gotk4_gtk3_ActionClass_activate(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Activate() })

	iface.Activate()
}

//export _gotk4_gtk3_ActionClass_connect_proxy
func _gotk4_gtk3_ActionClass_connect_proxy(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ConnectProxy(proxy Widgetter) })

	var _proxy Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	iface.ConnectProxy(_proxy)
}

//export _gotk4_gtk3_ActionClass_create_menu
func _gotk4_gtk3_ActionClass_create_menu(arg0 *C.void) (cret *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CreateMenu() Widgetter })

	widget := iface.CreateMenu()

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_create_menu_item
func _gotk4_gtk3_ActionClass_create_menu_item(arg0 *C.void) (cret *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CreateMenuItem() Widgetter })

	widget := iface.CreateMenuItem()

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_create_tool_item
func _gotk4_gtk3_ActionClass_create_tool_item(arg0 *C.void) (cret *C.GtkWidget) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CreateToolItem() Widgetter })

	widget := iface.CreateToolItem()

	cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	return cret
}

//export _gotk4_gtk3_ActionClass_disconnect_proxy
func _gotk4_gtk3_ActionClass_disconnect_proxy(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ DisconnectProxy(proxy Widgetter) })

	var _proxy Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_proxy = rv
	}

	iface.DisconnectProxy(_proxy)
}

func wrapAction(obj *coreglib.Object) *Action {
	return &Action{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalAction(p uintptr) (interface{}, error) {
	return wrapAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_Action_ConnectActivate
func _gotk4_gtk3_Action_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivate: "activate" signal is emitted when the action is activated.
func (action *Action) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(action, "activate", false, unsafe.Pointer(C._gotk4_gtk3_Action_ConnectActivate), f)
}

// NewAction creates a new Action object. To add the action to a ActionGroup and
// set the accelerator for the action, call
// gtk_action_group_add_action_with_accel(). See the [UI Definition
// section][XML-UI] for information on allowed action names.
//
// Deprecated: Use #GAction instead, associating it to a widget with Actionable
// or creating a Menu with gtk_menu_new_from_model().
//
// The function takes the following parameters:
//
//    - name: unique name for the action.
//    - label (optional) displayed in menu items and on buttons, or NULL.
//    - tooltip (optional) for the action, or NULL.
//    - stockId (optional): stock icon to display in widgets representing the
//      action, or NULL.
//
// The function returns the following values:
//
//    - action: new Action.
//
func NewAction(name, label, tooltip, stockId string) *Action {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_args[0]))
	if label != "" {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_args[1]))
	}
	if tooltip != "" {
		*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(C.CString(tooltip)))
		defer C.free(unsafe.Pointer(_args[2]))
	}
	if stockId != "" {
		*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(unsafe.Pointer(C.CString(stockId)))
		defer C.free(unsafe.Pointer(_args[3]))
	}

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("new_Action", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(name)
	runtime.KeepAlive(label)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(stockId)

	var _action *Action // out

	_action = wrapAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _action
}

// Activate emits the “activate” signal on the specified action, if it isn't
// insensitive. This gets called by the proxy widgets when they get activated.
//
// It can also be used to manually activate an action.
//
// Deprecated: Use g_action_group_activate_action() on a #GAction instead.
func (action *Action) Activate() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	girepository.MustFind("Gtk", "Action").InvokeMethod("activate", _args[:], nil)

	runtime.KeepAlive(action)
}

// BlockActivate: disable activation signals from the action
//
// This is needed when updating the state of your proxy Activatable widget could
// result in calling gtk_action_activate(), this is a convenience function to
// avoid recursing in those cases (updating toggle state for instance).
//
// Deprecated: Use g_simple_action_set_enabled() to disable the Action instead.
func (action *Action) BlockActivate() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	girepository.MustFind("Gtk", "Action").InvokeMethod("block_activate", _args[:], nil)

	runtime.KeepAlive(action)
}

// ConnectAccelerator installs the accelerator for action if action has an accel
// path and group. See gtk_action_set_accel_path() and
// gtk_action_set_accel_group()
//
// Since multiple proxies may independently trigger the installation of the
// accelerator, the action counts the number of times this function has been
// called and doesn’t remove the accelerator until
// gtk_action_disconnect_accelerator() has been called as many times.
//
// Deprecated: Use #GAction and the accelerator group on an associated Menu
// instead.
func (action *Action) ConnectAccelerator() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	girepository.MustFind("Gtk", "Action").InvokeMethod("connect_accelerator", _args[:], nil)

	runtime.KeepAlive(action)
}

// CreateMenu: if action provides a Menu widget as a submenu for the menu item
// or the toolbar item it creates, this function returns an instance of that
// menu.
//
// Deprecated: Use #GAction and Model instead, and create a Menu with
// gtk_menu_new_from_model().
//
// The function returns the following values:
//
//    - widget: menu item provided by the action, or NULL.
//
func (action *Action) CreateMenu() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("create_menu", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// CreateMenuItem creates a menu item widget that proxies for the given action.
//
// Deprecated: Use g_menu_item_new() and associate it with a #GAction instead.
//
// The function returns the following values:
//
//    - widget: menu item connected to the action.
//
func (action *Action) CreateMenuItem() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("create_menu_item", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// CreateToolItem creates a toolbar item widget that proxies for the given
// action.
//
// Deprecated: Use a ToolItem and associate it with a #GAction using
// gtk_actionable_set_action_name() instead.
//
// The function returns the following values:
//
//    - widget: toolbar item connected to the action.
//
func (action *Action) CreateToolItem() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("create_tool_item", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// DisconnectAccelerator undoes the effect of one call to
// gtk_action_connect_accelerator().
//
// Deprecated: Use #GAction and the accelerator group on an associated Menu
// instead.
func (action *Action) DisconnectAccelerator() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	girepository.MustFind("Gtk", "Action").InvokeMethod("disconnect_accelerator", _args[:], nil)

	runtime.KeepAlive(action)
}

// AccelPath returns the accel path for this action.
//
// Deprecated: Use #GAction and the accelerator path on an associated Menu
// instead.
//
// The function returns the following values:
//
//    - utf8: accel path for this action, or NULL if none is set. The returned
//      string is owned by GTK+ and must not be freed or modified.
//
func (action *Action) AccelPath() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_accel_path", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// AlwaysShowImage returns whether action's menu item proxies will always show
// their image, if available.
//
// Deprecated: Use g_menu_item_get_attribute_value() on a Item instead.
//
// The function returns the following values:
//
//    - ok: TRUE if the menu item proxies will always show their image.
//
func (action *Action) AlwaysShowImage() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_always_show_image", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// GIcon gets the gicon of action.
//
// Deprecated: Use #GAction instead, and g_menu_item_get_attribute_value() to
// get an icon from a Item associated with a #GAction.
//
// The function returns the following values:
//
//    - icon action’s #GIcon if one is set.
//
func (action *Action) GIcon() *gio.Icon {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_gicon", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _icon *gio.Icon // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_icon = &gio.Icon{
			Object: obj,
		}
	}

	return _icon
}

// IconName gets the icon name of action.
//
// Deprecated: Use #GAction instead, and g_menu_item_get_attribute_value() to
// get an icon from a Item associated with a #GAction.
//
// The function returns the following values:
//
//    - utf8: icon name.
//
func (action *Action) IconName() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_icon_name", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsImportant checks whether action is important or not
//
// Deprecated: Use #GAction instead, and control and monitor whether labels are
// shown directly.
//
// The function returns the following values:
//
//    - ok: whether action is important.
//
func (action *Action) IsImportant() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_is_important", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Label gets the label text of action.
//
// Deprecated: Use #GAction instead, and get a label from a menu item with
// g_menu_item_get_attribute_value(). For Actionable widgets, use the
// widget-specific API to get a label.
//
// The function returns the following values:
//
//    - utf8: label text.
//
func (action *Action) Label() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_label", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Name returns the name of the action.
//
// Deprecated: Use g_action_get_name() on a #GAction instead.
//
// The function returns the following values:
//
//    - utf8: name of the action. The string belongs to GTK+ and should not be
//      freed.
//
func (action *Action) Name() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_name", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Proxies returns the proxy widgets for an action. See also
// gtk_activatable_get_related_action().
//
// Deprecated: since version 3.10.
//
// The function returns the following values:
//
//    - sList of proxy widgets. The list is owned by GTK+ and must not be
//      modified.
//
func (action *Action) Proxies() []Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_proxies", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _sList []Widgetter // out

	_sList = make([]Widgetter, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// Sensitive returns whether the action itself is sensitive. Note that this
// doesn’t necessarily mean effective sensitivity. See gtk_action_is_sensitive()
// for that.
//
// Deprecated: Use g_action_get_enabled() on a #GAction instead.
//
// The function returns the following values:
//
//    - ok: TRUE if the action itself is sensitive.
//
func (action *Action) Sensitive() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_sensitive", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ShortLabel gets the short label text of action.
//
// Deprecated: Use #GAction instead, which has no equivalent of short labels.
//
// The function returns the following values:
//
//    - utf8: short label text.
//
func (action *Action) ShortLabel() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_short_label", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// StockID gets the stock id of action.
//
// Deprecated: Use #GAction instead, which has no equivalent of stock items.
//
// The function returns the following values:
//
//    - utf8: stock id.
//
func (action *Action) StockID() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_stock_id", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Tooltip gets the tooltip text of action.
//
// Deprecated: Use #GAction instead, and get tooltips from associated Actionable
// widgets with gtk_widget_get_tooltip_text().
//
// The function returns the following values:
//
//    - utf8: tooltip text.
//
func (action *Action) Tooltip() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_tooltip", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Visible returns whether the action itself is visible. Note that this doesn’t
// necessarily mean effective visibility. See gtk_action_is_sensitive() for
// that.
//
// Deprecated: Use #GAction instead, and control and monitor the state of
// Actionable widgets directly.
//
// The function returns the following values:
//
//    - ok: TRUE if the action itself is visible.
//
func (action *Action) Visible() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_visible", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// VisibleHorizontal checks whether action is visible when horizontal
//
// Deprecated: Use #GAction instead, and control and monitor the visibility of
// associated widgets and menu items directly.
//
// The function returns the following values:
//
//    - ok: whether action is visible when horizontal.
//
func (action *Action) VisibleHorizontal() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_visible_horizontal", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// VisibleVertical checks whether action is visible when horizontal
//
// Deprecated: Use #GAction instead, and control and monitor the visibility of
// associated widgets and menu items directly.
//
// The function returns the following values:
//
//    - ok: whether action is visible when horizontal.
//
func (action *Action) VisibleVertical() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("get_visible_vertical", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsSensitive returns whether the action is effectively sensitive.
//
// Deprecated: Use g_action_get_enabled() on a #GAction instead.
//
// The function returns the following values:
//
//    - ok: TRUE if the action and its associated action group are both
//      sensitive.
//
func (action *Action) IsSensitive() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("is_sensitive", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsVisible returns whether the action is effectively visible.
//
// Deprecated: Use #GAction instead, and control and monitor the state of
// Actionable widgets directly.
//
// The function returns the following values:
//
//    - ok: TRUE if the action and its associated action group are both visible.
//
func (action *Action) IsVisible() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	_gret := girepository.MustFind("Gtk", "Action").InvokeMethod("is_visible", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(action)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// SetAccelGroup sets the AccelGroup in which the accelerator for this action
// will be installed.
//
// Deprecated: Use #GAction and the accelerator group on an associated Menu
// instead.
//
// The function takes the following parameters:
//
//    - accelGroup (optional) or NULL.
//
func (action *Action) SetAccelGroup(accelGroup *AccelGroup) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if accelGroup != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	}

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_accel_group", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(accelGroup)
}

// SetAccelPath sets the accel path for this action. All proxy widgets
// associated with the action will have this accel path, so that their
// accelerators are consistent.
//
// Note that accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
//
// Deprecated: Use #GAction and the accelerator path on an associated Menu
// instead.
//
// The function takes the following parameters:
//
//    - accelPath: accelerator path.
//
func (action *Action) SetAccelPath(accelPath string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(accelPath)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_accel_path", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(accelPath)
}

// SetAlwaysShowImage sets whether action's menu item proxies will ignore the
// Settings:gtk-menu-images setting and always show their image, if available.
//
// Use this if the menu item would be useless or hard to use without their
// image.
//
// Deprecated: Use g_menu_item_set_icon() on a Item instead, if the item should
// have an image.
//
// The function takes the following parameters:
//
//    - alwaysShow: TRUE if menuitem proxies should always show their image.
//
func (action *Action) SetAlwaysShowImage(alwaysShow bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if alwaysShow {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_always_show_image", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(alwaysShow)
}

// SetGIcon sets the icon of action.
//
// Deprecated: Use #GAction instead, and g_menu_item_set_icon() to set an icon
// on a Item associated with a #GAction, or gtk_container_add() to add a Image
// to a Button.
//
// The function takes the following parameters:
//
//    - icon to set.
//
func (action *Action) SetGIcon(icon gio.Iconner) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_gicon", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(icon)
}

// SetIconName sets the icon name on action
//
// Deprecated: Use #GAction instead, and g_menu_item_set_icon() to set an icon
// on a Item associated with a #GAction, or gtk_container_add() to add a Image
// to a Button.
//
// The function takes the following parameters:
//
//    - iconName: icon name to set.
//
func (action *Action) SetIconName(iconName string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_icon_name", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(iconName)
}

// SetIsImportant sets whether the action is important, this attribute is used
// primarily by toolbar items to decide whether to show a label or not.
//
// Deprecated: Use #GAction instead, and control and monitor whether labels are
// shown directly.
//
// The function takes the following parameters:
//
//    - isImportant: TRUE to make the action important.
//
func (action *Action) SetIsImportant(isImportant bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if isImportant {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_is_important", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(isImportant)
}

// SetLabel sets the label of action.
//
// Deprecated: Use #GAction instead, and set a label on a menu item with
// g_menu_item_set_label(). For Actionable widgets, use the widget-specific API
// to set a label.
//
// The function takes the following parameters:
//
//    - label text to set.
//
func (action *Action) SetLabel(label string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_label", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(label)
}

// SetSensitive sets the :sensitive property of the action to sensitive. Note
// that this doesn’t necessarily mean effective sensitivity. See
// gtk_action_is_sensitive() for that.
//
// Deprecated: Use g_simple_action_set_enabled() on a Action instead.
//
// The function takes the following parameters:
//
//    - sensitive: TRUE to make the action sensitive.
//
func (action *Action) SetSensitive(sensitive bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if sensitive {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_sensitive", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(sensitive)
}

// SetShortLabel sets a shorter label text on action.
//
// Deprecated: Use #GAction instead, which has no equivalent of short labels.
//
// The function takes the following parameters:
//
//    - shortLabel: label text to set.
//
func (action *Action) SetShortLabel(shortLabel string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(shortLabel)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_short_label", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(shortLabel)
}

// SetStockID sets the stock id on action
//
// Deprecated: Use #GAction instead, which has no equivalent of stock items.
//
// The function takes the following parameters:
//
//    - stockId: stock id.
//
func (action *Action) SetStockID(stockId string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(stockId)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_stock_id", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(stockId)
}

// SetTooltip sets the tooltip text on action
//
// Deprecated: Use #GAction instead, and set tooltips on associated Actionable
// widgets with gtk_widget_set_tooltip_text().
//
// The function takes the following parameters:
//
//    - tooltip text.
//
func (action *Action) SetTooltip(tooltip string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(tooltip)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_tooltip", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(tooltip)
}

// SetVisible sets the :visible property of the action to visible. Note that
// this doesn’t necessarily mean effective visibility. See
// gtk_action_is_visible() for that.
//
// Deprecated: Use #GAction instead, and control and monitor the state of
// Actionable widgets directly.
//
// The function takes the following parameters:
//
//    - visible: TRUE to make the action visible.
//
func (action *Action) SetVisible(visible bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if visible {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_visible", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(visible)
}

// SetVisibleHorizontal sets whether action is visible when horizontal
//
// Deprecated: Use #GAction instead, and control and monitor the visibility of
// associated widgets and menu items directly.
//
// The function takes the following parameters:
//
//    - visibleHorizontal: whether the action is visible horizontally.
//
func (action *Action) SetVisibleHorizontal(visibleHorizontal bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if visibleHorizontal {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_visible_horizontal", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(visibleHorizontal)
}

// SetVisibleVertical sets whether action is visible when vertical
//
// Deprecated: Use #GAction instead, and control and monitor the visibility of
// associated widgets and menu items directly.
//
// The function takes the following parameters:
//
//    - visibleVertical: whether the action is visible vertically.
//
func (action *Action) SetVisibleVertical(visibleVertical bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))
	if visibleVertical {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "Action").InvokeMethod("set_visible_vertical", _args[:], nil)

	runtime.KeepAlive(action)
	runtime.KeepAlive(visibleVertical)
}

// UnblockActivate: reenable activation signals from the action
//
// Deprecated: Use g_simple_action_set_enabled() to enable the Action instead.
func (action *Action) UnblockActivate() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(action).Native()))

	girepository.MustFind("Gtk", "Action").InvokeMethod("unblock_activate", _args[:], nil)

	runtime.KeepAlive(action)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gtk3_StyleContextClass_changed(void*);
// extern void _gotk4_gtk3_StyleContext_ConnectChanged(gpointer, guintptr);
import "C"

// GTypeStyleContextPrintFlags returns the GType for the type StyleContextPrintFlags.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeStyleContextPrintFlags() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "StyleContextPrintFlags").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalStyleContextPrintFlags)
	return gtype
}

// GTypeStyleContext returns the GType for the type StyleContext.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeStyleContext() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "StyleContext").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalStyleContext)
	return gtype
}

// STYLE_CLASS_ACCELERATOR: CSS class to match an accelerator.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_ACCELERATOR = "accelerator"

// STYLE_CLASS_ARROW: CSS class used when rendering an arrow element.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_ARROW = "arrow"

// STYLE_CLASS_BACKGROUND: CSS class to match the window background.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_BACKGROUND = "background"

// STYLE_CLASS_BOTTOM: CSS class to indicate an area at the bottom of a widget.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_BOTTOM = "bottom"

// STYLE_CLASS_BUTTON: CSS class to match buttons.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_BUTTON = "button"

// STYLE_CLASS_CALENDAR: CSS class to match calendars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_CALENDAR = "calendar"

// STYLE_CLASS_CELL: CSS class to match content rendered in cell views.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_CELL = "cell"

// STYLE_CLASS_CHECK: CSS class to match check boxes.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_CHECK = "check"

// STYLE_CLASS_COMBOBOX_ENTRY: CSS class to match combobox entries.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_COMBOBOX_ENTRY = "combobox-entry"

// STYLE_CLASS_CONTEXT_MENU: CSS class to match context menus.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_CONTEXT_MENU = "context-menu"

// STYLE_CLASS_CSD: CSS class that gets added to windows which have client-side
// decorations.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_CSD = "csd"

// STYLE_CLASS_CURSOR_HANDLE: CSS class used when rendering a drag handle for
// text selection.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_CURSOR_HANDLE = "cursor-handle"

// STYLE_CLASS_DEFAULT: CSS class to match the default widget.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_DEFAULT = "default"

// STYLE_CLASS_DESTRUCTIVE_ACTION: CSS class used when an action (usually a
// button) is one that is expected to remove or destroy something visible to the
// user.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_DESTRUCTIVE_ACTION = "destructive-action"

// STYLE_CLASS_DIM_LABEL: CSS class to match dimmed labels.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_DIM_LABEL = "dim-label"

// STYLE_CLASS_DND: CSS class for a drag-and-drop indicator.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_DND = "dnd"

// STYLE_CLASS_DOCK: CSS class defining a dock area.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_DOCK = "dock"

// STYLE_CLASS_ENTRY: CSS class to match text entries.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_ENTRY = "entry"

// STYLE_CLASS_ERROR: CSS class for an area displaying an error message, such as
// those in infobars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_ERROR = "error"

// STYLE_CLASS_EXPANDER: CSS class defining an expander, such as those in
// treeviews.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_EXPANDER = "expander"

// STYLE_CLASS_FLAT: CSS class that is added when widgets that usually have a
// frame or border (like buttons or entries) should appear without it.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_FLAT = "flat"

// STYLE_CLASS_FRAME: CSS class defining a frame delimiting content, such as
// Frame or the scrolled window frame around the scrollable area.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_FRAME = "frame"

// STYLE_CLASS_GRIP: CSS class defining a resize grip.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_GRIP = "grip"

// STYLE_CLASS_HEADER: CSS class to match a header element.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_HEADER = "header"

// STYLE_CLASS_HIGHLIGHT: CSS class defining a highlighted area, such as
// headings in assistants and calendars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_HIGHLIGHT = "highlight"

// STYLE_CLASS_HORIZONTAL: CSS class for horizontally layered widgets.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_HORIZONTAL = "horizontal"

// STYLE_CLASS_IMAGE: CSS class defining an image, such as the icon in an entry.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_IMAGE = "image"

// STYLE_CLASS_INFO: CSS class for an area displaying an informational message,
// such as those in infobars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_INFO = "info"

// STYLE_CLASS_INLINE_TOOLBAR: CSS class to match inline toolbars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_INLINE_TOOLBAR = "inline-toolbar"

// STYLE_CLASS_INSERTION_CURSOR: CSS class used when rendering a drag handle for
// the insertion cursor position.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_INSERTION_CURSOR = "insertion-cursor"

// STYLE_CLASS_LABEL: CSS class to match labels.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_LABEL = "label"

// STYLE_CLASS_LEFT: CSS class to indicate an area at the left of a widget.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_LEFT = "left"

// STYLE_CLASS_LEVEL_BAR: CSS class used when rendering a level indicator, such
// as a battery charge level, or a password strength.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_LEVEL_BAR = "level-bar"

// STYLE_CLASS_LINKED: CSS class to match a linked area, such as a box
// containing buttons belonging to the same control.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_LINKED = "linked"

// STYLE_CLASS_LIST: CSS class to match lists.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_LIST = "list"

// STYLE_CLASS_LIST_ROW: CSS class to match list rows.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_LIST_ROW = "list-row"

// STYLE_CLASS_MARK: CSS class defining marks in a widget, such as in scales.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_MARK = "mark"

// STYLE_CLASS_MENU: CSS class to match menus.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_MENU = "menu"

// STYLE_CLASS_MENUBAR: CSS class to menubars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_MENUBAR = "menubar"

// STYLE_CLASS_MENUITEM: CSS class to match menu items.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_MENUITEM = "menuitem"

// STYLE_CLASS_MESSAGE_DIALOG: CSS class that is added to message dialogs.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_MESSAGE_DIALOG = "message-dialog"

// STYLE_CLASS_MONOSPACE: CSS class that is added to text view that should use a
// monospace font.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_MONOSPACE = "monospace"

// STYLE_CLASS_NEEDS_ATTENTION: CSS class used when an element needs the user
// attention, for instance a button in a stack switcher corresponding to a
// hidden page that changed state.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_NEEDS_ATTENTION = "needs-attention"

// STYLE_CLASS_NOTEBOOK: CSS class defining a notebook.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_NOTEBOOK = "notebook"

// STYLE_CLASS_OSD: CSS class used when rendering an OSD (On Screen Display)
// element, on top of another container.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_OSD = "osd"

// STYLE_CLASS_OVERSHOOT: CSS class that is added on the visual hints that
// happen when scrolling is attempted past the limits of a scrollable area.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_OVERSHOOT = "overshoot"

// STYLE_CLASS_PANE_SEPARATOR: CSS class for a pane separator, such as those in
// Paned.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_PANE_SEPARATOR = "pane-separator"

// STYLE_CLASS_PAPER: CSS class that is added to areas that should look like
// paper.
//
// This is used in print previews and themes are encouraged to style it as black
// text on white background.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_PAPER = "paper"

// STYLE_CLASS_POPOVER: CSS class that matches popovers.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_POPOVER = "popover"

// STYLE_CLASS_POPUP: CSS class that is added to the toplevel windows used for
// menus.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_POPUP = "popup"

// STYLE_CLASS_PRIMARY_TOOLBAR: CSS class to match primary toolbars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_PRIMARY_TOOLBAR = "primary-toolbar"

// STYLE_CLASS_PROGRESSBAR: CSS class to use when rendering activity as a
// progressbar.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_PROGRESSBAR = "progressbar"

// STYLE_CLASS_PULSE: CSS class to use when rendering a pulse in an
// indeterminate progress bar.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_PULSE = "pulse"

// STYLE_CLASS_QUESTION: CSS class for an area displaying a question to the
// user, such as those in infobars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_QUESTION = "question"

// STYLE_CLASS_RADIO: CSS class to match radio buttons.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_RADIO = "radio"

// STYLE_CLASS_RAISED: CSS class to match a raised control, such as a raised
// button on a toolbar.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_RAISED = "raised"

// STYLE_CLASS_READ_ONLY: CSS class used to indicate a read-only state.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_READ_ONLY = "read-only"

// STYLE_CLASS_RIGHT: CSS class to indicate an area at the right of a widget.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_RIGHT = "right"

// STYLE_CLASS_RUBBERBAND: CSS class to match the rubberband selection
// rectangle.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_RUBBERBAND = "rubberband"

// STYLE_CLASS_SCALE: CSS class to match scale widgets.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SCALE = "scale"

// STYLE_CLASS_SCALE_HAS_MARKS_ABOVE: CSS class to match scale widgets with
// marks attached, all the marks are above for horizontal Scale. left for
// vertical Scale.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SCALE_HAS_MARKS_ABOVE = "scale-has-marks-above"

// STYLE_CLASS_SCALE_HAS_MARKS_BELOW: CSS class to match scale widgets with
// marks attached, all the marks are below for horizontal Scale, right for
// vertical Scale.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SCALE_HAS_MARKS_BELOW = "scale-has-marks-below"

// STYLE_CLASS_SCROLLBAR: CSS class to match scrollbars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SCROLLBAR = "scrollbar"

// STYLE_CLASS_SCROLLBARS_JUNCTION: CSS class to match the junction area between
// an horizontal and vertical scrollbar, when they’re both shown.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SCROLLBARS_JUNCTION = "scrollbars-junction"

// STYLE_CLASS_SEPARATOR: CSS class for a separator.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SEPARATOR = "separator"

// STYLE_CLASS_SIDEBAR: CSS class defining a sidebar, such as the left side in a
// file chooser.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SIDEBAR = "sidebar"

// STYLE_CLASS_SLIDER: CSS class to match sliders.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SLIDER = "slider"

// STYLE_CLASS_SPINBUTTON: CSS class defining an spinbutton.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SPINBUTTON = "spinbutton"

// STYLE_CLASS_SPINNER: CSS class to use when rendering activity as a “spinner”.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SPINNER = "spinner"

// STYLE_CLASS_STATUSBAR: CSS class to match statusbars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_STATUSBAR = "statusbar"

// STYLE_CLASS_SUBTITLE: CSS class used for the subtitle label in a titlebar in
// a toplevel window.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SUBTITLE = "subtitle"

// STYLE_CLASS_SUGGESTED_ACTION: CSS class used when an action (usually a
// button) is the primary suggested action in a specific context.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_SUGGESTED_ACTION = "suggested-action"

// STYLE_CLASS_TITLE: CSS class used for the title label in a titlebar in a
// toplevel window.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_TITLE = "title"

// STYLE_CLASS_TITLEBAR: CSS class used when rendering a titlebar in a toplevel
// window.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_TITLEBAR = "titlebar"

// STYLE_CLASS_TOOLBAR: CSS class to match toolbars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_TOOLBAR = "toolbar"

// STYLE_CLASS_TOOLTIP: CSS class to match tooltip windows.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_TOOLTIP = "tooltip"

// STYLE_CLASS_TOP: CSS class to indicate an area at the top of a widget.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_TOP = "top"

// STYLE_CLASS_TOUCH_SELECTION: CSS class for touch selection popups on entries
// and text views.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_TOUCH_SELECTION = "touch-selection"

// STYLE_CLASS_TROUGH: CSS class to match troughs, as in scrollbars and
// progressbars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_TROUGH = "trough"

// STYLE_CLASS_UNDERSHOOT: CSS class that is added on the visual hints that
// happen where content is 'scrolled off' and can be made visible by scrolling.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_UNDERSHOOT = "undershoot"

// STYLE_CLASS_VERTICAL: CSS class for vertically layered widgets.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_VERTICAL = "vertical"

// STYLE_CLASS_VIEW: CSS class defining a view, such as iconviews or treeviews.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_VIEW = "view"

// STYLE_CLASS_WARNING: CSS class for an area displaying a warning message, such
// as those in infobars.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_WARNING = "warning"

// STYLE_CLASS_WIDE: CSS class to indicate that a UI element should be 'wide'.
// Used by Paned.
//
// Refer to individual widget documentation for used style classes.
const STYLE_CLASS_WIDE = "wide"

// STYLE_PROPERTY_BACKGROUND_COLOR: property holding the background color of
// rendered elements as a RGBA.
const STYLE_PROPERTY_BACKGROUND_COLOR = "background-color"

// STYLE_PROPERTY_BACKGROUND_IMAGE: property holding the element’s background as
// a #cairo_pattern_t.
const STYLE_PROPERTY_BACKGROUND_IMAGE = "background-image"

// STYLE_PROPERTY_BORDER_COLOR: property holding the element’s border color as a
// RGBA.
const STYLE_PROPERTY_BORDER_COLOR = "border-color"

// STYLE_PROPERTY_BORDER_RADIUS: property holding the rendered element’s border
// radius in pixels as a #gint.
const STYLE_PROPERTY_BORDER_RADIUS = "border-radius"

// STYLE_PROPERTY_BORDER_STYLE: property holding the element’s border style as a
// BorderStyle.
const STYLE_PROPERTY_BORDER_STYLE = "border-style"

// STYLE_PROPERTY_BORDER_WIDTH: property holding the rendered element’s border
// width in pixels as a Border. The border is the intermediary spacing property
// of the padding/border/margin series.
//
// gtk_render_frame() uses this property to find out the frame line width, so
// Widgets rendering frames may need to add up this padding when requesting
// size.
const STYLE_PROPERTY_BORDER_WIDTH = "border-width"

// STYLE_PROPERTY_COLOR: property holding the foreground color of rendered
// elements as a RGBA.
const STYLE_PROPERTY_COLOR = "color"

// STYLE_PROPERTY_FONT: property holding the font properties used when rendering
// text as a FontDescription.
const STYLE_PROPERTY_FONT = "font"

// STYLE_PROPERTY_MARGIN: property holding the rendered element’s margin as a
// Border. The margin is defined as the spacing between the border of the
// element and its surrounding elements. It is external to Widget's size
// allocations, and the most external spacing property of the
// padding/border/margin series.
const STYLE_PROPERTY_MARGIN = "margin"

// STYLE_PROPERTY_PADDING: property holding the rendered element’s padding as a
// Border. The padding is defined as the spacing between the inner part of the
// element border and its child. It’s the innermost spacing property of the
// padding/border/margin series.
const STYLE_PROPERTY_PADDING = "padding"

// STYLE_REGION_COLUMN: widget region name to define a treeview column.
//
// Deprecated: Don't use regions.
const STYLE_REGION_COLUMN = "column"

// STYLE_REGION_COLUMN_HEADER: widget region name to define a treeview column
// header.
//
// Deprecated: Don't use regions.
const STYLE_REGION_COLUMN_HEADER = "column-header"

// STYLE_REGION_ROW: widget region name to define a treeview row.
//
// Deprecated: Don't use regions.
const STYLE_REGION_ROW = "row"

// STYLE_REGION_TAB: widget region name to define a notebook tab.
//
// Deprecated: Don't use regions.
const STYLE_REGION_TAB = "tab"

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string(). New values may be added to this enumeration.
type StyleContextPrintFlags C.guint

const (
	StyleContextPrintNone StyleContextPrintFlags = 0b0
	// StyleContextPrintRecurse: print the entire tree of CSS nodes starting at
	// the style context's node.
	StyleContextPrintRecurse StyleContextPrintFlags = 0b1
	// StyleContextPrintShowStyle: show the values of the CSS properties for
	// each node.
	StyleContextPrintShowStyle StyleContextPrintFlags = 0b10
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StyleContextPrintFlags.
func (s StyleContextPrintFlags) String() string {
	if s == 0 {
		return "StyleContextPrintFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(73)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StyleContextPrintNone:
			builder.WriteString("None|")
		case StyleContextPrintRecurse:
			builder.WriteString("Recurse|")
		case StyleContextPrintShowStyle:
			builder.WriteString("ShowStyle|")
		default:
			builder.WriteString(fmt.Sprintf("StyleContextPrintFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StyleContextPrintFlags) Has(other StyleContextPrintFlags) bool {
	return (s & other) == other
}

// StyleContextOverrider contains methods that are overridable.
type StyleContextOverrider interface {
	Changed()
}

// StyleContext is an object that stores styling information affecting a widget
// defined by WidgetPath.
//
// In order to construct the final style information, StyleContext queries
// information from all attached StyleProviders. Style providers can be either
// attached explicitly to the context through gtk_style_context_add_provider(),
// or to the screen through gtk_style_context_add_provider_for_screen(). The
// resulting style is a combination of all providers’ information in priority
// order.
//
// For GTK+ widgets, any StyleContext returned by gtk_widget_get_style_context()
// will already have a WidgetPath, a Screen and RTL/LTR information set. The
// style context will also be updated automatically if any of these settings
// change on the widget.
//
// If you are using the theming layer standalone, you will need to set a widget
// path and a screen yourself to the created style context through
// gtk_style_context_set_path() and possibly gtk_style_context_set_screen(). See
// the “Foreign drawing“ example in gtk3-demo.
//
//
// Style Classes
//
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
//
// GTK+ defines macros for a number of style classes.
//
//
// Style Regions
//
// Widgets can also add regions with flags to their context. This feature is
// deprecated and will be removed in a future GTK+ update. Please use style
// classes instead.
//
// GTK+ defines macros for a number of style regions.
//
//
// Custom styling in UI libraries and applications
//
// If you are developing a library with custom Widgets that render differently
// than standard components, you may need to add a StyleProvider yourself with
// the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a CssProvider or a
// custom object implementing the StyleProvider interface. This way themes may
// still attempt to style your UI elements in a different way if needed so.
//
// If you are using custom styling on an applications, you probably want then to
// make your style information prevail to the theme’s, so you must use a
// StyleProvider with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority, keep
// in mind that the user settings in XDG_CONFIG_HOME/gtk-3.0/gtk.css will still
// take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
type StyleContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*StyleContext)(nil)
)

func classInitStyleContexter(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "StyleContextClass")

	if _, ok := goval.(interface{ Changed() }); ok {
		o := pclass.StructFieldOffset("changed")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_StyleContextClass_changed)
	}
}

//export _gotk4_gtk3_StyleContextClass_changed
func _gotk4_gtk3_StyleContextClass_changed(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Changed() })

	iface.Changed()
}

func wrapStyleContext(obj *coreglib.Object) *StyleContext {
	return &StyleContext{
		Object: obj,
	}
}

func marshalStyleContext(p uintptr) (interface{}, error) {
	return wrapStyleContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_StyleContext_ConnectChanged
func _gotk4_gtk3_StyleContext_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectChanged signal is emitted when there is a change in the StyleContext.
//
// For a StyleContext returned by gtk_widget_get_style_context(), the
// Widget::style-updated signal/vfunc might be more convenient to use.
//
// This signal is useful when using the theming layer standalone.
func (context *StyleContext) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "changed", false, unsafe.Pointer(C._gotk4_gtk3_StyleContext_ConnectChanged), f)
}

// NewStyleContext creates a standalone StyleContext, this style context won’t
// be attached to any widget, so you may want to call
// gtk_style_context_set_path() yourself.
//
// This function is only useful when using the theming layer separated from
// GTK+, if you are using StyleContext to theme Widgets, use
// gtk_widget_get_style_context() in order to get a style context ready to theme
// the widget.
//
// The function returns the following values:
//
//    - styleContext: newly created StyleContext.
//
func NewStyleContext() *StyleContext {
	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("new_StyleContext", nil, nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	var _styleContext *StyleContext // out

	_styleContext = wrapStyleContext(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _styleContext
}

// AddClass adds a style class to context, so posterior calls to
// gtk_style_context_get() or any of the gtk_render_*() functions will make use
// of this new class for styling.
//
// In the CSS file format, a Entry defining a “search” class, would be matched
// by:
//
// |[ <!-- language="CSS" --> entry.search { ... } ]|
//
// While any widget defining a “search” class would be matched by: |[ <!--
// language="CSS" --> .search { ... } ]|.
//
// The function takes the following parameters:
//
//    - className class name to use in styling.
//
func (context *StyleContext) AddClass(className string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(className)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("add_class", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(className)
}

// AddProvider adds a style provider to context, to be used in style
// construction. Note that a style provider added by this function only affects
// the style of the widget to which context belongs. If you want to affect the
// style of all widgets, use gtk_style_context_add_provider_for_screen().
//
// Note: If both priorities are the same, a StyleProvider added through this
// function takes precedence over another added through
// gtk_style_context_add_provider_for_screen().
//
// The function takes the following parameters:
//
//    - provider: StyleProvider.
//    - priority of the style provider. The lower it is, the earlier it will be
//      used in the style construction. Typically this will be in the range
//      between GTK_STYLE_PROVIDER_PRIORITY_FALLBACK and
//      GTK_STYLE_PROVIDER_PRIORITY_USER.
//
func (context *StyleContext) AddProvider(provider StyleProviderer, priority uint32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(priority)

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("add_provider", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(priority)
}

// CancelAnimations stops all running animations for region_id and all
// animatable regions underneath.
//
// A NULL region_id will stop all ongoing animations in context, when dealing
// with a StyleContext obtained through gtk_widget_get_style_context(), this is
// normally done for you in all circumstances you would expect all widget to be
// stopped, so this should be only used in complex widgets with different
// animatable regions.
//
// Deprecated: This function does nothing.
//
// The function takes the following parameters:
//
//    - regionId (optional): animatable region to stop, or NULL. See
//      gtk_style_context_push_animatable_region().
//
func (context *StyleContext) CancelAnimations(regionId unsafe.Pointer) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (C.gpointer)(unsafe.Pointer(regionId))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("cancel_animations", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(regionId)
}

// FrameClock returns the FrameClock to which context is attached.
//
// The function returns the following values:
//
//    - frameClock (optional) or NULL if context does not have an attached frame
//      clock.
//
func (context *StyleContext) FrameClock() gdk.FrameClocker {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("get_frame_clock", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _frameClock gdk.FrameClocker // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.FrameClocker)
				return ok
			})
			rv, ok := casted.(gdk.FrameClocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.FrameClocker")
			}
			_frameClock = rv
		}
	}

	return _frameClock
}

// Parent gets the parent context set via gtk_style_context_set_parent(). See
// that function for details.
//
// The function returns the following values:
//
//    - styleContext (optional): parent context or NULL.
//
func (context *StyleContext) Parent() *StyleContext {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("get_parent", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _styleContext *StyleContext // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_styleContext = wrapStyleContext(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	}

	return _styleContext
}

// Path returns the widget path used for style matching.
//
// The function returns the following values:
//
//    - widgetPath: WidgetPath.
//
func (context *StyleContext) Path() *WidgetPath {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("get_path", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	C.gtk_widget_path_ref(*(**C.void)(unsafe.Pointer(&_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				var args [1]girepository.Argument
				*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
				girepository.MustFind("Gtk", "WidgetPath").InvokeRecordMethod("free", args[:], nil)
			}
		},
	)

	return _widgetPath
}

// Scale returns the scale used for assets.
//
// The function returns the following values:
//
//    - gint: scale.
//
func (context *StyleContext) Scale() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("get_scale", _args[:], nil)
	_cret := *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Screen returns the Screen to which context is attached.
//
// The function returns the following values:
//
//    - screen: Screen.
//
func (context *StyleContext) Screen() *gdk.Screen {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("get_screen", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _screen *gdk.Screen // out

	{
		obj := coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret))))
		_screen = &gdk.Screen{
			Object: obj,
		}
	}

	return _screen
}

// Section queries the location in the CSS where property was defined for the
// current context. Note that the state to be queried is taken from
// gtk_style_context_get_state().
//
// If the location is not available, NULL will be returned. The location might
// not be available for various reasons, such as the property being overridden,
// property not naming a supported CSS property or tracking of definitions being
// disabled for performance reasons.
//
// Shorthand CSS properties cannot be queried for a location and will always
// return NULL.
//
// The function takes the following parameters:
//
//    - property: style property name.
//
// The function returns the following values:
//
//    - cssSection (optional): NULL or the section where a value for property was
//      defined.
//
func (context *StyleContext) Section(property string) *CSSSection {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("get_section", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)
	runtime.KeepAlive(property)

	var _cssSection *CSSSection // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_cssSection = (*CSSSection)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
		C.gtk_css_section_ref(*(**C.void)(unsafe.Pointer(&_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_cssSection)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _cssSection
}

// StyleProperty gets the value for a widget style property.
//
// When value is no longer needed, g_value_unset() must be called to free any
// allocated memory.
//
// The function takes the following parameters:
//
//    - propertyName: name of the widget style property.
//
// The function returns the following values:
//
//    - value: return location for the property value.
//
func (context *StyleContext) StyleProperty(propertyName string) coreglib.Value {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("get_style_property", _args[:], _outs[:])

	runtime.KeepAlive(context)
	runtime.KeepAlive(propertyName)

	var _value coreglib.Value // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer(*(**C.GValue)(unsafe.Pointer(&_outs[0]))))

	return _value
}

// HasClass returns TRUE if context currently has defined the given class name.
//
// The function takes the following parameters:
//
//    - className class name.
//
// The function returns the following values:
//
//    - ok: TRUE if context has class_name defined.
//
func (context *StyleContext) HasClass(className string) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(className)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("has_class", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)
	runtime.KeepAlive(className)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// HasRegion returns TRUE if context has the region defined. If flags_return is
// not NULL, it is set to the flags affecting the region.
//
// Deprecated: since version 3.14.
//
// The function takes the following parameters:
//
//    - regionName: region name.
//
// The function returns the following values:
//
//    - flagsReturn (optional): return location for region flags.
//    - ok: TRUE if region is defined.
//
func (context *StyleContext) HasRegion(regionName string) (RegionFlags, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(regionName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("has_region", _args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)
	runtime.KeepAlive(regionName)

	var _flagsReturn RegionFlags // out
	var _ok bool                 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_flagsReturn = *(*RegionFlags)(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0]))))
	}
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _flagsReturn, _ok
}

// Invalidate invalidates context style information, so it will be reconstructed
// again. It is useful if you modify the context and need the new information
// immediately.
//
// Deprecated: Style contexts are invalidated automatically.
func (context *StyleContext) Invalidate() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("invalidate", _args[:], nil)

	runtime.KeepAlive(context)
}

// ListClasses returns the list of classes currently defined in context.
//
// The function returns the following values:
//
//    - list of strings with the currently defined classes. The contents of the
//      list are owned by GTK+, but you must free the list itself with
//      g_list_free() when you are done with it.
//
func (context *StyleContext) ListClasses() []string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("list_classes", _args[:], nil)
	_cret := *(**C.GList)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret)))))
	gextras.MoveList(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret))), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&src)))))
		_list = append(_list, dst)
	})

	return _list
}

// ListRegions returns the list of regions currently defined in context.
//
// Deprecated: since version 3.14.
//
// The function returns the following values:
//
//    - list of strings with the currently defined regions. The contents of the
//      list are owned by GTK+, but you must free the list itself with
//      g_list_free() when you are done with it.
//
func (context *StyleContext) ListRegions() []string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("list_regions", _args[:], nil)
	_cret := *(**C.GList)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret)))))
	gextras.MoveList(unsafe.Pointer(*(**C.GList)(unsafe.Pointer(&_cret))), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&src)))))
		_list = append(_list, dst)
	})

	return _list
}

// LookupColor looks up and resolves a color name in the context color map.
//
// The function takes the following parameters:
//
//    - colorName: color name to lookup.
//
// The function returns the following values:
//
//    - color: return location for the looked up color.
//    - ok: TRUE if color_name was found and resolved, FALSE otherwise.
//
func (context *StyleContext) LookupColor(colorName string) (*gdk.RGBA, bool) {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(colorName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("lookup_color", _args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)
	runtime.KeepAlive(colorName)

	var _color *gdk.RGBA // out
	var _ok bool         // out

	_color = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0])))))
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _color, _ok
}

// LookupIconSet looks up stock_id in the icon factories associated to context
// and the default icon factory, returning an icon set if found, otherwise NULL.
//
// Deprecated: Use gtk_icon_theme_lookup_icon() instead.
//
// The function takes the following parameters:
//
//    - stockId: icon name.
//
// The function returns the following values:
//
//    - iconSet (optional): looked up GtkIconSet, or NULL.
//
func (context *StyleContext) LookupIconSet(stockId string) *IconSet {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(stockId)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_gret := _info.InvokeClassMethod("lookup_icon_set", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)
	runtime.KeepAlive(stockId)

	var _iconSet *IconSet // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_iconSet = (*IconSet)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
		C.gtk_icon_set_ref(*(**C.void)(unsafe.Pointer(&_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_iconSet)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _iconSet
}

// PopAnimatableRegion pops an animatable region from context. See
// gtk_style_context_push_animatable_region().
//
// Deprecated: This function does nothing.
func (context *StyleContext) PopAnimatableRegion() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("pop_animatable_region", _args[:], nil)

	runtime.KeepAlive(context)
}

// PushAnimatableRegion pushes an animatable region, so all further
// gtk_render_*() calls between this call and the following
// gtk_style_context_pop_animatable_region() will potentially show transition
// animations for this region if gtk_style_context_notify_state_change() is
// called for a given state, and the current theme/style defines transition
// animations for state changes.
//
// The region_id used must be unique in context so the themes can uniquely
// identify rendered elements subject to a state transition.
//
// Deprecated: This function does nothing.
//
// The function takes the following parameters:
//
//    - regionId (optional): unique identifier for the animatable region.
//
func (context *StyleContext) PushAnimatableRegion(regionId unsafe.Pointer) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (C.gpointer)(unsafe.Pointer(regionId))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("push_animatable_region", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(regionId)
}

// RemoveClass removes class_name from context.
//
// The function takes the following parameters:
//
//    - className class name to remove.
//
func (context *StyleContext) RemoveClass(className string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(className)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("remove_class", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(className)
}

// RemoveProvider removes provider from the style providers list in context.
//
// The function takes the following parameters:
//
//    - provider: StyleProvider.
//
func (context *StyleContext) RemoveProvider(provider StyleProviderer) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("remove_provider", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(provider)
}

// RemoveRegion removes a region from context.
//
// Deprecated: since version 3.14.
//
// The function takes the following parameters:
//
//    - regionName: region name to unset.
//
func (context *StyleContext) RemoveRegion(regionName string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[1])) = (*C.gchar)(unsafe.Pointer(C.CString(regionName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("remove_region", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(regionName)
}

// Restore restores context state to a previous stage. See
// gtk_style_context_save().
func (context *StyleContext) Restore() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("restore", _args[:], nil)

	runtime.KeepAlive(context)
}

// Save saves the context state, so temporary modifications done through
// gtk_style_context_add_class(), gtk_style_context_remove_class(),
// gtk_style_context_set_state(), etc. can quickly be reverted in one go through
// gtk_style_context_restore().
//
// The matching call to gtk_style_context_restore() must be done before GTK
// returns to the main loop.
func (context *StyleContext) Save() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("save", _args[:], nil)

	runtime.KeepAlive(context)
}

// ScrollAnimations: this function is analogous to gdk_window_scroll(), and
// should be called together with it so the invalidation areas for any ongoing
// animation are scrolled together with it.
//
// Deprecated: This function does nothing.
//
// The function takes the following parameters:
//
//    - window used previously in gtk_style_context_notify_state_change().
//    - dx: amount to scroll in the X axis.
//    - dy: amount to scroll in the Y axis.
//
func (context *StyleContext) ScrollAnimations(window gdk.Windower, dx, dy int32) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(dx)
	*(*C.gint)(unsafe.Pointer(&_args[3])) = C.gint(dy)

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("scroll_animations", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(window)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
}

// SetBackground sets the background of window to the background pattern or
// color specified in context for its current state.
//
// Deprecated: Use gtk_render_background() instead. Note that clients still
// using this function are now responsible for calling this function again
// whenever context is invalidated.
//
// The function takes the following parameters:
//
//    - window: Window.
//
func (context *StyleContext) SetBackground(window gdk.Windower) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("set_background", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(window)
}

// SetFrameClock attaches context to the given frame clock.
//
// The frame clock is used for the timing of animations.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
//
// The function takes the following parameters:
//
//    - frameClock: FrameClock.
//
func (context *StyleContext) SetFrameClock(frameClock gdk.FrameClocker) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(frameClock).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("set_frame_clock", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(frameClock)
}

// SetParent sets the parent style context for context. The parent style context
// is used to implement inheritance
// (http://www.w3.org/TR/css3-cascade/#inheritance) of properties.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// the parent will be set for you.
//
// The function takes the following parameters:
//
//    - parent (optional): new parent or NULL.
//
func (context *StyleContext) SetParent(parent *StyleContext) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if parent != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("set_parent", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(parent)
}

// SetPath sets the WidgetPath used for style matching. As a consequence, the
// style will be regenerated to match the new given path.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
//
// The function takes the following parameters:
//
//    - path: WidgetPath.
//
func (context *StyleContext) SetPath(path *WidgetPath) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(path)))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("set_path", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(path)
}

// SetScale sets the scale to use when getting image assets for the style.
//
// The function takes the following parameters:
//
//    - scale: scale.
//
func (context *StyleContext) SetScale(scale int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(scale)

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("set_scale", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(scale)
}

// SetScreen attaches context to the given screen.
//
// The screen is used to add style information from “global” style providers,
// such as the screen’s Settings instance.
//
// If you are using a StyleContext returned from gtk_widget_get_style_context(),
// you do not need to call this yourself.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
func (context *StyleContext) SetScreen(screen *gdk.Screen) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_info := girepository.MustFind("Gtk", "StyleContext")
	_info.InvokeClassMethod("set_screen", _args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(screen)
}

// StyleContextAddProviderForScreen adds a global style provider to screen,
// which will be used in style construction for all StyleContexts under screen.
//
// GTK+ uses this to make styling information from Settings available.
//
// Note: If both priorities are the same, A StyleProvider added through
// gtk_style_context_add_provider() takes precedence over another added through
// this function.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//    - provider: StyleProvider.
//    - priority of the style provider. The lower it is, the earlier it will be
//      used in the style construction. Typically this will be in the range
//      between GTK_STYLE_PROVIDER_PRIORITY_FALLBACK and
//      GTK_STYLE_PROVIDER_PRIORITY_USER.
//
func StyleContextAddProviderForScreen(screen *gdk.Screen, provider StyleProviderer, priority uint32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(priority)

	_info := girepository.MustFind("Gtk", "add_provider_for_screen")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(screen)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(priority)
}

// StyleContextRemoveProviderForScreen removes provider from the global style
// providers list in screen.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//    - provider: StyleProvider.
//
func StyleContextRemoveProviderForScreen(screen *gdk.Screen, provider StyleProviderer) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_info := girepository.MustFind("Gtk", "remove_provider_for_screen")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(screen)
	runtime.KeepAlive(provider)
}

// StyleContextResetWidgets: this function recomputes the styles for all widgets
// under a particular Screen. This is useful when some global parameter has
// changed that affects the appearance of all widgets, because when a widget
// gets a new style, it will both redraw and recompute any cached information
// about its appearance. As an example, it is used when the color scheme changes
// in the related Settings object.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
func StyleContextResetWidgets(screen *gdk.Screen) {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_info := girepository.MustFind("Gtk", "reset_widgets")
	_info.InvokeFunction(_args[:], nil)

	runtime.KeepAlive(screen)
}

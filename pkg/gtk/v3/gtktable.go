// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeAttachOptions returns the GType for the type AttachOptions.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeAttachOptions() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "AttachOptions").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalAttachOptions)
	return gtype
}

// GTypeTable returns the GType for the type Table.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTable() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "Table").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTable)
	return gtype
}

// AttachOptions denotes the expansion properties that a widget will have when
// it (or its parent) is resized.
type AttachOptions C.guint

const (
	// Expand: widget should expand to take up any extra space in its container
	// that has been allocated.
	Expand AttachOptions = 0b1
	// Shrink: widget should shrink as and when possible.
	Shrink AttachOptions = 0b10
	// Fill: widget should fill the space allocated to it.
	Fill AttachOptions = 0b100
)

func marshalAttachOptions(p uintptr) (interface{}, error) {
	return AttachOptions(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AttachOptions.
func (a AttachOptions) String() string {
	if a == 0 {
		return "AttachOptions(0)"
	}

	var builder strings.Builder
	builder.Grow(18)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case Expand:
			builder.WriteString("Expand|")
		case Shrink:
			builder.WriteString("Shrink|")
		case Fill:
			builder.WriteString("Fill|")
		default:
			builder.WriteString(fmt.Sprintf("AttachOptions(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AttachOptions) Has(other AttachOptions) bool {
	return (a & other) == other
}

// TableOverrider contains methods that are overridable.
type TableOverrider interface {
}

// Table functions allow the programmer to arrange widgets in rows and columns,
// making it easy to align many widgets next to each other, horizontally and
// vertically.
//
// Tables are created with a call to gtk_table_new(), the size of which can
// later be changed with gtk_table_resize().
//
// Widgets can be added to a table using gtk_table_attach() or the more
// convenient (but slightly less flexible) gtk_table_attach_defaults().
//
// To alter the space next to a specific row, use gtk_table_set_row_spacing(),
// and for a column, gtk_table_set_col_spacing(). The gaps between all rows or
// columns can be changed by calling gtk_table_set_row_spacings() or
// gtk_table_set_col_spacings() respectively. Note that spacing is added between
// the children, while padding added by gtk_table_attach() is added on either
// side of the widget it belongs to.
//
// gtk_table_set_homogeneous(), can be used to set whether all cells in the
// table will resize themselves to the size of the largest widget in the table.
//
// > Table has been deprecated. Use Grid instead. It provides the same >
// capabilities as GtkTable for arranging widgets in a rectangular grid, but >
// does support height-for-width geometry management.
type Table struct {
	_ [0]func() // equal guard
	Container
}

var (
	_ Containerer = (*Table)(nil)
)

func classInitTabler(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapTable(obj *coreglib.Object) *Table {
	return &Table{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalTable(p uintptr) (interface{}, error) {
	return wrapTable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTable: used to create a new table widget. An initial size must be given by
// specifying how many rows and columns the table should have, although this can
// be changed later with gtk_table_resize(). rows and columns must both be in
// the range 1 .. 65535. For historical reasons, 0 is accepted as well and is
// silently interpreted as 1.
//
// Deprecated: Use gtk_grid_new().
//
// The function takes the following parameters:
//
//    - rows: number of rows the new table should have.
//    - columns: number of columns the new table should have.
//    - homogeneous: if set to TRUE, all table cells are resized to the size of
//      the cell containing the largest widget.
//
// The function returns the following values:
//
//    - table: pointer to the newly created table widget.
//
func NewTable(rows, columns uint32, homogeneous bool) *Table {
	var _args [3]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[0])) = C.guint(rows)
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(columns)
	if homogeneous {
		*(*C.gboolean)(unsafe.Pointer(&_args[2])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Table")
	_gret := _info.InvokeClassMethod("new_Table", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(rows)
	runtime.KeepAlive(columns)
	runtime.KeepAlive(homogeneous)

	var _table *Table // out

	_table = wrapTable(coreglib.Take(unsafe.Pointer(_cret)))

	return _table
}

// AttachDefaults as there are many options associated with gtk_table_attach(),
// this convenience function provides the programmer with a means to add
// children to a table with identical padding and expansion options. The values
// used for the AttachOptions are GTK_EXPAND | GTK_FILL, and the padding is set
// to 0.
//
// Deprecated: Use gtk_grid_attach() with Grid. Note that the attach arguments
// differ between those two functions.
//
// The function takes the following parameters:
//
//    - widget: child widget to add.
//    - leftAttach: column number to attach the left side of the child widget to.
//    - rightAttach: column number to attach the right side of the child widget
//      to.
//    - topAttach: row number to attach the top of the child widget to.
//    - bottomAttach: row number to attach the bottom of the child widget to.
//
func (table *Table) AttachDefaults(widget Widgetter, leftAttach, rightAttach, topAttach, bottomAttach uint32) {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(leftAttach)
	*(*C.guint)(unsafe.Pointer(&_args[3])) = C.guint(rightAttach)
	*(*C.guint)(unsafe.Pointer(&_args[4])) = C.guint(topAttach)
	*(*C.guint)(unsafe.Pointer(&_args[5])) = C.guint(bottomAttach)

	_info := girepository.MustFind("Gtk", "Table")
	_info.InvokeClassMethod("attach_defaults", _args[:], nil)

	runtime.KeepAlive(table)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(leftAttach)
	runtime.KeepAlive(rightAttach)
	runtime.KeepAlive(topAttach)
	runtime.KeepAlive(bottomAttach)
}

// ColSpacing gets the amount of space between column col, and column col + 1.
// See gtk_table_set_col_spacing().
//
// Deprecated: Grid does not offer a replacement for this functionality.
//
// The function takes the following parameters:
//
//    - column in the table, 0 indicates the first column.
//
// The function returns the following values:
//
//    - guint: column spacing.
//
func (table *Table) ColSpacing(column uint32) uint32 {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(column)

	_info := girepository.MustFind("Gtk", "Table")
	_gret := _info.InvokeClassMethod("get_col_spacing", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(table)
	runtime.KeepAlive(column)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// DefaultColSpacing gets the default column spacing for the table. This is the
// spacing that will be used for newly added columns. (See
// gtk_table_set_col_spacings())
//
// Deprecated: Use gtk_grid_get_column_spacing() with Grid.
//
// The function returns the following values:
//
//    - guint: default column spacing.
//
func (table *Table) DefaultColSpacing() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))

	_info := girepository.MustFind("Gtk", "Table")
	_gret := _info.InvokeClassMethod("get_default_col_spacing", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(table)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// DefaultRowSpacing gets the default row spacing for the table. This is the
// spacing that will be used for newly added rows. (See
// gtk_table_set_row_spacings())
//
// Deprecated: Use gtk_grid_get_row_spacing() with Grid.
//
// The function returns the following values:
//
//    - guint: default row spacing.
//
func (table *Table) DefaultRowSpacing() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))

	_info := girepository.MustFind("Gtk", "Table")
	_gret := _info.InvokeClassMethod("get_default_row_spacing", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(table)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Homogeneous returns whether the table cells are all constrained to the same
// width and height. (See gtk_table_set_homogeneous ())
//
// Deprecated: Use gtk_grid_get_row_homogeneous() and
// gtk_grid_get_column_homogeneous() with Grid.
//
// The function returns the following values:
//
//    - ok: TRUE if the cells are all constrained to the same size.
//
func (table *Table) Homogeneous() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))

	_info := girepository.MustFind("Gtk", "Table")
	_gret := _info.InvokeClassMethod("get_homogeneous", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(table)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// RowSpacing gets the amount of space between row row, and row row + 1. See
// gtk_table_set_row_spacing().
//
// Deprecated: Grid does not offer a replacement for this functionality.
//
// The function takes the following parameters:
//
//    - row in the table, 0 indicates the first row.
//
// The function returns the following values:
//
//    - guint: row spacing.
//
func (table *Table) RowSpacing(row uint32) uint32 {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(row)

	_info := girepository.MustFind("Gtk", "Table")
	_gret := _info.InvokeClassMethod("get_row_spacing", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(table)
	runtime.KeepAlive(row)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Size gets the number of rows and columns in the table.
//
// Deprecated: Grid does not expose the number of columns and rows.
//
// The function returns the following values:
//
//    - rows (optional): return location for the number of rows, or NULL.
//    - columns (optional): return location for the number of columns, or NULL.
//
func (table *Table) Size() (rows, columns uint32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))

	_info := girepository.MustFind("Gtk", "Table")
	_info.InvokeClassMethod("get_size", _args[:], _outs[:])

	runtime.KeepAlive(table)

	var _rows uint32    // out
	var _columns uint32 // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_rows = *(*uint32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_columns = *(*uint32)(unsafe.Pointer(_outs[1]))
	}

	return _rows, _columns
}

// Resize: if you need to change a table’s size after it has been created, this
// function allows you to do so.
//
// Deprecated: Grid resizes automatically.
//
// The function takes the following parameters:
//
//    - rows: new number of rows.
//    - columns: new number of columns.
//
func (table *Table) Resize(rows, columns uint32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(rows)
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(columns)

	_info := girepository.MustFind("Gtk", "Table")
	_info.InvokeClassMethod("resize", _args[:], nil)

	runtime.KeepAlive(table)
	runtime.KeepAlive(rows)
	runtime.KeepAlive(columns)
}

// SetColSpacing alters the amount of space between a given table column and the
// following column.
//
// Deprecated: Use gtk_widget_set_margin_start() and gtk_widget_set_margin_end()
// on the widgets contained in the row if you need this functionality. Grid does
// not support per-row spacing.
//
// The function takes the following parameters:
//
//    - column whose spacing should be changed.
//    - spacing: number of pixels that the spacing should take up.
//
func (table *Table) SetColSpacing(column, spacing uint32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(column)
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(spacing)

	_info := girepository.MustFind("Gtk", "Table")
	_info.InvokeClassMethod("set_col_spacing", _args[:], nil)

	runtime.KeepAlive(table)
	runtime.KeepAlive(column)
	runtime.KeepAlive(spacing)
}

// SetColSpacings sets the space between every column in table equal to spacing.
//
// Deprecated: Use gtk_grid_set_column_spacing() with Grid.
//
// The function takes the following parameters:
//
//    - spacing: number of pixels of space to place between every column in the
//      table.
//
func (table *Table) SetColSpacings(spacing uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(spacing)

	_info := girepository.MustFind("Gtk", "Table")
	_info.InvokeClassMethod("set_col_spacings", _args[:], nil)

	runtime.KeepAlive(table)
	runtime.KeepAlive(spacing)
}

// SetHomogeneous changes the homogenous property of table cells, ie. whether
// all cells are an equal size or not.
//
// Deprecated: Use gtk_grid_set_row_homogeneous() and
// gtk_grid_set_column_homogeneous() with Grid.
//
// The function takes the following parameters:
//
//    - homogeneous: set to TRUE to ensure all table cells are the same size. Set
//      to FALSE if this is not your desired behaviour.
//
func (table *Table) SetHomogeneous(homogeneous bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	if homogeneous {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Table")
	_info.InvokeClassMethod("set_homogeneous", _args[:], nil)

	runtime.KeepAlive(table)
	runtime.KeepAlive(homogeneous)
}

// SetRowSpacing changes the space between a given table row and the subsequent
// row.
//
// Deprecated: Use gtk_widget_set_margin_top() and
// gtk_widget_set_margin_bottom() on the widgets contained in the row if you
// need this functionality. Grid does not support per-row spacing.
//
// The function takes the following parameters:
//
//    - row number whose spacing will be changed.
//    - spacing: number of pixels that the spacing should take up.
//
func (table *Table) SetRowSpacing(row, spacing uint32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(row)
	*(*C.guint)(unsafe.Pointer(&_args[2])) = C.guint(spacing)

	_info := girepository.MustFind("Gtk", "Table")
	_info.InvokeClassMethod("set_row_spacing", _args[:], nil)

	runtime.KeepAlive(table)
	runtime.KeepAlive(row)
	runtime.KeepAlive(spacing)
}

// SetRowSpacings sets the space between every row in table equal to spacing.
//
// Deprecated: Use gtk_grid_set_row_spacing() with Grid.
//
// The function takes the following parameters:
//
//    - spacing: number of pixels of space to place between every row in the
//      table.
//
func (table *Table) SetRowSpacings(spacing uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(spacing)

	_info := girepository.MustFind("Gtk", "Table")
	_info.InvokeClassMethod("set_row_spacings", _args[:], nil)

	runtime.KeepAlive(table)
	runtime.KeepAlive(spacing)
}

// TableChild: instance of this type is always passed by reference.
type TableChild struct {
	*tableChild
}

// tableChild is the struct that's finalized.
type tableChild struct {
	native unsafe.Pointer
}

func (t *TableChild) Widget() Widgetter {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("widget")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v Widgetter // out
	{
		objptr := unsafe.Pointer(*valptr)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		v = rv
	}
	return v
}

func (t *TableChild) LeftAttach() uint16 {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("left_attach")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableChild) RightAttach() uint16 {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("right_attach")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableChild) TopAttach() uint16 {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("top_attach")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableChild) BottomAttach() uint16 {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("bottom_attach")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableChild) Xpadding() uint16 {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("xpadding")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableChild) Ypadding() uint16 {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("ypadding")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableChild) SetLeftAttach(leftAttach uint16) {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("left_attach")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(leftAttach)
}

func (t *TableChild) SetRightAttach(rightAttach uint16) {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("right_attach")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(rightAttach)
}

func (t *TableChild) SetTopAttach(topAttach uint16) {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("top_attach")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(topAttach)
}

func (t *TableChild) SetBottomAttach(bottomAttach uint16) {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("bottom_attach")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(bottomAttach)
}

func (t *TableChild) SetXpadding(xpadding uint16) {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("xpadding")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(xpadding)
}

func (t *TableChild) SetYpadding(ypadding uint16) {
	offset := girepository.MustFind("Gtk", "TableChild").StructFieldOffset("ypadding")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(ypadding)
}

// TableRowCol: instance of this type is always passed by reference.
type TableRowCol struct {
	*tableRowCol
}

// tableRowCol is the struct that's finalized.
type tableRowCol struct {
	native unsafe.Pointer
}

func (t *TableRowCol) Requisition() uint16 {
	offset := girepository.MustFind("Gtk", "TableRowCol").StructFieldOffset("requisition")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableRowCol) Allocation() uint16 {
	offset := girepository.MustFind("Gtk", "TableRowCol").StructFieldOffset("allocation")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableRowCol) Spacing() uint16 {
	offset := girepository.MustFind("Gtk", "TableRowCol").StructFieldOffset("spacing")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	var v uint16 // out
	v = uint16(*(*C.guint16)(unsafe.Pointer(&*valptr)))
	return v
}

func (t *TableRowCol) SetRequisition(requisition uint16) {
	offset := girepository.MustFind("Gtk", "TableRowCol").StructFieldOffset("requisition")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(requisition)
}

func (t *TableRowCol) SetAllocation(allocation uint16) {
	offset := girepository.MustFind("Gtk", "TableRowCol").StructFieldOffset("allocation")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(allocation)
}

func (t *TableRowCol) SetSpacing(spacing uint16) {
	offset := girepository.MustFind("Gtk", "TableRowCol").StructFieldOffset("spacing")
	valptr := (*uintptr)(unsafe.Add(t.native, offset))
	*(*C.guint16)(unsafe.Pointer(&*valptr)) = C.guint16(spacing)
}

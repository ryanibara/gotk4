// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

//export _gotk4_gtk3_Callback
func _gotk4_gtk3_Callback(arg1 *C.GtkWidget, arg2 C.gpointer) {
	var fn Callback
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(Callback)
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	fn(_widget)
}

//export _gotk4_gtk3_Widget_ConnectButtonPressEvent
func _gotk4_gtk3_Widget_ConnectButtonPressEvent(arg0 C.gpointer, arg1 *C.GdkEventButton, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectButtonReleaseEvent
func _gotk4_gtk3_Widget_ConnectButtonReleaseEvent(arg0 C.gpointer, arg1 *C.GdkEventButton, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventButton) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventButton) (ok bool))
	}

	var _event *gdk.EventButton // out

	_event = (*gdk.EventButton)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectCanActivateAccel
func _gotk4_gtk3_Widget_ConnectCanActivateAccel(arg0 C.gpointer, arg1 C.guint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(signalId uint) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(signalId uint) (ok bool))
	}

	var _signalId uint // out

	_signalId = uint(arg1)

	ok := f(_signalId)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectCompositedChanged
func _gotk4_gtk3_Widget_ConnectCompositedChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectConfigureEvent
func _gotk4_gtk3_Widget_ConnectConfigureEvent(arg0 C.gpointer, arg1 *C.GdkEventConfigure, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventConfigure) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventConfigure) (ok bool))
	}

	var _event *gdk.EventConfigure // out

	_event = (*gdk.EventConfigure)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDamageEvent
func _gotk4_gtk3_Widget_ConnectDamageEvent(arg0 C.gpointer, arg1 *C.GdkEventExpose, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventExpose) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventExpose) (ok bool))
	}

	var _event *gdk.EventExpose // out

	_event = (*gdk.EventExpose)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDeleteEvent
func _gotk4_gtk3_Widget_ConnectDeleteEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDestroy
func _gotk4_gtk3_Widget_ConnectDestroy(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectDestroyEvent
func _gotk4_gtk3_Widget_ConnectDestroyEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDirectionChanged
func _gotk4_gtk3_Widget_ConnectDirectionChanged(arg0 C.gpointer, arg1 C.GtkTextDirection, arg2 C.guintptr) {
	var f func(previousDirection TextDirection)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousDirection TextDirection))
	}

	var _previousDirection TextDirection // out

	_previousDirection = TextDirection(arg1)

	f(_previousDirection)
}

//export _gotk4_gtk3_Widget_ConnectDragBegin
func _gotk4_gtk3_Widget_ConnectDragBegin(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

//export _gotk4_gtk3_Widget_ConnectDragDataDelete
func _gotk4_gtk3_Widget_ConnectDragDataDelete(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

//export _gotk4_gtk3_Widget_ConnectDragDataGet
func _gotk4_gtk3_Widget_ConnectDragDataGet(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 *C.GtkSelectionData, arg3 C.guint, arg4 C.guint, arg5 C.guintptr) {
	var f func(context *gdk.DragContext, data *SelectionData, info, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, data *SelectionData, info, time uint))
	}

	var _context *gdk.DragContext // out
	var _data *SelectionData      // out
	var _info uint                // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_info = uint(arg3)
	_time = uint(arg4)

	f(_context, _data, _info, _time)
}

//export _gotk4_gtk3_Widget_ConnectDragDataReceived
func _gotk4_gtk3_Widget_ConnectDragDataReceived(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 *C.GtkSelectionData, arg5 C.guint, arg6 C.guint, arg7 C.guintptr) {
	var f func(context *gdk.DragContext, x, y int, data *SelectionData, info, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg7))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int, data *SelectionData, info, time uint))
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _data *SelectionData      // out
	var _info uint                // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_data = (*SelectionData)(gextras.NewStructNative(unsafe.Pointer(arg4)))
	_info = uint(arg5)
	_time = uint(arg6)

	f(_context, _x, _y, _data, _info, _time)
}

//export _gotk4_gtk3_Widget_ConnectDragDrop
func _gotk4_gtk3_Widget_ConnectDragDrop(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint, arg5 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, x, y int, time uint) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int, time uint) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_time = uint(arg4)

	ok := f(_context, _x, _y, _time)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDragEnd
func _gotk4_gtk3_Widget_ConnectDragEnd(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guintptr) {
	var f func(context *gdk.DragContext)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext))
	}

	var _context *gdk.DragContext // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}

	f(_context)
}

//export _gotk4_gtk3_Widget_ConnectDragFailed
func _gotk4_gtk3_Widget_ConnectDragFailed(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.GtkDragResult, arg3 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, result DragResult) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, result DragResult) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _result DragResult        // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_result = DragResult(arg2)

	ok := f(_context, _result)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDragLeave
func _gotk4_gtk3_Widget_ConnectDragLeave(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.guint, arg3 C.guintptr) {
	var f func(context *gdk.DragContext, time uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, time uint))
	}

	var _context *gdk.DragContext // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_time = uint(arg2)

	f(_context, _time)
}

//export _gotk4_gtk3_Widget_ConnectDragMotion
func _gotk4_gtk3_Widget_ConnectDragMotion(arg0 C.gpointer, arg1 *C.GdkDragContext, arg2 C.gint, arg3 C.gint, arg4 C.guint, arg5 C.guintptr) (cret C.gboolean) {
	var f func(context *gdk.DragContext, x, y int, time uint) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(context *gdk.DragContext, x, y int, time uint) (ok bool))
	}

	var _context *gdk.DragContext // out
	var _x int                    // out
	var _y int                    // out
	var _time uint                // out

	{
		obj := coreglib.Take(unsafe.Pointer(arg1))
		_context = &gdk.DragContext{
			Object: obj,
		}
	}
	_x = int(arg2)
	_y = int(arg3)
	_time = uint(arg4)

	ok := f(_context, _x, _y, _time)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectDraw
func _gotk4_gtk3_Widget_ConnectDraw(arg0 C.gpointer, arg1 *C.cairo_t, arg2 C.guintptr) (cret C.gboolean) {
	var f func(cr *cairo.Context) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(cr *cairo.Context) (ok bool))
	}

	var _cr *cairo.Context // out

	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg1)))
	C.cairo_reference(arg1)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	ok := f(_cr)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectEnterNotifyEvent
func _gotk4_gtk3_Widget_ConnectEnterNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventCrossing, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventCrossing) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventCrossing) (ok bool))
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectEvent
func _gotk4_gtk3_Widget_ConnectEvent(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.Event) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event) (ok bool))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectEventAfter
func _gotk4_gtk3_Widget_ConnectEventAfter(arg0 C.gpointer, arg1 C.GdkEvent, arg2 C.guintptr) {
	var f func(event *gdk.Event)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.Event))
	}

	var _event *gdk.Event // out

	{
		v := (*gdk.Event)(gextras.NewStructNative(unsafe.Pointer((&arg1))))
		v = gdk.CopyEventer(v)
		_event = v
	}

	f(_event)
}

//export _gotk4_gtk3_Widget_ConnectFocusInEvent
func _gotk4_gtk3_Widget_ConnectFocusInEvent(arg0 C.gpointer, arg1 *C.GdkEventFocus, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventFocus) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventFocus) (ok bool))
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectFocusOutEvent
func _gotk4_gtk3_Widget_ConnectFocusOutEvent(arg0 C.gpointer, arg1 *C.GdkEventFocus, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventFocus) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventFocus) (ok bool))
	}

	var _event *gdk.EventFocus // out

	_event = (*gdk.EventFocus)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectGrabBrokenEvent
func _gotk4_gtk3_Widget_ConnectGrabBrokenEvent(arg0 C.gpointer, arg1 *C.GdkEventGrabBroken, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventGrabBroken) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventGrabBroken) (ok bool))
	}

	var _event *gdk.EventGrabBroken // out

	_event = (*gdk.EventGrabBroken)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectGrabNotify
func _gotk4_gtk3_Widget_ConnectGrabNotify(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(wasGrabbed bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(wasGrabbed bool))
	}

	var _wasGrabbed bool // out

	if arg1 != 0 {
		_wasGrabbed = true
	}

	f(_wasGrabbed)
}

//export _gotk4_gtk3_Widget_ConnectHide
func _gotk4_gtk3_Widget_ConnectHide(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectHierarchyChanged
func _gotk4_gtk3_Widget_ConnectHierarchyChanged(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(previousToplevel Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousToplevel Widgetter))
	}

	var _previousToplevel Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_previousToplevel = rv
		}
	}

	f(_previousToplevel)
}

//export _gotk4_gtk3_Widget_ConnectKeyPressEvent
func _gotk4_gtk3_Widget_ConnectKeyPressEvent(arg0 C.gpointer, arg1 *C.GdkEventKey, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventKey) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventKey) (ok bool))
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectKeyReleaseEvent
func _gotk4_gtk3_Widget_ConnectKeyReleaseEvent(arg0 C.gpointer, arg1 *C.GdkEventKey, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventKey) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventKey) (ok bool))
	}

	var _event *gdk.EventKey // out

	_event = (*gdk.EventKey)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectKeynavFailed
func _gotk4_gtk3_Widget_ConnectKeynavFailed(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) (cret C.gboolean) {
	var f func(direction DirectionType) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(direction DirectionType) (ok bool))
	}

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	ok := f(_direction)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent
func _gotk4_gtk3_Widget_ConnectLeaveNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventCrossing, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventCrossing) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventCrossing) (ok bool))
	}

	var _event *gdk.EventCrossing // out

	_event = (*gdk.EventCrossing)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectMap
func _gotk4_gtk3_Widget_ConnectMap(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectMapEvent
func _gotk4_gtk3_Widget_ConnectMapEvent(arg0 C.gpointer, arg1 *C.GdkEventAny, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventAny) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventAny) (ok bool))
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectMnemonicActivate
func _gotk4_gtk3_Widget_ConnectMnemonicActivate(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(groupCycling bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(groupCycling bool) (ok bool))
	}

	var _groupCycling bool // out

	if arg1 != 0 {
		_groupCycling = true
	}

	ok := f(_groupCycling)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectMotionNotifyEvent
func _gotk4_gtk3_Widget_ConnectMotionNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventMotion, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventMotion) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventMotion) (ok bool))
	}

	var _event *gdk.EventMotion // out

	_event = (*gdk.EventMotion)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectParentSet
func _gotk4_gtk3_Widget_ConnectParentSet(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(oldParent Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(oldParent Widgetter))
	}

	var _oldParent Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_oldParent = rv
		}
	}

	f(_oldParent)
}

//export _gotk4_gtk3_Widget_ConnectPopupMenu
func _gotk4_gtk3_Widget_ConnectPopupMenu(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent
func _gotk4_gtk3_Widget_ConnectPropertyNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventProperty, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProperty) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProperty) (ok bool))
	}

	var _event *gdk.EventProperty // out

	_event = (*gdk.EventProperty)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectProximityInEvent
func _gotk4_gtk3_Widget_ConnectProximityInEvent(arg0 C.gpointer, arg1 *C.GdkEventProximity, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProximity) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProximity) (ok bool))
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectProximityOutEvent
func _gotk4_gtk3_Widget_ConnectProximityOutEvent(arg0 C.gpointer, arg1 *C.GdkEventProximity, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventProximity) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventProximity) (ok bool))
	}

	var _event *gdk.EventProximity // out

	_event = (*gdk.EventProximity)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectQueryTooltip
func _gotk4_gtk3_Widget_ConnectQueryTooltip(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.gboolean, arg4 *C.GtkTooltip, arg5 C.guintptr) (cret C.gboolean) {
	var f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool))
	}

	var _x int             // out
	var _y int             // out
	var _keyboardMode bool // out
	var _tooltip *Tooltip  // out

	_x = int(arg1)
	_y = int(arg2)
	if arg3 != 0 {
		_keyboardMode = true
	}
	_tooltip = wrapTooltip(coreglib.Take(unsafe.Pointer(arg4)))

	ok := f(_x, _y, _keyboardMode, _tooltip)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectRealize
func _gotk4_gtk3_Widget_ConnectRealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectScreenChanged
func _gotk4_gtk3_Widget_ConnectScreenChanged(arg0 C.gpointer, arg1 *C.GdkScreen, arg2 C.guintptr) {
	var f func(previousScreen *gdk.Screen)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousScreen *gdk.Screen))
	}

	var _previousScreen *gdk.Screen // out

	if arg1 != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(arg1))
			_previousScreen = &gdk.Screen{
				Object: obj,
			}
		}
	}

	f(_previousScreen)
}

//export _gotk4_gtk3_Widget_ConnectScrollEvent
func _gotk4_gtk3_Widget_ConnectScrollEvent(arg0 C.gpointer, arg1 *C.GdkEventScroll, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventScroll) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventScroll) (ok bool))
	}

	var _event *gdk.EventScroll // out

	_event = (*gdk.EventScroll)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectSelectionClearEvent
func _gotk4_gtk3_Widget_ConnectSelectionClearEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectSelectionRequestEvent
func _gotk4_gtk3_Widget_ConnectSelectionRequestEvent(arg0 C.gpointer, arg1 *C.GdkEventSelection, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventSelection) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventSelection) (ok bool))
	}

	var _event *gdk.EventSelection // out

	_event = (*gdk.EventSelection)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectShow
func _gotk4_gtk3_Widget_ConnectShow(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectStateChanged
func _gotk4_gtk3_Widget_ConnectStateChanged(arg0 C.gpointer, arg1 C.GtkStateType, arg2 C.guintptr) {
	var f func(state StateType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(state StateType))
	}

	var _state StateType // out

	_state = StateType(arg1)

	f(_state)
}

//export _gotk4_gtk3_Widget_ConnectStateFlagsChanged
func _gotk4_gtk3_Widget_ConnectStateFlagsChanged(arg0 C.gpointer, arg1 C.GtkStateFlags, arg2 C.guintptr) {
	var f func(flags StateFlags)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(flags StateFlags))
	}

	var _flags StateFlags // out

	_flags = StateFlags(arg1)

	f(_flags)
}

//export _gotk4_gtk3_Widget_ConnectStyleSet
func _gotk4_gtk3_Widget_ConnectStyleSet(arg0 C.gpointer, arg1 *C.GtkStyle, arg2 C.guintptr) {
	var f func(previousStyle *Style)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(previousStyle *Style))
	}

	var _previousStyle *Style // out

	if arg1 != nil {
		_previousStyle = wrapStyle(coreglib.Take(unsafe.Pointer(arg1)))
	}

	f(_previousStyle)
}

//export _gotk4_gtk3_Widget_ConnectStyleUpdated
func _gotk4_gtk3_Widget_ConnectStyleUpdated(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectUnmap
func _gotk4_gtk3_Widget_ConnectUnmap(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectUnmapEvent
func _gotk4_gtk3_Widget_ConnectUnmapEvent(arg0 C.gpointer, arg1 *C.GdkEventAny, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventAny) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventAny) (ok bool))
	}

	var _event *gdk.EventAny // out

	_event = (*gdk.EventAny)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectUnrealize
func _gotk4_gtk3_Widget_ConnectUnrealize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

//export _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent
func _gotk4_gtk3_Widget_ConnectVisibilityNotifyEvent(arg0 C.gpointer, arg1 *C.GdkEventVisibility, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventVisibility) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventVisibility) (ok bool))
	}

	var _event *gdk.EventVisibility // out

	_event = (*gdk.EventVisibility)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_Widget_ConnectWindowStateEvent
func _gotk4_gtk3_Widget_ConnectWindowStateEvent(arg0 C.gpointer, arg1 *C.GdkEventWindowState, arg2 C.guintptr) (cret C.gboolean) {
	var f func(event *gdk.EventWindowState) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(event *gdk.EventWindowState) (ok bool))
	}

	var _event *gdk.EventWindowState // out

	_event = (*gdk.EventWindowState)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := f(_event)

	if ok {
		cret = C.TRUE
	}

	return cret
}

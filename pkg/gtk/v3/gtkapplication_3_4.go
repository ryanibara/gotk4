// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// GType values.
var (
	GTypeApplicationInhibitFlags = coreglib.Type(C.gtk_application_inhibit_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeApplicationInhibitFlags, F: marshalApplicationInhibitFlags},
	})
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// gtk_application_inhibit().
type ApplicationInhibitFlags C.guint

const (
	// ApplicationInhibitLogout: inhibit ending the user session by logging out
	// or by shutting down the computer.
	ApplicationInhibitLogout ApplicationInhibitFlags = 0b1
	// ApplicationInhibitSwitch: inhibit user switching.
	ApplicationInhibitSwitch ApplicationInhibitFlags = 0b10
	// ApplicationInhibitSuspend: inhibit suspending the session or computer.
	ApplicationInhibitSuspend ApplicationInhibitFlags = 0b100
	// ApplicationInhibitIdle: inhibit the session being marked as idle (and
	// possibly locked).
	ApplicationInhibitIdle ApplicationInhibitFlags = 0b1000
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ApplicationInhibitFlags.
func (a ApplicationInhibitFlags) String() string {
	if a == 0 {
		return "ApplicationInhibitFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(98)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case ApplicationInhibitLogout:
			builder.WriteString("Logout|")
		case ApplicationInhibitSwitch:
			builder.WriteString("Switch|")
		case ApplicationInhibitSuspend:
			builder.WriteString("Suspend|")
		case ApplicationInhibitIdle:
			builder.WriteString("Idle|")
		default:
			builder.WriteString(fmt.Sprintf("ApplicationInhibitFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a ApplicationInhibitFlags) Has(other ApplicationInhibitFlags) bool {
	return (a & other) == other
}

// AddAccelerator installs an accelerator that will cause the named action to be
// activated when the key combination specificed by accelerator is pressed.
//
// accelerator must be a string that can be parsed by gtk_accelerator_parse(),
// e.g. "<Primary>q" or “<Control><Alt>p”.
//
// action_name must be the name of an action as it would be used in the app
// menu, i.e. actions that have been added to the application are referred to
// with an “app.” prefix, and window-specific actions with a “win.” prefix.
//
// GtkApplication also extracts accelerators out of “accel” attributes in the
// Models passed to gtk_application_set_app_menu() and
// gtk_application_set_menubar(), which is usually more convenient than calling
// this function for each accelerator.
//
// Deprecated: Use gtk_application_set_accels_for_action() instead.
//
// The function takes the following parameters:
//
//    - accelerator string.
//    - actionName: name of the action to activate.
//    - parameter (optional) to pass when activating the action, or NULL if the
//      action does not accept an activation parameter.
//
func (application *Application) AddAccelerator(accelerator, actionName string, parameter *glib.Variant) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.gchar          // out
	var _arg3 *C.GVariant       // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg2))
	if parameter != nil {
		_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}

	C.gtk_application_add_accelerator(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(accelerator)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(parameter)
}

// AppMenu returns the menu model that has been set with
// gtk_application_set_app_menu().
//
// The function returns the following values:
//
//    - menuModel (optional): application menu of application or NULL if no
//      application menu has been set.
//
func (application *Application) AppMenu() gio.MenuModeller {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_get_app_menu(_arg0)
	runtime.KeepAlive(application)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// Menubar returns the menu model that has been set with
// gtk_application_set_menubar().
//
// The function returns the following values:
//
//    - menuModel: menubar for windows of application.
//
func (application *Application) Menubar() gio.MenuModeller {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_get_menubar(_arg0)
	runtime.KeepAlive(application)

	var _menuModel gio.MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.MenuModeller)
			return ok
		})
		rv, ok := casted.(gio.MenuModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// Inhibit: inform the session manager that certain types of actions should be
// inhibited. This is not guaranteed to work on all platforms and for all types
// of actions.
//
// Applications should invoke this method when they begin an operation that
// should not be interrupted, such as creating a CD or DVD. The types of actions
// that may be blocked are specified by the flags parameter. When the
// application completes the operation it should call
// gtk_application_uninhibit() to remove the inhibitor. Note that an application
// can have multiple inhibitors, and all of them must be individually removed.
// Inhibitors are also cleared when the application exits.
//
// Applications should not expect that they will always be able to block the
// action. In most cases, users will be given the option to force the action to
// take place.
//
// Reasons should be short and to the point.
//
// If window is given, the session manager may point the user to this window to
// find out more about why the action is inhibited.
//
// The function takes the following parameters:
//
//    - window (optional) or NULL.
//    - flags: what types of actions should be inhibited.
//    - reason (optional): short, human-readable string that explains why these
//      operations are inhibited.
//
// The function returns the following values:
//
//    - guint: non-zero cookie that is used to uniquely identify this request. It
//      should be used as an argument to gtk_application_uninhibit() in order to
//      remove the request. If the platform does not support inhibiting or the
//      request failed for some reason, 0 is returned.
//
func (application *Application) Inhibit(window *Window, flags ApplicationInhibitFlags, reason string) uint {
	var _arg0 *C.GtkApplication            // out
	var _arg1 *C.GtkWindow                 // out
	var _arg2 C.GtkApplicationInhibitFlags // out
	var _arg3 *C.gchar                     // out
	var _cret C.guint                      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if window != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	}
	_arg2 = C.GtkApplicationInhibitFlags(flags)
	if reason != "" {
		_arg3 = (*C.gchar)(unsafe.Pointer(C.CString(reason)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gtk_application_inhibit(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(reason)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsInhibited determines if any of the actions specified in flags are currently
// inhibited (possibly by another application).
//
// Note that this information may not be available (for example when the
// application is running in a sandbox).
//
// The function takes the following parameters:
//
//    - flags: what types of actions should be queried.
//
// The function returns the following values:
//
//    - ok: TRUE if any of the actions specified in flags are inhibited.
//
func (application *Application) IsInhibited(flags ApplicationInhibitFlags) bool {
	var _arg0 *C.GtkApplication            // out
	var _arg1 C.GtkApplicationInhibitFlags // out
	var _cret C.gboolean                   // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.GtkApplicationInhibitFlags(flags)

	_cret = C.gtk_application_is_inhibited(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAccelerator removes an accelerator that has been previously added with
// gtk_application_add_accelerator().
//
// Deprecated: Use gtk_application_set_accels_for_action() instead.
//
// The function takes the following parameters:
//
//    - actionName: name of the action to activate.
//    - parameter (optional) to pass when activating the action, or NULL if the
//      action does not accept an activation parameter.
//
func (application *Application) RemoveAccelerator(actionName string, parameter *glib.Variant) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.gchar          // out
	var _arg2 *C.GVariant       // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if parameter != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(parameter)))
	}

	C.gtk_application_remove_accelerator(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(parameter)
}

// SetAppMenu sets or unsets the application menu for application.
//
// This can only be done in the primary instance of the application, after it
// has been registered. #GApplication::startup is a good place to call this.
//
// The application menu is a single menu containing items that typically impact
// the application as a whole, rather than acting on a specific window or
// document. For example, you would expect to see “Preferences” or “Quit” in an
// application menu, but not “Save” or “Print”.
//
// If supported, the application menu will be rendered by the desktop
// environment.
//
// Use the base Map interface to add actions, to respond to the user selecting
// these menu items.
//
// The function takes the following parameters:
//
//    - appMenu (optional) or NULL.
//
func (application *Application) SetAppMenu(appMenu gio.MenuModeller) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if appMenu != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(appMenu).Native()))
	}

	C.gtk_application_set_app_menu(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(appMenu)
}

// SetMenubar sets or unsets the menubar for windows of application.
//
// This is a menubar in the traditional sense.
//
// This can only be done in the primary instance of the application, after it
// has been registered. #GApplication::startup is a good place to call this.
//
// Depending on the desktop environment, this may appear at the top of each
// window, or at the top of the screen. In some environments, if both the
// application menu and the menubar are set, the application menu will be
// presented as if it were the first item of the menubar. Other environments
// treat the two as completely separate — for example, the application menu may
// be rendered by the desktop shell while the menubar (if set) remains in each
// individual window.
//
// Use the base Map interface to add actions, to respond to the user selecting
// these menu items.
//
// The function takes the following parameters:
//
//    - menubar (optional) or NULL.
//
func (application *Application) SetMenubar(menubar gio.MenuModeller) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if menubar != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(menubar).Native()))
	}

	C.gtk_application_set_menubar(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(menubar)
}

// Uninhibit removes an inhibitor that has been established with
// gtk_application_inhibit(). Inhibitors are also cleared when the application
// exits.
//
// The function takes the following parameters:
//
//    - cookie that was returned by gtk_application_inhibit().
//
func (application *Application) Uninhibit(cookie uint) {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.guint(cookie)

	C.gtk_application_uninhibit(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(cookie)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gtk3_EntryClass_activate(void*);
// extern void _gotk4_gtk3_EntryClass_backspace(void*);
// extern void _gotk4_gtk3_EntryClass_copy_clipboard(void*);
// extern void _gotk4_gtk3_EntryClass_cut_clipboard(void*);
// extern void _gotk4_gtk3_EntryClass_get_frame_size(void*, void*, void*, void*, void*);
// extern void _gotk4_gtk3_EntryClass_get_text_area_size(void*, void*, void*, void*, void*);
// extern void _gotk4_gtk3_EntryClass_insert_at_cursor(void*, void*);
// extern void _gotk4_gtk3_EntryClass_insert_emoji(void*);
// extern void _gotk4_gtk3_EntryClass_paste_clipboard(void*);
// extern void _gotk4_gtk3_EntryClass_populate_popup(void*, void*);
// extern void _gotk4_gtk3_EntryClass_toggle_overwrite(void*);
// extern void _gotk4_gtk3_Entry_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectInsertAtCursor(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPopulatePopup(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPreeditChanged(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectToggleOverwrite(gpointer, guintptr);
import "C"

// glib.Type values for gtkentry.go.
var (
	GTypeEntryIconPosition = coreglib.Type(C.gtk_entry_icon_position_get_type())
	GTypeEntry             = coreglib.Type(C.gtk_entry_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeEntryIconPosition, F: marshalEntryIconPosition},
		{T: GTypeEntry, F: marshalEntry},
	})
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition C.gint

const (
	// EntryIconPrimary: at the beginning of the entry (depending on the text
	// direction).
	EntryIconPrimary EntryIconPosition = iota
	// EntryIconSecondary: at the end of the entry (depending on the text
	// direction).
	EntryIconSecondary
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EntryIconPosition.
func (e EntryIconPosition) String() string {
	switch e {
	case EntryIconPrimary:
		return "Primary"
	case EntryIconSecondary:
		return "Secondary"
	default:
		return fmt.Sprintf("EntryIconPosition(%d)", e)
	}
}

// EntryOverrider contains methods that are overridable.
type EntryOverrider interface {
	Activate()
	Backspace()
	CopyClipboard()
	CutClipboard()
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - width
	//    - height
	//
	FrameSize(x, y, width, height *int32)
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - width
	//    - height
	//
	TextAreaSize(x, y, width, height *int32)
	// The function takes the following parameters:
	//
	InsertAtCursor(str string)
	InsertEmoji()
	PasteClipboard()
	// The function takes the following parameters:
	//
	PopulatePopup(popup Widgetter)
	ToggleOverwrite()
}

// Entry widget is a single line text entry widget. A fairly large set of key
// bindings are supported by default. If the entered text is longer than the
// allocation of the widget, the widget will scroll so that the cursor position
// is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_entry_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK+
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_entry_set_invisible_char(). Since 2.16, GTK+
// displays a warning when Caps Lock or input methods might interfere with
// entering text in a password entry. The warning can be turned off with the
// Entry:caps-lock-warning property.
//
// Since 2.16, GtkEntry has the ability to display progress or activity
// information behind the text. To make an entry display such information, use
// gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
//
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or one of
// the various other functions that set an icon from a stock id, an icon name or
// a pixbuf. To trigger an action when the user clicks an icon, connect to the
// Entry::icon-press signal. To allow DND operations from an icon, use
// gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use
// gtk_entry_set_icon_tooltip_text() or the corresponding function for markup.
//
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
//
// CSS nodes
//
//    entry[.read-only][.flat][.warning][.error]
//    ├── image.left
//    ├── image.right
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [progress[.pulse]]
//    ╰── [window.popup]
//
// GtkEntry has a main node with the name entry. Depending on the properties of
// the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
//
// The CSS node for a context menu is added as a subnode below entry as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
type Entry struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	CellEditable
	Editable
}

var (
	_ Widgetter         = (*Entry)(nil)
	_ coreglib.Objector = (*Entry)(nil)
)

func classInitEntrier(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkEntryClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkEntryClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ Activate() }); ok {
		pclass.activate = (*[0]byte)(C._gotk4_gtk3_EntryClass_activate)
	}

	if _, ok := goval.(interface{ Backspace() }); ok {
		pclass.backspace = (*[0]byte)(C._gotk4_gtk3_EntryClass_backspace)
	}

	if _, ok := goval.(interface{ CopyClipboard() }); ok {
		pclass.copy_clipboard = (*[0]byte)(C._gotk4_gtk3_EntryClass_copy_clipboard)
	}

	if _, ok := goval.(interface{ CutClipboard() }); ok {
		pclass.cut_clipboard = (*[0]byte)(C._gotk4_gtk3_EntryClass_cut_clipboard)
	}

	if _, ok := goval.(interface {
		FrameSize(x, y, width, height *int32)
	}); ok {
		pclass.get_frame_size = (*[0]byte)(C._gotk4_gtk3_EntryClass_get_frame_size)
	}

	if _, ok := goval.(interface {
		TextAreaSize(x, y, width, height *int32)
	}); ok {
		pclass.get_text_area_size = (*[0]byte)(C._gotk4_gtk3_EntryClass_get_text_area_size)
	}

	if _, ok := goval.(interface{ InsertAtCursor(str string) }); ok {
		pclass.insert_at_cursor = (*[0]byte)(C._gotk4_gtk3_EntryClass_insert_at_cursor)
	}

	if _, ok := goval.(interface{ InsertEmoji() }); ok {
		pclass.insert_emoji = (*[0]byte)(C._gotk4_gtk3_EntryClass_insert_emoji)
	}

	if _, ok := goval.(interface{ PasteClipboard() }); ok {
		pclass.paste_clipboard = (*[0]byte)(C._gotk4_gtk3_EntryClass_paste_clipboard)
	}

	if _, ok := goval.(interface{ PopulatePopup(popup Widgetter) }); ok {
		pclass.populate_popup = (*[0]byte)(C._gotk4_gtk3_EntryClass_populate_popup)
	}

	if _, ok := goval.(interface{ ToggleOverwrite() }); ok {
		pclass.toggle_overwrite = (*[0]byte)(C._gotk4_gtk3_EntryClass_toggle_overwrite)
	}
}

//export _gotk4_gtk3_EntryClass_activate
func _gotk4_gtk3_EntryClass_activate(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Activate() })

	iface.Activate()
}

//export _gotk4_gtk3_EntryClass_backspace
func _gotk4_gtk3_EntryClass_backspace(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Backspace() })

	iface.Backspace()
}

//export _gotk4_gtk3_EntryClass_copy_clipboard
func _gotk4_gtk3_EntryClass_copy_clipboard(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CopyClipboard() })

	iface.CopyClipboard()
}

//export _gotk4_gtk3_EntryClass_cut_clipboard
func _gotk4_gtk3_EntryClass_cut_clipboard(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CutClipboard() })

	iface.CutClipboard()
}

//export _gotk4_gtk3_EntryClass_get_frame_size
func _gotk4_gtk3_EntryClass_get_frame_size(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		FrameSize(x, y, width, height *int32)
	})

	var _x *int32      // out
	var _y *int32      // out
	var _width *int32  // out
	var _height *int32 // out

	_x = (*int32)(unsafe.Pointer(arg1))
	_y = (*int32)(unsafe.Pointer(arg2))
	_width = (*int32)(unsafe.Pointer(arg3))
	_height = (*int32)(unsafe.Pointer(arg4))

	iface.FrameSize(_x, _y, _width, _height)
}

//export _gotk4_gtk3_EntryClass_get_text_area_size
func _gotk4_gtk3_EntryClass_get_text_area_size(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		TextAreaSize(x, y, width, height *int32)
	})

	var _x *int32      // out
	var _y *int32      // out
	var _width *int32  // out
	var _height *int32 // out

	_x = (*int32)(unsafe.Pointer(arg1))
	_y = (*int32)(unsafe.Pointer(arg2))
	_width = (*int32)(unsafe.Pointer(arg3))
	_height = (*int32)(unsafe.Pointer(arg4))

	iface.TextAreaSize(_x, _y, _width, _height)
}

//export _gotk4_gtk3_EntryClass_insert_at_cursor
func _gotk4_gtk3_EntryClass_insert_at_cursor(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ InsertAtCursor(str string) })

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	iface.InsertAtCursor(_str)
}

//export _gotk4_gtk3_EntryClass_insert_emoji
func _gotk4_gtk3_EntryClass_insert_emoji(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ InsertEmoji() })

	iface.InsertEmoji()
}

//export _gotk4_gtk3_EntryClass_paste_clipboard
func _gotk4_gtk3_EntryClass_paste_clipboard(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ PasteClipboard() })

	iface.PasteClipboard()
}

//export _gotk4_gtk3_EntryClass_populate_popup
func _gotk4_gtk3_EntryClass_populate_popup(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ PopulatePopup(popup Widgetter) })

	var _popup Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_popup = rv
	}

	iface.PopulatePopup(_popup)
}

//export _gotk4_gtk3_EntryClass_toggle_overwrite
func _gotk4_gtk3_EntryClass_toggle_overwrite(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ToggleOverwrite() })

	iface.ToggleOverwrite()
}

func wrapEntry(obj *coreglib.Object) *Entry {
	return &Entry{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
		Object: obj,
		CellEditable: CellEditable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Editable: Editable{
			Object: obj,
		},
	}
}

func marshalEntry(p uintptr) (interface{}, error) {
	return wrapEntry(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_Entry_ConnectActivate
func _gotk4_gtk3_Entry_ConnectActivate(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectActivate signal is emitted when the user hits the Enter key.
//
// While this signal is used as a [keybinding signal][GtkBindingSignal], it is
// also commonly used by applications to intercept activation of entries.
//
// The default bindings for this signal are all forms of the Enter key.
func (entry *Entry) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "activate", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectActivate), f)
}

//export _gotk4_gtk3_Entry_ConnectBackspace
func _gotk4_gtk3_Entry_ConnectBackspace(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectBackspace signal is a [keybinding signal][GtkBindingSignal] which gets
// emitted when the user asks for it.
//
// The default bindings for this signal are Backspace and Shift-Backspace.
func (entry *Entry) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "backspace", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectBackspace), f)
}

//export _gotk4_gtk3_Entry_ConnectCopyClipboard
func _gotk4_gtk3_Entry_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCopyClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to copy the selection to the clipboard.
//
// The default bindings for this signal are Ctrl-c and Ctrl-Insert.
func (entry *Entry) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectCopyClipboard), f)
}

//export _gotk4_gtk3_Entry_ConnectCutClipboard
func _gotk4_gtk3_Entry_ConnectCutClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCutClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to cut the selection to the clipboard.
//
// The default bindings for this signal are Ctrl-x and Shift-Delete.
func (entry *Entry) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectCutClipboard), f)
}

//export _gotk4_gtk3_Entry_ConnectInsertAtCursor
func _gotk4_gtk3_Entry_ConnectInsertAtCursor(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(str string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(str string))
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_str)
}

// ConnectInsertAtCursor signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user initiates the insertion of a fixed string at the
// cursor.
//
// This signal has no default bindings.
func (entry *Entry) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectInsertAtCursor), f)
}

//export _gotk4_gtk3_Entry_ConnectInsertEmoji
func _gotk4_gtk3_Entry_ConnectInsertEmoji(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectInsertEmoji signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to present the Emoji chooser for the entry.
//
// The default bindings for this signal are Ctrl-. and Ctrl-;.
func (entry *Entry) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectInsertEmoji), f)
}

//export _gotk4_gtk3_Entry_ConnectPasteClipboard
func _gotk4_gtk3_Entry_ConnectPasteClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectPasteClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to paste the contents of the clipboard into the text view.
//
// The default bindings for this signal are Ctrl-v and Shift-Insert.
func (entry *Entry) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPasteClipboard), f)
}

//export _gotk4_gtk3_Entry_ConnectPopulatePopup
func _gotk4_gtk3_Entry_ConnectPopulatePopup(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(widget Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(widget Widgetter))
	}

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	f(_widget)
}

// ConnectPopulatePopup signal gets emitted before showing the context menu of
// the entry.
//
// If you need to add items to the context menu, connect to this signal and
// append your items to the widget, which will be a Menu in this case.
//
// If Entry:populate-all is TRUE, this signal will also be emitted to populate
// touch popups. In this case, widget will be a different container, e.g. a
// Toolbar. The signal handler should not make assumptions about the type of
// widget.
func (entry *Entry) ConnectPopulatePopup(f func(widget Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "populate-popup", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPopulatePopup), f)
}

//export _gotk4_gtk3_Entry_ConnectPreeditChanged
func _gotk4_gtk3_Entry_ConnectPreeditChanged(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(preedit string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(preedit string))
	}

	var _preedit string // out

	_preedit = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_preedit)
}

// ConnectPreeditChanged: if an input method is used, the typed text will not
// immediately be committed to the buffer. So if you are interested in the text,
// connect to this signal.
func (entry *Entry) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPreeditChanged), f)
}

//export _gotk4_gtk3_Entry_ConnectToggleOverwrite
func _gotk4_gtk3_Entry_ConnectToggleOverwrite(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectToggleOverwrite signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted to toggle the overwrite mode of the entry.
//
// The default bindings for this signal is Insert.
func (entry *Entry) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectToggleOverwrite), f)
}

// NewEntry creates a new entry.
//
// The function returns the following values:
//
//    - entry: new Entry.
//
func NewEntry() *Entry {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("new_Entry", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _entry *Entry // out

	_entry = wrapEntry(coreglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// NewEntryWithBuffer creates a new entry with the specified text buffer.
//
// The function takes the following parameters:
//
//    - buffer to use for the new Entry.
//
// The function returns the following values:
//
//    - entry: new Entry.
//
func NewEntryWithBuffer(buffer *EntryBuffer) *Entry {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("new_Entry_with_buffer", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _entry *Entry // out

	_entry = wrapEntry(coreglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// ActivatesDefault retrieves the value set by
// gtk_entry_set_activates_default().
//
// The function returns the following values:
//
//    - ok: TRUE if the entry will activate the default widget.
//
func (entry *Entry) ActivatesDefault() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_activates_default", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Alignment gets the value set by gtk_entry_set_alignment().
//
// The function returns the following values:
//
//    - gfloat: alignment.
//
func (entry *Entry) Alignment() float32 {
	var _args [1]girepository.Argument
	var _arg0 *C.void  // out
	var _cret C.gfloat // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_alignment", _args[:], nil)
	_cret = *(*C.gfloat)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Attributes gets the attribute list that was set on the entry using
// gtk_entry_set_attributes(), if any.
//
// The function returns the following values:
//
//    - attrList (optional): attribute list, or NULL if none was set.
//
func (entry *Entry) Attributes() *pango.AttrList {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_attributes", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _attrList *pango.AttrList // out

	if _cret != nil {
		_attrList = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// Buffer: get the EntryBuffer object which holds the text for this widget.
//
// The function returns the following values:
//
//    - entryBuffer: EntryBuffer object.
//
func (entry *Entry) Buffer() *EntryBuffer {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_buffer", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _entryBuffer *EntryBuffer // out

	_entryBuffer = wrapEntryBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _entryBuffer
}

// Completion returns the auxiliary completion object currently in use by entry.
//
// The function returns the following values:
//
//    - entryCompletion: auxiliary completion object currently in use by entry.
//
func (entry *Entry) Completion() *EntryCompletion {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_completion", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _entryCompletion *EntryCompletion // out

	_entryCompletion = wrapEntryCompletion(coreglib.Take(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// CurrentIconDragSource returns the index of the icon which is the source of
// the current DND operation, or -1.
//
// This function is meant to be used in a Widget::drag-data-get callback.
//
// The function returns the following values:
//
//    - gint: index of the icon which is the source of the current DND operation,
//      or -1.
//
func (entry *Entry) CurrentIconDragSource() int32 {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_current_icon_drag_source", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// CursorHAdjustment retrieves the horizontal cursor adjustment for the entry.
// See gtk_entry_set_cursor_hadjustment().
//
// The function returns the following values:
//
//    - adjustment (optional): horizontal cursor adjustment, or NULL if none has
//      been set.
//
func (entry *Entry) CursorHAdjustment() *Adjustment {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_cursor_hadjustment", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _adjustment *Adjustment // out

	if _cret != nil {
		_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _adjustment
}

// HasFrame gets the value set by gtk_entry_set_has_frame().
//
// The function returns the following values:
//
//    - ok: whether the entry has a beveled frame.
//
func (entry *Entry) HasFrame() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_has_frame", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconAtPos finds the icon at the given position and return its index. The
// position’s coordinates are relative to the entry’s top left corner. If x, y
// doesn’t lie inside an icon, -1 is returned. This function is intended for use
// in a Widget::query-tooltip signal handler.
//
// The function takes the following parameters:
//
//    - x coordinate of the position to find.
//    - y coordinate of the position to find.
//
// The function returns the following values:
//
//    - gint: index of the icon at the given position, or -1.
//
func (entry *Entry) IconAtPos(x, y int32) int32 {
	var _args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(x)
	_arg2 = C.gint(y)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gint)(unsafe.Pointer(&_args[1])) = _arg1
	*(*C.gint)(unsafe.Pointer(&_args[2])) = _arg2

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_icon_at_pos", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// InnerBorder: this function returns the entry’s Entry:inner-border property.
// See gtk_entry_set_inner_border() for more information.
//
// Deprecated: Use the standard border and padding CSS properties (through
// objects like StyleContext and CssProvider); the value returned by this
// function is ignored by Entry.
//
// The function returns the following values:
//
//    - border (optional) entry’s Border, or NULL if none was set.
//
func (entry *Entry) InnerBorder() *Border {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_inner_border", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _border *Border // out

	if _cret != nil {
		_border = (*Border)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _border
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false. See
// gtk_entry_set_invisible_char().
//
// The function returns the following values:
//
//    - gunichar: current invisible char, or 0, if the entry does not show
//      invisible text at all.
//
func (entry *Entry) InvisibleChar() uint32 {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gunichar // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_invisible_char", _args[:], nil)
	_cret = *(*C.gunichar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// Layout gets the Layout used to display the entry. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_entry_get_layout_offsets(). The returned layout is owned by the entry and
// must not be modified or freed by the caller.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices in
// the layout to byte indices in the entry contents.
//
// The function returns the following values:
//
//    - layout for this entry.
//
func (entry *Entry) Layout() *pango.Layout {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_layout", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _layout *pango.Layout // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// LayoutOffsets obtains the position of the Layout used to render text in the
// entry, in widget coordinates. Useful if you want to line up the text in an
// entry with some other text, e.g. when using the entry to implement editable
// cells in a sheet widget.
//
// Also useful to convert mouse events into coordinates inside the Layout, e.g.
// to take some action if some part of the entry text is clicked.
//
// Note that as the user scrolls around in the entry the offsets will change;
// you’ll need to connect to the “notify::scroll-offset” signal to track this.
// Remember when using the Layout functions you need to convert to and from
// pixels using PANGO_PIXELS() or NGO_SCALE.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices in
// the layout to byte indices in the entry contents.
//
// The function returns the following values:
//
//    - x (optional): location to store X offset of layout, or NULL.
//    - y (optional): location to store Y offset of layout, or NULL.
//
func (entry *Entry) LayoutOffsets() (x int32, y int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "Entry").InvokeMethod("get_layout_offsets", _args[:], _outs[:])

	runtime.KeepAlive(entry)

	var _x int32 // out
	var _y int32 // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_x = *(*int32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_y = *(*int32)(unsafe.Pointer(_out1))
	}

	return _x, _y
}

// MaxLength retrieves the maximum allowed length of the text in entry. See
// gtk_entry_set_max_length().
//
// This is equivalent to getting entry's EntryBuffer and calling
// gtk_entry_buffer_get_max_length() on it.
//
// The function returns the following values:
//
//    - gint: maximum allowed number of characters in Entry, or 0 if there is no
//      maximum.
//
func (entry *Entry) MaxLength() int32 {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_max_length", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// MaxWidthChars retrieves the desired maximum width of entry, in characters.
// See gtk_entry_set_max_width_chars().
//
// The function returns the following values:
//
//    - gint: maximum width of the entry, in characters.
//
func (entry *Entry) MaxWidthChars() int32 {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_max_width_chars", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// OverwriteMode gets the value set by gtk_entry_set_overwrite_mode().
//
// The function returns the following values:
//
//    - ok: whether the text is overwritten when typing.
//
func (entry *Entry) OverwriteMode() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_overwrite_mode", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceholderText retrieves the text that will be displayed when entry is empty
// and unfocused.
//
// The function returns the following values:
//
//    - utf8: pointer to the placeholder text as a string. This string points to
//      internally allocated storage in the widget and must not be freed,
//      modified or stored.
//
func (entry *Entry) PlaceholderText() string {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_placeholder_text", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ProgressFraction returns the current fraction of the task that’s been
// completed. See gtk_entry_set_progress_fraction().
//
// The function returns the following values:
//
//    - gdouble: fraction from 0.0 to 1.0.
//
func (entry *Entry) ProgressFraction() float64 {
	var _args [1]girepository.Argument
	var _arg0 *C.void   // out
	var _cret C.gdouble // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_progress_fraction", _args[:], nil)
	_cret = *(*C.gdouble)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ProgressPulseStep retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
//
// The function returns the following values:
//
//    - gdouble: fraction from 0.0 to 1.0.
//
func (entry *Entry) ProgressPulseStep() float64 {
	var _args [1]girepository.Argument
	var _arg0 *C.void   // out
	var _cret C.gdouble // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_progress_pulse_step", _args[:], nil)
	_cret = *(*C.gdouble)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Tabs gets the tabstops that were set on the entry using gtk_entry_set_tabs(),
// if any.
//
// The function returns the following values:
//
//    - tabArray (optional): tabstops, or NULL if none was set.
//
func (entry *Entry) Tabs() *pango.TabArray {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_tabs", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _tabArray *pango.TabArray // out

	if _cret != nil {
		_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tabArray
}

// Text retrieves the contents of the entry widget. See also
// gtk_editable_get_chars().
//
// This is equivalent to getting entry's EntryBuffer and calling
// gtk_entry_buffer_get_text() on it.
//
// The function returns the following values:
//
//    - utf8: pointer to the contents of the widget as a string. This string
//      points to internally allocated storage in the widget and must not be
//      freed, modified or stored.
//
func (entry *Entry) Text() string {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_text", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TextArea gets the area where the entry’s text is drawn. This function is
// useful when drawing something to the entry in a draw callback.
//
// If the entry is not realized, text_area is filled with zeros.
//
// See also gtk_entry_get_icon_area().
//
// The function returns the following values:
//
//    - textArea: return location for the text area.
//
func (entry *Entry) TextArea() *gdk.Rectangle {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument
	var _arg0 *C.void // out
	var _out0 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "Entry").InvokeMethod("get_text_area", _args[:], _outs[:])

	runtime.KeepAlive(entry)

	var _textArea *gdk.Rectangle // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))

	_textArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(_out0)))

	return _textArea
}

// TextLength retrieves the current length of the text in entry.
//
// This is equivalent to getting entry's EntryBuffer and calling
// gtk_entry_buffer_get_length() on it.
//
// The function returns the following values:
//
//    - guint16: current number of characters in Entry, or 0 if there are none.
//
func (entry *Entry) TextLength() uint16 {
	var _args [1]girepository.Argument
	var _arg0 *C.void   // out
	var _cret C.guint16 // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_text_length", _args[:], nil)
	_cret = *(*C.guint16)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Visibility retrieves whether the text in entry is visible. See
// gtk_entry_set_visibility().
//
// The function returns the following values:
//
//    - ok: TRUE if the text is currently visible.
//
func (entry *Entry) Visibility() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_visibility", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidthChars gets the value set by gtk_entry_set_width_chars().
//
// The function returns the following values:
//
//    - gint: number of chars to request space for, or negative if unset.
//
func (entry *Entry) WidthChars() int32 {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("get_width_chars", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// GrabFocusWithoutSelecting causes entry to have keyboard focus.
//
// It behaves like gtk_widget_grab_focus(), except that it doesn't select the
// contents of the entry. You only want to call this on some special entries
// which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
func (entry *Entry) GrabFocusWithoutSelecting() {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "Entry").InvokeMethod("grab_focus_without_selecting", _args[:], nil)

	runtime.KeepAlive(entry)
}

// IMContextFilterKeypress: allow the Entry input method to internally handle
// key press and release events. If this function returns TRUE, then no further
// processing should be done for this key event. See
// gtk_im_context_filter_keypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the Entry. See gtk_text_view_reset_im_context() for an
// example of use.
//
// The function takes the following parameters:
//
//    - event: key event.
//
// The function returns the following values:
//
//    - ok: TRUE if the input method handled the key event.
//
func (entry *Entry) IMContextFilterKeypress(event *gdk.EventKey) bool {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(event)))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("im_context_filter_keypress", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LayoutIndexToTextIndex converts from a position in the entry’s Layout
// (returned by gtk_entry_get_layout()) to a position in the entry contents
// (returned by gtk_entry_get_text()).
//
// The function takes the following parameters:
//
//    - layoutIndex: byte index into the entry layout text.
//
// The function returns the following values:
//
//    - gint: byte index into the entry contents.
//
func (entry *Entry) LayoutIndexToTextIndex(layoutIndex int32) int32 {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(layoutIndex)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gint)(unsafe.Pointer(&_args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("layout_index_to_text_index", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)
	runtime.KeepAlive(layoutIndex)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// ProgressPulse indicates that some progress is made, but you don’t know how
// much. Causes the entry’s progress indicator to enter “activity mode,” where a
// block bounces back and forth. Each call to gtk_entry_progress_pulse() causes
// the block to move by a little bit (the amount of movement per pulse is
// determined by gtk_entry_set_progress_pulse_step()).
func (entry *Entry) ProgressPulse() {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "Entry").InvokeMethod("progress_pulse", _args[:], nil)

	runtime.KeepAlive(entry)
}

// ResetIMContext: reset the input method context of the entry if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (entry *Entry) ResetIMContext() {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "Entry").InvokeMethod("reset_im_context", _args[:], nil)

	runtime.KeepAlive(entry)
}

// SetActivatesDefault: if setting is TRUE, pressing Enter in the entry will
// activate the default widget for the window containing the entry. This usually
// means that the dialog box containing the entry will be closed, since the
// default widget is usually one of the dialog buttons.
//
// (For experts: if setting is TRUE, the entry calls
// gtk_window_activate_default() on the window containing the entry, in the
// default handler for the Entry::activate signal.).
//
// The function takes the following parameters:
//
//    - setting: TRUE to activate window’s default widget on Enter keypress.
//
func (entry *Entry) SetActivatesDefault(setting bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_activates_default", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(setting)
}

// SetAlignment sets the alignment for the contents of the entry. This controls
// the horizontal positioning of the contents when the displayed text is shorter
// than the width of the entry.
//
// The function takes the following parameters:
//
//    - xalign: horizontal alignment, from 0 (left) to 1 (right). Reversed for
//      RTL layouts.
//
func (entry *Entry) SetAlignment(xalign float32) {
	var _args [2]girepository.Argument
	var _arg0 *C.void  // out
	var _arg1 C.gfloat // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gfloat(xalign)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gfloat)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_alignment", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(xalign)
}

// SetAttributes sets a AttrList; the attributes in the list are applied to the
// entry text.
//
// The function takes the following parameters:
//
//    - attrs: AttrList.
//
func (entry *Entry) SetAttributes(attrs *pango.AttrList) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(attrs)))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_attributes", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(attrs)
}

// SetBuffer: set the EntryBuffer object which holds the text for this widget.
//
// The function takes the following parameters:
//
//    - buffer: EntryBuffer.
//
func (entry *Entry) SetBuffer(buffer *EntryBuffer) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_buffer", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(buffer)
}

// SetCompletion sets completion to be the auxiliary completion object to use
// with entry. All further configuration of the completion mechanism is done on
// completion using the EntryCompletion API. Completion is disabled if
// completion is set to NULL.
//
// The function takes the following parameters:
//
//    - completion (optional) or NULL.
//
func (entry *Entry) SetCompletion(completion *EntryCompletion) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if completion != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_completion", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(completion)
}

// SetCursorHAdjustment hooks up an adjustment to the cursor position in an
// entry, so that when the cursor is moved, the adjustment is scrolled to show
// that position. See gtk_scrolled_window_get_hadjustment() for a typical way of
// obtaining the adjustment.
//
// The adjustment has to be in pixel units and in the same coordinate system as
// the entry.
//
// The function takes the following parameters:
//
//    - adjustment (optional) which should be adjusted when the cursor is moved,
//      or NULL.
//
func (entry *Entry) SetCursorHAdjustment(adjustment *Adjustment) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if adjustment != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_cursor_hadjustment", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(adjustment)
}

// SetHasFrame sets whether the entry has a beveled frame around it.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (entry *Entry) SetHasFrame(setting bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_has_frame", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(setting)
}

// SetInnerBorder sets entry’s inner-border property to border, or clears it if
// NULL is passed. The inner-border is the area around the entry’s text, but
// inside its frame.
//
// If set, this property overrides the inner-border style property. Overriding
// the style-provided border is useful when you want to do in-place editing of
// some text in a canvas or list widget, where pixel-exact positioning of the
// entry is important.
//
// Deprecated: Use the standard border and padding CSS properties (through
// objects like StyleContext and CssProvider); the value set with this function
// is ignored by Entry.
//
// The function takes the following parameters:
//
//    - border (optional) or NULL.
//
func (entry *Entry) SetInnerBorder(border *Border) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if border != nil {
		_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(border)))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_inner_border", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(border)
}

// SetInvisibleChar sets the character to use in place of the actual text when
// gtk_entry_set_visibility() has been called to set text visibility to FALSE.
// i.e. this is the character used in “password mode” to show the user how many
// characters have been typed. By default, GTK+ picks the best invisible char
// available in the current font. If you set the invisible char to 0, then the
// user will get no feedback at all; there will be no text on the screen as they
// type.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//
func (entry *Entry) SetInvisibleChar(ch uint32) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gunichar // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gunichar(ch)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gunichar)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_invisible_char", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(ch)
}

// SetMaxLength sets the maximum allowed length of the contents of the widget.
// If the current contents are longer than the given length, then they will be
// truncated to fit.
//
// This is equivalent to getting entry's EntryBuffer and calling
// gtk_entry_buffer_set_max_length() on it. ]|.
//
// The function takes the following parameters:
//
//    - max: maximum length of the entry, or 0 for no maximum. (other than the
//      maximum length of entries.) The value passed in will be clamped to the
//      range 0-65536.
//
func (entry *Entry) SetMaxLength(max int32) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(max)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gint)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_max_length", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(max)
}

// SetMaxWidthChars sets the desired maximum width in characters of entry.
//
// The function takes the following parameters:
//
//    - nChars: new desired maximum width, in characters.
//
func (entry *Entry) SetMaxWidthChars(nChars int32) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(nChars)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gint)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_max_width_chars", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(nChars)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// Entry.
//
// The function takes the following parameters:
//
//    - overwrite: new value.
//
func (entry *Entry) SetOverwriteMode(overwrite bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_overwrite_mode", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(overwrite)
}

// SetPlaceholderText sets text to be displayed in entry when it is empty and
// unfocused. This can be used to give a visual hint of the expected contents of
// the Entry.
//
// Note that since the placeholder text gets removed when the entry received
// focus, using this feature is a bit problematic if the entry is given the
// initial focus in a window. Sometimes this can be worked around by delaying
// the initial focus setting until the first key event arrives.
//
// The function takes the following parameters:
//
//    - text (optional): string to be displayed when entry is empty and
//      unfocused, or NULL.
//
func (entry *Entry) SetPlaceholderText(text string) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if text != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_placeholder_text", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(text)
}

// SetProgressFraction causes the entry’s progress indicator to “fill in” the
// given fraction of the bar. The fraction should be between 0.0 and 1.0,
// inclusive.
//
// The function takes the following parameters:
//
//    - fraction of the task that’s been completed.
//
func (entry *Entry) SetProgressFraction(fraction float64) {
	var _args [2]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.gdouble // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gdouble(fraction)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gdouble)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_progress_fraction", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(fraction)
}

// SetProgressPulseStep sets the fraction of total entry width to move the
// progress bouncing block for each call to gtk_entry_progress_pulse().
//
// The function takes the following parameters:
//
//    - fraction between 0.0 and 1.0.
//
func (entry *Entry) SetProgressPulseStep(fraction float64) {
	var _args [2]girepository.Argument
	var _arg0 *C.void   // out
	var _arg1 C.gdouble // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gdouble(fraction)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gdouble)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_progress_pulse_step", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(fraction)
}

// SetTabs sets a TabArray; the tabstops in the array are applied to the entry
// text.
//
// The function takes the following parameters:
//
//    - tabs: TabArray.
//
func (entry *Entry) SetTabs(tabs *pango.TabArray) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(tabs)))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_tabs", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(tabs)
}

// SetText sets the text in the widget to the given value, replacing the current
// contents.
//
// See gtk_entry_buffer_set_text().
//
// The function takes the following parameters:
//
//    - text: new text.
//
func (entry *Entry) SetText(text string) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_text", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(text)
}

// SetVisibility sets whether the contents of the entry are visible or not. When
// visibility is set to FALSE, characters are displayed as the invisible char,
// and will also appear that way when the text in the entry widget is copied
// elsewhere.
//
// By default, GTK+ picks the best invisible character available in the current
// font, but it can be changed with gtk_entry_set_invisible_char().
//
// Note that you probably want to set Entry:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this entry, in addition to setting visibility to FALSE.
//
// The function takes the following parameters:
//
//    - visible: TRUE if the contents of the entry are displayed as plaintext.
//
func (entry *Entry) SetVisibility(visible bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_visibility", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(visible)
}

// SetWidthChars changes the size request of the entry to be about the right
// size for n_chars characters. Note that it changes the size request, the size
// can still be affected by how you pack the widget into containers. If n_chars
// is -1, the size reverts to the default entry size.
//
// The function takes the following parameters:
//
//    - nChars: width in chars.
//
func (entry *Entry) SetWidthChars(nChars int32) {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(nChars)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gint)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "Entry").InvokeMethod("set_width_chars", _args[:], nil)

	runtime.KeepAlive(entry)
	runtime.KeepAlive(nChars)
}

// TextIndexToLayoutIndex converts from a position in the entry contents
// (returned by gtk_entry_get_text()) to a position in the entry’s Layout
// (returned by gtk_entry_get_layout(), with text retrieved via
// pango_layout_get_text()).
//
// The function takes the following parameters:
//
//    - textIndex: byte index into the entry contents.
//
// The function returns the following values:
//
//    - gint: byte index into the entry layout text.
//
func (entry *Entry) TextIndexToLayoutIndex(textIndex int32) int32 {
	var _args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(textIndex)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gint)(unsafe.Pointer(&_args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "Entry").InvokeMethod("text_index_to_layout_index", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(entry)
	runtime.KeepAlive(textIndex)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// UnsetInvisibleChar unsets the invisible char previously set with
// gtk_entry_set_invisible_char(). So that the default invisible char is used
// again.
func (entry *Entry) UnsetInvisibleChar() {
	var _args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "Entry").InvokeMethod("unset_invisible_char", _args[:], nil)

	runtime.KeepAlive(entry)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_Entry_ConnectToggleOverwrite(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPreeditChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPopulatePopup(gpointer, GtkWidget*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectInsertAtCursor(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectIconRelease(gpointer, GtkEntryIconPosition, GdkEvent, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectIconPress(gpointer, GtkEntryIconPosition, GdkEvent, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectDeleteFromCursor(gpointer, GtkDeleteType, gint, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk3_Entry_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk3_EntryClass_toggle_overwrite(GtkEntry*);
// extern void _gotk4_gtk3_EntryClass_populate_popup(GtkEntry*, GtkWidget*);
// extern void _gotk4_gtk3_EntryClass_paste_clipboard(GtkEntry*);
// extern void _gotk4_gtk3_EntryClass_move_cursor(GtkEntry*, GtkMovementStep, gint, gboolean);
// extern void _gotk4_gtk3_EntryClass_insert_emoji(GtkEntry*);
// extern void _gotk4_gtk3_EntryClass_insert_at_cursor(GtkEntry*, gchar*);
// extern void _gotk4_gtk3_EntryClass_get_text_area_size(GtkEntry*, gint*, gint*, gint*, gint*);
// extern void _gotk4_gtk3_EntryClass_get_frame_size(GtkEntry*, gint*, gint*, gint*, gint*);
// extern void _gotk4_gtk3_EntryClass_delete_from_cursor(GtkEntry*, GtkDeleteType, gint);
// extern void _gotk4_gtk3_EntryClass_cut_clipboard(GtkEntry*);
// extern void _gotk4_gtk3_EntryClass_copy_clipboard(GtkEntry*);
// extern void _gotk4_gtk3_EntryClass_backspace(GtkEntry*);
// extern void _gotk4_gtk3_EntryClass_activate(GtkEntry*);
// void _gotk4_gtk3_Entry_virtual_activate(void* fnptr, GtkEntry* arg0) {
//   ((void (*)(GtkEntry*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Entry_virtual_backspace(void* fnptr, GtkEntry* arg0) {
//   ((void (*)(GtkEntry*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Entry_virtual_copy_clipboard(void* fnptr, GtkEntry* arg0) {
//   ((void (*)(GtkEntry*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Entry_virtual_cut_clipboard(void* fnptr, GtkEntry* arg0) {
//   ((void (*)(GtkEntry*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Entry_virtual_delete_from_cursor(void* fnptr, GtkEntry* arg0, GtkDeleteType arg1, gint arg2) {
//   ((void (*)(GtkEntry*, GtkDeleteType, gint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_Entry_virtual_get_frame_size(void* fnptr, GtkEntry* arg0, gint* arg1, gint* arg2, gint* arg3, gint* arg4) {
//   ((void (*)(GtkEntry*, gint*, gint*, gint*, gint*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk3_Entry_virtual_get_text_area_size(void* fnptr, GtkEntry* arg0, gint* arg1, gint* arg2, gint* arg3, gint* arg4) {
//   ((void (*)(GtkEntry*, gint*, gint*, gint*, gint*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk3_Entry_virtual_insert_at_cursor(void* fnptr, GtkEntry* arg0, gchar* arg1) {
//   ((void (*)(GtkEntry*, gchar*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Entry_virtual_insert_emoji(void* fnptr, GtkEntry* arg0) {
//   ((void (*)(GtkEntry*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Entry_virtual_move_cursor(void* fnptr, GtkEntry* arg0, GtkMovementStep arg1, gint arg2, gboolean arg3) {
//   ((void (*)(GtkEntry*, GtkMovementStep, gint, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk3_Entry_virtual_paste_clipboard(void* fnptr, GtkEntry* arg0) {
//   ((void (*)(GtkEntry*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_Entry_virtual_populate_popup(void* fnptr, GtkEntry* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkEntry*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Entry_virtual_toggle_overwrite(void* fnptr, GtkEntry* arg0) {
//   ((void (*)(GtkEntry*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeEntry = coreglib.Type(C.gtk_entry_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeEntry, F: marshalEntry},
	})
}

// EntryOverrides contains methods that are overridable.
type EntryOverrides struct {
	Activate      func()
	Backspace     func()
	CopyClipboard func()
	CutClipboard  func()
	// The function takes the following parameters:
	//
	//    - typ
	//    - count
	//
	DeleteFromCursor func(typ DeleteType, count int)
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - width
	//    - height
	//
	FrameSize func(x, y, width, height *int)
	// The function takes the following parameters:
	//
	//    - x
	//    - y
	//    - width
	//    - height
	//
	TextAreaSize func(x, y, width, height *int)
	// The function takes the following parameters:
	//
	InsertAtCursor func(str string)
	InsertEmoji    func()
	// The function takes the following parameters:
	//
	//    - step
	//    - count
	//    - extendSelection
	//
	MoveCursor     func(step MovementStep, count int, extendSelection bool)
	PasteClipboard func()
	// The function takes the following parameters:
	//
	PopulatePopup   func(popup Widgetter)
	ToggleOverwrite func()
}

func defaultEntryOverrides(v *Entry) EntryOverrides {
	return EntryOverrides{
		Activate:         v.activate,
		Backspace:        v.backspace,
		CopyClipboard:    v.copyClipboard,
		CutClipboard:     v.cutClipboard,
		DeleteFromCursor: v.deleteFromCursor,
		FrameSize:        v.frameSize,
		TextAreaSize:     v.textAreaSize,
		InsertAtCursor:   v.insertAtCursor,
		InsertEmoji:      v.insertEmoji,
		MoveCursor:       v.moveCursor,
		PasteClipboard:   v.pasteClipboard,
		PopulatePopup:    v.populatePopup,
		ToggleOverwrite:  v.toggleOverwrite,
	}
}

// Entry widget is a single line text entry widget. A fairly large set of key
// bindings are supported by default. If the entered text is longer than the
// allocation of the widget, the widget will scroll so that the cursor position
// is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk_entry_set_visibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK+
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk_entry_set_invisible_char(). Since 2.16, GTK+
// displays a warning when Caps Lock or input methods might interfere with
// entering text in a password entry. The warning can be turned off with the
// Entry:caps-lock-warning property.
//
// Since 2.16, GtkEntry has the ability to display progress or activity
// information behind the text. To make an entry display such information, use
// gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
//
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or one of
// the various other functions that set an icon from a stock id, an icon name or
// a pixbuf. To trigger an action when the user clicks an icon, connect to the
// Entry::icon-press signal. To allow DND operations from an icon, use
// gtk_entry_set_icon_drag_source(). To set a tooltip on an icon, use
// gtk_entry_set_icon_tooltip_text() or the corresponding function for markup.
//
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
//
// CSS nodes
//
//    entry[.read-only][.flat][.warning][.error]
//    ├── image.left
//    ├── image.right
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [progress[.pulse]]
//    ╰── [window.popup]
//
// GtkEntry has a main node with the name entry. Depending on the properties of
// the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
//
// The CSS node for a context menu is added as a subnode below entry as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
type Entry struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	CellEditable
	Editable
}

var (
	_ Widgetter         = (*Entry)(nil)
	_ coreglib.Objector = (*Entry)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Entry, *EntryClass, EntryOverrides](
		GTypeEntry,
		initEntryClass,
		wrapEntry,
		defaultEntryOverrides,
	)
}

func initEntryClass(gclass unsafe.Pointer, overrides EntryOverrides, classInitFunc func(*EntryClass)) {
	pclass := (*C.GtkEntryClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeEntry))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk3_EntryClass_activate)
	}

	if overrides.Backspace != nil {
		pclass.backspace = (*[0]byte)(C._gotk4_gtk3_EntryClass_backspace)
	}

	if overrides.CopyClipboard != nil {
		pclass.copy_clipboard = (*[0]byte)(C._gotk4_gtk3_EntryClass_copy_clipboard)
	}

	if overrides.CutClipboard != nil {
		pclass.cut_clipboard = (*[0]byte)(C._gotk4_gtk3_EntryClass_cut_clipboard)
	}

	if overrides.DeleteFromCursor != nil {
		pclass.delete_from_cursor = (*[0]byte)(C._gotk4_gtk3_EntryClass_delete_from_cursor)
	}

	if overrides.FrameSize != nil {
		pclass.get_frame_size = (*[0]byte)(C._gotk4_gtk3_EntryClass_get_frame_size)
	}

	if overrides.TextAreaSize != nil {
		pclass.get_text_area_size = (*[0]byte)(C._gotk4_gtk3_EntryClass_get_text_area_size)
	}

	if overrides.InsertAtCursor != nil {
		pclass.insert_at_cursor = (*[0]byte)(C._gotk4_gtk3_EntryClass_insert_at_cursor)
	}

	if overrides.InsertEmoji != nil {
		pclass.insert_emoji = (*[0]byte)(C._gotk4_gtk3_EntryClass_insert_emoji)
	}

	if overrides.MoveCursor != nil {
		pclass.move_cursor = (*[0]byte)(C._gotk4_gtk3_EntryClass_move_cursor)
	}

	if overrides.PasteClipboard != nil {
		pclass.paste_clipboard = (*[0]byte)(C._gotk4_gtk3_EntryClass_paste_clipboard)
	}

	if overrides.PopulatePopup != nil {
		pclass.populate_popup = (*[0]byte)(C._gotk4_gtk3_EntryClass_populate_popup)
	}

	if overrides.ToggleOverwrite != nil {
		pclass.toggle_overwrite = (*[0]byte)(C._gotk4_gtk3_EntryClass_toggle_overwrite)
	}

	if classInitFunc != nil {
		class := (*EntryClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapEntry(obj *coreglib.Object) *Entry {
	return &Entry{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
		Object: obj,
		CellEditable: CellEditable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Editable: Editable{
			Object: obj,
		},
	}
}

func marshalEntry(p uintptr) (interface{}, error) {
	return wrapEntry(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate signal is emitted when the user hits the Enter key.
//
// While this signal is used as a [keybinding signal][GtkBindingSignal], it is
// also commonly used by applications to intercept activation of entries.
//
// The default bindings for this signal are all forms of the Enter key.
func (entry *Entry) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "activate", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectActivate), f)
}

// ConnectBackspace signal is a [keybinding signal][GtkBindingSignal] which gets
// emitted when the user asks for it.
//
// The default bindings for this signal are Backspace and Shift-Backspace.
func (entry *Entry) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "backspace", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectBackspace), f)
}

// ConnectCopyClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to copy the selection to the clipboard.
//
// The default bindings for this signal are Ctrl-c and Ctrl-Insert.
func (entry *Entry) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectCopyClipboard), f)
}

// ConnectCutClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to cut the selection to the clipboard.
//
// The default bindings for this signal are Ctrl-x and Shift-Delete.
func (entry *Entry) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectCutClipboard), f)
}

// ConnectDeleteFromCursor signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted when the user initiates a text deletion.
//
// If the type is GTK_DELETE_CHARS, GTK+ deletes the selection if there is one,
// otherwise it deletes the requested number of characters.
//
// The default bindings for this signal are Delete for deleting a character and
// Ctrl-Delete for deleting a word.
func (entry *Entry) ConnectDeleteFromCursor(f func(typ DeleteType, count int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "delete-from-cursor", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectDeleteFromCursor), f)
}

// ConnectIconPress signal is emitted when an activatable icon is clicked.
func (entry *Entry) ConnectIconPress(f func(iconPos EntryIconPosition, event *gdk.Event)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "icon-press", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectIconPress), f)
}

// ConnectIconRelease signal is emitted on the button release from a mouse click
// over an activatable icon.
func (entry *Entry) ConnectIconRelease(f func(iconPos EntryIconPosition, event *gdk.Event)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "icon-release", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectIconRelease), f)
}

// ConnectInsertAtCursor signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user initiates the insertion of a fixed string at the
// cursor.
//
// This signal has no default bindings.
func (entry *Entry) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectInsertAtCursor), f)
}

// ConnectInsertEmoji signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to present the Emoji chooser for the entry.
//
// The default bindings for this signal are Ctrl-. and Ctrl-;.
func (entry *Entry) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectInsertEmoji), f)
}

// ConnectMoveCursor signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user initiates a cursor movement. If the cursor is not
// visible in entry, this signal causes the viewport to be moved instead.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
//
// The default bindings for this signal come in two variants, the variant with
// the Shift modifier extends the selection, the variant without the Shift
// modifer does not. There are too many key combinations to list them all here.
//
// - Arrow keys move by individual characters/lines
//
// - Ctrl-arrow key combinations move by words/paragraphs
//
// - Home/End keys move to the ends of the buffer.
func (entry *Entry) ConnectMoveCursor(f func(step MovementStep, count int, extendSelection bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectMoveCursor), f)
}

// ConnectPasteClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to paste the contents of the clipboard into the text view.
//
// The default bindings for this signal are Ctrl-v and Shift-Insert.
func (entry *Entry) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPasteClipboard), f)
}

// ConnectPopulatePopup signal gets emitted before showing the context menu of
// the entry.
//
// If you need to add items to the context menu, connect to this signal and
// append your items to the widget, which will be a Menu in this case.
//
// If Entry:populate-all is TRUE, this signal will also be emitted to populate
// touch popups. In this case, widget will be a different container, e.g. a
// Toolbar. The signal handler should not make assumptions about the type of
// widget.
func (entry *Entry) ConnectPopulatePopup(f func(widget Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "populate-popup", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPopulatePopup), f)
}

// ConnectPreeditChanged: if an input method is used, the typed text will not
// immediately be committed to the buffer. So if you are interested in the text,
// connect to this signal.
func (entry *Entry) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectPreeditChanged), f)
}

// ConnectToggleOverwrite signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted to toggle the overwrite mode of the entry.
//
// The default bindings for this signal is Insert.
func (entry *Entry) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk3_Entry_ConnectToggleOverwrite), f)
}

// NewEntry creates a new entry.
//
// The function returns the following values:
//
//    - entry: new Entry.
//
func NewEntry() *Entry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_entry_new()

	var _entry *Entry // out

	_entry = wrapEntry(coreglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// ActivatesDefault retrieves the value set by
// gtk_entry_set_activates_default().
//
// The function returns the following values:
//
//    - ok: TRUE if the entry will activate the default widget.
//
func (entry *Entry) ActivatesDefault() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_activates_default(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasFrame gets the value set by gtk_entry_set_has_frame().
//
// The function returns the following values:
//
//    - ok: whether the entry has a beveled frame.
//
func (entry *Entry) HasFrame() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_has_frame(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false. See
// gtk_entry_set_invisible_char().
//
// The function returns the following values:
//
//    - gunichar: current invisible char, or 0, if the entry does not show
//      invisible text at all.
//
func (entry *Entry) InvisibleChar() uint32 {
	var _arg0 *C.GtkEntry // out
	var _cret C.gunichar  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_invisible_char(_arg0)
	runtime.KeepAlive(entry)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// Layout gets the Layout used to display the entry. The layout is useful to
// e.g. convert text positions to pixel positions, in combination with
// gtk_entry_get_layout_offsets(). The returned layout is owned by the entry and
// must not be modified or freed by the caller.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices in
// the layout to byte indices in the entry contents.
//
// The function returns the following values:
//
//    - layout for this entry.
//
func (entry *Entry) Layout() *pango.Layout {
	var _arg0 *C.GtkEntry    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_layout(_arg0)
	runtime.KeepAlive(entry)

	var _layout *pango.Layout // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// LayoutOffsets obtains the position of the Layout used to render text in the
// entry, in widget coordinates. Useful if you want to line up the text in an
// entry with some other text, e.g. when using the entry to implement editable
// cells in a sheet widget.
//
// Also useful to convert mouse events into coordinates inside the Layout, e.g.
// to take some action if some part of the entry text is clicked.
//
// Note that as the user scrolls around in the entry the offsets will change;
// you’ll need to connect to the “notify::scroll-offset” signal to track this.
// Remember when using the Layout functions you need to convert to and from
// pixels using PANGO_PIXELS() or NGO_SCALE.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte indices in
// the layout to byte indices in the entry contents.
//
// The function returns the following values:
//
//    - x (optional): location to store X offset of layout, or NULL.
//    - y (optional): location to store Y offset of layout, or NULL.
//
func (entry *Entry) LayoutOffsets() (x, y int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // in
	var _arg2 C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C.gtk_entry_get_layout_offsets(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(entry)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// MaxLength retrieves the maximum allowed length of the text in entry. See
// gtk_entry_set_max_length().
//
// This is equivalent to getting entry's EntryBuffer and calling
// gtk_entry_buffer_get_max_length() on it.
//
// The function returns the following values:
//
//    - gint: maximum allowed number of characters in Entry, or 0 if there is no
//      maximum.
//
func (entry *Entry) MaxLength() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_max_length(_arg0)
	runtime.KeepAlive(entry)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Text retrieves the contents of the entry widget. See also
// gtk_editable_get_chars().
//
// This is equivalent to getting entry's EntryBuffer and calling
// gtk_entry_buffer_get_text() on it.
//
// The function returns the following values:
//
//    - utf8: pointer to the contents of the widget as a string. This string
//      points to internally allocated storage in the widget and must not be
//      freed, modified or stored.
//
func (entry *Entry) Text() string {
	var _arg0 *C.GtkEntry // out
	var _cret *C.gchar    // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_text(_arg0)
	runtime.KeepAlive(entry)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Visibility retrieves whether the text in entry is visible. See
// gtk_entry_set_visibility().
//
// The function returns the following values:
//
//    - ok: TRUE if the text is currently visible.
//
func (entry *Entry) Visibility() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_visibility(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidthChars gets the value set by gtk_entry_set_width_chars().
//
// The function returns the following values:
//
//    - gint: number of chars to request space for, or negative if unset.
//
func (entry *Entry) WidthChars() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_width_chars(_arg0)
	runtime.KeepAlive(entry)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LayoutIndexToTextIndex converts from a position in the entry’s Layout
// (returned by gtk_entry_get_layout()) to a position in the entry contents
// (returned by gtk_entry_get_text()).
//
// The function takes the following parameters:
//
//    - layoutIndex: byte index into the entry layout text.
//
// The function returns the following values:
//
//    - gint: byte index into the entry contents.
//
func (entry *Entry) LayoutIndexToTextIndex(layoutIndex int) int {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(layoutIndex)

	_cret = C.gtk_entry_layout_index_to_text_index(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(layoutIndex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SetActivatesDefault: if setting is TRUE, pressing Enter in the entry will
// activate the default widget for the window containing the entry. This usually
// means that the dialog box containing the entry will be closed, since the
// default widget is usually one of the dialog buttons.
//
// (For experts: if setting is TRUE, the entry calls
// gtk_window_activate_default() on the window containing the entry, in the
// default handler for the Entry::activate signal.).
//
// The function takes the following parameters:
//
//    - setting: TRUE to activate window’s default widget on Enter keypress.
//
func (entry *Entry) SetActivatesDefault(setting bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_activates_default(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(setting)
}

// SetHasFrame sets whether the entry has a beveled frame around it.
//
// The function takes the following parameters:
//
//    - setting: new value.
//
func (entry *Entry) SetHasFrame(setting bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_has_frame(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(setting)
}

// SetInvisibleChar sets the character to use in place of the actual text when
// gtk_entry_set_visibility() has been called to set text visibility to FALSE.
// i.e. this is the character used in “password mode” to show the user how many
// characters have been typed. By default, GTK+ picks the best invisible char
// available in the current font. If you set the invisible char to 0, then the
// user will get no feedback at all; there will be no text on the screen as they
// type.
//
// The function takes the following parameters:
//
//    - ch: unicode character.
//
func (entry *Entry) SetInvisibleChar(ch uint32) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gunichar  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gunichar(ch)

	C.gtk_entry_set_invisible_char(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(ch)
}

// SetMaxLength sets the maximum allowed length of the contents of the widget.
// If the current contents are longer than the given length, then they will be
// truncated to fit.
//
// This is equivalent to getting entry's EntryBuffer and calling
// gtk_entry_buffer_set_max_length() on it. ]|.
//
// The function takes the following parameters:
//
//    - max: maximum length of the entry, or 0 for no maximum. (other than the
//      maximum length of entries.) The value passed in will be clamped to the
//      range 0-65536.
//
func (entry *Entry) SetMaxLength(max int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(max)

	C.gtk_entry_set_max_length(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(max)
}

// SetText sets the text in the widget to the given value, replacing the current
// contents.
//
// See gtk_entry_buffer_set_text().
//
// The function takes the following parameters:
//
//    - text: new text.
//
func (entry *Entry) SetText(text string) {
	var _arg0 *C.GtkEntry // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_entry_set_text(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(text)
}

// SetVisibility sets whether the contents of the entry are visible or not. When
// visibility is set to FALSE, characters are displayed as the invisible char,
// and will also appear that way when the text in the entry widget is copied
// elsewhere.
//
// By default, GTK+ picks the best invisible character available in the current
// font, but it can be changed with gtk_entry_set_invisible_char().
//
// Note that you probably want to set Entry:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this entry, in addition to setting visibility to FALSE.
//
// The function takes the following parameters:
//
//    - visible: TRUE if the contents of the entry are displayed as plaintext.
//
func (entry *Entry) SetVisibility(visible bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_visibility(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(visible)
}

// SetWidthChars changes the size request of the entry to be about the right
// size for n_chars characters. Note that it changes the size request, the size
// can still be affected by how you pack the widget into containers. If n_chars
// is -1, the size reverts to the default entry size.
//
// The function takes the following parameters:
//
//    - nChars: width in chars.
//
func (entry *Entry) SetWidthChars(nChars int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(nChars)

	C.gtk_entry_set_width_chars(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(nChars)
}

// TextIndexToLayoutIndex converts from a position in the entry contents
// (returned by gtk_entry_get_text()) to a position in the entry’s Layout
// (returned by gtk_entry_get_layout(), with text retrieved via
// pango_layout_get_text()).
//
// The function takes the following parameters:
//
//    - textIndex: byte index into the entry contents.
//
// The function returns the following values:
//
//    - gint: byte index into the entry layout text.
//
func (entry *Entry) TextIndexToLayoutIndex(textIndex int) int {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gint      // out
	var _cret C.gint      // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gint(textIndex)

	_cret = C.gtk_entry_text_index_to_layout_index(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(textIndex)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

func (entry *Entry) activate() {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.activate

	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C._gotk4_gtk3_Entry_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(entry)
}

func (entry *Entry) backspace() {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.backspace

	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C._gotk4_gtk3_Entry_virtual_backspace(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(entry)
}

func (entry *Entry) copyClipboard() {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.copy_clipboard

	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C._gotk4_gtk3_Entry_virtual_copy_clipboard(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(entry)
}

func (entry *Entry) cutClipboard() {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.cut_clipboard

	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C._gotk4_gtk3_Entry_virtual_cut_clipboard(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(entry)
}

// The function takes the following parameters:
//
//    - typ
//    - count
//
func (entry *Entry) deleteFromCursor(typ DeleteType, count int) {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.delete_from_cursor

	var _arg0 *C.GtkEntry     // out
	var _arg1 C.GtkDeleteType // out
	var _arg2 C.gint          // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkDeleteType(typ)
	_arg2 = C.gint(count)

	C._gotk4_gtk3_Entry_virtual_delete_from_cursor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(count)
}

// The function takes the following parameters:
//
//    - x
//    - y
//    - width
//    - height
//
func (entry *Entry) frameSize(x, y, width, height *int) {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.get_frame_size

	var _arg0 *C.GtkEntry // out
	var _arg1 *C.gint     // out
	var _arg2 *C.gint     // out
	var _arg3 *C.gint     // out
	var _arg4 *C.gint     // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.gint)(unsafe.Pointer(x))
	_arg2 = (*C.gint)(unsafe.Pointer(y))
	_arg3 = (*C.gint)(unsafe.Pointer(width))
	_arg4 = (*C.gint)(unsafe.Pointer(height))

	C._gotk4_gtk3_Entry_virtual_get_frame_size(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// The function takes the following parameters:
//
//    - x
//    - y
//    - width
//    - height
//
func (entry *Entry) textAreaSize(x, y, width, height *int) {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.get_text_area_size

	var _arg0 *C.GtkEntry // out
	var _arg1 *C.gint     // out
	var _arg2 *C.gint     // out
	var _arg3 *C.gint     // out
	var _arg4 *C.gint     // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.gint)(unsafe.Pointer(x))
	_arg2 = (*C.gint)(unsafe.Pointer(y))
	_arg3 = (*C.gint)(unsafe.Pointer(width))
	_arg4 = (*C.gint)(unsafe.Pointer(height))

	C._gotk4_gtk3_Entry_virtual_get_text_area_size(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// The function takes the following parameters:
//
func (entry *Entry) insertAtCursor(str string) {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.insert_at_cursor

	var _arg0 *C.GtkEntry // out
	var _arg1 *C.gchar    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gtk3_Entry_virtual_insert_at_cursor(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(str)
}

func (entry *Entry) insertEmoji() {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.insert_emoji

	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C._gotk4_gtk3_Entry_virtual_insert_emoji(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(entry)
}

// The function takes the following parameters:
//
//    - step
//    - count
//    - extendSelection
//
func (entry *Entry) moveCursor(step MovementStep, count int, extendSelection bool) {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.move_cursor

	var _arg0 *C.GtkEntry       // out
	var _arg1 C.GtkMovementStep // out
	var _arg2 C.gint            // out
	var _arg3 C.gboolean        // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkMovementStep(step)
	_arg2 = C.gint(count)
	if extendSelection {
		_arg3 = C.TRUE
	}

	C._gotk4_gtk3_Entry_virtual_move_cursor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(step)
	runtime.KeepAlive(count)
	runtime.KeepAlive(extendSelection)
}

func (entry *Entry) pasteClipboard() {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.paste_clipboard

	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C._gotk4_gtk3_Entry_virtual_paste_clipboard(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(entry)
}

// The function takes the following parameters:
//
func (entry *Entry) populatePopup(popup Widgetter) {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.populate_popup

	var _arg0 *C.GtkEntry  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(popup).Native()))

	C._gotk4_gtk3_Entry_virtual_populate_popup(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(popup)
}

func (entry *Entry) toggleOverwrite() {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.toggle_overwrite

	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C._gotk4_gtk3_Entry_virtual_toggle_overwrite(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(entry)
}

// EntryClass class structure for Entry. All virtual functions have a default
// implementation. Derived classes may set the virtual function pointers for the
// signal handlers to NULL, but must keep get_text_area_size and get_frame_size
// non-NULL; either use the default implementation, or provide a custom one.
//
// An instance of this type is always passed by reference.
type EntryClass struct {
	*entryClass
}

// entryClass is the struct that's finalized.
type entryClass struct {
	native *C.GtkEntryClass
}

// ParentClass: parent class.
func (e *EntryClass) ParentClass() *WidgetClass {
	valptr := &e.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

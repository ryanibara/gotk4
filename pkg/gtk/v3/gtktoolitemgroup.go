// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// GTypeToolItemGroup returns the GType for the type ToolItemGroup.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeToolItemGroup() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "ToolItemGroup").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalToolItemGroup)
	return gtype
}

// ToolItemGroupOverrider contains methods that are overridable.
type ToolItemGroupOverrider interface {
}

// ToolItemGroup is used together with ToolPalette to add ToolItems to a palette
// like container with different categories and drag and drop support.
//
//
// CSS nodes
//
// GtkToolItemGroup has a single CSS node named toolitemgroup.
type ToolItemGroup struct {
	_ [0]func() // equal guard
	Container

	*coreglib.Object
	atk.ImplementorIface
	coreglib.InitiallyUnowned
	Buildable
	ToolShell
	Widget
}

var (
	_ Containerer       = (*ToolItemGroup)(nil)
	_ coreglib.Objector = (*ToolItemGroup)(nil)
	_ Widgetter         = (*ToolItemGroup)(nil)
)

func classInitToolItemGrouper(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapToolItemGroup(obj *coreglib.Object) *ToolItemGroup {
	return &ToolItemGroup{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Object: obj,
		ImplementorIface: atk.ImplementorIface{
			Object: obj,
		},
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
		ToolShell: ToolShell{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
	}
}

func marshalToolItemGroup(p uintptr) (interface{}, error) {
	return wrapToolItemGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewToolItemGroup creates a new tool item group with label label.
//
// The function takes the following parameters:
//
//    - label of the new group.
//
// The function returns the following values:
//
//    - toolItemGroup: new ToolItemGroup.
//
func NewToolItemGroup(label string) *ToolItemGroup {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_args[0]))

	_gret := girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("new_ToolItemGroup", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(label)

	var _toolItemGroup *ToolItemGroup // out

	_toolItemGroup = wrapToolItemGroup(coreglib.Take(unsafe.Pointer(_cret)))

	return _toolItemGroup
}

// Collapsed gets whether group is collapsed or expanded.
//
// The function returns the following values:
//
//    - ok: TRUE if group is collapsed, FALSE if it is expanded.
//
func (group *ToolItemGroup) Collapsed() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))

	_gret := girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("get_collapsed", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(group)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// DropItem gets the tool item at position (x, y).
//
// The function takes the following parameters:
//
//    - x position.
//    - y position.
//
// The function returns the following values:
//
//    - toolItem at position (x, y).
//
func (group *ToolItemGroup) DropItem(x, y int32) *ToolItem {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(x)
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(y)

	_gret := girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("get_drop_item", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(group)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _toolItem *ToolItem // out

	_toolItem = wrapToolItem(coreglib.Take(unsafe.Pointer(_cret)))

	return _toolItem
}

// ItemPosition gets the position of item in group as index.
//
// The function takes the following parameters:
//
//    - item: ToolItem.
//
// The function returns the following values:
//
//    - gint: index of item in group or -1 if item is no child of group.
//
func (group *ToolItemGroup) ItemPosition(item *ToolItem) int32 {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(item).Native()))

	_gret := girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("get_item_position", _args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(group)
	runtime.KeepAlive(item)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Label gets the label of group.
//
// The function returns the following values:
//
//    - utf8: label of group. The label is an internal string of group and must
//      not be modified. Note that NULL is returned if a custom label has been
//      set with gtk_tool_item_group_set_label_widget().
//
func (group *ToolItemGroup) Label() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))

	_gret := girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("get_label", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(group)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// LabelWidget gets the label widget of group. See
// gtk_tool_item_group_set_label_widget().
//
// The function returns the following values:
//
//    - widget: label widget of group.
//
func (group *ToolItemGroup) LabelWidget() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))

	_gret := girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("get_label_widget", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(group)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// NItems gets the number of tool items in group.
//
// The function returns the following values:
//
//    - guint: number of tool items in group.
//
func (group *ToolItemGroup) NItems() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))

	_gret := girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("get_n_items", _args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(group)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// NthItem gets the tool item at index in group.
//
// The function takes the following parameters:
//
//    - index: index.
//
// The function returns the following values:
//
//    - toolItem at index.
//
func (group *ToolItemGroup) NthItem(index uint32) *ToolItem {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(index)

	_gret := girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("get_nth_item", _args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(group)
	runtime.KeepAlive(index)

	var _toolItem *ToolItem // out

	_toolItem = wrapToolItem(coreglib.Take(unsafe.Pointer(_cret)))

	return _toolItem
}

// Insert inserts item at position in the list of children of group.
//
// The function takes the following parameters:
//
//    - item to insert into group.
//    - position of item in group, starting with 0. The position -1 means end of
//      list.
//
func (group *ToolItemGroup) Insert(item *ToolItem, position int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(item).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(position)

	girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("insert", _args[:], nil)

	runtime.KeepAlive(group)
	runtime.KeepAlive(item)
	runtime.KeepAlive(position)
}

// SetCollapsed sets whether the group should be collapsed or expanded.
//
// The function takes the following parameters:
//
//    - collapsed: whether the group should be collapsed or expanded.
//
func (group *ToolItemGroup) SetCollapsed(collapsed bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if collapsed {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("set_collapsed", _args[:], nil)

	runtime.KeepAlive(group)
	runtime.KeepAlive(collapsed)
}

// SetItemPosition sets the position of item in the list of children of group.
//
// The function takes the following parameters:
//
//    - item to move to a new position, should be a child of group.
//    - position: new position of item in group, starting with 0. The position -1
//      means end of list.
//
func (group *ToolItemGroup) SetItemPosition(item *ToolItem, position int32) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(item).Native()))
	*(*C.gint)(unsafe.Pointer(&_args[2])) = C.gint(position)

	girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("set_item_position", _args[:], nil)

	runtime.KeepAlive(group)
	runtime.KeepAlive(item)
	runtime.KeepAlive(position)
}

// SetLabel sets the label of the tool item group. The label is displayed in the
// header of the group.
//
// The function takes the following parameters:
//
//    - label: new human-readable label of of the group.
//
func (group *ToolItemGroup) SetLabel(label string) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_args[1]))

	girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("set_label", _args[:], nil)

	runtime.KeepAlive(group)
	runtime.KeepAlive(label)
}

// SetLabelWidget sets the label of the tool item group. The label widget is
// displayed in the header of the group, in place of the usual label.
//
// The function takes the following parameters:
//
//    - labelWidget: widget to be displayed in place of the usual label.
//
func (group *ToolItemGroup) SetLabelWidget(labelWidget Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(labelWidget).Native()))

	girepository.MustFind("Gtk", "ToolItemGroup").InvokeMethod("set_label_widget", _args[:], nil)

	runtime.KeepAlive(group)
	runtime.KeepAlive(labelWidget)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void callbackDelete(gpointer);
// extern gboolean _gotk4_gtk3_EntryCompletionMatchFunc(GtkEntryCompletion*, gchar*, GtkTreeIter*, gpointer);
import "C"

// NewEntryCompletion creates a new EntryCompletion object.
//
// The function returns the following values:
//
//    - entryCompletion: newly created EntryCompletion object.
//
func NewEntryCompletion() *EntryCompletion {
	var _cret *C.GtkEntryCompletion // in

	_cret = C.gtk_entry_completion_new()

	var _entryCompletion *EntryCompletion // out

	_entryCompletion = wrapEntryCompletion(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// Complete requests a completion operation, or in other words a refiltering of
// the current list with completions, using the current key. The completion list
// view will be updated accordingly.
func (completion *EntryCompletion) Complete() {
	var _arg0 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C.gtk_entry_completion_complete(_arg0)
	runtime.KeepAlive(completion)
}

// DeleteAction deletes the action at index_ from completion’s action list.
//
// Note that index_ is a relative position and the position of an action may
// have changed since it was inserted.
//
// The function takes the following parameters:
//
//    - index_: index of the item to delete.
//
func (completion *EntryCompletion) DeleteAction(index_ int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.gint(index_)

	C.gtk_entry_completion_delete_action(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(index_)
}

// Entry gets the entry completion has been attached to.
//
// The function returns the following values:
//
//    - widget: entry completion has been attached to.
//
func (completion *EntryCompletion) Entry() Widgetter {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_entry(_arg0)
	runtime.KeepAlive(completion)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// MinimumKeyLength returns the minimum key length as set for completion.
//
// The function returns the following values:
//
//    - gint: currently used minimum key length.
//
func (completion *EntryCompletion) MinimumKeyLength() int {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gint                // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_minimum_key_length(_arg0)
	runtime.KeepAlive(completion)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Model returns the model the EntryCompletion is using as data source. Returns
// NULL if the model is unset.
//
// The function returns the following values:
//
//    - treeModel (optional) or NULL if none is currently being used.
//
func (completion *EntryCompletion) Model() *TreeModel {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.GtkTreeModel       // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_model(_arg0)
	runtime.KeepAlive(completion)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// InsertActionMarkup inserts an action in completion’s action item list at
// position index_ with markup markup.
//
// The function takes the following parameters:
//
//    - index_: index of the item to insert.
//    - markup of the item to insert.
//
func (completion *EntryCompletion) InsertActionMarkup(index_ int, markup string) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out
	var _arg2 *C.gchar              // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.gint(index_)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(markup)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_completion_insert_action_markup(_arg0, _arg1, _arg2)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(markup)
}

// InsertActionText inserts an action in completion’s action item list at
// position index_ with text text. If you want the action item to have markup,
// use gtk_entry_completion_insert_action_markup().
//
// Note that index_ is a relative position in the list of actions and the
// position of an action can change when deleting a different action.
//
// The function takes the following parameters:
//
//    - index_: index of the item to insert.
//    - text of the item to insert.
//
func (completion *EntryCompletion) InsertActionText(index_ int, text string) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out
	var _arg2 *C.gchar              // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.gint(index_)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_entry_completion_insert_action_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(index_)
	runtime.KeepAlive(text)
}

// SetMatchFunc sets the match function for completion to be func. The match
// function is used to determine if a row should or should not be in the
// completion list.
//
// The function takes the following parameters:
//
//    - fn to use.
//
func (completion *EntryCompletion) SetMatchFunc(fn EntryCompletionMatchFunc) {
	var _arg0 *C.GtkEntryCompletion         // out
	var _arg1 C.GtkEntryCompletionMatchFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk3_EntryCompletionMatchFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_entry_completion_set_match_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(fn)
}

// SetMinimumKeyLength requires the length of the search key for completion to
// be at least length. This is useful for long lists, where completing using a
// small key takes a lot of time and will come up with meaningless results
// anyway (ie, a too large dataset).
//
// The function takes the following parameters:
//
//    - length: minimum length of the key in order to start completing.
//
func (completion *EntryCompletion) SetMinimumKeyLength(length int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.gint(length)

	C.gtk_entry_completion_set_minimum_key_length(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(length)
}

// SetModel sets the model for a EntryCompletion. If completion already has a
// model set, it will remove it before setting the new model. If model is NULL,
// then it will unset the model.
//
// The function takes the following parameters:
//
//    - model (optional): TreeModel.
//
func (completion *EntryCompletion) SetModel(model TreeModeller) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 *C.GtkTreeModel       // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if model != nil {
		_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_entry_completion_set_model(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(model)
}

// SetTextColumn: convenience function for setting up the most used case of this
// code: a completion list with just strings. This function will set up
// completion to have a list displaying all (and just) strings in the completion
// list, and to get those strings from column in the model of completion.
//
// This functions creates and adds a CellRendererText for the selected column.
// If you need to set the text column, but don't want the cell renderer, use
// g_object_set() to set the EntryCompletion:text-column property directly.
//
// The function takes the following parameters:
//
//    - column in the model of completion to get strings from.
//
func (completion *EntryCompletion) SetTextColumn(column int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gint                // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.gint(column)

	C.gtk_entry_completion_set_text_column(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(column)
}

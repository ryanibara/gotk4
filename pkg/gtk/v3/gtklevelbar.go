// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_LevelBar_ConnectOffsetChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk3_LevelBarClass_offset_changed(GtkLevelBar*, gchar*);
// void _gotk4_gtk3_LevelBar_virtual_offset_changed(void* fnptr, GtkLevelBar* arg0, gchar* arg1) {
//   ((void (*)(GtkLevelBar*, gchar*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeLevelBar = coreglib.Type(C.gtk_level_bar_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeLevelBar, F: marshalLevelBar},
	})
}

// LevelBarOverrides contains methods that are overridable.
type LevelBarOverrides struct {
	// The function takes the following parameters:
	//
	OffsetChanged func(name string)
}

func defaultLevelBarOverrides(v *LevelBar) LevelBarOverrides {
	return LevelBarOverrides{
		OffsetChanged: v.offsetChanged,
	}
}

// LevelBar is a bar widget that can be used as a level indicator. Typical use
// cases are displaying the strength of a password, or showing the charge level
// of a battery.
//
// Use gtk_level_bar_set_value() to set the current value, and
// gtk_level_bar_add_offset_value() to set the value offsets at which the bar
// will be considered in a different state. GTK will add a few offsets by
// default on the level bar: K_LEVEL_BAR_OFFSET_LOW, K_LEVEL_BAR_OFFSET_HIGH and
// K_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK+ will simply clamp them to the new
// range.
//
// Adding a custom offset on the bar
//
//    levelbar[.discrete]
//    ╰── trough
//        ├── block.filled.level-name
//        ┊
//        ├── block.empty
//        ┊
//
// GtkLevelBar has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
type LevelBar struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*LevelBar)(nil)
	_ coreglib.Objector = (*LevelBar)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*LevelBar, *LevelBarClass, LevelBarOverrides](
		GTypeLevelBar,
		initLevelBarClass,
		wrapLevelBar,
		defaultLevelBarOverrides,
	)
}

func initLevelBarClass(gclass unsafe.Pointer, overrides LevelBarOverrides, classInitFunc func(*LevelBarClass)) {
	pclass := (*C.GtkLevelBarClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeLevelBar))))

	if overrides.OffsetChanged != nil {
		pclass.offset_changed = (*[0]byte)(C._gotk4_gtk3_LevelBarClass_offset_changed)
	}

	if classInitFunc != nil {
		class := (*LevelBarClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapLevelBar(obj *coreglib.Object) *LevelBar {
	return &LevelBar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	return wrapLevelBar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectOffsetChanged is emitted when an offset specified on the bar changes
// value as an effect to gtk_level_bar_add_offset_value() being called.
//
// The signal supports detailed connections; you can connect to the detailed
// signal "changed::x" in order to only receive callbacks when the value of
// offset "x" changes.
func (self *LevelBar) ConnectOffsetChanged(f func(name string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "offset-changed", false, unsafe.Pointer(C._gotk4_gtk3_LevelBar_ConnectOffsetChanged), f)
}

// The function takes the following parameters:
//
func (self *LevelBar) offsetChanged(name string) {
	gclass := (*C.GtkLevelBarClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.offset_changed

	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gtk3_LevelBar_virtual_offset_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
}

// LevelBarClass: instance of this type is always passed by reference.
type LevelBarClass struct {
	*levelBarClass
}

// levelBarClass is the struct that's finalized.
type levelBarClass struct {
	native *C.GtkLevelBarClass
}

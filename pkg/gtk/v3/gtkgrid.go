// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// GType values.
var (
	GTypeGrid = coreglib.Type(C.gtk_grid_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeGrid, F: marshalGrid},
	})
}

// GridOverrides contains methods that are overridable.
type GridOverrides struct {
}

func defaultGridOverrides(v *Grid) GridOverrides {
	return GridOverrides{}
}

// Grid is a container which arranges its child widgets in rows and columns,
// with arbitrary positions and horizontal/vertical spans.
//
// Children are added using gtk_grid_attach(). They can span multiple rows or
// columns. It is also possible to add a child next to an existing child, using
// gtk_grid_attach_next_to(). The behaviour of GtkGrid when several children
// occupy the same grid cell is undefined.
//
// GtkGrid can be used like a Box by just using gtk_container_add(), which will
// place children next to each other in the direction determined by the
// Orientable:orientation property. However, if all you want is a single row or
// column, then Box is the preferred widget.
//
//
// CSS nodes
//
// GtkGrid uses a single CSS node with name grid.
type Grid struct {
	_ [0]func() // equal guard
	Container

	*coreglib.Object
	Orientable
}

var (
	_ Containerer       = (*Grid)(nil)
	_ coreglib.Objector = (*Grid)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Grid, *GridClass, GridOverrides](
		GTypeGrid,
		initGridClass,
		wrapGrid,
		defaultGridOverrides,
	)
}

func initGridClass(gclass unsafe.Pointer, overrides GridOverrides, classInitFunc func(*GridClass)) {
	if classInitFunc != nil {
		class := (*GridClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGrid(obj *coreglib.Object) *Grid {
	return &Grid{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalGrid(p uintptr) (interface{}, error) {
	return wrapGrid(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGrid creates a new grid widget.
//
// The function returns the following values:
//
//    - grid: new Grid.
//
func NewGrid() *Grid {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_grid_new()

	var _grid *Grid // out

	_grid = wrapGrid(coreglib.Take(unsafe.Pointer(_cret)))

	return _grid
}

// Attach adds a widget to the grid.
//
// The position of child is determined by left and top. The number of “cells”
// that child will occupy is determined by width and height.
//
// The function takes the following parameters:
//
//    - child: widget to add.
//    - left: column number to attach the left side of child to.
//    - top: row number to attach the top side of child to.
//    - width: number of columns that child will span.
//    - height: number of rows that child will span.
//
func (grid *Grid) Attach(child Widgetter, left, top, width, height int) {
	var _arg0 *C.GtkGrid   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.gint       // out
	var _arg3 C.gint       // out
	var _arg4 C.gint       // out
	var _arg5 C.gint       // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.gint(left)
	_arg3 = C.gint(top)
	_arg4 = C.gint(width)
	_arg5 = C.gint(height)

	C.gtk_grid_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(child)
	runtime.KeepAlive(left)
	runtime.KeepAlive(top)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// AttachNextTo adds a widget to the grid.
//
// The widget is placed next to sibling, on the side determined by side. When
// sibling is NULL, the widget is placed in row (for left or right placement) or
// column 0 (for top or bottom placement), at the end indicated by side.
//
// Attaching widgets labeled [1], [2], [3] with sibling == NULL and side ==
// GTK_POS_LEFT yields a layout of [3][2][1].
//
// The function takes the following parameters:
//
//    - child: widget to add.
//    - sibling (optional): child of grid that child will be placed next to, or
//      NULL to place child at the beginning or end.
//    - side of sibling that child is positioned next to.
//    - width: number of columns that child will span.
//    - height: number of rows that child will span.
//
func (grid *Grid) AttachNextTo(child, sibling Widgetter, side PositionType, width, height int) {
	var _arg0 *C.GtkGrid        // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 *C.GtkWidget      // out
	var _arg3 C.GtkPositionType // out
	var _arg4 C.gint            // out
	var _arg5 C.gint            // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))
	}
	_arg3 = C.GtkPositionType(side)
	_arg4 = C.gint(width)
	_arg5 = C.gint(height)

	C.gtk_grid_attach_next_to(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
	runtime.KeepAlive(side)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// ColumnHomogeneous returns whether all columns of grid have the same width.
//
// The function returns the following values:
//
//    - ok: whether all columns of grid have the same width.
//
func (grid *Grid) ColumnHomogeneous() bool {
	var _arg0 *C.GtkGrid // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_column_homogeneous(_arg0)
	runtime.KeepAlive(grid)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColumnSpacing returns the amount of space between the columns of grid.
//
// The function returns the following values:
//
//    - guint: column spacing of grid.
//
func (grid *Grid) ColumnSpacing() uint {
	var _arg0 *C.GtkGrid // out
	var _cret C.guint    // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_column_spacing(_arg0)
	runtime.KeepAlive(grid)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RowHomogeneous returns whether all rows of grid have the same height.
//
// The function returns the following values:
//
//    - ok: whether all rows of grid have the same height.
//
func (grid *Grid) RowHomogeneous() bool {
	var _arg0 *C.GtkGrid // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_row_homogeneous(_arg0)
	runtime.KeepAlive(grid)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowSpacing returns the amount of space between the rows of grid.
//
// The function returns the following values:
//
//    - guint: row spacing of grid.
//
func (grid *Grid) RowSpacing() uint {
	var _arg0 *C.GtkGrid // out
	var _cret C.guint    // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_row_spacing(_arg0)
	runtime.KeepAlive(grid)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetColumnHomogeneous sets whether all columns of grid will have the same
// width.
//
// The function takes the following parameters:
//
//    - homogeneous: TRUE to make columns homogeneous.
//
func (grid *Grid) SetColumnHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_set_column_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(homogeneous)
}

// SetColumnSpacing sets the amount of space between columns of grid.
//
// The function takes the following parameters:
//
//    - spacing: amount of space to insert between columns.
//
func (grid *Grid) SetColumnSpacing(spacing uint) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_grid_set_column_spacing(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(spacing)
}

// SetRowHomogeneous sets whether all rows of grid will have the same height.
//
// The function takes the following parameters:
//
//    - homogeneous: TRUE to make rows homogeneous.
//
func (grid *Grid) SetRowHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_set_row_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(homogeneous)
}

// SetRowSpacing sets the amount of space between rows of grid.
//
// The function takes the following parameters:
//
//    - spacing: amount of space to insert between rows.
//
func (grid *Grid) SetRowSpacing(spacing uint) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_grid_set_row_spacing(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(spacing)
}

// GridClass: instance of this type is always passed by reference.
type GridClass struct {
	*gridClass
}

// gridClass is the struct that's finalized.
type gridClass struct {
	native *C.GtkGridClass
}

// ParentClass: parent class.
func (g *GridClass) ParentClass() *ContainerClass {
	valptr := &g.native.parent_class
	var _v *ContainerClass // out
	_v = (*ContainerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_MenuShell_ConnectSelectionDone(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectMoveCurrent(gpointer, GtkMenuDirectionType, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectInsert(gpointer, GtkWidget*, gint, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectDeactivate(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectCycleFocus(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectCancel(gpointer, guintptr);
// extern void _gotk4_gtk3_MenuShell_ConnectActivateCurrent(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk3_MenuShellClass_selection_done(GtkMenuShell*);
// extern void _gotk4_gtk3_MenuShellClass_select_item(GtkMenuShell*, GtkWidget*);
// extern void _gotk4_gtk3_MenuShellClass_move_current(GtkMenuShell*, GtkMenuDirectionType);
// extern void _gotk4_gtk3_MenuShellClass_insert(GtkMenuShell*, GtkWidget*, gint);
// extern void _gotk4_gtk3_MenuShellClass_deactivate(GtkMenuShell*);
// extern void _gotk4_gtk3_MenuShellClass_cancel(GtkMenuShell*);
// extern void _gotk4_gtk3_MenuShellClass_activate_current(GtkMenuShell*, gboolean);
// extern gint _gotk4_gtk3_MenuShellClass_get_popup_delay(GtkMenuShell*);
// extern gboolean _gotk4_gtk3_MenuShell_ConnectMoveSelected(gpointer, gint, guintptr);
// extern gboolean _gotk4_gtk3_MenuShellClass_move_selected(GtkMenuShell*, gint);
// gboolean _gotk4_gtk3_MenuShell_virtual_move_selected(void* fnptr, GtkMenuShell* arg0, gint arg1) {
//   return ((gboolean (*)(GtkMenuShell*, gint))(fnptr))(arg0, arg1);
// };
// gint _gotk4_gtk3_MenuShell_virtual_get_popup_delay(void* fnptr, GtkMenuShell* arg0) {
//   return ((gint (*)(GtkMenuShell*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_MenuShell_virtual_activate_current(void* fnptr, GtkMenuShell* arg0, gboolean arg1) {
//   ((void (*)(GtkMenuShell*, gboolean))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_MenuShell_virtual_deactivate(void* fnptr, GtkMenuShell* arg0) {
//   ((void (*)(GtkMenuShell*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_MenuShell_virtual_insert(void* fnptr, GtkMenuShell* arg0, GtkWidget* arg1, gint arg2) {
//   ((void (*)(GtkMenuShell*, GtkWidget*, gint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_MenuShell_virtual_move_current(void* fnptr, GtkMenuShell* arg0, GtkMenuDirectionType arg1) {
//   ((void (*)(GtkMenuShell*, GtkMenuDirectionType))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_MenuShell_virtual_select_item(void* fnptr, GtkMenuShell* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkMenuShell*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_MenuShell_virtual_selection_done(void* fnptr, GtkMenuShell* arg0) {
//   ((void (*)(GtkMenuShell*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeMenuShell = coreglib.Type(C.gtk_menu_shell_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeMenuShell, F: marshalMenuShell},
	})
}

// MenuShellOverrides contains methods that are overridable.
type MenuShellOverrides struct {
	// The function takes the following parameters:
	//
	ActivateCurrent func(forceHide bool)
	// Cancel cancels the selection within the menu shell.
	Cancel func()
	// Deactivate deactivates the menu shell.
	//
	// Typically this results in the menu shell being erased from the screen.
	Deactivate func()
	// The function returns the following values:
	//
	PopupDelay func() int
	// Insert adds a new MenuItem to the menu shell’s item list at the position
	// indicated by position.
	//
	// The function takes the following parameters:
	//
	//    - child to add.
	//    - position in the item list where child is added. Positions are
	//      numbered from 0 to n-1.
	//
	Insert func(child Widgetter, position int)
	// The function takes the following parameters:
	//
	MoveCurrent func(direction MenuDirectionType)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	MoveSelected func(distance int) bool
	// SelectItem selects the menu item from the menu shell.
	//
	// The function takes the following parameters:
	//
	//    - menuItem to select.
	//
	SelectItem    func(menuItem Widgetter)
	SelectionDone func()
}

func defaultMenuShellOverrides(v *MenuShell) MenuShellOverrides {
	return MenuShellOverrides{
		ActivateCurrent: v.activateCurrent,
		Cancel:          v.cancel,
		Deactivate:      v.deactivate,
		PopupDelay:      v.popupDelay,
		Insert:          v.insert,
		MoveCurrent:     v.moveCurrent,
		MoveSelected:    v.moveSelected,
		SelectItem:      v.selectItem,
		SelectionDone:   v.selectionDone,
	}
}

// MenuShell is the abstract base class used to derive the Menu and MenuBar
// subclasses.
//
// A MenuShell is a container of MenuItem objects arranged in a list which can
// be navigated, selected, and activated by the user to perform application
// functions. A MenuItem can have a submenu associated with it, allowing for
// nested hierarchical menus.
//
//
// Terminology
//
// A menu item can be “selected”, this means that it is displayed in the
// prelight state, and if it has a submenu, that submenu will be popped up.
//
// A menu is “active” when it is visible onscreen and the user is selecting from
// it. A menubar is not active until the user clicks on one of its menuitems.
// When a menu is active, passing the mouse over a submenu will pop it up.
//
// There is also is a concept of the current menu and a current menu item. The
// current menu item is the selected menu item that is furthest down in the
// hierarchy. (Every active menu shell does not necessarily contain a selected
// menu item, but if it does, then the parent menu shell must also contain a
// selected menu item.) The current menu is the menu that contains the current
// menu item. It will always have a GTK grab and receive all key presses.
type MenuShell struct {
	_ [0]func() // equal guard
	Container
}

var (
	_ Containerer = (*MenuShell)(nil)
)

// MenuSheller describes types inherited from class MenuShell.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MenuSheller interface {
	coreglib.Objector
	baseMenuShell() *MenuShell
}

var _ MenuSheller = (*MenuShell)(nil)

func init() {
	coreglib.RegisterClassInfo[*MenuShell, *MenuShellClass, MenuShellOverrides](
		GTypeMenuShell,
		initMenuShellClass,
		wrapMenuShell,
		defaultMenuShellOverrides,
	)
}

func initMenuShellClass(gclass unsafe.Pointer, overrides MenuShellOverrides, classInitFunc func(*MenuShellClass)) {
	pclass := (*C.GtkMenuShellClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeMenuShell))))

	if overrides.ActivateCurrent != nil {
		pclass.activate_current = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_activate_current)
	}

	if overrides.Cancel != nil {
		pclass.cancel = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_cancel)
	}

	if overrides.Deactivate != nil {
		pclass.deactivate = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_deactivate)
	}

	if overrides.PopupDelay != nil {
		pclass.get_popup_delay = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_get_popup_delay)
	}

	if overrides.Insert != nil {
		pclass.insert = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_insert)
	}

	if overrides.MoveCurrent != nil {
		pclass.move_current = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_move_current)
	}

	if overrides.MoveSelected != nil {
		pclass.move_selected = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_move_selected)
	}

	if overrides.SelectItem != nil {
		pclass.select_item = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_select_item)
	}

	if overrides.SelectionDone != nil {
		pclass.selection_done = (*[0]byte)(C._gotk4_gtk3_MenuShellClass_selection_done)
	}

	if classInitFunc != nil {
		class := (*MenuShellClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMenuShell(obj *coreglib.Object) *MenuShell {
	return &MenuShell{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalMenuShell(p uintptr) (interface{}, error) {
	return wrapMenuShell(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (menuShell *MenuShell) baseMenuShell() *MenuShell {
	return menuShell
}

// BaseMenuShell returns the underlying base object.
func BaseMenuShell(obj MenuSheller) *MenuShell {
	return obj.baseMenuShell()
}

// ConnectActivateCurrent: action signal that activates the current menu item
// within the menu shell.
func (menuShell *MenuShell) ConnectActivateCurrent(f func(forceHide bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(menuShell, "activate-current", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectActivateCurrent), f)
}

// ConnectCancel: action signal which cancels the selection within the menu
// shell. Causes the MenuShell::selection-done signal to be emitted.
func (menuShell *MenuShell) ConnectCancel(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(menuShell, "cancel", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectCancel), f)
}

// ConnectCycleFocus: keybinding signal which moves the focus in the given
// direction.
func (menuShell *MenuShell) ConnectCycleFocus(f func(direction DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(menuShell, "cycle-focus", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectCycleFocus), f)
}

// ConnectDeactivate: this signal is emitted when a menu shell is deactivated.
func (menuShell *MenuShell) ConnectDeactivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(menuShell, "deactivate", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectDeactivate), f)
}

// ConnectInsert signal is emitted when a new MenuItem is added to a MenuShell.
// A separate signal is used instead of GtkContainer::add because of the need
// for an additional position parameter.
//
// The inverse of this signal is the GtkContainer::removed signal.
func (menuShell *MenuShell) ConnectInsert(f func(child Widgetter, position int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(menuShell, "insert", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectInsert), f)
}

// ConnectMoveCurrent: keybinding signal which moves the current menu item in
// the direction specified by direction.
func (menuShell *MenuShell) ConnectMoveCurrent(f func(direction MenuDirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(menuShell, "move-current", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectMoveCurrent), f)
}

// ConnectMoveSelected signal is emitted to move the selection to another item.
func (menuShell *MenuShell) ConnectMoveSelected(f func(distance int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(menuShell, "move-selected", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectMoveSelected), f)
}

// ConnectSelectionDone: this signal is emitted when a selection has been
// completed within a menu shell.
func (menuShell *MenuShell) ConnectSelectionDone(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(menuShell, "selection-done", false, unsafe.Pointer(C._gotk4_gtk3_MenuShell_ConnectSelectionDone), f)
}

// ActivateItem activates the menu item within the menu shell.
//
// The function takes the following parameters:
//
//    - menuItem to activate.
//    - forceDeactivate: if TRUE, force the deactivation of the menu shell after
//      the menu item is activated.
//
func (menuShell *MenuShell) ActivateItem(menuItem Widgetter, forceDeactivate bool) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	if forceDeactivate {
		_arg2 = C.TRUE
	}

	C.gtk_menu_shell_activate_item(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(menuItem)
	runtime.KeepAlive(forceDeactivate)
}

// Append adds a new MenuItem to the end of the menu shell's item list.
//
// The function takes the following parameters:
//
//    - child to add.
//
func (menuShell *MenuShell) Append(child *MenuItem) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_menu_shell_append(_arg0, _arg1)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(child)
}

// Deactivate deactivates the menu shell.
//
// Typically this results in the menu shell being erased from the screen.
func (menuShell *MenuShell) Deactivate() {
	var _arg0 *C.GtkMenuShell // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))

	C.gtk_menu_shell_deactivate(_arg0)
	runtime.KeepAlive(menuShell)
}

// Deselect deselects the currently selected item from the menu shell, if any.
func (menuShell *MenuShell) Deselect() {
	var _arg0 *C.GtkMenuShell // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))

	C.gtk_menu_shell_deselect(_arg0)
	runtime.KeepAlive(menuShell)
}

// Insert adds a new MenuItem to the menu shell’s item list at the position
// indicated by position.
//
// The function takes the following parameters:
//
//    - child to add.
//    - position in the item list where child is added. Positions are numbered
//      from 0 to n-1.
//
func (menuShell *MenuShell) Insert(child Widgetter, position int) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gint          // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.gint(position)

	C.gtk_menu_shell_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)
}

// Prepend adds a new MenuItem to the beginning of the menu shell's item list.
//
// The function takes the following parameters:
//
//    - child to add.
//
func (menuShell *MenuShell) Prepend(child Widgetter) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_menu_shell_prepend(_arg0, _arg1)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(child)
}

// SelectItem selects the menu item from the menu shell.
//
// The function takes the following parameters:
//
//    - menuItem to select.
//
func (menuShell *MenuShell) SelectItem(menuItem Widgetter) {
	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))

	C.gtk_menu_shell_select_item(_arg0, _arg1)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(menuItem)
}

// The function takes the following parameters:
//
func (menuShell *MenuShell) activateCurrent(forceHide bool) {
	gclass := (*C.GtkMenuShellClass)(coreglib.PeekParentClass(menuShell))
	fnarg := gclass.activate_current

	var _arg0 *C.GtkMenuShell // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	if forceHide {
		_arg1 = C.TRUE
	}

	C._gotk4_gtk3_MenuShell_virtual_activate_current(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(forceHide)
}

// Deactivate deactivates the menu shell.
//
// Typically this results in the menu shell being erased from the screen.
func (menuShell *MenuShell) deactivate() {
	gclass := (*C.GtkMenuShellClass)(coreglib.PeekParentClass(menuShell))
	fnarg := gclass.deactivate

	var _arg0 *C.GtkMenuShell // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))

	C._gotk4_gtk3_MenuShell_virtual_deactivate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(menuShell)
}

// The function returns the following values:
//
func (menuShell *MenuShell) popupDelay() int {
	gclass := (*C.GtkMenuShellClass)(coreglib.PeekParentClass(menuShell))
	fnarg := gclass.get_popup_delay

	var _arg0 *C.GtkMenuShell // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))

	_cret = C._gotk4_gtk3_MenuShell_virtual_get_popup_delay(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(menuShell)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Insert adds a new MenuItem to the menu shell’s item list at the position
// indicated by position.
//
// The function takes the following parameters:
//
//    - child to add.
//    - position in the item list where child is added. Positions are numbered
//      from 0 to n-1.
//
func (menuShell *MenuShell) insert(child Widgetter, position int) {
	gclass := (*C.GtkMenuShellClass)(coreglib.PeekParentClass(menuShell))
	fnarg := gclass.insert

	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gint          // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.gint(position)

	C._gotk4_gtk3_MenuShell_virtual_insert(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)
}

// The function takes the following parameters:
//
func (menuShell *MenuShell) moveCurrent(direction MenuDirectionType) {
	gclass := (*C.GtkMenuShellClass)(coreglib.PeekParentClass(menuShell))
	fnarg := gclass.move_current

	var _arg0 *C.GtkMenuShell        // out
	var _arg1 C.GtkMenuDirectionType // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = C.GtkMenuDirectionType(direction)

	C._gotk4_gtk3_MenuShell_virtual_move_current(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(direction)
}

// The function takes the following parameters:
//
// The function returns the following values:
//
func (menuShell *MenuShell) moveSelected(distance int) bool {
	gclass := (*C.GtkMenuShellClass)(coreglib.PeekParentClass(menuShell))
	fnarg := gclass.move_selected

	var _arg0 *C.GtkMenuShell // out
	var _arg1 C.gint          // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = C.gint(distance)

	_cret = C._gotk4_gtk3_MenuShell_virtual_move_selected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(distance)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// selectItem selects the menu item from the menu shell.
//
// The function takes the following parameters:
//
//    - menuItem to select.
//
func (menuShell *MenuShell) selectItem(menuItem Widgetter) {
	gclass := (*C.GtkMenuShellClass)(coreglib.PeekParentClass(menuShell))
	fnarg := gclass.select_item

	var _arg0 *C.GtkMenuShell // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))

	C._gotk4_gtk3_MenuShell_virtual_select_item(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(menuShell)
	runtime.KeepAlive(menuItem)
}

func (menuShell *MenuShell) selectionDone() {
	gclass := (*C.GtkMenuShellClass)(coreglib.PeekParentClass(menuShell))
	fnarg := gclass.selection_done

	var _arg0 *C.GtkMenuShell // out

	_arg0 = (*C.GtkMenuShell)(unsafe.Pointer(coreglib.InternObject(menuShell).Native()))

	C._gotk4_gtk3_MenuShell_virtual_selection_done(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(menuShell)
}

// MenuShellClass: instance of this type is always passed by reference.
type MenuShellClass struct {
	*menuShellClass
}

// menuShellClass is the struct that's finalized.
type menuShellClass struct {
	native *C.GtkMenuShellClass
}

func (m *MenuShellClass) ParentClass() *ContainerClass {
	valptr := &m.native.parent_class
	var _v *ContainerClass // out
	_v = (*ContainerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

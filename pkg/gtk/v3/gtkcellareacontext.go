// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_CellAreaContextClass_reset(GtkCellAreaContext*);
// extern void _gotk4_gtk3_CellAreaContextClass_get_preferred_width_for_height(GtkCellAreaContext*, gint, gint*, gint*);
// extern void _gotk4_gtk3_CellAreaContextClass_get_preferred_height_for_width(GtkCellAreaContext*, gint, gint*, gint*);
// extern void _gotk4_gtk3_CellAreaContextClass_allocate(GtkCellAreaContext*, gint, gint);
// void _gotk4_gtk3_CellAreaContext_virtual_allocate(void* fnptr, GtkCellAreaContext* arg0, gint arg1, gint arg2) {
//   ((void (*)(GtkCellAreaContext*, gint, gint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_CellAreaContext_virtual_reset(void* fnptr, GtkCellAreaContext* arg0) {
//   ((void (*)(GtkCellAreaContext*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeCellAreaContext = coreglib.Type(C.gtk_cell_area_context_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCellAreaContext, F: marshalCellAreaContext},
	})
}

// CellAreaContextOverrides contains methods that are overridable.
type CellAreaContextOverrides struct {
	// Allocate allocates a width and/or a height for all rows which are to be
	// rendered with context.
	//
	// Usually allocation is performed only horizontally or sometimes vertically
	// since a group of rows are usually rendered side by side vertically or
	// horizontally and share either the same width or the same height.
	// Sometimes they are allocated in both horizontal and vertical orientations
	// producing a homogeneous effect of the rows. This is generally the case
	// for TreeView when TreeView:fixed-height-mode is enabled.
	//
	// Since 3.0.
	//
	// The function takes the following parameters:
	//
	//    - width: allocated width for all TreeModel rows rendered with context,
	//      or -1.
	//    - height: allocated height for all TreeModel rows rendered with
	//      context, or -1.
	//
	Allocate func(width, height int)
	// PreferredHeightForWidth gets the accumulative preferred height for width
	// for all rows which have been requested for the same said width with this
	// context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	//
	// The function takes the following parameters:
	//
	//    - width: proposed width for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location to store the minimum height, or
	//      NULL.
	//    - naturalHeight (optional): location to store the natural height, or
	//      NULL.
	//
	PreferredHeightForWidth func(width int) (minimumHeight, naturalHeight int)
	// PreferredWidthForHeight gets the accumulative preferred width for height
	// for all rows which have been requested for the same said height with this
	// context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	//
	// The function takes the following parameters:
	//
	//    - height: proposed height for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location to store the minimum width, or
	//      NULL.
	//    - naturalWidth (optional): location to store the natural width, or
	//      NULL.
	//
	PreferredWidthForHeight func(height int) (minimumWidth, naturalWidth int)
	// Reset resets any previously cached request and allocation data.
	//
	// When underlying TreeModel data changes its important to reset the context
	// if the content size is allowed to shrink. If the content size is only
	// allowed to grow (this is usually an option for views rendering large data
	// stores as a measure of optimization), then only the row that changed or
	// was inserted needs to be (re)requested with
	// gtk_cell_area_get_preferred_width().
	//
	// When the new overall size of the context requires that the allocated size
	// changes (or whenever this allocation changes at all), the variable row
	// sizes need to be re-requested for every row.
	//
	// For instance, if the rows are displayed all with the same width from top
	// to bottom then a change in the allocated width necessitates a
	// recalculation of all the displayed row heights using
	// gtk_cell_area_get_preferred_height_for_width().
	//
	// Since 3.0.
	Reset func()
}

func defaultCellAreaContextOverrides(v *CellAreaContext) CellAreaContextOverrides {
	return CellAreaContextOverrides{
		Allocate:                v.allocate,
		PreferredHeightForWidth: v.preferredHeightForWidth,
		PreferredWidthForHeight: v.preferredWidthForHeight,
		Reset:                   v.reset,
	}
}

// CellAreaContext object is created by a given CellArea implementation via its
// CellAreaClass.create_context() virtual method and is used to store cell sizes
// and alignments for a series of TreeModel rows that are requested and rendered
// in the same context.
//
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, itâ€™s important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
type CellAreaContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*CellAreaContext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CellAreaContext, *CellAreaContextClass, CellAreaContextOverrides](
		GTypeCellAreaContext,
		initCellAreaContextClass,
		wrapCellAreaContext,
		defaultCellAreaContextOverrides,
	)
}

func initCellAreaContextClass(gclass unsafe.Pointer, overrides CellAreaContextOverrides, classInitFunc func(*CellAreaContextClass)) {
	pclass := (*C.GtkCellAreaContextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCellAreaContext))))

	if overrides.Allocate != nil {
		pclass.allocate = (*[0]byte)(C._gotk4_gtk3_CellAreaContextClass_allocate)
	}

	if overrides.PreferredHeightForWidth != nil {
		pclass.get_preferred_height_for_width = (*[0]byte)(C._gotk4_gtk3_CellAreaContextClass_get_preferred_height_for_width)
	}

	if overrides.PreferredWidthForHeight != nil {
		pclass.get_preferred_width_for_height = (*[0]byte)(C._gotk4_gtk3_CellAreaContextClass_get_preferred_width_for_height)
	}

	if overrides.Reset != nil {
		pclass.reset = (*[0]byte)(C._gotk4_gtk3_CellAreaContextClass_reset)
	}

	if classInitFunc != nil {
		class := (*CellAreaContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCellAreaContext(obj *coreglib.Object) *CellAreaContext {
	return &CellAreaContext{
		Object: obj,
	}
}

func marshalCellAreaContext(p uintptr) (interface{}, error) {
	return wrapCellAreaContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Allocate allocates a width and/or a height for all rows which are to be
// rendered with context.
//
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height. Sometimes
// they are allocated in both horizontal and vertical orientations producing a
// homogeneous effect of the rows. This is generally the case for TreeView when
// TreeView:fixed-height-mode is enabled.
//
// Since 3.0.
//
// The function takes the following parameters:
//
//    - width: allocated width for all TreeModel rows rendered with context, or
//      -1.
//    - height: allocated height for all TreeModel rows rendered with context, or
//      -1.
//
func (context *CellAreaContext) Allocate(width, height int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // out
	var _arg2 C.gint                // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C.gtk_cell_area_context_allocate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// Reset resets any previously cached request and allocation data.
//
// When underlying TreeModel data changes its important to reset the context if
// the content size is allowed to shrink. If the content size is only allowed to
// grow (this is usually an option for views rendering large data stores as a
// measure of optimization), then only the row that changed or was inserted
// needs to be (re)requested with gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row sizes
// need to be re-requested for every row.
//
// For instance, if the rows are displayed all with the same width from top to
// bottom then a change in the allocated width necessitates a recalculation of
// all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
//
// Since 3.0.
func (context *CellAreaContext) Reset() {
	var _arg0 *C.GtkCellAreaContext // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_cell_area_context_reset(_arg0)
	runtime.KeepAlive(context)
}

// Allocate allocates a width and/or a height for all rows which are to be
// rendered with context.
//
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height. Sometimes
// they are allocated in both horizontal and vertical orientations producing a
// homogeneous effect of the rows. This is generally the case for TreeView when
// TreeView:fixed-height-mode is enabled.
//
// Since 3.0.
//
// The function takes the following parameters:
//
//    - width: allocated width for all TreeModel rows rendered with context, or
//      -1.
//    - height: allocated height for all TreeModel rows rendered with context, or
//      -1.
//
func (context *CellAreaContext) allocate(width, height int) {
	gclass := (*C.GtkCellAreaContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.allocate

	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.gint                // out
	var _arg2 C.gint                // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	C._gotk4_gtk3_CellAreaContext_virtual_allocate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// Reset resets any previously cached request and allocation data.
//
// When underlying TreeModel data changes its important to reset the context if
// the content size is allowed to shrink. If the content size is only allowed to
// grow (this is usually an option for views rendering large data stores as a
// measure of optimization), then only the row that changed or was inserted
// needs to be (re)requested with gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row sizes
// need to be re-requested for every row.
//
// For instance, if the rows are displayed all with the same width from top to
// bottom then a change in the allocated width necessitates a recalculation of
// all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
//
// Since 3.0.
func (context *CellAreaContext) reset() {
	gclass := (*C.GtkCellAreaContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.reset

	var _arg0 *C.GtkCellAreaContext // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk3_CellAreaContext_virtual_reset(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// CellAreaContextClass: instance of this type is always passed by reference.
type CellAreaContextClass struct {
	*cellAreaContextClass
}

// cellAreaContextClass is the struct that's finalized.
type cellAreaContextClass struct {
	native *C.GtkCellAreaContextClass
}

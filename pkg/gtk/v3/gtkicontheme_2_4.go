// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// AttachPoints: this function is deprecated and always returns FALSE.
//
// Deprecated: Attachment points are deprecated.
//
// The function returns the following values:
//
//    - points (optional): location to store pointer to an array of points, or
//      NULL free the array of points with g_free().
//    - ok: FALSE.
//
func (iconInfo *IconInfo) AttachPoints() ([]gdk.Point, bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 *C.GdkPoint    // in
	var _arg2 C.gint         // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))

	_cret = C.gtk_icon_info_get_attach_points(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconInfo)

	var _points []gdk.Point // out
	var _ok bool            // out

	if _arg1 != nil {
		defer C.free(unsafe.Pointer(_arg1))
		{
			src := unsafe.Slice((*C.GdkPoint)(_arg1), _arg2)
			_points = make([]gdk.Point, _arg2)
			for i := 0; i < int(_arg2); i++ {
				_points[i] = *(*gdk.Point)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
				runtime.SetFinalizer(
					gextras.StructIntern(unsafe.Pointer(&_points[i])),
					func(intern *struct{ C unsafe.Pointer }) {
						C.free(intern.C)
					},
				)
			}
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _points, _ok
}

// BaseSize gets the base size for the icon. The base size is a size for the
// icon that was specified by the icon theme creator. This may be different than
// the actual size of image; an example of this is small emblem icons that can
// be attached to a larger icon. These icons will be given the same base size as
// the larger icons to which they are attached.
//
// Note that for scaled icons the base size does not include the base scale.
//
// The function returns the following values:
//
//    - gint: base size, or 0, if no base size is known for the icon.
//
func (iconInfo *IconInfo) BaseSize() int {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))

	_cret = C.gtk_icon_info_get_base_size(_arg0)
	runtime.KeepAlive(iconInfo)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// BuiltinPixbuf gets the built-in image for this icon, if any. To allow GTK+ to
// use built in icon images, you must pass the GTK_ICON_LOOKUP_USE_BUILTIN to
// gtk_icon_theme_lookup_icon().
//
// Deprecated: This function is deprecated, use
// gtk_icon_theme_add_resource_path() instead of builtin icons.
//
// The function returns the following values:
//
//    - pixbuf (optional): built-in image pixbuf, or NULL. No extra reference is
//      added to the returned pixbuf, so if you want to keep it around, you must
//      use g_object_ref(). The returned image must not be modified.
//
func (iconInfo *IconInfo) BuiltinPixbuf() *gdkpixbuf.Pixbuf {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.GdkPixbuf   // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))

	_cret = C.gtk_icon_info_get_builtin_pixbuf(_arg0)
	runtime.KeepAlive(iconInfo)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// DisplayName: this function is deprecated and always returns NULL.
//
// Deprecated: Display names are deprecated.
//
// The function returns the following values:
//
//    - utf8: NULL.
//
func (iconInfo *IconInfo) DisplayName() string {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))

	_cret = C.gtk_icon_info_get_display_name(_arg0)
	runtime.KeepAlive(iconInfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EmbeddedRect: this function is deprecated and always returns FALSE.
//
// Deprecated: Embedded rectangles are deprecated.
//
// The function returns the following values:
//
//    - rectangle in which to store embedded rectangle coordinates; coordinates
//      are only stored when this function returns TRUE.
//    - ok: FALSE.
//
func (iconInfo *IconInfo) EmbeddedRect() (*gdk.Rectangle, bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 C.GdkRectangle // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))

	_cret = C.gtk_icon_info_get_embedded_rect(_arg0, &_arg1)
	runtime.KeepAlive(iconInfo)

	var _rectangle *gdk.Rectangle // out
	var _ok bool                  // out

	_rectangle = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _rectangle, _ok
}

// Filename gets the filename for the icon. If the GTK_ICON_LOOKUP_USE_BUILTIN
// flag was passed to gtk_icon_theme_lookup_icon(), there may be no filename if
// a builtin icon is returned; in this case, you should use
// gtk_icon_info_get_builtin_pixbuf().
//
// The function returns the following values:
//
//    - filename (optional) for the icon, or NULL if
//      gtk_icon_info_get_builtin_pixbuf() should be used instead. The return
//      value is owned by GTK+ and should not be modified or freed.
//
func (iconInfo *IconInfo) Filename() string {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))

	_cret = C.gtk_icon_info_get_filename(_arg0)
	runtime.KeepAlive(iconInfo)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// LoadIcon renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
//
// The function returns the following values:
//
//    - pixbuf: rendered icon; this may be a newly created icon or a new
//      reference to an internal icon, so you must not modify the icon. Use
//      g_object_unref() to release your reference to the icon.
//
func (iconInfo *IconInfo) LoadIcon() (*gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconInfo // out
	var _cret *C.GdkPixbuf   // in
	var _cerr *C.GError      // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))

	_cret = C.gtk_icon_info_load_icon(_arg0, &_cerr)
	runtime.KeepAlive(iconInfo)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// SetRawCoordinates sets whether the coordinates returned by
// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
// should be returned in their original form as specified in the icon theme,
// instead of scaled appropriately for the pixbuf returned by
// gtk_icon_info_load_icon().
//
// Raw coordinates are somewhat strange; they are specified to be with respect
// to the unscaled pixmap for PNG and XPM icons, but for SVG icons, they are in
// a 1000x1000 coordinate space that is scaled to the final size of the icon.
// You can determine if the icon is an SVG icon by using
// gtk_icon_info_get_filename(), and seeing if it is non-NULL and ends in
// “.svg”.
//
// This function is provided primarily to allow compatibility wrappers for older
// API's, and is not expected to be useful for applications.
//
// Deprecated: Embedded rectangles and attachment points are deprecated.
//
// The function takes the following parameters:
//
//    - rawCoordinates: whether the coordinates of embedded rectangles and
//      attached points should be returned in their original (unscaled) form.
//
func (iconInfo *IconInfo) SetRawCoordinates(rawCoordinates bool) {
	var _arg0 *C.GtkIconInfo // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	if rawCoordinates {
		_arg1 = C.TRUE
	}

	C.gtk_icon_info_set_raw_coordinates(_arg0, _arg1)
	runtime.KeepAlive(iconInfo)
	runtime.KeepAlive(rawCoordinates)
}

// NewIconTheme creates a new icon theme object. Icon theme objects are used to
// lookup up an icon by name in a particular icon theme. Usually, you’ll want to
// use gtk_icon_theme_get_default() or gtk_icon_theme_get_for_screen() rather
// than creating a new icon theme object for scratch.
//
// The function returns the following values:
//
//    - iconTheme: newly created IconTheme object.
//
func NewIconTheme() *IconTheme {
	var _cret *C.GtkIconTheme // in

	_cret = C.gtk_icon_theme_new()

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconTheme
}

// AppendSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
//
// The function takes the following parameters:
//
//    - path: directory name to append to the icon path.
//
func (iconTheme *IconTheme) AppendSearchPath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_append_search_path(_arg0, _arg1)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(path)
}

// ExampleIconName gets the name of an icon that is representative of the
// current theme (for instance, to use when presenting a list of themes to the
// user.).
//
// The function returns the following values:
//
//    - utf8 (optional): name of an example icon or NULL. Free with g_free().
//
func (iconTheme *IconTheme) ExampleIconName() string {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))

	_cret = C.gtk_icon_theme_get_example_icon_name(_arg0)
	runtime.KeepAlive(iconTheme)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// SearchPath gets the current search path. See
// gtk_icon_theme_set_search_path().
//
// The function returns the following values:
//
//    - path (optional): location to store a list of icon theme path directories
//      or NULL. The stored value should be freed with g_strfreev().
//
func (iconTheme *IconTheme) SearchPath() []string {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar       // in
	var _arg2 C.gint          // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))

	C.gtk_icon_theme_get_search_path(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconTheme)

	var _path []string // out

	if _arg1 != nil {
		defer C.free(unsafe.Pointer(_arg1))
		{
			src := unsafe.Slice((**C.gchar)(_arg1), _arg2)
			_path = make([]string, _arg2)
			for i := 0; i < int(_arg2); i++ {
				_path[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _path
}

// HasIcon checks whether an icon theme includes an icon for a particular name.
//
// The function takes the following parameters:
//
//    - iconName: name of an icon.
//
// The function returns the following values:
//
//    - ok: TRUE if icon_theme includes an icon for icon_name.
//
func (iconTheme *IconTheme) HasIcon(iconName string) bool {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListIcons lists the icons in the current icon theme. Only a subset of the
// icons can be listed by providing a context string. The set of values for the
// context string is system dependent, but will typically include such values as
// “Applications” and “MimeTypes”. Contexts are explained in the Icon Theme
// Specification
// (http://www.freedesktop.org/wiki/Specifications/icon-theme-spec). The
// standard contexts are listed in the Icon Naming Specification
// (http://www.freedesktop.org/wiki/Specifications/icon-naming-spec). Also see
// gtk_icon_theme_list_contexts().
//
// The function takes the following parameters:
//
//    - context (optional): string identifying a particular type of icon, or NULL
//      to list all icons.
//
// The function returns the following values:
//
//    - list list holding the names of all the icons in the theme. You must first
//      free each element in the list with g_free(), then free the list itself
//      with g_list_free().
//
func (iconTheme *IconTheme) ListIcons(context string) []string {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out
	var _cret *C.GList        // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	if context != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(context)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_icon_theme_list_icons(_arg0, _arg1)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(context)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.gchar)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// LoadIcon looks up an icon in an icon theme, scales it to the given size and
// renders it into a pixbuf. This is a convenience function; if more details
// about the icon are needed, use gtk_icon_theme_lookup_icon() followed by
// gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
// If for some reason you do not want to update the icon when the icon theme
// changes, you should consider using gdk_pixbuf_copy() to make a private copy
// of the pixbuf returned by this function. Otherwise GTK+ may need to keep the
// old icon theme loaded, which would be a waste of memory.
//
// The function takes the following parameters:
//
//    - iconName: name of the icon to lookup.
//    - size: desired icon size. The resulting icon may not be exactly this size;
//      see gtk_icon_info_load_icon().
//    - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//    - pixbuf (optional): rendered icon; this may be a newly created icon or a
//      new reference to an internal icon, so you must not modify the icon. Use
//      g_object_unref() to release your reference to the icon. NULL if the icon
//      isn’t found.
//
func (iconTheme *IconTheme) LoadIcon(iconName string, size int, flags IconLookupFlags) (*gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GdkPixbuf         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_icon(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconName)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// LookupIcon looks up a named icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon(). (gtk_icon_theme_load_icon()
// combines these two steps if all you need is the pixbuf.)
//
// When rendering on displays with high pixel densities you should not use a
// size multiplied by the scaling factor returned by functions like
// gdk_window_get_scale_factor(). Instead, you should use
// gtk_icon_theme_lookup_icon_for_scale(), as the assets loaded for a given
// scaling factor may be different.
//
// The function takes the following parameters:
//
//    - iconName: name of the icon to lookup.
//    - size: desired icon size.
//    - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//    - iconInfo (optional) object containing information about the icon, or NULL
//      if the icon wasn’t found.
//
func (iconTheme *IconTheme) LookupIcon(iconName string, size int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_icon(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconName)
	runtime.KeepAlive(size)
	runtime.KeepAlive(flags)

	var _iconInfo *IconInfo // out

	if _cret != nil {
		_iconInfo = wrapIconInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _iconInfo
}

// PrependSearchPath prepends a directory to the search path. See
// gtk_icon_theme_set_search_path().
//
// The function takes the following parameters:
//
//    - path: directory name to prepend to the icon path.
//
func (iconTheme *IconTheme) PrependSearchPath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_prepend_search_path(_arg0, _arg1)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(path)
}

// RescanIfNeeded checks to see if the icon theme has changed; if it has, any
// currently cached information is discarded and will be reloaded next time
// icon_theme is accessed.
//
// The function returns the following values:
//
//    - ok: TRUE if the icon theme has changed and needed to be reloaded.
//
func (iconTheme *IconTheme) RescanIfNeeded() bool {
	var _arg0 *C.GtkIconTheme // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))

	_cret = C.gtk_icon_theme_rescan_if_needed(_arg0)
	runtime.KeepAlive(iconTheme)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCustomTheme sets the name of the icon theme that the IconTheme object uses
// overriding system configuration. This function cannot be called on the icon
// theme objects returned from gtk_icon_theme_get_default() and
// gtk_icon_theme_get_for_screen().
//
// The function takes the following parameters:
//
//    - themeName (optional): name of icon theme to use instead of configured
//      theme, or NULL to unset a previously set custom theme.
//
func (iconTheme *IconTheme) SetCustomTheme(themeName string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.gchar        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	if themeName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(themeName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_icon_theme_set_custom_theme(_arg0, _arg1)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(themeName)
}

// SetScreen sets the screen for an icon theme; the screen is used to track the
// user’s currently configured icon theme, which might be different for
// different screens.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
func (iconTheme *IconTheme) SetScreen(screen *gdk.Screen) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.GdkScreen    // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.GdkScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	C.gtk_icon_theme_set_screen(_arg0, _arg1)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(screen)
}

// SetSearchPath sets the search path for the icon theme object. When looking
// for an icon theme, GTK+ will search for a subdirectory of one or more of the
// directories in path with the same name as the icon theme containing an
// index.theme file. (Themes from multiple of the path elements are combined to
// allow themes to be extended by adding icons in the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme or
// the default icon theme, and an image file with the right name is found
// directly in one of the elements of path, then that image will be used for the
// icon name. (This is legacy feature, and new icons should be put into the
// fallback icon theme, which is called hicolor, rather than directly on the
// icon path.).
//
// The function takes the following parameters:
//
//    - path: array of directories that are searched for icon themes.
//
func (iconTheme *IconTheme) SetSearchPath(path []string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.gchar       // out
	var _arg2 C.gint

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg2 = (C.gint)(len(path))
	_arg1 = (**C.gchar)(C.calloc(C.size_t(len(path)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.gchar)(_arg1), len(path))
		for i := range path {
			out[i] = (*C.gchar)(unsafe.Pointer(C.CString(path[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}

	C.gtk_icon_theme_set_search_path(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(path)
}

// IconThemeAddBuiltinIcon registers a built-in icon for icon theme lookups. The
// idea of built-in icons is to allow an application or library that uses themed
// icons to function requiring files to be present in the file system. For
// instance, the default images for all of GTK+’s stock icons are registered as
// built-icons.
//
// In general, if you use gtk_icon_theme_add_builtin_icon() you should also
// install the icon in the icon theme, so that the icon is generally available.
//
// This function will generally be used with pixbufs loaded via
// gdk_pixbuf_new_from_inline().
//
// Deprecated: Use gtk_icon_theme_add_resource_path() to add
// application-specific icons to the icon theme.
//
// The function takes the following parameters:
//
//    - iconName: name of the icon to register.
//    - size in pixels at which to register the icon (different images can be
//      registered for the same icon name at different sizes.).
//    - pixbuf that contains the image to use for icon_name.
//
func IconThemeAddBuiltinIcon(iconName string, size int, pixbuf *gdkpixbuf.Pixbuf) {
	var _arg1 *C.gchar     // out
	var _arg2 C.gint       // out
	var _arg3 *C.GdkPixbuf // out

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	C.gtk_icon_theme_add_builtin_icon(_arg1, _arg2, _arg3)
	runtime.KeepAlive(iconName)
	runtime.KeepAlive(size)
	runtime.KeepAlive(pixbuf)
}

// IconThemeGetDefault gets the icon theme for the default screen. See
// gtk_icon_theme_get_for_screen().
//
// The function returns the following values:
//
//    - iconTheme: unique IconTheme associated with the default screen. This icon
//      theme is associated with the screen and can be used as long as the screen
//      is open. Do not ref or unref it.
//
func IconThemeGetDefault() *IconTheme {
	var _cret *C.GtkIconTheme // in

	_cret = C.gtk_icon_theme_get_default()

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconTheme
}

// IconThemeGetForScreen gets the icon theme object associated with screen; if
// this function has not previously been called for the given screen, a new icon
// theme object will be created and associated with the screen. Icon theme
// objects are fairly expensive to create, so using this function is usually a
// better choice than calling than gtk_icon_theme_new() and setting the screen
// yourself; by using this function a single icon theme object will be shared
// between users.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
// The function returns the following values:
//
//    - iconTheme: unique IconTheme associated with the given screen. This icon
//      theme is associated with the screen and can be used as long as the screen
//      is open. Do not ref or unref it.
//
func IconThemeGetForScreen(screen *gdk.Screen) *IconTheme {
	var _arg1 *C.GdkScreen    // out
	var _cret *C.GtkIconTheme // in

	_arg1 = (*C.GdkScreen)(unsafe.Pointer(coreglib.InternObject(screen).Native()))

	_cret = C.gtk_icon_theme_get_for_screen(_arg1)
	runtime.KeepAlive(screen)

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconTheme
}

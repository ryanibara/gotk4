// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_ScrolledWindow_ConnectMoveFocusOut(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk3_ScrolledWindow_ConnectEdgeReached(gpointer, GtkPositionType, guintptr);
// extern void _gotk4_gtk3_ScrolledWindow_ConnectEdgeOvershot(gpointer, GtkPositionType, guintptr);
// extern void _gotk4_gtk3_ScrolledWindowClass_move_focus_out(GtkScrolledWindow*, GtkDirectionType);
// extern gboolean _gotk4_gtk3_ScrolledWindow_ConnectScrollChild(gpointer, GtkScrollType, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_ScrolledWindowClass_scroll_child(GtkScrolledWindow*, GtkScrollType, gboolean);
// gboolean _gotk4_gtk3_ScrolledWindow_virtual_scroll_child(void* fnptr, GtkScrolledWindow* arg0, GtkScrollType arg1, gboolean arg2) {
//   return ((gboolean (*)(GtkScrolledWindow*, GtkScrollType, gboolean))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_ScrolledWindow_virtual_move_focus_out(void* fnptr, GtkScrolledWindow* arg0, GtkDirectionType arg1) {
//   ((void (*)(GtkScrolledWindow*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeCornerType     = coreglib.Type(C.gtk_corner_type_get_type())
	GTypePolicyType     = coreglib.Type(C.gtk_policy_type_get_type())
	GTypeScrolledWindow = coreglib.Type(C.gtk_scrolled_window_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCornerType, F: marshalCornerType},
		coreglib.TypeMarshaler{T: GTypePolicyType, F: marshalPolicyType},
		coreglib.TypeMarshaler{T: GTypeScrolledWindow, F: marshalScrolledWindow},
	})
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a ScrolledWindow. This is effectively the opposite of where the
// scroll bars are placed.
type CornerType C.gint

const (
	// CornerTopLeft: place the scrollbars on the right and bottom of the widget
	// (default behaviour).
	CornerTopLeft CornerType = iota
	// CornerBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerBottomLeft
	// CornerTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTopRight
	// CornerBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerBottomRight
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CornerType.
func (c CornerType) String() string {
	switch c {
	case CornerTopLeft:
		return "TopLeft"
	case CornerBottomLeft:
		return "BottomLeft"
	case CornerTopRight:
		return "TopRight"
	case CornerBottomRight:
		return "BottomRight"
	default:
		return fmt.Sprintf("CornerType(%d)", c)
	}
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType C.gint

const (
	// PolicyAlways: scrollbar is always visible. The view size is independent
	// of the content.
	PolicyAlways PolicyType = iota
	// PolicyAutomatic: scrollbar will appear and disappear as necessary. For
	// example, when all of a TreeView can not be seen.
	PolicyAutomatic
	// PolicyNever: scrollbar should never appear. In this mode the content
	// determines the size.
	PolicyNever
	// PolicyExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar. Since: 3.16.
	PolicyExternal
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PolicyType.
func (p PolicyType) String() string {
	switch p {
	case PolicyAlways:
		return "Always"
	case PolicyAutomatic:
		return "Automatic"
	case PolicyNever:
		return "Never"
	case PolicyExternal:
		return "External"
	default:
		return fmt.Sprintf("PolicyType(%d)", p)
	}
}

// ScrolledWindowOverrides contains methods that are overridable.
type ScrolledWindowOverrides struct {
	// The function takes the following parameters:
	//
	MoveFocusOut func(direction DirectionType)
	// The function takes the following parameters:
	//
	//    - scroll
	//    - horizontal
	//
	// The function returns the following values:
	//
	ScrollChild func(scroll ScrollType, horizontal bool) bool
}

func defaultScrolledWindowOverrides(v *ScrolledWindow) ScrolledWindowOverrides {
	return ScrolledWindowOverrides{
		MoveFocusOut: v.moveFocusOut,
		ScrollChild:  v.scrollChild,
	}
}

// ScrolledWindow is a container that accepts a single child widget, makes that
// child scrollable using either internally added scrollbars or externally
// associated adjustments, and optionally draws a frame around the child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// Scrollable interface, are added directly. For other types of widget, the
// class Viewport acts as an adaptor, giving scrollability to other widgets.
// GtkScrolledWindow’s implementation of gtk_container_add() intelligently
// accounts for whether or not the added child is a Scrollable. If it isn’t,
// ScrolledWindow wraps the child in a Viewport and adds that for you.
// Therefore, you can just add any child widget and not worry about the details.
//
// If gtk_container_add() has added a Viewport for you, you can remove both your
// added child widget from the Viewport, and the Viewport from the
// GtkScrolledWindow, like this:
//
//    GtkWidget *scrolled_window = gtk_scrolled_window_new (NULL, NULL);
//    GtkWidget *child_widget = gtk_button_new ();
//
//    // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
//    // add a GtkViewport.
//    gtk_container_add (GTK_CONTAINER (scrolled_window),
//                       child_widget);
//
//    // Either of these will result in child_widget being unparented:
//    gtk_container_remove (GTK_CONTAINER (scrolled_window),
//                          child_widget);
//    // or
//    gtk_container_remove (GTK_CONTAINER (scrolled_window),
//                          gtk_bin_get_child (GTK_BIN (scrolled_window)));
//
// Unless ScrolledWindow:policy is GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL,
// GtkScrolledWindow adds internal Scrollbar widgets around its child. The
// scroll position of the child, and if applicable the scrollbars, is controlled
// by the ScrolledWindow:hadjustment and ScrolledWindow:vadjustment that are
// associated with the GtkScrolledWindow. See the docs on Scrollbar for the
// details, but note that the “step_increment” and “page_increment” fields are
// only effective if the policy causes scrollbars to be present.
//
// If a GtkScrolledWindow doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with Scrollbar and for example a Grid.
//
//
// Touch support
//
// GtkScrolledWindow has built-in support for touch devices. When a touchscreen
// is used, swiping will move the scrolled window, and will expose 'kinetic'
// behavior. This can be turned off with the ScrolledWindow:kinetic-scrolling
// property if it is undesired.
//
// GtkScrolledWindow also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// ScrolledWindow::edge-overshot signal.
//
// If no mouse device is present, the scrollbars will overlayed as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the ScrolledWindow:overlay-scrolling property.
//
//
// CSS nodes
//
// GtkScrolledWindow has a main CSS node with name scrolledwindow.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// GtkScrolledWindow also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
type ScrolledWindow struct {
	_ [0]func() // equal guard
	Bin
}

var (
	_ Binner = (*ScrolledWindow)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ScrolledWindow, *ScrolledWindowClass, ScrolledWindowOverrides](
		GTypeScrolledWindow,
		initScrolledWindowClass,
		wrapScrolledWindow,
		defaultScrolledWindowOverrides,
	)
}

func initScrolledWindowClass(gclass unsafe.Pointer, overrides ScrolledWindowOverrides, classInitFunc func(*ScrolledWindowClass)) {
	pclass := (*C.GtkScrolledWindowClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeScrolledWindow))))

	if overrides.MoveFocusOut != nil {
		pclass.move_focus_out = (*[0]byte)(C._gotk4_gtk3_ScrolledWindowClass_move_focus_out)
	}

	if overrides.ScrollChild != nil {
		pclass.scroll_child = (*[0]byte)(C._gotk4_gtk3_ScrolledWindowClass_scroll_child)
	}

	if classInitFunc != nil {
		class := (*ScrolledWindowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapScrolledWindow(obj *coreglib.Object) *ScrolledWindow {
	return &ScrolledWindow{
		Bin: Bin{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	return wrapScrolledWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEdgeOvershot signal is emitted whenever user initiated scrolling makes
// the scrolled window firmly surpass (i.e. with some edge resistance) the lower
// or upper limits defined by the adjustment in that orientation.
//
// A similar behavior without edge resistance is provided by the
// ScrolledWindow::edge-reached signal.
//
// Note: The pos argument is LTR/RTL aware, so callers should be aware too if
// intending to provide behavior on horizontal edges.
func (scrolledWindow *ScrolledWindow) ConnectEdgeOvershot(f func(pos PositionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scrolledWindow, "edge-overshot", false, unsafe.Pointer(C._gotk4_gtk3_ScrolledWindow_ConnectEdgeOvershot), f)
}

// ConnectEdgeReached signal is emitted whenever user-initiated scrolling makes
// the scrolled window exactly reach the lower or upper limits defined by the
// adjustment in that orientation.
//
// A similar behavior with edge resistance is provided by the
// ScrolledWindow::edge-overshot signal.
//
// Note: The pos argument is LTR/RTL aware, so callers should be aware too if
// intending to provide behavior on horizontal edges.
func (scrolledWindow *ScrolledWindow) ConnectEdgeReached(f func(pos PositionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scrolledWindow, "edge-reached", false, unsafe.Pointer(C._gotk4_gtk3_ScrolledWindow_ConnectEdgeReached), f)
}

// ConnectMoveFocusOut signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when focus is moved away from the scrolled window by a
// keybinding. The Widget::move-focus signal is emitted with direction_type on
// this scrolled window’s toplevel parent in the container hierarchy. The
// default bindings for this signal are Ctrl + Tab to move forward and Ctrl +
// Shift + Tab to move backward.
func (scrolledWindow *ScrolledWindow) ConnectMoveFocusOut(f func(directionType DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scrolledWindow, "move-focus-out", false, unsafe.Pointer(C._gotk4_gtk3_ScrolledWindow_ConnectMoveFocusOut), f)
}

// ConnectScrollChild signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when a keybinding that scrolls is pressed. The horizontal or
// vertical adjustment is updated which triggers a signal that the scrolled
// window’s child may listen to and scroll itself.
func (scrolledWindow *ScrolledWindow) ConnectScrollChild(f func(scroll ScrollType, horizontal bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scrolledWindow, "scroll-child", false, unsafe.Pointer(C._gotk4_gtk3_ScrolledWindow_ConnectScrollChild), f)
}

// NewScrolledWindow creates a new scrolled window.
//
// The two arguments are the scrolled window’s adjustments; these will be shared
// with the scrollbars and the child widget to keep the bars in sync with the
// child. Usually you want to pass NULL for the adjustments, which will cause
// the scrolled window to create them for you.
//
// The function takes the following parameters:
//
//    - hadjustment (optional): horizontal adjustment.
//    - vadjustment (optional): vertical adjustment.
//
// The function returns the following values:
//
//    - scrolledWindow: new scrolled window.
//
func NewScrolledWindow(hadjustment, vadjustment *Adjustment) *ScrolledWindow {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	if hadjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(hadjustment).Native()))
	}
	if vadjustment != nil {
		_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(vadjustment).Native()))
	}

	_cret = C.gtk_scrolled_window_new(_arg1, _arg2)
	runtime.KeepAlive(hadjustment)
	runtime.KeepAlive(vadjustment)

	var _scrolledWindow *ScrolledWindow // out

	_scrolledWindow = wrapScrolledWindow(coreglib.Take(unsafe.Pointer(_cret)))

	return _scrolledWindow
}

// AddWithViewport: used to add children without native scrolling capabilities.
// This is simply a convenience function; it is equivalent to adding the
// unscrollable child to a viewport, then adding the viewport to the scrolled
// window. If a child has native scrolling, use gtk_container_add() instead of
// this function.
//
// The viewport scrolls the child by moving its Window, and takes the size of
// the child to be the size of its toplevel Window. This will be very wrong for
// most widgets that support native scrolling; for example, if you add a widget
// such as TreeView with a viewport, the whole widget will scroll, including the
// column headings. Thus, widgets with native scrolling support should not be
// used with the Viewport proxy.
//
// A widget supports scrolling natively if it implements the Scrollable
// interface.
//
// Deprecated: gtk_container_add() will automatically add a Viewport if the
// child doesn’t implement Scrollable.
//
// The function takes the following parameters:
//
//    - child: widget you want to scroll.
//
func (scrolledWindow *ScrolledWindow) AddWithViewport(child Widgetter) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_scrolled_window_add_with_viewport(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(child)
}

// HAdjustment returns the horizontal scrollbar’s adjustment, used to connect
// the horizontal scrollbar to the child widget’s horizontal scroll
// functionality.
//
// The function returns the following values:
//
//    - adjustment: horizontal Adjustment.
//
func (scrolledWindow *ScrolledWindow) HAdjustment() *Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_hadjustment(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// Placement gets the placement of the contents with respect to the scrollbars
// for the scrolled window. See gtk_scrolled_window_set_placement().
//
// The function returns the following values:
//
//    - cornerType: current placement value.
//
//      See also gtk_scrolled_window_set_placement() and
//      gtk_scrolled_window_unset_placement().
//
func (scrolledWindow *ScrolledWindow) Placement() CornerType {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.GtkCornerType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_placement(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _cornerType CornerType // out

	_cornerType = CornerType(_cret)

	return _cornerType
}

// Policy retrieves the current policy values for the horizontal and vertical
// scrollbars. See gtk_scrolled_window_set_policy().
//
// The function returns the following values:
//
//    - hscrollbarPolicy (optional): location to store the policy for the
//      horizontal scrollbar, or NULL.
//    - vscrollbarPolicy (optional): location to store the policy for the
//      vertical scrollbar, or NULL.
//
func (scrolledWindow *ScrolledWindow) Policy() (hscrollbarPolicy, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // in
	var _arg2 C.GtkPolicyType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	C.gtk_scrolled_window_get_policy(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(scrolledWindow)

	var _hscrollbarPolicy PolicyType // out
	var _vscrollbarPolicy PolicyType // out

	_hscrollbarPolicy = PolicyType(_arg1)
	_vscrollbarPolicy = PolicyType(_arg2)

	return _hscrollbarPolicy, _vscrollbarPolicy
}

// ShadowType gets the shadow type of the scrolled window. See
// gtk_scrolled_window_set_shadow_type().
//
// The function returns the following values:
//
//    - shadowType: current shadow type.
//
func (scrolledWindow *ScrolledWindow) ShadowType() ShadowType {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.GtkShadowType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_shadow_type(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _shadowType ShadowType // out

	_shadowType = ShadowType(_cret)

	return _shadowType
}

// VAdjustment returns the vertical scrollbar’s adjustment, used to connect the
// vertical scrollbar to the child widget’s vertical scroll functionality.
//
// The function returns the following values:
//
//    - adjustment: vertical Adjustment.
//
func (scrolledWindow *ScrolledWindow) VAdjustment() *Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_vadjustment(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// SetHAdjustment sets the Adjustment for the horizontal scrollbar.
//
// The function takes the following parameters:
//
//    - hadjustment (optional) to use, or NULL to create a new one.
//
func (scrolledWindow *ScrolledWindow) SetHAdjustment(hadjustment *Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if hadjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(hadjustment).Native()))
	}

	C.gtk_scrolled_window_set_hadjustment(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(hadjustment)
}

// SetPlacement sets the placement of the contents with respect to the
// scrollbars for the scrolled window.
//
// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
// with the scrollbars underneath and to the right. Other values in CornerType
// are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
// GTK_CORNER_BOTTOM_RIGHT.
//
// See also gtk_scrolled_window_get_placement() and
// gtk_scrolled_window_unset_placement().
//
// The function takes the following parameters:
//
//    - windowPlacement: position of the child window.
//
func (scrolledWindow *ScrolledWindow) SetPlacement(windowPlacement CornerType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkCornerType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.GtkCornerType(windowPlacement)

	C.gtk_scrolled_window_set_placement(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(windowPlacement)
}

// SetPolicy sets the scrollbar policy for the horizontal and vertical
// scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value from
// the PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar is always
// present; if GTK_POLICY_NEVER, the scrollbar is never present; if
// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is, if
// the slider part of the bar would be smaller than the trough — the display is
// larger than the page size).
//
// The function takes the following parameters:
//
//    - hscrollbarPolicy: policy for horizontal bar.
//    - vscrollbarPolicy: policy for vertical bar.
//
func (scrolledWindow *ScrolledWindow) SetPolicy(hscrollbarPolicy, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // out
	var _arg2 C.GtkPolicyType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.GtkPolicyType(hscrollbarPolicy)
	_arg2 = C.GtkPolicyType(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy(_arg0, _arg1, _arg2)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(hscrollbarPolicy)
	runtime.KeepAlive(vscrollbarPolicy)
}

// SetShadowType changes the type of shadow drawn around the contents of
// scrolled_window.
//
// The function takes the following parameters:
//
//    - typ: kind of shadow to draw around scrolled window contents.
//
func (scrolledWindow *ScrolledWindow) SetShadowType(typ ShadowType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkShadowType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.GtkShadowType(typ)

	C.gtk_scrolled_window_set_shadow_type(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(typ)
}

// SetVAdjustment sets the Adjustment for the vertical scrollbar.
//
// The function takes the following parameters:
//
//    - vadjustment (optional) to use, or NULL to create a new one.
//
func (scrolledWindow *ScrolledWindow) SetVAdjustment(vadjustment *Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if vadjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(vadjustment).Native()))
	}

	C.gtk_scrolled_window_set_vadjustment(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(vadjustment)
}

// The function takes the following parameters:
//
func (scrolledWindow *ScrolledWindow) moveFocusOut(direction DirectionType) {
	gclass := (*C.GtkScrolledWindowClass)(coreglib.PeekParentClass(scrolledWindow))
	fnarg := gclass.move_focus_out

	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkDirectionType   // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.GtkDirectionType(direction)

	C._gotk4_gtk3_ScrolledWindow_virtual_move_focus_out(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(direction)
}

// The function takes the following parameters:
//
//    - scroll
//    - horizontal
//
// The function returns the following values:
//
func (scrolledWindow *ScrolledWindow) scrollChild(scroll ScrollType, horizontal bool) bool {
	gclass := (*C.GtkScrolledWindowClass)(coreglib.PeekParentClass(scrolledWindow))
	fnarg := gclass.scroll_child

	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkScrollType      // out
	var _arg2 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.GtkScrollType(scroll)
	if horizontal {
		_arg2 = C.TRUE
	}

	_cret = C._gotk4_gtk3_ScrolledWindow_virtual_scroll_child(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(scroll)
	runtime.KeepAlive(horizontal)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrolledWindowClass: instance of this type is always passed by reference.
type ScrolledWindowClass struct {
	*scrolledWindowClass
}

// scrolledWindowClass is the struct that's finalized.
type scrolledWindowClass struct {
	native *C.GtkScrolledWindowClass
}

// ParentClass: parent class.
func (s *ScrolledWindowClass) ParentClass() *BinClass {
	valptr := &s.native.parent_class
	var _v *BinClass // out
	_v = (*BinClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

func (s *ScrolledWindowClass) ScrollbarSpacing() int {
	valptr := &s.native.scrollbar_spacing
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_Application_ConnectWindowRemoved(gpointer, GtkWindow*, guintptr);
// extern void _gotk4_gtk3_Application_ConnectWindowAdded(gpointer, GtkWindow*, guintptr);
// extern void _gotk4_gtk3_Application_ConnectQueryEnd(gpointer, guintptr);
// extern void _gotk4_gtk3_ApplicationClass_window_removed(GtkApplication*, GtkWindow*);
// extern void _gotk4_gtk3_ApplicationClass_window_added(GtkApplication*, GtkWindow*);
// void _gotk4_gtk3_Application_virtual_window_added(void* fnptr, GtkApplication* arg0, GtkWindow* arg1) {
//   ((void (*)(GtkApplication*, GtkWindow*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk3_Application_virtual_window_removed(void* fnptr, GtkApplication* arg0, GtkWindow* arg1) {
//   ((void (*)(GtkApplication*, GtkWindow*))(fnptr))(arg0, arg1);
// };
import "C"

// GType values.
var (
	GTypeApplication = coreglib.Type(C.gtk_application_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeApplication, F: marshalApplication},
	})
}

// ApplicationOverrides contains methods that are overridable.
type ApplicationOverrides struct {
	// The function takes the following parameters:
	//
	WindowAdded func(window *Window)
	// The function takes the following parameters:
	//
	WindowRemoved func(window *Window)
}

func defaultApplicationOverrides(v *Application) ApplicationOverrides {
	return ApplicationOverrides{
		WindowAdded:   v.windowAdded,
		WindowRemoved: v.windowRemoved,
	}
}

// Application is a class that handles many important aspects of a GTK+
// application in a convenient fashion, without enforcing a one-size-fits-all
// application model.
//
// Currently, GtkApplication handles GTK+ initialization, application
// uniqueness, session management, provides some basic scriptability and desktop
// shell integration by exporting actions and menus and manages a list of
// toplevel windows whose life-cycle is automatically tied to the life-cycle of
// your application.
//
// While GtkApplication works fine with plain Windows, it is recommended to use
// it together with ApplicationWindow.
//
// When GDK threads are enabled, GtkApplication will acquire the GDK lock when
// invoking actions that arrive from other processes. The GDK lock is not
// touched for local action invocations. In order to have actions invoked in a
// predictable context it is therefore recommended that the GDK lock be held
// while invoking actions locally with g_action_group_activate_action(). The
// same applies to actions associated with ApplicationWindow and to the
// “activate” and “open” #GApplication methods.
//
//
// Automatic resources
//
// Application will automatically load menus from the Builder resource located
// at "gtk/menus.ui", relative to the application's resource base path (see
// g_application_set_resource_base_path()). The menu with the ID "app-menu" is
// taken as the application's app menu and the menu with the ID "menubar" is
// taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk_application_get_menu_by_id()
// which allows for dynamic population of a part of the menu structure.
//
// If the resources "gtk/menus-appmenu.ui" or "gtk/menus-traditional.ui" are
// present then these files will be used in preference, depending on the value
// of gtk_application_prefers_app_menu(). If the resource "gtk/menus-common.ui"
// is present it will be loaded as well. This is useful for storing items that
// are referenced from both "gtk/menus-appmenu.ui" and
// "gtk/menus-traditional.ui".
//
// It is also possible to provide the menus manually using
// gtk_application_set_app_menu() and gtk_application_set_menubar().
//
// Application will also automatically setup an icon search path for the default
// icon theme by appending "icons" to the resource base path. This allows your
// application to easily store its icons as resources. See
// gtk_icon_theme_add_resource_path() for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// ShortcutsWindow with ID "help_overlay" then GtkApplication associates an
// instance of this shortcuts window with each ApplicationWindow and sets up
// keyboard accelerators (Control-F1 and Control-?) to open it. To create a menu
// item that displays the shortcuts window, associate the item with the action
// win.show-help-overlay.
//
//
// A simple application
//
// A simple example
// (https://git.gnome.org/browse/gtk+/tree/examples/bp/bloatpad.c)
//
// GtkApplication optionally registers with a session manager of the users
// session (if you set the Application:register-session property) and offers
// various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// gtk_application_inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
//
// See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK+: Basics
// (https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.3).
type Application struct {
	_ [0]func() // equal guard
	gio.Application
}

var (
	_ coreglib.Objector = (*Application)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Application, *ApplicationClass, ApplicationOverrides](
		GTypeApplication,
		initApplicationClass,
		wrapApplication,
		defaultApplicationOverrides,
	)
}

func initApplicationClass(gclass unsafe.Pointer, overrides ApplicationOverrides, classInitFunc func(*ApplicationClass)) {
	pclass := (*C.GtkApplicationClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeApplication))))

	if overrides.WindowAdded != nil {
		pclass.window_added = (*[0]byte)(C._gotk4_gtk3_ApplicationClass_window_added)
	}

	if overrides.WindowRemoved != nil {
		pclass.window_removed = (*[0]byte)(C._gotk4_gtk3_ApplicationClass_window_removed)
	}

	if classInitFunc != nil {
		class := (*ApplicationClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapApplication(obj *coreglib.Object) *Application {
	return &Application{
		Application: gio.Application{
			Object: obj,
			ActionGroup: gio.ActionGroup{
				Object: obj,
			},
			ActionMap: gio.ActionMap{
				Object: obj,
			},
		},
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	return wrapApplication(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectQueryEnd is emitted when the session manager is about to end the
// session, only if Application::register-session is TRUE. Applications can
// connect to this signal and call gtk_application_inhibit() with
// GTK_APPLICATION_INHIBIT_LOGOUT to delay the end of the session until state
// has been saved.
func (application *Application) ConnectQueryEnd(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "query-end", false, unsafe.Pointer(C._gotk4_gtk3_Application_ConnectQueryEnd), f)
}

// ConnectWindowAdded is emitted when a Window is added to application through
// gtk_application_add_window().
func (application *Application) ConnectWindowAdded(f func(window *Window)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "window-added", false, unsafe.Pointer(C._gotk4_gtk3_Application_ConnectWindowAdded), f)
}

// ConnectWindowRemoved is emitted when a Window is removed from application,
// either as a side-effect of being destroyed or explicitly through
// gtk_application_remove_window().
func (application *Application) ConnectWindowRemoved(f func(window *Window)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "window-removed", false, unsafe.Pointer(C._gotk4_gtk3_Application_ConnectWindowRemoved), f)
}

// The function takes the following parameters:
//
func (application *Application) windowAdded(window *Window) {
	gclass := (*C.GtkApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.window_added

	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gtk3_Application_virtual_window_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
}

// The function takes the following parameters:
//
func (application *Application) windowRemoved(window *Window) {
	gclass := (*C.GtkApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.window_removed

	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gtk3_Application_virtual_window_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
}

// ApplicationClass: instance of this type is always passed by reference.
type ApplicationClass struct {
	*applicationClass
}

// applicationClass is the struct that's finalized.
type applicationClass struct {
	native *C.GtkApplicationClass
}

// ParentClass: parent class.
func (a *ApplicationClass) ParentClass() *gio.ApplicationClass {
	valptr := &a.native.parent_class
	var _v *gio.ApplicationClass // out
	_v = (*gio.ApplicationClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// GType _gotk4_gtk3_Builder_virtual_get_type_from_name(void* fnptr, GtkBuilder* arg0, char* arg1) {
//   return ((GType (*)(GtkBuilder*, char*))(fnptr))(arg0, arg1);
// };
import "C"

// NewBuilder creates a new empty builder object.
//
// This function is only useful if you intend to make multiple calls to
// gtk_builder_add_from_file(), gtk_builder_add_from_resource() or
// gtk_builder_add_from_string() in order to merge multiple UI descriptions into
// a single builder.
//
// Most users will probably want to use gtk_builder_new_from_file(),
// gtk_builder_new_from_resource() or gtk_builder_new_from_string().
//
// The function returns the following values:
//
//    - builder: new (empty) Builder object.
//
func NewBuilder() *Builder {
	var _cret *C.GtkBuilder // in

	_cret = C.gtk_builder_new()

	var _builder *Builder // out

	_builder = wrapBuilder(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// AddFromFile parses a file containing a [GtkBuilder UI definition][BUILDER-UI]
// and merges it with the current contents of builder.
//
// Most users will probably want to use gtk_builder_new_from_file().
//
// If an error occurs, 0 will be returned and error will be assigned a #GError
// from the K_BUILDER_ERROR, MARKUP_ERROR or FILE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call. You
// should not use this function with untrusted files (ie: files that are not
// part of your application). Broken Builder files can easily crash your
// program, and it’s possible that memory was leaked leading up to the reported
// failure. The only reasonable thing to do when an error is detected is to call
// g_error().
//
// The function takes the following parameters:
//
//    - filename: name of the file to parse.
//
// The function returns the following values:
//
//    - guint: positive value on success, 0 if an error occurred.
//
func (builder *Builder) AddFromFile(filename string) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _cret C.guint       // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_add_from_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(filename)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// AddFromString parses a string containing a [GtkBuilder UI
// definition][BUILDER-UI] and merges it with the current contents of builder.
//
// Most users will probably want to use gtk_builder_new_from_string().
//
// Upon errors 0 will be returned and error will be assigned a #GError from the
// K_BUILDER_ERROR, MARKUP_ERROR or VARIANT_PARSE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
//
// The function takes the following parameters:
//
//    - buffer: string to parse.
//    - length of buffer (may be -1 if buffer is nul-terminated).
//
// The function returns the following values:
//
//    - guint: positive value on success, 0 if an error occurred.
//
func (builder *Builder) AddFromString(buffer string, length uint) (uint, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _arg2 C.gsize       // out
	var _cret C.guint       // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gsize(length)

	_cret = C.gtk_builder_add_from_string(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(length)

	var _guint uint  // out
	var _goerr error // out

	_guint = uint(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _guint, _goerr
}

// ConnectSignals: this method is a simpler variation of
// gtk_builder_connect_signals_full(). It uses symbols explicitly added to
// builder with prior calls to gtk_builder_add_callback_symbol(). In the case
// that symbols are not explicitly added; it uses #GModule’s introspective
// features (by opening the module NULL) to look at the application’s symbol
// table. From here it tries to match the signal handler names given in the
// interface description with symbols in the application and connects the
// signals. Note that this function can only be called once, subsequent calls
// will do nothing.
//
// Note that unless gtk_builder_add_callback_symbol() is called for all signal
// callbacks which are referenced by the loaded XML, this function will require
// that #GModule be supported on the platform.
//
// If you rely on #GModule support to lookup callbacks in the symbol table, the
// following details should be noted:
//
// When compiling applications for Windows, you must declare signal callbacks
// with MODULE_EXPORT, or they will not be put in the symbol table. On Linux and
// Unices, this is not necessary; applications should instead be compiled with
// the -Wl,--export-dynamic CFLAGS, and linked against gmodule-export-2.0.
//
// The function takes the following parameters:
//
//    - userData (optional): user data to pass back with all signals.
//
func (builder *Builder) ConnectSignals(userData unsafe.Pointer) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 C.gpointer    // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (C.gpointer)(unsafe.Pointer(userData))

	C.gtk_builder_connect_signals(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(userData)
}

// GetObject gets the object named name. Note that this function does not
// increment the reference count of the returned object.
//
// The function takes the following parameters:
//
//    - name of object to get.
//
// The function returns the following values:
//
//    - object (optional) named name or NULL if it could not be found in the
//      object tree.
//
func (builder *Builder) GetObject(name string) *coreglib.Object {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out
	var _cret *C.GObject    // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_get_object(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.Take(unsafe.Pointer(_cret))
	}

	return _object
}

// Objects gets all objects that have been constructed by builder. Note that
// this function does not increment the reference counts of the returned
// objects.
//
// The function returns the following values:
//
//    - sList: newly-allocated List containing all the objects constructed by the
//      Builder instance. It should be freed by g_slist_free().
//
func (builder *Builder) Objects() []*coreglib.Object {
	var _arg0 *C.GtkBuilder // out
	var _cret *C.GSList     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))

	_cret = C.gtk_builder_get_objects(_arg0)
	runtime.KeepAlive(builder)

	var _sList []*coreglib.Object // out

	_sList = make([]*coreglib.Object, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GObject)(v)
		var dst *coreglib.Object // out
		dst = coreglib.Take(unsafe.Pointer(src))
		_sList = append(_sList, dst)
	})

	return _sList
}

// TranslationDomain gets the translation domain of builder.
//
// The function returns the following values:
//
//    - utf8: translation domain. This string is owned by the builder object and
//      must not be modified or freed.
//
func (builder *Builder) TranslationDomain() string {
	var _arg0 *C.GtkBuilder // out
	var _cret *C.gchar      // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))

	_cret = C.gtk_builder_get_translation_domain(_arg0)
	runtime.KeepAlive(builder)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TypeFromName looks up a type by name, using the virtual function that Builder
// has for that purpose. This is mainly used when implementing the Buildable
// interface on a type.
//
// The function takes the following parameters:
//
//    - typeName: type name to lookup.
//
// The function returns the following values:
//
//    - gType found for type_name or TYPE_INVALID if no type was found.
//
func (builder *Builder) TypeFromName(typeName string) coreglib.Type {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cret C.GType       // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(typeName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_get_type_from_name(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typeName)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// SetTranslationDomain sets the translation domain of builder. See
// Builder:translation-domain.
//
// The function takes the following parameters:
//
//    - domain (optional): translation domain or NULL.
//
func (builder *Builder) SetTranslationDomain(domain string) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.gchar      // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if domain != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_builder_set_translation_domain(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(domain)
}

// ValueFromStringType: like gtk_builder_value_from_string(), this function
// demarshals a value from a string, but takes a #GType instead of Spec. This
// function calls g_value_init() on the value argument, so it need not be
// initialised beforehand.
//
// Upon errors FALSE will be returned and error will be assigned a #GError from
// the K_BUILDER_ERROR domain.
//
// The function takes the following parameters:
//
//    - typ of the value.
//    - str: string representation of the value.
//
// The function returns the following values:
//
//    - value to store the result in.
//
func (builder *Builder) ValueFromStringType(typ coreglib.Type, str string) (coreglib.Value, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 C.GType       // out
	var _arg2 *C.gchar      // out
	var _arg3 C.GValue      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = C.GType(typ)
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_builder_value_from_string_type(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(str)

	var _value coreglib.Value // out
	var _goerr error          // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg3)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// typeFromName looks up a type by name, using the virtual function that Builder
// has for that purpose. This is mainly used when implementing the Buildable
// interface on a type.
//
// The function takes the following parameters:
//
//    - typeName: type name to lookup.
//
// The function returns the following values:
//
//    - gType found for type_name or TYPE_INVALID if no type was found.
//
func (builder *Builder) typeFromName(typeName string) coreglib.Type {
	gclass := (*C.GtkBuilderClass)(coreglib.PeekParentClass(builder))
	fnarg := gclass.get_type_from_name

	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cret C.GType       // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(typeName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gtk3_Builder_virtual_get_type_from_name(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typeName)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gtk3_CellRendererClass_editing_canceled(void*);
// extern void _gotk4_gtk3_CellRendererClass_editing_started(void*, void*, void*);
// extern void _gotk4_gtk3_CellRendererClass_get_preferred_height(void*, void*, void*, void*);
// extern void _gotk4_gtk3_CellRendererClass_get_preferred_height_for_width(void*, void*, gint, void*, void*);
// extern void _gotk4_gtk3_CellRendererClass_get_preferred_width(void*, void*, void*, void*);
// extern void _gotk4_gtk3_CellRendererClass_get_preferred_width_for_height(void*, void*, gint, void*, void*);
// extern void _gotk4_gtk3_CellRendererClass_get_size(void*, void*, void*, void*, void*, void*, void*);
// extern void _gotk4_gtk3_CellRenderer_ConnectEditingCanceled(gpointer, guintptr);
// extern void _gotk4_gtk3_CellRenderer_ConnectEditingStarted(gpointer, void*, void*, guintptr);
import "C"

// glib.Type values for gtkcellrenderer.go.
var (
	GTypeCellRendererMode  = coreglib.Type(C.gtk_cell_renderer_mode_get_type())
	GTypeCellRendererState = coreglib.Type(C.gtk_cell_renderer_state_get_type())
	GTypeCellRenderer      = coreglib.Type(C.gtk_cell_renderer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeCellRendererMode, F: marshalCellRendererMode},
		{T: GTypeCellRendererState, F: marshalCellRendererState},
		{T: GTypeCellRenderer, F: marshalCellRenderer},
	})
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode C.gint

const (
	// CellRendererModeInert: cell is just for display and cannot be interacted
	// with. Note that this doesn’t mean that eg. the row being drawn can’t be
	// selected -- just that a particular element of it cannot be individually
	// modified.
	CellRendererModeInert CellRendererMode = iota
	// CellRendererModeActivatable: cell can be clicked.
	CellRendererModeActivatable
	// CellRendererModeEditable: cell can be edited or otherwise modified.
	CellRendererModeEditable
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CellRendererMode.
func (c CellRendererMode) String() string {
	switch c {
	case CellRendererModeInert:
		return "Inert"
	case CellRendererModeActivatable:
		return "Activatable"
	case CellRendererModeEditable:
		return "Editable"
	default:
		return fmt.Sprintf("CellRendererMode(%d)", c)
	}
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState C.guint

const (
	// CellRendererSelected: cell is currently selected, and probably has a
	// selection colored background to render to.
	CellRendererSelected CellRendererState = 0b1
	// CellRendererPrelit: mouse is hovering over the cell.
	CellRendererPrelit CellRendererState = 0b10
	// CellRendererInsensitive: cell is drawn in an insensitive manner.
	CellRendererInsensitive CellRendererState = 0b100
	// CellRendererSorted: cell is in a sorted row.
	CellRendererSorted CellRendererState = 0b1000
	// CellRendererFocused: cell is in the focus row.
	CellRendererFocused CellRendererState = 0b10000
	// CellRendererExpandable: cell is in a row that can be expanded. Since 3.4.
	CellRendererExpandable CellRendererState = 0b100000
	// CellRendererExpanded: cell is in a row that is expanded. Since 3.4.
	CellRendererExpanded CellRendererState = 0b1000000
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for CellRendererState.
func (c CellRendererState) String() string {
	if c == 0 {
		return "CellRendererState(0)"
	}

	var builder strings.Builder
	builder.Grow(146)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CellRendererSelected:
			builder.WriteString("Selected|")
		case CellRendererPrelit:
			builder.WriteString("Prelit|")
		case CellRendererInsensitive:
			builder.WriteString("Insensitive|")
		case CellRendererSorted:
			builder.WriteString("Sorted|")
		case CellRendererFocused:
			builder.WriteString("Focused|")
		case CellRendererExpandable:
			builder.WriteString("Expandable|")
		case CellRendererExpanded:
			builder.WriteString("Expanded|")
		default:
			builder.WriteString(fmt.Sprintf("CellRendererState(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c CellRendererState) Has(other CellRendererState) bool {
	return (c & other) == other
}

// CellRendererOverrider contains methods that are overridable.
type CellRendererOverrider interface {
	EditingCanceled()
	// The function takes the following parameters:
	//
	//    - editable
	//    - path
	//
	EditingStarted(editable CellEditabler, path string)
	// PreferredHeight retreives a renderer’s natural size when rendered to
	// widget.
	//
	// The function takes the following parameters:
	//
	//    - widget this cell will be rendering to.
	//
	// The function returns the following values:
	//
	//    - minimumSize (optional): location to store the minimum size, or NULL.
	//    - naturalSize (optional): location to store the natural size, or NULL.
	//
	PreferredHeight(widget Widgetter) (minimumSize int32, naturalSize int32)
	// PreferredHeightForWidth retreives a cell renderers’s minimum and natural
	// height if it were rendered to widget with the specified width.
	//
	// The function takes the following parameters:
	//
	//    - widget this cell will be rendering to.
	//    - width: size which is available for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumHeight (optional): location for storing the minimum size, or
	//      NULL.
	//    - naturalHeight (optional): location for storing the preferred size, or
	//      NULL.
	//
	PreferredHeightForWidth(widget Widgetter, width int32) (minimumHeight int32, naturalHeight int32)
	// PreferredWidth retreives a renderer’s natural size when rendered to
	// widget.
	//
	// The function takes the following parameters:
	//
	//    - widget this cell will be rendering to.
	//
	// The function returns the following values:
	//
	//    - minimumSize (optional): location to store the minimum size, or NULL.
	//    - naturalSize (optional): location to store the natural size, or NULL.
	//
	PreferredWidth(widget Widgetter) (minimumSize int32, naturalSize int32)
	// PreferredWidthForHeight retreives a cell renderers’s minimum and natural
	// width if it were rendered to widget with the specified height.
	//
	// The function takes the following parameters:
	//
	//    - widget this cell will be rendering to.
	//    - height: size which is available for allocation.
	//
	// The function returns the following values:
	//
	//    - minimumWidth (optional): location for storing the minimum size, or
	//      NULL.
	//    - naturalWidth (optional): location for storing the preferred size, or
	//      NULL.
	//
	PreferredWidthForHeight(widget Widgetter, height int32) (minimumWidth int32, naturalWidth int32)
	// Size obtains the width and height needed to render the cell. Used by view
	// widgets to determine the appropriate size for the cell_area passed to
	// gtk_cell_renderer_render(). If cell_area is not NULL, fills in the x and
	// y offsets (if set) of the cell relative to this location.
	//
	// Please note that the values set in width and height, as well as those in
	// x_offset and y_offset are inclusive of the xpad and ypad properties.
	//
	// Deprecated: Use gtk_cell_renderer_get_preferred_size() instead.
	//
	// The function takes the following parameters:
	//
	//    - widget the renderer is rendering to.
	//    - cellArea (optional): area a cell will be allocated, or NULL.
	//
	// The function returns the following values:
	//
	//    - xOffset (optional): location to return x offset of cell relative to
	//      cell_area, or NULL.
	//    - yOffset (optional): location to return y offset of cell relative to
	//      cell_area, or NULL.
	//    - width (optional): location to return width needed to render a cell,
	//      or NULL.
	//    - height (optional): location to return height needed to render a cell,
	//      or NULL.
	//
	Size(widget Widgetter, cellArea *gdk.Rectangle) (xOffset int32, yOffset int32, width int32, height int32)
}

// CellRenderer is a base class of a set of objects used for rendering a cell to
// a #cairo_t. These objects are used primarily by the TreeView widget, though
// they aren’t tied to them in any specific way. It is worth noting that
// CellRenderer is not a Widget and cannot be treated as such.
//
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isn’t expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_size(). Finally, the cell is rendered in the correct
// location using gtk_cell_renderer_render().
//
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, it’s important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// Style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be “activatable” like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be “editable” like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
//
// Many properties of CellRenderer and its subclasses have a corresponding “set”
// property, e.g. “cell-background-set” corresponds to “cell-background”. These
// “set” properties reflect whether a property has been set or not. You should
// not set them independently.
type CellRenderer struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned
}

var ()

// CellRendererer describes types inherited from class CellRenderer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type CellRendererer interface {
	coreglib.Objector
	baseCellRenderer() *CellRenderer
}

var _ CellRendererer = (*CellRenderer)(nil)

func classInitCellRendererer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkCellRendererClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkCellRendererClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ EditingCanceled() }); ok {
		pclass.editing_canceled = (*[0]byte)(C._gotk4_gtk3_CellRendererClass_editing_canceled)
	}

	if _, ok := goval.(interface {
		EditingStarted(editable CellEditabler, path string)
	}); ok {
		pclass.editing_started = (*[0]byte)(C._gotk4_gtk3_CellRendererClass_editing_started)
	}

	if _, ok := goval.(interface {
		PreferredHeight(widget Widgetter) (minimumSize int32, naturalSize int32)
	}); ok {
		pclass.get_preferred_height = (*[0]byte)(C._gotk4_gtk3_CellRendererClass_get_preferred_height)
	}

	if _, ok := goval.(interface {
		PreferredHeightForWidth(widget Widgetter, width int32) (minimumHeight int32, naturalHeight int32)
	}); ok {
		pclass.get_preferred_height_for_width = (*[0]byte)(C._gotk4_gtk3_CellRendererClass_get_preferred_height_for_width)
	}

	if _, ok := goval.(interface {
		PreferredWidth(widget Widgetter) (minimumSize int32, naturalSize int32)
	}); ok {
		pclass.get_preferred_width = (*[0]byte)(C._gotk4_gtk3_CellRendererClass_get_preferred_width)
	}

	if _, ok := goval.(interface {
		PreferredWidthForHeight(widget Widgetter, height int32) (minimumWidth int32, naturalWidth int32)
	}); ok {
		pclass.get_preferred_width_for_height = (*[0]byte)(C._gotk4_gtk3_CellRendererClass_get_preferred_width_for_height)
	}

	if _, ok := goval.(interface {
		Size(widget Widgetter, cellArea *gdk.Rectangle) (xOffset int32, yOffset int32, width int32, height int32)
	}); ok {
		pclass.get_size = (*[0]byte)(C._gotk4_gtk3_CellRendererClass_get_size)
	}
}

//export _gotk4_gtk3_CellRendererClass_editing_canceled
func _gotk4_gtk3_CellRendererClass_editing_canceled(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ EditingCanceled() })

	iface.EditingCanceled()
}

//export _gotk4_gtk3_CellRendererClass_editing_started
func _gotk4_gtk3_CellRendererClass_editing_started(arg0 *C.void, arg1 *C.void, arg2 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		EditingStarted(editable CellEditabler, path string)
	})

	var _editable CellEditabler // out
	var _path string            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	iface.EditingStarted(_editable, _path)
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_height
func _gotk4_gtk3_CellRendererClass_get_preferred_height(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeight(widget Widgetter) (minimumSize int32, naturalSize int32)
	})

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := iface.PreferredHeight(_widget)

	*arg2 = (*C.void)(unsafe.Pointer(minimumSize))
	*arg3 = (*C.void)(unsafe.Pointer(naturalSize))
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_height_for_width
func _gotk4_gtk3_CellRendererClass_get_preferred_height_for_width(arg0 *C.void, arg1 *C.void, arg2 C.gint, arg3 *C.void, arg4 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredHeightForWidth(widget Widgetter, width int32) (minimumHeight int32, naturalHeight int32)
	})

	var _widget Widgetter // out
	var _width int32      // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_width = int32(arg2)

	minimumHeight, naturalHeight := iface.PreferredHeightForWidth(_widget, _width)

	*arg3 = (*C.void)(unsafe.Pointer(minimumHeight))
	*arg4 = (*C.void)(unsafe.Pointer(naturalHeight))
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_width
func _gotk4_gtk3_CellRendererClass_get_preferred_width(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredWidth(widget Widgetter) (minimumSize int32, naturalSize int32)
	})

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	minimumSize, naturalSize := iface.PreferredWidth(_widget)

	*arg2 = (*C.void)(unsafe.Pointer(minimumSize))
	*arg3 = (*C.void)(unsafe.Pointer(naturalSize))
}

//export _gotk4_gtk3_CellRendererClass_get_preferred_width_for_height
func _gotk4_gtk3_CellRendererClass_get_preferred_width_for_height(arg0 *C.void, arg1 *C.void, arg2 C.gint, arg3 *C.void, arg4 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PreferredWidthForHeight(widget Widgetter, height int32) (minimumWidth int32, naturalWidth int32)
	})

	var _widget Widgetter // out
	var _height int32     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	_height = int32(arg2)

	minimumWidth, naturalWidth := iface.PreferredWidthForHeight(_widget, _height)

	*arg3 = (*C.void)(unsafe.Pointer(minimumWidth))
	*arg4 = (*C.void)(unsafe.Pointer(naturalWidth))
}

//export _gotk4_gtk3_CellRendererClass_get_size
func _gotk4_gtk3_CellRendererClass_get_size(arg0 *C.void, arg1 *C.void, arg2 *C.void, arg3 *C.void, arg4 *C.void, arg5 *C.void, arg6 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Size(widget Widgetter, cellArea *gdk.Rectangle) (xOffset int32, yOffset int32, width int32, height int32)
	})

	var _widget Widgetter        // out
	var _cellArea *gdk.Rectangle // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}
	if arg2 != nil {
		_cellArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	}

	xOffset, yOffset, width, height := iface.Size(_widget, _cellArea)

	*arg3 = (*C.void)(unsafe.Pointer(xOffset))
	*arg4 = (*C.void)(unsafe.Pointer(yOffset))
	*arg5 = (*C.void)(unsafe.Pointer(width))
	*arg6 = (*C.void)(unsafe.Pointer(height))
}

func wrapCellRenderer(obj *coreglib.Object) *CellRenderer {
	return &CellRenderer{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
	}
}

func marshalCellRenderer(p uintptr) (interface{}, error) {
	return wrapCellRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (cell *CellRenderer) baseCellRenderer() *CellRenderer {
	return cell
}

// BaseCellRenderer returns the underlying base object.
func BaseCellRenderer(obj CellRendererer) *CellRenderer {
	return obj.baseCellRenderer()
}

//export _gotk4_gtk3_CellRenderer_ConnectEditingCanceled
func _gotk4_gtk3_CellRenderer_ConnectEditingCanceled(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectEditingCanceled: this signal gets emitted when the user cancels the
// process of editing a cell. For example, an editable cell renderer could be
// written to cancel editing when the user presses Escape.
//
// See also: gtk_cell_renderer_stop_editing().
func (cell *CellRenderer) ConnectEditingCanceled(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cell, "editing-canceled", false, unsafe.Pointer(C._gotk4_gtk3_CellRenderer_ConnectEditingCanceled), f)
}

//export _gotk4_gtk3_CellRenderer_ConnectEditingStarted
func _gotk4_gtk3_CellRenderer_ConnectEditingStarted(arg0 C.gpointer, arg1 *C.void, arg2 *C.void, arg3 C.guintptr) {
	var f func(editable CellEditabler, path string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(editable CellEditabler, path string))
	}

	var _editable CellEditabler // out
	var _path string            // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.CellEditabler is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellEditabler)
			return ok
		})
		rv, ok := casted.(CellEditabler)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellEditabler")
		}
		_editable = rv
	}
	_path = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_editable, _path)
}

// ConnectEditingStarted: this signal gets emitted when a cell starts to be
// edited. The intended use of this signal is to do special setup on editable,
// e.g. adding a EntryCompletion or setting up additional columns in a ComboBox.
//
// See gtk_cell_editable_start_editing() for information on the lifecycle of the
// editable and a way to do setup that doesn’t depend on the renderer.
//
// Note that GTK+ doesn't guarantee that cell renderers will continue to use the
// same kind of widget for editing in future releases, therefore you should
// check the type of editable before doing any specific setup, as in the
// following example:
//
//    static void
//    text_editing_started (GtkCellRenderer *cell,
//                          GtkCellEditable *editable,
//                          const gchar     *path,
//                          gpointer         data)
//    {
//      if (GTK_IS_ENTRY (editable))
//        {
//          GtkEntry *entry = GTK_ENTRY (editable);
//
//          // ... create a GtkEntryCompletion
//
//          gtk_entry_set_completion (entry, completion);
//        }
//    }.
func (cell *CellRenderer) ConnectEditingStarted(f func(editable CellEditabler, path string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cell, "editing-started", false, unsafe.Pointer(C._gotk4_gtk3_CellRenderer_ConnectEditingStarted), f)
}

// Alignment fills in xalign and yalign with the appropriate values of cell.
//
// The function returns the following values:
//
//    - xalign (optional): location to fill in with the x alignment of the cell,
//      or NULL.
//    - yalign (optional): location to fill in with the y alignment of the cell,
//      or NULL.
//
func (cell *CellRenderer) Alignment() (xalign float32, yalign float32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_alignment", _args[:], _outs[:])

	runtime.KeepAlive(cell)

	var _xalign float32 // out
	var _yalign float32 // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_xalign = *(*float32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_yalign = *(*float32)(unsafe.Pointer(_out1))
	}

	return _xalign, _yalign
}

// FixedSize fills in width and height with the appropriate size of cell.
//
// The function returns the following values:
//
//    - width (optional): location to fill in with the fixed width of the cell,
//      or NULL.
//    - height (optional): location to fill in with the fixed height of the cell,
//      or NULL.
//
func (cell *CellRenderer) FixedSize() (width int32, height int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_fixed_size", _args[:], _outs[:])

	runtime.KeepAlive(cell)

	var _width int32  // out
	var _height int32 // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_width = *(*int32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_height = *(*int32)(unsafe.Pointer(_out1))
	}

	return _width, _height
}

// Padding fills in xpad and ypad with the appropriate values of cell.
//
// The function returns the following values:
//
//    - xpad (optional): location to fill in with the x padding of the cell, or
//      NULL.
//    - ypad (optional): location to fill in with the y padding of the cell, or
//      NULL.
//
func (cell *CellRenderer) Padding() (xpad int32, ypad int32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_padding", _args[:], _outs[:])

	runtime.KeepAlive(cell)

	var _xpad int32 // out
	var _ypad int32 // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_xpad = *(*int32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_ypad = *(*int32)(unsafe.Pointer(_out1))
	}

	return _xpad, _ypad
}

// PreferredHeight retreives a renderer’s natural size when rendered to widget.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//
// The function returns the following values:
//
//    - minimumSize (optional): location to store the minimum size, or NULL.
//    - naturalSize (optional): location to store the natural size, or NULL.
//
func (cell *CellRenderer) PreferredHeight(widget Widgetter) (minimumSize int32, naturalSize int32) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_height", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize int32 // out
	var _naturalSize int32 // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_minimumSize = *(*int32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_naturalSize = *(*int32)(unsafe.Pointer(_out1))
	}

	return _minimumSize, _naturalSize
}

// PreferredHeightForWidth retreives a cell renderers’s minimum and natural
// height if it were rendered to widget with the specified width.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//    - width: size which is available for allocation.
//
// The function returns the following values:
//
//    - minimumHeight (optional): location for storing the minimum size, or NULL.
//    - naturalHeight (optional): location for storing the preferred size, or
//      NULL.
//
func (cell *CellRenderer) PreferredHeightForWidth(widget Widgetter, width int32) (minimumHeight int32, naturalHeight int32) {
	var _args [3]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.gint(width)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1
	*(*C.gint)(unsafe.Pointer(&_args[2])) = _arg2

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_height_for_width", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int32 // out
	var _naturalHeight int32 // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_minimumHeight = *(*int32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_naturalHeight = *(*int32)(unsafe.Pointer(_out1))
	}

	return _minimumHeight, _naturalHeight
}

// PreferredSize retrieves the minimum and natural size of a cell taking into
// account the widget’s preference for height-for-width management.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//
// The function returns the following values:
//
//    - minimumSize (optional): location for storing the minimum size, or NULL.
//    - naturalSize (optional): location for storing the natural size, or NULL.
//
func (cell *CellRenderer) PreferredSize(widget Widgetter) (minimumSize *Requisition, naturalSize *Requisition) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_size", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize *Requisition // out
	var _naturalSize *Requisition // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_minimumSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_out0)))
	}
	if _out1 != nil {
		_naturalSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_out1)))
	}

	return _minimumSize, _naturalSize
}

// PreferredWidth retreives a renderer’s natural size when rendered to widget.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//
// The function returns the following values:
//
//    - minimumSize (optional): location to store the minimum size, or NULL.
//    - naturalSize (optional): location to store the natural size, or NULL.
//
func (cell *CellRenderer) PreferredWidth(widget Widgetter) (minimumSize int32, naturalSize int32) {
	var _args [2]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_width", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize int32 // out
	var _naturalSize int32 // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_minimumSize = *(*int32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_naturalSize = *(*int32)(unsafe.Pointer(_out1))
	}

	return _minimumSize, _naturalSize
}

// PreferredWidthForHeight retreives a cell renderers’s minimum and natural
// width if it were rendered to widget with the specified height.
//
// The function takes the following parameters:
//
//    - widget this cell will be rendering to.
//    - height: size which is available for allocation.
//
// The function returns the following values:
//
//    - minimumWidth (optional): location for storing the minimum size, or NULL.
//    - naturalWidth (optional): location for storing the preferred size, or
//      NULL.
//
func (cell *CellRenderer) PreferredWidthForHeight(widget Widgetter, height int32) (minimumWidth int32, naturalWidth int32) {
	var _args [3]girepository.Argument
	var _outs [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _out0 *C.void // in
	var _out1 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.gint(height)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1
	*(*C.gint)(unsafe.Pointer(&_args[2])) = _arg2

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_preferred_width_for_height", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int32 // out
	var _naturalWidth int32 // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))

	if _out0 != nil {
		_minimumWidth = *(*int32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_naturalWidth = *(*int32)(unsafe.Pointer(_out1))
	}

	return _minimumWidth, _naturalWidth
}

// Sensitive returns the cell renderer’s sensitivity.
//
// The function returns the following values:
//
//    - ok: TRUE if the cell renderer is sensitive.
//
func (cell *CellRenderer) Sensitive() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_sensitive", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(cell)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size obtains the width and height needed to render the cell. Used by view
// widgets to determine the appropriate size for the cell_area passed to
// gtk_cell_renderer_render(). If cell_area is not NULL, fills in the x and y
// offsets (if set) of the cell relative to this location.
//
// Please note that the values set in width and height, as well as those in
// x_offset and y_offset are inclusive of the xpad and ypad properties.
//
// Deprecated: Use gtk_cell_renderer_get_preferred_size() instead.
//
// The function takes the following parameters:
//
//    - widget the renderer is rendering to.
//    - cellArea (optional): area a cell will be allocated, or NULL.
//
// The function returns the following values:
//
//    - xOffset (optional): location to return x offset of cell relative to
//      cell_area, or NULL.
//    - yOffset (optional): location to return y offset of cell relative to
//      cell_area, or NULL.
//    - width (optional): location to return width needed to render a cell, or
//      NULL.
//    - height (optional): location to return height needed to render a cell, or
//      NULL.
//
func (cell *CellRenderer) Size(widget Widgetter, cellArea *gdk.Rectangle) (xOffset int32, yOffset int32, width int32, height int32) {
	var _args [3]girepository.Argument
	var _outs [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _out0 *C.void // in
	var _out1 *C.void // in
	var _out2 *C.void // in
	var _out3 *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if cellArea != nil {
		_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(cellArea)))
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(**C.void)(unsafe.Pointer(&_args[1])) = _arg1
	*(**C.void)(unsafe.Pointer(&_args[2])) = _arg2

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_size", _args[:], _outs[:])

	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)

	var _xOffset int32 // out
	var _yOffset int32 // out
	var _width int32   // out
	var _height int32  // out
	_out0 = *(**C.void)(unsafe.Pointer(&_outs[0]))
	_out1 = *(**C.void)(unsafe.Pointer(&_outs[1]))
	_out2 = *(**C.void)(unsafe.Pointer(&_outs[2]))
	_out3 = *(**C.void)(unsafe.Pointer(&_outs[3]))

	if _out0 != nil {
		_xOffset = *(*int32)(unsafe.Pointer(_out0))
	}
	if _out1 != nil {
		_yOffset = *(*int32)(unsafe.Pointer(_out1))
	}
	if _out2 != nil {
		_width = *(*int32)(unsafe.Pointer(_out2))
	}
	if _out3 != nil {
		_height = *(*int32)(unsafe.Pointer(_out3))
	}

	return _xOffset, _yOffset, _width, _height
}

// Visible returns the cell renderer’s visibility.
//
// The function returns the following values:
//
//    - ok: TRUE if the cell renderer is visible.
//
func (cell *CellRenderer) Visible() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("get_visible", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(cell)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActivatable checks whether the cell renderer can do something when
// activated.
//
// The function returns the following values:
//
//    - ok: TRUE if the cell renderer can do anything when activated.
//
func (cell *CellRenderer) IsActivatable() bool {
	var _args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("is_activatable", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(cell)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAlignment sets the renderer’s alignment within its available space.
//
// The function takes the following parameters:
//
//    - xalign: x alignment of the cell renderer.
//    - yalign: y alignment of the cell renderer.
//
func (cell *CellRenderer) SetAlignment(xalign, yalign float32) {
	var _args [3]girepository.Argument
	var _arg0 *C.void  // out
	var _arg1 C.gfloat // out
	var _arg2 C.gfloat // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = C.gfloat(xalign)
	_arg2 = C.gfloat(yalign)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gfloat)(unsafe.Pointer(&_args[1])) = _arg1
	*(*C.gfloat)(unsafe.Pointer(&_args[2])) = _arg2

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_alignment", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
}

// SetFixedSize sets the renderer size to be explicit, independent of the
// properties set.
//
// The function takes the following parameters:
//
//    - width of the cell renderer, or -1.
//    - height of the cell renderer, or -1.
//
func (cell *CellRenderer) SetFixedSize(width, height int32) {
	var _args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = C.gint(width)
	_arg2 = C.gint(height)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gint)(unsafe.Pointer(&_args[1])) = _arg1
	*(*C.gint)(unsafe.Pointer(&_args[2])) = _arg2

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_fixed_size", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetPadding sets the renderer’s padding.
//
// The function takes the following parameters:
//
//    - xpad: x padding of the cell renderer.
//    - ypad: y padding of the cell renderer.
//
func (cell *CellRenderer) SetPadding(xpad, ypad int32) {
	var _args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = C.gint(xpad)
	_arg2 = C.gint(ypad)

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gint)(unsafe.Pointer(&_args[1])) = _arg1
	*(*C.gint)(unsafe.Pointer(&_args[2])) = _arg2

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_padding", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(xpad)
	runtime.KeepAlive(ypad)
}

// SetSensitive sets the cell renderer’s sensitivity.
//
// The function takes the following parameters:
//
//    - sensitive: sensitivity of the cell.
//
func (cell *CellRenderer) SetSensitive(sensitive bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_sensitive", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(sensitive)
}

// SetVisible sets the cell renderer’s visibility.
//
// The function takes the following parameters:
//
//    - visible: visibility of the cell.
//
func (cell *CellRenderer) SetVisible(visible bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("set_visible", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(visible)
}

// StopEditing informs the cell renderer that the editing is stopped. If
// canceled is TRUE, the cell renderer will emit the
// CellRenderer::editing-canceled signal.
//
// This function should be called by cell renderer implementations in response
// to the CellEditable::editing-done signal of CellEditable.
//
// The function takes the following parameters:
//
//    - canceled: TRUE if the editing has been canceled.
//
func (cell *CellRenderer) StopEditing(canceled bool) {
	var _args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if canceled {
		_arg1 = C.TRUE
	}

	*(**C.void)(unsafe.Pointer(&_args[0])) = _arg0
	*(*C.gboolean)(unsafe.Pointer(&_args[1])) = _arg1

	girepository.MustFind("Gtk", "CellRenderer").InvokeMethod("stop_editing", _args[:], nil)

	runtime.KeepAlive(cell)
	runtime.KeepAlive(canceled)
}

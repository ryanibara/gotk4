// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// NewApplication creates a new Application instance.
//
// When using Application, it is not necessary to call gtk_init() manually. It
// is called as soon as the application gets registered as the primary instance.
//
// Concretely, gtk_init() is called in the default handler for the
// #GApplication::startup signal. Therefore, Application subclasses should chain
// up in their #GApplication::startup handler before using any GTK+ API.
//
// Note that commandline arguments are not passed to gtk_init(). All GTK+
// functionality that is available via commandline arguments can also be
// achieved by setting suitable environment variables such as G_DEBUG, so this
// should not be a big problem. If you absolutely must support GTK+ commandline
// arguments, you can explicitly call gtk_init() before creating the application
// instance.
//
// If non-NULL, the application ID must be valid. See
// g_application_id_is_valid().
//
// If no application ID is given then some features (most notably application
// uniqueness) will be disabled. A null application ID is only allowed with GTK+
// 3.6 or later.
//
// The function takes the following parameters:
//
//    - applicationId (optional): application ID.
//    - flags: application flags.
//
// The function returns the following values:
//
//    - application: new Application instance.
//
func NewApplication(applicationId string, flags gio.ApplicationFlags) *Application {
	var _arg1 *C.gchar            // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GtkApplication   // in

	if applicationId != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GApplicationFlags(flags)

	_cret = C.gtk_application_new(_arg1, _arg2)
	runtime.KeepAlive(applicationId)
	runtime.KeepAlive(flags)

	var _application *Application // out

	_application = wrapApplication(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _application
}

// AddWindow adds a window to application.
//
// This call can only happen after the application has started; typically, you
// should add new application windows in response to the emission of the
// #GApplication::activate signal.
//
// This call is equivalent to setting the Window:application property of window
// to application.
//
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it with
// gtk_application_remove_window().
//
// GTK+ will keep the application running as long as it has any windows.
//
// The function takes the following parameters:
//
//    - window: Window.
//
func (application *Application) AddWindow(window *Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_application_add_window(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
}

// Windows gets a list of the Windows associated with application.
//
// The list is sorted by most recently focused window, such that the first
// element is the currently focused window. (Useful for choosing a parent for a
// transient window.)
//
// The list that is returned should not be modified in any way. It will only
// remain valid until the next focus change or window creation or deletion.
//
// The function returns the following values:
//
//    - list of Window.
//
func (application *Application) Windows() []*Window {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GList          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_get_windows(_arg0)
	runtime.KeepAlive(application)

	var _list []*Window // out

	_list = make([]*Window, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkWindow)(v)
		var dst *Window // out
		dst = wrapWindow(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// RemoveWindow: remove a window from application.
//
// If window belongs to application then this call is equivalent to setting the
// Window:application property of window to NULL.
//
// The application may stop running as a result of a call to this function.
//
// The function takes the following parameters:
//
//    - window: Window.
//
func (application *Application) RemoveWindow(window *Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_application_remove_window(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gtkaccelgroup.go.
var (
	GTypeAccelFlags = coreglib.Type(C.gtk_accel_flags_get_type())
	GTypeAccelGroup = coreglib.Type(C.gtk_accel_group_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeAccelFlags, F: marshalAccelFlags},
		{T: GTypeAccelGroup, F: marshalAccelGroup},
	})
}

// AccelFlags: accelerator flags used with gtk_accel_group_connect().
type AccelFlags C.guint

const (
	// AccelVisible: accelerator is visible.
	AccelVisible AccelFlags = 0b1
	// AccelLocked: accelerator not removable.
	AccelLocked AccelFlags = 0b10
	// AccelMask: mask.
	AccelMask AccelFlags = 0b111
)

func marshalAccelFlags(p uintptr) (interface{}, error) {
	return AccelFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AccelFlags.
func (a AccelFlags) String() string {
	if a == 0 {
		return "AccelFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(34)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AccelVisible:
			builder.WriteString("Visible|")
		case AccelLocked:
			builder.WriteString("Locked|")
		case AccelMask:
			builder.WriteString("Mask|")
		default:
			builder.WriteString(fmt.Sprintf("AccelFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AccelFlags) Has(other AccelFlags) bool {
	return (a & other) == other
}

// AccelGroupsFromObject gets a list of all accel groups which are attached to
// object.
//
// The function takes the following parameters:
//
//    - object usually a Window.
//
// The function returns the following values:
//
//    - sList: list of all accel groups which are attached to object.
//
func AccelGroupsFromObject(object *coreglib.Object) []*AccelGroup {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(object.Native()))
	*(**coreglib.Object)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "accel_groups_from_object").Invoke(args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(object)

	var _sList []*AccelGroup // out

	_sList = make([]*AccelGroup, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *AccelGroup // out
		dst = wrapAccelGroup(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// AccelGroupOverrider contains methods that are overridable.
type AccelGroupOverrider interface {
}

// AccelGroup represents a group of keyboard accelerators, typically attached to
// a toplevel Window (with gtk_window_add_accel_group()). Usually you won’t need
// to create a AccelGroup directly; instead, when using UIManager, GTK+
// automatically sets up the accelerators for your menus in the ui manager’s
// AccelGroup.
//
// Note that “accelerators” are different from “mnemonics”. Accelerators are
// shortcuts for activating a menu item; they appear alongside the menu item
// they’re a shortcut for. For example “Ctrl+Q” might appear alongside the
// “Quit” menu item. Mnemonics are shortcuts for GUI elements such as text
// entries or buttons; they appear as underlined characters. See
// gtk_label_new_with_mnemonic(). Menu items can have both accelerators and
// mnemonics, of course.
type AccelGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AccelGroup)(nil)
)

func classInitAccelGrouper(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapAccelGroup(obj *coreglib.Object) *AccelGroup {
	return &AccelGroup{
		Object: obj,
	}
}

func marshalAccelGroup(p uintptr) (interface{}, error) {
	return wrapAccelGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewAccelGroup creates a new AccelGroup.
//
// The function returns the following values:
//
//    - accelGroup: new AccelGroup object.
//
func NewAccelGroup() *AccelGroup {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("new_AccelGroup", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _accelGroup *AccelGroup // out

	_accelGroup = wrapAccelGroup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _accelGroup
}

// ConnectByPath installs an accelerator in this group, using an accelerator
// path to look up the appropriate key and modifiers (see
// gtk_accel_map_add_entry()). When accel_group is being activated in response
// to a call to gtk_accel_groups_activate(), closure will be invoked if the
// accel_key and accel_mods from gtk_accel_groups_activate() match the key and
// modifiers for the path.
//
// The signature used for the closure is that of AccelGroupActivate.
//
// Note that accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
//
// The function takes the following parameters:
//
//    - accelPath: path used for determining key and modifiers.
//    - closure to be executed upon accelerator activation.
//
func (accelGroup *AccelGroup) ConnectByPath(accelPath string, closure coreglib.AnyClosure) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(accelPath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(accelGroup), closure))
	*(**AccelGroup)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("connect_by_path", args[:], nil)

	runtime.KeepAlive(accelGroup)
	runtime.KeepAlive(accelPath)
	runtime.KeepAlive(closure)
}

// Disconnect removes an accelerator previously installed through
// gtk_accel_group_connect().
//
// Since 2.20 closure can be NULL.
//
// The function takes the following parameters:
//
//    - closure (optional) to remove from this accelerator group, or NULL to
//      remove all closures.
//
// The function returns the following values:
//
//    - ok: TRUE if the closure was found and got disconnected.
//
func (accelGroup *AccelGroup) Disconnect(closure coreglib.AnyClosure) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	_arg1 = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(accelGroup), closure))
	*(**AccelGroup)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("disconnect", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accelGroup)
	runtime.KeepAlive(closure)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLocked locks are added and removed using gtk_accel_group_lock() and
// gtk_accel_group_unlock().
//
// The function returns the following values:
//
//    - ok: TRUE if there are 1 or more locks on the accel_group, FALSE
//      otherwise.
//
func (accelGroup *AccelGroup) IsLocked() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	*(**AccelGroup)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("get_is_locked", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accelGroup)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Lock locks the given accelerator group.
//
// Locking an acelerator group prevents the accelerators contained within it to
// be changed during runtime. Refer to gtk_accel_map_change_entry() about
// runtime accelerator changes.
//
// If called more than once, accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number of times.
func (accelGroup *AccelGroup) Lock() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	*(**AccelGroup)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("lock", args[:], nil)

	runtime.KeepAlive(accelGroup)
}

// Unlock undoes the last call to gtk_accel_group_lock() on this accel_group.
func (accelGroup *AccelGroup) Unlock() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	*(**AccelGroup)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("unlock", args[:], nil)

	runtime.KeepAlive(accelGroup)
}

// AccelGroupEntry: instance of this type is always passed by reference.
type AccelGroupEntry struct {
	*accelGroupEntry
}

// accelGroupEntry is the struct that's finalized.
type accelGroupEntry struct {
	native *C.GtkAccelGroupEntry
}

// AccelKey: instance of this type is always passed by reference.
type AccelKey struct {
	*accelKey
}

// accelKey is the struct that's finalized.
type accelKey struct {
	native *C.GtkAccelKey
}

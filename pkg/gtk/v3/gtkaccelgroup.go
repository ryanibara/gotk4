// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// GTypeAccelFlags returns the GType for the type AccelFlags.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeAccelFlags() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "AccelFlags").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalAccelFlags)
	return gtype
}

// GTypeAccelGroup returns the GType for the type AccelGroup.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeAccelGroup() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "AccelGroup").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalAccelGroup)
	return gtype
}

// AccelFlags: accelerator flags used with gtk_accel_group_connect().
type AccelFlags C.guint

const (
	// AccelVisible: accelerator is visible.
	AccelVisible AccelFlags = 0b1
	// AccelLocked: accelerator not removable.
	AccelLocked AccelFlags = 0b10
	// AccelMask: mask.
	AccelMask AccelFlags = 0b111
)

func marshalAccelFlags(p uintptr) (interface{}, error) {
	return AccelFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for AccelFlags.
func (a AccelFlags) String() string {
	if a == 0 {
		return "AccelFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(34)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case AccelVisible:
			builder.WriteString("Visible|")
		case AccelLocked:
			builder.WriteString("Locked|")
		case AccelMask:
			builder.WriteString("Mask|")
		default:
			builder.WriteString(fmt.Sprintf("AccelFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a AccelFlags) Has(other AccelFlags) bool {
	return (a & other) == other
}

// AccelGroupsFromObject gets a list of all accel groups which are attached to
// object.
//
// The function takes the following parameters:
//
//    - object usually a Window.
//
// The function returns the following values:
//
//    - sList: list of all accel groups which are attached to object.
//
func AccelGroupsFromObject(object *coreglib.Object) []*AccelGroup {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(object.Native()))

	_gret := girepository.MustFind("Gtk", "accel_groups_from_object").Invoke(_args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(object)

	var _sList []*AccelGroup // out

	_sList = make([]*AccelGroup, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *AccelGroup // out
		dst = wrapAccelGroup(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// AcceleratorParse parses a string representing an accelerator. The format
// looks like “<Control>a” or “<Shift><Alt>F1” or “<Release>z” (the last one is
// for key release).
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk_keyval_from_name(). For character keys the name is not the symbol, but
// the lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
//
// If the parse fails, accelerator_key and accelerator_mods will be set to 0
// (zero).
//
// The function takes the following parameters:
//
//    - accelerator: string representing an accelerator.
//
// The function returns the following values:
//
//    - acceleratorKey (optional): return location for accelerator keyval, or
//      NULL.
//    - acceleratorMods (optional): return location for accelerator modifier
//      mask, NULL.
//
func AcceleratorParse(accelerator string) (uint32, gdk.ModifierType) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_args[0]))

	girepository.MustFind("Gtk", "accelerator_parse").Invoke(_args[:], _outs[:])

	runtime.KeepAlive(accelerator)

	var _acceleratorKey uint32            // out
	var _acceleratorMods gdk.ModifierType // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_acceleratorKey = *(*uint32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		_acceleratorMods = *(*gdk.ModifierType)(unsafe.Pointer(_outs[1]))
	}

	return _acceleratorKey, _acceleratorMods
}

// AcceleratorParseWithKeycode parses a string representing an accelerator,
// similarly to gtk_accelerator_parse() but handles keycodes as well. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If accelerator_codes is given and the result stored in it is non-NULL, the
// result must be freed with g_free().
//
// If a keycode is present in the accelerator and no accelerator_codes is given,
// the parse will fail.
//
// If the parse fails, accelerator_key, accelerator_mods and accelerator_codes
// will be set to 0 (zero).
//
// The function takes the following parameters:
//
//    - accelerator: string representing an accelerator.
//
// The function returns the following values:
//
//    - acceleratorKey (optional): return location for accelerator keyval, or
//      NULL.
//    - acceleratorCodes (optional): return location for accelerator keycodes, or
//      NULL.
//    - acceleratorMods (optional): return location for accelerator modifier
//      mask, NULL.
//
func AcceleratorParseWithKeycode(accelerator string) (uint32, []uint32, gdk.ModifierType) {
	var _args [1]girepository.Argument
	var _outs [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_args[0]))

	girepository.MustFind("Gtk", "accelerator_parse_with_keycode").Invoke(_args[:], _outs[:])

	runtime.KeepAlive(accelerator)

	var _acceleratorKey uint32            // out
	var _acceleratorCodes []uint32        // out
	var _acceleratorMods gdk.ModifierType // out

	if *(**C.void)(unsafe.Pointer(&_outs[0])) != nil {
		_acceleratorKey = *(*uint32)(unsafe.Pointer(_outs[0]))
	}
	if *(**C.void)(unsafe.Pointer(&_outs[1])) != nil {
		defer C.free(unsafe.Pointer(_outs[1]))
		{
			var i int
			var z *C.void
			for p := _outs[1]; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_outs[1], i)
			_acceleratorCodes = make([]uint32, i)
			for i := range src {
				_acceleratorCodes[i] = *(*uint32)(unsafe.Pointer(src[i]))
			}
		}
	}
	if *(**C.void)(unsafe.Pointer(&_outs[2])) != nil {
		_acceleratorMods = *(*gdk.ModifierType)(unsafe.Pointer(_outs[2]))
	}

	return _acceleratorKey, _acceleratorCodes, _acceleratorMods
}

// AccelGroupOverrider contains methods that are overridable.
type AccelGroupOverrider interface {
}

// AccelGroup represents a group of keyboard accelerators, typically attached to
// a toplevel Window (with gtk_window_add_accel_group()). Usually you won’t need
// to create a AccelGroup directly; instead, when using UIManager, GTK+
// automatically sets up the accelerators for your menus in the ui manager’s
// AccelGroup.
//
// Note that “accelerators” are different from “mnemonics”. Accelerators are
// shortcuts for activating a menu item; they appear alongside the menu item
// they’re a shortcut for. For example “Ctrl+Q” might appear alongside the
// “Quit” menu item. Mnemonics are shortcuts for GUI elements such as text
// entries or buttons; they appear as underlined characters. See
// gtk_label_new_with_mnemonic(). Menu items can have both accelerators and
// mnemonics, of course.
type AccelGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AccelGroup)(nil)
)

func classInitAccelGrouper(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapAccelGroup(obj *coreglib.Object) *AccelGroup {
	return &AccelGroup{
		Object: obj,
	}
}

func marshalAccelGroup(p uintptr) (interface{}, error) {
	return wrapAccelGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewAccelGroup creates a new AccelGroup.
//
// The function returns the following values:
//
//    - accelGroup: new AccelGroup object.
//
func NewAccelGroup() *AccelGroup {
	_gret := girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("new_AccelGroup", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _accelGroup *AccelGroup // out

	_accelGroup = wrapAccelGroup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _accelGroup
}

// ConnectByPath installs an accelerator in this group, using an accelerator
// path to look up the appropriate key and modifiers (see
// gtk_accel_map_add_entry()). When accel_group is being activated in response
// to a call to gtk_accel_groups_activate(), closure will be invoked if the
// accel_key and accel_mods from gtk_accel_groups_activate() match the key and
// modifiers for the path.
//
// The signature used for the closure is that of AccelGroupActivate.
//
// Note that accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
//
// The function takes the following parameters:
//
//    - accelPath: path used for determining key and modifiers.
//    - closure to be executed upon accelerator activation.
//
func (accelGroup *AccelGroup) ConnectByPath(accelPath string, closure coreglib.AnyClosure) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(C.CString(accelPath)))
	defer C.free(unsafe.Pointer(_args[1]))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(accelGroup), closure))

	girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("connect_by_path", _args[:], nil)

	runtime.KeepAlive(accelGroup)
	runtime.KeepAlive(accelPath)
	runtime.KeepAlive(closure)
}

// Disconnect removes an accelerator previously installed through
// gtk_accel_group_connect().
//
// Since 2.20 closure can be NULL.
//
// The function takes the following parameters:
//
//    - closure (optional) to remove from this accelerator group, or NULL to
//      remove all closures.
//
// The function returns the following values:
//
//    - ok: TRUE if the closure was found and got disconnected.
//
func (accelGroup *AccelGroup) Disconnect(closure coreglib.AnyClosure) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.GClosure)(coreglib.NewClosure(coreglib.InternObject(accelGroup), closure))

	_gret := girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("disconnect", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accelGroup)
	runtime.KeepAlive(closure)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsLocked locks are added and removed using gtk_accel_group_lock() and
// gtk_accel_group_unlock().
//
// The function returns the following values:
//
//    - ok: TRUE if there are 1 or more locks on the accel_group, FALSE
//      otherwise.
//
func (accelGroup *AccelGroup) IsLocked() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))

	_gret := girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("get_is_locked", _args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(accelGroup)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Lock locks the given accelerator group.
//
// Locking an acelerator group prevents the accelerators contained within it to
// be changed during runtime. Refer to gtk_accel_map_change_entry() about
// runtime accelerator changes.
//
// If called more than once, accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number of times.
func (accelGroup *AccelGroup) Lock() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))

	girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("lock", _args[:], nil)

	runtime.KeepAlive(accelGroup)
}

// Unlock undoes the last call to gtk_accel_group_lock() on this accel_group.
func (accelGroup *AccelGroup) Unlock() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(accelGroup).Native()))

	girepository.MustFind("Gtk", "AccelGroup").InvokeMethod("unlock", _args[:], nil)

	runtime.KeepAlive(accelGroup)
}

// AccelGroupEntry: instance of this type is always passed by reference.
type AccelGroupEntry struct {
	*accelGroupEntry
}

// accelGroupEntry is the struct that's finalized.
type accelGroupEntry struct {
	native unsafe.Pointer
}

// AccelKey: instance of this type is always passed by reference.
type AccelKey struct {
	*accelKey
}

// accelKey is the struct that's finalized.
type accelKey struct {
	native unsafe.Pointer
}

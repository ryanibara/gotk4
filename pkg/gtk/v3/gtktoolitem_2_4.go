// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// NewToolItem creates a new ToolItem.
//
// The function returns the following values:
//
//    - toolItem: new ToolItem.
//
func NewToolItem() *ToolItem {
	var _cret *C.GtkToolItem // in

	_cret = C.gtk_tool_item_new()

	var _toolItem *ToolItem // out

	_toolItem = wrapToolItem(coreglib.Take(unsafe.Pointer(_cret)))

	return _toolItem
}

// Expand returns whether tool_item is allocated extra space. See
// gtk_tool_item_set_expand().
//
// The function returns the following values:
//
//    - ok: TRUE if tool_item is allocated extra space.
//
func (toolItem *ToolItem) Expand() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_expand(_arg0)
	runtime.KeepAlive(toolItem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Homogeneous returns whether tool_item is the same size as other homogeneous
// items. See gtk_tool_item_set_homogeneous().
//
// The function returns the following values:
//
//    - ok: TRUE if the item is the same size as other homogeneous items.
//
func (toolItem *ToolItem) Homogeneous() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_homogeneous(_arg0)
	runtime.KeepAlive(toolItem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconSize returns the icon size used for tool_item. Custom subclasses of
// ToolItem should call this function to find out what size icons they should
// use.
//
// The function returns the following values:
//
//    - gint indicating the icon size used for tool_item.
//
func (toolItem *ToolItem) IconSize() int {
	var _arg0 *C.GtkToolItem // out
	var _cret C.GtkIconSize  // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_icon_size(_arg0)
	runtime.KeepAlive(toolItem)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsImportant returns whether tool_item is considered important. See
// gtk_tool_item_set_is_important().
//
// The function returns the following values:
//
//    - ok: TRUE if tool_item is considered important.
//
func (toolItem *ToolItem) IsImportant() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_is_important(_arg0)
	runtime.KeepAlive(toolItem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Orientation returns the orientation used for tool_item. Custom subclasses of
// ToolItem should call this function to find out what size icons they should
// use.
//
// The function returns the following values:
//
//    - orientation indicating the orientation used for tool_item.
//
func (toolItem *ToolItem) Orientation() Orientation {
	var _arg0 *C.GtkToolItem   // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_orientation(_arg0)
	runtime.KeepAlive(toolItem)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// ProxyMenuItem: if menu_item_id matches the string passed to
// gtk_tool_item_set_proxy_menu_item() return the corresponding MenuItem.
//
// Custom subclasses of ToolItem should use this function to update their menu
// item when the ToolItem changes. That the menu_item_ids must match ensures
// that a ToolItem will not inadvertently change a menu item that they did not
// create.
//
// The function takes the following parameters:
//
//    - menuItemId: string used to identify the menu item.
//
// The function returns the following values:
//
//    - widget (optional) passed to gtk_tool_item_set_proxy_menu_item(), if the
//      menu_item_ids match.
//
func (toolItem *ToolItem) ProxyMenuItem(menuItemId string) Widgetter {
	var _arg0 *C.GtkToolItem // out
	var _arg1 *C.gchar       // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(menuItemId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_tool_item_get_proxy_menu_item(_arg0, _arg1)
	runtime.KeepAlive(toolItem)
	runtime.KeepAlive(menuItemId)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ReliefStyle returns the relief style of tool_item. See
// gtk_button_set_relief(). Custom subclasses of ToolItem should call this
// function in the handler of the ToolItem::toolbar_reconfigured signal to find
// out the relief style of buttons.
//
// The function returns the following values:
//
//    - reliefStyle indicating the relief style used for tool_item.
//
func (toolItem *ToolItem) ReliefStyle() ReliefStyle {
	var _arg0 *C.GtkToolItem   // out
	var _cret C.GtkReliefStyle // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_relief_style(_arg0)
	runtime.KeepAlive(toolItem)

	var _reliefStyle ReliefStyle // out

	_reliefStyle = ReliefStyle(_cret)

	return _reliefStyle
}

// ToolbarStyle returns the toolbar style used for tool_item. Custom subclasses
// of ToolItem should call this function in the handler of the
// GtkToolItem::toolbar_reconfigured signal to find out in what style the
// toolbar is displayed and change themselves accordingly
//
// Possibilities are:
//
// - GTK_TOOLBAR_BOTH, meaning the tool item should show both an icon and a
// label, stacked vertically
//
// - GTK_TOOLBAR_ICONS, meaning the toolbar shows only icons
//
// - GTK_TOOLBAR_TEXT, meaning the tool item should only show text
//
// - GTK_TOOLBAR_BOTH_HORIZ, meaning the tool item should show both an icon and
// a label, arranged horizontally.
//
// The function returns the following values:
//
//    - toolbarStyle indicating the toolbar style used for tool_item.
//
func (toolItem *ToolItem) ToolbarStyle() ToolbarStyle {
	var _arg0 *C.GtkToolItem    // out
	var _cret C.GtkToolbarStyle // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_toolbar_style(_arg0)
	runtime.KeepAlive(toolItem)

	var _toolbarStyle ToolbarStyle // out

	_toolbarStyle = ToolbarStyle(_cret)

	return _toolbarStyle
}

// UseDragWindow returns whether tool_item has a drag window. See
// gtk_tool_item_set_use_drag_window().
//
// The function returns the following values:
//
//    - ok: TRUE if tool_item uses a drag window.
//
func (toolItem *ToolItem) UseDragWindow() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_use_drag_window(_arg0)
	runtime.KeepAlive(toolItem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleHorizontal returns whether the tool_item is visible on toolbars that
// are docked horizontally.
//
// The function returns the following values:
//
//    - ok: TRUE if tool_item is visible on toolbars that are docked
//      horizontally.
//
func (toolItem *ToolItem) VisibleHorizontal() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_visible_horizontal(_arg0)
	runtime.KeepAlive(toolItem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleVertical returns whether tool_item is visible when the toolbar is
// docked vertically. See gtk_tool_item_set_visible_vertical().
//
// The function returns the following values:
//
//    - ok: whether tool_item is visible when the toolbar is docked vertically.
//
func (toolItem *ToolItem) VisibleVertical() bool {
	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_get_visible_vertical(_arg0)
	runtime.KeepAlive(toolItem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RetrieveProxyMenuItem returns the MenuItem that was last set by
// gtk_tool_item_set_proxy_menu_item(), ie. the MenuItem that is going to appear
// in the overflow menu.
//
// The function returns the following values:
//
//    - widget that is going to appear in the overflow menu for tool_item.
//
func (toolItem *ToolItem) RetrieveProxyMenuItem() Widgetter {
	var _arg0 *C.GtkToolItem // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C.gtk_tool_item_retrieve_proxy_menu_item(_arg0)
	runtime.KeepAlive(toolItem)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// SetExpand sets whether tool_item is allocated extra space when there is more
// room on the toolbar then needed for the items. The effect is that the item
// gets bigger when the toolbar gets bigger and smaller when the toolbar gets
// smaller.
//
// The function takes the following parameters:
//
//    - expand: whether tool_item is allocated extra space.
//
func (toolItem *ToolItem) SetExpand(expand bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_expand(_arg0, _arg1)
	runtime.KeepAlive(toolItem)
	runtime.KeepAlive(expand)
}

// SetHomogeneous sets whether tool_item is to be allocated the same size as
// other homogeneous items. The effect is that all homogeneous items will have
// the same width as the widest of the items.
//
// The function takes the following parameters:
//
//    - homogeneous: whether tool_item is the same size as other homogeneous
//      items.
//
func (toolItem *ToolItem) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(toolItem)
	runtime.KeepAlive(homogeneous)
}

// SetIsImportant sets whether tool_item should be considered important. The
// ToolButton class uses this property to determine whether to show or hide its
// label when the toolbar style is GTK_TOOLBAR_BOTH_HORIZ. The result is that
// only tool buttons with the “is_important” property set have labels, an effect
// known as “priority text”.
//
// The function takes the following parameters:
//
//    - isImportant: whether the tool item should be considered important.
//
func (toolItem *ToolItem) SetIsImportant(isImportant bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))
	if isImportant {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_is_important(_arg0, _arg1)
	runtime.KeepAlive(toolItem)
	runtime.KeepAlive(isImportant)
}

// SetProxyMenuItem sets the MenuItem used in the toolbar overflow menu. The
// menu_item_id is used to identify the caller of this function and should also
// be used with gtk_tool_item_get_proxy_menu_item().
//
// See also ToolItem::create-menu-proxy.
//
// The function takes the following parameters:
//
//    - menuItemId: string used to identify menu_item.
//    - menuItem (optional) to use in the overflow menu, or NULL.
//
func (toolItem *ToolItem) SetProxyMenuItem(menuItemId string, menuItem Widgetter) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 *C.gchar       // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(menuItemId)))
	defer C.free(unsafe.Pointer(_arg1))
	if menuItem != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuItem).Native()))
	}

	C.gtk_tool_item_set_proxy_menu_item(_arg0, _arg1, _arg2)
	runtime.KeepAlive(toolItem)
	runtime.KeepAlive(menuItemId)
	runtime.KeepAlive(menuItem)
}

// SetUseDragWindow sets whether tool_item has a drag window. When TRUE the
// toolitem can be used as a drag source through gtk_drag_source_set(). When
// tool_item has a drag window it will intercept all events, even those that
// would otherwise be sent to a child of tool_item.
//
// The function takes the following parameters:
//
//    - useDragWindow: whether tool_item has a drag window.
//
func (toolItem *ToolItem) SetUseDragWindow(useDragWindow bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))
	if useDragWindow {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_use_drag_window(_arg0, _arg1)
	runtime.KeepAlive(toolItem)
	runtime.KeepAlive(useDragWindow)
}

// SetVisibleHorizontal sets whether tool_item is visible when the toolbar is
// docked horizontally.
//
// The function takes the following parameters:
//
//    - visibleHorizontal: whether tool_item is visible when in horizontal mode.
//
func (toolItem *ToolItem) SetVisibleHorizontal(visibleHorizontal bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))
	if visibleHorizontal {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_visible_horizontal(_arg0, _arg1)
	runtime.KeepAlive(toolItem)
	runtime.KeepAlive(visibleHorizontal)
}

// SetVisibleVertical sets whether tool_item is visible when the toolbar is
// docked vertically. Some tool items, such as text entries, are too wide to be
// useful on a vertically docked toolbar. If visible_vertical is FALSE tool_item
// will not appear on toolbars that are docked vertically.
//
// The function takes the following parameters:
//
//    - visibleVertical: whether tool_item is visible when the toolbar is in
//      vertical mode.
//
func (toolItem *ToolItem) SetVisibleVertical(visibleVertical bool) {
	var _arg0 *C.GtkToolItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))
	if visibleVertical {
		_arg1 = C.TRUE
	}

	C.gtk_tool_item_set_visible_vertical(_arg0, _arg1)
	runtime.KeepAlive(toolItem)
	runtime.KeepAlive(visibleVertical)
}

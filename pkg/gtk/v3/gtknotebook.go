// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern GtkNotebook* _gotk4_gtk3_Notebook_ConnectCreateWindow(gpointer, GtkWidget*, gint, gint, guintptr);
// extern gboolean _gotk4_gtk3_NotebookClass_change_current_page(GtkNotebook*, gint);
// extern gboolean _gotk4_gtk3_NotebookClass_focus_tab(GtkNotebook*, GtkNotebookTab);
// extern gboolean _gotk4_gtk3_NotebookClass_reorder_tab(GtkNotebook*, GtkDirectionType, gboolean);
// extern gboolean _gotk4_gtk3_NotebookClass_select_page(GtkNotebook*, gboolean);
// extern gboolean _gotk4_gtk3_Notebook_ConnectChangeCurrentPage(gpointer, gint, guintptr);
// extern gboolean _gotk4_gtk3_Notebook_ConnectFocusTab(gpointer, GtkNotebookTab, guintptr);
// extern gboolean _gotk4_gtk3_Notebook_ConnectReorderTab(gpointer, GtkDirectionType, gboolean, guintptr);
// extern gboolean _gotk4_gtk3_Notebook_ConnectSelectPage(gpointer, gboolean, guintptr);
// extern gint _gotk4_gtk3_NotebookClass_insert_page(GtkNotebook*, GtkWidget*, GtkWidget*, GtkWidget*, gint);
// extern void _gotk4_gtk3_NotebookClass_move_focus_out(GtkNotebook*, GtkDirectionType);
// extern void _gotk4_gtk3_NotebookClass_page_added(GtkNotebook*, GtkWidget*, guint);
// extern void _gotk4_gtk3_NotebookClass_page_removed(GtkNotebook*, GtkWidget*, guint);
// extern void _gotk4_gtk3_NotebookClass_page_reordered(GtkNotebook*, GtkWidget*, guint);
// extern void _gotk4_gtk3_NotebookClass_switch_page(GtkNotebook*, GtkWidget*, guint);
// extern void _gotk4_gtk3_Notebook_ConnectMoveFocusOut(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk3_Notebook_ConnectPageAdded(gpointer, GtkWidget*, guint, guintptr);
// extern void _gotk4_gtk3_Notebook_ConnectPageRemoved(gpointer, GtkWidget*, guint, guintptr);
// extern void _gotk4_gtk3_Notebook_ConnectPageReordered(gpointer, GtkWidget*, guint, guintptr);
// extern void _gotk4_gtk3_Notebook_ConnectSwitchPage(gpointer, GtkWidget*, guint, guintptr);
import "C"

// GType values.
var (
	GTypeNotebook = coreglib.Type(C.gtk_notebook_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeNotebook, F: marshalNotebook},
	})
}

// NotebookOverrider contains methods that are overridable.
type NotebookOverrider interface {
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	ChangeCurrentPage(offset int) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	FocusTab(typ NotebookTab) bool
	// The function takes the following parameters:
	//
	//    - child
	//    - tabLabel
	//    - menuLabel
	//    - position
	//
	// The function returns the following values:
	//
	InsertPage(child, tabLabel, menuLabel Widgetter, position int) int
	// The function takes the following parameters:
	//
	MoveFocusOut(direction DirectionType)
	// The function takes the following parameters:
	//
	//    - child
	//    - pageNum
	//
	PageAdded(child Widgetter, pageNum uint)
	// The function takes the following parameters:
	//
	//    - child
	//    - pageNum
	//
	PageRemoved(child Widgetter, pageNum uint)
	// The function takes the following parameters:
	//
	//    - child
	//    - pageNum
	//
	PageReordered(child Widgetter, pageNum uint)
	// The function takes the following parameters:
	//
	//    - direction
	//    - moveToLast
	//
	// The function returns the following values:
	//
	ReorderTab(direction DirectionType, moveToLast bool) bool
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	SelectPage(moveFocus bool) bool
	// The function takes the following parameters:
	//
	//    - page
	//    - pageNum
	//
	SwitchPage(page Widgetter, pageNum uint)
}

// Notebook widget is a Container whose children are pages that can be switched
// between using tab labels along one edge.
//
// There are many configuration options for GtkNotebook. Among other things, you
// can choose on which edge the tabs appear (see gtk_notebook_set_tab_pos()),
// whether, if there are too many tabs to fit the notebook should be made bigger
// or scrolling arrows added (see gtk_notebook_set_scrollable()), and whether
// there will be a popup menu allowing the users to switch pages. (see
// gtk_notebook_popup_enable(), gtk_notebook_popup_disable())
//
//
// GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the Buildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
// An example of a UI definition fragment with GtkNotebook:
//
//    <object class="GtkNotebook">
//      <child>
//        <object class="GtkLabel" id="notebook-content">
//          <property name="label">Content</property>
//        </object>
//      </child>
//      <child type="tab">
//        <object class="GtkLabel" id="notebook-tab">
//          <property name="label">Tab</property>
//        </object>
//      </child>
//    </object>
//
// CSS nodes
//
//    notebook
//    ├── header.top
//    │   ├── [<action widget>]
//    │   ├── tabs
//    │   │   ├── [arrow]
//    │   │   ├── tab
//    │   │   │   ╰── <tab label>
//    ┊   ┊   ┊
//    │   │   ├── tab[.reorderable-page]
//    │   │   │   ╰── <tab label>
//    │   │   ╰── [arrow]
//    │   ╰── [<action widget>]
//    │
//    ╰── stack
//        ├── <child>
//        ┊
//        ╰── <child>
//
// GtkNotebook has a main CSS node with name notebook, a subnode with name
// header and below that a subnode with name tabs which contains one subnode per
// tab with name tab.
//
// If action widgets are present, their CSS nodes are placed next to the tabs
// node. If the notebook is scrollable, CSS nodes with name arrow are placed as
// first and last child of the tabs node.
//
// The main node gets the .frame style class when the notebook has a border (see
// gtk_notebook_set_show_border()).
//
// The header node gets one of the style class .top, .bottom, .left or .right,
// depending on where the tabs are placed. For reorderable pages, the tab node
// gets the .reorderable-page class.
//
// A tab node gets the .dnd style class while it is moved with drag-and-drop.
//
// The nodes are always arranged from left-to-right, regarldess of text
// direction.
type Notebook struct {
	_ [0]func() // equal guard
	Container
}

var (
	_ Containerer = (*Notebook)(nil)
)

func init() {
	coreglib.RegisterClassInfo(coreglib.ClassTypeInfo{
		GType:        GTypeNotebook,
		GoType:       reflect.TypeOf((*Notebook)(nil)),
		InitClass:    initClassNotebook,
		ClassSize:    uint16(unsafe.Sizeof(C.GtkNotebook{})),
		InstanceSize: uint16(unsafe.Sizeof(C.GtkNotebookClass{})),
	})
}

func initClassNotebook(gclass unsafe.Pointer, goval any) {

	pclass := (*C.GtkNotebookClass)(unsafe.Pointer(gclass))

	if _, ok := goval.(interface{ ChangeCurrentPage(offset int) bool }); ok {
		pclass.change_current_page = (*[0]byte)(C._gotk4_gtk3_NotebookClass_change_current_page)
	}

	if _, ok := goval.(interface{ FocusTab(typ NotebookTab) bool }); ok {
		pclass.focus_tab = (*[0]byte)(C._gotk4_gtk3_NotebookClass_focus_tab)
	}

	if _, ok := goval.(interface {
		InsertPage(child, tabLabel, menuLabel Widgetter, position int) int
	}); ok {
		pclass.insert_page = (*[0]byte)(C._gotk4_gtk3_NotebookClass_insert_page)
	}

	if _, ok := goval.(interface{ MoveFocusOut(direction DirectionType) }); ok {
		pclass.move_focus_out = (*[0]byte)(C._gotk4_gtk3_NotebookClass_move_focus_out)
	}

	if _, ok := goval.(interface {
		PageAdded(child Widgetter, pageNum uint)
	}); ok {
		pclass.page_added = (*[0]byte)(C._gotk4_gtk3_NotebookClass_page_added)
	}

	if _, ok := goval.(interface {
		PageRemoved(child Widgetter, pageNum uint)
	}); ok {
		pclass.page_removed = (*[0]byte)(C._gotk4_gtk3_NotebookClass_page_removed)
	}

	if _, ok := goval.(interface {
		PageReordered(child Widgetter, pageNum uint)
	}); ok {
		pclass.page_reordered = (*[0]byte)(C._gotk4_gtk3_NotebookClass_page_reordered)
	}

	if _, ok := goval.(interface {
		ReorderTab(direction DirectionType, moveToLast bool) bool
	}); ok {
		pclass.reorder_tab = (*[0]byte)(C._gotk4_gtk3_NotebookClass_reorder_tab)
	}

	if _, ok := goval.(interface{ SelectPage(moveFocus bool) bool }); ok {
		pclass.select_page = (*[0]byte)(C._gotk4_gtk3_NotebookClass_select_page)
	}

	if _, ok := goval.(interface {
		SwitchPage(page Widgetter, pageNum uint)
	}); ok {
		pclass.switch_page = (*[0]byte)(C._gotk4_gtk3_NotebookClass_switch_page)
	}
}

//export _gotk4_gtk3_NotebookClass_change_current_page
func _gotk4_gtk3_NotebookClass_change_current_page(arg0 *C.GtkNotebook, arg1 C.gint) (cret C.gboolean) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ ChangeCurrentPage(offset int) bool })

	var _offset int // out

	_offset = int(arg1)

	ok := iface.ChangeCurrentPage(_offset)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_focus_tab
func _gotk4_gtk3_NotebookClass_focus_tab(arg0 *C.GtkNotebook, arg1 C.GtkNotebookTab) (cret C.gboolean) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ FocusTab(typ NotebookTab) bool })

	var _typ NotebookTab // out

	_typ = NotebookTab(arg1)

	ok := iface.FocusTab(_typ)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_insert_page
func _gotk4_gtk3_NotebookClass_insert_page(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 *C.GtkWidget, arg3 *C.GtkWidget, arg4 C.gint) (cret C.gint) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		InsertPage(child, tabLabel, menuLabel Widgetter, position int) int
	})

	var _child Widgetter     // out
	var _tabLabel Widgetter  // out
	var _menuLabel Widgetter // out
	var _position int        // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	{
		objptr := unsafe.Pointer(arg2)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_tabLabel = rv
	}
	{
		objptr := unsafe.Pointer(arg3)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_menuLabel = rv
	}
	_position = int(arg4)

	gint := iface.InsertPage(_child, _tabLabel, _menuLabel, _position)

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_NotebookClass_move_focus_out
func _gotk4_gtk3_NotebookClass_move_focus_out(arg0 *C.GtkNotebook, arg1 C.GtkDirectionType) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ MoveFocusOut(direction DirectionType) })

	var _direction DirectionType // out

	_direction = DirectionType(arg1)

	iface.MoveFocusOut(_direction)
}

//export _gotk4_gtk3_NotebookClass_page_added
func _gotk4_gtk3_NotebookClass_page_added(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PageAdded(child Widgetter, pageNum uint)
	})

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	iface.PageAdded(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_page_removed
func _gotk4_gtk3_NotebookClass_page_removed(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PageRemoved(child Widgetter, pageNum uint)
	})

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	iface.PageRemoved(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_page_reordered
func _gotk4_gtk3_NotebookClass_page_reordered(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PageReordered(child Widgetter, pageNum uint)
	})

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	iface.PageReordered(_child, _pageNum)
}

//export _gotk4_gtk3_NotebookClass_reorder_tab
func _gotk4_gtk3_NotebookClass_reorder_tab(arg0 *C.GtkNotebook, arg1 C.GtkDirectionType, arg2 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ReorderTab(direction DirectionType, moveToLast bool) bool
	})

	var _direction DirectionType // out
	var _moveToLast bool         // out

	_direction = DirectionType(arg1)
	if arg2 != 0 {
		_moveToLast = true
	}

	ok := iface.ReorderTab(_direction, _moveToLast)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_select_page
func _gotk4_gtk3_NotebookClass_select_page(arg0 *C.GtkNotebook, arg1 C.gboolean) (cret C.gboolean) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ SelectPage(moveFocus bool) bool })

	var _moveFocus bool // out

	if arg1 != 0 {
		_moveFocus = true
	}

	ok := iface.SelectPage(_moveFocus)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_NotebookClass_switch_page
func _gotk4_gtk3_NotebookClass_switch_page(arg0 *C.GtkNotebook, arg1 *C.GtkWidget, arg2 C.guint) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		SwitchPage(page Widgetter, pageNum uint)
	})

	var _page Widgetter // out
	var _pageNum uint   // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}
	_pageNum = uint(arg2)

	iface.SwitchPage(_page, _pageNum)
}

func wrapNotebook(obj *coreglib.Object) *Notebook {
	return &Notebook{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
	}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	return wrapNotebook(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_Notebook_ConnectChangeCurrentPage
func _gotk4_gtk3_Notebook_ConnectChangeCurrentPage(arg0 C.gpointer, arg1 C.gint, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object int) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object int) (ok bool))
	}

	var _object int // out

	_object = int(arg1)

	ok := f(_object)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (notebook *Notebook) ConnectChangeCurrentPage(f func(object int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "change-current-page", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectChangeCurrentPage), f)
}

//export _gotk4_gtk3_Notebook_ConnectCreateWindow
func _gotk4_gtk3_Notebook_ConnectCreateWindow(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.gint, arg3 C.gint, arg4 C.guintptr) (cret *C.GtkNotebook) {
	var f func(page Widgetter, x, y int) (notebook *Notebook)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(page Widgetter, x, y int) (notebook *Notebook))
	}

	var _page Widgetter // out
	var _x int          // out
	var _y int          // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}
	_x = int(arg2)
	_y = int(arg3)

	notebook := f(_page, _x, _y)

	cret = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	return cret
}

// ConnectCreateWindow signal is emitted when a detachable tab is dropped on the
// root window.
//
// A handler for this signal can create a window containing a notebook where the
// tab will be attached. It is also responsible for moving/resizing the window
// and adding the necessary properties to the notebook (e.g. the
// Notebook:group-name ).
func (notebook *Notebook) ConnectCreateWindow(f func(page Widgetter, x, y int) (notebook *Notebook)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "create-window", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectCreateWindow), f)
}

//export _gotk4_gtk3_Notebook_ConnectFocusTab
func _gotk4_gtk3_Notebook_ConnectFocusTab(arg0 C.gpointer, arg1 C.GtkNotebookTab, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object NotebookTab) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object NotebookTab) (ok bool))
	}

	var _object NotebookTab // out

	_object = NotebookTab(arg1)

	ok := f(_object)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (notebook *Notebook) ConnectFocusTab(f func(object NotebookTab) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "focus-tab", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectFocusTab), f)
}

//export _gotk4_gtk3_Notebook_ConnectMoveFocusOut
func _gotk4_gtk3_Notebook_ConnectMoveFocusOut(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.guintptr) {
	var f func(object DirectionType)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType))
	}

	var _object DirectionType // out

	_object = DirectionType(arg1)

	f(_object)
}

func (notebook *Notebook) ConnectMoveFocusOut(f func(object DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "move-focus-out", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectMoveFocusOut), f)
}

//export _gotk4_gtk3_Notebook_ConnectPageAdded
func _gotk4_gtk3_Notebook_ConnectPageAdded(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guint, arg3 C.guintptr) {
	var f func(child Widgetter, pageNum uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(child Widgetter, pageNum uint))
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	f(_child, _pageNum)
}

// ConnectPageAdded signal is emitted in the notebook right after a page is
// added to the notebook.
func (notebook *Notebook) ConnectPageAdded(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "page-added", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectPageAdded), f)
}

//export _gotk4_gtk3_Notebook_ConnectPageRemoved
func _gotk4_gtk3_Notebook_ConnectPageRemoved(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guint, arg3 C.guintptr) {
	var f func(child Widgetter, pageNum uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(child Widgetter, pageNum uint))
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	f(_child, _pageNum)
}

// ConnectPageRemoved signal is emitted in the notebook right after a page is
// removed from the notebook.
func (notebook *Notebook) ConnectPageRemoved(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "page-removed", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectPageRemoved), f)
}

//export _gotk4_gtk3_Notebook_ConnectPageReordered
func _gotk4_gtk3_Notebook_ConnectPageReordered(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guint, arg3 C.guintptr) {
	var f func(child Widgetter, pageNum uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(child Widgetter, pageNum uint))
	}

	var _child Widgetter // out
	var _pageNum uint    // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}
	_pageNum = uint(arg2)

	f(_child, _pageNum)
}

// ConnectPageReordered signal is emitted in the notebook right after a page has
// been reordered.
func (notebook *Notebook) ConnectPageReordered(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "page-reordered", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectPageReordered), f)
}

//export _gotk4_gtk3_Notebook_ConnectReorderTab
func _gotk4_gtk3_Notebook_ConnectReorderTab(arg0 C.gpointer, arg1 C.GtkDirectionType, arg2 C.gboolean, arg3 C.guintptr) (cret C.gboolean) {
	var f func(object DirectionType, p0 bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object DirectionType, p0 bool) (ok bool))
	}

	var _object DirectionType // out
	var _p0 bool              // out

	_object = DirectionType(arg1)
	if arg2 != 0 {
		_p0 = true
	}

	ok := f(_object, _p0)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (notebook *Notebook) ConnectReorderTab(f func(object DirectionType, p0 bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "reorder-tab", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectReorderTab), f)
}

//export _gotk4_gtk3_Notebook_ConnectSelectPage
func _gotk4_gtk3_Notebook_ConnectSelectPage(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) (cret C.gboolean) {
	var f func(object bool) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object bool) (ok bool))
	}

	var _object bool // out

	if arg1 != 0 {
		_object = true
	}

	ok := f(_object)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func (notebook *Notebook) ConnectSelectPage(f func(object bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "select-page", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectSelectPage), f)
}

//export _gotk4_gtk3_Notebook_ConnectSwitchPage
func _gotk4_gtk3_Notebook_ConnectSwitchPage(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guint, arg3 C.guintptr) {
	var f func(page Widgetter, pageNum uint)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(page Widgetter, pageNum uint))
	}

	var _page Widgetter // out
	var _pageNum uint   // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_page = rv
	}
	_pageNum = uint(arg2)

	f(_page, _pageNum)
}

// ConnectSwitchPage is emitted when the user or a function changes the current
// page.
func (notebook *Notebook) ConnectSwitchPage(f func(page Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "switch-page", false, unsafe.Pointer(C._gotk4_gtk3_Notebook_ConnectSwitchPage), f)
}

// NewNotebook creates a new Notebook widget with no pages.
//
// The function returns the following values:
//
//    - notebook: newly created Notebook.
//
func NewNotebook() *Notebook {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_notebook_new()

	var _notebook *Notebook // out

	_notebook = wrapNotebook(coreglib.Take(unsafe.Pointer(_cret)))

	return _notebook
}

// AppendPage appends a page to notebook.
//
// The function takes the following parameters:
//
//    - child to use as the contents of the page.
//    - tabLabel (optional) to be used as the label for the page, or NULL to use
//      the default label, “page N”.
//
// The function returns the following values:
//
//    - gint: index (starting from 0) of the appended page in the notebook, or -1
//      if function fails.
//
func (notebook *Notebook) AppendPage(child, tabLabel Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}

	_cret = C.gtk_notebook_append_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AppendPageMenu appends a page to notebook, specifying the widget to use as
// the label in the popup menu.
//
// The function takes the following parameters:
//
//    - child to use as the contents of the page.
//    - tabLabel (optional) to be used as the label for the page, or NULL to use
//      the default label, “page N”.
//    - menuLabel (optional): widget to use as a label for the page-switch menu,
//      if that is enabled. If NULL, and tab_label is a Label or NULL, then the
//      menu label will be a newly created label with the same text as tab_label;
//      if tab_label is not a Label, menu_label must be specified if the
//      page-switch menu is to be used.
//
// The function returns the following values:
//
//    - gint: index (starting from 0) of the appended page in the notebook, or -1
//      if function fails.
//
func (notebook *Notebook) AppendPageMenu(child, tabLabel, menuLabel Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}
	if menuLabel != nil {
		_arg3 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuLabel).Native()))
	}

	_cret = C.gtk_notebook_append_page_menu(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
	runtime.KeepAlive(menuLabel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DetachTab removes the child from the notebook.
//
// This function is very similar to gtk_container_remove(), but additionally
// informs the notebook that the removal is happening as part of a tab DND
// operation, which should not be cancelled.
//
// The function takes the following parameters:
//
//    - child: child.
//
func (notebook *Notebook) DetachTab(child Widgetter) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_notebook_detach_tab(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
}

// ActionWidget gets one of the action widgets. See
// gtk_notebook_set_action_widget().
//
// The function takes the following parameters:
//
//    - packType: pack type of the action widget to receive.
//
// The function returns the following values:
//
//    - widget (optional): action widget with the given pack_type or NULL when
//      this action widget has not been set.
//
func (notebook *Notebook) ActionWidget(packType PackType) Widgetter {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.GtkPackType  // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.GtkPackType(packType)

	_cret = C.gtk_notebook_get_action_widget(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(packType)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// CurrentPage returns the page number of the current page.
//
// The function returns the following values:
//
//    - gint: index (starting from 0) of the current page in the notebook. If the
//      notebook has no pages, then -1 will be returned.
//
func (notebook *Notebook) CurrentPage() int {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_current_page(_arg0)
	runtime.KeepAlive(notebook)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// GroupName gets the current group name for notebook.
//
// The function returns the following values:
//
//    - utf8 (optional): group name, or NULL if none is set.
//
func (notebook *Notebook) GroupName() string {
	var _arg0 *C.GtkNotebook // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_group_name(_arg0)
	runtime.KeepAlive(notebook)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MenuLabel retrieves the menu label widget of the page containing child.
//
// The function takes the following parameters:
//
//    - child: widget contained in a page of notebook.
//
// The function returns the following values:
//
//    - widget (optional): menu label, or NULL if the notebook page does not have
//      a menu label other than the default (the tab label).
//
func (notebook *Notebook) MenuLabel(child Widgetter) Widgetter {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_menu_label(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// MenuLabelText retrieves the text of the menu label for the page containing
// child.
//
// The function takes the following parameters:
//
//    - child widget of a page of the notebook.
//
// The function returns the following values:
//
//    - utf8 (optional): text of the tab label, or NULL if the widget does not
//      have a menu label other than the default menu label, or the menu label
//      widget is not a Label. The string is owned by the widget and must not be
//      freed.
//
func (notebook *Notebook) MenuLabelText(child Widgetter) string {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_menu_label_text(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// NPages gets the number of pages in a notebook.
//
// The function returns the following values:
//
//    - gint: number of pages in the notebook.
//
func (notebook *Notebook) NPages() int {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_n_pages(_arg0)
	runtime.KeepAlive(notebook)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NthPage returns the child widget contained in page number page_num.
//
// The function takes the following parameters:
//
//    - pageNum: index of a page in the notebook, or -1 to get the last page.
//
// The function returns the following values:
//
//    - widget (optional): child widget, or NULL if page_num is out of bounds.
//
func (notebook *Notebook) NthPage(pageNum int) Widgetter {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gint         // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.gint(pageNum)

	_cret = C.gtk_notebook_get_nth_page(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(pageNum)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Scrollable returns whether the tab label area has arrows for scrolling. See
// gtk_notebook_set_scrollable().
//
// The function returns the following values:
//
//    - ok: TRUE if arrows for scrolling are present.
//
func (notebook *Notebook) Scrollable() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_scrollable(_arg0)
	runtime.KeepAlive(notebook)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowBorder returns whether a bevel will be drawn around the notebook pages.
// See gtk_notebook_set_show_border().
//
// The function returns the following values:
//
//    - ok: TRUE if the bevel is drawn.
//
func (notebook *Notebook) ShowBorder() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_show_border(_arg0)
	runtime.KeepAlive(notebook)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowTabs returns whether the tabs of the notebook are shown. See
// gtk_notebook_set_show_tabs().
//
// The function returns the following values:
//
//    - ok: TRUE if the tabs are shown.
//
func (notebook *Notebook) ShowTabs() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_show_tabs(_arg0)
	runtime.KeepAlive(notebook)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabDetachable returns whether the tab contents can be detached from notebook.
//
// The function takes the following parameters:
//
//    - child Widget.
//
// The function returns the following values:
//
//    - ok: TRUE if the tab is detachable.
//
func (notebook *Notebook) TabDetachable(child Widgetter) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_detachable(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabHborder returns the horizontal width of a tab border.
//
// Deprecated: this function returns zero.
//
// The function returns the following values:
//
//    - guint16: horizontal width of a tab border.
//
func (notebook *Notebook) TabHborder() uint16 {
	var _arg0 *C.GtkNotebook // out
	var _cret C.guint16      // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_tab_hborder(_arg0)
	runtime.KeepAlive(notebook)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// TabLabel returns the tab label widget for the page child. NULL is returned if
// child is not in notebook or if no tab label has specifically been set for
// child.
//
// The function takes the following parameters:
//
//    - child: page.
//
// The function returns the following values:
//
//    - widget (optional): tab label.
//
func (notebook *Notebook) TabLabel(child Widgetter) Widgetter {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_label(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// TabLabelText retrieves the text of the tab label for the page containing
// child.
//
// The function takes the following parameters:
//
//    - child: widget contained in a page of notebook.
//
// The function returns the following values:
//
//    - utf8 (optional): text of the tab label, or NULL if the tab label widget
//      is not a Label. The string is owned by the widget and must not be freed.
//
func (notebook *Notebook) TabLabelText(child Widgetter) string {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_label_text(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TabPos gets the edge at which the tabs for switching pages in the notebook
// are drawn.
//
// The function returns the following values:
//
//    - positionType: edge at which the tabs are drawn.
//
func (notebook *Notebook) TabPos() PositionType {
	var _arg0 *C.GtkNotebook    // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_tab_pos(_arg0)
	runtime.KeepAlive(notebook)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
//
// The function takes the following parameters:
//
//    - child Widget.
//
// The function returns the following values:
//
//    - ok: TRUE if the tab is reorderable.
//
func (notebook *Notebook) TabReorderable(child Widgetter) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_reorderable(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabVborder returns the vertical width of a tab border.
//
// Deprecated: this function returns zero.
//
// The function returns the following values:
//
//    - guint16: vertical width of a tab border.
//
func (notebook *Notebook) TabVborder() uint16 {
	var _arg0 *C.GtkNotebook // out
	var _cret C.guint16      // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_tab_vborder(_arg0)
	runtime.KeepAlive(notebook)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// InsertPage: insert a page into notebook at the given position.
//
// The function takes the following parameters:
//
//    - child to use as the contents of the page.
//    - tabLabel (optional) to be used as the label for the page, or NULL to use
//      the default label, “page N”.
//    - position: index (starting at 0) at which to insert the page, or -1 to
//      append the page after all other pages.
//
// The function returns the following values:
//
//    - gint: index (starting from 0) of the inserted page in the notebook, or -1
//      if function fails.
//
func (notebook *Notebook) InsertPage(child, tabLabel Widgetter, position int) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 C.gint         // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}
	_arg3 = C.gint(position)

	_cret = C.gtk_notebook_insert_page(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
	runtime.KeepAlive(position)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InsertPageMenu: insert a page into notebook at the given position, specifying
// the widget to use as the label in the popup menu.
//
// The function takes the following parameters:
//
//    - child to use as the contents of the page.
//    - tabLabel (optional) to be used as the label for the page, or NULL to use
//      the default label, “page N”.
//    - menuLabel (optional): widget to use as a label for the page-switch menu,
//      if that is enabled. If NULL, and tab_label is a Label or NULL, then the
//      menu label will be a newly created label with the same text as tab_label;
//      if tab_label is not a Label, menu_label must be specified if the
//      page-switch menu is to be used.
//    - position: index (starting at 0) at which to insert the page, or -1 to
//      append the page after all other pages.
//
// The function returns the following values:
//
//    - gint: index (starting from 0) of the inserted page in the notebook.
//
func (notebook *Notebook) InsertPageMenu(child, tabLabel, menuLabel Widgetter, position int) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _arg4 C.gint         // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}
	if menuLabel != nil {
		_arg3 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuLabel).Native()))
	}
	_arg4 = C.gint(position)

	_cret = C.gtk_notebook_insert_page_menu(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
	runtime.KeepAlive(menuLabel)
	runtime.KeepAlive(position)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NextPage switches to the next page. Nothing happens if the current page is
// the last page.
func (notebook *Notebook) NextPage() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	C.gtk_notebook_next_page(_arg0)
	runtime.KeepAlive(notebook)
}

// PageNum finds the index of the page which contains the given child widget.
//
// The function takes the following parameters:
//
//    - child: Widget.
//
// The function returns the following values:
//
//    - gint: index of the page containing child, or -1 if child is not in the
//      notebook.
//
func (notebook *Notebook) PageNum(child Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_page_num(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PopupDisable disables the popup menu.
func (notebook *Notebook) PopupDisable() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	C.gtk_notebook_popup_disable(_arg0)
	runtime.KeepAlive(notebook)
}

// PopupEnable enables the popup menu: if the user clicks with the right mouse
// button on the tab labels, a menu with all the pages will be popped up.
func (notebook *Notebook) PopupEnable() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	C.gtk_notebook_popup_enable(_arg0)
	runtime.KeepAlive(notebook)
}

// PrependPage prepends a page to notebook.
//
// The function takes the following parameters:
//
//    - child to use as the contents of the page.
//    - tabLabel (optional) to be used as the label for the page, or NULL to use
//      the default label, “page N”.
//
// The function returns the following values:
//
//    - gint: index (starting from 0) of the prepended page in the notebook, or
//      -1 if function fails.
//
func (notebook *Notebook) PrependPage(child, tabLabel Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}

	_cret = C.gtk_notebook_prepend_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PrependPageMenu prepends a page to notebook, specifying the widget to use as
// the label in the popup menu.
//
// The function takes the following parameters:
//
//    - child to use as the contents of the page.
//    - tabLabel (optional) to be used as the label for the page, or NULL to use
//      the default label, “page N”.
//    - menuLabel (optional): widget to use as a label for the page-switch menu,
//      if that is enabled. If NULL, and tab_label is a Label or NULL, then the
//      menu label will be a newly created label with the same text as tab_label;
//      if tab_label is not a Label, menu_label must be specified if the
//      page-switch menu is to be used.
//
// The function returns the following values:
//
//    - gint: index (starting from 0) of the prepended page in the notebook, or
//      -1 if function fails.
//
func (notebook *Notebook) PrependPageMenu(child, tabLabel, menuLabel Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}
	if menuLabel != nil {
		_arg3 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuLabel).Native()))
	}

	_cret = C.gtk_notebook_prepend_page_menu(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
	runtime.KeepAlive(menuLabel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PrevPage switches to the previous page. Nothing happens if the current page
// is the first page.
func (notebook *Notebook) PrevPage() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	C.gtk_notebook_prev_page(_arg0)
	runtime.KeepAlive(notebook)
}

// RemovePage removes a page from the notebook given its index in the notebook.
//
// The function takes the following parameters:
//
//    - pageNum: index of a notebook page, starting from 0. If -1, the last page
//      will be removed.
//
func (notebook *Notebook) RemovePage(pageNum int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.gint(pageNum)

	C.gtk_notebook_remove_page(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(pageNum)
}

// ReorderChild reorders the page containing child, so that it appears in
// position position. If position is greater than or equal to the number of
// children in the list or negative, child will be moved to the end of the list.
//
// The function takes the following parameters:
//
//    - child to move.
//    - position: new position, or -1 to move to the end.
//
func (notebook *Notebook) ReorderChild(child Widgetter, position int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gint         // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.gint(position)

	C.gtk_notebook_reorder_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)
}

// SetActionWidget sets widget as one of the action widgets. Depending on the
// pack type the widget will be placed before or after the tabs. You can use a
// Box if you need to pack more than one widget on the same side.
//
// Note that action widgets are “internal” children of the notebook and thus not
// included in the list returned from gtk_container_foreach().
//
// The function takes the following parameters:
//
//    - widget: Widget.
//    - packType: pack type of the action widget.
//
func (notebook *Notebook) SetActionWidget(widget Widgetter, packType PackType) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.GtkPackType  // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.GtkPackType(packType)

	C.gtk_notebook_set_action_widget(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(packType)
}

// SetCurrentPage switches to the page number page_num.
//
// Note that due to historical reasons, GtkNotebook refuses to switch to a page
// unless the child widget is visible. Therefore, it is recommended to show
// child widgets before adding them to a notebook.
//
// The function takes the following parameters:
//
//    - pageNum: index of the page to switch to, starting from 0. If negative,
//      the last page will be used. If greater than the number of pages in the
//      notebook, nothing will be done.
//
func (notebook *Notebook) SetCurrentPage(pageNum int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.gint(pageNum)

	C.gtk_notebook_set_current_page(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(pageNum)
}

// SetGroupName sets a group name for notebook.
//
// Notebooks with the same name will be able to exchange tabs via drag and drop.
// A notebook with a NULL group name will not be able to exchange tabs with any
// other notebook.
//
// The function takes the following parameters:
//
//    - groupName (optional): name of the notebook group, or NULL to unset it.
//
func (notebook *Notebook) SetGroupName(groupName string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.gchar       // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	if groupName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_notebook_set_group_name(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(groupName)
}

// SetMenuLabel changes the menu label for the page containing child.
//
// The function takes the following parameters:
//
//    - child widget.
//    - menuLabel (optional): menu label, or NULL for default.
//
func (notebook *Notebook) SetMenuLabel(child, menuLabel Widgetter) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if menuLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuLabel).Native()))
	}

	C.gtk_notebook_set_menu_label(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(menuLabel)
}

// SetMenuLabelText creates a new label and sets it as the menu label of child.
//
// The function takes the following parameters:
//
//    - child widget.
//    - menuText: label text.
//
func (notebook *Notebook) SetMenuLabelText(child Widgetter, menuText string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.gchar       // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(menuText)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_menu_label_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(menuText)
}

// SetScrollable sets whether the tab label area will have arrows for scrolling
// if there are too many tabs to fit in the area.
//
// The function takes the following parameters:
//
//    - scrollable: TRUE if scroll arrows should be added.
//
func (notebook *Notebook) SetScrollable(scrollable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	if scrollable {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_scrollable(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(scrollable)
}

// SetShowBorder sets whether a bevel will be drawn around the notebook pages.
// This only has a visual effect when the tabs are not shown. See
// gtk_notebook_set_show_tabs().
//
// The function takes the following parameters:
//
//    - showBorder: TRUE if a bevel should be drawn around the notebook.
//
func (notebook *Notebook) SetShowBorder(showBorder bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	if showBorder {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_show_border(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(showBorder)
}

// SetShowTabs sets whether to show the tabs for the notebook or not.
//
// The function takes the following parameters:
//
//    - showTabs: TRUE if the tabs should be shown.
//
func (notebook *Notebook) SetShowTabs(showTabs bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	if showTabs {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_show_tabs(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(showTabs)
}

// SetTabDetachable sets whether the tab can be detached from notebook to
// another notebook or widget.
//
// Note that 2 notebooks must share a common group identificator (see
// gtk_notebook_set_group_name()) to allow automatic tabs interchange between
// them.
//
// If you want a widget to interact with a notebook through DnD (i.e.: accept
// dragged tabs from it) it must be set as a drop destination and accept the
// target “GTK_NOTEBOOK_TAB”. The notebook will fill the selection with a
// GtkWidget** pointing to the child widget that corresponds to the dropped tab.
//
// Note that you should use gtk_notebook_detach_tab() instead of
// gtk_container_remove() if you want to remove the tab from the source notebook
// as part of accepting a drop. Otherwise, the source notebook will think that
// the dragged tab was removed from underneath the ongoing drag operation, and
// will initiate a drag cancel animation.
//
//     static void
//     on_drag_data_received (GtkWidget        *widget,
//                            GdkDragContext   *context,
//                            gint              x,
//                            gint              y,
//                            GtkSelectionData *data,
//                            guint             info,
//                            guint             time,
//                            gpointer          user_data)
//     {
//       GtkWidget *notebook;
//       GtkWidget **child;
//
//       notebook = gtk_drag_get_source_widget (context);
//       child = (void*) gtk_selection_data_get_data (data);
//
//       // process_widget (*child);
//
//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//     }
//
// If you want a notebook to accept drags from other widgets, you will have to
// set your own DnD code to do it.
//
// The function takes the following parameters:
//
//    - child Widget.
//    - detachable: whether the tab is detachable or not.
//
func (notebook *Notebook) SetTabDetachable(child Widgetter, detachable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if detachable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_detachable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(detachable)
}

// SetTabLabel changes the tab label for child. If NULL is specified for
// tab_label, then the page will have the label “page N”.
//
// The function takes the following parameters:
//
//    - child: page.
//    - tabLabel (optional): tab label widget to use, or NULL for default tab
//      label.
//
func (notebook *Notebook) SetTabLabel(child, tabLabel Widgetter) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}

	C.gtk_notebook_set_tab_label(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
}

// SetTabLabelText creates a new label and sets it as the tab label for the page
// containing child.
//
// The function takes the following parameters:
//
//    - child: page.
//    - tabText: label text.
//
func (notebook *Notebook) SetTabLabelText(child Widgetter, tabText string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.gchar       // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(tabText)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_tab_label_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabText)
}

// SetTabPos sets the edge at which the tabs for switching pages in the notebook
// are drawn.
//
// The function takes the following parameters:
//
//    - pos: edge to draw the tabs at.
//
func (notebook *Notebook) SetTabPos(pos PositionType) {
	var _arg0 *C.GtkNotebook    // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.GtkPositionType(pos)

	C.gtk_notebook_set_tab_pos(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(pos)
}

// SetTabReorderable sets whether the notebook tab can be reordered via drag and
// drop or not.
//
// The function takes the following parameters:
//
//    - child Widget.
//    - reorderable: whether the tab is reorderable or not.
//
func (notebook *Notebook) SetTabReorderable(child Widgetter, reorderable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if reorderable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_reorderable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(reorderable)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_ToolItem_ConnectToolbarReconfigured(gpointer, guintptr);
// extern void _gotk4_gtk3_ToolItemClass_toolbar_reconfigured(GtkToolItem*);
// extern gboolean _gotk4_gtk3_ToolItem_ConnectCreateMenuProxy(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_ToolItemClass_create_menu_proxy(GtkToolItem*);
// gboolean _gotk4_gtk3_ToolItem_virtual_create_menu_proxy(void* fnptr, GtkToolItem* arg0) {
//   return ((gboolean (*)(GtkToolItem*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeToolItem = coreglib.Type(C.gtk_tool_item_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeToolItem, F: marshalToolItem},
	})
}

// ToolItemOverrides contains methods that are overridable.
type ToolItemOverrides struct {
	// The function returns the following values:
	//
	CreateMenuProxy func() bool
	// ToolbarReconfigured emits the signal ToolItem::toolbar_reconfigured on
	// tool_item. Toolbar and other ToolShell implementations use this function
	// to notify children, when some aspect of their configuration changes.
	ToolbarReconfigured func()
}

func defaultToolItemOverrides(v *ToolItem) ToolItemOverrides {
	return ToolItemOverrides{
		CreateMenuProxy:     v.createMenuProxy,
		ToolbarReconfigured: v.toolbarReconfigured,
	}
}

// ToolItem are widgets that can appear on a toolbar. To create a toolbar item
// that contain something else than a button, use gtk_tool_item_new(). Use
// gtk_container_add() to add a child widget to the tool item.
//
// For toolbar items that contain buttons, see the ToolButton, ToggleToolButton
// and RadioToolButton classes.
//
// See the Toolbar class for a description of the toolbar widget, and ToolShell
// for a description of the tool shell interface.
type ToolItem struct {
	_ [0]func() // equal guard
	Bin

	*coreglib.Object
	Activatable
}

var (
	_ Binner            = (*ToolItem)(nil)
	_ coreglib.Objector = (*ToolItem)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ToolItem, *ToolItemClass, ToolItemOverrides](
		GTypeToolItem,
		initToolItemClass,
		wrapToolItem,
		defaultToolItemOverrides,
	)
}

func initToolItemClass(gclass unsafe.Pointer, overrides ToolItemOverrides, classInitFunc func(*ToolItemClass)) {
	pclass := (*C.GtkToolItemClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeToolItem))))

	if overrides.CreateMenuProxy != nil {
		pclass.create_menu_proxy = (*[0]byte)(C._gotk4_gtk3_ToolItemClass_create_menu_proxy)
	}

	if overrides.ToolbarReconfigured != nil {
		pclass.toolbar_reconfigured = (*[0]byte)(C._gotk4_gtk3_ToolItemClass_toolbar_reconfigured)
	}

	if classInitFunc != nil {
		class := (*ToolItemClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapToolItem(obj *coreglib.Object) *ToolItem {
	return &ToolItem{
		Bin: Bin{
			Container: Container{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					ImplementorIface: atk.ImplementorIface{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
				},
			},
		},
		Object: obj,
		Activatable: Activatable{
			Object: obj,
		},
	}
}

func marshalToolItem(p uintptr) (interface{}, error) {
	return wrapToolItem(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCreateMenuProxy: this signal is emitted when the toolbar needs
// information from tool_item about whether the item should appear in the
// toolbar overflow menu. In response the tool item should either
//
// - call gtk_tool_item_set_proxy_menu_item() with a NULL pointer and return
// TRUE to indicate that the item should not appear in the overflow menu
//
// - call gtk_tool_item_set_proxy_menu_item() with a new menu item and return
// TRUE, or
//
// - return FALSE to indicate that the signal was not handled by the item. This
// means that the item will not appear in the overflow menu unless a later
// handler installs a menu item.
//
// The toolbar may cache the result of this signal. When the tool item changes
// how it will respond to this signal it must call gtk_tool_item_rebuild_menu()
// to invalidate the cache and ensure that the toolbar rebuilds its overflow
// menu.
func (toolItem *ToolItem) ConnectCreateMenuProxy(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(toolItem, "create-menu-proxy", false, unsafe.Pointer(C._gotk4_gtk3_ToolItem_ConnectCreateMenuProxy), f)
}

// ConnectToolbarReconfigured: this signal is emitted when some property of the
// toolbar that the item is a child of changes. For custom subclasses of
// ToolItem, the default handler of this signal use the functions
//
// - gtk_tool_shell_get_orientation()
//
// - gtk_tool_shell_get_style()
//
// - gtk_tool_shell_get_icon_size()
//
// - gtk_tool_shell_get_relief_style() to find out what the toolbar should look
// like and change themselves accordingly.
func (toolItem *ToolItem) ConnectToolbarReconfigured(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(toolItem, "toolbar-reconfigured", false, unsafe.Pointer(C._gotk4_gtk3_ToolItem_ConnectToolbarReconfigured), f)
}

// The function returns the following values:
//
func (toolItem *ToolItem) createMenuProxy() bool {
	gclass := (*C.GtkToolItemClass)(coreglib.PeekParentClass(toolItem))
	fnarg := gclass.create_menu_proxy

	var _arg0 *C.GtkToolItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkToolItem)(unsafe.Pointer(coreglib.InternObject(toolItem).Native()))

	_cret = C._gotk4_gtk3_ToolItem_virtual_create_menu_proxy(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(toolItem)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ToolItemClass: instance of this type is always passed by reference.
type ToolItemClass struct {
	*toolItemClass
}

// toolItemClass is the struct that's finalized.
type toolItemClass struct {
	native *C.GtkToolItemClass
}

// ParentClass: parent class.
func (t *ToolItemClass) ParentClass() *BinClass {
	valptr := &t.native.parent_class
	var _v *BinClass // out
	_v = (*BinClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

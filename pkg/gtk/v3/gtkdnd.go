// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// DragCancel cancels an ongoing drag operation on the source side.
//
// If you want to be able to cancel a drag operation in this way, you need to
// keep a pointer to the drag context, either from an explicit call to
// gtk_drag_begin_with_coordinates(), or by connecting to Widget::drag-begin.
//
// If context does not refer to an ongoing drag operation, this function does
// nothing.
//
// If a drag is cancelled in this way, the result argument of
// Widget::drag-failed is set to GTK_DRAG_RESULT_ERROR.
//
// The function takes the following parameters:
//
//    - context as e.g. returned by gtk_drag_begin_with_coordinates().
//
func DragCancel(context *gdk.DragContext) {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "drag_cancel").Invoke(args[:], nil)

	runtime.KeepAlive(context)
}

// DragFinish informs the drag source that the drop is finished, and that the
// data of the drag will no longer be required.
//
// The function takes the following parameters:
//
//    - context: drag context.
//    - success: flag indicating whether the drop was successful.
//    - del: flag indicating whether the source should delete the original data.
//      (This should be TRUE for a move).
//    - time_: timestamp from the Widget::drag-drop signal.
//
func DragFinish(context *gdk.DragContext, success, del bool, time_ uint32) {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out
	var _arg2 C.gboolean // out
	var _arg3 C.guint32  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if success {
		_arg1 = C.TRUE
	}
	if del {
		_arg2 = C.TRUE
	}
	_arg3 = C.guint32(time_)
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0
	*(*bool)(unsafe.Pointer(&args[1])) = _arg1
	*(*bool)(unsafe.Pointer(&args[2])) = _arg2
	*(*uint32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "drag_finish").Invoke(args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(success)
	runtime.KeepAlive(del)
	runtime.KeepAlive(time_)
}

// DragGetSourceWidget determines the source widget for a drag.
//
// The function takes the following parameters:
//
//    - context: (destination side) drag context.
//
// The function returns the following values:
//
//    - widget (optional): if the drag is occurring within a single application,
//      a pointer to the source widget. Otherwise, NULL.
//
func DragGetSourceWidget(context *gdk.DragContext) Widgetter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "drag_get_source_widget").Invoke(args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(context)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// DragSetIconDefault sets the icon for a particular drag to the default icon.
//
// The function takes the following parameters:
//
//    - context for a drag (This must be called with a context for the source
//      side of a drag).
//
func DragSetIconDefault(context *gdk.DragContext) {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "drag_set_icon_default").Invoke(args[:], nil)

	runtime.KeepAlive(context)
}

// DragSetIconGIcon sets the icon for a given drag from the given icon. See the
// documentation for gtk_drag_set_icon_name() for more details about using icons
// in drag and drop.
//
// The function takes the following parameters:
//
//    - context for a drag (This must be called with a context for the source
//      side of a drag).
//    - icon: #GIcon.
//    - hotX: x offset of the hotspot within the icon.
//    - hotY: y offset of the hotspot within the icon.
//
func DragSetIconGIcon(context *gdk.DragContext, icon gio.Iconner, hotX, hotY int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	_arg2 = C.gint(hotX)
	_arg3 = C.gint(hotY)
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0
	*(*gio.Iconner)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "drag_set_icon_gicon").Invoke(args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

// DragSetIconName sets the icon for a given drag from a named themed icon. See
// the docs for IconTheme for more details. Note that the size of the icon
// depends on the icon theme (the icon is loaded at the symbolic size
// K_ICON_SIZE_DND), thus hot_x and hot_y have to be used with care.
//
// The function takes the following parameters:
//
//    - context for a drag (This must be called with a context for the source
//      side of a drag).
//    - iconName: name of icon to use.
//    - hotX: x offset of the hotspot within the icon.
//    - hotY: y offset of the hotspot within the icon.
//
func DragSetIconName(context *gdk.DragContext, iconName string, hotX, hotY int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(hotX)
	_arg3 = C.gint(hotY)
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0
	*(*string)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "drag_set_icon_name").Invoke(args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(iconName)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

// DragSetIconPixbuf sets pixbuf as the icon for a given drag.
//
// The function takes the following parameters:
//
//    - context for a drag (This must be called with a context for the source
//      side of a drag).
//    - pixbuf to use as the drag icon.
//    - hotX: x offset within widget of the hotspot.
//    - hotY: y offset within widget of the hotspot.
//
func DragSetIconPixbuf(context *gdk.DragContext, pixbuf *gdkpixbuf.Pixbuf, hotX, hotY int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	_arg2 = C.gint(hotX)
	_arg3 = C.gint(hotY)
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0
	*(**gdkpixbuf.Pixbuf)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "drag_set_icon_pixbuf").Invoke(args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

// DragSetIconStock sets the icon for a given drag from a stock ID.
//
// Deprecated: Use gtk_drag_set_icon_name() instead.
//
// The function takes the following parameters:
//
//    - context for a drag (This must be called with a context for the source
//      side of a drag).
//    - stockId: ID of the stock icon to use for the drag.
//    - hotX: x offset within the icon of the hotspot.
//    - hotY: y offset within the icon of the hotspot.
//
func DragSetIconStock(context *gdk.DragContext, stockId string, hotX, hotY int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(stockId)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(hotX)
	_arg3 = C.gint(hotY)
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0
	*(*string)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "drag_set_icon_stock").Invoke(args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(stockId)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

// DragSetIconSurface sets surface as the icon for a given drag. GTK+ retains
// references for the arguments, and will release them when they are no longer
// needed.
//
// To position the surface relative to the mouse, use
// cairo_surface_set_device_offset() on surface. The mouse cursor will be
// positioned at the (0,0) coordinate of the surface.
//
// The function takes the following parameters:
//
//    - context for a drag (This must be called with a context for the source
//      side of a drag).
//    - surface to use as icon.
//
func DragSetIconSurface(context *gdk.DragContext, surface *cairo.Surface) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(surface.Native()))
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0
	*(**cairo.Surface)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "drag_set_icon_surface").Invoke(args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(surface)
}

// DragSetIconWidget changes the icon for drag operation to a given widget. GTK+
// will not destroy the widget, so if you don’t want it to persist, you should
// connect to the “drag-end” signal and destroy it yourself.
//
// The function takes the following parameters:
//
//    - context for a drag. (This must be called with a context for the source
//      side of a drag).
//    - widget to use as an icon.
//    - hotX: x offset within widget of the hotspot.
//    - hotY: y offset within widget of the hotspot.
//
func DragSetIconWidget(context *gdk.DragContext, widget Widgetter, hotX, hotY int32) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint  // out
	var _arg3 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.gint(hotX)
	_arg3 = C.gint(hotY)
	*(**gdk.DragContext)(unsafe.Pointer(&args[0])) = _arg0
	*(*Widgetter)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "drag_set_icon_widget").Invoke(args[:], nil)

	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

// DragCheckThreshold checks to see if a mouse drag starting at (start_x,
// start_y) and ending at (current_x, current_y) has passed the GTK+ drag
// threshold, and thus should trigger the beginning of a drag-and-drop
// operation.
//
// The function takes the following parameters:
//
//    - startX: x coordinate of start of drag.
//    - startY: y coordinate of start of drag.
//    - currentX: current X coordinate.
//    - currentY: current Y coordinate.
//
// The function returns the following values:
//
//    - ok: TRUE if the drag threshold has been passed.
//
func (widget *Widget) DragCheckThreshold(startX, startY, currentX, currentY int32) bool {
	var args [5]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gint     // out
	var _arg2 C.gint     // out
	var _arg3 C.gint     // out
	var _arg4 C.gint     // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.gint(startX)
	_arg2 = C.gint(startY)
	_arg3 = C.gint(currentX)
	_arg4 = C.gint(currentY)
	*(**Widget)(unsafe.Pointer(&args[1])) = _arg1
	*(*int32)(unsafe.Pointer(&args[2])) = _arg2
	*(*int32)(unsafe.Pointer(&args[3])) = _arg3
	*(*int32)(unsafe.Pointer(&args[4])) = _arg4

	_gret := girepository.MustFind("Gtk", "Widget").InvokeMethod("drag_check_threshold", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(widget)
	runtime.KeepAlive(startX)
	runtime.KeepAlive(startY)
	runtime.KeepAlive(currentX)
	runtime.KeepAlive(currentY)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragHighlight highlights a widget as a currently hovered drop target. To end
// the highlight, call gtk_drag_unhighlight(). GTK+ calls this automatically if
// GTK_DEST_DEFAULT_HIGHLIGHT is set.
func (widget *Widget) DragHighlight() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	*(**Widget)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Widget").InvokeMethod("drag_highlight", args[:], nil)

	runtime.KeepAlive(widget)
}

// DragUnhighlight removes a highlight set by gtk_drag_highlight() from a
// widget.
func (widget *Widget) DragUnhighlight() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	*(**Widget)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Widget").InvokeMethod("drag_unhighlight", args[:], nil)

	runtime.KeepAlive(widget)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// NewStatusIconFromGIcon creates a status icon displaying a #GIcon. If the icon
// is a themed icon, it will be updated when the theme changes.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications.
//
// The function takes the following parameters:
//
//    - icon: #GIcon.
//
// The function returns the following values:
//
//    - statusIcon: new StatusIcon.
//
func NewStatusIconFromGIcon(icon gio.Iconner) *StatusIcon {
	var _arg1 *C.GIcon         // out
	var _cret *C.GtkStatusIcon // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.gtk_status_icon_new_from_gicon(_arg1)
	runtime.KeepAlive(icon)

	var _statusIcon *StatusIcon // out

	_statusIcon = wrapStatusIcon(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _statusIcon
}

// GIcon retrieves the #GIcon being displayed by the StatusIcon. The storage
// type of the status icon must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// gtk_status_icon_get_storage_type()). The caller of this function does not own
// a reference to the returned #GIcon.
//
// If this function fails, icon is left unchanged;
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - icon (optional): displayed icon, or NULL if the image is empty.
//
func (statusIcon *StatusIcon) GIcon() *gio.Icon {
	var _arg0 *C.GtkStatusIcon // out
	var _cret *C.GIcon         // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_cret = C.gtk_status_icon_get_gicon(_arg0)
	runtime.KeepAlive(statusIcon)

	var _icon *gio.Icon // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// X11WindowID: this function is only useful on the X11/freedesktop.org
// platform.
//
// It returns a window ID for the widget in the underlying status icon
// implementation. This is useful for the Galago notification service, which can
// send a window ID in the protocol in order for the server to position
// notification windows pointing to a status icon reliably.
//
// This function is not intended for other use cases which are more likely to be
// met by one of the non-X11 specific methods, such as
// gtk_status_icon_position_menu().
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; there is no direct replacement for this function.
//
// The function returns the following values:
//
//    - guint32: 32 bit unsigned integer identifier for the underlying X11
//      Window.
//
func (statusIcon *StatusIcon) X11WindowID() uint32 {
	var _arg0 *C.GtkStatusIcon // out
	var _cret C.guint32        // in

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))

	_cret = C.gtk_status_icon_get_x11_window_id(_arg0)
	runtime.KeepAlive(statusIcon)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// SetFromGIcon makes status_icon display the #GIcon. See
// gtk_status_icon_new_from_gicon() for details.
//
// Deprecated: Use #GNotification and Application to provide status
// notifications; you can use g_notification_set_icon() to associate a #GIcon
// with a notification.
//
// The function takes the following parameters:
//
//    - icon: GIcon.
//
func (statusIcon *StatusIcon) SetFromGIcon(icon gio.Iconner) {
	var _arg0 *C.GtkStatusIcon // out
	var _arg1 *C.GIcon         // out

	_arg0 = (*C.GtkStatusIcon)(unsafe.Pointer(coreglib.InternObject(statusIcon).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	C.gtk_status_icon_set_from_gicon(_arg0, _arg1)
	runtime.KeepAlive(statusIcon)
	runtime.KeepAlive(icon)
}

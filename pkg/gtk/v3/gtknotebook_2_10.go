// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// TabDetachable returns whether the tab contents can be detached from notebook.
//
// The function takes the following parameters:
//
//    - child Widget.
//
// The function returns the following values:
//
//    - ok: TRUE if the tab is detachable.
//
func (notebook *Notebook) TabDetachable(child Widgetter) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_detachable(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
//
// The function takes the following parameters:
//
//    - child Widget.
//
// The function returns the following values:
//
//    - ok: TRUE if the tab is reorderable.
//
func (notebook *Notebook) TabReorderable(child Widgetter) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_reorderable(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetTabDetachable sets whether the tab can be detached from notebook to
// another notebook or widget.
//
// Note that 2 notebooks must share a common group identificator (see
// gtk_notebook_set_group_name()) to allow automatic tabs interchange between
// them.
//
// If you want a widget to interact with a notebook through DnD (i.e.: accept
// dragged tabs from it) it must be set as a drop destination and accept the
// target “GTK_NOTEBOOK_TAB”. The notebook will fill the selection with a
// GtkWidget** pointing to the child widget that corresponds to the dropped tab.
//
// Note that you should use gtk_notebook_detach_tab() instead of
// gtk_container_remove() if you want to remove the tab from the source notebook
// as part of accepting a drop. Otherwise, the source notebook will think that
// the dragged tab was removed from underneath the ongoing drag operation, and
// will initiate a drag cancel animation.
//
//     static void
//     on_drag_data_received (GtkWidget        *widget,
//                            GdkDragContext   *context,
//                            gint              x,
//                            gint              y,
//                            GtkSelectionData *data,
//                            guint             info,
//                            guint             time,
//                            gpointer          user_data)
//     {
//       GtkWidget *notebook;
//       GtkWidget **child;
//
//       notebook = gtk_drag_get_source_widget (context);
//       child = (void*) gtk_selection_data_get_data (data);
//
//       // process_widget (*child);
//
//       gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//     }
//
// If you want a notebook to accept drags from other widgets, you will have to
// set your own DnD code to do it.
//
// The function takes the following parameters:
//
//    - child Widget.
//    - detachable: whether the tab is detachable or not.
//
func (notebook *Notebook) SetTabDetachable(child Widgetter, detachable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if detachable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_detachable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(detachable)
}

// SetTabReorderable sets whether the notebook tab can be reordered via drag and
// drop or not.
//
// The function takes the following parameters:
//
//    - child Widget.
//    - reorderable: whether the tab is reorderable or not.
//
func (notebook *Notebook) SetTabReorderable(child Widgetter, reorderable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if reorderable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_reorderable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(reorderable)
}

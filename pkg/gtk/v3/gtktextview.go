// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern gboolean _gotk4_gtk3_TextViewClass_extend_selection(GtkTextView*, GtkTextExtendSelection, GtkTextIter*, GtkTextIter*, GtkTextIter*);
// extern gboolean _gotk4_gtk3_TextView_ConnectExtendSelection(gpointer, GtkTextExtendSelection, GtkTextIter*, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk3_TextViewClass_backspace(GtkTextView*);
// extern void _gotk4_gtk3_TextViewClass_copy_clipboard(GtkTextView*);
// extern void _gotk4_gtk3_TextViewClass_cut_clipboard(GtkTextView*);
// extern void _gotk4_gtk3_TextViewClass_delete_from_cursor(GtkTextView*, GtkDeleteType, gint);
// extern void _gotk4_gtk3_TextViewClass_draw_layer(GtkTextView*, GtkTextViewLayer, cairo_t*);
// extern void _gotk4_gtk3_TextViewClass_insert_at_cursor(GtkTextView*, gchar*);
// extern void _gotk4_gtk3_TextViewClass_insert_emoji(GtkTextView*);
// extern void _gotk4_gtk3_TextViewClass_move_cursor(GtkTextView*, GtkMovementStep, gint, gboolean);
// extern void _gotk4_gtk3_TextViewClass_paste_clipboard(GtkTextView*);
// extern void _gotk4_gtk3_TextViewClass_populate_popup(GtkTextView*, GtkWidget*);
// extern void _gotk4_gtk3_TextViewClass_set_anchor(GtkTextView*);
// extern void _gotk4_gtk3_TextViewClass_toggle_overwrite(GtkTextView*);
// extern void _gotk4_gtk3_TextView_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectDeleteFromCursor(gpointer, GtkDeleteType, gint, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectInsertAtCursor(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectMoveViewport(gpointer, GtkScrollStep, gint, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectPopulatePopup(gpointer, GtkWidget*, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectPreeditChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectSelectAll(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectSetAnchor(gpointer, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectToggleCursorVisible(gpointer, guintptr);
// extern void _gotk4_gtk3_TextView_ConnectToggleOverwrite(gpointer, guintptr);
import "C"

// GType values.
var (
	GTypeTextExtendSelection = coreglib.Type(C.gtk_text_extend_selection_get_type())
	GTypeTextViewLayer       = coreglib.Type(C.gtk_text_view_layer_get_type())
	GTypeTextWindowType      = coreglib.Type(C.gtk_text_window_type_get_type())
	GTypeTextView            = coreglib.Type(C.gtk_text_view_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTextExtendSelection, F: marshalTextExtendSelection},
		coreglib.TypeMarshaler{T: GTypeTextViewLayer, F: marshalTextViewLayer},
		coreglib.TypeMarshaler{T: GTypeTextWindowType, F: marshalTextWindowType},
		coreglib.TypeMarshaler{T: GTypeTextView, F: marshalTextView},
	})
}

// TEXT_VIEW_PRIORITY_VALIDATE: priority at which the text view validates
// onscreen lines in an idle job in the background.
const TEXT_VIEW_PRIORITY_VALIDATE = 125

// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
type TextExtendSelection C.gint

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = iota
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextExtendSelection.
func (t TextExtendSelection) String() string {
	switch t {
	case TextExtendSelectionWord:
		return "Word"
	case TextExtendSelectionLine:
		return "Line"
	default:
		return fmt.Sprintf("TextExtendSelection(%d)", t)
	}
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::draw_layer vfunc.
type TextViewLayer C.gint

const (
	// TextViewLayerBelow: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_BELOW_TEXT instead.
	TextViewLayerBelow TextViewLayer = iota
	// TextViewLayerAbove: old deprecated layer, use
	// GTK_TEXT_VIEW_LAYER_ABOVE_TEXT instead.
	TextViewLayerAbove
	// TextViewLayerBelowText: layer rendered below the text (but above the
	// background). Since: 3.20.
	TextViewLayerBelowText
	// TextViewLayerAboveText: layer rendered above the text. Since: 3.20.
	TextViewLayerAboveText
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextViewLayer.
func (t TextViewLayer) String() string {
	switch t {
	case TextViewLayerBelow:
		return "Below"
	case TextViewLayerAbove:
		return "Above"
	case TextViewLayerBelowText:
		return "BelowText"
	case TextViewLayerAboveText:
		return "AboveText"
	default:
		return fmt.Sprintf("TextViewLayer(%d)", t)
	}
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType C.gint

const (
	// TextWindowPrivate: invalid value, used as a marker.
	TextWindowPrivate TextWindowType = iota
	// TextWindowWidget: window that floats over scrolling areas.
	TextWindowWidget
	// TextWindowText: scrollable text window.
	TextWindowText
	// TextWindowLeft: left side border window.
	TextWindowLeft
	// TextWindowRight: right side border window.
	TextWindowRight
	// TextWindowTop: top border window.
	TextWindowTop
	// TextWindowBottom: bottom border window.
	TextWindowBottom
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextWindowType.
func (t TextWindowType) String() string {
	switch t {
	case TextWindowPrivate:
		return "Private"
	case TextWindowWidget:
		return "Widget"
	case TextWindowText:
		return "Text"
	case TextWindowLeft:
		return "Left"
	case TextWindowRight:
		return "Right"
	case TextWindowTop:
		return "Top"
	case TextWindowBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("TextWindowType(%d)", t)
	}
}

// TextViewOverrider contains methods that are overridable.
type TextViewOverrider interface {
	Backspace()
	CopyClipboard()
	CutClipboard()
	// The function takes the following parameters:
	//
	//    - typ
	//    - count
	//
	DeleteFromCursor(typ DeleteType, count int)
	// The function takes the following parameters:
	//
	//    - layer
	//    - cr
	//
	DrawLayer(layer TextViewLayer, cr *cairo.Context)
	// The function takes the following parameters:
	//
	//    - granularity
	//    - location
	//    - start
	//    - end
	//
	// The function returns the following values:
	//
	ExtendSelection(granularity TextExtendSelection, location, start, end *TextIter) bool
	// The function takes the following parameters:
	//
	InsertAtCursor(str string)
	InsertEmoji()
	// The function takes the following parameters:
	//
	//    - step
	//    - count
	//    - extendSelection
	//
	MoveCursor(step MovementStep, count int, extendSelection bool)
	PasteClipboard()
	// The function takes the following parameters:
	//
	PopulatePopup(popup Widgetter)
	SetAnchor()
	ToggleOverwrite()
}

// TextView: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// CSS nodes
//
//    textview.view
//    ├── border.top
//    ├── border.left
//    ├── text
//    │   ╰── [selection]
//    ├── border.right
//    ├── border.bottom
//    ╰── [window.popup]
//
// GtkTextView has a main css node with name textview and style class .view, and
// subnodes for each of the border windows, and the main text area, with names
// border and text, respectively. The border nodes each get one of the style
// classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
type TextView struct {
	_ [0]func() // equal guard
	Container

	*coreglib.Object
	Scrollable
}

var (
	_ Containerer       = (*TextView)(nil)
	_ coreglib.Objector = (*TextView)(nil)
)

func init() {
	coreglib.RegisterClassInfo(coreglib.ClassTypeInfo{
		GType:        GTypeTextView,
		GoType:       reflect.TypeOf((*TextView)(nil)),
		InitClass:    initClassTextView,
		ClassSize:    uint16(unsafe.Sizeof(C.GtkTextView{})),
		InstanceSize: uint16(unsafe.Sizeof(C.GtkTextViewClass{})),
	})
}

func initClassTextView(gclass unsafe.Pointer, goval any) {

	pclass := (*C.GtkTextViewClass)(unsafe.Pointer(gclass))

	if _, ok := goval.(interface{ Backspace() }); ok {
		pclass.backspace = (*[0]byte)(C._gotk4_gtk3_TextViewClass_backspace)
	}

	if _, ok := goval.(interface{ CopyClipboard() }); ok {
		pclass.copy_clipboard = (*[0]byte)(C._gotk4_gtk3_TextViewClass_copy_clipboard)
	}

	if _, ok := goval.(interface{ CutClipboard() }); ok {
		pclass.cut_clipboard = (*[0]byte)(C._gotk4_gtk3_TextViewClass_cut_clipboard)
	}

	if _, ok := goval.(interface {
		DeleteFromCursor(typ DeleteType, count int)
	}); ok {
		pclass.delete_from_cursor = (*[0]byte)(C._gotk4_gtk3_TextViewClass_delete_from_cursor)
	}

	if _, ok := goval.(interface {
		DrawLayer(layer TextViewLayer, cr *cairo.Context)
	}); ok {
		pclass.draw_layer = (*[0]byte)(C._gotk4_gtk3_TextViewClass_draw_layer)
	}

	if _, ok := goval.(interface {
		ExtendSelection(granularity TextExtendSelection, location, start, end *TextIter) bool
	}); ok {
		pclass.extend_selection = (*[0]byte)(C._gotk4_gtk3_TextViewClass_extend_selection)
	}

	if _, ok := goval.(interface{ InsertAtCursor(str string) }); ok {
		pclass.insert_at_cursor = (*[0]byte)(C._gotk4_gtk3_TextViewClass_insert_at_cursor)
	}

	if _, ok := goval.(interface{ InsertEmoji() }); ok {
		pclass.insert_emoji = (*[0]byte)(C._gotk4_gtk3_TextViewClass_insert_emoji)
	}

	if _, ok := goval.(interface {
		MoveCursor(step MovementStep, count int, extendSelection bool)
	}); ok {
		pclass.move_cursor = (*[0]byte)(C._gotk4_gtk3_TextViewClass_move_cursor)
	}

	if _, ok := goval.(interface{ PasteClipboard() }); ok {
		pclass.paste_clipboard = (*[0]byte)(C._gotk4_gtk3_TextViewClass_paste_clipboard)
	}

	if _, ok := goval.(interface{ PopulatePopup(popup Widgetter) }); ok {
		pclass.populate_popup = (*[0]byte)(C._gotk4_gtk3_TextViewClass_populate_popup)
	}

	if _, ok := goval.(interface{ SetAnchor() }); ok {
		pclass.set_anchor = (*[0]byte)(C._gotk4_gtk3_TextViewClass_set_anchor)
	}

	if _, ok := goval.(interface{ ToggleOverwrite() }); ok {
		pclass.toggle_overwrite = (*[0]byte)(C._gotk4_gtk3_TextViewClass_toggle_overwrite)
	}
}

//export _gotk4_gtk3_TextViewClass_backspace
func _gotk4_gtk3_TextViewClass_backspace(arg0 *C.GtkTextView) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ Backspace() })

	iface.Backspace()
}

//export _gotk4_gtk3_TextViewClass_copy_clipboard
func _gotk4_gtk3_TextViewClass_copy_clipboard(arg0 *C.GtkTextView) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ CopyClipboard() })

	iface.CopyClipboard()
}

//export _gotk4_gtk3_TextViewClass_cut_clipboard
func _gotk4_gtk3_TextViewClass_cut_clipboard(arg0 *C.GtkTextView) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ CutClipboard() })

	iface.CutClipboard()
}

//export _gotk4_gtk3_TextViewClass_delete_from_cursor
func _gotk4_gtk3_TextViewClass_delete_from_cursor(arg0 *C.GtkTextView, arg1 C.GtkDeleteType, arg2 C.gint) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DeleteFromCursor(typ DeleteType, count int)
	})

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	iface.DeleteFromCursor(_typ, _count)
}

//export _gotk4_gtk3_TextViewClass_draw_layer
func _gotk4_gtk3_TextViewClass_draw_layer(arg0 *C.GtkTextView, arg1 C.GtkTextViewLayer, arg2 *C.cairo_t) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		DrawLayer(layer TextViewLayer, cr *cairo.Context)
	})

	var _layer TextViewLayer // out
	var _cr *cairo.Context   // out

	_layer = TextViewLayer(arg1)
	_cr = cairo.WrapContext(uintptr(unsafe.Pointer(arg2)))
	C.cairo_reference(arg2)
	runtime.SetFinalizer(_cr, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	iface.DrawLayer(_layer, _cr)
}

//export _gotk4_gtk3_TextViewClass_extend_selection
func _gotk4_gtk3_TextViewClass_extend_selection(arg0 *C.GtkTextView, arg1 C.GtkTextExtendSelection, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 *C.GtkTextIter) (cret C.gboolean) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ExtendSelection(granularity TextExtendSelection, location, start, end *TextIter) bool
	})

	var _granularity TextExtendSelection // out
	var _location *TextIter              // out
	var _start *TextIter                 // out
	var _end *TextIter                   // out

	_granularity = TextExtendSelection(arg1)
	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := iface.ExtendSelection(_granularity, _location, _start, _end)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TextViewClass_insert_at_cursor
func _gotk4_gtk3_TextViewClass_insert_at_cursor(arg0 *C.GtkTextView, arg1 *C.gchar) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ InsertAtCursor(str string) })

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	iface.InsertAtCursor(_str)
}

//export _gotk4_gtk3_TextViewClass_insert_emoji
func _gotk4_gtk3_TextViewClass_insert_emoji(arg0 *C.GtkTextView) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ InsertEmoji() })

	iface.InsertEmoji()
}

//export _gotk4_gtk3_TextViewClass_move_cursor
func _gotk4_gtk3_TextViewClass_move_cursor(arg0 *C.GtkTextView, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface {
		MoveCursor(step MovementStep, count int, extendSelection bool)
	})

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	iface.MoveCursor(_step, _count, _extendSelection)
}

//export _gotk4_gtk3_TextViewClass_paste_clipboard
func _gotk4_gtk3_TextViewClass_paste_clipboard(arg0 *C.GtkTextView) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ PasteClipboard() })

	iface.PasteClipboard()
}

//export _gotk4_gtk3_TextViewClass_populate_popup
func _gotk4_gtk3_TextViewClass_populate_popup(arg0 *C.GtkTextView, arg1 *C.GtkWidget) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ PopulatePopup(popup Widgetter) })

	var _popup Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_popup = rv
	}

	iface.PopulatePopup(_popup)
}

//export _gotk4_gtk3_TextViewClass_set_anchor
func _gotk4_gtk3_TextViewClass_set_anchor(arg0 *C.GtkTextView) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ SetAnchor() })

	iface.SetAnchor()
}

//export _gotk4_gtk3_TextViewClass_toggle_overwrite
func _gotk4_gtk3_TextViewClass_toggle_overwrite(arg0 *C.GtkTextView) {
	goval := coreglib.GoObjectFromInstance(unsafe.Pointer(arg0))
	iface := goval.(interface{ ToggleOverwrite() })

	iface.ToggleOverwrite()
}

func wrapTextView(obj *coreglib.Object) *TextView {
	return &TextView{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalTextView(p uintptr) (interface{}, error) {
	return wrapTextView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_TextView_ConnectBackspace
func _gotk4_gtk3_TextView_ConnectBackspace(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectBackspace signal is a [keybinding signal][GtkBindingSignal] which gets
// emitted when the user asks for it.
//
// The default bindings for this signal are Backspace and Shift-Backspace.
func (textView *TextView) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "backspace", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectBackspace), f)
}

//export _gotk4_gtk3_TextView_ConnectCopyClipboard
func _gotk4_gtk3_TextView_ConnectCopyClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCopyClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to copy the selection to the clipboard.
//
// The default bindings for this signal are Ctrl-c and Ctrl-Insert.
func (textView *TextView) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectCopyClipboard), f)
}

//export _gotk4_gtk3_TextView_ConnectCutClipboard
func _gotk4_gtk3_TextView_ConnectCutClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectCutClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to cut the selection to the clipboard.
//
// The default bindings for this signal are Ctrl-x and Shift-Delete.
func (textView *TextView) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectCutClipboard), f)
}

//export _gotk4_gtk3_TextView_ConnectDeleteFromCursor
func _gotk4_gtk3_TextView_ConnectDeleteFromCursor(arg0 C.gpointer, arg1 C.GtkDeleteType, arg2 C.gint, arg3 C.guintptr) {
	var f func(typ DeleteType, count int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(typ DeleteType, count int))
	}

	var _typ DeleteType // out
	var _count int      // out

	_typ = DeleteType(arg1)
	_count = int(arg2)

	f(_typ, _count)
}

// ConnectDeleteFromCursor signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted when the user initiates a text deletion.
//
// If the type is GTK_DELETE_CHARS, GTK+ deletes the selection if there is one,
// otherwise it deletes the requested number of characters.
//
// The default bindings for this signal are Delete for deleting a character,
// Ctrl-Delete for deleting a word and Ctrl-Backspace for deleting a word
// backwords.
func (textView *TextView) ConnectDeleteFromCursor(f func(typ DeleteType, count int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "delete-from-cursor", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectDeleteFromCursor), f)
}

//export _gotk4_gtk3_TextView_ConnectExtendSelection
func _gotk4_gtk3_TextView_ConnectExtendSelection(arg0 C.gpointer, arg1 C.GtkTextExtendSelection, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 *C.GtkTextIter, arg5 C.guintptr) (cret C.gboolean) {
	var f func(granularity TextExtendSelection, location, start, end *TextIter) (ok bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(granularity TextExtendSelection, location, start, end *TextIter) (ok bool))
	}

	var _granularity TextExtendSelection // out
	var _location *TextIter              // out
	var _start *TextIter                 // out
	var _end *TextIter                   // out

	_granularity = TextExtendSelection(arg1)
	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	ok := f(_granularity, _location, _start, _end)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectExtendSelection signal is emitted when the selection needs to be
// extended at location.
func (textView *TextView) ConnectExtendSelection(f func(granularity TextExtendSelection, location, start, end *TextIter) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "extend-selection", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectExtendSelection), f)
}

//export _gotk4_gtk3_TextView_ConnectInsertAtCursor
func _gotk4_gtk3_TextView_ConnectInsertAtCursor(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(str string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(str string))
	}

	var _str string // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_str)
}

// ConnectInsertAtCursor signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user initiates the insertion of a fixed string at the
// cursor.
//
// This signal has no default bindings.
func (textView *TextView) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectInsertAtCursor), f)
}

//export _gotk4_gtk3_TextView_ConnectInsertEmoji
func _gotk4_gtk3_TextView_ConnectInsertEmoji(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectInsertEmoji signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to present the Emoji chooser for the text_view.
//
// The default bindings for this signal are Ctrl-. and Ctrl-;.
func (textView *TextView) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectInsertEmoji), f)
}

//export _gotk4_gtk3_TextView_ConnectMoveCursor
func _gotk4_gtk3_TextView_ConnectMoveCursor(arg0 C.gpointer, arg1 C.GtkMovementStep, arg2 C.gint, arg3 C.gboolean, arg4 C.guintptr) {
	var f func(step MovementStep, count int, extendSelection bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step MovementStep, count int, extendSelection bool))
	}

	var _step MovementStep    // out
	var _count int            // out
	var _extendSelection bool // out

	_step = MovementStep(arg1)
	_count = int(arg2)
	if arg3 != 0 {
		_extendSelection = true
	}

	f(_step, _count, _extendSelection)
}

// ConnectMoveCursor signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user initiates a cursor movement. If the cursor is not
// visible in text_view, this signal causes the viewport to be moved instead.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
//
// The default bindings for this signal come in two variants, the variant with
// the Shift modifier extends the selection, the variant without the Shift
// modifer does not. There are too many key combinations to list them all here.
//
// - Arrow keys move by individual characters/lines
//
// - Ctrl-arrow key combinations move by words/paragraphs
//
// - Home/End keys move to the ends of the buffer
//
// - PageUp/PageDown keys move vertically by pages
//
// - Ctrl-PageUp/PageDown keys move horizontally by pages.
func (textView *TextView) ConnectMoveCursor(f func(step MovementStep, count int, extendSelection bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectMoveCursor), f)
}

//export _gotk4_gtk3_TextView_ConnectMoveViewport
func _gotk4_gtk3_TextView_ConnectMoveViewport(arg0 C.gpointer, arg1 C.GtkScrollStep, arg2 C.gint, arg3 C.guintptr) {
	var f func(step ScrollStep, count int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(step ScrollStep, count int))
	}

	var _step ScrollStep // out
	var _count int       // out

	_step = ScrollStep(arg1)
	_count = int(arg2)

	f(_step, _count)
}

// ConnectMoveViewport signal is a [keybinding signal][GtkBindingSignal] which
// can be bound to key combinations to allow the user to move the viewport, i.e.
// change what part of the text view is visible in a containing scrolled window.
//
// There are no default bindings for this signal.
func (textView *TextView) ConnectMoveViewport(f func(step ScrollStep, count int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "move-viewport", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectMoveViewport), f)
}

//export _gotk4_gtk3_TextView_ConnectPasteClipboard
func _gotk4_gtk3_TextView_ConnectPasteClipboard(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectPasteClipboard signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted to paste the contents of the clipboard into the text view.
//
// The default bindings for this signal are Ctrl-v and Shift-Insert.
func (textView *TextView) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectPasteClipboard), f)
}

//export _gotk4_gtk3_TextView_ConnectPopulatePopup
func _gotk4_gtk3_TextView_ConnectPopulatePopup(arg0 C.gpointer, arg1 *C.GtkWidget, arg2 C.guintptr) {
	var f func(popup Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(popup Widgetter))
	}

	var _popup Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_popup = rv
	}

	f(_popup)
}

// ConnectPopulatePopup signal gets emitted before showing the context menu of
// the text view.
//
// If you need to add items to the context menu, connect to this signal and
// append your items to the popup, which will be a Menu in this case.
//
// If TextView:populate-all is TRUE, this signal will also be emitted to
// populate touch popups. In this case, popup will be a different container,
// e.g. a Toolbar.
//
// The signal handler should not make assumptions about the type of widget, but
// check whether popup is a Menu or Toolbar or another kind of container.
func (textView *TextView) ConnectPopulatePopup(f func(popup Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "populate-popup", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectPopulatePopup), f)
}

//export _gotk4_gtk3_TextView_ConnectPreeditChanged
func _gotk4_gtk3_TextView_ConnectPreeditChanged(arg0 C.gpointer, arg1 *C.gchar, arg2 C.guintptr) {
	var f func(preedit string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(preedit string))
	}

	var _preedit string // out

	_preedit = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))

	f(_preedit)
}

// ConnectPreeditChanged: if an input method is used, the typed text will not
// immediately be committed to the buffer. So if you are interested in the text,
// connect to this signal.
//
// This signal is only emitted if the text at the given position is actually
// editable.
func (textView *TextView) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectPreeditChanged), f)
}

//export _gotk4_gtk3_TextView_ConnectSelectAll
func _gotk4_gtk3_TextView_ConnectSelectAll(arg0 C.gpointer, arg1 C.gboolean, arg2 C.guintptr) {
	var f func(sel bool)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(sel bool))
	}

	var _sel bool // out

	if arg1 != 0 {
		_sel = true
	}

	f(_sel)
}

// ConnectSelectAll signal is a [keybinding signal][GtkBindingSignal] which gets
// emitted to select or unselect the complete contents of the text view.
//
// The default bindings for this signal are Ctrl-a and Ctrl-/ for selecting and
// Shift-Ctrl-a and Ctrl-\ for unselecting.
func (textView *TextView) ConnectSelectAll(f func(sel bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "select-all", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectSelectAll), f)
}

//export _gotk4_gtk3_TextView_ConnectSetAnchor
func _gotk4_gtk3_TextView_ConnectSetAnchor(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectSetAnchor signal is a [keybinding signal][GtkBindingSignal] which gets
// emitted when the user initiates setting the "anchor" mark. The "anchor" mark
// gets placed at the same position as the "insert" mark.
//
// This signal has no default bindings.
func (textView *TextView) ConnectSetAnchor(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "set-anchor", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectSetAnchor), f)
}

//export _gotk4_gtk3_TextView_ConnectToggleCursorVisible
func _gotk4_gtk3_TextView_ConnectToggleCursorVisible(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectToggleCursorVisible signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted to toggle the TextView:cursor-visible property.
//
// The default binding for this signal is F7.
func (textView *TextView) ConnectToggleCursorVisible(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "toggle-cursor-visible", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectToggleCursorVisible), f)
}

//export _gotk4_gtk3_TextView_ConnectToggleOverwrite
func _gotk4_gtk3_TextView_ConnectToggleOverwrite(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectToggleOverwrite signal is a [keybinding signal][GtkBindingSignal]
// which gets emitted to toggle the overwrite mode of the text view.
//
// The default bindings for this signal is Insert.
func (textView *TextView) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk3_TextView_ConnectToggleOverwrite), f)
}

// NewTextView creates a new TextView. If you don’t call
// gtk_text_view_set_buffer() before using the text view, an empty default
// buffer will be created for you. Get the buffer with
// gtk_text_view_get_buffer(). If you want to specify your own buffer, consider
// gtk_text_view_new_with_buffer().
//
// The function returns the following values:
//
//    - textView: new TextView.
//
func NewTextView() *TextView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_view_new()

	var _textView *TextView // out

	_textView = wrapTextView(coreglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// NewTextViewWithBuffer creates a new TextView widget displaying the buffer
// buffer. One buffer can be shared among many widgets. buffer may be NULL to
// create a default buffer, in which case this function is equivalent to
// gtk_text_view_new(). The text view adds its own reference count to the
// buffer; it does not take over an existing reference.
//
// The function takes the following parameters:
//
//    - buffer: TextBuffer.
//
// The function returns the following values:
//
//    - textView: new TextView.
//
func NewTextViewWithBuffer(buffer *TextBuffer) *TextView {
	var _arg1 *C.GtkTextBuffer // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_view_new_with_buffer(_arg1)
	runtime.KeepAlive(buffer)

	var _textView *TextView // out

	_textView = wrapTextView(coreglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// AddChildAtAnchor adds a child widget in the text buffer, at the given anchor.
//
// The function takes the following parameters:
//
//    - child: Widget.
//    - anchor in the TextBuffer for text_view.
//
func (textView *TextView) AddChildAtAnchor(child Widgetter, anchor *TextChildAnchor) {
	var _arg0 *C.GtkTextView        // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(anchor)
}

// AddChildInWindow adds a child at fixed coordinates in one of the text
// widget's windows.
//
// The window must have nonzero size (see
// gtk_text_view_set_border_window_size()). Note that the child coordinates are
// given relative to scrolling. When placing a child in K_TEXT_WINDOW_WIDGET,
// scrolling is irrelevant, the child floats above all scrollable areas. But
// when placing a child in one of the scrollable windows (border windows or text
// window) it will move with the scrolling as needed.
//
// The function takes the following parameters:
//
//    - child: Widget.
//    - whichWindow: which window the child should appear in.
//    - xpos: x position of child in window coordinates.
//    - ypos: y position of child in window coordinates.
//
func (textView *TextView) AddChildInWindow(child Widgetter, whichWindow TextWindowType, xpos, ypos int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.GtkTextWindowType // out
	var _arg3 C.gint              // out
	var _arg4 C.gint              // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.GtkTextWindowType(whichWindow)
	_arg3 = C.gint(xpos)
	_arg4 = C.gint(ypos)

	C.gtk_text_view_add_child_in_window(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(whichWindow)
	runtime.KeepAlive(xpos)
	runtime.KeepAlive(ypos)
}

// BackwardDisplayLine moves the given iter backward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter was moved and is not on the end iterator.
//
func (textView *TextView) BackwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardDisplayLineStart moves the given iter backward to the next display
// line start. A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters. Display lines
// are created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter was moved and is not on the end iterator.
//
func (textView *TextView) BackwardDisplayLineStart(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferToWindowCoords converts coordinate (buffer_x, buffer_y) to coordinates
// for the window win, and stores the result in (window_x, window_y).
//
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
//
// The function takes the following parameters:
//
//    - win except GTK_TEXT_WINDOW_PRIVATE.
//    - bufferX: buffer x coordinate.
//    - bufferY: buffer y coordinate.
//
// The function returns the following values:
//
//    - windowX (optional): window x coordinate return location or NULL.
//    - windowY (optional): window y coordinate return location or NULL.
//
func (textView *TextView) BufferToWindowCoords(win TextWindowType, bufferX, bufferY int) (windowX, windowY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.gint              // out
	var _arg3 C.gint              // out
	var _arg4 C.gint              // in
	var _arg5 C.gint              // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = C.gint(bufferX)
	_arg3 = C.gint(bufferY)

	C.gtk_text_view_buffer_to_window_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)
	runtime.KeepAlive(bufferX)
	runtime.KeepAlive(bufferY)

	var _windowX int // out
	var _windowY int // out

	_windowX = int(_arg4)
	_windowY = int(_arg5)

	return _windowX, _windowY
}

// ForwardDisplayLine moves the given iter forward by one display (wrapped)
// line. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter was moved and is not on the end iterator.
//
func (textView *TextView) ForwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardDisplayLineEnd moves the given iter forward to the next display line
// end. A display line is different from a paragraph. Paragraphs are separated
// by newlines or other paragraph separator characters. Display lines are
// created by line-wrapping a paragraph. If wrapping is turned off, display
// lines and paragraphs will be the same. Display lines are divided differently
// for each view, since they depend on the view’s width; paragraphs are the same
// in all views, since they depend on the contents of the TextBuffer.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter was moved and is not on the end iterator.
//
func (textView *TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
// gtk_text_view_set_accepts_tab().
//
// The function returns the following values:
//
//    - ok: TRUE if pressing the Tab key inserts a tab character, FALSE if
//      pressing the Tab key moves the keyboard focus.
//
func (textView *TextView) AcceptsTab() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_accepts_tab(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BorderWindowSize gets the width of the specified border window. See
// gtk_text_view_set_border_window_size().
//
// The function takes the following parameters:
//
//    - typ: window to return size from.
//
// The function returns the following values:
//
//    - gint: width of window.
//
func (textView *TextView) BorderWindowSize(typ TextWindowType) int {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _cret C.gint              // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(typ)

	_cret = C.gtk_text_view_get_border_window_size(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(typ)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// BottomMargin gets the bottom margin for text in the text_view.
//
// The function returns the following values:
//
//    - gint: bottom margin in pixels.
//
func (textView *TextView) BottomMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_bottom_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Buffer returns the TextBuffer being displayed by this text view. The
// reference count on the buffer is not incremented; the caller of this function
// won’t own a new reference.
//
// The function returns the following values:
//
//    - textBuffer: TextBuffer.
//
func (textView *TextView) Buffer() *TextBuffer {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_buffer(_arg0)
	runtime.KeepAlive(textView)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _textBuffer
}

// CursorLocations: given an iter within a text layout, determine the positions
// of the strong and weak cursors if the insertion point is at that iterator.
// The position of each cursor is stored as a zero-width rectangle. The strong
// cursor location is the location where characters of the directionality equal
// to the base direction of the paragraph are inserted. The weak cursor location
// is the location where characters of the directionality opposite to the base
// direction of the paragraph are inserted.
//
// If iter is NULL, the actual cursor position is used.
//
// Note that if iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations will
// be adjusted to account for the preedit cursor’s offset within the preedit
// sequence.
//
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
//
// The function takes the following parameters:
//
//    - iter (optional): TextIter.
//
// The function returns the following values:
//
//    - strong (optional): location to store the strong cursor position (may be
//      NULL).
//    - weak (optional): location to store the weak cursor position (may be
//      NULL).
//
func (textView *TextView) CursorLocations(iter *TextIter) (strong, weak *gdk.Rectangle) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in
	var _arg3 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if iter != nil {
		_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	C.gtk_text_view_get_cursor_locations(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _strong *gdk.Rectangle // out
	var _weak *gdk.Rectangle   // out

	_strong = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_weak = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _strong, _weak
}

// CursorVisible: find out whether the cursor should be displayed.
//
// The function returns the following values:
//
//    - ok: whether the insertion mark is visible.
//
func (textView *TextView) CursorVisible() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_cursor_visible(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultAttributes obtains a copy of the default text attributes. These are
// the attributes used for text unless a tag overrides them. You’d typically
// pass the default attributes in to gtk_text_iter_get_attributes() in order to
// get the attributes in effect at a given text position.
//
// The return value is a copy owned by the caller of this function, and should
// be freed with gtk_text_attributes_unref().
//
// The function returns the following values:
//
//    - textAttributes: new TextAttributes.
//
func (textView *TextView) DefaultAttributes() *TextAttributes {
	var _arg0 *C.GtkTextView       // out
	var _cret *C.GtkTextAttributes // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_default_attributes(_arg0)
	runtime.KeepAlive(textView)

	var _textAttributes *TextAttributes // out

	_textAttributes = (*TextAttributes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_textAttributes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_text_attributes_unref((*C.GtkTextAttributes)(intern.C))
		},
	)

	return _textAttributes
}

// Editable returns the default editability of the TextView. Tags in the buffer
// may override this setting for some ranges of text.
//
// The function returns the following values:
//
//    - ok: whether text is editable by default.
//
func (textView *TextView) Editable() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_editable(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HAdjustment gets the horizontal-scrolling Adjustment.
//
// Deprecated: Use gtk_scrollable_get_hadjustment().
//
// The function returns the following values:
//
//    - adjustment: pointer to the horizontal Adjustment.
//
func (textView *TextView) HAdjustment() *Adjustment {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_hadjustment(_arg0)
	runtime.KeepAlive(textView)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// Indent gets the default indentation of paragraphs in text_view. Tags in the
// view’s buffer may override the default. The indentation may be negative.
//
// The function returns the following values:
//
//    - gint: number of pixels of indentation.
//
func (textView *TextView) Indent() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_indent(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InputHints gets the value of the TextView:input-hints property.
//
// The function returns the following values:
//
func (textView *TextView) InputHints() InputHints {
	var _arg0 *C.GtkTextView  // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_input_hints(_arg0)
	runtime.KeepAlive(textView)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose gets the value of the TextView:input-purpose property.
//
// The function returns the following values:
//
func (textView *TextView) InputPurpose() InputPurpose {
	var _arg0 *C.GtkTextView    // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_input_purpose(_arg0)
	runtime.KeepAlive(textView)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// IterAtLocation retrieves the iterator at buffer coordinates x and y. Buffer
// coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you have
// to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
//
// The function takes the following parameters:
//
//    - x position, in buffer coordinates.
//    - y position, in buffer coordinates.
//
// The function returns the following values:
//
//    - iter: TextIter.
//    - ok: TRUE if the position is over text.
//
func (textView *TextView) IterAtLocation(x, y int) (*TextIter, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg2 = C.gint(x)
	_arg3 = C.gint(y)

	_cret = C.gtk_text_view_get_iter_at_location(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates x and y. Buffer coordinates are coordinates for the entire
// buffer, not just the currently-displayed portion. If you have coordinates
// from an event, you have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
//
// Note that this is different from gtk_text_view_get_iter_at_location(), which
// returns cursor locations, i.e. positions between characters.
//
// The function takes the following parameters:
//
//    - x position, in buffer coordinates.
//    - y position, in buffer coordinates.
//
// The function returns the following values:
//
//    - iter: TextIter.
//    - trailing (optional): if non-NULL, location to store an integer indicating
//      where in the grapheme the user clicked. It will either be zero, or the
//      number of characters in the grapheme. 0 represents the trailing edge of
//      the grapheme.
//    - ok: TRUE if the position is over text.
//
func (textView *TextView) IterAtPosition(x, y int) (*TextIter, int, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.gint         // in
	var _arg3 C.gint         // out
	var _arg4 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg3 = C.gint(x)
	_arg4 = C.gint(y)

	_cret = C.gtk_text_view_get_iter_at_position(_arg0, &_arg1, &_arg2, _arg3, _arg4)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _iter *TextIter // out
	var _trailing int   // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_trailing = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _trailing, _ok
}

// IterLocation gets a rectangle which roughly contains the character at iter.
// The rectangle position is in buffer coordinates; use
// gtk_text_view_buffer_to_window_coords() to convert these coordinates to
// coordinates for one of the windows in the text view.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//
// The function returns the following values:
//
//    - location bounds of the character at iter.
//
func (textView *TextView) IterLocation(iter *TextIter) *gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_text_view_get_iter_location(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _location *gdk.Rectangle // out

	_location = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _location
}

// Justification gets the default justification of paragraphs in text_view. Tags
// in the buffer may override the default.
//
// The function returns the following values:
//
//    - justification: default justification.
//
func (textView *TextView) Justification() Justification {
	var _arg0 *C.GtkTextView     // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_justification(_arg0)
	runtime.KeepAlive(textView)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

// LeftMargin gets the default left margin size of paragraphs in the text_view.
// Tags in the buffer may override the default.
//
// The function returns the following values:
//
//    - gint: left margin in pixels.
//
func (textView *TextView) LeftMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_left_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineAtY gets the TextIter at the start of the line containing the coordinate
// y. y is in buffer coordinates, convert from window coordinates with
// gtk_text_view_window_to_buffer_coords(). If non-NULL, line_top will be filled
// with the coordinate of the top edge of the line.
//
// The function takes the following parameters:
//
//    - y coordinate.
//
// The function returns the following values:
//
//    - targetIter: TextIter.
//    - lineTop: return location for top coordinate of the line.
//
func (textView *TextView) LineAtY(y int) (*TextIter, int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.gint         // out
	var _arg3 C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg2 = C.gint(y)

	C.gtk_text_view_get_line_at_y(_arg0, &_arg1, _arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(y)

	var _targetIter *TextIter // out
	var _lineTop int          // out

	_targetIter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_lineTop = int(_arg3)

	return _targetIter, _lineTop
}

// LineYrange gets the y coordinate of the top of the line containing iter, and
// the height of the line. The coordinate is a buffer coordinate; convert to
// window coordinates with gtk_text_view_buffer_to_window_coords().
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//
// The function returns the following values:
//
//    - y: return location for a y coordinate.
//    - height: return location for a height.
//
func (textView *TextView) LineYrange(iter *TextIter) (y, height int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gint         // in
	var _arg3 C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _y int      // out
	var _height int // out

	_y = int(_arg2)
	_height = int(_arg3)

	return _y, _height
}

// Monospace gets the value of the TextView:monospace property.
//
// The function returns the following values:
//
//    - ok: TRUE if monospace fonts are desired.
//
func (textView *TextView) Monospace() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_monospace(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Overwrite returns whether the TextView is in overwrite mode or not.
//
// The function returns the following values:
//
//    - ok: whether text_view is in overwrite mode or not.
//
func (textView *TextView) Overwrite() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_overwrite(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PixelsAboveLines gets the default number of pixels to put above paragraphs.
// Adding this function with gtk_text_view_get_pixels_below_lines() is equal to
// the line space between each paragraph.
//
// The function returns the following values:
//
//    - gint: default number of pixels above paragraphs.
//
func (textView *TextView) PixelsAboveLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelsBelowLines gets the value set by
// gtk_text_view_set_pixels_below_lines().
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk_text_view_get_pixels_above_lines().
//
// The function returns the following values:
//
//    - gint: default number of blank pixels below paragraphs.
//
func (textView *TextView) PixelsBelowLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelsInsideWrap gets the value set by
// gtk_text_view_set_pixels_inside_wrap().
//
// The function returns the following values:
//
//    - gint: default number of pixels of blank space between wrapped lines.
//
func (textView *TextView) PixelsInsideWrap() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RightMargin gets the default right margin for text in text_view. Tags in the
// buffer may override the default.
//
// The function returns the following values:
//
//    - gint: right margin in pixels.
//
func (textView *TextView) RightMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_right_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Tabs gets the default tabs for text_view. Tags in the buffer may override the
// defaults. The returned array will be NULL if “standard” (8-space) tabs are
// used. Free the return value with pango_tab_array_free().
//
// The function returns the following values:
//
//    - tabArray (optional): copy of default tab array, or NULL if “standard"
//      tabs are used; must be freed with pango_tab_array_free().
//
func (textView *TextView) Tabs() *pango.TabArray {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_tabs(_arg0)
	runtime.KeepAlive(textView)

	var _tabArray *pango.TabArray // out

	if _cret != nil {
		_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tabArray)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
			},
		)
	}

	return _tabArray
}

// TopMargin gets the top margin for text in the text_view.
//
// The function returns the following values:
//
//    - gint: top margin in pixels.
//
func (textView *TextView) TopMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_top_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VAdjustment gets the vertical-scrolling Adjustment.
//
// Deprecated: Use gtk_scrollable_get_vadjustment().
//
// The function returns the following values:
//
//    - adjustment: pointer to the vertical Adjustment.
//
func (textView *TextView) VAdjustment() *Adjustment {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_vadjustment(_arg0)
	runtime.KeepAlive(textView)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// VisibleRect fills visible_rect with the currently-visible region of the
// buffer, in buffer coordinates. Convert to window coordinates with
// gtk_text_view_buffer_to_window_coords().
//
// The function returns the following values:
//
//    - visibleRect: rectangle to fill.
//
func (textView *TextView) VisibleRect() *gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C.gtk_text_view_get_visible_rect(_arg0, &_arg1)
	runtime.KeepAlive(textView)

	var _visibleRect *gdk.Rectangle // out

	_visibleRect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _visibleRect
}

// Window retrieves the Window corresponding to an area of the text view;
// possible windows include the overall widget window, child windows on the
// left, right, top, bottom, and the window that displays the text buffer.
// Windows are NULL and nonexistent if their width or height is 0, and are
// nonexistent before the widget has been realized.
//
// The function takes the following parameters:
//
//    - win: window to get.
//
// The function returns the following values:
//
//    - window (optional) or NULL.
//
func (textView *TextView) Window(win TextWindowType) gdk.Windower {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _cret *C.GdkWindow        // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(win)

	_cret = C.gtk_text_view_get_window(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)

	var _window gdk.Windower // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Windower)
				return ok
			})
			rv, ok := casted.(gdk.Windower)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Windower")
			}
			_window = rv
		}
	}

	return _window
}

// WindowType: usually used to find out which window an event corresponds to.
//
// If you connect to an event signal on text_view, this function should be
// called on event->window to see which window it was.
//
// The function takes the following parameters:
//
//    - window type.
//
// The function returns the following values:
//
//    - textWindowType: window type.
//
func (textView *TextView) WindowType(window gdk.Windower) TextWindowType {
	var _arg0 *C.GtkTextView      // out
	var _arg1 *C.GdkWindow        // out
	var _cret C.GtkTextWindowType // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_text_view_get_window_type(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(window)

	var _textWindowType TextWindowType // out

	_textWindowType = TextWindowType(_cret)

	return _textWindowType
}

// WrapMode gets the line wrapping for the view.
//
// The function returns the following values:
//
//    - wrapMode: line wrap setting.
//
func (textView *TextView) WrapMode() WrapMode {
	var _arg0 *C.GtkTextView // out
	var _cret C.GtkWrapMode  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_wrap_mode(_arg0)
	runtime.KeepAlive(textView)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

// IMContextFilterKeypress: allow the TextView input method to internally handle
// key press and release events. If this function returns TRUE, then no further
// processing should be done for this key event. See
// gtk_im_context_filter_keypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the TextView.
//
//    static gboolean
//    gtk_foo_bar_key_press_event (GtkWidget   *widget,
//                                 GdkEventKey *event)
//    {
//      guint keyval;
//
//      gdk_event_get_keyval ((GdkEvent*)event, &keyval);
//
//      if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//        {
//          if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//            return TRUE;
//        }
//
//      // Do some stuff
//
//      return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//    }.
//
// The function takes the following parameters:
//
//    - event: key event.
//
// The function returns the following values:
//
//    - ok: TRUE if the input method handled the key event.
//
func (textView *TextView) IMContextFilterKeypress(event *gdk.EventKey) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GdkEventKey // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GdkEventKey)(gextras.StructNative(unsafe.Pointer(event)))

	_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveChild updates the position of a child, as for
// gtk_text_view_add_child_in_window().
//
// The function takes the following parameters:
//
//    - child widget already added to the text view.
//    - xpos: new X position in window coordinates.
//    - ypos: new Y position in window coordinates.
//
func (textView *TextView) MoveChild(child Widgetter, xpos, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gint         // out
	var _arg3 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.gint(xpos)
	_arg3 = C.gint(ypos)

	C.gtk_text_view_move_child(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(xpos)
	runtime.KeepAlive(ypos)
}

// MoveMarkOnscreen moves a mark within the buffer so that it's located within
// the currently-visible text area.
//
// The function takes the following parameters:
//
//    - mark: TextMark.
//
// The function returns the following values:
//
//    - ok: TRUE if the mark moved (wasn’t already onscreen).
//
func (textView *TextView) MoveMarkOnscreen(mark *TextMark) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position. If count is positive, then the new
// strong cursor position will be count positions to the right of the old cursor
// position. If count is negative then the new strong cursor position will be
// count positions to the left of the old cursor position.
//
// In the presence of bi-directional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and there
// may be jumps when the cursor is moved off of the end of a run.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//    - count: number of characters to move (negative moves left, positive moves
//      right).
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not on the end iterator.
//
func (textView *TextView) MoveVisually(iter *TextIter, count int) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gint         // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.gint(count)

	_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceCursorOnscreen moves the cursor to the currently visible region of the
// buffer, it it isn’t there already.
//
// The function returns the following values:
//
//    - ok: TRUE if the cursor had to be moved.
//
func (textView *TextView) PlaceCursorOnscreen() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResetCursorBlink ensures that the cursor is shown (i.e. not in an 'off' blink
// interval) and resets the time that it will stay blinking (or visible, in case
// blinking is disabled).
//
// This function should be called in response to user input (e.g. from derived
// classes that override the textview's Widget::key-press-event handler).
func (textView *TextView) ResetCursorBlink() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C.gtk_text_view_reset_cursor_blink(_arg0)
	runtime.KeepAlive(textView)
}

// ResetIMContext: reset the input method context of the text view if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (textView *TextView) ResetIMContext() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C.gtk_text_view_reset_im_context(_arg0)
	runtime.KeepAlive(textView)
}

// ScrollMarkOnscreen scrolls text_view the minimum distance such that mark is
// contained within the visible area of the widget.
//
// The function takes the following parameters:
//
//    - mark in the buffer for text_view.
//
func (textView *TextView) ScrollMarkOnscreen(mark *TextMark) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)
}

// ScrollToIter scrolls text_view so that iter is on the screen in the position
// indicated by xalign and yalign. An alignment of 0.0 indicates left or top,
// 1.0 indicates right or bottom, 0.5 means center. If use_align is FALSE, the
// text scrolls the minimal distance to get the mark onscreen, possibly not
// scrolling at all. The effective screen for purposes of this function is
// reduced by a margin of size within_margin.
//
// Note that this function uses the currently-computed height of the lines in
// the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using gtk_text_view_scroll_to_mark()
// which saves a point to be scrolled to after line validation.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//    - withinMargin: margin as a [0.0,0.5) fraction of screen size.
//    - useAlign: whether to use alignment arguments (if FALSE, just get the mark
//      onscreen).
//    - xalign: horizontal alignment of mark within visible area.
//    - yalign: vertical alignment of mark within visible area.
//
// The function returns the following values:
//
//    - ok: TRUE if scrolling occurred.
//
func (textView *TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign, yalign float64) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.gdouble      // out
	var _arg3 C.gboolean     // out
	var _arg4 C.gdouble      // out
	var _arg5 C.gdouble      // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.gdouble(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.gdouble(xalign)
	_arg5 = C.gdouble(yalign)

	_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(withinMargin)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToMark scrolls text_view so that mark is on the screen in the position
// indicated by xalign and yalign. An alignment of 0.0 indicates left or top,
// 1.0 indicates right or bottom, 0.5 means center. If use_align is FALSE, the
// text scrolls the minimal distance to get the mark onscreen, possibly not
// scrolling at all. The effective screen for purposes of this function is
// reduced by a margin of size within_margin.
//
// The function takes the following parameters:
//
//    - mark: TextMark.
//    - withinMargin: margin as a [0.0,0.5) fraction of screen size.
//    - useAlign: whether to use alignment arguments (if FALSE, just get the mark
//      onscreen).
//    - xalign: horizontal alignment of mark within visible area.
//    - yalign: vertical alignment of mark within visible area.
//
func (textView *TextView) ScrollToMark(mark *TextMark, withinMargin float64, useAlign bool, xalign, yalign float64) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _arg2 C.gdouble      // out
	var _arg3 C.gboolean     // out
	var _arg4 C.gdouble      // out
	var _arg5 C.gdouble      // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = C.gdouble(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.gdouble(xalign)
	_arg5 = C.gdouble(yalign)

	C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(withinMargin)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
}

// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed. If accepts_tab is TRUE, a tab character is inserted. If accepts_tab
// is FALSE the keyboard focus is moved to the next widget in the focus chain.
//
// The function takes the following parameters:
//
//    - acceptsTab: TRUE if pressing the Tab key should insert a tab character,
//      FALSE, if pressing the Tab key should move the keyboard focus.
//
func (textView *TextView) SetAcceptsTab(acceptsTab bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if acceptsTab {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(acceptsTab)
}

// SetBorderWindowSize sets the width of GTK_TEXT_WINDOW_LEFT or
// GTK_TEXT_WINDOW_RIGHT, or the height of GTK_TEXT_WINDOW_TOP or
// GTK_TEXT_WINDOW_BOTTOM. Automatically destroys the corresponding window if
// the size is set to 0, and creates the window if the size is set to non-zero.
// This function can only be used for the “border windows”, and it won’t work
// with GTK_TEXT_WINDOW_WIDGET, GTK_TEXT_WINDOW_TEXT, or
// GTK_TEXT_WINDOW_PRIVATE.
//
// The function takes the following parameters:
//
//    - typ: window to affect.
//    - size: width or height of the window.
//
func (textView *TextView) SetBorderWindowSize(typ TextWindowType, size int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.gint              // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(typ)
	_arg2 = C.gint(size)

	C.gtk_text_view_set_border_window_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(size)
}

// SetBottomMargin sets the bottom margin for text in text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//    - bottomMargin: bottom margin in pixels.
//
func (textView *TextView) SetBottomMargin(bottomMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.gint(bottomMargin)

	C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(bottomMargin)
}

// SetBuffer sets buffer as the buffer being displayed by text_view. The
// previous buffer displayed by the text view is unreferenced, and a reference
// is added to buffer. If you owned a reference to buffer before passing it to
// this function, you must remove that reference yourself; TextView will not
// “adopt” it.
//
// The function takes the following parameters:
//
//    - buffer (optional): TextBuffer.
//
func (textView *TextView) SetBuffer(buffer *TextBuffer) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if buffer != nil {
		_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	}

	C.gtk_text_view_set_buffer(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(buffer)
}

// SetCursorVisible toggles whether the insertion point should be displayed. A
// buffer with no editable text probably shouldn’t have a visible cursor, so you
// may want to turn the cursor off.
//
// Note that this property may be overridden by the
// Settings:gtk-keynave-use-caret settings.
//
// The function takes the following parameters:
//
//    - setting: whether to show the insertion cursor.
//
func (textView *TextView) SetCursorVisible(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(setting)
}

// SetEditable sets the default editability of the TextView. You can override
// this default setting with tags in the buffer, using the “editable” attribute
// of tags.
//
// The function takes the following parameters:
//
//    - setting: whether it’s editable.
//
func (textView *TextView) SetEditable(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_editable(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(setting)
}

// SetIndent sets the default indentation for paragraphs in text_view. Tags in
// the buffer may override the default.
//
// The function takes the following parameters:
//
//    - indent: indentation in pixels.
//
func (textView *TextView) SetIndent(indent int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.gint(indent)

	C.gtk_text_view_set_indent(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(indent)
}

// SetInputHints sets the TextView:input-hints property, which allows input
// methods to fine-tune their behaviour.
//
// The function takes the following parameters:
//
//    - hints: hints.
//
func (textView *TextView) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkTextView  // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkInputHints(hints)

	C.gtk_text_view_set_input_hints(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(hints)
}

// SetInputPurpose sets the TextView:input-purpose property which can be used by
// on-screen keyboards and other input methods to adjust their behaviour.
//
// The function takes the following parameters:
//
//    - purpose: purpose.
//
func (textView *TextView) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkTextView    // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkInputPurpose(purpose)

	C.gtk_text_view_set_input_purpose(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(purpose)
}

// SetJustification sets the default justification of text in text_view. Tags in
// the view’s buffer may override the default.
//
// The function takes the following parameters:
//
//    - justification: justification.
//
func (textView *TextView) SetJustification(justification Justification) {
	var _arg0 *C.GtkTextView     // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkJustification(justification)

	C.gtk_text_view_set_justification(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(justification)
}

// SetLeftMargin sets the default left margin for text in text_view. Tags in the
// buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//    - leftMargin: left margin in pixels.
//
func (textView *TextView) SetLeftMargin(leftMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.gint(leftMargin)

	C.gtk_text_view_set_left_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(leftMargin)
}

// SetMonospace sets the TextView:monospace property, which indicates that the
// text view should use monospace fonts.
//
// The function takes the following parameters:
//
//    - monospace: TRUE to request monospace styling.
//
func (textView *TextView) SetMonospace(monospace bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if monospace {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_monospace(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(monospace)
}

// SetOverwrite changes the TextView overwrite mode.
//
// The function takes the following parameters:
//
//    - overwrite: TRUE to turn on overwrite mode, FALSE to turn it off.
//
func (textView *TextView) SetOverwrite(overwrite bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_overwrite(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(overwrite)
}

// SetPixelsAboveLines sets the default number of blank pixels above paragraphs
// in text_view. Tags in the buffer for text_view may override the defaults.
//
// The function takes the following parameters:
//
//    - pixelsAboveLines pixels above paragraphs.
//
func (textView *TextView) SetPixelsAboveLines(pixelsAboveLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.gint(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsAboveLines)
}

// SetPixelsBelowLines sets the default number of pixels of blank space to put
// below paragraphs in text_view. May be overridden by tags applied to
// text_view’s buffer.
//
// The function takes the following parameters:
//
//    - pixelsBelowLines pixels below paragraphs.
//
func (textView *TextView) SetPixelsBelowLines(pixelsBelowLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.gint(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsBelowLines)
}

// SetPixelsInsideWrap sets the default number of pixels of blank space to leave
// between display/wrapped lines within a paragraph. May be overridden by tags
// in text_view’s buffer.
//
// The function takes the following parameters:
//
//    - pixelsInsideWrap: default number of pixels between wrapped lines.
//
func (textView *TextView) SetPixelsInsideWrap(pixelsInsideWrap int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.gint(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsInsideWrap)
}

// SetRightMargin sets the default right margin for text in the text view. Tags
// in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//    - rightMargin: right margin in pixels.
//
func (textView *TextView) SetRightMargin(rightMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.gint(rightMargin)

	C.gtk_text_view_set_right_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(rightMargin)
}

// SetTabs sets the default tab stops for paragraphs in text_view. Tags in the
// buffer may override the default.
//
// The function takes the following parameters:
//
//    - tabs as a TabArray.
//
func (textView *TextView) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabs)))

	C.gtk_text_view_set_tabs(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(tabs)
}

// SetTopMargin sets the top margin for text in text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//    - topMargin: top margin in pixels.
//
func (textView *TextView) SetTopMargin(topMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.gint(topMargin)

	C.gtk_text_view_set_top_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(topMargin)
}

// SetWrapMode sets the line wrapping for the view.
//
// The function takes the following parameters:
//
//    - wrapMode: WrapMode.
//
func (textView *TextView) SetWrapMode(wrapMode WrapMode) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkWrapMode  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkWrapMode(wrapMode)

	C.gtk_text_view_set_wrap_mode(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(wrapMode)
}

// StartsDisplayLine determines whether iter is at the start of a display line.
// See gtk_text_view_forward_display_line() for an explanation of display lines
// vs. paragraphs.
//
// The function takes the following parameters:
//
//    - iter: TextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if iter begins a wrapped line.
//
func (textView *TextView) StartsDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WindowToBufferCoords converts coordinates on the window identified by win to
// buffer coordinates, storing the result in (buffer_x,buffer_y).
//
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
//
// The function takes the following parameters:
//
//    - win except GTK_TEXT_WINDOW_PRIVATE.
//    - windowX: window x coordinate.
//    - windowY: window y coordinate.
//
// The function returns the following values:
//
//    - bufferX (optional): buffer x coordinate return location or NULL.
//    - bufferY (optional): buffer y coordinate return location or NULL.
//
func (textView *TextView) WindowToBufferCoords(win TextWindowType, windowX, windowY int) (bufferX, bufferY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.gint              // out
	var _arg3 C.gint              // out
	var _arg4 C.gint              // in
	var _arg5 C.gint              // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = C.gint(windowX)
	_arg3 = C.gint(windowY)

	C.gtk_text_view_window_to_buffer_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)
	runtime.KeepAlive(windowX)
	runtime.KeepAlive(windowY)

	var _bufferX int // out
	var _bufferY int // out

	_bufferX = int(_arg4)
	_bufferY = int(_arg5)

	return _bufferX, _bufferY
}

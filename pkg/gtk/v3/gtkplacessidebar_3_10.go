// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// NewPlacesSidebar creates a new PlacesSidebar widget.
//
// The application should connect to at least the PlacesSidebar::open-location
// signal to be notified when the user makes a selection in the sidebar.
//
// The function returns the following values:
//
//    - placesSidebar: newly created PlacesSidebar.
//
func NewPlacesSidebar() *PlacesSidebar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_places_sidebar_new()

	var _placesSidebar *PlacesSidebar // out

	_placesSidebar = wrapPlacesSidebar(coreglib.Take(unsafe.Pointer(_cret)))

	return _placesSidebar
}

// AddShortcut applications may want to present some folders in the places
// sidebar if they could be immediately useful to users. For example, a drawing
// program could add a “/usr/share/clipart” location when the sidebar is being
// used in an “Insert Clipart” dialog box.
//
// This function adds the specified location to a special place for immutable
// shortcuts. The shortcuts are application-specific; they are not shared across
// applications, and they are not persistent. If this function is called
// multiple times with different locations, then they are added to the sidebar’s
// list in the same order as the function is called.
//
// The function takes the following parameters:
//
//    - location to add as an application-specific shortcut.
//
func (sidebar *PlacesSidebar) AddShortcut(location gio.Filer) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 *C.GFile            // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(location).Native()))

	C.gtk_places_sidebar_add_shortcut(_arg0, _arg1)
	runtime.KeepAlive(sidebar)
	runtime.KeepAlive(location)
}

// Location gets the currently selected location in the sidebar. This can be
// NULL when nothing is selected, for example, when
// gtk_places_sidebar_set_location() has been called with a location that is not
// among the sidebar’s list of places to show.
//
// You can use this function to get the selection in the sidebar. Also, if you
// connect to the PlacesSidebar::populate-popup signal, you can use this
// function to get the location that is being referred to during the callbacks
// for your menu items.
//
// The function returns the following values:
//
//    - file (optional) with the selected location, or NULL if nothing is
//      visually selected.
//
func (sidebar *PlacesSidebar) Location() *gio.File {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret *C.GFile            // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))

	_cret = C.gtk_places_sidebar_get_location(_arg0)
	runtime.KeepAlive(sidebar)

	var _file *gio.File // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_file = &gio.File{
				Object: obj,
			}
		}
	}

	return _file
}

// NthBookmark: this function queries the bookmarks added by the user to the
// places sidebar, and returns one of them. This function is used by FileChooser
// to implement the “Alt-1”, “Alt-2”, etc. shortcuts, which activate the
// cooresponding bookmark.
//
// The function takes the following parameters:
//
//    - n: index of the bookmark to query.
//
// The function returns the following values:
//
//    - file (optional): bookmark specified by the index n, or NULL if no such
//      index exist. Note that the indices start at 0, even though the file
//      chooser starts them with the keyboard shortcut "Alt-1".
//
func (sidebar *PlacesSidebar) NthBookmark(n int) *gio.File {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gint              // out
	var _cret *C.GFile            // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))
	_arg1 = C.gint(n)

	_cret = C.gtk_places_sidebar_get_nth_bookmark(_arg0, _arg1)
	runtime.KeepAlive(sidebar)
	runtime.KeepAlive(n)

	var _file *gio.File // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_file = &gio.File{
				Object: obj,
			}
		}
	}

	return _file
}

// OpenFlags gets the open flags.
//
// The function returns the following values:
//
//    - placesOpenFlags of sidebar.
//
func (sidebar *PlacesSidebar) OpenFlags() PlacesOpenFlags {
	var _arg0 *C.GtkPlacesSidebar  // out
	var _cret C.GtkPlacesOpenFlags // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))

	_cret = C.gtk_places_sidebar_get_open_flags(_arg0)
	runtime.KeepAlive(sidebar)

	var _placesOpenFlags PlacesOpenFlags // out

	_placesOpenFlags = PlacesOpenFlags(_cret)

	return _placesOpenFlags
}

// ShowDesktop returns the value previously set with
// gtk_places_sidebar_set_show_desktop().
//
// The function returns the following values:
//
//    - ok: TRUE if the sidebar will display a builtin shortcut to the desktop
//      folder.
//
func (sidebar *PlacesSidebar) ShowDesktop() bool {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))

	_cret = C.gtk_places_sidebar_get_show_desktop(_arg0)
	runtime.KeepAlive(sidebar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListShortcuts gets the list of shortcuts.
//
// The function returns the following values:
//
//    - sList: A List of #GFile of the locations that have been added as
//      application-specific shortcuts with gtk_places_sidebar_add_shortcut(). To
//      free this list, you can use
//
//         g_slist_free_full (list, (GDestroyNotify) g_object_unref);.
//
func (sidebar *PlacesSidebar) ListShortcuts() []*gio.File {
	var _arg0 *C.GtkPlacesSidebar // out
	var _cret *C.GSList           // in

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))

	_cret = C.gtk_places_sidebar_list_shortcuts(_arg0)
	runtime.KeepAlive(sidebar)

	var _sList []*gio.File // out

	_sList = make([]*gio.File, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GFile)(v)
		var dst *gio.File // out
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(src))
			dst = &gio.File{
				Object: obj,
			}
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// RemoveShortcut removes an application-specific shortcut that has been
// previously been inserted with gtk_places_sidebar_add_shortcut(). If the
// location is not a shortcut in the sidebar, then nothing is done.
//
// The function takes the following parameters:
//
//    - location to remove.
//
func (sidebar *PlacesSidebar) RemoveShortcut(location gio.Filer) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 *C.GFile            // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(location).Native()))

	C.gtk_places_sidebar_remove_shortcut(_arg0, _arg1)
	runtime.KeepAlive(sidebar)
	runtime.KeepAlive(location)
}

// SetLocation sets the location that is being shown in the widgets surrounding
// the sidebar, for example, in a folder view in a file manager. In turn, the
// sidebar will highlight that location if it is being shown in the list of
// places, or it will unhighlight everything if the location is not among the
// places in the list.
//
// The function takes the following parameters:
//
//    - location (optional) to select, or NULL for no current path.
//
func (sidebar *PlacesSidebar) SetLocation(location gio.Filer) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 *C.GFile            // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))
	if location != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(location).Native()))
	}

	C.gtk_places_sidebar_set_location(_arg0, _arg1)
	runtime.KeepAlive(sidebar)
	runtime.KeepAlive(location)
}

// SetOpenFlags sets the way in which the calling application can open new
// locations from the places sidebar. For example, some applications only open
// locations “directly” into their main view, while others may support opening
// locations in a new notebook tab or a new window.
//
// This function is used to tell the places sidebar about the ways in which the
// application can open new locations, so that the sidebar can display (or not)
// the “Open in new tab” and “Open in new window” menu items as appropriate.
//
// When the PlacesSidebar::open-location signal is emitted, its flags argument
// will be set to one of the flags that was passed in
// gtk_places_sidebar_set_open_flags().
//
// Passing 0 for flags will cause K_PLACES_OPEN_NORMAL to always be sent to
// callbacks for the “open-location” signal.
//
// The function takes the following parameters:
//
//    - flags: bitmask of modes in which the calling application can open
//      locations.
//
func (sidebar *PlacesSidebar) SetOpenFlags(flags PlacesOpenFlags) {
	var _arg0 *C.GtkPlacesSidebar  // out
	var _arg1 C.GtkPlacesOpenFlags // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))
	_arg1 = C.GtkPlacesOpenFlags(flags)

	C.gtk_places_sidebar_set_open_flags(_arg0, _arg1)
	runtime.KeepAlive(sidebar)
	runtime.KeepAlive(flags)
}

// SetShowConnectToServer sets whether the sidebar should show an item for
// connecting to a network server; this is off by default. An application may
// want to turn this on if it implements a way for the user to connect to
// network servers directly.
//
// If you enable this, you should connect to the
// PlacesSidebar::show-connect-to-server signal.
//
// Deprecated: It is recommended to group this functionality with the drives and
// network location under the new 'Other Location' item.
//
// The function takes the following parameters:
//
//    - showConnectToServer: whether to show an item for the Connect to Server
//      command.
//
func (sidebar *PlacesSidebar) SetShowConnectToServer(showConnectToServer bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))
	if showConnectToServer {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_connect_to_server(_arg0, _arg1)
	runtime.KeepAlive(sidebar)
	runtime.KeepAlive(showConnectToServer)
}

// SetShowDesktop sets whether the sidebar should show an item for the Desktop
// folder. The default value for this option is determined by the desktop
// environment and the user’s configuration, but this function can be used to
// override it on a per-application basis.
//
// The function takes the following parameters:
//
//    - showDesktop: whether to show an item for the Desktop folder.
//
func (sidebar *PlacesSidebar) SetShowDesktop(showDesktop bool) {
	var _arg0 *C.GtkPlacesSidebar // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPlacesSidebar)(unsafe.Pointer(coreglib.InternObject(sidebar).Native()))
	if showDesktop {
		_arg1 = C.TRUE
	}

	C.gtk_places_sidebar_set_show_desktop(_arg0, _arg1)
	runtime.KeepAlive(sidebar)
	runtime.KeepAlive(showDesktop)
}

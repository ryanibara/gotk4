// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern gchar* _gotk4_gtk3_ContainerClass_composite_name(void*, void*);
// extern void _gotk4_gtk3_Callback(void*, gpointer);
// extern void _gotk4_gtk3_ContainerClass_add(void*, void*);
// extern void _gotk4_gtk3_ContainerClass_check_resize(void*);
// extern void _gotk4_gtk3_ContainerClass_remove(void*, void*);
// extern void _gotk4_gtk3_ContainerClass_set_focus_child(void*, void*);
// extern void _gotk4_gtk3_Container_ConnectAdd(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Container_ConnectCheckResize(gpointer, guintptr);
// extern void _gotk4_gtk3_Container_ConnectRemove(gpointer, void*, guintptr);
// extern void _gotk4_gtk3_Container_ConnectSetFocusChild(gpointer, void*, guintptr);
// extern void* _gotk4_gtk3_ContainerClass_get_path_for_child(void*, void*);
import "C"

// GTypeContainer returns the GType for the type Container.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeContainer() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "Container").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalContainer)
	return gtype
}

// ContainerOverrider contains methods that are overridable.
type ContainerOverrider interface {
	// Add adds widget to container. Typically used for simple containers such
	// as Window, Frame, or Button; for more complicated layout containers such
	// as Box or Grid, this function will pick default packing parameters that
	// may not be correct. So consider functions such as gtk_box_pack_start()
	// and gtk_grid_attach() as an alternative to gtk_container_add() in those
	// cases. A widget may be added to only one container at a time; you can’t
	// place the same widget inside two different containers.
	//
	// Note that some containers, such as ScrolledWindow or ListBox, may add
	// intermediate children between the added widget and the container.
	//
	// The function takes the following parameters:
	//
	//    - widget to be placed inside container.
	//
	Add(widget Widgetter)
	CheckResize()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	CompositeName(child Widgetter) string
	// PathForChild returns a newly created widget path representing all the
	// widget hierarchy from the toplevel down to and including child.
	//
	// The function takes the following parameters:
	//
	//    - child of container.
	//
	// The function returns the following values:
	//
	//    - widgetPath: newly created WidgetPath.
	//
	PathForChild(child Widgetter) *WidgetPath
	// Remove removes widget from container. widget must be inside container.
	// Note that container will own a reference to widget, and that this may be
	// the last reference held; so removing a widget from its container can
	// destroy that widget. If you want to use widget again, you need to add a
	// reference to it before removing it from a container, using
	// g_object_ref(). If you don’t want to use widget again it’s usually more
	// efficient to simply destroy it directly using gtk_widget_destroy() since
	// this will remove it from the container and help break any circular
	// reference count cycles.
	//
	// The function takes the following parameters:
	//
	//    - widget: current child of container.
	//
	Remove(widget Widgetter)
	// SetFocusChild: sets, or unsets if child is NULL, the focused child of
	// container.
	//
	// This function emits the GtkContainer::set_focus_child signal of
	// container. Implementations of Container can override the default
	// behaviour by overriding the class closure of this signal.
	//
	// This is function is mostly meant to be used by widgets. Applications can
	// use gtk_widget_grab_focus() to manually set the focus to a specific
	// widget.
	//
	// The function takes the following parameters:
	//
	//    - child (optional) or NULL.
	//
	SetFocusChild(child Widgetter)
}

// Container: GTK+ user interface is constructed by nesting widgets inside
// widgets. Container widgets are the inner nodes in the resulting tree of
// widgets: they contain other widgets. So, for example, you might have a Window
// containing a Frame containing a Label. If you wanted an image instead of a
// textual label inside the frame, you might replace the Label widget with a
// Image widget.
//
// There are two major kinds of container widgets in GTK+. Both are subclasses
// of the abstract GtkContainer base class.
//
// The first type of container widget has a single child widget and derives from
// Bin. These containers are decorators, which add some kind of functionality to
// the child. For example, a Button makes its child into a clickable button; a
// Frame draws a frame around its child and a Window places its child widget
// inside a top-level window.
//
// The second type of container can have more than one child; its purpose is to
// manage layout. This means that these containers assign sizes and positions to
// their children. For example, a HBox arranges its children in a horizontal
// row, and a Grid arranges the widgets it contains in a two-dimensional grid.
//
// For implementations of Container the virtual method ContainerClass.forall()
// is always required, since it's used for drawing and other internal operations
// on the children. If the Container implementation expect to have non internal
// children it's needed to implement both ContainerClass.add() and
// ContainerClass.remove(). If the GtkContainer implementation has internal
// children, they should be added with gtk_widget_set_parent() on init() and
// removed with gtk_widget_unparent() in the WidgetClass.destroy()
// implementation. See more about implementing custom widgets at
// https://wiki.gnome.org/HowDoI/CustomWidgets
//
//
// Height for width geometry management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height).
//
// There are some things to keep in mind when implementing container widgets
// that make use of GTK+’s height for width geometry management system. First,
// it’s important to note that a container must prioritize one of its
// dimensions, that is to say that a widget or container can only have a
// SizeRequestMode that is GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH or
// GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT. However, every widget and container must
// be able to respond to the APIs for both dimensions, i.e. even if a widget has
// a request mode that is height-for-width, it is possible that its parent will
// request its sizes using the width-for-height APIs.
//
// To ensure that everything works properly, here are some guidelines to follow
// when implementing height-for-width (or width-for-height) containers.
//
// Each request mode involves 2 virtual methods. Height-for-width apis run
// through gtk_widget_get_preferred_width() and then through
// gtk_widget_get_preferred_height_for_width(). When handling requests in the
// opposite SizeRequestMode it is important that every widget request at least
// enough space to display all of its content at all times.
//
// When gtk_widget_get_preferred_height() is called on a container that is
// height-for-width, the container must return the height for its minimum width.
// This is easily achieved by simply calling the reverse apis implemented for
// itself as follows:
//
//    static void
//    foo_container_get_preferred_width_for_height (GtkWidget *widget,
//                                                  gint for_height,
//                                                  gint *min_width,
//                                                  gint *nat_width)
//    {
//       if (i_am_in_height_for_width_mode)
//         {
//           GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
//                                                               min_width,
//                                                               nat_width);
//         }
//       else
//         {
//           ... execute the real width-for-height request here based on
//           the required width of the children collectively if the
//           container were to be allocated the said height ...
//         }
//    }
//
// Height for width requests are generally implemented in terms of a virtual
// allocation of widgets in the input orientation. Assuming an height-for-width
// request mode, a container would implement the
// get_preferred_height_for_width() virtual function by first calling
// gtk_widget_get_preferred_width() for each of its children.
//
// For each potential group of children that are lined up horizontally, the
// values returned by gtk_widget_get_preferred_width() should be collected in an
// array of RequestedSize structures. Any child spacing should be removed from
// the input for_width and then the collective size should be allocated using
// the gtk_distribute_natural_allocation() convenience function.
//
// The container will then move on to request the preferred height for each
// child by using gtk_widget_get_preferred_height_for_width() and using the
// sizes stored in the RequestedSize array.
//
// To allocate a height-for-width container, it’s again important to consider
// that a container must prioritize one dimension over the other. So if a
// container is a height-for-width container it must first allocate all widgets
// horizontally using a RequestedSize array and
// gtk_distribute_natural_allocation() and then add any extra space (if and
// where appropriate) for the widget to expand.
//
// After adding all the expand space, the container assumes it was allocated
// sufficient height to fit all of its content. At this time, the container must
// use the total horizontal sizes of each widget to request the height-for-width
// of each of its children and store the requests in a RequestedSize array for
// any widgets that stack vertically (for tabular containers this can be
// generalized into the heights and widths of rows and columns). The vertical
// space must then again be distributed using
// gtk_distribute_natural_allocation() while this time considering the allocated
// height of the widget minus any vertical spacing that the container adds. Then
// vertical expand space should be added where appropriate and available and the
// container should go on to actually allocating the child widgets.
//
// See [GtkWidget’s geometry management section][geometry-management] to learn
// more about implementing height-for-width geometry management for widgets.
//
//
// Child properties
//
// GtkContainer introduces child properties. These are object properties that
// are not specific to either the container or the contained widget, but rather
// to their relation. Typical examples of child properties are the position or
// pack-type of a widget which is contained in a Box.
//
// Use gtk_container_class_install_child_property() to install child properties
// for a container class and gtk_container_class_find_child_property() or
// gtk_container_class_list_child_properties() to get information about existing
// child properties.
//
// To set the value of a child property, use gtk_container_child_set_property(),
// gtk_container_child_set() or gtk_container_child_set_valist(). To obtain the
// value of a child property, use gtk_container_child_get_property(),
// gtk_container_child_get() or gtk_container_child_get_valist(). To emit
// notification about child property changes, use gtk_widget_child_notify().
//
//
// GtkContainer as GtkBuildable
//
// The GtkContainer implementation of the GtkBuildable interface supports a
// <packing> element for children, which can contain multiple <property>
// elements that specify child properties for the child.
//
// Since 2.16, child properties can also be marked as translatable using the
// same “translatable”, “comments” and “context” attributes that are used for
// regular properties.
//
// Since 3.16, containers can have a <focus-chain> element containing multiple
// <widget> elements, one for each child that should be added to the focus
// chain. The ”name” attribute gives the id of the widget.
//
// An example of these properties in UI definitions:
//
//    <object class="GtkBox">
//      <child>
//        <object class="GtkEntry" id="entry1"/>
//        <packing>
//          <property name="pack-type">start</property>
//        </packing>
//      </child>
//      <child>
//        <object class="GtkEntry" id="entry2"/>
//      </child>
//      <focus-chain>
//        <widget name="entry1"/>
//        <widget name="entry2"/>
//      </focus-chain>
//    </object>.
type Container struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Container)(nil)
)

// Containerer describes types inherited from class Container.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Containerer interface {
	coreglib.Objector
	baseContainer() *Container
}

var _ Containerer = (*Container)(nil)

func classInitContainerer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := girepository.MustFind("Gtk", "ContainerClass")

	if _, ok := goval.(interface{ Add(widget Widgetter) }); ok {
		o := pclass.StructFieldOffset("add")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_ContainerClass_add)
	}

	if _, ok := goval.(interface{ CheckResize() }); ok {
		o := pclass.StructFieldOffset("check_resize")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_ContainerClass_check_resize)
	}

	if _, ok := goval.(interface{ CompositeName(child Widgetter) string }); ok {
		o := pclass.StructFieldOffset("composite_name")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_ContainerClass_composite_name)
	}

	if _, ok := goval.(interface {
		PathForChild(child Widgetter) *WidgetPath
	}); ok {
		o := pclass.StructFieldOffset("get_path_for_child")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_ContainerClass_get_path_for_child)
	}

	if _, ok := goval.(interface{ Remove(widget Widgetter) }); ok {
		o := pclass.StructFieldOffset("remove")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_ContainerClass_remove)
	}

	if _, ok := goval.(interface{ SetFocusChild(child Widgetter) }); ok {
		o := pclass.StructFieldOffset("set_focus_child")
		*(*unsafe.Pointer)(unsafe.Add(unsafe.Pointer(gclassPtr), o)) = unsafe.Pointer(C._gotk4_gtk3_ContainerClass_set_focus_child)
	}
}

//export _gotk4_gtk3_ContainerClass_add
func _gotk4_gtk3_ContainerClass_add(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Add(widget Widgetter) })

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	iface.Add(_widget)
}

//export _gotk4_gtk3_ContainerClass_check_resize
func _gotk4_gtk3_ContainerClass_check_resize(arg0 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CheckResize() })

	iface.CheckResize()
}

//export _gotk4_gtk3_ContainerClass_composite_name
func _gotk4_gtk3_ContainerClass_composite_name(arg0 *C.void, arg1 *C.void) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ CompositeName(child Widgetter) string })

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	utf8 := iface.CompositeName(_child)

	cret = (*C.gchar)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

//export _gotk4_gtk3_ContainerClass_get_path_for_child
func _gotk4_gtk3_ContainerClass_get_path_for_child(arg0 *C.void, arg1 *C.void) (cret *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		PathForChild(child Widgetter) *WidgetPath
	})

	var _child Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_child = rv
	}

	widgetPath := iface.PathForChild(_child)

	cret = (*C.void)(gextras.StructNative(unsafe.Pointer(widgetPath)))

	return cret
}

//export _gotk4_gtk3_ContainerClass_remove
func _gotk4_gtk3_ContainerClass_remove(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Remove(widget Widgetter) })

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	iface.Remove(_widget)
}

//export _gotk4_gtk3_ContainerClass_set_focus_child
func _gotk4_gtk3_ContainerClass_set_focus_child(arg0 *C.void, arg1 *C.void) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ SetFocusChild(child Widgetter) })

	var _child Widgetter // out

	if arg1 != nil {
		{
			objptr := unsafe.Pointer(arg1)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_child = rv
		}
	}

	iface.SetFocusChild(_child)
}

func wrapContainer(obj *coreglib.Object) *Container {
	return &Container{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
	}
}

func marshalContainer(p uintptr) (interface{}, error) {
	return wrapContainer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (container *Container) baseContainer() *Container {
	return container
}

// BaseContainer returns the underlying base object.
func BaseContainer(obj Containerer) *Container {
	return obj.baseContainer()
}

//export _gotk4_gtk3_Container_ConnectAdd
func _gotk4_gtk3_Container_ConnectAdd(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

func (container *Container) ConnectAdd(f func(object Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(container, "add", false, unsafe.Pointer(C._gotk4_gtk3_Container_ConnectAdd), f)
}

//export _gotk4_gtk3_Container_ConnectCheckResize
func _gotk4_gtk3_Container_ConnectCheckResize(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

func (container *Container) ConnectCheckResize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(container, "check-resize", false, unsafe.Pointer(C._gotk4_gtk3_Container_ConnectCheckResize), f)
}

//export _gotk4_gtk3_Container_ConnectRemove
func _gotk4_gtk3_Container_ConnectRemove(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

func (container *Container) ConnectRemove(f func(object Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(container, "remove", false, unsafe.Pointer(C._gotk4_gtk3_Container_ConnectRemove), f)
}

//export _gotk4_gtk3_Container_ConnectSetFocusChild
func _gotk4_gtk3_Container_ConnectSetFocusChild(arg0 C.gpointer, arg1 *C.void, arg2 C.guintptr) {
	var f func(object Widgetter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(object Widgetter))
	}

	var _object Widgetter // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_object = rv
	}

	f(_object)
}

func (container *Container) ConnectSetFocusChild(f func(object Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(container, "set-focus-child", false, unsafe.Pointer(C._gotk4_gtk3_Container_ConnectSetFocusChild), f)
}

// Add adds widget to container. Typically used for simple containers such as
// Window, Frame, or Button; for more complicated layout containers such as Box
// or Grid, this function will pick default packing parameters that may not be
// correct. So consider functions such as gtk_box_pack_start() and
// gtk_grid_attach() as an alternative to gtk_container_add() in those cases. A
// widget may be added to only one container at a time; you can’t place the same
// widget inside two different containers.
//
// Note that some containers, such as ScrolledWindow or ListBox, may add
// intermediate children between the added widget and the container.
//
// The function takes the following parameters:
//
//    - widget to be placed inside container.
//
func (container *Container) Add(widget Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("add", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(widget)
}

func (container *Container) CheckResize() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("check_resize", _args[:], nil)

	runtime.KeepAlive(container)
}

// ChildGetProperty gets the value of a child property for child and container.
//
// The function takes the following parameters:
//
//    - child: widget which is a child of container.
//    - propertyName: name of the property to get.
//    - value: location to return the value.
//
func (container *Container) ChildGetProperty(child Widgetter, propertyName string, value *coreglib.Value) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[2])) = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[2]))))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(unsafe.Pointer(value.Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("child_get_property", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(child)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// ChildNotify emits a Widget::child-notify signal for the [child
// property][child-properties] child_property on the child.
//
// This is an analogue of g_object_notify() for child properties.
//
// Also see gtk_widget_child_notify().
//
// The function takes the following parameters:
//
//    - child widget.
//    - childProperty: name of a child property installed on the class of
//      container.
//
func (container *Container) ChildNotify(child Widgetter, childProperty string) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[2])) = (*C.gchar)(unsafe.Pointer(C.CString(childProperty)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[2]))))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("child_notify", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(child)
	runtime.KeepAlive(childProperty)
}

// ChildSetProperty sets a child property for child and container.
//
// The function takes the following parameters:
//
//    - child: widget which is a child of container.
//    - propertyName: name of the property to set.
//    - value to set the property to.
//
func (container *Container) ChildSetProperty(child Widgetter, propertyName string, value *coreglib.Value) {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.gchar)(unsafe.Pointer(&_args[2])) = (*C.gchar)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(*(**C.gchar)(unsafe.Pointer(&_args[2]))))
	*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(unsafe.Pointer(value.Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("child_set_property", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(child)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// Forall invokes callback on each direct child of container, including children
// that are considered “internal” (implementation details of the container).
// “Internal” children generally weren’t added by the user of the container, but
// were added by the container implementation itself.
//
// Most applications should use gtk_container_foreach(), rather than
// gtk_container_forall().
//
// The function takes the following parameters:
//
//    - callback: callback.
//
func (container *Container) Forall(callback Callback) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_gtk3_Callback)
	_args[2] = C.gpointer(gbox.Assign(callback))
	defer gbox.Delete(uintptr(_args[2]))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("forall", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(callback)
}

// ForEach invokes callback on each non-internal child of container. See
// gtk_container_forall() for details on what constitutes an “internal” child.
// For all practical purposes, this function should iterate over precisely those
// child widgets that were added to the container by the application with
// explicit add() calls.
//
// It is permissible to remove the child from the callback handler.
//
// Most applications should use gtk_container_foreach(), rather than
// gtk_container_forall().
//
// The function takes the following parameters:
//
//    - callback: callback.
//
func (container *Container) ForEach(callback Callback) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_gtk3_Callback)
	_args[2] = C.gpointer(gbox.Assign(callback))
	defer gbox.Delete(uintptr(_args[2]))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("foreach", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(callback)
}

// BorderWidth retrieves the border width of the container. See
// gtk_container_set_border_width().
//
// The function returns the following values:
//
//    - guint: current border width.
//
func (container *Container) BorderWidth() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_gret := _info.InvokeClassMethod("get_border_width", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(container)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Children returns the container’s non-internal children. See
// gtk_container_forall() for details on what constitutes an "internal" child.
//
// The function returns the following values:
//
//    - list: newly-allocated list of the container’s non-internal children.
//
func (container *Container) Children() []Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_gret := _info.InvokeClassMethod("get_children", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(container)

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	gextras.MoveList(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret))), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&src)))
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// FocusChain retrieves the focus chain of the container, if one has been set
// explicitly. If no focus chain has been explicitly set, GTK+ computes the
// focus chain based on the positions of the children. In that case, GTK+ stores
// NULL in focusable_widgets and returns FALSE.
//
// Deprecated: For overriding focus behavior, use the GtkWidgetClass::focus
// signal.
//
// The function returns the following values:
//
//    - focusableWidgets: location to store the focus chain of the container, or
//      NULL. You should free this list using g_list_free() when you are done
//      with it, however no additional reference count is added to the individual
//      widgets in the focus chain.
//    - ok: TRUE if the focus chain of the container has been set explicitly.
//
func (container *Container) FocusChain() ([]Widgetter, bool) {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_gret := _info.InvokeClassMethod("get_focus_chain", _args[:], _outs[:])
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(container)

	var _focusableWidgets []Widgetter // out
	var _ok bool                      // out

	_focusableWidgets = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0])))))
	gextras.MoveList(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_outs[0]))), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&src)))
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_focusableWidgets = append(_focusableWidgets, dst)
	})
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _focusableWidgets, _ok
}

// FocusChild returns the current focus child widget inside container. This is
// not the currently focused widget. That can be obtained by calling
// gtk_window_get_focus().
//
// The function returns the following values:
//
//    - widget (optional): child widget which will receive the focus inside
//      container when the container is focused, or NULL if none is set.
//
func (container *Container) FocusChild() Widgetter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_gret := _info.InvokeClassMethod("get_focus_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(container)

	var _widget Widgetter // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// FocusHAdjustment retrieves the horizontal focus adjustment for the container.
// See gtk_container_set_focus_hadjustment ().
//
// The function returns the following values:
//
//    - adjustment (optional): horizontal focus adjustment, or NULL if none has
//      been set.
//
func (container *Container) FocusHAdjustment() *Adjustment {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_gret := _info.InvokeClassMethod("get_focus_hadjustment", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(container)

	var _adjustment *Adjustment // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	}

	return _adjustment
}

// FocusVAdjustment retrieves the vertical focus adjustment for the container.
// See gtk_container_set_focus_vadjustment().
//
// The function returns the following values:
//
//    - adjustment (optional): vertical focus adjustment, or NULL if none has
//      been set.
//
func (container *Container) FocusVAdjustment() *Adjustment {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_gret := _info.InvokeClassMethod("get_focus_vadjustment", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(container)

	var _adjustment *Adjustment // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	}

	return _adjustment
}

// PathForChild returns a newly created widget path representing all the widget
// hierarchy from the toplevel down to and including child.
//
// The function takes the following parameters:
//
//    - child of container.
//
// The function returns the following values:
//
//    - widgetPath: newly created WidgetPath.
//
func (container *Container) PathForChild(child Widgetter) *WidgetPath {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_gret := _info.InvokeClassMethod("get_path_for_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(container)
	runtime.KeepAlive(child)

	var _widgetPath *WidgetPath // out

	_widgetPath = (*WidgetPath)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_widgetPath)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				var args [1]girepository.Argument
				*(*unsafe.Pointer)(unsafe.Pointer(&args[0])) = unsafe.Pointer(intern.C)
				girepository.MustFind("Gtk", "WidgetPath").InvokeRecordMethod("free", args[:], nil)
			}
		},
	)

	return _widgetPath
}

// PropagateDraw: when a container receives a call to the draw function, it must
// send synthetic Widget::draw calls to all children that don’t have their own
// Windows. This function provides a convenient way of doing this. A container,
// when it receives a call to its Widget::draw function, calls
// gtk_container_propagate_draw() once for each child, passing in the cr the
// container received.
//
// gtk_container_propagate_draw() takes care of translating the origin of cr,
// and deciding whether the draw needs to be sent to the child. It is a
// convenient and optimized way of getting the same effect as calling
// gtk_widget_draw() on the child directly.
//
// In most cases, a container can simply either inherit the Widget::draw
// implementation from Container, or do some drawing and then chain to the
// ::draw implementation from Container.
//
// The function takes the following parameters:
//
//    - child of container.
//    - cr: cairo context as passed to the container. If you want to use cr in
//      container’s draw function, consider using cairo_save() and
//      cairo_restore() before calling this function.
//
func (container *Container) PropagateDraw(child Widgetter, cr *cairo.Context) {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(unsafe.Pointer(cr.Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("propagate_draw", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(child)
	runtime.KeepAlive(cr)
}

// Remove removes widget from container. widget must be inside container. Note
// that container will own a reference to widget, and that this may be the last
// reference held; so removing a widget from its container can destroy that
// widget. If you want to use widget again, you need to add a reference to it
// before removing it from a container, using g_object_ref(). If you don’t want
// to use widget again it’s usually more efficient to simply destroy it directly
// using gtk_widget_destroy() since this will remove it from the container and
// help break any circular reference count cycles.
//
// The function takes the following parameters:
//
//    - widget: current child of container.
//
func (container *Container) Remove(widget Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("remove", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(widget)
}

// ResizeChildren: deprecated: since version 3.10.
func (container *Container) ResizeChildren() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("resize_children", _args[:], nil)

	runtime.KeepAlive(container)
}

// SetBorderWidth sets the border width of the container.
//
// The border width of a container is the amount of space to leave around the
// outside of the container. The only exception to this is Window; because
// toplevel windows can’t leave space outside, they leave the space inside. The
// border is added on all sides of the container. To add space to only one side,
// use a specific Widget:margin property on the child widget, for example
// Widget:margin-top.
//
// The function takes the following parameters:
//
//    - borderWidth: amount of blank space to leave outside the container. Valid
//      values are in the range 0-65535 pixels.
//
func (container *Container) SetBorderWidth(borderWidth uint32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(borderWidth)

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("set_border_width", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(borderWidth)
}

// SetFocusChain sets a focus chain, overriding the one computed automatically
// by GTK+.
//
// In principle each widget in the chain should be a descendant of the
// container, but this is not enforced by this method, since it’s allowed to set
// the focus chain before you pack the widgets, or have a widget in the chain
// that isn’t always packed. The necessary checks are done when the focus chain
// is actually traversed.
//
// Deprecated: For overriding focus behavior, use the GtkWidgetClass::focus
// signal.
//
// The function takes the following parameters:
//
//    - focusableWidgets: the new focus chain.
//
func (container *Container) SetFocusChain(focusableWidgets []Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	for i := len(focusableWidgets) - 1; i >= 0; i-- {
		src := focusableWidgets[i]
		var dst *C.void // out
		*(**C.void)(unsafe.Pointer(&dst)) = (*C.void)(unsafe.Pointer(coreglib.InternObject(src).Native()))
		*(**C.void)(unsafe.Pointer(&_args[1])) = C.g_list_prepend(*(**C.void)(unsafe.Pointer(&_args[1])), C.gpointer(unsafe.Pointer(dst)))
	}
	defer C.g_list_free(_args[1])

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("set_focus_chain", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(focusableWidgets)
}

// SetFocusChild: sets, or unsets if child is NULL, the focused child of
// container.
//
// This function emits the GtkContainer::set_focus_child signal of container.
// Implementations of Container can override the default behaviour by overriding
// the class closure of this signal.
//
// This is function is mostly meant to be used by widgets. Applications can use
// gtk_widget_grab_focus() to manually set the focus to a specific widget.
//
// The function takes the following parameters:
//
//    - child (optional) or NULL.
//
func (container *Container) SetFocusChild(child Widgetter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	if child != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("set_focus_child", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(child)
}

// SetFocusHAdjustment hooks up an adjustment to focus handling in a container,
// so when a child of the container is focused, the adjustment is scrolled to
// show that widget. This function sets the horizontal alignment. See
// gtk_scrolled_window_get_hadjustment() for a typical way of obtaining the
// adjustment and gtk_container_set_focus_vadjustment() for setting the vertical
// adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the container.
//
// The function takes the following parameters:
//
//    - adjustment which should be adjusted when the focus is moved among the
//      descendents of container.
//
func (container *Container) SetFocusHAdjustment(adjustment *Adjustment) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("set_focus_hadjustment", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(adjustment)
}

// SetFocusVAdjustment hooks up an adjustment to focus handling in a container,
// so when a child of the container is focused, the adjustment is scrolled to
// show that widget. This function sets the vertical alignment. See
// gtk_scrolled_window_get_vadjustment() for a typical way of obtaining the
// adjustment and gtk_container_set_focus_hadjustment() for setting the
// horizontal adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the container.
//
// The function takes the following parameters:
//
//    - adjustment which should be adjusted when the focus is moved among the
//      descendents of container.
//
func (container *Container) SetFocusVAdjustment(adjustment *Adjustment) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("set_focus_vadjustment", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(adjustment)
}

// SetReallocateRedraws sets the reallocate_redraws flag of the container to the
// given value.
//
// Containers requesting reallocation redraws get automatically redrawn if any
// of their children changed allocation.
//
// Deprecated: Call gtk_widget_queue_draw() in your size_allocate handler.
//
// The function takes the following parameters:
//
//    - needsRedraws: new value for the container’s reallocate_redraws flag.
//
func (container *Container) SetReallocateRedraws(needsRedraws bool) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))
	if needsRedraws {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("set_reallocate_redraws", _args[:], nil)

	runtime.KeepAlive(container)
	runtime.KeepAlive(needsRedraws)
}

// UnsetFocusChain removes a focus chain explicitly set with
// gtk_container_set_focus_chain().
//
// Deprecated: For overriding focus behavior, use the GtkWidgetClass::focus
// signal.
func (container *Container) UnsetFocusChain() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(container).Native()))

	_info := girepository.MustFind("Gtk", "Container")
	_info.InvokeClassMethod("unset_focus_chain", _args[:], nil)

	runtime.KeepAlive(container)
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gchar* _gotk4_gtk3_ScaleClass_format_value(GtkScale*, gdouble);
// extern gchar* _gotk4_gtk3_Scale_ConnectFormatValue(gpointer, gdouble, guintptr);
// extern void _gotk4_gtk3_ScaleClass_draw_value(GtkScale*);
import "C"

// glib.Type values for gtkscale.go.
var GTypeScale = coreglib.Type(C.gtk_scale_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeScale, F: marshalScale},
	})
}

// ScaleOverrider contains methods that are overridable.
type ScaleOverrider interface {
	DrawValue()
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	FormatValue(value float64) string
}

// Scale is a slider control used to select a numeric value. To use it, you’ll
// probably want to investigate the methods on its base class, Range, in
// addition to the methods for GtkScale itself. To set the value of a scale, you
// would normally use gtk_range_set_value(). To detect changes to the value, you
// would normally use the Range::value-changed signal.
//
// Note that using the same upper and lower bounds for the Scale (through the
// Range methods) will hide the slider itself. This is useful for applications
// that want to show an undeterminate value on the scale, without changing the
// layout of the application (such as movie or music players).
//
//
// GtkScale as GtkBuildable
//
// GtkScale supports a custom <marks> element, which can contain multiple <mark>
// elements. The “value” and “position” attributes have the same meaning as
// gtk_scale_add_mark() parameters of the same name. If the element is not
// empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
//
// CSS nodes
//
//    scale[.fine-tune][.marks-before][.marks-after]
//    ├── marks.top
//    │   ├── mark
//    │   ┊    ├── [label]
//    │   ┊    ╰── indicator
//    ┊   ┊
//    │   ╰── mark
//    ├── [value]
//    ├── contents
//    │   ╰── trough
//    │       ├── slider
//    │       ├── [highlight]
//    │       ╰── [fill]
//    ╰── marks.bottom
//        ├── mark
//        ┊    ├── indicator
//        ┊    ╰── [label]
//        ╰── mark
//
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see gtk_scale_set_has_origin()), there is a
// subnode with name highlight below the trough node that is used for rendering
// the highlighted part of the trough.
//
// If the scale is showing a fill level (see gtk_range_set_show_fill_level()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
//
// If marks are present, there is a marks subnode before or after the contents
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see Scale:draw-value), there is subnode
// with name value.
type Scale struct {
	_ [0]func() // equal guard
	Range
}

var (
	_ Ranger = (*Scale)(nil)
)

func classInitScaler(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkScaleClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkScaleClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ DrawValue() }); ok {
		pclass.draw_value = (*[0]byte)(C._gotk4_gtk3_ScaleClass_draw_value)
	}

	if _, ok := goval.(interface{ FormatValue(value float64) string }); ok {
		pclass.format_value = (*[0]byte)(C._gotk4_gtk3_ScaleClass_format_value)
	}
}

//export _gotk4_gtk3_ScaleClass_draw_value
func _gotk4_gtk3_ScaleClass_draw_value(arg0 *C.GtkScale) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ DrawValue() })

	iface.DrawValue()
}

//export _gotk4_gtk3_ScaleClass_format_value
func _gotk4_gtk3_ScaleClass_format_value(arg0 *C.GtkScale, arg1 C.gdouble) (cret *C.gchar) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ FormatValue(value float64) string })

	var _value float64 // out

	_value = float64(arg1)

	utf8 := iface.FormatValue(_value)

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

func wrapScale(obj *coreglib.Object) *Scale {
	return &Scale{
		Range: Range{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
		},
	}
}

func marshalScale(p uintptr) (interface{}, error) {
	return wrapScale(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_Scale_ConnectFormatValue
func _gotk4_gtk3_Scale_ConnectFormatValue(arg0 C.gpointer, arg1 C.gdouble, arg2 C.guintptr) (cret *C.gchar) {
	var f func(value float64) (utf8 string)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(value float64) (utf8 string))
	}

	var _value float64 // out

	_value = float64(arg1)

	utf8 := f(_value)

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))

	return cret
}

// ConnectFormatValue: signal which allows you to change how the scale value is
// displayed. Connect a signal handler which returns an allocated string
// representing value. That string will then be used to display the scale's
// value.
//
// If no user-provided handlers are installed, the value will be displayed on
// its own, rounded according to the value of the Scale:digits property.
//
// Here's an example signal handler which displays a value 1.0 as with
// "-->1.0<--".
//
//    static gchar*
//    format_value_callback (GtkScale *scale,
//                           gdouble   value)
//    {
//      return g_strdup_printf ("-->\0.*g<--",
//                              gtk_scale_get_digits (scale), value);
//     }.
func (scale *Scale) ConnectFormatValue(f func(value float64) (utf8 string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scale, "format-value", false, unsafe.Pointer(C._gotk4_gtk3_Scale_ConnectFormatValue), f)
}

// ClearMarks removes any marks that have been added with gtk_scale_add_mark().
func (scale *Scale) ClearMarks() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	*(**Scale)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "Scale").InvokeMethod("clear_marks", args[:], nil)

	runtime.KeepAlive(scale)
}

// Digits gets the number of decimal places that are displayed in the value.
//
// The function returns the following values:
//
//    - gint: number of decimal places that are displayed.
//
func (scale *Scale) Digits() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	*(**Scale)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Scale").InvokeMethod("get_digits", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scale)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// DrawValue returns whether the current value is displayed as a string next to
// the slider.
//
// The function returns the following values:
//
//    - ok: whether the current value is displayed as a string.
//
func (scale *Scale) DrawValue() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	*(**Scale)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Scale").InvokeMethod("get_draw_value", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scale)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasOrigin returns whether the scale has an origin.
//
// The function returns the following values:
//
//    - ok: TRUE if the scale has an origin.
//
func (scale *Scale) HasOrigin() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	*(**Scale)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Scale").InvokeMethod("get_has_origin", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scale)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Layout gets the Layout used to display the scale. The returned object is
// owned by the scale so does not need to be freed by the caller.
//
// The function returns the following values:
//
//    - layout (optional) for this scale, or NULL if the Scale:draw-value
//      property is FALSE.
//
func (scale *Scale) Layout() *pango.Layout {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	*(**Scale)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "Scale").InvokeMethod("get_layout", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(scale)

	var _layout *pango.Layout // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_layout = &pango.Layout{
				Object: obj,
			}
		}
	}

	return _layout
}

// SetDigits sets the number of decimal places that are displayed in the value.
// Also causes the value of the adjustment to be rounded to this number of
// digits, so the retrieved value matches the displayed one, if Scale:draw-value
// is TRUE when the value changes. If you want to enforce rounding the value
// when Scale:draw-value is FALSE, you can set Range:round-digits instead.
//
// Note that rounding to a small number of digits can interfere with the smooth
// autoscrolling that is built into Scale. As an alternative, you can use the
// Scale::format-value signal to format the displayed value yourself.
//
// The function takes the following parameters:
//
//    - digits: number of decimal places to display, e.g. use 1 to display 1.0, 2
//      to display 1.00, etc.
//
func (scale *Scale) SetDigits(digits int32) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	_arg1 = C.gint(digits)
	*(**Scale)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Scale").InvokeMethod("set_digits", args[:], nil)

	runtime.KeepAlive(scale)
	runtime.KeepAlive(digits)
}

// SetDrawValue specifies whether the current value is displayed as a string
// next to the slider.
//
// The function takes the following parameters:
//
//    - drawValue: TRUE to draw the value.
//
func (scale *Scale) SetDrawValue(drawValue bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	if drawValue {
		_arg1 = C.TRUE
	}
	*(**Scale)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Scale").InvokeMethod("set_draw_value", args[:], nil)

	runtime.KeepAlive(scale)
	runtime.KeepAlive(drawValue)
}

// SetHasOrigin: if Scale:has-origin is set to TRUE (the default), the scale
// will highlight the part of the trough between the origin (bottom or left
// side) and the current value.
//
// The function takes the following parameters:
//
//    - hasOrigin: TRUE if the scale has an origin.
//
func (scale *Scale) SetHasOrigin(hasOrigin bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	if hasOrigin {
		_arg1 = C.TRUE
	}
	*(**Scale)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "Scale").InvokeMethod("set_has_origin", args[:], nil)

	runtime.KeepAlive(scale)
	runtime.KeepAlive(hasOrigin)
}

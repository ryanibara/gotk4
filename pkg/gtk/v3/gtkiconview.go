// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_IconView_ConnectUnselectAll(gpointer, guintptr);
// extern void _gotk4_gtk3_IconView_ConnectToggleCursorItem(gpointer, guintptr);
// extern void _gotk4_gtk3_IconView_ConnectSelectionChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_IconView_ConnectSelectCursorItem(gpointer, guintptr);
// extern void _gotk4_gtk3_IconView_ConnectSelectAll(gpointer, guintptr);
// extern void _gotk4_gtk3_IconView_ConnectItemActivated(gpointer, GtkTreePath*, guintptr);
// extern void _gotk4_gtk3_IconViewClass_unselect_all(GtkIconView*);
// extern void _gotk4_gtk3_IconViewClass_toggle_cursor_item(GtkIconView*);
// extern void _gotk4_gtk3_IconViewClass_selection_changed(GtkIconView*);
// extern void _gotk4_gtk3_IconViewClass_select_cursor_item(GtkIconView*);
// extern void _gotk4_gtk3_IconViewClass_select_all(GtkIconView*);
// extern void _gotk4_gtk3_IconViewClass_item_activated(GtkIconView*, GtkTreePath*);
// extern gboolean _gotk4_gtk3_IconView_ConnectMoveCursor(gpointer, GtkMovementStep, gint, guintptr);
// extern gboolean _gotk4_gtk3_IconView_ConnectActivateCursorItem(gpointer, guintptr);
// extern gboolean _gotk4_gtk3_IconViewClass_move_cursor(GtkIconView*, GtkMovementStep, gint);
// extern gboolean _gotk4_gtk3_IconViewClass_activate_cursor_item(GtkIconView*);
// gboolean _gotk4_gtk3_IconView_virtual_activate_cursor_item(void* fnptr, GtkIconView* arg0) {
//   return ((gboolean (*)(GtkIconView*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk3_IconView_virtual_move_cursor(void* fnptr, GtkIconView* arg0, GtkMovementStep arg1, gint arg2) {
//   return ((gboolean (*)(GtkIconView*, GtkMovementStep, gint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk3_IconView_virtual_select_cursor_item(void* fnptr, GtkIconView* arg0) {
//   ((void (*)(GtkIconView*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_IconView_virtual_selection_changed(void* fnptr, GtkIconView* arg0) {
//   ((void (*)(GtkIconView*))(fnptr))(arg0);
// };
// void _gotk4_gtk3_IconView_virtual_toggle_cursor_item(void* fnptr, GtkIconView* arg0) {
//   ((void (*)(GtkIconView*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeIconViewDropPosition = coreglib.Type(C.gtk_icon_view_drop_position_get_type())
	GTypeIconView             = coreglib.Type(C.gtk_icon_view_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeIconViewDropPosition, F: marshalIconViewDropPosition},
		coreglib.TypeMarshaler{T: GTypeIconView, F: marshalIconView},
	})
}

// IconViewDropPosition: enum for determining where a dropped item goes.
type IconViewDropPosition C.gint

const (
	// IconViewNoDrop: no drop possible.
	IconViewNoDrop IconViewDropPosition = iota
	// IconViewDropInto: dropped item replaces the item.
	IconViewDropInto
	// IconViewDropLeft: droppped item is inserted to the left.
	IconViewDropLeft
	// IconViewDropRight: dropped item is inserted to the right.
	IconViewDropRight
	// IconViewDropAbove: dropped item is inserted above.
	IconViewDropAbove
	// IconViewDropBelow: dropped item is inserted below.
	IconViewDropBelow
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconViewDropPosition.
func (i IconViewDropPosition) String() string {
	switch i {
	case IconViewNoDrop:
		return "NoDrop"
	case IconViewDropInto:
		return "DropInto"
	case IconViewDropLeft:
		return "DropLeft"
	case IconViewDropRight:
		return "DropRight"
	case IconViewDropAbove:
		return "DropAbove"
	case IconViewDropBelow:
		return "DropBelow"
	default:
		return fmt.Sprintf("IconViewDropPosition(%d)", i)
	}
}

// IconViewForEachFunc: function used by gtk_icon_view_selected_foreach() to map
// all selected rows. It will be called on every selected row in the view.
type IconViewForEachFunc func(iconView *IconView, path *TreePath)

// IconViewOverrides contains methods that are overridable.
type IconViewOverrides struct {
	// The function returns the following values:
	//
	ActivateCursorItem func() bool
	// ItemActivated activates the item determined by path.
	//
	// The function takes the following parameters:
	//
	//    - path to be activated.
	//
	ItemActivated func(path *TreePath)
	// The function takes the following parameters:
	//
	//    - step
	//    - count
	//
	// The function returns the following values:
	//
	MoveCursor func(step MovementStep, count int) bool
	// SelectAll selects all the icons. icon_view must has its selection mode
	// set to K_SELECTION_MULTIPLE.
	SelectAll        func()
	SelectCursorItem func()
	SelectionChanged func()
	ToggleCursorItem func()
	// UnselectAll unselects all the icons.
	UnselectAll func()
}

func defaultIconViewOverrides(v *IconView) IconViewOverrides {
	return IconViewOverrides{
		ActivateCursorItem: v.activateCursorItem,
		ItemActivated:      v.itemActivated,
		MoveCursor:         v.moveCursor,
		SelectAll:          v.selectAll,
		SelectCursorItem:   v.selectCursorItem,
		SelectionChanged:   v.selectionChanged,
		ToggleCursorItem:   v.toggleCursorItem,
		UnselectAll:        v.unselectAll,
	}
}

// IconView provides an alternative view on a TreeModel. It displays the model
// as a grid of icons with labels. Like TreeView, it allows to select one or
// multiple items (depending on the selection mode, see
// gtk_icon_view_set_selection_mode()). In addition to selection with the arrow
// keys, IconView supports rubberband selection, which is controlled by dragging
// the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
// CSS nodes
//
//    iconview.view
//    ╰── [rubberband]
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView struct {
	_ [0]func() // equal guard
	Container

	*coreglib.Object
	CellLayout
	Scrollable
}

var (
	_ Containerer       = (*IconView)(nil)
	_ coreglib.Objector = (*IconView)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*IconView, *IconViewClass, IconViewOverrides](
		GTypeIconView,
		initIconViewClass,
		wrapIconView,
		defaultIconViewOverrides,
	)
}

func initIconViewClass(gclass unsafe.Pointer, overrides IconViewOverrides, classInitFunc func(*IconViewClass)) {
	pclass := (*C.GtkIconViewClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeIconView))))

	if overrides.ActivateCursorItem != nil {
		pclass.activate_cursor_item = (*[0]byte)(C._gotk4_gtk3_IconViewClass_activate_cursor_item)
	}

	if overrides.ItemActivated != nil {
		pclass.item_activated = (*[0]byte)(C._gotk4_gtk3_IconViewClass_item_activated)
	}

	if overrides.MoveCursor != nil {
		pclass.move_cursor = (*[0]byte)(C._gotk4_gtk3_IconViewClass_move_cursor)
	}

	if overrides.SelectAll != nil {
		pclass.select_all = (*[0]byte)(C._gotk4_gtk3_IconViewClass_select_all)
	}

	if overrides.SelectCursorItem != nil {
		pclass.select_cursor_item = (*[0]byte)(C._gotk4_gtk3_IconViewClass_select_cursor_item)
	}

	if overrides.SelectionChanged != nil {
		pclass.selection_changed = (*[0]byte)(C._gotk4_gtk3_IconViewClass_selection_changed)
	}

	if overrides.ToggleCursorItem != nil {
		pclass.toggle_cursor_item = (*[0]byte)(C._gotk4_gtk3_IconViewClass_toggle_cursor_item)
	}

	if overrides.UnselectAll != nil {
		pclass.unselect_all = (*[0]byte)(C._gotk4_gtk3_IconViewClass_unselect_all)
	}

	if classInitFunc != nil {
		class := (*IconViewClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapIconView(obj *coreglib.Object) *IconView {
	return &IconView{
		Container: Container{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				ImplementorIface: atk.ImplementorIface{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
			},
		},
		Object: obj,
		CellLayout: CellLayout{
			Object: obj,
		},
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalIconView(p uintptr) (interface{}, error) {
	return wrapIconView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateCursorItem: [keybinding signal][GtkBindingSignal] which gets
// emitted when the user activates the currently focused item.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control activation programmatically.
//
// The default bindings for this signal are Space, Return and Enter.
func (iconView *IconView) ConnectActivateCursorItem(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "activate-cursor-item", false, unsafe.Pointer(C._gotk4_gtk3_IconView_ConnectActivateCursorItem), f)
}

// ConnectItemActivated signal is emitted when the method
// gtk_icon_view_item_activated() is called, when the user double clicks an item
// with the "activate-on-single-click" property set to FALSE, or when the user
// single clicks an item when the "activate-on-single-click" property set to
// TRUE. It is also emitted when a non-editable item is selected and one of the
// keys: Space, Return or Enter is pressed.
func (iconView *IconView) ConnectItemActivated(f func(path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "item-activated", false, unsafe.Pointer(C._gotk4_gtk3_IconView_ConnectItemActivated), f)
}

// ConnectMoveCursor signal is a [keybinding signal][GtkBindingSignal] which
// gets emitted when the user initiates a cursor movement.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
//
//
// The default bindings for this signal include
//
// - Arrow keys which move by individual steps
//
// - Home/End keys which move to the first/last item
//
// - PageUp/PageDown which move by "pages" All of these will extend the
// selection when combined with the Shift modifier.
func (iconView *IconView) ConnectMoveCursor(f func(step MovementStep, count int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk3_IconView_ConnectMoveCursor), f)
}

// ConnectSelectAll: [keybinding signal][GtkBindingSignal] which gets emitted
// when the user selects all items.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// The default binding for this signal is Ctrl-a.
func (iconView *IconView) ConnectSelectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "select-all", false, unsafe.Pointer(C._gotk4_gtk3_IconView_ConnectSelectAll), f)
}

// ConnectSelectCursorItem: [keybinding signal][GtkBindingSignal] which gets
// emitted when the user selects the item that is currently focused.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// There is no default binding for this signal.
func (iconView *IconView) ConnectSelectCursorItem(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "select-cursor-item", false, unsafe.Pointer(C._gotk4_gtk3_IconView_ConnectSelectCursorItem), f)
}

// ConnectSelectionChanged signal is emitted when the selection (i.e. the set of
// selected items) changes.
func (iconView *IconView) ConnectSelectionChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "selection-changed", false, unsafe.Pointer(C._gotk4_gtk3_IconView_ConnectSelectionChanged), f)
}

// ConnectToggleCursorItem: [keybinding signal][GtkBindingSignal] which gets
// emitted when the user toggles whether the currently focused item is selected
// or not. The exact effect of this depend on the selection mode.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// There is no default binding for this signal is Ctrl-Space.
func (iconView *IconView) ConnectToggleCursorItem(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "toggle-cursor-item", false, unsafe.Pointer(C._gotk4_gtk3_IconView_ConnectToggleCursorItem), f)
}

// ConnectUnselectAll: [keybinding signal][GtkBindingSignal] which gets emitted
// when the user unselects all items.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// The default binding for this signal is Ctrl-Shift-a.
func (iconView *IconView) ConnectUnselectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "unselect-all", false, unsafe.Pointer(C._gotk4_gtk3_IconView_ConnectUnselectAll), f)
}

// The function returns the following values:
//
func (iconView *IconView) activateCursorItem() bool {
	gclass := (*C.GtkIconViewClass)(coreglib.PeekParentClass(iconView))
	fnarg := gclass.activate_cursor_item

	var _arg0 *C.GtkIconView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C._gotk4_gtk3_IconView_virtual_activate_cursor_item(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(iconView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - step
//    - count
//
// The function returns the following values:
//
func (iconView *IconView) moveCursor(step MovementStep, count int) bool {
	gclass := (*C.GtkIconViewClass)(coreglib.PeekParentClass(iconView))
	fnarg := gclass.move_cursor

	var _arg0 *C.GtkIconView    // out
	var _arg1 C.GtkMovementStep // out
	var _arg2 C.gint            // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.GtkMovementStep(step)
	_arg2 = C.gint(count)

	_cret = C._gotk4_gtk3_IconView_virtual_move_cursor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(step)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (iconView *IconView) selectCursorItem() {
	gclass := (*C.GtkIconViewClass)(coreglib.PeekParentClass(iconView))
	fnarg := gclass.select_cursor_item

	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C._gotk4_gtk3_IconView_virtual_select_cursor_item(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(iconView)
}

func (iconView *IconView) selectionChanged() {
	gclass := (*C.GtkIconViewClass)(coreglib.PeekParentClass(iconView))
	fnarg := gclass.selection_changed

	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C._gotk4_gtk3_IconView_virtual_selection_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(iconView)
}

func (iconView *IconView) toggleCursorItem() {
	gclass := (*C.GtkIconViewClass)(coreglib.PeekParentClass(iconView))
	fnarg := gclass.toggle_cursor_item

	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C._gotk4_gtk3_IconView_virtual_toggle_cursor_item(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(iconView)
}

// IconViewClass: instance of this type is always passed by reference.
type IconViewClass struct {
	*iconViewClass
}

// iconViewClass is the struct that's finalized.
type iconViewClass struct {
	native *C.GtkIconViewClass
}

func (i *IconViewClass) ParentClass() *ContainerClass {
	valptr := &i.native.parent_class
	var _v *ContainerClass // out
	_v = (*ContainerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

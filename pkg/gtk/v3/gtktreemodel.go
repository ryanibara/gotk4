// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern GType _gotk4_gtk3_TreeModelIface_get_column_type(GtkTreeModel*, gint);
// extern GtkTreeModelFlags _gotk4_gtk3_TreeModelIface_get_flags(GtkTreeModel*);
// extern GtkTreePath* _gotk4_gtk3_TreeModelIface_get_path(GtkTreeModel*, GtkTreeIter*);
// extern gboolean _gotk4_gtk3_TreeModelForEachFunc(GtkTreeModel*, GtkTreePath*, GtkTreeIter*, gpointer);
// extern gboolean _gotk4_gtk3_TreeModelIface_get_iter(GtkTreeModel*, GtkTreeIter*, GtkTreePath*);
// extern gboolean _gotk4_gtk3_TreeModelIface_iter_children(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*);
// extern gboolean _gotk4_gtk3_TreeModelIface_iter_has_child(GtkTreeModel*, GtkTreeIter*);
// extern gboolean _gotk4_gtk3_TreeModelIface_iter_next(GtkTreeModel*, GtkTreeIter*);
// extern gboolean _gotk4_gtk3_TreeModelIface_iter_nth_child(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*, gint);
// extern gboolean _gotk4_gtk3_TreeModelIface_iter_parent(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*);
// extern gboolean _gotk4_gtk3_TreeModelIface_iter_previous(GtkTreeModel*, GtkTreeIter*);
// extern gint _gotk4_gtk3_TreeModelIface_get_n_columns(GtkTreeModel*);
// extern gint _gotk4_gtk3_TreeModelIface_iter_n_children(GtkTreeModel*, GtkTreeIter*);
// extern void _gotk4_gtk3_TreeModelIface_get_value(GtkTreeModel*, GtkTreeIter*, gint, GValue*);
// extern void _gotk4_gtk3_TreeModelIface_ref_node(GtkTreeModel*, GtkTreeIter*);
// extern void _gotk4_gtk3_TreeModelIface_row_changed(GtkTreeModel*, GtkTreePath*, GtkTreeIter*);
// extern void _gotk4_gtk3_TreeModelIface_row_deleted(GtkTreeModel*, GtkTreePath*);
// extern void _gotk4_gtk3_TreeModelIface_row_has_child_toggled(GtkTreeModel*, GtkTreePath*, GtkTreeIter*);
// extern void _gotk4_gtk3_TreeModelIface_row_inserted(GtkTreeModel*, GtkTreePath*, GtkTreeIter*);
// extern void _gotk4_gtk3_TreeModelIface_unref_node(GtkTreeModel*, GtkTreeIter*);
// extern void _gotk4_gtk3_TreeModel_ConnectRowChanged(gpointer, GtkTreePath*, GtkTreeIter*, guintptr);
// extern void _gotk4_gtk3_TreeModel_ConnectRowDeleted(gpointer, GtkTreePath*, guintptr);
// extern void _gotk4_gtk3_TreeModel_ConnectRowHasChildToggled(gpointer, GtkTreePath*, GtkTreeIter*, guintptr);
// extern void _gotk4_gtk3_TreeModel_ConnectRowInserted(gpointer, GtkTreePath*, GtkTreeIter*, guintptr);
// extern void _gotk4_gtk3_TreeModel_ConnectRowsReordered(gpointer, GtkTreePath*, GtkTreeIter*, gpointer, guintptr);
import "C"

// glib.Type values for gtktreemodel.go.
var (
	GTypeTreeModelFlags   = externglib.Type(C.gtk_tree_model_flags_get_type())
	GTypeTreeModel        = externglib.Type(C.gtk_tree_model_get_type())
	GTypeTreeIter         = externglib.Type(C.gtk_tree_iter_get_type())
	GTypeTreePath         = externglib.Type(C.gtk_tree_path_get_type())
	GTypeTreeRowReference = externglib.Type(C.gtk_tree_row_reference_get_type())
)

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeTreeModelFlags, F: marshalTreeModelFlags},
		{T: GTypeTreeModel, F: marshalTreeModel},
		{T: GTypeTreeIter, F: marshalTreeIter},
		{T: GTypeTreePath, F: marshalTreePath},
		{T: GTypeTreeRowReference, F: marshalTreeRowReference},
	})
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags C.guint

const (
	// TreeModelItersPersist iterators survive all signals emitted by the tree.
	TreeModelItersPersist TreeModelFlags = 0b1
	// TreeModelListOnly: model is a list only, and never has children.
	TreeModelListOnly TreeModelFlags = 0b10
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TreeModelFlags.
func (t TreeModelFlags) String() string {
	if t == 0 {
		return "TreeModelFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(39)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TreeModelItersPersist:
			builder.WriteString("ItersPersist|")
		case TreeModelListOnly:
			builder.WriteString("ListOnly|")
		default:
			builder.WriteString(fmt.Sprintf("TreeModelFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TreeModelFlags) Has(other TreeModelFlags) bool {
	return (t & other) == other
}

// TreeModelForEachFunc: type of the callback passed to gtk_tree_model_foreach()
// to iterate over the rows in a tree model.
type TreeModelForEachFunc func(model TreeModeller, path *TreePath, iter *TreeIter) (ok bool)

//export _gotk4_gtk3_TreeModelForEachFunc
func _gotk4_gtk3_TreeModelForEachFunc(arg1 *C.GtkTreeModel, arg2 *C.GtkTreePath, arg3 *C.GtkTreeIter, arg4 C.gpointer) (cret C.gboolean) {
	var fn TreeModelForEachFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TreeModelForEachFunc)
	}

	var _model TreeModeller // out
	var _path *TreePath     // out
	var _iter *TreeIter     // out

	{
		objptr := unsafe.Pointer(arg1)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_model = rv
	}
	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	ok := fn(_model, _path, _iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TreeModelOverrider contains methods that are overridable.
type TreeModelOverrider interface {
	// ColumnType returns the type of the column.
	//
	// The function takes the following parameters:
	//
	//    - index_: column index.
	//
	// The function returns the following values:
	//
	//    - gType: type of the column.
	//
	ColumnType(index_ int) externglib.Type
	// Flags returns a set of flags supported by this interface.
	//
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the tree_model.
	//
	// The function returns the following values:
	//
	//    - treeModelFlags flags supported by this interface.
	//
	Flags() TreeModelFlags
	// Iter sets iter to a valid iterator pointing to path. If path does not
	// exist, iter is set to an invalid iterator and FALSE is returned.
	//
	// The function takes the following parameters:
	//
	//    - path: TreePath-struct.
	//
	// The function returns the following values:
	//
	//    - iter: uninitialized TreeIter-struct.
	//    - ok: TRUE, if iter was set.
	//
	Iter(path *TreePath) (*TreeIter, bool)
	// NColumns returns the number of columns supported by tree_model.
	//
	// The function returns the following values:
	//
	//    - gint: number of columns.
	//
	NColumns() int
	// Path returns a newly-created TreePath-struct referenced by iter.
	//
	// This path should be freed with gtk_tree_path_free().
	//
	// The function takes the following parameters:
	//
	//    - iter: TreeIter-struct.
	//
	// The function returns the following values:
	//
	//    - treePath: newly-created TreePath-struct.
	//
	Path(iter *TreeIter) *TreePath
	// Value initializes and sets value to that at column.
	//
	// When done with value, g_value_unset() needs to be called to free any
	// allocated memory.
	//
	// The function takes the following parameters:
	//
	//    - iter: TreeIter-struct.
	//    - column to lookup the value at.
	//
	// The function returns the following values:
	//
	//    - value: empty #GValue to set.
	//
	Value(iter *TreeIter, column int) externglib.Value
	// IterChildren sets iter to point to the first child of parent.
	//
	// If parent has no children, FALSE is returned and iter is set to be
	// invalid. parent will remain a valid node after this function has been
	// called.
	//
	// If parent is NULL returns the first node, equivalent to
	// gtk_tree_model_get_iter_first (tree_model, iter);.
	//
	// The function takes the following parameters:
	//
	//    - parent (optional) or NULL.
	//
	// The function returns the following values:
	//
	//    - iter: new TreeIter-struct to be set to the child.
	//    - ok: TRUE, if iter has been set to the first child.
	//
	IterChildren(parent *TreeIter) (*TreeIter, bool)
	// IterHasChild returns TRUE if iter has children, FALSE otherwise.
	//
	// The function takes the following parameters:
	//
	//    - iter to test for children.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if iter has children.
	//
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that iter has.
	//
	// As a special case, if iter is NULL, then the number of toplevel nodes is
	// returned.
	//
	// The function takes the following parameters:
	//
	//    - iter (optional) or NULL.
	//
	// The function returns the following values:
	//
	//    - gint: number of children of iter.
	//
	IterNChildren(iter *TreeIter) int
	// IterNext sets iter to point to the node following it at the current
	// level.
	//
	// If there is no next iter, FALSE is returned and iter is set to be
	// invalid.
	//
	// The function takes the following parameters:
	//
	//    - iter: TreeIter-struct.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if iter has been changed to the next node.
	//
	IterNext(iter *TreeIter) bool
	// IterNthChild sets iter to be the child of parent, using the given index.
	//
	// The first index is 0. If n is too big, or parent has no children, iter is
	// set to an invalid iterator and FALSE is returned. parent will remain a
	// valid node after this function has been called. As a special case, if
	// parent is NULL, then the n-th root node is set.
	//
	// The function takes the following parameters:
	//
	//    - parent (optional) to get the child from, or NULL.
	//    - n: index of the desired child.
	//
	// The function returns the following values:
	//
	//    - iter to set to the nth child.
	//    - ok: TRUE, if parent has an n-th child.
	//
	IterNthChild(parent *TreeIter, n int) (*TreeIter, bool)
	// IterParent sets iter to be the parent of child.
	//
	// If child is at the toplevel, and doesn’t have a parent, then iter is set
	// to an invalid iterator and FALSE is returned. child will remain a valid
	// node after this function has been called.
	//
	// iter will be initialized before the lookup is performed, so child and
	// iter cannot point to the same memory location.
	//
	// The function takes the following parameters:
	//
	//    - child: TreeIter-struct.
	//
	// The function returns the following values:
	//
	//    - iter: new TreeIter-struct to set to the parent.
	//    - ok: TRUE, if iter is set to the parent of child.
	//
	IterParent(child *TreeIter) (*TreeIter, bool)
	// IterPrevious sets iter to point to the previous node at the current
	// level.
	//
	// If there is no previous iter, FALSE is returned and iter is set to be
	// invalid.
	//
	// The function takes the following parameters:
	//
	//    - iter: TreeIter-struct.
	//
	// The function returns the following values:
	//
	//    - ok: TRUE if iter has been changed to the previous node.
	//
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	//
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	//
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
	//
	// The function takes the following parameters:
	//
	//    - iter: TreeIter-struct.
	//
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on tree_model.
	//
	// The function takes the following parameters:
	//
	//    - path pointing to the changed row.
	//    - iter: valid TreeIter-struct pointing to the changed row.
	//
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on tree_model.
	//
	// This should be called by models after a row has been removed. The
	// location pointed to by path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	//
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
	//
	// The function takes the following parameters:
	//
	//    - path pointing to the previous location of the deleted row.
	//
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// tree_model. This should be called by models after the child state of a
	// node changes.
	//
	// The function takes the following parameters:
	//
	//    - path pointing to the changed row.
	//    - iter: valid TreeIter-struct pointing to the changed row.
	//
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on tree_model.
	//
	// The function takes the following parameters:
	//
	//    - path pointing to the inserted row.
	//    - iter: valid TreeIter-struct pointing to the inserted row.
	//
	RowInserted(path *TreePath, iter *TreeIter)
	// UnrefNode lets the tree unref the node.
	//
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	//
	// Please note that nodes that are deleted are not unreffed.
	//
	// The function takes the following parameters:
	//
	//    - iter: TreeIter-struct.
	//
	UnrefNode(iter *TreeIter)
}

// TreeModel interface defines a generic tree interface for use by the TreeView
// widget. It is an abstract interface, and is designed to be usable with any
// appropriate data structure. The programmer just has to implement this
// interface on their own data type for it to be viewable by a TreeView widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the TreePath-struct and the TreeIter-struct (“iter” is short for
// iterator). Most of the interface consists of operations on a TreeIter-struct.
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. The
// TreePath-struct can be converted into either an array of unsigned integers or
// a string. The string form is a list of numbers separated by a colon. Each
// number refers to the offset at that level. Thus, the path 0 refers to the
// root node and the path 2:4 refers to the fifth child of the third node.
//
// By contrast, a TreeIter-struct is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
//
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location 3:2:5.
// While the first method shown is easier, the second is much more common, as
// you often get paths from callbacks.
//
// Acquiring a TreeIter-struct
//
//    enum
//    {
//      STRING_COLUMN,
//      INT_COLUMN,
//      N_COLUMNS
//    };
//
//    ...
//
//    GtkTreeModel *list_store;
//    GtkTreeIter iter;
//    gboolean valid;
//    gint row_count = 0;
//
//    // make a new list_store
//    list_store = gtk_list_store_new (N_COLUMNS,
//                                     G_TYPE_STRING,
//                                     G_TYPE_INT);
//
//    // Fill the list store with data
//    populate_model (list_store);
//
//    // Get the first iter in the list, check it is valid and walk
//    // through the list, reading each row.
//
//    valid = gtk_tree_model_get_iter_first (list_store,
//                                           &iter);
//    while (valid)
//     {
//       gchar *str_data;
//       gint   int_data;
//
//       // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//       gtk_tree_model_get (list_store, &iter,
//                           STRING_COLUMN, &str_data,
//                           INT_COLUMN, &int_data,
//                           -1);
//
//       // Do something with the data
//       g_print ("Row d: (s,d)\n",
//                row_count, str_data, int_data);
//       g_free (str_data);
//
//       valid = gtk_tree_model_iter_next (list_store,
//                                         &iter);
//       row_count++;
//     }
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
type TreeModel struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*TreeModel)(nil)
)

// TreeModeller describes TreeModel's interface methods.
type TreeModeller interface {
	externglib.Objector

	// ForEach calls func on each node in model in a depth-first fashion.
	ForEach(fn TreeModelForEachFunc)
	// ColumnType returns the type of the column.
	ColumnType(index_ int) externglib.Type
	// Flags returns a set of flags supported by this interface.
	Flags() TreeModelFlags
	// Iter sets iter to a valid iterator pointing to path.
	Iter(path *TreePath) (*TreeIter, bool)
	// IterFirst initializes iter with the first iterator in the tree (the one
	// at the path "0") and returns TRUE.
	IterFirst() (*TreeIter, bool)
	// IterFromString sets iter to a valid iterator pointing to path_string, if
	// it exists.
	IterFromString(pathString string) (*TreeIter, bool)
	// NColumns returns the number of columns supported by tree_model.
	NColumns() int
	// Path returns a newly-created TreePath-struct referenced by iter.
	Path(iter *TreeIter) *TreePath
	// StringFromIter generates a string representation of the iter.
	StringFromIter(iter *TreeIter) string
	// Value initializes and sets value to that at column.
	Value(iter *TreeIter, column int) externglib.Value
	// IterChildren sets iter to point to the first child of parent.
	IterChildren(parent *TreeIter) (*TreeIter, bool)
	// IterHasChild returns TRUE if iter has children, FALSE otherwise.
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that iter has.
	IterNChildren(iter *TreeIter) int
	// IterNext sets iter to point to the node following it at the current
	// level.
	IterNext(iter *TreeIter) bool
	// IterNthChild sets iter to be the child of parent, using the given index.
	IterNthChild(parent *TreeIter, n int) (*TreeIter, bool)
	// IterParent sets iter to be the parent of child.
	IterParent(child *TreeIter) (*TreeIter, bool)
	// IterPrevious sets iter to point to the previous node at the current
	// level.
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on tree_model.
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on tree_model.
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// tree_model.
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on tree_model.
	RowInserted(path *TreePath, iter *TreeIter)
	// RowsReordered emits the TreeModel::rows-reordered signal on tree_model.
	RowsReordered(path *TreePath, iter *TreeIter, newOrder []int)
	// UnrefNode lets the tree unref the node.
	UnrefNode(iter *TreeIter)
}

var _ TreeModeller = (*TreeModel)(nil)

func ifaceInitTreeModeller(gifacePtr, data C.gpointer) {
	iface := (*C.GtkTreeModelIface)(unsafe.Pointer(gifacePtr))
	iface.get_column_type = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_get_column_type)
	iface.get_flags = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_get_flags)
	iface.get_iter = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_get_iter)
	iface.get_n_columns = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_get_n_columns)
	iface.get_path = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_get_path)
	iface.get_value = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_get_value)
	iface.iter_children = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_iter_children)
	iface.iter_has_child = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_iter_has_child)
	iface.iter_n_children = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_iter_n_children)
	iface.iter_next = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_iter_next)
	iface.iter_nth_child = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_iter_nth_child)
	iface.iter_parent = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_iter_parent)
	iface.iter_previous = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_iter_previous)
	iface.ref_node = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_ref_node)
	iface.row_changed = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_row_changed)
	iface.row_deleted = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_row_deleted)
	iface.row_has_child_toggled = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_row_has_child_toggled)
	iface.row_inserted = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_row_inserted)
	iface.unref_node = (*[0]byte)(C._gotk4_gtk3_TreeModelIface_unref_node)
}

//export _gotk4_gtk3_TreeModelIface_get_column_type
func _gotk4_gtk3_TreeModelIface_get_column_type(arg0 *C.GtkTreeModel, arg1 C.gint) (cret C.GType) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _index_ int // out

	_index_ = int(arg1)

	gType := iface.ColumnType(_index_)

	cret = C.GType(gType)

	return cret
}

//export _gotk4_gtk3_TreeModelIface_get_flags
func _gotk4_gtk3_TreeModelIface_get_flags(arg0 *C.GtkTreeModel) (cret C.GtkTreeModelFlags) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	treeModelFlags := iface.Flags()

	cret = C.GtkTreeModelFlags(treeModelFlags)

	return cret
}

//export _gotk4_gtk3_TreeModelIface_get_iter
func _gotk4_gtk3_TreeModelIface_get_iter(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GtkTreePath) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _path *TreePath // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iter, ok := iface.Iter(_path)

	*arg1 = *(*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeModelIface_get_n_columns
func _gotk4_gtk3_TreeModelIface_get_n_columns(arg0 *C.GtkTreeModel) (cret C.gint) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	gint := iface.NColumns()

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_TreeModelIface_get_path
func _gotk4_gtk3_TreeModelIface_get_path(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter) (cret *C.GtkTreePath) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	treePath := iface.Path(_iter)

	cret = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(treePath)))
	runtime.SetFinalizer(gextras.StructIntern(unsafe.Pointer(treePath)), nil)

	return cret
}

//export _gotk4_gtk3_TreeModelIface_get_value
func _gotk4_gtk3_TreeModelIface_get_value(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 C.gint, arg3 *C.GValue) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _iter *TreeIter // out
	var _column int     // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_column = int(arg2)

	value := iface.Value(_iter, _column)

	*arg3 = *(*C.GValue)(unsafe.Pointer((&value).Native()))
}

//export _gotk4_gtk3_TreeModelIface_iter_children
func _gotk4_gtk3_TreeModelIface_iter_children(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _parent *TreeIter // out

	if arg2 != nil {
		_parent = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	}

	iter, ok := iface.IterChildren(_parent)

	*arg1 = *(*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeModelIface_iter_has_child
func _gotk4_gtk3_TreeModelIface_iter_has_child(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.IterHasChild(_iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeModelIface_iter_n_children
func _gotk4_gtk3_TreeModelIface_iter_n_children(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter) (cret C.gint) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _iter *TreeIter // out

	if arg1 != nil {
		_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	}

	gint := iface.IterNChildren(_iter)

	cret = C.gint(gint)

	return cret
}

//export _gotk4_gtk3_TreeModelIface_iter_next
func _gotk4_gtk3_TreeModelIface_iter_next(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.IterNext(_iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeModelIface_iter_nth_child
func _gotk4_gtk3_TreeModelIface_iter_nth_child(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GtkTreeIter, arg3 C.gint) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _parent *TreeIter // out
	var _n int            // out

	if arg2 != nil {
		_parent = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	}
	_n = int(arg3)

	iter, ok := iface.IterNthChild(_parent, _n)

	*arg1 = *(*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeModelIface_iter_parent
func _gotk4_gtk3_TreeModelIface_iter_parent(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter, arg2 *C.GtkTreeIter) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _child *TreeIter // out

	_child = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iter, ok := iface.IterParent(_child)

	*arg1 = *(*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeModelIface_iter_previous
func _gotk4_gtk3_TreeModelIface_iter_previous(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.IterPrevious(_iter)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_gtk3_TreeModelIface_ref_node
func _gotk4_gtk3_TreeModelIface_ref_node(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	iface.RefNode(_iter)
}

//export _gotk4_gtk3_TreeModelIface_row_changed
func _gotk4_gtk3_TreeModelIface_row_changed(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iface.RowChanged(_path, _iter)
}

//export _gotk4_gtk3_TreeModelIface_row_deleted
func _gotk4_gtk3_TreeModelIface_row_deleted(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _path *TreePath // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	iface.RowDeleted(_path)
}

//export _gotk4_gtk3_TreeModelIface_row_has_child_toggled
func _gotk4_gtk3_TreeModelIface_row_has_child_toggled(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iface.RowHasChildToggled(_path, _iter)
}

//export _gotk4_gtk3_TreeModelIface_row_inserted
func _gotk4_gtk3_TreeModelIface_row_inserted(arg0 *C.GtkTreeModel, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iface.RowInserted(_path, _iter)
}

//export _gotk4_gtk3_TreeModelIface_unref_node
func _gotk4_gtk3_TreeModelIface_unref_node(arg0 *C.GtkTreeModel, arg1 *C.GtkTreeIter) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(TreeModelOverrider)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	iface.UnrefNode(_iter)
}

func wrapTreeModel(obj *externglib.Object) *TreeModel {
	return &TreeModel{
		Object: obj,
	}
}

func marshalTreeModel(p uintptr) (interface{}, error) {
	return wrapTreeModel(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_TreeModel_ConnectRowChanged
func _gotk4_gtk3_TreeModel_ConnectRowChanged(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.guintptr) {
	var f func(path *TreePath, iter *TreeIter)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, iter *TreeIter))
	}

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_path, _iter)
}

// ConnectRowChanged: this signal is emitted when a row in the model has
// changed.
func (childModel *TreeModel) ConnectRowChanged(f func(path *TreePath, iter *TreeIter)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(childModel, "row-changed", false, unsafe.Pointer(C._gotk4_gtk3_TreeModel_ConnectRowChanged), f)
}

//export _gotk4_gtk3_TreeModel_ConnectRowDeleted
func _gotk4_gtk3_TreeModel_ConnectRowDeleted(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 C.guintptr) {
	var f func(path *TreePath)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath))
	}

	var _path *TreePath // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	f(_path)
}

// ConnectRowDeleted: this signal is emitted when a row has been deleted.
//
// Note that no iterator is passed to the signal handler, since the row is
// already deleted.
//
// This should be called by models after a row has been removed. The location
// pointed to by path should be the location that the row previously was at. It
// may not be a valid location anymore.
func (childModel *TreeModel) ConnectRowDeleted(f func(path *TreePath)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(childModel, "row-deleted", false, unsafe.Pointer(C._gotk4_gtk3_TreeModel_ConnectRowDeleted), f)
}

//export _gotk4_gtk3_TreeModel_ConnectRowHasChildToggled
func _gotk4_gtk3_TreeModel_ConnectRowHasChildToggled(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.guintptr) {
	var f func(path *TreePath, iter *TreeIter)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, iter *TreeIter))
	}

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_path, _iter)
}

// ConnectRowHasChildToggled: this signal is emitted when a row has gotten the
// first child row or lost its last child row.
func (childModel *TreeModel) ConnectRowHasChildToggled(f func(path *TreePath, iter *TreeIter)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(childModel, "row-has-child-toggled", false, unsafe.Pointer(C._gotk4_gtk3_TreeModel_ConnectRowHasChildToggled), f)
}

//export _gotk4_gtk3_TreeModel_ConnectRowInserted
func _gotk4_gtk3_TreeModel_ConnectRowInserted(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.guintptr) {
	var f func(path *TreePath, iter *TreeIter)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, iter *TreeIter))
	}

	var _path *TreePath // out
	var _iter *TreeIter // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_path, _iter)
}

// ConnectRowInserted: this signal is emitted when a new row has been inserted
// in the model.
//
// Note that the row may still be empty at this point, since it is a common
// pattern to first insert an empty row, and then fill it with the desired
// values.
func (childModel *TreeModel) ConnectRowInserted(f func(path *TreePath, iter *TreeIter)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(childModel, "row-inserted", false, unsafe.Pointer(C._gotk4_gtk3_TreeModel_ConnectRowInserted), f)
}

//export _gotk4_gtk3_TreeModel_ConnectRowsReordered
func _gotk4_gtk3_TreeModel_ConnectRowsReordered(arg0 C.gpointer, arg1 *C.GtkTreePath, arg2 *C.GtkTreeIter, arg3 C.gpointer, arg4 C.guintptr) {
	var f func(path *TreePath, iter *TreeIter, newOrder cgo.Handle)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(path *TreePath, iter *TreeIter, newOrder cgo.Handle))
	}

	var _path *TreePath      // out
	var _iter *TreeIter      // out
	var _newOrder cgo.Handle // out

	_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_newOrder = (cgo.Handle)(unsafe.Pointer(arg3))

	f(_path, _iter, _newOrder)
}

// ConnectRowsReordered: this signal is emitted when the children of a node in
// the TreeModel have been reordered.
//
// Note that this signal is not emitted when rows are reordered by DND, since
// this is implemented by removing and then reinserting the row.
func (childModel *TreeModel) ConnectRowsReordered(f func(path *TreePath, iter *TreeIter, newOrder cgo.Handle)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(childModel, "rows-reordered", false, unsafe.Pointer(C._gotk4_gtk3_TreeModel_ConnectRowsReordered), f)
}

// ForEach calls func on each node in model in a depth-first fashion.
//
// If func returns TRUE, then the tree ceases to be walked, and
// gtk_tree_model_foreach() returns.
//
// The function takes the following parameters:
//
//    - fn: function to be called on each row.
//
func (model *TreeModel) ForEach(fn TreeModelForEachFunc) {
	var _arg0 *C.GtkTreeModel           // out
	var _arg1 C.GtkTreeModelForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(model).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk3_TreeModelForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_tree_model_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(fn)
}

// ColumnType returns the type of the column.
//
// The function takes the following parameters:
//
//    - index_: column index.
//
// The function returns the following values:
//
//    - gType: type of the column.
//
func (treeModel *TreeModel) ColumnType(index_ int) externglib.Type {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.gint          // out
	var _cret C.GType         // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = C.gint(index_)

	_cret = C.gtk_tree_model_get_column_type(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(index_)

	var _gType externglib.Type // out

	_gType = externglib.Type(_cret)

	return _gType
}

// Flags returns a set of flags supported by this interface.
//
// The flags are a bitwise combination of TreeModelFlags. The flags supported
// should not change during the lifetime of the tree_model.
//
// The function returns the following values:
//
//    - treeModelFlags flags supported by this interface.
//
func (treeModel *TreeModel) Flags() TreeModelFlags {
	var _arg0 *C.GtkTreeModel     // out
	var _cret C.GtkTreeModelFlags // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))

	_cret = C.gtk_tree_model_get_flags(_arg0)
	runtime.KeepAlive(treeModel)

	var _treeModelFlags TreeModelFlags // out

	_treeModelFlags = TreeModelFlags(_cret)

	return _treeModelFlags
}

// Iter sets iter to a valid iterator pointing to path. If path does not exist,
// iter is set to an invalid iterator and FALSE is returned.
//
// The function takes the following parameters:
//
//    - path: TreePath-struct.
//
// The function returns the following values:
//
//    - iter: uninitialized TreeIter-struct.
//    - ok: TRUE, if iter was set.
//
func (treeModel *TreeModel) Iter(path *TreePath) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreePath  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_model_get_iter(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterFirst initializes iter with the first iterator in the tree (the one at
// the path "0") and returns TRUE. Returns FALSE if the tree is empty.
//
// The function returns the following values:
//
//    - iter: uninitialized TreeIter-struct.
//    - ok: TRUE, if iter was set.
//
func (treeModel *TreeModel) IterFirst() (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))

	_cret = C.gtk_tree_model_get_iter_first(_arg0, &_arg1)
	runtime.KeepAlive(treeModel)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterFromString sets iter to a valid iterator pointing to path_string, if it
// exists. Otherwise, iter is left invalid and FALSE is returned.
//
// The function takes the following parameters:
//
//    - pathString: string representation of a TreePath-struct.
//
// The function returns the following values:
//
//    - iter: uninitialized TreeIter-struct.
//    - ok: TRUE, if iter was set.
//
func (treeModel *TreeModel) IterFromString(pathString string) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.gchar        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(pathString)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_tree_model_get_iter_from_string(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(pathString)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// NColumns returns the number of columns supported by tree_model.
//
// The function returns the following values:
//
//    - gint: number of columns.
//
func (treeModel *TreeModel) NColumns() int {
	var _arg0 *C.GtkTreeModel // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))

	_cret = C.gtk_tree_model_get_n_columns(_arg0)
	runtime.KeepAlive(treeModel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Path returns a newly-created TreePath-struct referenced by iter.
//
// This path should be freed with gtk_tree_path_free().
//
// The function takes the following parameters:
//
//    - iter: TreeIter-struct.
//
// The function returns the following values:
//
//    - treePath: newly-created TreePath-struct.
//
func (treeModel *TreeModel) Path(iter *TreeIter) *TreePath {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.GtkTreePath  // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_get_path(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// StringFromIter generates a string representation of the iter.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string.
//
// The function takes the following parameters:
//
//    - iter: TreeIter-struct.
//
// The function returns the following values:
//
//    - utf8: newly-allocated string. Must be freed with g_free().
//
func (treeModel *TreeModel) StringFromIter(iter *TreeIter) string {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.gchar        // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_get_string_from_iter(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Value initializes and sets value to that at column.
//
// When done with value, g_value_unset() needs to be called to free any
// allocated memory.
//
// The function takes the following parameters:
//
//    - iter: TreeIter-struct.
//    - column to lookup the value at.
//
// The function returns the following values:
//
//    - value: empty #GValue to set.
//
func (treeModel *TreeModel) Value(iter *TreeIter, column int) externglib.Value {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.gint          // out
	var _arg3 C.GValue        // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.gint(column)

	C.gtk_tree_model_get_value(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(column)

	var _value externglib.Value // out

	_value = *externglib.ValueFromNative(unsafe.Pointer((&_arg3)))

	return _value
}

// IterChildren sets iter to point to the first child of parent.
//
// If parent has no children, FALSE is returned and iter is set to be invalid.
// parent will remain a valid node after this function has been called.
//
// If parent is NULL returns the first node, equivalent to
// gtk_tree_model_get_iter_first (tree_model, iter);.
//
// The function takes the following parameters:
//
//    - parent (optional) or NULL.
//
// The function returns the following values:
//
//    - iter: new TreeIter-struct to be set to the child.
//    - ok: TRUE, if iter has been set to the first child.
//
func (treeModel *TreeModel) IterChildren(parent *TreeIter) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}

	_cret = C.gtk_tree_model_iter_children(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(parent)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterHasChild returns TRUE if iter has children, FALSE otherwise.
//
// The function takes the following parameters:
//
//    - iter to test for children.
//
// The function returns the following values:
//
//    - ok: TRUE if iter has children.
//
func (treeModel *TreeModel) IterHasChild(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_iter_has_child(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterNChildren returns the number of children that iter has.
//
// As a special case, if iter is NULL, then the number of toplevel nodes is
// returned.
//
// The function takes the following parameters:
//
//    - iter (optional) or NULL.
//
// The function returns the following values:
//
//    - gint: number of children of iter.
//
func (treeModel *TreeModel) IterNChildren(iter *TreeIter) int {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gint          // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	if iter != nil {
		_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	_cret = C.gtk_tree_model_iter_n_children(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IterNext sets iter to point to the node following it at the current level.
//
// If there is no next iter, FALSE is returned and iter is set to be invalid.
//
// The function takes the following parameters:
//
//    - iter: TreeIter-struct.
//
// The function returns the following values:
//
//    - ok: TRUE if iter has been changed to the next node.
//
func (treeModel *TreeModel) IterNext(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_iter_next(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterNthChild sets iter to be the child of parent, using the given index.
//
// The first index is 0. If n is too big, or parent has no children, iter is set
// to an invalid iterator and FALSE is returned. parent will remain a valid node
// after this function has been called. As a special case, if parent is NULL,
// then the n-th root node is set.
//
// The function takes the following parameters:
//
//    - parent (optional) to get the child from, or NULL.
//    - n: index of the desired child.
//
// The function returns the following values:
//
//    - iter to set to the nth child.
//    - ok: TRUE, if parent has an n-th child.
//
func (treeModel *TreeModel) IterNthChild(parent *TreeIter, n int) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.gint          // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}
	_arg3 = C.gint(n)

	_cret = C.gtk_tree_model_iter_nth_child(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(n)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterParent sets iter to be the parent of child.
//
// If child is at the toplevel, and doesn’t have a parent, then iter is set to
// an invalid iterator and FALSE is returned. child will remain a valid node
// after this function has been called.
//
// iter will be initialized before the lookup is performed, so child and iter
// cannot point to the same memory location.
//
// The function takes the following parameters:
//
//    - child: TreeIter-struct.
//
// The function returns the following values:
//
//    - iter: new TreeIter-struct to set to the parent.
//    - ok: TRUE, if iter is set to the parent of child.
//
func (treeModel *TreeModel) IterParent(child *TreeIter) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(child)))

	_cret = C.gtk_tree_model_iter_parent(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(child)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterPrevious sets iter to point to the previous node at the current level.
//
// If there is no previous iter, FALSE is returned and iter is set to be
// invalid.
//
// The function takes the following parameters:
//
//    - iter: TreeIter-struct.
//
// The function returns the following values:
//
//    - ok: TRUE if iter has been changed to the previous node.
//
func (treeModel *TreeModel) IterPrevious(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_iter_previous(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RefNode lets the tree ref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
//
// This function is primarily meant as a way for views to let caching models
// know when nodes are being displayed (and hence, whether or not to cache that
// node). Being displayed means a node is in an expanded branch, regardless of
// whether the node is currently visible in the viewport. For example, a
// file-system based model would not want to keep the entire file-hierarchy in
// memory, just the sections that are currently being displayed by every current
// view.
//
// A model should be expected to be able to get an iter independent of its
// reffed state.
//
// The function takes the following parameters:
//
//    - iter: TreeIter-struct.
//
func (treeModel *TreeModel) RefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_ref_node(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
}

// RowChanged emits the TreeModel::row-changed signal on tree_model.
//
// The function takes the following parameters:
//
//    - path pointing to the changed row.
//    - iter: valid TreeIter-struct pointing to the changed row.
//
func (treeModel *TreeModel) RowChanged(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_row_changed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// RowDeleted emits the TreeModel::row-deleted signal on tree_model.
//
// This should be called by models after a row has been removed. The location
// pointed to by path should be the location that the row previously was at. It
// may not be a valid location anymore.
//
// Nodes that are deleted are not unreffed, this means that any outstanding
// references on the deleted node should not be released.
//
// The function takes the following parameters:
//
//    - path pointing to the previous location of the deleted row.
//
func (treeModel *TreeModel) RowDeleted(path *TreePath) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_model_row_deleted(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
}

// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
// tree_model. This should be called by models after the child state of a node
// changes.
//
// The function takes the following parameters:
//
//    - path pointing to the changed row.
//    - iter: valid TreeIter-struct pointing to the changed row.
//
func (treeModel *TreeModel) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_row_has_child_toggled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// RowInserted emits the TreeModel::row-inserted signal on tree_model.
//
// The function takes the following parameters:
//
//    - path pointing to the inserted row.
//    - iter: valid TreeIter-struct pointing to the inserted row.
//
func (treeModel *TreeModel) RowInserted(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_row_inserted(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// RowsReordered emits the TreeModel::rows-reordered signal on tree_model.
//
// This should be called by models when their rows have been reordered.
//
// The function takes the following parameters:
//
//    - path pointing to the tree node whose children have been reordered.
//    - iter (optional): valid TreeIter-struct pointing to the node whose
//      children have been reordered, or NULL if the depth of path is 0.
//    - newOrder: array of integers mapping the current position of each child to
//      its old position before the re-ordering, i.e. new_order[newpos] = oldpos.
//
func (treeModel *TreeModel) RowsReordered(path *TreePath, iter *TreeIter, newOrder []int) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 *C.gint         // out
	var _arg4 C.gint

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if iter != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}
	_arg4 = (C.gint)(len(newOrder))
	_arg3 = (*C.gint)(C.calloc(C.size_t(len(newOrder)), C.size_t(C.sizeof_gint)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.gint)(_arg3), len(newOrder))
		for i := range newOrder {
			out[i] = C.gint(newOrder[i])
		}
	}

	C.gtk_tree_model_rows_reordered_with_length(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(newOrder)
}

// UnrefNode lets the tree unref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
// For more information on what this means, see gtk_tree_model_ref_node().
//
// Please note that nodes that are deleted are not unreffed.
//
// The function takes the following parameters:
//
//    - iter: TreeIter-struct.
//
func (treeModel *TreeModel) UnrefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_unref_node(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
}

// TreeIter is the primary structure for accessing a TreeModel. Models are
// expected to put a unique integer in the stamp member, and put model-specific
// data in the three user_data members.
//
// An instance of this type is always passed by reference.
type TreeIter struct {
	*treeIter
}

// treeIter is the struct that's finalized.
type treeIter struct {
	native *C.GtkTreeIter
}

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreeIter{&treeIter{(*C.GtkTreeIter)(b)}}, nil
}

// Stamp: unique stamp to catch invalid iterators.
func (t *TreeIter) Stamp() int {
	var v int // out
	v = int(t.native.stamp)
	return v
}

// UserData: model-specific data.
func (t *TreeIter) UserData() cgo.Handle {
	var v cgo.Handle // out
	v = (cgo.Handle)(unsafe.Pointer(t.native.user_data))
	return v
}

// UserData2: model-specific data.
func (t *TreeIter) UserData2() cgo.Handle {
	var v cgo.Handle // out
	v = (cgo.Handle)(unsafe.Pointer(t.native.user_data2))
	return v
}

// UserData3: model-specific data.
func (t *TreeIter) UserData3() cgo.Handle {
	var v cgo.Handle // out
	v = (cgo.Handle)(unsafe.Pointer(t.native.user_data3))
	return v
}

// Copy creates a dynamically allocated tree iterator as a copy of iter.
//
// This function is not intended for use in applications, because you can just
// copy the structs by value (GtkTreeIter new_iter = iter;). You must free this
// iter with gtk_tree_iter_free().
//
// The function returns the following values:
//
//    - treeIter: newly-allocated copy of iter.
//
func (iter *TreeIter) Copy() *TreeIter {
	var _arg0 *C.GtkTreeIter // out
	var _cret *C.GtkTreeIter // in

	_arg0 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_iter_copy(_arg0)
	runtime.KeepAlive(iter)

	var _treeIter *TreeIter // out

	_treeIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treeIter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_iter_free((*C.GtkTreeIter)(intern.C))
		},
	)

	return _treeIter
}

// TreePath: instance of this type is always passed by reference.
type TreePath struct {
	*treePath
}

// treePath is the struct that's finalized.
type treePath struct {
	native *C.GtkTreePath
}

func marshalTreePath(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreePath{&treePath{(*C.GtkTreePath)(b)}}, nil
}

// NewTreePath constructs a struct TreePath.
func NewTreePath() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new()

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// NewTreePathFirst constructs a struct TreePath.
func NewTreePathFirst() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new_first()

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// NewTreePathFromIndices constructs a struct TreePath.
func NewTreePathFromIndices(indices []int) *TreePath {
	var _arg1 *C.gint // out
	var _arg2 C.gsize
	var _cret *C.GtkTreePath // in

	_arg2 = (C.gsize)(len(indices))
	_arg1 = (*C.gint)(C.calloc(C.size_t(len(indices)), C.size_t(C.sizeof_gint)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.gint)(_arg1), len(indices))
		for i := range indices {
			out[i] = C.gint(indices[i])
		}
	}

	_cret = C.gtk_tree_path_new_from_indicesv(_arg1, _arg2)
	runtime.KeepAlive(indices)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// NewTreePathFromString constructs a struct TreePath.
func NewTreePathFromString(path string) *TreePath {
	var _arg1 *C.gchar       // out
	var _cret *C.GtkTreePath // in

	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_tree_path_new_from_string(_arg1)
	runtime.KeepAlive(path)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// AppendIndex appends a new index to a path.
//
// As a result, the depth of the path is increased.
//
// The function takes the following parameters:
//
//    - index_: index.
//
func (path *TreePath) AppendIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(index_)

	C.gtk_tree_path_append_index(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(index_)
}

// Compare compares two paths.
//
// If a appears before b in a tree, then -1 is returned. If b appears before a,
// then 1 is returned. If the two nodes are equal, then 0 is returned.
//
// The function takes the following parameters:
//
//    - b to compare with.
//
// The function returns the following values:
//
//    - gint: relative positions of a and b.
//
func (a *TreePath) Compare(b *TreePath) int {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(a)))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(b)))

	_cret = C.gtk_tree_path_compare(_arg0, _arg1)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Copy creates a new TreePath-struct as a copy of path.
//
// The function returns the following values:
//
//    - treePath: new TreePath-struct.
//
func (path *TreePath) Copy() *TreePath {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_copy(_arg0)
	runtime.KeepAlive(path)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// Down moves path to point to the first child of the current path.
func (path *TreePath) Down() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_path_down(_arg0)
	runtime.KeepAlive(path)
}

// Depth returns the current depth of path.
//
// The function returns the following values:
//
//    - gint: depth of path.
//
func (path *TreePath) Depth() int {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_get_depth(_arg0)
	runtime.KeepAlive(path)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Indices returns the current indices of path.
//
// This is an array of integers, each representing a node in a tree. It also
// returns the number of elements in the array. The array should not be freed.
//
// The function returns the following values:
//
//    - gints: current indices, or NULL.
//
func (path *TreePath) Indices() []int {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.gint        // in
	var _arg1 C.gint         // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_get_indices_with_depth(_arg0, &_arg1)
	runtime.KeepAlive(path)

	var _gints []int // out

	{
		src := unsafe.Slice((*C.gint)(_cret), _arg1)
		_gints = make([]int, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_gints[i] = int(src[i])
		}
	}

	return _gints
}

// IsAncestor returns TRUE if descendant is a descendant of path.
//
// The function takes the following parameters:
//
//    - descendant: another TreePath-struct.
//
// The function returns the following values:
//
//    - ok: TRUE if descendant is contained inside path.
//
func (path *TreePath) IsAncestor(descendant *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(descendant)))

	_cret = C.gtk_tree_path_is_ancestor(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(descendant)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDescendant returns TRUE if path is a descendant of ancestor.
//
// The function takes the following parameters:
//
//    - ancestor: another TreePath-struct.
//
// The function returns the following values:
//
//    - ok: TRUE if ancestor contains path somewhere below it.
//
func (path *TreePath) IsDescendant(ancestor *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(ancestor)))

	_cret = C.gtk_tree_path_is_descendant(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next moves the path to point to the next node at the current depth.
func (path *TreePath) Next() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_path_next(_arg0)
	runtime.KeepAlive(path)
}

// PrependIndex prepends a new index to a path.
//
// As a result, the depth of the path is increased.
//
// The function takes the following parameters:
//
//    - index_: index.
//
func (path *TreePath) PrependIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.gint         // out

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.gint(index_)

	C.gtk_tree_path_prepend_index(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(index_)
}

// Prev moves the path to point to the previous node at the current depth, if it
// exists.
//
// The function returns the following values:
//
//    - ok: TRUE if path has a previous node, and the move was made.
//
func (path *TreePath) Prev() bool {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_prev(_arg0)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String generates a string representation of the path.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string.
//
// The function returns the following values:
//
//    - utf8: newly-allocated string. Must be freed with g_free().
//
func (path *TreePath) String() string {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.gchar       // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_to_string(_arg0)
	runtime.KeepAlive(path)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Up moves the path to point to its parent node, if it has a parent.
//
// The function returns the following values:
//
//    - ok: TRUE if path has a parent, and the move was made.
//
func (path *TreePath) Up() bool {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_up(_arg0)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeRowReference tracks model changes so that it always refers to the same
// row (a TreePath refers to a position, not a fixed row). Create a new
// GtkTreeRowReference with gtk_tree_row_reference_new().
//
// An instance of this type is always passed by reference.
type TreeRowReference struct {
	*treeRowReference
}

// treeRowReference is the struct that's finalized.
type treeRowReference struct {
	native *C.GtkTreeRowReference
}

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreeRowReference{&treeRowReference{(*C.GtkTreeRowReference)(b)}}, nil
}

// NewTreeRowReference constructs a struct TreeRowReference.
func NewTreeRowReference(model TreeModeller, path *TreePath) *TreeRowReference {
	var _arg1 *C.GtkTreeModel        // out
	var _arg2 *C.GtkTreePath         // out
	var _cret *C.GtkTreeRowReference // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(model).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_row_reference_new(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(path)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = (*TreeRowReference)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treeRowReference)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_row_reference_free((*C.GtkTreeRowReference)(intern.C))
		},
	)

	return _treeRowReference
}

// NewTreeRowReferenceProxy constructs a struct TreeRowReference.
func NewTreeRowReferenceProxy(proxy *externglib.Object, model TreeModeller, path *TreePath) *TreeRowReference {
	var _arg1 *C.GObject             // out
	var _arg2 *C.GtkTreeModel        // out
	var _arg3 *C.GtkTreePath         // out
	var _cret *C.GtkTreeRowReference // in

	_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
	_arg2 = (*C.GtkTreeModel)(unsafe.Pointer(externglib.InternObject(model).Native()))
	_arg3 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_row_reference_new_proxy(_arg1, _arg2, _arg3)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(model)
	runtime.KeepAlive(path)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = (*TreeRowReference)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treeRowReference)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_row_reference_free((*C.GtkTreeRowReference)(intern.C))
		},
	)

	return _treeRowReference
}

// Copy copies a TreeRowReference.
//
// The function returns the following values:
//
//    - treeRowReference: copy of reference.
//
func (reference *TreeRowReference) Copy() *TreeRowReference {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreeRowReference // in

	_arg0 = (*C.GtkTreeRowReference)(gextras.StructNative(unsafe.Pointer(reference)))

	_cret = C.gtk_tree_row_reference_copy(_arg0)
	runtime.KeepAlive(reference)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = (*TreeRowReference)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treeRowReference)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_row_reference_free((*C.GtkTreeRowReference)(intern.C))
		},
	)

	return _treeRowReference
}

// Model returns the model that the row reference is monitoring.
//
// The function returns the following values:
//
//    - treeModel: model.
//
func (reference *TreeRowReference) Model() TreeModeller {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreeModel        // in

	_arg0 = (*C.GtkTreeRowReference)(gextras.StructNative(unsafe.Pointer(reference)))

	_cret = C.gtk_tree_row_reference_get_model(_arg0)
	runtime.KeepAlive(reference)

	var _treeModel TreeModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.TreeModeller is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(TreeModeller)
			return ok
		})
		rv, ok := casted.(TreeModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.TreeModeller")
		}
		_treeModel = rv
	}

	return _treeModel
}

// Path returns a path that the row reference currently points to, or NULL if
// the path pointed to is no longer valid.
//
// The function returns the following values:
//
//    - treePath (optional): current path, or NULL.
//
func (reference *TreeRowReference) Path() *TreePath {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreePath         // in

	_arg0 = (*C.GtkTreeRowReference)(gextras.StructNative(unsafe.Pointer(reference)))

	_cret = C.gtk_tree_row_reference_get_path(_arg0)
	runtime.KeepAlive(reference)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// Valid returns TRUE if the reference is non-NULL and refers to a current valid
// path.
//
// The function returns the following values:
//
//    - ok: TRUE if reference points to a valid path.
//
func (reference *TreeRowReference) Valid() bool {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret C.gboolean             // in

	if reference != nil {
		_arg0 = (*C.GtkTreeRowReference)(gextras.StructNative(unsafe.Pointer(reference)))
	}

	_cret = C.gtk_tree_row_reference_valid(_arg0)
	runtime.KeepAlive(reference)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeRowReferenceDeleted lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-deleted signal.
//
// The function takes the following parameters:
//
//    - proxy: #GObject.
//    - path position that was deleted.
//
func TreeRowReferenceDeleted(proxy *externglib.Object, path *TreePath) {
	var _arg1 *C.GObject     // out
	var _arg2 *C.GtkTreePath // out

	_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_row_reference_deleted(_arg1, _arg2)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(path)
}

// TreeRowReferenceInserted lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-inserted signal.
//
// The function takes the following parameters:
//
//    - proxy: #GObject.
//    - path: row position that was inserted.
//
func TreeRowReferenceInserted(proxy *externglib.Object, path *TreePath) {
	var _arg1 *C.GObject     // out
	var _arg2 *C.GtkTreePath // out

	_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_row_reference_inserted(_arg1, _arg2)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(path)
}

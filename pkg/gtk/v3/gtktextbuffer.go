// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gtk3_TextBufferClass_apply_tag(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtk3_TextBufferClass_begin_user_action(GtkTextBuffer*);
// extern void _gotk4_gtk3_TextBufferClass_changed(GtkTextBuffer*);
// extern void _gotk4_gtk3_TextBufferClass_delete_range(GtkTextBuffer*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtk3_TextBufferClass_end_user_action(GtkTextBuffer*);
// extern void _gotk4_gtk3_TextBufferClass_insert_child_anchor(GtkTextBuffer*, GtkTextIter*, GtkTextChildAnchor*);
// extern void _gotk4_gtk3_TextBufferClass_insert_pixbuf(GtkTextBuffer*, GtkTextIter*, GdkPixbuf*);
// extern void _gotk4_gtk3_TextBufferClass_insert_text(GtkTextBuffer*, GtkTextIter*, gchar*, gint);
// extern void _gotk4_gtk3_TextBufferClass_mark_deleted(GtkTextBuffer*, GtkTextMark*);
// extern void _gotk4_gtk3_TextBufferClass_mark_set(GtkTextBuffer*, GtkTextIter*, GtkTextMark*);
// extern void _gotk4_gtk3_TextBufferClass_modified_changed(GtkTextBuffer*);
// extern void _gotk4_gtk3_TextBufferClass_paste_done(GtkTextBuffer*, GtkClipboard*);
// extern void _gotk4_gtk3_TextBufferClass_remove_tag(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtk3_TextBuffer_ConnectApplyTag(gpointer, GtkTextTag*, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectBeginUserAction(gpointer, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectDeleteRange(gpointer, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectEndUserAction(gpointer, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectInsertChildAnchor(gpointer, GtkTextIter*, GtkTextChildAnchor*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectInsertPixbuf(gpointer, GtkTextIter*, GdkPixbuf*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectInsertText(gpointer, GtkTextIter*, gchar*, gint, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectMarkDeleted(gpointer, GtkTextMark*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectMarkSet(gpointer, GtkTextIter*, GtkTextMark*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectModifiedChanged(gpointer, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectPasteDone(gpointer, GtkClipboard*, guintptr);
// extern void _gotk4_gtk3_TextBuffer_ConnectRemoveTag(gpointer, GtkTextTag*, GtkTextIter*, GtkTextIter*, guintptr);
import "C"

// glib.Type values for gtktextbuffer.go.
var (
	GTypeTextBufferTargetInfo = coreglib.Type(C.gtk_text_buffer_target_info_get_type())
	GTypeTextBuffer           = coreglib.Type(C.gtk_text_buffer_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeTextBufferTargetInfo, F: marshalTextBufferTargetInfo},
		{T: GTypeTextBuffer, F: marshalTextBuffer},
	})
}

// TextBufferTargetInfo: these values are used as “info” for the targets
// contained in the lists returned by gtk_text_buffer_get_copy_target_list() and
// gtk_text_buffer_get_paste_target_list().
//
// The values counts down from -1 to avoid clashes with application added drag
// destinations which usually start at 0.
type TextBufferTargetInfo C.gint

const (
	// TextBufferTargetInfoBufferContents: buffer contents.
	TextBufferTargetInfoBufferContents TextBufferTargetInfo = -1
	// TextBufferTargetInfoRichText: rich text.
	TextBufferTargetInfoRichText TextBufferTargetInfo = -2
	// TextBufferTargetInfoText: text.
	TextBufferTargetInfoText TextBufferTargetInfo = -3
)

func marshalTextBufferTargetInfo(p uintptr) (interface{}, error) {
	return TextBufferTargetInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextBufferTargetInfo.
func (t TextBufferTargetInfo) String() string {
	switch t {
	case TextBufferTargetInfoBufferContents:
		return "BufferContents"
	case TextBufferTargetInfoRichText:
		return "RichText"
	case TextBufferTargetInfoText:
		return "Text"
	default:
		return fmt.Sprintf("TextBufferTargetInfo(%d)", t)
	}
}

// TextBufferOverrider contains methods that are overridable.
type TextBufferOverrider interface {
	// ApplyTag emits the “apply-tag” signal on buffer. The default handler for
	// the signal applies tag to the given range. start and end do not have to
	// be in order.
	//
	// The function takes the following parameters:
	//
	//    - tag: TextTag.
	//    - start: one bound of range to be tagged.
	//    - end: other bound of range to be tagged.
	//
	ApplyTag(tag *TextTag, start, end *TextIter)
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation. The operations between
	// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
	// can then be grouped when creating an undo stack. TextBuffer maintains a
	// count of calls to gtk_text_buffer_begin_user_action() that have not been
	// closed with a call to gtk_text_buffer_end_user_action(), and emits the
	// “begin-user-action” and “end-user-action” signals only for the outermost
	// pair of calls. This allows you to build user actions from other user
	// actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk_text_buffer_insert_interactive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	Changed()
	// The function takes the following parameters:
	//
	//    - start
	//    - end
	//
	DeleteRange(start, end *TextIter)
	// EndUserAction: should be paired with a call to
	// gtk_text_buffer_begin_user_action(). See that function for a full
	// explanation.
	EndUserAction()
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// iter. The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
	// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
	// this function. The buffer will add a reference to the anchor, so you can
	// unref it after insertion.
	//
	// The function takes the following parameters:
	//
	//    - iter: location to insert the anchor.
	//    - anchor: TextChildAnchor.
	//
	InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor)
	// InsertPixbuf inserts an image into the text buffer at iter. The image
	// will be counted as one character in character counts, and when obtaining
	// the buffer contents as a string, will be represented by the Unicode
	// “object replacement character” 0xFFFC. Note that the “slice” variants for
	// obtaining portions of the buffer as a string include this character for
	// pixbufs, but the “text” variants do not. e.g. see
	// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
	//
	// The function takes the following parameters:
	//
	//    - iter: location to insert the pixbuf.
	//    - pixbuf: Pixbuf.
	//
	InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf)
	// The function takes the following parameters:
	//
	//    - pos
	//    - newText
	//    - newTextLength
	//
	InsertText(pos *TextIter, newText string, newTextLength int32)
	// The function takes the following parameters:
	//
	MarkDeleted(mark *TextMark)
	// The function takes the following parameters:
	//
	//    - location
	//    - mark
	//
	MarkSet(location *TextIter, mark *TextMark)
	ModifiedChanged()
	// The function takes the following parameters:
	//
	PasteDone(clipboard *Clipboard)
	// RemoveTag emits the “remove-tag” signal. The default handler for the
	// signal removes all occurrences of tag from the given range. start and end
	// don’t have to be in order.
	//
	// The function takes the following parameters:
	//
	//    - tag: TextTag.
	//    - start: one bound of range to be untagged.
	//    - end: other bound of range to be untagged.
	//
	RemoveTag(tag *TextTag, start, end *TextIter)
}

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TextBuffer)(nil)
)

func classInitTextBufferer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkTextBufferClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkTextBufferClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface {
		ApplyTag(tag *TextTag, start, end *TextIter)
	}); ok {
		pclass.apply_tag = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_apply_tag)
	}

	if _, ok := goval.(interface{ BeginUserAction() }); ok {
		pclass.begin_user_action = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_begin_user_action)
	}

	if _, ok := goval.(interface{ Changed() }); ok {
		pclass.changed = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_changed)
	}

	if _, ok := goval.(interface{ DeleteRange(start, end *TextIter) }); ok {
		pclass.delete_range = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_delete_range)
	}

	if _, ok := goval.(interface{ EndUserAction() }); ok {
		pclass.end_user_action = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_end_user_action)
	}

	if _, ok := goval.(interface {
		InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor)
	}); ok {
		pclass.insert_child_anchor = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_insert_child_anchor)
	}

	if _, ok := goval.(interface {
		InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf)
	}); ok {
		pclass.insert_pixbuf = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_insert_pixbuf)
	}

	if _, ok := goval.(interface {
		InsertText(pos *TextIter, newText string, newTextLength int32)
	}); ok {
		pclass.insert_text = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_insert_text)
	}

	if _, ok := goval.(interface{ MarkDeleted(mark *TextMark) }); ok {
		pclass.mark_deleted = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_mark_deleted)
	}

	if _, ok := goval.(interface {
		MarkSet(location *TextIter, mark *TextMark)
	}); ok {
		pclass.mark_set = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_mark_set)
	}

	if _, ok := goval.(interface{ ModifiedChanged() }); ok {
		pclass.modified_changed = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_modified_changed)
	}

	if _, ok := goval.(interface{ PasteDone(clipboard *Clipboard) }); ok {
		pclass.paste_done = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_paste_done)
	}

	if _, ok := goval.(interface {
		RemoveTag(tag *TextTag, start, end *TextIter)
	}); ok {
		pclass.remove_tag = (*[0]byte)(C._gotk4_gtk3_TextBufferClass_remove_tag)
	}
}

//export _gotk4_gtk3_TextBufferClass_apply_tag
func _gotk4_gtk3_TextBufferClass_apply_tag(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		ApplyTag(tag *TextTag, start, end *TextIter)
	})

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	iface.ApplyTag(_tag, _start, _end)
}

//export _gotk4_gtk3_TextBufferClass_begin_user_action
func _gotk4_gtk3_TextBufferClass_begin_user_action(arg0 *C.GtkTextBuffer) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ BeginUserAction() })

	iface.BeginUserAction()
}

//export _gotk4_gtk3_TextBufferClass_changed
func _gotk4_gtk3_TextBufferClass_changed(arg0 *C.GtkTextBuffer) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Changed() })

	iface.Changed()
}

//export _gotk4_gtk3_TextBufferClass_delete_range
func _gotk4_gtk3_TextBufferClass_delete_range(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextIter) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ DeleteRange(start, end *TextIter) })

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	iface.DeleteRange(_start, _end)
}

//export _gotk4_gtk3_TextBufferClass_end_user_action
func _gotk4_gtk3_TextBufferClass_end_user_action(arg0 *C.GtkTextBuffer) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ EndUserAction() })

	iface.EndUserAction()
}

//export _gotk4_gtk3_TextBufferClass_insert_child_anchor
func _gotk4_gtk3_TextBufferClass_insert_child_anchor(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextChildAnchor) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor)
	})

	var _iter *TextIter          // out
	var _anchor *TextChildAnchor // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_anchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(arg2)))

	iface.InsertChildAnchor(_iter, _anchor)
}

//export _gotk4_gtk3_TextBufferClass_insert_pixbuf
func _gotk4_gtk3_TextBufferClass_insert_pixbuf(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GdkPixbuf) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf)
	})

	var _iter *TextIter           // out
	var _pixbuf *gdkpixbuf.Pixbuf // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	iface.InsertPixbuf(_iter, _pixbuf)
}

//export _gotk4_gtk3_TextBufferClass_insert_text
func _gotk4_gtk3_TextBufferClass_insert_text(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.gchar, arg3 C.gint) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		InsertText(pos *TextIter, newText string, newTextLength int32)
	})

	var _pos *TextIter       // out
	var _newText string      // out
	var _newTextLength int32 // out

	_pos = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_newText = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_newTextLength = int32(arg3)

	iface.InsertText(_pos, _newText, _newTextLength)
}

//export _gotk4_gtk3_TextBufferClass_mark_deleted
func _gotk4_gtk3_TextBufferClass_mark_deleted(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextMark) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ MarkDeleted(mark *TextMark) })

	var _mark *TextMark // out

	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg1)))

	iface.MarkDeleted(_mark)
}

//export _gotk4_gtk3_TextBufferClass_mark_set
func _gotk4_gtk3_TextBufferClass_mark_set(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextIter, arg2 *C.GtkTextMark) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		MarkSet(location *TextIter, mark *TextMark)
	})

	var _location *TextIter // out
	var _mark *TextMark     // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg2)))

	iface.MarkSet(_location, _mark)
}

//export _gotk4_gtk3_TextBufferClass_modified_changed
func _gotk4_gtk3_TextBufferClass_modified_changed(arg0 *C.GtkTextBuffer) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ModifiedChanged() })

	iface.ModifiedChanged()
}

//export _gotk4_gtk3_TextBufferClass_paste_done
func _gotk4_gtk3_TextBufferClass_paste_done(arg0 *C.GtkTextBuffer, arg1 *C.GtkClipboard) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ PasteDone(clipboard *Clipboard) })

	var _clipboard *Clipboard // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))

	iface.PasteDone(_clipboard)
}

//export _gotk4_gtk3_TextBufferClass_remove_tag
func _gotk4_gtk3_TextBufferClass_remove_tag(arg0 *C.GtkTextBuffer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		RemoveTag(tag *TextTag, start, end *TextIter)
	})

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	iface.RemoveTag(_tag, _start, _end)
}

func wrapTextBuffer(obj *coreglib.Object) *TextBuffer {
	return &TextBuffer{
		Object: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	return wrapTextBuffer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_TextBuffer_ConnectApplyTag
func _gotk4_gtk3_TextBuffer_ConnectApplyTag(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 C.guintptr) {
	var f func(tag *TextTag, start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag, start, end *TextIter))
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	f(_tag, _start, _end)
}

// ConnectApplyTag signal is emitted to apply a tag to a range of text in a
// TextBuffer. Applying actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk_text_buffer_apply_tag(), gtk_text_buffer_insert_with_tags(),
// gtk_text_buffer_insert_range().
func (buffer *TextBuffer) ConnectApplyTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "apply-tag", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectApplyTag), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectBeginUserAction
func _gotk4_gtk3_TextBuffer_ConnectBeginUserAction(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectBeginUserAction signal is emitted at the beginning of a single
// user-visible operation on a TextBuffer.
//
// See also: gtk_text_buffer_begin_user_action(),
// gtk_text_buffer_insert_interactive(),
// gtk_text_buffer_insert_range_interactive(),
// gtk_text_buffer_delete_interactive(), gtk_text_buffer_backspace(),
// gtk_text_buffer_delete_selection().
func (buffer *TextBuffer) ConnectBeginUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "begin-user-action", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectBeginUserAction), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectChanged
func _gotk4_gtk3_TextBuffer_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectChanged signal is emitted when the content of a TextBuffer has
// changed.
func (buffer *TextBuffer) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "changed", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectChanged), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectDeleteRange
func _gotk4_gtk3_TextBuffer_ConnectDeleteRange(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.GtkTextIter, arg3 C.guintptr) {
	var f func(start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(start, end *TextIter))
	}

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	f(_start, _end)
}

// ConnectDeleteRange signal is emitted to delete a range from a TextBuffer.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them). The default
// signal handler revalidates the start and end iters to both point to the
// location where text was deleted. Handlers which run after the default handler
// (see g_signal_connect_after()) do not have access to the deleted text.
//
// See also: gtk_text_buffer_delete().
func (buffer *TextBuffer) ConnectDeleteRange(f func(start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "delete-range", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectDeleteRange), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectEndUserAction
func _gotk4_gtk3_TextBuffer_ConnectEndUserAction(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectEndUserAction signal is emitted at the end of a single user-visible
// operation on the TextBuffer.
//
// See also: gtk_text_buffer_end_user_action(),
// gtk_text_buffer_insert_interactive(),
// gtk_text_buffer_insert_range_interactive(),
// gtk_text_buffer_delete_interactive(), gtk_text_buffer_backspace(),
// gtk_text_buffer_delete_selection(), gtk_text_buffer_backspace().
func (buffer *TextBuffer) ConnectEndUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "end-user-action", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectEndUserAction), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectInsertChildAnchor
func _gotk4_gtk3_TextBuffer_ConnectInsertChildAnchor(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.GtkTextChildAnchor, arg3 C.guintptr) {
	var f func(location *TextIter, anchor *TextChildAnchor)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, anchor *TextChildAnchor))
	}

	var _location *TextIter      // out
	var _anchor *TextChildAnchor // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_anchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(arg2)))

	f(_location, _anchor)
}

// ConnectInsertChildAnchor signal is emitted to insert a TextChildAnchor in a
// TextBuffer. Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted anchor.
//
// See also: gtk_text_buffer_insert_child_anchor().
func (buffer *TextBuffer) ConnectInsertChildAnchor(f func(location *TextIter, anchor *TextChildAnchor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-child-anchor", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectInsertChildAnchor), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectInsertPixbuf
func _gotk4_gtk3_TextBuffer_ConnectInsertPixbuf(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.GdkPixbuf, arg3 C.guintptr) {
	var f func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf))
	}

	var _location *TextIter       // out
	var _pixbuf *gdkpixbuf.Pixbuf // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	{
		obj := coreglib.Take(unsafe.Pointer(arg2))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	f(_location, _pixbuf)
}

// ConnectInsertPixbuf signal is emitted to insert a Pixbuf in a TextBuffer.
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted pixbuf.
//
// See also: gtk_text_buffer_insert_pixbuf().
func (buffer *TextBuffer) ConnectInsertPixbuf(f func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-pixbuf", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectInsertPixbuf), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectInsertText
func _gotk4_gtk3_TextBuffer_ConnectInsertText(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.gchar, arg3 C.gint, arg4 C.guintptr) {
	var f func(location *TextIter, text string, len int32)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, text string, len int32))
	}

	var _location *TextIter // out
	var _text string        // out
	var _len int32          // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_text = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_len = int32(arg3)

	f(_location, _text, _len)
}

// ConnectInsertText signal is emitted to insert text in a TextBuffer. Insertion
// actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to point to the end of the inserted text.
//
// See also: gtk_text_buffer_insert(), gtk_text_buffer_insert_range().
func (buffer *TextBuffer) ConnectInsertText(f func(location *TextIter, text string, len int32)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-text", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectInsertText), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectMarkDeleted
func _gotk4_gtk3_TextBuffer_ConnectMarkDeleted(arg0 C.gpointer, arg1 *C.GtkTextMark, arg2 C.guintptr) {
	var f func(mark *TextMark)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(mark *TextMark))
	}

	var _mark *TextMark // out

	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg1)))

	f(_mark)
}

// ConnectMarkDeleted signal is emitted as notification after a TextMark is
// deleted.
//
// See also: gtk_text_buffer_delete_mark().
func (buffer *TextBuffer) ConnectMarkDeleted(f func(mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "mark-deleted", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectMarkDeleted), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectMarkSet
func _gotk4_gtk3_TextBuffer_ConnectMarkSet(arg0 C.gpointer, arg1 *C.GtkTextIter, arg2 *C.GtkTextMark, arg3 C.guintptr) {
	var f func(location *TextIter, mark *TextMark)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(location *TextIter, mark *TextMark))
	}

	var _location *TextIter // out
	var _mark *TextMark     // out

	_location = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_mark = wrapTextMark(coreglib.Take(unsafe.Pointer(arg2)))

	f(_location, _mark)
}

// ConnectMarkSet signal is emitted as notification after a TextMark is set.
//
// See also: gtk_text_buffer_create_mark(), gtk_text_buffer_move_mark().
func (buffer *TextBuffer) ConnectMarkSet(f func(location *TextIter, mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "mark-set", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectMarkSet), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectModifiedChanged
func _gotk4_gtk3_TextBuffer_ConnectModifiedChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectModifiedChanged signal is emitted when the modified bit of a
// TextBuffer flips.
//
// See also: gtk_text_buffer_set_modified().
func (buffer *TextBuffer) ConnectModifiedChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "modified-changed", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectModifiedChanged), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectPasteDone
func _gotk4_gtk3_TextBuffer_ConnectPasteDone(arg0 C.gpointer, arg1 *C.GtkClipboard, arg2 C.guintptr) {
	var f func(clipboard *Clipboard)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg2))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(clipboard *Clipboard))
	}

	var _clipboard *Clipboard // out

	_clipboard = wrapClipboard(coreglib.Take(unsafe.Pointer(arg1)))

	f(_clipboard)
}

// ConnectPasteDone signal is emitted after paste operation has been completed.
// This is useful to properly scroll the view to the end of the pasted text. See
// gtk_text_buffer_paste_clipboard() for more details.
func (buffer *TextBuffer) ConnectPasteDone(f func(clipboard *Clipboard)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "paste-done", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectPasteDone), f)
}

//export _gotk4_gtk3_TextBuffer_ConnectRemoveTag
func _gotk4_gtk3_TextBuffer_ConnectRemoveTag(arg0 C.gpointer, arg1 *C.GtkTextTag, arg2 *C.GtkTextIter, arg3 *C.GtkTextIter, arg4 C.guintptr) {
	var f func(tag *TextTag, start, end *TextIter)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(tag *TextTag, start, end *TextIter))
	}

	var _tag *TextTag    // out
	var _start *TextIter // out
	var _end *TextIter   // out

	_tag = wrapTextTag(coreglib.Take(unsafe.Pointer(arg1)))
	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(arg3)))

	f(_tag, _start, _end)
}

// ConnectRemoveTag signal is emitted to remove all occurrences of tag from a
// range of text in a TextBuffer. Removal actually occurs in the default
// handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk_text_buffer_remove_tag().
func (buffer *TextBuffer) ConnectRemoveTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "remove-tag", false, unsafe.Pointer(C._gotk4_gtk3_TextBuffer_ConnectRemoveTag), f)
}

// NewTextBuffer creates a new text buffer.
//
// The function takes the following parameters:
//
//    - table (optional): tag table, or NULL to create a new one.
//
// The function returns the following values:
//
//    - textBuffer: new text buffer.
//
func NewTextBuffer(table *TextTagTable) *TextBuffer {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	if table != nil {
		_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	}
	*(**TextTagTable)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("new_TextBuffer", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(table)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textBuffer
}

// AddMark adds the mark at position where. The mark must not be added to
// another buffer, and if its name is not NULL then there must not be another
// mark in the buffer with the same name.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's initial
// placement.
//
// The function takes the following parameters:
//
//    - mark to add.
//    - where: location to place mark.
//
func (buffer *TextBuffer) AddMark(mark *TextMark, where *TextIter) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextMark)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("add_mark", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// AddSelectionClipboard adds clipboard to the list of clipboards in which the
// selection contents of buffer are available. In most cases, clipboard will be
// the Clipboard of type GDK_SELECTION_PRIMARY for a view of buffer.
//
// The function takes the following parameters:
//
//    - clipboard: Clipboard.
//
func (buffer *TextBuffer) AddSelectionClipboard(clipboard *Clipboard) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("add_selection_clipboard", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// ApplyTag emits the “apply-tag” signal on buffer. The default handler for the
// signal applies tag to the given range. start and end do not have to be in
// order.
//
// The function takes the following parameters:
//
//    - tag: TextTag.
//    - start: one bound of range to be tagged.
//    - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) ApplyTag(tag *TextTag, start, end *TextIter) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextTag)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("apply_tag", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag table to
// get a TextTag, then calls gtk_text_buffer_apply_tag().
//
// The function takes the following parameters:
//
//    - name of a named TextTag.
//    - start: one bound of range to be tagged.
//    - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) ApplyTagByName(name string, start, end *TextIter) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("apply_tag_by_name", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by iter. In the normal case a
// single character will be deleted, but when combining accents are involved,
// more than one character can be deleted, and when precomposed character and
// accent combinations are involved, less than one character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the iter will be re-initialized to
// point to the location where text was deleted.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - interactive: whether the deletion is caused by user interaction.
//    - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//    - ok: TRUE if the buffer was modified.
//
func (buffer *TextBuffer) Backspace(iter *TextIter, interactive, defaultEditable bool) bool {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.gboolean // out
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if interactive {
		_arg2 = C.TRUE
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(*bool)(unsafe.Pointer(&args[3])) = _arg3

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("backspace", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BeginUserAction: called to indicate that the buffer operations between here
// and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action() can
// then be grouped when creating an undo stack. TextBuffer maintains a count of
// calls to gtk_text_buffer_begin_user_action() that have not been closed with a
// call to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
// and “end-user-action” signals only for the outermost pair of calls. This
// allows you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end user
// action around the buffer operations they perform, so there's no need to add
// extra calls if you user action consists solely of a single call to one of
// those functions.
func (buffer *TextBuffer) BeginUserAction() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("begin_user_action", args[:], nil)

	runtime.KeepAlive(buffer)
}

// CopyClipboard copies the currently-selected text to a clipboard.
//
// The function takes the following parameters:
//
//    - clipboard object to copy to.
//
func (buffer *TextBuffer) CopyClipboard(clipboard *Clipboard) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("copy_clipboard", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// CreateChildAnchor: this is a convenience function which simply creates a
// child anchor with gtk_text_child_anchor_new() and inserts it into the buffer
// with gtk_text_buffer_insert_child_anchor(). The new anchor is owned by the
// buffer; no reference count is returned to the caller of
// gtk_text_buffer_create_child_anchor().
//
// The function takes the following parameters:
//
//    - iter: location in the buffer.
//
// The function returns the following values:
//
//    - textChildAnchor: created child anchor.
//
func (buffer *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("create_child_anchor", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// CreateMark creates a mark at position where. If mark_name is NULL, the mark
// is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is inserted
// at the mark’s current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity (left_gravity = FALSE),
// the mark will end up on the right of newly-inserted text. The standard
// left-to-right cursor is a mark with right gravity (when you type, the cursor
// stays on the right side of the text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's initial
// placement.
//
// The function takes the following parameters:
//
//    - markName (optional): name for mark, or NULL.
//    - where: location to place mark.
//    - leftGravity: whether the mark has left gravity.
//
// The function returns the following values:
//
//    - textMark: new TextMark object.
//
func (buffer *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 C.gboolean // out
	var _cret *C.void    // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if markName != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(markName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))
	if leftGravity {
		_arg3 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("create_mark", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(markName)
	runtime.KeepAlive(where)
	runtime.KeepAlive(leftGravity)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
//
// The function takes the following parameters:
//
//    - clipboard object to cut to.
//    - defaultEditable: default editability of the buffer.
//
func (buffer *TextBuffer) CutClipboard(clipboard *Clipboard, defaultEditable bool) {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if defaultEditable {
		_arg2 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**Clipboard)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("cut_clipboard", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(defaultEditable)
}

// Delete deletes text between start and end. The order of start and end is not
// actually relevant; gtk_text_buffer_delete() will reorder them. This function
// actually emits the “delete-range” signal, and the default handler of that
// signal deletes the text. Because the buffer is modified, all outstanding
// iterators become invalid after calling this function; however, the start and
// end will be re-initialized to point to the location where text was deleted.
//
// The function takes the following parameters:
//
//    - start: position in buffer.
//    - end: another position in buffer.
//
func (buffer *TextBuffer) Delete(start, end *TextIter) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// DeleteInteractive deletes all editable text in the given range. Calls
// gtk_text_buffer_delete() for each editable sub-range of [start,end). start
// and end are revalidated to point to the location of the last deleted range,
// or left untouched if no text was deleted.
//
// The function takes the following parameters:
//
//    - startIter: start of range to delete.
//    - endIter: end of range.
//    - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//    - ok: whether some text was actually deleted.
//
func (buffer *TextBuffer) DeleteInteractive(startIter, endIter *TextIter, defaultEditable bool) bool {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(startIter)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(endIter)))
	if defaultEditable {
		_arg3 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete_interactive", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(startIter)
	runtime.KeepAlive(endIter)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeleteMark deletes mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if you haven’t
// called g_object_ref() on the mark, it will be freed. Even if the mark isn’t
// freed, most operations on mark become invalid, until it gets added to a
// buffer again with gtk_text_buffer_add_mark(). Use gtk_text_mark_get_deleted()
// to find out if a mark has been removed from its buffer. The
// TextBuffer::mark-deleted signal will be emitted as notification after the
// mark is deleted.
//
// The function takes the following parameters:
//
//    - mark in buffer.
//
func (buffer *TextBuffer) DeleteMark(mark *TextMark) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete_mark", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
}

// DeleteMarkByName deletes the mark named name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
//
// The function takes the following parameters:
//
//    - name of a mark in buffer.
//
func (buffer *TextBuffer) DeleteMarkByName(name string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete_mark_by_name", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
}

// DeleteSelection deletes the range between the “insert” and “selection_bound”
// marks, that is, the currently-selected text. If interactive is TRUE, the
// editability of the selection will be considered (users can’t delete
// uneditable text).
//
// The function takes the following parameters:
//
//    - interactive: whether the deletion is caused by user interaction.
//    - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//    - ok: whether there was a non-empty selection to delete.
//
func (buffer *TextBuffer) DeleteSelection(interactive, defaultEditable bool) bool {
	var args [3]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out
	var _arg2 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if interactive {
		_arg1 = C.TRUE
	}
	if defaultEditable {
		_arg2 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(*bool)(unsafe.Pointer(&args[2])) = _arg2

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("delete_selection", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndUserAction: should be paired with a call to
// gtk_text_buffer_begin_user_action(). See that function for a full
// explanation.
func (buffer *TextBuffer) EndUserAction() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("end_user_action", args[:], nil)

	runtime.KeepAlive(buffer)
}

// CharCount gets the number of characters in the buffer; note that characters
// and bytes are not the same, you can’t e.g. expect the contents of the buffer
// in string form to be this many bytes long. The character count is cached, so
// this function is very fast.
//
// The function returns the following values:
//
//    - gint: number of characters in the buffer.
//
func (buffer *TextBuffer) CharCount() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_char_count", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// CopyTargetList: this function returns the list of targets this text buffer
// can provide for copying and as DND source. The targets in the list are added
// with info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
//
// The function returns the following values:
//
//    - targetList: TargetList.
//
func (buffer *TextBuffer) CopyTargetList() *TargetList {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_copy_target_list", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _targetList *TargetList // out

	_targetList = (*TargetList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_target_list_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_targetList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_target_list_unref((*C.GtkTargetList)(intern.C))
		},
	)

	return _targetList
}

// HasSelection indicates whether the buffer has some text currently selected.
//
// The function returns the following values:
//
//    - ok: TRUE if the there is text selected.
//
func (buffer *TextBuffer) HasSelection() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_has_selection", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetInsert returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
//
// The function returns the following values:
//
//    - textMark: insertion point mark.
//
func (buffer *TextBuffer) GetInsert() *TextMark {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_insert", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// LineCount obtains the number of lines in the buffer. This value is cached, so
// the function is very fast.
//
// The function returns the following values:
//
//    - gint: number of lines in the buffer.
//
func (buffer *TextBuffer) LineCount() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_line_count", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// Mark returns the mark named name in buffer buffer, or NULL if no such mark
// exists in the buffer.
//
// The function takes the following parameters:
//
//    - name: mark name.
//
// The function returns the following values:
//
//    - textMark (optional) or NULL.
//
func (buffer *TextBuffer) Mark(name string) *TextMark {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_mark", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _textMark *TextMark // out

	if _cret != nil {
		_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _textMark
}

// Modified indicates whether the buffer has been modified since the last call
// to gtk_text_buffer_set_modified() set the modification flag to FALSE. Used
// for example to enable a “save” function in a text editor.
//
// The function returns the following values:
//
//    - ok: TRUE if the buffer has been modified.
//
func (buffer *TextBuffer) Modified() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_modified", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PasteTargetList: this function returns the list of targets this text buffer
// supports for pasting and as DND destination. The targets in the list are
// added with info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
//
// The function returns the following values:
//
//    - targetList: TargetList.
//
func (buffer *TextBuffer) PasteTargetList() *TargetList {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_paste_target_list", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _targetList *TargetList // out

	_targetList = (*TargetList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_target_list_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_targetList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_target_list_unref((*C.GtkTargetList)(intern.C))
		},
	)

	return _targetList
}

// SelectionBound returns the mark that represents the selection bound.
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert” are
// in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a selection
// and what its bounds are.
//
// The function returns the following values:
//
//    - textMark: selection bound mark.
//
func (buffer *TextBuffer) SelectionBound() *TextMark {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_selection_bound", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// Slice returns the text in the range [start,end). Excludes undisplayed text
// (text marked with tags that set the invisibility attribute) if
// include_hidden_chars is FALSE. The returned string includes a 0xFFFC
// character whenever the buffer contains embedded images, so byte and character
// indexes into the returned string do correspond to byte and character indexes
// into the buffer. Contrast with gtk_text_buffer_get_text(). Note that 0xFFFC
// can occur in normal text as well, so it is not a reliable indicator that a
// pixbuf or widget is in the buffer.
//
// The function takes the following parameters:
//
//    - start of a range.
//    - end of a range.
//    - includeHiddenChars: whether to include invisible text.
//
// The function returns the following values:
//
//    - utf8: allocated UTF-8 string.
//
func (buffer *TextBuffer) Slice(start, end *TextIter, includeHiddenChars bool) string {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 C.gboolean // out
	var _cret *C.void    // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_slice", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// TagTable: get the TextTagTable associated with this buffer.
//
// The function returns the following values:
//
//    - textTagTable buffer’s tag table.
//
func (buffer *TextBuffer) TagTable() *TextTagTable {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_tag_table", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)

	var _textTagTable *TextTagTable // out

	_textTagTable = wrapTextTagTable(coreglib.Take(unsafe.Pointer(_cret)))

	return _textTagTable
}

// Text returns the text in the range [start,end). Excludes undisplayed text
// (text marked with tags that set the invisibility attribute) if
// include_hidden_chars is FALSE. Does not include characters representing
// embedded images, so byte and character indexes into the returned string do
// not correspond to byte and character indexes into the buffer. Contrast with
// gtk_text_buffer_get_slice().
//
// The function takes the following parameters:
//
//    - start of a range.
//    - end of a range.
//    - includeHiddenChars: whether to include invisible text.
//
// The function returns the following values:
//
//    - utf8: allocated UTF-8 string.
//
func (buffer *TextBuffer) Text(start, end *TextIter, includeHiddenChars bool) string {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 C.gboolean // out
	var _cret *C.void    // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("get_text", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts len bytes of text at position iter. If len is -1, text must be
// nul-terminated and will be inserted in its entirety. Emits the “insert-text”
// signal; insertion actually occurs in the default handler for the signal. iter
// is invalidated when insertion occurs (because the buffer contents change),
// but the default signal handler revalidates it to point to the end of the
// inserted text.
//
// The function takes the following parameters:
//
//    - iter: position in the buffer.
//    - text in UTF-8 format.
//
func (buffer *TextBuffer) Insert(iter *TextIter, text string) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 C.gint

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.gint)(len(text))
	_arg2 = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg2))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(*string)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
}

// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
//
// The function takes the following parameters:
//
//    - text in UTF-8 format.
//
func (buffer *TextBuffer) InsertAtCursor(text string) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.gint)(len(text))
	_arg1 = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_at_cursor", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at iter.
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the “text” variants do not. E.g. see gtk_text_buffer_get_slice()
// and gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
// this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
//
// The function takes the following parameters:
//
//    - iter: location to insert the anchor.
//    - anchor: TextChildAnchor.
//
func (buffer *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_child_anchor", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(anchor)
}

// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will not
// occur if iter is at a non-editable location in the buffer. Usually you want
// to prevent insertions at ineditable locations if the insertion results from a
// user action (is interactive).
//
// default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - text: some UTF-8 text.
//    - defaultEditable: default editability of buffer.
//
// The function returns the following values:
//
//    - ok: whether text was actually inserted.
//
func (buffer *TextBuffer) InsertInteractive(iter *TextIter, text string, defaultEditable bool) bool {
	var args [5]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 C.gint
	var _arg4 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.gint)(len(text))
	_arg2 = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg2))
	if defaultEditable {
		_arg4 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(*string)(unsafe.Pointer(&args[3])) = _arg3
	*(*bool)(unsafe.Pointer(&args[4])) = _arg4

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_interactive", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at the
// cursor position.
//
// default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
//
// The function takes the following parameters:
//
//    - text in UTF-8 format.
//    - defaultEditable: default editability of buffer.
//
// The function returns the following values:
//
//    - ok: whether text was actually inserted.
//
func (buffer *TextBuffer) InsertInteractiveAtCursor(text string, defaultEditable bool) bool {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.gint)(len(text))
	_arg1 = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	if defaultEditable {
		_arg3 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2
	*(*bool)(unsafe.Pointer(&args[3])) = _arg3

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_interactive_at_cursor", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertMarkup inserts the text in markup at position iter. markup will be
// inserted in its entirety and must be nul-terminated and valid UTF-8. Emits
// the TextBuffer::insert-text signal, possibly multiple times; insertion
// actually occurs in the default handler for the signal. iter will point to the
// end of the inserted text on return.
//
// The function takes the following parameters:
//
//    - iter: location to insert the markup.
//    - markup: nul-terminated UTF-8 string containing [Pango
//      markup][PangoMarkupFormat].
//
func (buffer *TextBuffer) InsertMarkup(iter *TextIter, markup string) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 C.gint

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.gint)(len(markup))
	_arg2 = (*C.void)(C.calloc(C.size_t((len(markup) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(markup)), markup)
	defer C.free(unsafe.Pointer(_arg2))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(*string)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_markup", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(markup)
}

// InsertPixbuf inserts an image into the text buffer at iter. The image will be
// counted as one character in character counts, and when obtaining the buffer
// contents as a string, will be represented by the Unicode “object replacement
// character” 0xFFFC. Note that the “slice” variants for obtaining portions of
// the buffer as a string include this character for pixbufs, but the “text”
// variants do not. e.g. see gtk_text_buffer_get_slice() and
// gtk_text_buffer_get_text().
//
// The function takes the following parameters:
//
//    - iter: location to insert the pixbuf.
//    - pixbuf: Pixbuf.
//
func (buffer *TextBuffer) InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_pixbuf", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(pixbuf)
}

// InsertRange copies text, tags, and pixbufs between start and end (the order
// of start and end doesn’t matter) and inserts the copy at iter. Used instead
// of simply getting/inserting text because it preserves images and tags. If
// start and end are in a different buffer from buffer, the two buffers must
// share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - start: position in a TextBuffer.
//    - end: another position in the same buffer as start.
//
func (buffer *TextBuffer) InsertRange(iter, start, end *TextIter) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_range", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
// nothing if the insertion point isn’t editable. The default_editable parameter
// indicates whether the text is editable at iter if no tags enclosing iter
// affect editability. Typically the result of gtk_text_view_get_editable() is
// appropriate here.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - start: position in a TextBuffer.
//    - end: another position in the same buffer as start.
//    - defaultEditable: default editability of the buffer.
//
// The function returns the following values:
//
//    - ok: whether an insertion was possible at iter.
//
func (buffer *TextBuffer) InsertRangeInteractive(iter, start, end *TextIter, defaultEditable bool) bool {
	var args [5]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 *C.void    // out
	var _arg4 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	if defaultEditable {
		_arg4 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3
	*(**TextIter)(unsafe.Pointer(&args[4])) = _arg4

	_gret := girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("insert_range_interactive", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMark moves mark to the new location where. Emits the TextBuffer::mark-set
// signal as notification of the move.
//
// The function takes the following parameters:
//
//    - mark: TextMark.
//    - where: new location for mark in buffer.
//
func (buffer *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextMark)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("move_mark", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// MoveMarkByName moves the mark named name (which must exist) to location
// where. See gtk_text_buffer_move_mark() for details.
//
// The function takes the following parameters:
//
//    - name of a mark.
//    - where: new location for mark.
//
func (buffer *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("move_mark_by_name", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(where)
}

// PasteClipboard pastes the contents of a clipboard. If override_location is
// NULL, the pasted text will be inserted at the cursor position, or the buffer
// selection will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
//
// The function takes the following parameters:
//
//    - clipboard to paste from.
//    - overrideLocation (optional): location to insert pasted text, or NULL.
//    - defaultEditable: whether the buffer is editable by default.
//
func (buffer *TextBuffer) PasteClipboard(clipboard *Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var args [4]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _arg2 *C.void    // out
	var _arg3 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if overrideLocation != nil {
		_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(overrideLocation)))
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**Clipboard)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("paste_clipboard", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(overrideLocation)
	runtime.KeepAlive(defaultEditable)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them to the same place in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
//
// The function takes the following parameters:
//
//    - where to put the cursor.
//
func (buffer *TextBuffer) PlaceCursor(where *TextIter) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(where)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("place_cursor", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(where)
}

// RemoveAllTags removes all tags in the range between start and end. Be careful
// with this function; it could remove tags added in code unrelated to the code
// you’re currently writing. That is, using this function is probably a bad idea
// if you have two or more unrelated code sections that add tags.
//
// The function takes the following parameters:
//
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveAllTags(start, end *TextIter) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("remove_all_tags", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveSelectionClipboard removes a Clipboard added with
// gtk_text_buffer_add_selection_clipboard().
//
// The function takes the following parameters:
//
//    - clipboard added to buffer by gtk_text_buffer_add_selection_clipboard().
//
func (buffer *TextBuffer) RemoveSelectionClipboard(clipboard *Clipboard) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("remove_selection_clipboard", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// RemoveTag emits the “remove-tag” signal. The default handler for the signal
// removes all occurrences of tag from the given range. start and end don’t have
// to be in order.
//
// The function takes the following parameters:
//
//    - tag: TextTag.
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveTag(tag *TextTag, start, end *TextIter) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextTag)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("remove_tag", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag table
// to get a TextTag, then calls gtk_text_buffer_remove_tag().
//
// The function takes the following parameters:
//
//    - name of a TextTag.
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveTagByName(name string, start, end *TextIter) {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2
	*(**TextIter)(unsafe.Pointer(&args[3])) = _arg3

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("remove_tag_by_name", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
//
// The function takes the following parameters:
//
//    - ins: where to put the “insert” mark.
//    - bound: where to put the “selection_bound” mark.
//
func (buffer *TextBuffer) SelectRange(ins, bound *TextIter) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(ins)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(bound)))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(**TextIter)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("select_range", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ins)
	runtime.KeepAlive(bound)
}

// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved. Whenever the buffer is saved to disk, call
// gtk_text_buffer_set_modified (buffer, FALSE). When the buffer is modified, it
// will automatically toggled on the modified bit again. When the modified bit
// flips, the buffer emits the TextBuffer::modified-changed signal.
//
// The function takes the following parameters:
//
//    - setting: modification flag setting.
//
func (buffer *TextBuffer) SetModified(setting bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if setting {
		_arg1 = C.TRUE
	}
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("set_modified", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(setting)
}

// SetText deletes current contents of buffer, and inserts text instead. If len
// is -1, text must be nul-terminated. text must be valid UTF-8.
//
// The function takes the following parameters:
//
//    - text: UTF-8 text to insert.
//
func (buffer *TextBuffer) SetText(text string) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.gint

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.gint)(len(text))
	_arg1 = (*C.void)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	*(**TextBuffer)(unsafe.Pointer(&args[1])) = _arg1
	*(*string)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "TextBuffer").InvokeMethod("set_text", args[:], nil)

	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
}

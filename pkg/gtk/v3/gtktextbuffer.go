// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
)

// #cgo pkg-config: gtk+-3.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_buffer_target_info_get_type()), F: marshalTextBufferTargetInfo},
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBufferer},
	})
}

// TextBufferTargetInfo: these values are used as “info” for the targets
// contained in the lists returned by gtk_text_buffer_get_copy_target_list() and
// gtk_text_buffer_get_paste_target_list().
//
// The values counts down from -1 to avoid clashes with application added drag
// destinations which usually start at 0.
type TextBufferTargetInfo int

const (
	// TextBufferTargetInfoBufferContents: buffer contents.
	TextBufferTargetInfoBufferContents TextBufferTargetInfo = -1
	// TextBufferTargetInfoRichText: rich text.
	TextBufferTargetInfoRichText TextBufferTargetInfo = -2
	// TextBufferTargetInfoText: text.
	TextBufferTargetInfoText TextBufferTargetInfo = -3
)

func marshalTextBufferTargetInfo(p uintptr) (interface{}, error) {
	return TextBufferTargetInfo(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextBufferTargetInfo.
func (t TextBufferTargetInfo) String() string {
	switch t {
	case TextBufferTargetInfoBufferContents:
		return "BufferContents"
	case TextBufferTargetInfoRichText:
		return "RichText"
	case TextBufferTargetInfoText:
		return "Text"
	default:
		return fmt.Sprintf("TextBufferTargetInfo(%d)", t)
	}
}

// TextBufferOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TextBufferOverrider interface {
	// ApplyTag emits the “apply-tag” signal on buffer. The default handler for
	// the signal applies tag to the given range. start and end do not have to
	// be in order.
	ApplyTag(tag *TextTag, start, end *TextIter)
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation. The operations between
	// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action()
	// can then be grouped when creating an undo stack. TextBuffer maintains a
	// count of calls to gtk_text_buffer_begin_user_action() that have not been
	// closed with a call to gtk_text_buffer_end_user_action(), and emits the
	// “begin-user-action” and “end-user-action” signals only for the outermost
	// pair of calls. This allows you to build user actions from other user
	// actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk_text_buffer_insert_interactive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	Changed()
	DeleteRange(start, end *TextIter)
	// EndUserAction: should be paired with a call to
	// gtk_text_buffer_begin_user_action(). See that function for a full
	// explanation.
	EndUserAction()
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// iter. The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk_text_buffer_get_slice() and gtk_text_buffer_get_text(). Consider
	// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
	// this function. The buffer will add a reference to the anchor, so you can
	// unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor)
	// InsertPixbuf inserts an image into the text buffer at iter. The image
	// will be counted as one character in character counts, and when obtaining
	// the buffer contents as a string, will be represented by the Unicode
	// “object replacement character” 0xFFFC. Note that the “slice” variants for
	// obtaining portions of the buffer as a string include this character for
	// pixbufs, but the “text” variants do not. e.g. see
	// gtk_text_buffer_get_slice() and gtk_text_buffer_get_text().
	InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf)
	InsertText(pos *TextIter, newText string, newTextLength int)
	MarkDeleted(mark *TextMark)
	MarkSet(location *TextIter, mark *TextMark)
	ModifiedChanged()
	PasteDone(clipboard *Clipboard)
	// RemoveTag emits the “remove-tag” signal. The default handler for the
	// signal removes all occurrences of tag from the given range. start and end
	// don’t have to be in order.
	RemoveTag(tag *TextTag, start, end *TextIter)
}

// TextBuffer: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
type TextBuffer struct {
	*externglib.Object
}

func wrapTextBuffer(obj *externglib.Object) *TextBuffer {
	return &TextBuffer{
		Object: obj,
	}
}

func marshalTextBufferer(p uintptr) (interface{}, error) {
	return wrapTextBuffer(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTextBuffer creates a new text buffer.
//
// The function takes the following parameters:
//
//    - table: tag table, or NULL to create a new one.
//
func NewTextBuffer(table *TextTagTable) *TextBuffer {
	var _arg1 *C.GtkTextTagTable // out
	var _cret *C.GtkTextBuffer   // in

	if table != nil {
		_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))
	}

	_cret = C.gtk_text_buffer_new(_arg1)
	runtime.KeepAlive(table)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textBuffer
}

// AddMark adds the mark at position where. The mark must not be added to
// another buffer, and if its name is not NULL then there must not be another
// mark in the buffer with the same name.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's initial
// placement.
//
// The function takes the following parameters:
//
//    - mark to add.
//    - where: location to place mark.
//
func (buffer *TextBuffer) AddMark(mark *TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// AddSelectionClipboard adds clipboard to the list of clipboards in which the
// selection contents of buffer are available. In most cases, clipboard will be
// the Clipboard of type GDK_SELECTION_PRIMARY for a view of buffer.
//
// The function takes the following parameters:
//
//    - clipboard: Clipboard.
//
func (buffer *TextBuffer) AddSelectionClipboard(clipboard *Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// ApplyTag emits the “apply-tag” signal on buffer. The default handler for the
// signal applies tag to the given range. start and end do not have to be in
// order.
//
// The function takes the following parameters:
//
//    - tag: TextTag.
//    - start: one bound of range to be tagged.
//    - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) ApplyTag(tag *TextTag, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ApplyTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag table to
// get a TextTag, then calls gtk_text_buffer_apply_tag().
//
// The function takes the following parameters:
//
//    - name of a named TextTag.
//    - start: one bound of range to be tagged.
//    - end: other bound of range to be tagged.
//
func (buffer *TextBuffer) ApplyTagByName(name string, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by iter. In the normal case a
// single character will be deleted, but when combining accents are involved,
// more than one character can be deleted, and when precomposed character and
// accent combinations are involved, less than one character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the iter will be re-initialized to
// point to the location where text was deleted.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - interactive: whether the deletion is caused by user interaction.
//    - defaultEditable: whether the buffer is editable by default.
//
func (buffer *TextBuffer) Backspace(iter *TextIter, interactive, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 C.gboolean       // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if interactive {
		_arg2 = C.TRUE
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BeginUserAction: called to indicate that the buffer operations between here
// and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and gtk_text_buffer_end_user_action() can
// then be grouped when creating an undo stack. TextBuffer maintains a count of
// calls to gtk_text_buffer_begin_user_action() that have not been closed with a
// call to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
// and “end-user-action” signals only for the outermost pair of calls. This
// allows you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end user
// action around the buffer operations they perform, so there's no need to add
// extra calls if you user action consists solely of a single call to one of
// those functions.
func (buffer *TextBuffer) BeginUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_begin_user_action(_arg0)
	runtime.KeepAlive(buffer)
}

// CopyClipboard copies the currently-selected text to a clipboard.
//
// The function takes the following parameters:
//
//    - clipboard object to copy to.
//
func (buffer *TextBuffer) CopyClipboard(clipboard *Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// CreateChildAnchor: this is a convenience function which simply creates a
// child anchor with gtk_text_child_anchor_new() and inserts it into the buffer
// with gtk_text_buffer_insert_child_anchor(). The new anchor is owned by the
// buffer; no reference count is returned to the caller of
// gtk_text_buffer_create_child_anchor().
//
// The function takes the following parameters:
//
//    - iter: location in the buffer.
//
func (buffer *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(externglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// CreateMark creates a mark at position where. If mark_name is NULL, the mark
// is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is inserted
// at the mark’s current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity (left_gravity = FALSE),
// the mark will end up on the right of newly-inserted text. The standard
// left-to-right cursor is a mark with right gravity (when you type, the cursor
// stays on the right side of the text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
//
// Emits the TextBuffer::mark-set signal as notification of the mark's initial
// placement.
//
// The function takes the following parameters:
//
//    - markName: name for mark, or NULL.
//    - where: location to place mark.
//    - leftGravity: whether the mark has left gravity.
//
func (buffer *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	if markName != "" {
		_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(markName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))
	if leftGravity {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(markName)
	runtime.KeepAlive(where)
	runtime.KeepAlive(leftGravity)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(externglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
//
// The function takes the following parameters:
//
//    - clipboard object to cut to.
//    - defaultEditable: default editability of the buffer.
//
func (buffer *TextBuffer) CutClipboard(clipboard *Clipboard, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))
	if defaultEditable {
		_arg2 = C.TRUE
	}

	C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(defaultEditable)
}

// Delete deletes text between start and end. The order of start and end is not
// actually relevant; gtk_text_buffer_delete() will reorder them. This function
// actually emits the “delete-range” signal, and the default handler of that
// signal deletes the text. Because the buffer is modified, all outstanding
// iterators become invalid after calling this function; however, the start and
// end will be re-initialized to point to the location where text was deleted.
//
// The function takes the following parameters:
//
//    - start: position in buffer.
//    - end: another position in buffer.
//
func (buffer *TextBuffer) Delete(start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// DeleteInteractive deletes all editable text in the given range. Calls
// gtk_text_buffer_delete() for each editable sub-range of [start,end). start
// and end are revalidated to point to the location of the last deleted range,
// or left untouched if no text was deleted.
//
// The function takes the following parameters:
//
//    - startIter: start of range to delete.
//    - endIter: end of range.
//    - defaultEditable: whether the buffer is editable by default.
//
func (buffer *TextBuffer) DeleteInteractive(startIter, endIter *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(startIter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(endIter)))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(startIter)
	runtime.KeepAlive(endIter)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeleteMark deletes mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if you haven’t
// called g_object_ref() on the mark, it will be freed. Even if the mark isn’t
// freed, most operations on mark become invalid, until it gets added to a
// buffer again with gtk_text_buffer_add_mark(). Use gtk_text_mark_get_deleted()
// to find out if a mark has been removed from its buffer. The
// TextBuffer::mark-deleted signal will be emitted as notification after the
// mark is deleted.
//
// The function takes the following parameters:
//
//    - mark in buffer.
//
func (buffer *TextBuffer) DeleteMark(mark *TextMark) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_delete_mark(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
}

// DeleteMarkByName deletes the mark named name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
//
// The function takes the following parameters:
//
//    - name of a mark in buffer.
//
func (buffer *TextBuffer) DeleteMarkByName(name string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
}

// DeleteSelection deletes the range between the “insert” and “selection_bound”
// marks, that is, the currently-selected text. If interactive is TRUE, the
// editability of the selection will be considered (users can’t delete
// uneditable text).
//
// The function takes the following parameters:
//
//    - interactive: whether the deletion is caused by user interaction.
//    - defaultEditable: whether the buffer is editable by default.
//
func (buffer *TextBuffer) DeleteSelection(interactive, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out
	var _arg2 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	if interactive {
		_arg1 = C.TRUE
	}
	if defaultEditable {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndUserAction: should be paired with a call to
// gtk_text_buffer_begin_user_action(). See that function for a full
// explanation.
func (buffer *TextBuffer) EndUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_end_user_action(_arg0)
	runtime.KeepAlive(buffer)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the entire
// buffer lies within the range [start,end).
func (buffer *TextBuffer) Bounds() (start TextIter, end TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_get_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _start TextIter // out
	var _end TextIter   // out

	_start = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _start, _end
}

// CharCount gets the number of characters in the buffer; note that characters
// and bytes are not the same, you can’t e.g. expect the contents of the buffer
// in string form to be this many bytes long. The character count is cached, so
// this function is very fast.
func (buffer *TextBuffer) CharCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_char_count(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CopyTargetList: this function returns the list of targets this text buffer
// can provide for copying and as DND source. The targets in the list are added
// with info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
func (buffer *TextBuffer) CopyTargetList() *TargetList {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTargetList // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_copy_target_list(_arg0)
	runtime.KeepAlive(buffer)

	var _targetList *TargetList // out

	_targetList = (*TargetList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_target_list_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_targetList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_target_list_unref((*C.GtkTargetList)(intern.C))
		},
	)

	return _targetList
}

// EndIter initializes iter with the “end iterator,” one past the last valid
// character in the text buffer. If dereferenced with gtk_text_iter_get_char(),
// the end iterator has a character value of 0. The entire buffer lies in the
// range from the first position in the buffer (call
// gtk_text_buffer_get_start_iter() to get character position 0) to the end
// iterator.
func (buffer *TextBuffer) EndIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_get_end_iter(_arg0, &_arg1)
	runtime.KeepAlive(buffer)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// HasSelection indicates whether the buffer has some text currently selected.
func (buffer *TextBuffer) HasSelection() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_has_selection(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetInsert returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
func (buffer *TextBuffer) GetInsert() *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_insert(_arg0)
	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(externglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// IterAtChildAnchor obtains the location of anchor within buffer.
//
// The function takes the following parameters:
//
//    - anchor: child anchor that appears in buffer.
//
func (buffer *TextBuffer) IterAtChildAnchor(anchor *TextChildAnchor) TextIter {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 C.GtkTextIter         // in
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(anchor)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtLine initializes iter to the start of the given line. If line_number is
// greater than the number of lines in the buffer, the end iterator is returned.
//
// The function takes the following parameters:
//
//    - lineNumber: line number counting from 0.
//
func (buffer *TextBuffer) IterAtLine(lineNumber int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = C.gint(lineNumber)

	C.gtk_text_buffer_get_iter_at_line(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtLineIndex obtains an iterator pointing to byte_index within the given
// line. byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if line_number is greater than the number of lines in
// the buffer, the end iterator is returned. And if byte_index is off the end of
// the line, the iterator at the end of the line is returned.
//
// The function takes the following parameters:
//
//    - lineNumber: line number counting from 0.
//    - byteIndex: byte index from start of line.
//
func (buffer *TextBuffer) IterAtLineIndex(lineNumber, byteIndex int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.gint           // out
	var _arg3 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = C.gint(lineNumber)
	_arg3 = C.gint(byteIndex)

	C.gtk_text_buffer_get_iter_at_line_index(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(byteIndex)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtLineOffset obtains an iterator pointing to char_offset within the given
// line. Note characters, not bytes; UTF-8 may encode one character as multiple
// bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if line_number is greater than the number of lines in
// the buffer, the end iterator is returned. And if char_offset is off the end
// of the line, the iterator at the end of the line is returned.
//
// The function takes the following parameters:
//
//    - lineNumber: line number counting from 0.
//    - charOffset: char offset from start of line.
//
func (buffer *TextBuffer) IterAtLineOffset(lineNumber, charOffset int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.gint           // out
	var _arg3 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = C.gint(lineNumber)
	_arg3 = C.gint(charOffset)

	C.gtk_text_buffer_get_iter_at_line_offset(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(charOffset)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtMark initializes iter with the current position of mark.
//
// The function takes the following parameters:
//
//    - mark in buffer.
//
func (buffer *TextBuffer) IterAtMark(mark *TextMark) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_get_iter_at_mark(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtOffset initializes iter to a position char_offset chars from the start
// of the entire buffer. If char_offset is -1 or greater than the number of
// characters in the buffer, iter is initialized to the end iterator, the
// iterator one past the last valid character in the buffer.
//
// The function takes the following parameters:
//
//    - charOffset: char offset from start of buffer, counting from 0, or -1.
//
func (buffer *TextBuffer) IterAtOffset(charOffset int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = C.gint(charOffset)

	C.gtk_text_buffer_get_iter_at_offset(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(charOffset)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// LineCount obtains the number of lines in the buffer. This value is cached, so
// the function is very fast.
func (buffer *TextBuffer) LineCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gint           // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_line_count(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Mark returns the mark named name in buffer buffer, or NULL if no such mark
// exists in the buffer.
//
// The function takes the following parameters:
//
//    - name: mark name.
//
func (buffer *TextBuffer) Mark(name string) *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _textMark *TextMark // out

	if _cret != nil {
		_textMark = wrapTextMark(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _textMark
}

// Modified indicates whether the buffer has been modified since the last call
// to gtk_text_buffer_set_modified() set the modification flag to FALSE. Used
// for example to enable a “save” function in a text editor.
func (buffer *TextBuffer) Modified() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_modified(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PasteTargetList: this function returns the list of targets this text buffer
// supports for pasting and as DND destination. The targets in the list are
// added with info values from the TextBufferTargetInfo enum, using
// gtk_target_list_add_rich_text_targets() and
// gtk_target_list_add_text_targets().
func (buffer *TextBuffer) PasteTargetList() *TargetList {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTargetList // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_paste_target_list(_arg0)
	runtime.KeepAlive(buffer)

	var _targetList *TargetList // out

	_targetList = (*TargetList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_target_list_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_targetList)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_target_list_unref((*C.GtkTargetList)(intern.C))
		},
	)

	return _targetList
}

// SelectionBound returns the mark that represents the selection bound.
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert” are
// in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a selection
// and what its bounds are.
func (buffer *TextBuffer) SelectionBound() *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_selection_bound(_arg0)
	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(externglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// SelectionBounds returns TRUE if some text is selected; places the bounds of
// the selection in start and end (if the selection has length 0, then start and
// end are filled in with the same value). start and end will be in ascending
// order. If start and end are NULL, then they are not filled in, but the return
// value still indicates whether text is selected.
func (buffer *TextBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _start TextIter // out
	var _end TextIter   // out
	var _ok bool        // out

	_start = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// Slice returns the text in the range [start,end). Excludes undisplayed text
// (text marked with tags that set the invisibility attribute) if
// include_hidden_chars is FALSE. The returned string includes a 0xFFFC
// character whenever the buffer contains embedded images, so byte and character
// indexes into the returned string do correspond to byte and character indexes
// into the buffer. Contrast with gtk_text_buffer_get_text(). Note that 0xFFFC
// can occur in normal text as well, so it is not a reliable indicator that a
// pixbuf or widget is in the buffer.
//
// The function takes the following parameters:
//
//    - start of a range.
//    - end of a range.
//    - includeHiddenChars: whether to include invisible text.
//
func (buffer *TextBuffer) Slice(start, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// StartIter: initialized iter with the first position in the text buffer. This
// is the same as using gtk_text_buffer_get_iter_at_offset() to get the iter at
// character offset 0.
func (buffer *TextBuffer) StartIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_get_start_iter(_arg0, &_arg1)
	runtime.KeepAlive(buffer)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// TagTable: get the TextTagTable associated with this buffer.
func (buffer *TextBuffer) TagTable() *TextTagTable {
	var _arg0 *C.GtkTextBuffer   // out
	var _cret *C.GtkTextTagTable // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_tag_table(_arg0)
	runtime.KeepAlive(buffer)

	var _textTagTable *TextTagTable // out

	_textTagTable = wrapTextTagTable(externglib.Take(unsafe.Pointer(_cret)))

	return _textTagTable
}

// Text returns the text in the range [start,end). Excludes undisplayed text
// (text marked with tags that set the invisibility attribute) if
// include_hidden_chars is FALSE. Does not include characters representing
// embedded images, so byte and character indexes into the returned string do
// not correspond to byte and character indexes into the buffer. Contrast with
// gtk_text_buffer_get_slice().
//
// The function takes the following parameters:
//
//    - start of a range.
//    - end of a range.
//    - includeHiddenChars: whether to include invisible text.
//
func (buffer *TextBuffer) Text(start, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.gchar         // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts len bytes of text at position iter. If len is -1, text must be
// nul-terminated and will be inserted in its entirety. Emits the “insert-text”
// signal; insertion actually occurs in the default handler for the signal. iter
// is invalidated when insertion occurs (because the buffer contents change),
// but the default signal handler revalidates it to point to the end of the
// inserted text.
//
// The function takes the following parameters:
//
//    - iter: position in the buffer.
//    - text in UTF-8 format.
//    - len: length of text in bytes, or -1.
//
func (buffer *TextBuffer) Insert(iter *TextIter, text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.gchar         // out
	var _arg3 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(len)

	C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
}

// InsertAtCursor: simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
//
// The function takes the following parameters:
//
//    - text in UTF-8 format.
//    - len: length of text, in bytes.
//
func (buffer *TextBuffer) InsertAtCursor(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(len)

	C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at iter.
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the “text” variants do not. E.g. see gtk_text_buffer_get_slice()
// and gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient alternative to
// this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
//
// The function takes the following parameters:
//
//    - iter: location to insert the anchor.
//    - anchor: TextChildAnchor.
//
func (buffer *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(anchor)
}

// InsertInteractive: like gtk_text_buffer_insert(), but the insertion will not
// occur if iter is at a non-editable location in the buffer. Usually you want
// to prevent insertions at ineditable locations if the insertion results from a
// user action (is interactive).
//
// default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - text: some UTF-8 text.
//    - len: length of text in bytes, or -1.
//    - defaultEditable: default editability of buffer.
//
func (buffer *TextBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.gchar         // out
	var _arg3 C.gint           // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(len)
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertInteractiveAtCursor calls gtk_text_buffer_insert_interactive() at the
// cursor position.
//
// default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
//
// The function takes the following parameters:
//
//    - text in UTF-8 format.
//    - len: length of text in bytes, or -1.
//    - defaultEditable: default editability of buffer.
//
func (buffer *TextBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gint           // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(len)
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertMarkup inserts the text in markup at position iter. markup will be
// inserted in its entirety and must be nul-terminated and valid UTF-8. Emits
// the TextBuffer::insert-text signal, possibly multiple times; insertion
// actually occurs in the default handler for the signal. iter will point to the
// end of the inserted text on return.
//
// The function takes the following parameters:
//
//    - iter: location to insert the markup.
//    - markup: nul-terminated UTF-8 string containing [Pango
//    markup][PangoMarkupFormat].
//    - len: length of markup in bytes, or -1.
//
func (buffer *TextBuffer) InsertMarkup(iter *TextIter, markup string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.gchar         // out
	var _arg3 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(markup)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gint(len)

	C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(markup)
	runtime.KeepAlive(len)
}

// InsertPixbuf inserts an image into the text buffer at iter. The image will be
// counted as one character in character counts, and when obtaining the buffer
// contents as a string, will be represented by the Unicode “object replacement
// character” 0xFFFC. Note that the “slice” variants for obtaining portions of
// the buffer as a string include this character for pixbufs, but the “text”
// variants do not. e.g. see gtk_text_buffer_get_slice() and
// gtk_text_buffer_get_text().
//
// The function takes the following parameters:
//
//    - iter: location to insert the pixbuf.
//    - pixbuf: Pixbuf.
//
func (buffer *TextBuffer) InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPixbuf     // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	C.gtk_text_buffer_insert_pixbuf(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(pixbuf)
}

// InsertRange copies text, tags, and pixbufs between start and end (the order
// of start and end doesn’t matter) and inserts the copy at iter. Used instead
// of simply getting/inserting text because it preserves images and tags. If
// start and end are in a different buffer from buffer, the two buffers must
// share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - start: position in a TextBuffer.
//    - end: another position in the same buffer as start.
//
func (buffer *TextBuffer) InsertRange(iter, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// InsertRangeInteractive: same as gtk_text_buffer_insert_range(), but does
// nothing if the insertion point isn’t editable. The default_editable parameter
// indicates whether the text is editable at iter if no tags enclosing iter
// affect editability. Typically the result of gtk_text_view_get_editable() is
// appropriate here.
//
// The function takes the following parameters:
//
//    - iter: position in buffer.
//    - start: position in a TextBuffer.
//    - end: another position in the same buffer as start.
//    - defaultEditable: default editability of the buffer.
//
func (buffer *TextBuffer) InsertRangeInteractive(iter, start, end *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMark moves mark to the new location where. Emits the TextBuffer::mark-set
// signal as notification of the move.
//
// The function takes the following parameters:
//
//    - mark: TextMark.
//    - where: new location for mark in buffer.
//
func (buffer *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// MoveMarkByName moves the mark named name (which must exist) to location
// where. See gtk_text_buffer_move_mark() for details.
//
// The function takes the following parameters:
//
//    - name of a mark.
//    - where: new location for mark.
//
func (buffer *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(where)
}

// PasteClipboard pastes the contents of a clipboard. If override_location is
// NULL, the pasted text will be inserted at the cursor position, or the buffer
// selection will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
//
// The function takes the following parameters:
//
//    - clipboard to paste from.
//    - overrideLocation: location to insert pasted text, or NULL.
//    - defaultEditable: whether the buffer is editable by default.
//
func (buffer *TextBuffer) PasteClipboard(clipboard *Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))
	if overrideLocation != nil {
		_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(overrideLocation)))
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(overrideLocation)
	runtime.KeepAlive(defaultEditable)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them to the same place in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
//
// The function takes the following parameters:
//
//    - where to put the cursor.
//
func (buffer *TextBuffer) PlaceCursor(where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_place_cursor(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(where)
}

// RemoveAllTags removes all tags in the range between start and end. Be careful
// with this function; it could remove tags added in code unrelated to the code
// you’re currently writing. That is, using this function is probably a bad idea
// if you have two or more unrelated code sections that add tags.
//
// The function takes the following parameters:
//
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveAllTags(start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveSelectionClipboard removes a Clipboard added with
// gtk_text_buffer_add_selection_clipboard().
//
// The function takes the following parameters:
//
//    - clipboard added to buffer by gtk_text_buffer_add_selection_clipboard().
//
func (buffer *TextBuffer) RemoveSelectionClipboard(clipboard *Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// RemoveTag emits the “remove-tag” signal. The default handler for the signal
// removes all occurrences of tag from the given range. start and end don’t have
// to be in order.
//
// The function takes the following parameters:
//
//    - tag: TextTag.
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveTag(tag *TextTag, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveTagByName calls gtk_text_tag_table_lookup() on the buffer’s tag table
// to get a TextTag, then calls gtk_text_buffer_remove_tag().
//
// The function takes the following parameters:
//
//    - name of a TextTag.
//    - start: one bound of range to be untagged.
//    - end: other bound of range to be untagged.
//
func (buffer *TextBuffer) RemoveTagByName(name string, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously. If you move them in two steps with
// gtk_text_buffer_move_mark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
//
// The function takes the following parameters:
//
//    - ins: where to put the “insert” mark.
//    - bound: where to put the “selection_bound” mark.
//
func (buffer *TextBuffer) SelectRange(ins, bound *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(ins)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(bound)))

	C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ins)
	runtime.KeepAlive(bound)
}

// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved. Whenever the buffer is saved to disk, call
// gtk_text_buffer_set_modified (buffer, FALSE). When the buffer is modified, it
// will automatically toggled on the modified bit again. When the modified bit
// flips, the buffer emits the TextBuffer::modified-changed signal.
//
// The function takes the following parameters:
//
//    - setting: modification flag setting.
//
func (buffer *TextBuffer) SetModified(setting bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_modified(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(setting)
}

// SetText deletes current contents of buffer, and inserts text instead. If len
// is -1, text must be nul-terminated. text must be valid UTF-8.
//
// The function takes the following parameters:
//
//    - text: UTF-8 text to insert.
//    - len: length of text in bytes.
//
func (buffer *TextBuffer) SetText(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.gchar         // out
	var _arg2 C.gint           // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(len)

	C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
}

// ConnectApplyTag signal is emitted to apply a tag to a range of text in a
// TextBuffer. Applying actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk_text_buffer_apply_tag(), gtk_text_buffer_insert_with_tags(),
// gtk_text_buffer_insert_range().
func (buffer *TextBuffer) ConnectApplyTag(f func(tag TextTag, start, end TextIter)) externglib.SignalHandle {
	return buffer.Connect("apply-tag", f)
}

// ConnectBeginUserAction signal is emitted at the beginning of a single
// user-visible operation on a TextBuffer.
//
// See also: gtk_text_buffer_begin_user_action(),
// gtk_text_buffer_insert_interactive(),
// gtk_text_buffer_insert_range_interactive(),
// gtk_text_buffer_delete_interactive(), gtk_text_buffer_backspace(),
// gtk_text_buffer_delete_selection().
func (buffer *TextBuffer) ConnectBeginUserAction(f func()) externglib.SignalHandle {
	return buffer.Connect("begin-user-action", f)
}

// ConnectChanged signal is emitted when the content of a TextBuffer has
// changed.
func (buffer *TextBuffer) ConnectChanged(f func()) externglib.SignalHandle {
	return buffer.Connect("changed", f)
}

// ConnectDeleteRange signal is emitted to delete a range from a TextBuffer.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them). The default
// signal handler revalidates the start and end iters to both point to the
// location where text was deleted. Handlers which run after the default handler
// (see g_signal_connect_after()) do not have access to the deleted text.
//
// See also: gtk_text_buffer_delete().
func (buffer *TextBuffer) ConnectDeleteRange(f func(start, end TextIter)) externglib.SignalHandle {
	return buffer.Connect("delete-range", f)
}

// ConnectEndUserAction signal is emitted at the end of a single user-visible
// operation on the TextBuffer.
//
// See also: gtk_text_buffer_end_user_action(),
// gtk_text_buffer_insert_interactive(),
// gtk_text_buffer_insert_range_interactive(),
// gtk_text_buffer_delete_interactive(), gtk_text_buffer_backspace(),
// gtk_text_buffer_delete_selection(), gtk_text_buffer_backspace().
func (buffer *TextBuffer) ConnectEndUserAction(f func()) externglib.SignalHandle {
	return buffer.Connect("end-user-action", f)
}

// ConnectInsertChildAnchor signal is emitted to insert a TextChildAnchor in a
// TextBuffer. Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted anchor.
//
// See also: gtk_text_buffer_insert_child_anchor().
func (buffer *TextBuffer) ConnectInsertChildAnchor(f func(location TextIter, anchor TextChildAnchor)) externglib.SignalHandle {
	return buffer.Connect("insert-child-anchor", f)
}

// ConnectInsertPixbuf signal is emitted to insert a Pixbuf in a TextBuffer.
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted pixbuf.
//
// See also: gtk_text_buffer_insert_pixbuf().
func (buffer *TextBuffer) ConnectInsertPixbuf(f func(location TextIter, pixbuf gdkpixbuf.Pixbuf)) externglib.SignalHandle {
	return buffer.Connect("insert-pixbuf", f)
}

// ConnectInsertText signal is emitted to insert text in a TextBuffer. Insertion
// actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to point to the end of the inserted text.
//
// See also: gtk_text_buffer_insert(), gtk_text_buffer_insert_range().
func (buffer *TextBuffer) ConnectInsertText(f func(location TextIter, text string, len int)) externglib.SignalHandle {
	return buffer.Connect("insert-text", f)
}

// ConnectMarkDeleted signal is emitted as notification after a TextMark is
// deleted.
//
// See also: gtk_text_buffer_delete_mark().
func (buffer *TextBuffer) ConnectMarkDeleted(f func(mark TextMark)) externglib.SignalHandle {
	return buffer.Connect("mark-deleted", f)
}

// ConnectMarkSet signal is emitted as notification after a TextMark is set.
//
// See also: gtk_text_buffer_create_mark(), gtk_text_buffer_move_mark().
func (buffer *TextBuffer) ConnectMarkSet(f func(location TextIter, mark TextMark)) externglib.SignalHandle {
	return buffer.Connect("mark-set", f)
}

// ConnectModifiedChanged signal is emitted when the modified bit of a
// TextBuffer flips.
//
// See also: gtk_text_buffer_set_modified().
func (buffer *TextBuffer) ConnectModifiedChanged(f func()) externglib.SignalHandle {
	return buffer.Connect("modified-changed", f)
}

// ConnectPasteDone signal is emitted after paste operation has been completed.
// This is useful to properly scroll the view to the end of the pasted text. See
// gtk_text_buffer_paste_clipboard() for more details.
func (buffer *TextBuffer) ConnectPasteDone(f func(clipboard Clipboard)) externglib.SignalHandle {
	return buffer.Connect("paste-done", f)
}

// ConnectRemoveTag signal is emitted to remove all occurrences of tag from a
// range of text in a TextBuffer. Removal actually occurs in the default
// handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk_text_buffer_remove_tag().
func (buffer *TextBuffer) ConnectRemoveTag(f func(tag TextTag, start, end TextIter)) externglib.SignalHandle {
	return buffer.Connect("remove-tag", f)
}

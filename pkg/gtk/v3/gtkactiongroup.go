// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// extern void _gotk4_gtk3_ActionGroup_ConnectPreActivate(gpointer, GtkAction*, guintptr);
// extern void _gotk4_gtk3_ActionGroup_ConnectPostActivate(gpointer, GtkAction*, guintptr);
// extern void _gotk4_gtk3_ActionGroup_ConnectDisconnectProxy(gpointer, GtkAction*, GtkWidget*, guintptr);
// extern void _gotk4_gtk3_ActionGroup_ConnectConnectProxy(gpointer, GtkAction*, GtkWidget*, guintptr);
// extern GtkAction* _gotk4_gtk3_ActionGroupClass_get_action(GtkActionGroup*, gchar*);
import "C"

// GType values.
var (
	GTypeActionGroup = coreglib.Type(C.gtk_action_group_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeActionGroup, F: marshalActionGroup},
	})
}

// ActionGroupOverrides contains methods that are overridable.
type ActionGroupOverrides struct {
	// Action looks up an action in the action group by name.
	//
	// Deprecated: since version 3.10.
	//
	// The function takes the following parameters:
	//
	//    - actionName: name of the action.
	//
	// The function returns the following values:
	//
	//    - action: action, or NULL if no action by that name exists.
	//
	Action func(actionName string) *Action
}

func defaultActionGroupOverrides(v *ActionGroup) ActionGroupOverrides {
	return ActionGroupOverrides{
		Action: v.action,
	}
}

// ActionGroup actions are organised into groups. An action group is essentially
// a map from names to Action objects.
//
// All actions that would make sense to use in a particular context should be in
// a single group. Multiple action groups may be used for a particular user
// interface. In fact, it is expected that most nontrivial applications will
// make use of multiple groups. For example, in an application that can edit
// multiple documents, one group holding global actions (e.g. quit, about, new),
// and one group per document holding actions that act on that document (eg.
// save, cut/copy/paste, etc). Each window’s menus would be constructed from a
// combination of two action groups.
//
//
// Accelerators
//
// Accelerators are handled by the GTK+ accelerator map. All actions are
// assigned an accelerator path (which normally has the form
// <Actions>/group-name/action-name) and a shortcut is associated with this
// accelerator path. All menuitems and toolitems take on this accelerator path.
// The GTK+ accelerator map code makes sure that the correct shortcut is
// displayed next to the menu item.
//
//
// GtkActionGroup as GtkBuildable
//
// The ActionGroup implementation of the Buildable interface accepts Action
// objects as <child> elements in UI definitions.
//
// Note that it is probably more common to define actions and action groups in
// the code, since they are directly related to what the code can do.
//
// The GtkActionGroup implementation of the GtkBuildable interface supports a
// custom <accelerator> element, which has attributes named “key“ and
// “modifiers“ and allows to specify accelerators. This is similar to the
// <accelerator> element of Widget, the main difference is that it doesn’t allow
// you to specify a signal.
//
// A Dialog UI definition fragment. ##
//
//    <object class="GtkActionGroup" id="actiongroup">
//      <child>
//          <object class="GtkAction" id="About">
//              <property name="name">About</property>
//              <property name="stock_id">gtk-about</property>
//              <signal handler="about_activate" name="activate"/>
//          </object>
//          <accelerator key="F1" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK"/>
//      </child>
//    </object>.
type ActionGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
}

var (
	_ coreglib.Objector = (*ActionGroup)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ActionGroup, *ActionGroupClass, ActionGroupOverrides](
		GTypeActionGroup,
		initActionGroupClass,
		wrapActionGroup,
		defaultActionGroupOverrides,
	)
}

func initActionGroupClass(gclass unsafe.Pointer, overrides ActionGroupOverrides, classInitFunc func(*ActionGroupClass)) {
	pclass := (*C.GtkActionGroupClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeActionGroup))))

	if overrides.Action != nil {
		pclass.get_action = (*[0]byte)(C._gotk4_gtk3_ActionGroupClass_get_action)
	}

	if classInitFunc != nil {
		class := (*ActionGroupClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapActionGroup(obj *coreglib.Object) *ActionGroup {
	return &ActionGroup{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalActionGroup(p uintptr) (interface{}, error) {
	return wrapActionGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectConnectProxy signal is emitted after connecting a proxy to an action
// in the group. Note that the proxy may have been connected to a different
// action before.
//
// This is intended for simple customizations for which a custom action class
// would be too clumsy, e.g. showing tooltips for menuitems in the statusbar.
//
// UIManager proxies the signal and provides global notification just before any
// action is connected to a proxy, which is probably more convenient to use.
func (actionGroup *ActionGroup) ConnectConnectProxy(f func(action *Action, proxy Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "connect-proxy", false, unsafe.Pointer(C._gotk4_gtk3_ActionGroup_ConnectConnectProxy), f)
}

// ConnectDisconnectProxy signal is emitted after disconnecting a proxy from an
// action in the group.
//
// UIManager proxies the signal and provides global notification just before any
// action is connected to a proxy, which is probably more convenient to use.
func (actionGroup *ActionGroup) ConnectDisconnectProxy(f func(action *Action, proxy Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "disconnect-proxy", false, unsafe.Pointer(C._gotk4_gtk3_ActionGroup_ConnectDisconnectProxy), f)
}

// ConnectPostActivate signal is emitted just after the action in the
// action_group is activated
//
// This is intended for UIManager to proxy the signal and provide global
// notification just after any action is activated.
func (actionGroup *ActionGroup) ConnectPostActivate(f func(action *Action)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "post-activate", false, unsafe.Pointer(C._gotk4_gtk3_ActionGroup_ConnectPostActivate), f)
}

// ConnectPreActivate signal is emitted just before the action in the
// action_group is activated
//
// This is intended for UIManager to proxy the signal and provide global
// notification just before any action is activated.
func (actionGroup *ActionGroup) ConnectPreActivate(f func(action *Action)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(actionGroup, "pre-activate", false, unsafe.Pointer(C._gotk4_gtk3_ActionGroup_ConnectPreActivate), f)
}

// ActionEntry structs are used with gtk_action_group_add_actions() to construct
// actions.
//
// Deprecated: since version 3.10.
//
// An instance of this type is always passed by reference.
type ActionEntry struct {
	*actionEntry
}

// actionEntry is the struct that's finalized.
type actionEntry struct {
	native *C.GtkActionEntry
}

// Name: name of the action.
func (a *ActionEntry) Name() string {
	valptr := &a.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// StockID: stock id for the action, or the name of an icon from the icon theme.
func (a *ActionEntry) StockID() string {
	valptr := &a.native.stock_id
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Label: label for the action. This field should typically be marked for
// translation, see gtk_action_group_set_translation_domain(). If label is NULL,
// the label of the stock item with id stock_id is used.
func (a *ActionEntry) Label() string {
	valptr := &a.native.label
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Accelerator: accelerator for the action, in the format understood by
// gtk_accelerator_parse().
func (a *ActionEntry) Accelerator() string {
	valptr := &a.native.accelerator
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Tooltip: tooltip for the action. This field should typically be marked for
// translation, see gtk_action_group_set_translation_domain().
func (a *ActionEntry) Tooltip() string {
	valptr := &a.native.tooltip
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ActionGroupClass: instance of this type is always passed by reference.
type ActionGroupClass struct {
	*actionGroupClass
}

// actionGroupClass is the struct that's finalized.
type actionGroupClass struct {
	native *C.GtkActionGroupClass
}

// RadioActionEntry structs are used with gtk_action_group_add_radio_actions()
// to construct groups of radio actions.
//
// Deprecated: since version 3.10.
//
// An instance of this type is always passed by reference.
type RadioActionEntry struct {
	*radioActionEntry
}

// radioActionEntry is the struct that's finalized.
type radioActionEntry struct {
	native *C.GtkRadioActionEntry
}

// Name: name of the action.
func (r *RadioActionEntry) Name() string {
	valptr := &r.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// StockID: stock id for the action, or the name of an icon from the icon theme.
func (r *RadioActionEntry) StockID() string {
	valptr := &r.native.stock_id
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Label: label for the action. This field should typically be marked for
// translation, see gtk_action_group_set_translation_domain().
func (r *RadioActionEntry) Label() string {
	valptr := &r.native.label
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Accelerator: accelerator for the action, in the format understood by
// gtk_accelerator_parse().
func (r *RadioActionEntry) Accelerator() string {
	valptr := &r.native.accelerator
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Tooltip: tooltip for the action. This field should typically be marked for
// translation, see gtk_action_group_set_translation_domain().
func (r *RadioActionEntry) Tooltip() string {
	valptr := &r.native.tooltip
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Value: value to set on the radio action. See
// gtk_radio_action_get_current_value().
func (r *RadioActionEntry) Value() int {
	valptr := &r.native.value
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Value: value to set on the radio action. See
// gtk_radio_action_get_current_value().
func (r *RadioActionEntry) SetValue(value int) {
	valptr := &r.native.value
	*valptr = C.gint(value)
}

// ToggleActionEntry structs are used with gtk_action_group_add_toggle_actions()
// to construct toggle actions.
//
// Deprecated: since version 3.10.
//
// An instance of this type is always passed by reference.
type ToggleActionEntry struct {
	*toggleActionEntry
}

// toggleActionEntry is the struct that's finalized.
type toggleActionEntry struct {
	native *C.GtkToggleActionEntry
}

// Name: name of the action.
func (t *ToggleActionEntry) Name() string {
	valptr := &t.native.name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// StockID: stock id for the action, or the name of an icon from the icon theme.
func (t *ToggleActionEntry) StockID() string {
	valptr := &t.native.stock_id
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Label: label for the action. This field should typically be marked for
// translation, see gtk_action_group_set_translation_domain().
func (t *ToggleActionEntry) Label() string {
	valptr := &t.native.label
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Accelerator: accelerator for the action, in the format understood by
// gtk_accelerator_parse().
func (t *ToggleActionEntry) Accelerator() string {
	valptr := &t.native.accelerator
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Tooltip: tooltip for the action. This field should typically be marked for
// translation, see gtk_action_group_set_translation_domain().
func (t *ToggleActionEntry) Tooltip() string {
	valptr := &t.native.tooltip
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// IsActive: initial state of the toggle action.
func (t *ToggleActionEntry) IsActive() bool {
	valptr := &t.native.is_active
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// IsActive: initial state of the toggle action.
func (t *ToggleActionEntry) SetIsActive(isActive bool) {
	valptr := &t.native.is_active
	if isActive {
		*valptr = C.TRUE
	}
}

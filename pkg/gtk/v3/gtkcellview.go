// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/atk"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// GType values.
var (
	GTypeCellView = coreglib.Type(C.gtk_cell_view_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeCellView, F: marshalCellView},
	})
}

// CellViewOverrides contains methods that are overridable.
type CellViewOverrides struct {
}

func defaultCellViewOverrides(v *CellView) CellViewOverrides {
	return CellViewOverrides{}
}

// CellView displays a single row of a TreeModel using a CellArea and
// CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with eachother (like the aligned cells in the menus of ComboBox).
//
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
//
// CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
type CellView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	CellLayout
	Orientable
}

var (
	_ Widgetter         = (*CellView)(nil)
	_ coreglib.Objector = (*CellView)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CellView, *CellViewClass, CellViewOverrides](
		GTypeCellView,
		initCellViewClass,
		wrapCellView,
		defaultCellViewOverrides,
	)
}

func initCellViewClass(gclass unsafe.Pointer, overrides CellViewOverrides, classInitFunc func(*CellViewClass)) {
	if classInitFunc != nil {
		class := (*CellViewClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCellView(obj *coreglib.Object) *CellView {
	return &CellView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			ImplementorIface: atk.ImplementorIface{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
		Object: obj,
		CellLayout: CellLayout{
			Object: obj,
		},
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalCellView(p uintptr) (interface{}, error) {
	return wrapCellView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CellViewClass: instance of this type is always passed by reference.
type CellViewClass struct {
	*cellViewClass
}

// cellViewClass is the struct that's finalized.
type cellViewClass struct {
	native *C.GtkCellViewClass
}

// ParentClass: parent class.
func (c *CellViewClass) ParentClass() *WidgetClass {
	valptr := &c.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

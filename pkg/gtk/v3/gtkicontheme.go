// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern void _gotk4_gtk3_IconThemeClass_changed(GtkIconTheme*);
// extern void _gotk4_gtk3_IconTheme_ConnectChanged(gpointer, guintptr);
import "C"

// glib.Type values for gtkicontheme.go.
var (
	GTypeIconThemeError  = coreglib.Type(C.gtk_icon_theme_error_get_type())
	GTypeIconLookupFlags = coreglib.Type(C.gtk_icon_lookup_flags_get_type())
	GTypeIconInfo        = coreglib.Type(C.gtk_icon_info_get_type())
	GTypeIconTheme       = coreglib.Type(C.gtk_icon_theme_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeIconThemeError, F: marshalIconThemeError},
		{T: GTypeIconLookupFlags, F: marshalIconLookupFlags},
		{T: GTypeIconInfo, F: marshalIconInfo},
		{T: GTypeIconTheme, F: marshalIconTheme},
	})
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError C.gint

const (
	// IconThemeNotFound: icon specified does not exist in the theme.
	IconThemeNotFound IconThemeError = iota
	// IconThemeFailed: unspecified error occurred.
	IconThemeFailed
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconThemeError.
func (i IconThemeError) String() string {
	switch i {
	case IconThemeNotFound:
		return "NotFound"
	case IconThemeFailed:
		return "Failed"
	default:
		return fmt.Sprintf("IconThemeError(%d)", i)
	}
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon().
type IconLookupFlags C.guint

const (
	// IconLookupNoSVG: never get SVG icons, even if gdk-pixbuf supports them.
	// Cannot be used together with GTK_ICON_LOOKUP_FORCE_SVG.
	IconLookupNoSVG IconLookupFlags = 0b1
	// IconLookupForceSVG: get SVG icons, even if gdk-pixbuf doesn’t support
	// them. Cannot be used together with GTK_ICON_LOOKUP_NO_SVG.
	IconLookupForceSVG IconLookupFlags = 0b10
	// IconLookupUseBuiltin: when passed to gtk_icon_theme_lookup_icon()
	// includes builtin icons as well as files. For a builtin icon,
	// gtk_icon_info_get_filename() is NULL and you need to call
	// gtk_icon_info_get_builtin_pixbuf().
	IconLookupUseBuiltin IconLookupFlags = 0b100
	// IconLookupGenericFallback: try to shorten icon name at '-' characters
	// before looking at inherited themes. This flag is only supported in
	// functions that take a single icon name. For more general fallback, see
	// gtk_icon_theme_choose_icon(). Since 2.12.
	IconLookupGenericFallback IconLookupFlags = 0b1000
	// IconLookupForceSize always get the icon scaled to the requested size.
	// Since 2.14.
	IconLookupForceSize IconLookupFlags = 0b10000
	// IconLookupForceRegular: try to always load regular icons, even when
	// symbolic icon names are given. Since 3.14.
	IconLookupForceRegular IconLookupFlags = 0b100000
	// IconLookupForceSymbolic: try to always load symbolic icons, even when
	// regular icon names are given. Since 3.14.
	IconLookupForceSymbolic IconLookupFlags = 0b1000000
	// IconLookupDirLTR: try to load a variant of the icon for left-to-right
	// text direction. Since 3.14.
	IconLookupDirLTR IconLookupFlags = 0b10000000
	// IconLookupDirRTL: try to load a variant of the icon for right-to-left
	// text direction. Since 3.14.
	IconLookupDirRTL IconLookupFlags = 0b100000000
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for IconLookupFlags.
func (i IconLookupFlags) String() string {
	if i == 0 {
		return "IconLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(182)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case IconLookupNoSVG:
			builder.WriteString("NoSVG|")
		case IconLookupForceSVG:
			builder.WriteString("ForceSVG|")
		case IconLookupUseBuiltin:
			builder.WriteString("UseBuiltin|")
		case IconLookupGenericFallback:
			builder.WriteString("GenericFallback|")
		case IconLookupForceSize:
			builder.WriteString("ForceSize|")
		case IconLookupForceRegular:
			builder.WriteString("ForceRegular|")
		case IconLookupForceSymbolic:
			builder.WriteString("ForceSymbolic|")
		case IconLookupDirLTR:
			builder.WriteString("DirLTR|")
		case IconLookupDirRTL:
			builder.WriteString("DirRTL|")
		default:
			builder.WriteString(fmt.Sprintf("IconLookupFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i IconLookupFlags) Has(other IconLookupFlags) bool {
	return (i & other) == other
}

// IconInfoOverrider contains methods that are overridable.
type IconInfoOverrider interface {
}

// IconInfo contains information found when looking up an icon in an icon theme.
type IconInfo struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*IconInfo)(nil)
)

func classInitIconInfor(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapIconInfo(obj *coreglib.Object) *IconInfo {
	return &IconInfo{
		Object: obj,
	}
}

func marshalIconInfo(p uintptr) (interface{}, error) {
	return wrapIconInfo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewIconInfoForPixbuf creates a IconInfo for a Pixbuf.
//
// The function takes the following parameters:
//
//    - iconTheme: IconTheme.
//    - pixbuf to wrap in a IconInfo.
//
// The function returns the following values:
//
//    - iconInfo: IconInfo.
//
func NewIconInfoForPixbuf(iconTheme *IconTheme, pixbuf *gdkpixbuf.Pixbuf) *IconInfo {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	*(**IconTheme)(unsafe.Pointer(&args[0])) = _arg0
	*(**gdkpixbuf.Pixbuf)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("new_IconInfo_for_pixbuf", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(pixbuf)

	var _iconInfo *IconInfo // out

	_iconInfo = wrapIconInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconInfo
}

// BaseScale gets the base scale for the icon. The base scale is a scale for the
// icon that was specified by the icon theme creator. For instance an icon drawn
// for a high-dpi screen with window scale 2 for a base size of 32 will be 64
// pixels tall and have a base scale of 2.
//
// The function returns the following values:
//
//    - gint: base scale.
//
func (iconInfo *IconInfo) BaseScale() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	*(**IconInfo)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("get_base_scale", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// BaseSize gets the base size for the icon. The base size is a size for the
// icon that was specified by the icon theme creator. This may be different than
// the actual size of image; an example of this is small emblem icons that can
// be attached to a larger icon. These icons will be given the same base size as
// the larger icons to which they are attached.
//
// Note that for scaled icons the base size does not include the base scale.
//
// The function returns the following values:
//
//    - gint: base size, or 0, if no base size is known for the icon.
//
func (iconInfo *IconInfo) BaseSize() int32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gint  // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	*(**IconInfo)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("get_base_size", args[:], nil)
	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)

	var _gint int32 // out

	_gint = int32(_cret)

	return _gint
}

// BuiltinPixbuf gets the built-in image for this icon, if any. To allow GTK+ to
// use built in icon images, you must pass the GTK_ICON_LOOKUP_USE_BUILTIN to
// gtk_icon_theme_lookup_icon().
//
// Deprecated: This function is deprecated, use
// gtk_icon_theme_add_resource_path() instead of builtin icons.
//
// The function returns the following values:
//
//    - pixbuf (optional): built-in image pixbuf, or NULL. No extra reference is
//      added to the returned pixbuf, so if you want to keep it around, you must
//      use g_object_ref(). The returned image must not be modified.
//
func (iconInfo *IconInfo) BuiltinPixbuf() *gdkpixbuf.Pixbuf {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	*(**IconInfo)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("get_builtin_pixbuf", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}

	return _pixbuf
}

// DisplayName: this function is deprecated and always returns NULL.
//
// Deprecated: Display names are deprecated.
//
// The function returns the following values:
//
//    - utf8: NULL.
//
func (iconInfo *IconInfo) DisplayName() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	*(**IconInfo)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("get_display_name", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Filename gets the filename for the icon. If the GTK_ICON_LOOKUP_USE_BUILTIN
// flag was passed to gtk_icon_theme_lookup_icon(), there may be no filename if
// a builtin icon is returned; in this case, you should use
// gtk_icon_info_get_builtin_pixbuf().
//
// The function returns the following values:
//
//    - filename (optional) for the icon, or NULL if
//      gtk_icon_info_get_builtin_pixbuf() should be used instead. The return
//      value is owned by GTK+ and should not be modified or freed.
//
func (iconInfo *IconInfo) Filename() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	*(**IconInfo)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("get_filename", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// IsSymbolic checks if the icon is symbolic or not. This currently uses only
// the file name and not the file contents for determining this. This behaviour
// may change in the future.
//
// The function returns the following values:
//
//    - ok: TRUE if the icon is symbolic, FALSE otherwise.
//
func (iconInfo *IconInfo) IsSymbolic() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	*(**IconInfo)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("is_symbolic", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadIcon renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting pixbuf may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
//
// The function returns the following values:
//
//    - pixbuf: rendered icon; this may be a newly created icon or a new
//      reference to an internal icon, so you must not modify the icon. Use
//      g_object_unref() to release your reference to the icon.
//
func (iconInfo *IconInfo) LoadIcon() (*gdkpixbuf.Pixbuf, error) {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in
	var _cerr *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	*(**IconInfo)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("load_icon", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// LoadIconFinish finishes an async icon load, see
// gtk_icon_info_load_icon_async().
//
// The function takes the following parameters:
//
//    - res: Result.
//
// The function returns the following values:
//
//    - pixbuf: rendered icon; this may be a newly created icon or a new
//      reference to an internal icon, so you must not modify the icon. Use
//      g_object_unref() to release your reference to the icon.
//
func (iconInfo *IconInfo) LoadIconFinish(res gio.AsyncResulter) (*gdkpixbuf.Pixbuf, error) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in
	var _cerr *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(res).Native()))
	*(**IconInfo)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("load_icon_finish", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)
	runtime.KeepAlive(res)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// LoadSurface renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting surface may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
//
// The function takes the following parameters:
//
//    - forWindow (optional) to optimize drawing for, or NULL.
//
// The function returns the following values:
//
//    - surface: rendered icon; this may be a newly created icon or a new
//      reference to an internal icon, so you must not modify the icon. Use
//      cairo_surface_destroy() to release your reference to the icon.
//
func (iconInfo *IconInfo) LoadSurface(forWindow gdk.Windower) (*cairo.Surface, error) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in
	var _cerr *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	if forWindow != nil {
		_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(forWindow).Native()))
	}
	*(**IconInfo)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "IconInfo").InvokeMethod("load_surface", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconInfo)
	runtime.KeepAlive(forWindow)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _surface, _goerr
}

// SetRawCoordinates sets whether the coordinates returned by
// gtk_icon_info_get_embedded_rect() and gtk_icon_info_get_attach_points()
// should be returned in their original form as specified in the icon theme,
// instead of scaled appropriately for the pixbuf returned by
// gtk_icon_info_load_icon().
//
// Raw coordinates are somewhat strange; they are specified to be with respect
// to the unscaled pixmap for PNG and XPM icons, but for SVG icons, they are in
// a 1000x1000 coordinate space that is scaled to the final size of the icon.
// You can determine if the icon is an SVG icon by using
// gtk_icon_info_get_filename(), and seeing if it is non-NULL and ends in
// “.svg”.
//
// This function is provided primarily to allow compatibility wrappers for older
// API's, and is not expected to be useful for applications.
//
// Deprecated: Embedded rectangles and attachment points are deprecated.
//
// The function takes the following parameters:
//
//    - rawCoordinates: whether the coordinates of embedded rectangles and
//      attached points should be returned in their original (unscaled) form.
//
func (iconInfo *IconInfo) SetRawCoordinates(rawCoordinates bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	if rawCoordinates {
		_arg1 = C.TRUE
	}
	*(**IconInfo)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconInfo").InvokeMethod("set_raw_coordinates", args[:], nil)

	runtime.KeepAlive(iconInfo)
	runtime.KeepAlive(rawCoordinates)
}

// IconThemeOverrider contains methods that are overridable.
type IconThemeOverrider interface {
	Changed()
}

// IconTheme provides a facility for looking up icons by name and size. The main
// reason for using a name rather than simply providing a filename is to allow
// different icons to be used depending on what “icon theme” is selected by the
// user. The operation of icon themes on Linux and Unix follows the Icon Theme
// Specification (http://www.freedesktop.org/Standards/icon-theme-spec) There is
// a fallback icon theme, named hicolor, where applications should install their
// icons, but additional icon themes can be installed as operating system
// vendors and users choose.
//
// Named icons are similar to the deprecated [Stock Items][gtkstock], and the
// distinction between the two may be a bit confusing. A few things to keep in
// mind:
//
// - Stock images usually are used in conjunction with [Stock Items][gtkstock],
// such as GTK_STOCK_OK or GTK_STOCK_OPEN. Named icons are easier to set up and
// therefore are more useful for new icons that an application wants to add,
// such as application icons or window icons.
//
// - Stock images can only be loaded at the symbolic sizes defined by the
// IconSize enumeration, or by custom sizes defined by gtk_icon_size_register(),
// while named icons are more flexible and any pixel size can be specified.
//
// - Because stock images are closely tied to stock items, and thus to actions
// in the user interface, stock images may come in multiple variants for
// different widget states or writing directions.
//
// A good rule of thumb is that if there is a stock image for what you want to
// use, use it, otherwise use a named icon. It turns out that internally stock
// images are generally defined in terms of one or more named icons. (An example
// of the more than one case is icons that depend on writing direction;
// GTK_STOCK_GO_FORWARD uses the two themed icons “gtk-stock-go-forward-ltr” and
// “gtk-stock-go-forward-rtl”.)
//
// In many cases, named themes are used indirectly, via Image or stock items,
// rather than directly, but looking up icons directly is also simple. The
// IconTheme object acts as a database of all the icons in the current theme.
// You can create new IconTheme objects, but it’s much more efficient to use the
// standard icon theme for the Screen so that the icon information is shared
// with other people looking up icons.
//
//    GError *error = NULL;
//    GtkIconTheme *icon_theme;
//    GdkPixbuf *pixbuf;
//
//    icon_theme = gtk_icon_theme_get_default ();
//    pixbuf = gtk_icon_theme_load_icon (icon_theme,
//                                       "my-icon-name", // icon name
//                                       48, // icon size
//                                       0,  // flags
//                                       &error);
//    if (!pixbuf)
//      {
//        g_warning ("Couldn’t load icon: s", error->message);
//        g_error_free (error);
//      }
//    else
//      {
//        // Use the pixbuf
//        g_object_unref (pixbuf);
//      }.
type IconTheme struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*IconTheme)(nil)
)

func classInitIconThemer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.GtkIconThemeClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.GtkIconThemeClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ Changed() }); ok {
		pclass.changed = (*[0]byte)(C._gotk4_gtk3_IconThemeClass_changed)
	}
}

//export _gotk4_gtk3_IconThemeClass_changed
func _gotk4_gtk3_IconThemeClass_changed(arg0 *C.GtkIconTheme) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Changed() })

	iface.Changed()
}

func wrapIconTheme(obj *coreglib.Object) *IconTheme {
	return &IconTheme{
		Object: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	return wrapIconTheme(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk3_IconTheme_ConnectChanged
func _gotk4_gtk3_IconTheme_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectChanged is emitted when the current icon theme is switched or GTK+
// detects that a change has occurred in the contents of the current icon theme.
func (iconTheme *IconTheme) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconTheme, "changed", false, unsafe.Pointer(C._gotk4_gtk3_IconTheme_ConnectChanged), f)
}

// NewIconTheme creates a new icon theme object. Icon theme objects are used to
// lookup up an icon by name in a particular icon theme. Usually, you’ll want to
// use gtk_icon_theme_get_default() or gtk_icon_theme_get_for_screen() rather
// than creating a new icon theme object for scratch.
//
// The function returns the following values:
//
//    - iconTheme: newly created IconTheme object.
//
func NewIconTheme() *IconTheme {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "IconTheme").InvokeMethod("new_IconTheme", nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconTheme
}

// AddResourcePath adds a resource path that will be looked at when looking for
// icons, similar to search paths.
//
// This function should be used to make application-specific icons available as
// part of the icon theme.
//
// The resources are considered as part of the hicolor icon theme and must be
// located in subdirectories that are defined in the hicolor icon theme, such as
// path/16x16/actions/run.png. Icons that are directly placed in the resource
// path instead of a subdirectory are also considered as ultimate fallback.
//
// The function takes the following parameters:
//
//    - path: resource path.
//
func (iconTheme *IconTheme) AddResourcePath(path string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconTheme").InvokeMethod("add_resource_path", args[:], nil)

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(path)
}

// AppendSearchPath appends a directory to the search path. See
// gtk_icon_theme_set_search_path().
//
// The function takes the following parameters:
//
//    - path: directory name to append to the icon path.
//
func (iconTheme *IconTheme) AppendSearchPath(path string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconTheme").InvokeMethod("append_search_path", args[:], nil)

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(path)
}

// ExampleIconName gets the name of an icon that is representative of the
// current theme (for instance, to use when presenting a list of themes to the
// user.).
//
// The function returns the following values:
//
//    - utf8 (optional): name of an example icon or NULL. Free with g_free().
//
func (iconTheme *IconTheme) ExampleIconName() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	*(**IconTheme)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconTheme").InvokeMethod("get_example_icon_name", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconTheme)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// IconSizes returns an array of integers describing the sizes at which the icon
// is available without scaling. A size of -1 means that the icon is available
// in a scalable format. The array is zero-terminated.
//
// The function takes the following parameters:
//
//    - iconName: name of an icon.
//
// The function returns the following values:
//
//    - gints: newly allocated array describing the sizes at which the icon is
//      available. The array should be freed with g_free() when it is no longer
//      needed.
//
func (iconTheme *IconTheme) IconSizes(iconName string) []int32 {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.gint // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "IconTheme").InvokeMethod("get_icon_sizes", args[:], nil)
	_cret = *(**C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconName)

	var _gints []int32 // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z C.gint
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_gints = make([]int32, i)
		for i := range src {
			_gints[i] = int32(src[i])
		}
	}

	return _gints
}

// HasIcon checks whether an icon theme includes an icon for a particular name.
//
// The function takes the following parameters:
//
//    - iconName: name of an icon.
//
// The function returns the following values:
//
//    - ok: TRUE if icon_theme includes an icon for icon_name.
//
func (iconTheme *IconTheme) HasIcon(iconName string) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "IconTheme").InvokeMethod("has_icon", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListContexts gets the list of contexts available within the current hierarchy
// of icon themes. See gtk_icon_theme_list_icons() for details about contexts.
//
// The function returns the following values:
//
//    - list list holding the names of all the contexts in the theme. You must
//      first free each element in the list with g_free(), then free the list
//      itself with g_list_free().
//
func (iconTheme *IconTheme) ListContexts() []string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	*(**IconTheme)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconTheme").InvokeMethod("list_contexts", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconTheme)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// ListIcons lists the icons in the current icon theme. Only a subset of the
// icons can be listed by providing a context string. The set of values for the
// context string is system dependent, but will typically include such values as
// “Applications” and “MimeTypes”. Contexts are explained in the Icon Theme
// Specification
// (http://www.freedesktop.org/wiki/Specifications/icon-theme-spec). The
// standard contexts are listed in the Icon Naming Specification
// (http://www.freedesktop.org/wiki/Specifications/icon-naming-spec). Also see
// gtk_icon_theme_list_contexts().
//
// The function takes the following parameters:
//
//    - context (optional): string identifying a particular type of icon, or NULL
//      to list all icons.
//
// The function returns the following values:
//
//    - list list holding the names of all the icons in the theme. You must first
//      free each element in the list with g_free(), then free the list itself
//      with g_list_free().
//
func (iconTheme *IconTheme) ListIcons(context string) []string {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	if context != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(context)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gtk", "IconTheme").InvokeMethod("list_icons", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(context)

	var _list []string // out

	_list = make([]string, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst string // out
		dst = C.GoString((*C.gchar)(unsafe.Pointer(src)))
		defer C.free(unsafe.Pointer(src))
		_list = append(_list, dst)
	})

	return _list
}

// PrependSearchPath prepends a directory to the search path. See
// gtk_icon_theme_set_search_path().
//
// The function takes the following parameters:
//
//    - path: directory name to prepend to the icon path.
//
func (iconTheme *IconTheme) PrependSearchPath(path string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconTheme").InvokeMethod("prepend_search_path", args[:], nil)

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(path)
}

// RescanIfNeeded checks to see if the icon theme has changed; if it has, any
// currently cached information is discarded and will be reloaded next time
// icon_theme is accessed.
//
// The function returns the following values:
//
//    - ok: TRUE if the icon theme has changed and needed to be reloaded.
//
func (iconTheme *IconTheme) RescanIfNeeded() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	*(**IconTheme)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "IconTheme").InvokeMethod("rescan_if_needed", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iconTheme)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetCustomTheme sets the name of the icon theme that the IconTheme object uses
// overriding system configuration. This function cannot be called on the icon
// theme objects returned from gtk_icon_theme_get_default() and
// gtk_icon_theme_get_for_screen().
//
// The function takes the following parameters:
//
//    - themeName (optional): name of icon theme to use instead of configured
//      theme, or NULL to unset a previously set custom theme.
//
func (iconTheme *IconTheme) SetCustomTheme(themeName string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	if themeName != "" {
		_arg1 = (*C.void)(unsafe.Pointer(C.CString(themeName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconTheme").InvokeMethod("set_custom_theme", args[:], nil)

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(themeName)
}

// SetScreen sets the screen for an icon theme; the screen is used to track the
// user’s currently configured icon theme, which might be different for
// different screens.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
func (iconTheme *IconTheme) SetScreen(screen *gdk.Screen) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gtk", "IconTheme").InvokeMethod("set_screen", args[:], nil)

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(screen)
}

// SetSearchPath sets the search path for the icon theme object. When looking
// for an icon theme, GTK+ will search for a subdirectory of one or more of the
// directories in path with the same name as the icon theme containing an
// index.theme file. (Themes from multiple of the path elements are combined to
// allow themes to be extended by adding icons in the user’s home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme or
// the default icon theme, and an image file with the right name is found
// directly in one of the elements of path, then that image will be used for the
// icon name. (This is legacy feature, and new icons should be put into the
// fallback icon theme, which is called hicolor, rather than directly on the
// icon path.).
//
// The function takes the following parameters:
//
//    - path: array of directories that are searched for icon themes.
//
func (iconTheme *IconTheme) SetSearchPath(path []string) {
	var args [3]girepository.Argument
	var _arg0 *C.void  // out
	var _arg1 **C.void // out
	var _arg2 C.gint

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg2 = (C.gint)(len(path))
	_arg1 = (**C.void)(C.calloc(C.size_t(len(path)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.void)(_arg1), len(path))
		for i := range path {
			out[i] = (*C.void)(unsafe.Pointer(C.CString(path[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	*(**IconTheme)(unsafe.Pointer(&args[1])) = _arg1
	*(*[]string)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "IconTheme").InvokeMethod("set_search_path", args[:], nil)

	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(path)
}

// IconThemeAddBuiltinIcon registers a built-in icon for icon theme lookups. The
// idea of built-in icons is to allow an application or library that uses themed
// icons to function requiring files to be present in the file system. For
// instance, the default images for all of GTK+’s stock icons are registered as
// built-icons.
//
// In general, if you use gtk_icon_theme_add_builtin_icon() you should also
// install the icon in the icon theme, so that the icon is generally available.
//
// This function will generally be used with pixbufs loaded via
// gdk_pixbuf_new_from_inline().
//
// Deprecated: Use gtk_icon_theme_add_resource_path() to add
// application-specific icons to the icon theme.
//
// The function takes the following parameters:
//
//    - iconName: name of the icon to register.
//    - size in pixels at which to register the icon (different images can be
//      registered for the same icon name at different sizes.).
//    - pixbuf that contains the image to use for icon_name.
//
func IconThemeAddBuiltinIcon(iconName string, size int32, pixbuf *gdkpixbuf.Pixbuf) {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gint  // out
	var _arg2 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg0))
	_arg1 = C.gint(size)
	_arg2 = (*C.void)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	*(*string)(unsafe.Pointer(&args[0])) = _arg0
	*(*int32)(unsafe.Pointer(&args[1])) = _arg1
	*(**gdkpixbuf.Pixbuf)(unsafe.Pointer(&args[2])) = _arg2

	girepository.MustFind("Gtk", "add_builtin_icon").Invoke(args[:], nil)

	runtime.KeepAlive(iconName)
	runtime.KeepAlive(size)
	runtime.KeepAlive(pixbuf)
}

// IconThemeGetDefault gets the icon theme for the default screen. See
// gtk_icon_theme_get_for_screen().
//
// The function returns the following values:
//
//    - iconTheme: unique IconTheme associated with the default screen. This icon
//      theme is associated with the screen and can be used as long as the screen
//      is open. Do not ref or unref it.
//
func IconThemeGetDefault() *IconTheme {
	var _cret *C.void // in

	_gret := girepository.MustFind("Gtk", "get_default").Invoke(nil, nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconTheme
}

// IconThemeGetForScreen gets the icon theme object associated with screen; if
// this function has not previously been called for the given screen, a new icon
// theme object will be created and associated with the screen. Icon theme
// objects are fairly expensive to create, so using this function is usually a
// better choice than calling than gtk_icon_theme_new() and setting the screen
// yourself; by using this function a single icon theme object will be shared
// between users.
//
// The function takes the following parameters:
//
//    - screen: Screen.
//
// The function returns the following values:
//
//    - iconTheme: unique IconTheme associated with the given screen. This icon
//      theme is associated with the screen and can be used as long as the screen
//      is open. Do not ref or unref it.
//
func IconThemeGetForScreen(screen *gdk.Screen) *IconTheme {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(screen).Native()))
	*(**gdk.Screen)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gtk", "get_for_screen").Invoke(args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(screen)

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconTheme
}

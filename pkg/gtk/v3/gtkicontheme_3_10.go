// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v3"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
)

// #include <stdlib.h>
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
import "C"

// BaseScale gets the base scale for the icon. The base scale is a scale for the
// icon that was specified by the icon theme creator. For instance an icon drawn
// for a high-dpi screen with window scale 2 for a base size of 32 will be 64
// pixels tall and have a base scale of 2.
//
// The function returns the following values:
//
//    - gint: base scale.
//
func (iconInfo *IconInfo) BaseScale() int {
	var _arg0 *C.GtkIconInfo // out
	var _cret C.gint         // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))

	_cret = C.gtk_icon_info_get_base_scale(_arg0)
	runtime.KeepAlive(iconInfo)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LoadSurface renders an icon previously looked up in an icon theme using
// gtk_icon_theme_lookup_icon(); the size will be based on the size passed to
// gtk_icon_theme_lookup_icon(). Note that the resulting surface may not be
// exactly this size; an icon theme may have icons that differ slightly from
// their nominal sizes, and in addition GTK+ will avoid scaling icons that it
// considers sufficiently close to the requested size or for which the source
// image would have to be scaled up too far. (This maintains sharpness.). This
// behaviour can be changed by passing the GTK_ICON_LOOKUP_FORCE_SIZE flag when
// obtaining the IconInfo. If this flag has been specified, the pixbuf returned
// by this function will be scaled to the exact size.
//
// The function takes the following parameters:
//
//    - forWindow (optional) to optimize drawing for, or NULL.
//
// The function returns the following values:
//
//    - surface: rendered icon; this may be a newly created icon or a new
//      reference to an internal icon, so you must not modify the icon. Use
//      cairo_surface_destroy() to release your reference to the icon.
//
func (iconInfo *IconInfo) LoadSurface(forWindow gdk.Windower) (*cairo.Surface, error) {
	var _arg0 *C.GtkIconInfo     // out
	var _arg1 *C.GdkWindow       // out
	var _cret *C.cairo_surface_t // in
	var _cerr *C.GError          // in

	_arg0 = (*C.GtkIconInfo)(unsafe.Pointer(coreglib.InternObject(iconInfo).Native()))
	if forWindow != nil {
		_arg1 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(forWindow).Native()))
	}

	_cret = C.gtk_icon_info_load_surface(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(iconInfo)
	runtime.KeepAlive(forWindow)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _surface, _goerr
}

// ChooseIconForScale looks up a named icon for a particular window scale and
// returns a IconInfo containing information such as the filename of the icon.
// The icon can then be rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is the
// pixbuf.)
//
// If icon_names contains more than one name, this function tries them all in
// the given order before falling back to inherited icon themes.
//
// The function takes the following parameters:
//
//    - iconNames: NULL-terminated array of icon names to lookup.
//    - size: desired icon size.
//    - scale: desired scale.
//    - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//    - iconInfo (optional) object containing information about the icon, or NULL
//      if the icon wasn’t found.
//
func (iconTheme *IconTheme) ChooseIconForScale(iconNames []string, size, scale int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 **C.gchar            // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	{
		_arg1 = (**C.gchar)(C.calloc(C.size_t((len(iconNames) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(iconNames)+1)
			var zero *C.gchar
			out[len(iconNames)] = zero
			for i := range iconNames {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(iconNames[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_choose_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconNames)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(flags)

	var _iconInfo *IconInfo // out

	if _cret != nil {
		_iconInfo = wrapIconInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _iconInfo
}

// LoadIconForScale looks up an icon in an icon theme for a particular window
// scale, scales it to the given size and renders it into a pixbuf. This is a
// convenience function; if more details about the icon are needed, use
// gtk_icon_theme_lookup_icon() followed by gtk_icon_info_load_icon().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
// If for some reason you do not want to update the icon when the icon theme
// changes, you should consider using gdk_pixbuf_copy() to make a private copy
// of the pixbuf returned by this function. Otherwise GTK+ may need to keep the
// old icon theme loaded, which would be a waste of memory.
//
// The function takes the following parameters:
//
//    - iconName: name of the icon to lookup.
//    - size: desired icon size. The resulting icon may not be exactly this size;
//      see gtk_icon_info_load_icon().
//    - scale: desired scale.
//    - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//    - pixbuf (optional): rendered icon; this may be a newly created icon or a
//      new reference to an internal icon, so you must not modify the icon. Use
//      g_object_unref() to release your reference to the icon. NULL if the icon
//      isn’t found.
//
func (iconTheme *IconTheme) LoadIconForScale(iconName string, size, scale int, flags IconLookupFlags) (*gdkpixbuf.Pixbuf, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GdkPixbuf         // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconName)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(flags)

	var _pixbuf *gdkpixbuf.Pixbuf // out
	var _goerr error              // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_pixbuf = &gdkpixbuf.Pixbuf{
				Object: obj,
				LoadableIcon: gio.LoadableIcon{
					Icon: gio.Icon{
						Object: obj,
					},
				},
			}
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// LoadSurface looks up an icon in an icon theme for a particular window scale,
// scales it to the given size and renders it into a cairo surface. This is a
// convenience function; if more details about the icon are needed, use
// gtk_icon_theme_lookup_icon() followed by gtk_icon_info_load_surface().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by connecting to the GtkWidget::style-set signal.
//
// The function takes the following parameters:
//
//    - iconName: name of the icon to lookup.
//    - size: desired icon size. The resulting icon may not be exactly this size;
//      see gtk_icon_info_load_icon().
//    - scale: desired scale.
//    - forWindow (optional) to optimize drawing for, or NULL.
//    - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//    - surface (optional): rendered icon; this may be a newly created icon or a
//      new reference to an internal icon, so you must not modify the icon. Use
//      cairo_surface_destroy() to release your reference to the icon. NULL if
//      the icon isn’t found.
//
func (iconTheme *IconTheme) LoadSurface(iconName string, size, scale int, forWindow gdk.Windower, flags IconLookupFlags) (*cairo.Surface, error) {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 *C.GdkWindow         // out
	var _arg5 C.GtkIconLookupFlags // out
	var _cret *C.cairo_surface_t   // in
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	if forWindow != nil {
		_arg4 = (*C.GdkWindow)(unsafe.Pointer(coreglib.InternObject(forWindow).Native()))
	}
	_arg5 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_load_surface(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconName)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(forWindow)
	runtime.KeepAlive(flags)

	var _surface *cairo.Surface // out
	var _goerr error            // out

	if _cret != nil {
		_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
			C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
		})
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _surface, _goerr
}

// LookupByGIconForScale looks up an icon and returns a IconInfo containing
// information such as the filename of the icon. The icon can then be rendered
// into a pixbuf using gtk_icon_info_load_icon().
//
// The function takes the following parameters:
//
//    - icon to look up.
//    - size: desired icon size.
//    - scale: desired scale.
//    - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//    - iconInfo (optional) containing information about the icon, or NULL if the
//      icon wasn’t found. Unref with g_object_unref().
//
func (iconTheme *IconTheme) LookupByGIconForScale(icon gio.Iconner, size, scale int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(flags)

	var _iconInfo *IconInfo // out

	if _cret != nil {
		_iconInfo = wrapIconInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _iconInfo
}

// LookupIconForScale looks up a named icon for a particular window scale and
// returns a IconInfo containing information such as the filename of the icon.
// The icon can then be rendered into a pixbuf using gtk_icon_info_load_icon().
// (gtk_icon_theme_load_icon() combines these two steps if all you need is the
// pixbuf.).
//
// The function takes the following parameters:
//
//    - iconName: name of the icon to lookup.
//    - size: desired icon size.
//    - scale: desired scale.
//    - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//    - iconInfo (optional) object containing information about the icon, or NULL
//      if the icon wasn’t found.
//
func (iconTheme *IconTheme) LookupIconForScale(iconName string, size, scale int, flags IconLookupFlags) *IconInfo {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.gchar             // out
	var _arg2 C.gint               // out
	var _arg3 C.gint               // out
	var _arg4 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconInfo       // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(iconTheme).Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gint(size)
	_arg3 = C.gint(scale)
	_arg4 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_icon_for_scale(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iconTheme)
	runtime.KeepAlive(iconName)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(flags)

	var _iconInfo *IconInfo // out

	if _cret != nil {
		_iconInfo = wrapIconInfo(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _iconInfo
}

// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern gboolean _gotk4_gtk3_TextCharPredicate(gunichar, gpointer);
import "C"

// GTypeTextSearchFlags returns the GType for the type TextSearchFlags.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTextSearchFlags() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "TextSearchFlags").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTextSearchFlags)
	return gtype
}

// GTypeTextIter returns the GType for the type TextIter.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTextIter() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gtk", "TextIter").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTextIter)
	return gtype
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither K_TEXT_SEARCH_VISIBLE_ONLY nor K_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded pixbufs or child widgets.
type TextSearchFlags C.guint

const (
	// TextSearchVisibleOnly: search only visible data. A search match may have
	// invisible text interspersed.
	TextSearchVisibleOnly TextSearchFlags = 0b1
	// TextSearchTextOnly: search only text. A match may have pixbufs or child
	// widgets mixed inside the matched range.
	TextSearchTextOnly TextSearchFlags = 0b10
	// TextSearchCaseInsensitive: text will be matched regardless of what case
	// it is in.
	TextSearchCaseInsensitive TextSearchFlags = 0b100
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TextSearchFlags.
func (t TextSearchFlags) String() string {
	if t == 0 {
		return "TextSearchFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(66)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TextSearchVisibleOnly:
			builder.WriteString("VisibleOnly|")
		case TextSearchTextOnly:
			builder.WriteString("TextOnly|")
		case TextSearchCaseInsensitive:
			builder.WriteString("CaseInsensitive|")
		default:
			builder.WriteString(fmt.Sprintf("TextSearchFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TextSearchFlags) Has(other TextSearchFlags) bool {
	return (t & other) == other
}

type TextCharPredicate func(ch uint32) (ok bool)

//export _gotk4_gtk3_TextCharPredicate
func _gotk4_gtk3_TextCharPredicate(arg1 C.gunichar, arg2 C.gpointer) (cret C.gboolean) {
	var fn TextCharPredicate
	{
		v := gbox.Get(uintptr(arg2))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(TextCharPredicate)
	}

	var _ch uint32 // out

	_ch = uint32(arg1)

	ok := fn(_ch)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TextIter: you may wish to begin by reading the [text widget conceptual
// overview][TextWidget] which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// An instance of this type is always passed by reference.
type TextIter struct {
	*textIter
}

// textIter is the struct that's finalized.
type textIter struct {
	native unsafe.Pointer
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TextIter{&textIter{(unsafe.Pointer)(b)}}, nil
}

// Assign assigns the value of other to iter. This function is not useful in
// applications, because iterators can be assigned with GtkTextIter i = j;. The
// function is used by language bindings.
//
// The function takes the following parameters:
//
//    - other TextIter.
//
func (iter *TextIter) Assign(other *TextIter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(other)))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(other)
}

// BackwardChar moves backward by one character offset. Returns TRUE if movement
// was possible; if iter was the first in the buffer (character offset 0),
// gtk_text_iter_backward_char() returns FALSE for convenience when writing
// loops.
//
// The function returns the following values:
//
//    - ok: whether movement was possible.
//
func (iter *TextIter) BackwardChar() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardChars moves count characters backward, if possible (if count would
// move past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then FALSE is returned. If count is 0, the function does nothing
// and returns FALSE.
//
// The function takes the following parameters:
//
//    - count: number of characters to move.
//
// The function returns the following values:
//
//    - ok: whether iter moved and is dereferenceable.
//
func (iter *TextIter) BackwardChars(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved.
//
func (iter *TextIter) BackwardCursorPosition() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPositions moves up to count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
//
// The function takes the following parameters:
//
//    - count: number of positions to move.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved and the new position is dereferenceable.
//
func (iter *TextIter) BackwardCursorPositions(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardFindChar: same as gtk_text_iter_forward_find_char(), but goes
// backward from iter.
//
// The function takes the following parameters:
//
//    - pred: function to be called on each character.
//    - limit (optional): search limit, or NULL for none.
//
// The function returns the following values:
//
//    - ok: whether a match was found.
//
func (iter *TextIter) BackwardFindChar(pred TextCharPredicate, limit *TextIter) bool {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_gtk3_TextCharPredicate)
	_args[2] = C.gpointer(gbox.Assign(pred))
	defer gbox.Delete(uintptr(_args[2]))
	if limit != nil {
		*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(limit)))
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(pred)
	runtime.KeepAlive(limit)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLine moves iter to the start of the previous line. Returns TRUE if
// iter could be moved; i.e. if iter was at character offset 0, this function
// returns FALSE. Therefore if iter was already on line 0, but not at the start
// of the line, iter is snapped to the start of the line and the function
// returns TRUE. (Note that this implies that in a loop calling this function,
// the line number may not change on every iteration, if your first iteration is
// on line 0.).
//
// The function returns the following values:
//
//    - ok: whether iter moved.
//
func (iter *TextIter) BackwardLine() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLines moves count lines backward, if possible (if count would move
// past the start or end of the buffer, moves to the start or end of the
// buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then FALSE is returned. If count is 0, the function does nothing
// and returns FALSE. If count is negative, moves forward by 0 - count lines.
//
// The function takes the following parameters:
//
//    - count: number of lines to move backward.
//
// The function returns the following values:
//
//    - ok: whether iter moved and is dereferenceable.
//
func (iter *TextIter) BackwardLines(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSentenceStart moves backward to the previous sentence start; if iter
// is already at the start of a sentence, moves backward to the next one.
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango text boundary
// algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) BackwardSentenceStart() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// count times, or until it returns FALSE. If count is negative, moves forward
// instead of backward.
//
// The function takes the following parameters:
//
//    - count: number of sentences to move.
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) BackwardSentenceStarts(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardToTagToggle moves backward to the next toggle (on or off) of the
// TextTag tag, or to the next toggle of any tag if tag is NULL. If no matching
// tag toggles are found, returns FALSE, otherwise TRUE. Does not return toggles
// located at iter, only toggles before iter. Sets iter to the location of the
// toggle, or the start of the buffer if no toggle is found.
//
// The function takes the following parameters:
//
//    - tag (optional) or NULL.
//
// The function returns the following values:
//
//    - ok: whether we found a tag toggle before iter.
//
func (iter *TextIter) BackwardToTagToggle(tag *TextTag) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPosition moves iter forward to the previous visible
// cursor position. See gtk_text_iter_backward_cursor_position() for details.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved and the new position is dereferenceable.
//
func (iter *TextIter) BackwardVisibleCursorPosition() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPositions moves up to count visible cursor positions.
// See gtk_text_iter_backward_cursor_position() for details.
//
// The function takes the following parameters:
//
//    - count: number of positions to move.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved and the new position is dereferenceable.
//
func (iter *TextIter) BackwardVisibleCursorPositions(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLine moves iter to the start of the previous visible line.
// Returns TRUE if iter could be moved; i.e. if iter was at character offset 0,
// this function returns FALSE. Therefore if iter was already on line 0, but not
// at the start of the line, iter is snapped to the start of the line and the
// function returns TRUE. (Note that this implies that in a loop calling this
// function, the line number may not change on every iteration, if your first
// iteration is on line 0.).
//
// The function returns the following values:
//
//    - ok: whether iter moved.
//
func (iter *TextIter) BackwardVisibleLine() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLines moves count visible lines backward, if possible (if
// count would move past the start or end of the buffer, moves to the start or
// end of the buffer). The return value indicates whether the iterator moved
// onto a dereferenceable position; if the iterator didn’t move, or moved onto
// the end iterator, then FALSE is returned. If count is 0, the function does
// nothing and returns FALSE. If count is negative, moves forward by 0 - count
// lines.
//
// The function takes the following parameters:
//
//    - count: number of lines to move backward.
//
// The function returns the following values:
//
//    - ok: whether iter moved and is dereferenceable.
//
func (iter *TextIter) BackwardVisibleLines(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStart moves backward to the previous visible word start.
// (If iter is currently on a word start, moves backward to the next one after
// that.) Word breaks are determined by Pango and should be correct for nearly
// any language (if not, the correct fix would be to the Pango word break
// algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) BackwardVisibleWordStart() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to count times.
//
// The function takes the following parameters:
//
//    - count: number of times to move.
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) BackwardVisibleWordStarts(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStart moves backward to the previous word start. (If iter is
// currently on a word start, moves backward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) BackwardWordStart() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to count
// times.
//
// The function takes the following parameters:
//
//    - count: number of times to move.
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) BackwardWordStarts(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// BeginsTag returns TRUE if tag is toggled on at exactly this point. If tag is
// NULL, returns TRUE if any tag is toggled on at this point.
//
// Note that if gtk_text_iter_begins_tag() returns TRUE, it means that iter is
// at the beginning of the tagged range, and that the character at iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_begins_tag() returns TRUE, gtk_text_iter_has_tag() will also
// return TRUE for the same parameters.
//
// Deprecated: Use gtk_text_iter_starts_tag() instead.
//
// The function takes the following parameters:
//
//    - tag (optional) or NULL.
//
// The function returns the following values:
//
//    - ok: whether iter is the start of a range tagged with tag.
//
func (iter *TextIter) BeginsTag(tag *TextTag) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at iter would be
// editable. If text inserted at iter would be editable then the user should be
// allowed to insert text at iter. gtk_text_buffer_insert_interactive() uses
// this function to decide whether insertions are allowed at a given position.
//
// The function takes the following parameters:
//
//    - defaultEditability: TRUE if text is editable by default.
//
// The function returns the following values:
//
//    - ok: whether text inserted at iter would be editable.
//
func (iter *TextIter) CanInsert(defaultEditability bool) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if defaultEditability {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(defaultEditability)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Compare: qsort()-style function that returns negative if lhs is less than
// rhs, positive if lhs is greater than rhs, and 0 if they’re equal. Ordering is
// in character offset order, i.e. the first character in the buffer is less
// than the second character in the buffer.
//
// The function takes the following parameters:
//
//    - rhs: another TextIter.
//
// The function returns the following values:
//
//    - gint: -1 if lhs is less than rhs, 1 if lhs is greater, 0 if they are
//      equal.
//
func (lhs *TextIter) Compare(rhs *TextIter) int32 {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(lhs)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(rhs)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(lhs)
	runtime.KeepAlive(rhs)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Copy creates a dynamically-allocated copy of an iterator. This function is
// not useful in applications, because iterators can be copied with a simple
// assignment (GtkTextIter i = j;). The function is used by language bindings.
//
// The function returns the following values:
//
//    - textIter: copy of the iter, free with gtk_text_iter_free().
//
func (iter *TextIter) Copy() *TextIter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _textIter *TextIter // out

	_textIter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_textIter)),
		func(intern *struct{ C unsafe.Pointer }) {
			{
				args := [1]girepository.Argument{(*C.void)(intern.C)}
				girepository.MustFind("Gtk", "TextIter").InvokeMethod("free", args[:], nil)
			}
		},
	)

	return _textIter
}

// Editable returns whether the character at iter is within an editable region
// of text. Non-editable text is “locked” and can’t be changed by the user via
// TextView. This function is simply a convenience wrapper around
// gtk_text_iter_get_attributes(). If no tags applied to this text affect
// editability, default_setting will be returned.
//
// You don’t want to use this function to decide whether text can be inserted at
// iter, because for insertion you don’t want to know whether the char at iter
// is inside an editable range, you want to know whether a new character
// inserted at iter would be inside an editable range. Use
// gtk_text_iter_can_insert() to handle this case.
//
// The function takes the following parameters:
//
//    - defaultSetting: TRUE if text is editable by default.
//
// The function returns the following values:
//
//    - ok: whether iter is inside an editable range.
//
func (iter *TextIter) Editable(defaultSetting bool) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if defaultSetting {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(defaultSetting)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// EndsLine returns TRUE if iter points to the start of the paragraph delimiter
// characters for a line (delimiters will be either a newline, a carriage
// return, a carriage return followed by a newline, or a Unicode paragraph
// separator character). Note that an iterator pointing to the \n of a \r\n pair
// will not be counted as the end of a line, the line ends before the \r. The
// end iterator is considered to be at the end of a line, even though there are
// no paragraph delimiter chars there.
//
// The function returns the following values:
//
//    - ok: whether iter is at the end of a line.
//
func (iter *TextIter) EndsLine() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// EndsSentence determines whether iter ends a sentence. Sentence boundaries are
// determined by Pango and should be correct for nearly any language (if not,
// the correct fix would be to the Pango text boundary algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter is at the end of a sentence.
//
func (iter *TextIter) EndsSentence() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// EndsTag returns TRUE if tag is toggled off at exactly this point. If tag is
// NULL, returns TRUE if any tag is toggled off at this point.
//
// Note that if gtk_text_iter_ends_tag() returns TRUE, it means that iter is at
// the end of the tagged range, but that the character at iter is outside the
// tagged range. In other words, unlike gtk_text_iter_starts_tag(), if
// gtk_text_iter_ends_tag() returns TRUE, gtk_text_iter_has_tag() will return
// FALSE for the same parameters.
//
// The function takes the following parameters:
//
//    - tag (optional) or NULL.
//
// The function returns the following values:
//
//    - ok: whether iter is the end of a range tagged with tag.
//
func (iter *TextIter) EndsTag(tag *TextTag) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// EndsWord determines whether iter ends a natural-language word. Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter is at the end of a word.
//
func (iter *TextIter) EndsWord() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Equal tests whether two iterators are equal, using the fastest possible
// mechanism. This function is very fast; you can expect it to perform better
// than e.g. getting the character offset for each iterator and comparing the
// offsets yourself. Also, it’s a bit faster than gtk_text_iter_compare().
//
// The function takes the following parameters:
//
//    - rhs: another TextIter.
//
// The function returns the following values:
//
//    - ok: TRUE if the iterators point to the same place in the buffer.
//
func (lhs *TextIter) Equal(rhs *TextIter) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(lhs)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(rhs)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(lhs)
	runtime.KeepAlive(rhs)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChar moves iter forward by one character offset. Note that images
// embedded in the buffer occupy 1 character slot, so
// gtk_text_iter_forward_char() may actually move onto an image instead of a
// character, if you have images in your buffer. If iter is the end iterator or
// one character before it, iter will now point at the end iterator, and
// gtk_text_iter_forward_char() returns FALSE for convenience when writing
// loops.
//
// The function returns the following values:
//
//    - ok: whether iter moved and is dereferenceable.
//
func (iter *TextIter) ForwardChar() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChars moves count characters if possible (if count would move past the
// start or end of the buffer, moves to the start or end of the buffer). The
// return value indicates whether the new position of iter is different from its
// original position, and dereferenceable (the last iterator in the buffer is
// not dereferenceable). If count is 0, the function does nothing and returns
// FALSE.
//
// The function takes the following parameters:
//
//    - count: number of characters to move, may be negative.
//
// The function returns the following values:
//
//    - ok: whether iter moved and is dereferenceable.
//
func (iter *TextIter) ForwardChars(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPosition moves iter forward by a single cursor position. Cursor
// positions are (unsurprisingly) positions where the cursor can appear. Perhaps
// surprisingly, there may not be a cursor position between all characters. The
// most common example for European languages would be a carriage return/newline
// sequence. For some Unicode characters, the equivalent of say the letter “a”
// with an accent mark will be represented as two characters, first the letter
// then a "combining mark" that causes the accent to be rendered; so the cursor
// can’t go between those two characters. See also the LogAttr-struct and
// pango_break() function.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved and the new position is dereferenceable.
//
func (iter *TextIter) ForwardCursorPosition() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPositions moves up to count cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
//
// The function takes the following parameters:
//
//    - count: number of positions to move.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved and the new position is dereferenceable.
//
func (iter *TextIter) ForwardCursorPositions(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardFindChar advances iter, calling pred on each character. If pred
// returns TRUE, returns TRUE and stops scanning. If pred never returns TRUE,
// iter is set to limit if limit is non-NULL, otherwise to the end iterator.
//
// The function takes the following parameters:
//
//    - pred: function to be called on each character.
//    - limit (optional): search limit, or NULL for none.
//
// The function returns the following values:
//
//    - ok: whether a match was found.
//
func (iter *TextIter) ForwardFindChar(pred TextCharPredicate, limit *TextIter) bool {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_gtk3_TextCharPredicate)
	_args[2] = C.gpointer(gbox.Assign(pred))
	defer gbox.Delete(uintptr(_args[2]))
	if limit != nil {
		*(**C.void)(unsafe.Pointer(&_args[3])) = (*C.void)(gextras.StructNative(unsafe.Pointer(limit)))
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(pred)
	runtime.KeepAlive(limit)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLine moves iter to the start of the next line. If the iter is already
// on the last line of the buffer, moves the iter to the end of the current
// line. If after the operation, the iter is at the end of the buffer and not
// dereferencable, returns FALSE. Otherwise, returns TRUE.
//
// The function returns the following values:
//
//    - ok: whether iter can be dereferenced.
//
func (iter *TextIter) ForwardLine() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLines moves count lines forward, if possible (if count would move past
// the start or end of the buffer, moves to the start or end of the buffer). The
// return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves backward by 0 - count lines.
//
// The function takes the following parameters:
//
//    - count: number of lines to move forward.
//
// The function returns the following values:
//
//    - ok: whether iter moved and is dereferenceable.
//
func (iter *TextIter) ForwardLines(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSentenceEnd moves forward to the next sentence end. (If iter is at the
// end of a sentence, moves to the next end of sentence.) Sentence boundaries
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango text boundary algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) ForwardSentenceEnd() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() count times
// (or until gtk_text_iter_forward_sentence_end() returns FALSE). If count is
// negative, moves backward instead of forward.
//
// The function takes the following parameters:
//
//    - count: number of sentences to move.
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) ForwardSentenceEnds(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToEnd moves iter forward to the “end iterator,” which points one past
// the last valid character in the buffer. gtk_text_iter_get_char() called on
// the end iterator returns 0, which is convenient for writing loops.
func (iter *TextIter) ForwardToEnd() {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	runtime.KeepAlive(iter)
}

// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters, which will be either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character. If
// the iterator is already at the paragraph delimiter characters, moves to the
// paragraph delimiter characters for the next line. If iter is on the last line
// in the buffer, which does not end in paragraph delimiters, moves to the end
// iterator (end of the last line), and returns FALSE.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved and the new location is not the end iterator.
//
func (iter *TextIter) ForwardToLineEnd() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToTagToggle moves forward to the next toggle (on or off) of the
// TextTag tag, or to the next toggle of any tag if tag is NULL. If no matching
// tag toggles are found, returns FALSE, otherwise TRUE. Does not return toggles
// located at iter, only toggles after iter. Sets iter to the location of the
// toggle, or to the end of the buffer if no toggle is found.
//
// The function takes the following parameters:
//
//    - tag (optional) or NULL.
//
// The function returns the following values:
//
//    - ok: whether we found a tag toggle after iter.
//
func (iter *TextIter) ForwardToTagToggle(tag *TextTag) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPosition moves iter forward to the next visible cursor
// position. See gtk_text_iter_forward_cursor_position() for details.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved and the new position is dereferenceable.
//
func (iter *TextIter) ForwardVisibleCursorPosition() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPositions moves up to count visible cursor positions. See
// gtk_text_iter_forward_cursor_position() for details.
//
// The function takes the following parameters:
//
//    - count: number of positions to move.
//
// The function returns the following values:
//
//    - ok: TRUE if we moved and the new position is dereferenceable.
//
func (iter *TextIter) ForwardVisibleCursorPositions(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLine moves iter to the start of the next visible line. Returns
// TRUE if there was a next line to move to, and FALSE if iter was simply moved
// to the end of the buffer and is now not dereferenceable, or if iter was
// already at the end of the buffer.
//
// The function returns the following values:
//
//    - ok: whether iter can be dereferenced.
//
func (iter *TextIter) ForwardVisibleLine() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLines moves count visible lines forward, if possible (if count
// would move past the start or end of the buffer, moves to the start or end of
// the buffer). The return value indicates whether the iterator moved onto a
// dereferenceable position; if the iterator didn’t move, or moved onto the end
// iterator, then FALSE is returned. If count is 0, the function does nothing
// and returns FALSE. If count is negative, moves backward by 0 - count lines.
//
// The function takes the following parameters:
//
//    - count: number of lines to move forward.
//
// The function returns the following values:
//
//    - ok: whether iter moved and is dereferenceable.
//
func (iter *TextIter) ForwardVisibleLines(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnd moves forward to the next visible word end. (If iter is
// currently on a word end, moves forward to the next one after that.) Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) ForwardVisibleWordEnd() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// count times.
//
// The function takes the following parameters:
//
//    - count: number of times to move.
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) ForwardVisibleWordEnds(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnd moves forward to the next word end. (If iter is currently on a
// word end, moves forward to the next one after that.) Word breaks are
// determined by Pango and should be correct for nearly any language (if not,
// the correct fix would be to the Pango word break algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) ForwardWordEnd() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to count times.
//
// The function takes the following parameters:
//
//    - count: number of times to move.
//
// The function returns the following values:
//
//    - ok: TRUE if iter moved and is not the end iterator.
//
func (iter *TextIter) ForwardWordEnds(count int32) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(count)

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Attributes computes the effect of any tags applied to this spot in the text.
// The values parameter should be initialized to the default settings you wish
// to use if no tags are in effect. You’d typically obtain the defaults from
// gtk_text_view_get_default_attributes().
//
// gtk_text_iter_get_attributes() will modify values, applying the effects of
// any tags present at iter. If any tags affected values, the function returns
// TRUE.
//
// The function returns the following values:
//
//    - values to be filled in.
//    - ok: TRUE if values was modified.
//
func (iter *TextIter) Attributes() (*TextAttributes, bool) {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _values *TextAttributes // out
	var _ok bool                // out

	_values = (*TextAttributes)(gextras.NewStructNative(unsafe.Pointer(_outs[0])))
	C.gtk_text_attributes_ref(_outs[0])
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_values)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)
	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _values, _ok
}

// Buffer returns the TextBuffer this iterator is associated with.
//
// The function returns the following values:
//
//    - textBuffer: buffer.
//
func (iter *TextIter) Buffer() *TextBuffer {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _textBuffer
}

// BytesInLine returns the number of bytes in the line containing iter,
// including the paragraph delimiters.
//
// The function returns the following values:
//
//    - gint: number of bytes in the line.
//
func (iter *TextIter) BytesInLine() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Char: unicode character at this iterator is returned. (Equivalent to
// operator* on a C++ iterator.) If the element at this iterator is a
// non-character element, such as an image embedded in the buffer, the Unicode
// “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character. So you can write a loop
// which ends when gtk_text_iter_get_char() returns 0.
//
// The function returns the following values:
//
//    - gunichar: unicode character, or 0 if iter is not dereferenceable.
//
func (iter *TextIter) Char() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gunichar)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gunichar uint32 // out

	_gunichar = uint32(*(*C.gunichar)(unsafe.Pointer(&_cret)))

	return _gunichar
}

// CharsInLine returns the number of characters in the line containing iter,
// including the paragraph delimiters.
//
// The function returns the following values:
//
//    - gint: number of characters in the line.
//
func (iter *TextIter) CharsInLine() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// ChildAnchor: if the location at iter contains a child anchor, the anchor is
// returned (with no new reference count added). Otherwise, NULL is returned.
//
// The function returns the following values:
//
//    - textChildAnchor: anchor at iter.
//
func (iter *TextIter) ChildAnchor() *TextChildAnchor {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// Language: convenience wrapper around gtk_text_iter_get_attributes(), which
// returns the language in effect at iter. If no tags affecting language apply
// to iter, the return value is identical to that of gtk_get_default_language().
//
// The function returns the following values:
//
//    - language in effect at iter.
//
func (iter *TextIter) Language() *pango.Language {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _language *pango.Language // out

	_language = (*pango.Language)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_language)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _language
}

// Line returns the line number containing the iterator. Lines in a TextBuffer
// are numbered beginning with 0 for the first line in the buffer.
//
// The function returns the following values:
//
//    - gint: line number.
//
func (iter *TextIter) Line() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line. Remember that TextBuffer encodes text in UTF-8,
// and that characters can require a variable number of bytes to represent.
//
// The function returns the following values:
//
//    - gint: distance from start of line, in bytes.
//
func (iter *TextIter) LineIndex() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line. The first character on the line has
// offset 0.
//
// The function returns the following values:
//
//    - gint: offset from start of line.
//
func (iter *TextIter) LineOffset() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Marks returns a list of all TextMark at this location. Because marks are not
// iterable (they don’t take up any "space" in the buffer, they are just marks
// in between iterable locations), multiple marks can exist in the same place.
// The returned list is not in any meaningful order.
//
// The function returns the following values:
//
//    - sList: list of TextMark.
//
func (iter *TextIter) Marks() []*TextMark {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _sList []*TextMark // out

	_sList = make([]*TextMark, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *TextMark // out
		dst = wrapTextMark(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// Offset returns the character offset of an iterator. Each character in a
// TextBuffer has an offset, starting with 0 for the first character in the
// buffer. Use gtk_text_buffer_get_iter_at_offset() to convert an offset back
// into an iterator.
//
// The function returns the following values:
//
//    - gint: character offset.
//
func (iter *TextIter) Offset() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// Pixbuf: if the element at iter is a pixbuf, the pixbuf is returned (with no
// new reference count added). Otherwise, NULL is returned.
//
// The function returns the following values:
//
//    - pixbuf at iter.
//
func (iter *TextIter) Pixbuf() *gdkpixbuf.Pixbuf {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _pixbuf *gdkpixbuf.Pixbuf // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_pixbuf = &gdkpixbuf.Pixbuf{
			Object: obj,
			LoadableIcon: gio.LoadableIcon{
				Icon: gio.Icon{
					Object: obj,
				},
			},
		}
	}

	return _pixbuf
}

// Slice returns the text in the given range. A “slice” is an array of
// characters encoded in UTF-8 format, including the Unicode “unknown” character
// 0xFFFC for iterable non-character elements in the buffer, such as images.
// Because images are encoded in the slice, byte and character offsets in the
// returned array will correspond to byte offsets in the text buffer. Note that
// 0xFFFC can occur in normal text as well, so it is not a reliable indicator
// that a pixbuf or widget is in the buffer.
//
// The function takes the following parameters:
//
//    - end: iterator at end of a range.
//
// The function returns the following values:
//
//    - utf8: slice of text from the buffer.
//
func (start *TextIter) Slice(end *TextIter) string {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Tags returns a list of tags that apply to iter, in ascending order of
// priority (highest-priority tags are last). The TextTag in the list don’t have
// a reference added, but you have to free the list itself.
//
// The function returns the following values:
//
//    - sList: list of TextTag.
//
func (iter *TextIter) Tags() []*TextTag {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _sList []*TextTag // out

	_sList = make([]*TextTag, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *TextTag // out
		dst = wrapTextTag(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// Text returns text in the given range. If the range contains non-text elements
// such as images, the character and byte offsets in the returned string will
// not correspond to character and byte offsets in the buffer. If you want
// offsets to correspond, see gtk_text_iter_get_slice().
//
// The function takes the following parameters:
//
//    - end: iterator at end of a range.
//
// The function returns the following values:
//
//    - utf8: array of characters from the buffer.
//
func (start *TextIter) Text(end *TextIter) string {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToggledTags returns a list of TextTag that are toggled on or off at this
// point. (If toggled_on is TRUE, the list contains tags that are toggled on.)
// If a tag is toggled on at iter, then some non-empty range of characters
// following iter has that tag applied to it. If a tag is toggled off, then some
// non-empty range following iter does not have the tag applied to it.
//
// The function takes the following parameters:
//
//    - toggledOn: TRUE to get toggled-on tags.
//
// The function returns the following values:
//
//    - sList tags toggled at this point.
//
func (iter *TextIter) ToggledTags(toggledOn bool) []*TextTag {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if toggledOn {
		*(*C.gboolean)(unsafe.Pointer(&_args[1])) = C.TRUE
	}

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(toggledOn)

	var _sList []*TextTag // out

	_sList = make([]*TextTag, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.void)(v)
		var dst *TextTag // out
		dst = wrapTextTag(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// VisibleLineIndex returns the number of bytes from the start of the line to
// the given iter, not counting bytes that are invisible due to tags with the
// “invisible” flag toggled on.
//
// The function returns the following values:
//
//    - gint: byte index of iter with respect to the start of the line.
//
func (iter *TextIter) VisibleLineIndex() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// VisibleLineOffset returns the offset in characters from the start of the line
// to the given iter, not counting characters that are invisible due to tags
// with the “invisible” flag toggled on.
//
// The function returns the following values:
//
//    - gint: offset in visible characters from the start of the line.
//
func (iter *TextIter) VisibleLineOffset() int32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _gint int32 // out

	_gint = int32(*(*C.gint)(unsafe.Pointer(&_cret)))

	return _gint
}

// VisibleSlice: like gtk_text_iter_get_slice(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
//
// The function takes the following parameters:
//
//    - end: iterator at end of range.
//
// The function returns the following values:
//
//    - utf8: slice of text from the buffer.
//
func (start *TextIter) VisibleSlice(end *TextIter) string {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VisibleText: like gtk_text_iter_get_text(), but invisible text is not
// included. Invisible text is usually invisible because a TextTag with the
// “invisible” attribute turned on has been applied to it.
//
// The function takes the following parameters:
//
//    - end: iterator at end of range.
//
// The function returns the following values:
//
//    - utf8: string containing visible text in the range.
//
func (start *TextIter) VisibleText(end *TextIter) string {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasTag returns TRUE if iter points to a character that is part of a range
// tagged with tag. See also gtk_text_iter_starts_tag() and
// gtk_text_iter_ends_tag().
//
// The function takes the following parameters:
//
//    - tag: TextTag.
//
// The function returns the following values:
//
//    - ok: whether iter is tagged with tag.
//
func (iter *TextIter) HasTag(tag *TextTag) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// InRange checks whether iter falls in the range [start, end). start and end
// must be in ascending order.
//
// The function takes the following parameters:
//
//    - start of range.
//    - end of range.
//
// The function returns the following values:
//
//    - ok: TRUE if iter is in the range.
//
func (iter *TextIter) InRange(start *TextIter, end *TextIter) bool {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(start)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// InsideSentence determines whether iter is inside a sentence (as opposed to in
// between two sentences, e.g. after a period and before the first letter of the
// next sentence). Sentence boundaries are determined by Pango and should be
// correct for nearly any language (if not, the correct fix would be to the
// Pango text boundary algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter is inside a sentence.
//
func (iter *TextIter) InsideSentence() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// InsideWord determines whether the character pointed by iter is part of a
// natural-language word (as opposed to say inside some whitespace). Word breaks
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango word break algorithms).
//
// Note that if gtk_text_iter_starts_word() returns TRUE, then this function
// returns TRUE too, since iter points to the first character of the word.
//
// The function returns the following values:
//
//    - ok: TRUE if iter is inside a word.
//
func (iter *TextIter) InsideWord() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsCursorPosition: see gtk_text_iter_forward_cursor_position() or LogAttr or
// pango_break() for details on what a cursor position is.
//
// The function returns the following values:
//
//    - ok: TRUE if the cursor can be placed at iter.
//
func (iter *TextIter) IsCursorPosition() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsEnd returns TRUE if iter is the end iterator, i.e. one past the last
// dereferenceable iterator in the buffer. gtk_text_iter_is_end() is the most
// efficient way to check whether an iterator is the end iterator.
//
// The function returns the following values:
//
//    - ok: whether iter is the end iterator.
//
func (iter *TextIter) IsEnd() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsStart returns TRUE if iter is the first iterator in the buffer, that is if
// iter has a character offset of 0.
//
// The function returns the following values:
//
//    - ok: whether iter is the first in the buffer.
//
func (iter *TextIter) IsStart() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Order swaps the value of first and second if second comes before first in the
// buffer. That is, ensures that first and second are in sequence. Most text
// buffer functions that take a range call this automatically on your behalf, so
// there’s no real reason to call it yourself in those cases. There are some
// exceptions, such as gtk_text_iter_in_range(), that expect a pre-sorted range.
//
// The function takes the following parameters:
//
//    - second: another TextIter.
//
func (first *TextIter) Order(second *TextIter) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(first)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(second)))

	runtime.KeepAlive(first)
	runtime.KeepAlive(second)
}

// SetLine moves iterator iter to the start of the line line_number. If
// line_number is negative or larger than the number of lines in the buffer,
// moves iter to the start of the last line in the buffer.
//
// The function takes the following parameters:
//
//    - lineNumber: line number (counted from 0).
//
func (iter *TextIter) SetLine(lineNumber int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(lineNumber)

	runtime.KeepAlive(iter)
	runtime.KeepAlive(lineNumber)
}

// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it can’t be
// in the middle of a UTF-8 encoded character.
//
// The function takes the following parameters:
//
//    - byteOnLine: byte index relative to the start of iter’s current line.
//
func (iter *TextIter) SetLineIndex(byteOnLine int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(byteOnLine)

	runtime.KeepAlive(iter)
	runtime.KeepAlive(byteOnLine)
}

// SetLineOffset moves iter within a line, to a new character (not byte) offset.
// The given character offset must be less than or equal to the number of
// characters in the line; if equal, iter moves to the start of the next line.
// See gtk_text_iter_set_line_index() if you have a byte index rather than a
// character offset.
//
// The function takes the following parameters:
//
//    - charOnLine: character offset relative to the start of iter’s current
//      line.
//
func (iter *TextIter) SetLineOffset(charOnLine int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(charOnLine)

	runtime.KeepAlive(iter)
	runtime.KeepAlive(charOnLine)
}

// SetOffset sets iter to point to char_offset. char_offset counts from the
// start of the entire text buffer, starting with 0.
//
// The function takes the following parameters:
//
//    - charOffset: character number.
//
func (iter *TextIter) SetOffset(charOffset int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(charOffset)

	runtime.KeepAlive(iter)
	runtime.KeepAlive(charOffset)
}

// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
//
// The function takes the following parameters:
//
//    - byteOnLine: byte index.
//
func (iter *TextIter) SetVisibleLineIndex(byteOnLine int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(byteOnLine)

	runtime.KeepAlive(iter)
	runtime.KeepAlive(byteOnLine)
}

// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
//
// The function takes the following parameters:
//
//    - charOnLine: character offset.
//
func (iter *TextIter) SetVisibleLineOffset(charOnLine int32) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	*(*C.gint)(unsafe.Pointer(&_args[1])) = C.gint(charOnLine)

	runtime.KeepAlive(iter)
	runtime.KeepAlive(charOnLine)
}

// StartsLine returns TRUE if iter begins a paragraph, i.e. if
// gtk_text_iter_get_line_offset() would return 0. However this function is
// potentially more efficient than gtk_text_iter_get_line_offset() because it
// doesn’t have to compute the offset, it just has to see whether it’s 0.
//
// The function returns the following values:
//
//    - ok: whether iter begins a line.
//
func (iter *TextIter) StartsLine() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// StartsSentence determines whether iter begins a sentence. Sentence boundaries
// are determined by Pango and should be correct for nearly any language (if
// not, the correct fix would be to the Pango text boundary algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter is at the start of a sentence.
//
func (iter *TextIter) StartsSentence() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// StartsTag returns TRUE if tag is toggled on at exactly this point. If tag is
// NULL, returns TRUE if any tag is toggled on at this point.
//
// Note that if gtk_text_iter_starts_tag() returns TRUE, it means that iter is
// at the beginning of the tagged range, and that the character at iter is
// inside the tagged range. In other words, unlike gtk_text_iter_ends_tag(), if
// gtk_text_iter_starts_tag() returns TRUE, gtk_text_iter_has_tag() will also
// return TRUE for the same parameters.
//
// The function takes the following parameters:
//
//    - tag (optional) or NULL.
//
// The function returns the following values:
//
//    - ok: whether iter is the start of a range tagged with tag.
//
func (iter *TextIter) StartsTag(tag *TextTag) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// StartsWord determines whether iter begins a natural-language word. Word
// breaks are determined by Pango and should be correct for nearly any language
// (if not, the correct fix would be to the Pango word break algorithms).
//
// The function returns the following values:
//
//    - ok: TRUE if iter is at the start of a word.
//
func (iter *TextIter) StartsWord() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// TogglesTag: this is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag()), i.e. it tells you whether a range with tag applied
// to it begins or ends at iter.
//
// The function takes the following parameters:
//
//    - tag (optional) or NULL.
//
// The function returns the following values:
//
//    - ok: whether tag is toggled on or off at iter.
//
func (iter *TextIter) TogglesTag(tag *TextTag) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

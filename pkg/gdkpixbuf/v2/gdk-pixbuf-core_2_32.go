// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
import "C"

// NewPixbufFromBytes creates a new Pixbuf out of in-memory readonly image data.
//
// Currently only RGB images with 8 bits per sample are supported.
//
// This is the GBytes variant of gdk_pixbuf_new_from_data(), useful for language
// bindings.
//
// The function takes the following parameters:
//
//    - data: image data in 8-bit/sample packed format inside a #GBytes.
//    - colorspace: colorspace for the image data.
//    - hasAlpha: whether the data has an opacity channel.
//    - bitsPerSample: number of bits per sample.
//    - width: width of the image in pixels, must be > 0.
//    - height: height of the image in pixels, must be > 0.
//    - rowstride: distance in bytes between row starts.
//
// The function returns the following values:
//
//    - pixbuf: newly-created pixbuf.
//
func NewPixbufFromBytes(data *glib.Bytes, colorspace Colorspace, hasAlpha bool, bitsPerSample, width, height, rowstride int) *Pixbuf {
	var _arg1 *C.GBytes       // out
	var _arg2 C.GdkColorspace // out
	var _arg3 C.gboolean      // out
	var _arg4 C.int           // out
	var _arg5 C.int           // out
	var _arg6 C.int           // out
	var _arg7 C.int           // out
	var _cret *C.GdkPixbuf    // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))
	_arg2 = C.GdkColorspace(colorspace)
	if hasAlpha {
		_arg3 = C.TRUE
	}
	_arg4 = C.int(bitsPerSample)
	_arg5 = C.int(width)
	_arg6 = C.int(height)
	_arg7 = C.int(rowstride)

	_cret = C.gdk_pixbuf_new_from_bytes(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(data)
	runtime.KeepAlive(colorspace)
	runtime.KeepAlive(hasAlpha)
	runtime.KeepAlive(bitsPerSample)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(rowstride)

	var _pixbuf *Pixbuf // out

	_pixbuf = wrapPixbuf(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pixbuf
}

// Options returns a GHashTable with a list of all the options that may have
// been attached to the pixbuf when it was loaded, or that may have been
// attached by another function using gdkpixbuf.Pixbuf.SetOption().
//
// The function returns the following values:
//
//    - hashTable: Table of key/values pairs.
//
func (pixbuf *Pixbuf) Options() map[string]string {
	var _arg0 *C.GdkPixbuf  // out
	var _cret *C.GHashTable // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	_cret = C.gdk_pixbuf_get_options(_arg0)
	runtime.KeepAlive(pixbuf)

	var _hashTable map[string]string // out

	_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.gchar)(v)
		var kdst string // out
		var vdst string // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
		_hashTable[kdst] = vdst
	})

	return _hashTable
}

// ReadPixelBytes provides a #GBytes buffer containing the raw pixel data; the
// data must not be modified.
//
// This function allows skipping the implicit copy that must be made if
// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
//
// The function returns the following values:
//
//    - bytes: new reference to a read-only copy of the pixel data. Note that for
//      mutable pixbufs, this function will incur a one-time copy of the pixel
//      data for conversion into the returned #GBytes.
//
func (pixbuf *Pixbuf) ReadPixelBytes() *glib.Bytes {
	var _arg0 *C.GdkPixbuf // out
	var _cret *C.GBytes    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	_cret = C.gdk_pixbuf_read_pixel_bytes(_arg0)
	runtime.KeepAlive(pixbuf)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// ReadPixels provides a read-only pointer to the raw pixel data.
//
// This function allows skipping the implicit copy that must be made if
// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
//
// The function returns the following values:
//
//    - guint8: read-only pointer to the raw pixel data.
//
func (pixbuf *Pixbuf) ReadPixels() *byte {
	var _arg0 *C.GdkPixbuf // out
	var _cret *C.guint8    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))

	_cret = C.gdk_pixbuf_read_pixels(_arg0)
	runtime.KeepAlive(pixbuf)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

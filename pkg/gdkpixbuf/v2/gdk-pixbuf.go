// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #cgo pkg-config: gdk-pixbuf-2.0
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
// #include <glib-object.h>
// gboolean _gotk4_gdkpixbuf2_PixbufSaveFunc(gchar*, gsize, GError**, gpointer);
// void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gdk_pixbuf_get_type()), F: marshalPixbuffer},
	})
}

// Pixbuf: pixel buffer.
//
// GdkPixbuf contains information about an image's pixel data, its color space,
// bits per sample, width and height, and the rowstride (the number of bytes
// between the start of one row and the start of the next).
//
//
// Creating new GdkPixbuf
//
// The most basic way to create a pixbuf is to wrap an existing pixel buffer
// with a gdkpixbuf.Pixbuf instance. You can use the
// gdkpixbuf.Pixbuf.NewFromData function to do this.
//
// Every time you create a new GdkPixbuf instance for some data, you will need
// to specify the destroy notification function that will be called when the
// data buffer needs to be freed; this will happen when a GdkPixbuf is finalized
// by the reference counting functions. If you have a chunk of static data
// compiled into your application, you can pass in NULL as the destroy
// notification function so that the data will not be freed.
//
// The gdkpixbuf.Pixbuf.New constructor function can be used as a convenience to
// create a pixbuf with an empty buffer; this is equivalent to allocating a data
// buffer using malloc() and then wrapping it with gdk_pixbuf_new_from_data().
// The gdk_pixbuf_new() function will compute an optimal rowstride so that
// rendering can be performed with an efficient algorithm.
//
// As a special case, you can use the gdkpixbuf.Pixbuf.NewFromXPMData function
// to create a pixbuf from inline XPM image data.
//
// You can also copy an existing pixbuf with the pixbuf.Copy function. This is
// not the same as just acquiring a reference to the old pixbuf instance: the
// copy function will actually duplicate the pixel data in memory and create a
// new pixbuf instance for it.
//
//
// Reference counting
//
// GdkPixbuf structures are reference counted. This means that an application
// can share a single pixbuf among many parts of the code. When a piece of the
// program needs to use a pixbuf, it should acquire a reference to it by calling
// g_object_ref(); when it no longer needs the pixbuf, it should release the
// reference it acquired by calling g_object_unref(). The resources associated
// with a GdkPixbuf will be freed when its reference count drops to zero.
// Newly-created GdkPixbuf instances start with a reference count of one.
//
//
// Image Data
//
// Image data in a pixbuf is stored in memory in an uncompressed, packed format.
// Rows in the image are stored top to bottom, and in each row pixels are stored
// from left to right.
//
// There may be padding at the end of a row.
//
// The "rowstride" value of a pixbuf, as returned by
// gdkpixbuf.Pixbuf.GetRowstride(), indicates the number of bytes between rows.
//
// **NOTE**: If you are copying raw pixbuf data with memcpy() note that the last
// row in the pixbuf may not be as wide as the full rowstride, but rather just
// as wide as the pixel data needs to be; that is: it is unsafe to do memcpy
// (dest, pixels, rowstride * height) to copy a whole pixbuf. Use
// gdkpixbuf.Pixbuf.Copy() instead, or compute the width in bytes of the last
// row as:
//
//    last_row = width * ((n_channels * bits_per_sample + 7) / 8);
//
//
// The same rule applies when iterating over each row of a GdkPixbuf pixels
// array.
//
// The following code illustrates a simple put_pixel() function for RGB pixbufs
// with 8 bits per channel with an alpha channel.
//
//    static void
//    put_pixel (GdkPixbuf *pixbuf,
//               int x,
//    	   int y,
//    	   guchar red,
//    	   guchar green,
//    	   guchar blue,
//    	   guchar alpha)
//    {
//      int n_channels = gdk_pixbuf_get_n_channels (pixbuf);
//
//      // Ensure that the pixbuf is valid
//      g_assert (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
//      g_assert (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
//      g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
//      g_assert (n_channels == 4);
//
//      int width = gdk_pixbuf_get_width (pixbuf);
//      int height = gdk_pixbuf_get_height (pixbuf);
//
//      // Ensure that the coordinates are in a valid range
//      g_assert (x >= 0 && x < width);
//      g_assert (y >= 0 && y < height);
//
//      int rowstride = gdk_pixbuf_get_rowstride (pixbuf);
//
//      // The pixel buffer in the GdkPixbuf instance
//      guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);
//
//      // The pixel we wish to modify
//      guchar *p = pixels + y * rowstride + x * n_channels;
//      p[0] = red;
//      p[1] = green;
//      p[2] = blue;
//      p[3] = alpha;
//    }
//
//
//
// Loading images
//
// The GdkPixBuf class provides a simple mechanism for loading an image from a
// file in synchronous and asynchronous fashion.
//
// For GUI applications, it is recommended to use the asynchronous stream API to
// avoid blocking the control flow of the application.
//
// Additionally, GdkPixbuf provides the gdkpixbuf.PixbufLoader` API for
// progressive image loading.
//
//
// Saving images
//
// The GdkPixbuf class provides methods for saving image data in a number of
// file formats. The formatted data can be written to a file or to a memory
// buffer. GdkPixbuf can also call a user-defined callback on the data, which
// allows to e.g. write the image to a socket or store it in a database.
type Pixbuf struct {
	*externglib.Object

	gio.LoadableIcon
}

func wrapPixbuf(obj *externglib.Object) *Pixbuf {
	return &Pixbuf{
		Object: obj,
		LoadableIcon: gio.LoadableIcon{
			Icon: gio.Icon{
				Object: obj,
			},
		},
	}
}

func marshalPixbuffer(p uintptr) (interface{}, error) {
	return wrapPixbuf(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPixbuf creates a new GdkPixbuf structure and allocates a buffer for it.
//
// If the allocation of the buffer failed, this function will return NULL.
//
// The buffer has an optimal rowstride. Note that the buffer is not cleared; you
// will have to fill it completely yourself.
//
// The function takes the following parameters:
//
//    - colorspace: color space for image.
//    - hasAlpha: whether the image should have transparency information.
//    - bitsPerSample: number of bits per color sample.
//    - width: width of image in pixels, must be > 0.
//    - height: height of image in pixels, must be > 0.
//
func NewPixbuf(colorspace Colorspace, hasAlpha bool, bitsPerSample, width, height int) *Pixbuf {
	var _arg1 C.GdkColorspace // out
	var _arg2 C.gboolean      // out
	var _arg3 C.int           // out
	var _arg4 C.int           // out
	var _arg5 C.int           // out
	var _cret *C.GdkPixbuf    // in

	_arg1 = C.GdkColorspace(colorspace)
	if hasAlpha {
		_arg2 = C.TRUE
	}
	_arg3 = C.int(bitsPerSample)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	_cret = C.gdk_pixbuf_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(colorspace)
	runtime.KeepAlive(hasAlpha)
	runtime.KeepAlive(bitsPerSample)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// NewPixbufFromBytes creates a new Pixbuf out of in-memory readonly image data.
//
// Currently only RGB images with 8 bits per sample are supported.
//
// This is the GBytes variant of gdk_pixbuf_new_from_data(), useful for language
// bindings.
//
// The function takes the following parameters:
//
//    - data: image data in 8-bit/sample packed format inside a #GBytes.
//    - colorspace: colorspace for the image data.
//    - hasAlpha: whether the data has an opacity channel.
//    - bitsPerSample: number of bits per sample.
//    - width: width of the image in pixels, must be > 0.
//    - height: height of the image in pixels, must be > 0.
//    - rowstride: distance in bytes between row starts.
//
func NewPixbufFromBytes(data *glib.Bytes, colorspace Colorspace, hasAlpha bool, bitsPerSample, width, height, rowstride int) *Pixbuf {
	var _arg1 *C.GBytes       // out
	var _arg2 C.GdkColorspace // out
	var _arg3 C.gboolean      // out
	var _arg4 C.int           // out
	var _arg5 C.int           // out
	var _arg6 C.int           // out
	var _arg7 C.int           // out
	var _cret *C.GdkPixbuf    // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(data)))
	_arg2 = C.GdkColorspace(colorspace)
	if hasAlpha {
		_arg3 = C.TRUE
	}
	_arg4 = C.int(bitsPerSample)
	_arg5 = C.int(width)
	_arg6 = C.int(height)
	_arg7 = C.int(rowstride)

	_cret = C.gdk_pixbuf_new_from_bytes(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(data)
	runtime.KeepAlive(colorspace)
	runtime.KeepAlive(hasAlpha)
	runtime.KeepAlive(bitsPerSample)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(rowstride)

	var _pixbuf *Pixbuf // out

	_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pixbuf
}

// NewPixbufFromFile creates a new pixbuf by loading an image from a file.
//
// The file format is detected automatically.
//
// If NULL is returned, then error will be set. Possible errors are:
//
//    - the file could not be opened
//    - there is no loader for the file's format
//    - there is not enough memory to allocate the image buffer
//    - the image buffer contains invalid data
//
// The error domains are GDK_PIXBUF_ERROR and G_FILE_ERROR.
//
// The function takes the following parameters:
//
//    - filename: name of file to load, in the GLib file name encoding.
//
func NewPixbufFromFile(filename string) (*Pixbuf, error) {
	var _arg1 *C.char      // out
	var _cret *C.GdkPixbuf // in
	var _cerr *C.GError    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_pixbuf_new_from_file(_arg1, &_cerr)
	runtime.KeepAlive(filename)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromFileAtScale creates a new pixbuf by loading an image from a
// file.
//
// The file format is detected automatically.
//
// If NULL is returned, then error will be set. Possible errors are:
//
//    - the file could not be opened
//    - there is no loader for the file's format
//    - there is not enough memory to allocate the image buffer
//    - the image buffer contains invalid data
//
// The error domains are GDK_PIXBUF_ERROR and G_FILE_ERROR.
//
// The image will be scaled to fit in the requested size, optionally preserving
// the image's aspect ratio.
//
// When preserving the aspect ratio, a width of -1 will cause the image to be
// scaled to the exact given height, and a height of -1 will cause the image to
// be scaled to the exact given width. When not preserving aspect ratio, a width
// or height of -1 means to not scale the image at all in that dimension.
// Negative values for width and height are allowed since 2.8.
//
// The function takes the following parameters:
//
//    - filename: name of file to load, in the GLib file name encoding.
//    - width the image should have or -1 to not constrain the width.
//    - height the image should have or -1 to not constrain the height.
//    - preserveAspectRatio: TRUE to preserve the image's aspect ratio.
//
func NewPixbufFromFileAtScale(filename string, width, height int, preserveAspectRatio bool) (*Pixbuf, error) {
	var _arg1 *C.char      // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.gboolean   // out
	var _cret *C.GdkPixbuf // in
	var _cerr *C.GError    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(width)
	_arg3 = C.int(height)
	if preserveAspectRatio {
		_arg4 = C.TRUE
	}

	_cret = C.gdk_pixbuf_new_from_file_at_scale(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(preserveAspectRatio)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromFileAtSize creates a new pixbuf by loading an image from a file.
//
// The file format is detected automatically.
//
// If NULL is returned, then error will be set. Possible errors are:
//
//    - the file could not be opened
//    - there is no loader for the file's format
//    - there is not enough memory to allocate the image buffer
//    - the image buffer contains invalid data
//
// The error domains are GDK_PIXBUF_ERROR and G_FILE_ERROR.
//
// The image will be scaled to fit in the requested size, preserving the image's
// aspect ratio. Note that the returned pixbuf may be smaller than width x
// height, if the aspect ratio requires it. To load and image at the requested
// size, regardless of aspect ratio, use gdkpixbuf.Pixbuf.NewFromFileAtScale.
//
// The function takes the following parameters:
//
//    - filename: name of file to load, in the GLib file name encoding.
//    - width the image should have or -1 to not constrain the width.
//    - height the image should have or -1 to not constrain the height.
//
func NewPixbufFromFileAtSize(filename string, width, height int) (*Pixbuf, error) {
	var _arg1 *C.char      // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _cret *C.GdkPixbuf // in
	var _cerr *C.GError    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(width)
	_arg3 = C.int(height)

	_cret = C.gdk_pixbuf_new_from_file_at_size(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromInline creates a GdkPixbuf from a flat representation that is
// suitable for storing as inline data in a program.
//
// This is useful if you want to ship a program with images, but don't want to
// depend on any external files.
//
// GdkPixbuf ships with a program called gdk-pixbuf-csource, which allows for
// conversion of GdkPixbufs into such a inline representation.
//
// In almost all cases, you should pass the --raw option to gdk-pixbuf-csource.
// A sample invocation would be:
//
//    gdk-pixbuf-csource --raw --name=myimage_inline myimage.png
//
//
// For the typical case where the inline pixbuf is read-only static data, you
// don't need to copy the pixel data unless you intend to write to it, so you
// can pass FALSE for copy_pixels. If you pass --rle to gdk-pixbuf-csource, a
// copy will be made even if copy_pixels is FALSE, so using this option is
// generally a bad idea.
//
// If you create a pixbuf from const inline data compiled into your program,
// it's probably safe to ignore errors and disable length checks, since things
// will always succeed:
//
//    pixbuf = gdk_pixbuf_new_from_inline (-1, myimage_inline, FALSE, NULL);
//
//
// For non-const inline data, you could get out of memory. For untrusted inline
// data located at runtime, you could have corrupt inline data in addition.
//
// Deprecated: Use GResource instead.
//
// The function takes the following parameters:
//
//    - data: byte data containing a serialized GdkPixdata structure.
//    - copyPixels: whether to copy the pixel data, or use direct pointers data
//    for the resulting pixbuf.
//
func NewPixbufFromInline(data []byte, copyPixels bool) (*Pixbuf, error) {
	var _arg2 *C.guint8 // out
	var _arg1 C.gint
	var _arg3 C.gboolean   // out
	var _cret *C.GdkPixbuf // in
	var _cerr *C.GError    // in

	_arg1 = (C.gint)(len(data))
	if len(data) > 0 {
		_arg2 = (*C.guint8)(unsafe.Pointer(&data[0]))
	}
	if copyPixels {
		_arg3 = C.TRUE
	}

	_cret = C.gdk_pixbuf_new_from_inline(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(data)
	runtime.KeepAlive(copyPixels)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromResource creates a new pixbuf by loading an image from an
// resource.
//
// The file format is detected automatically. If NULL is returned, then error
// will be set.
//
// The function takes the following parameters:
//
//    - resourcePath: path of the resource file.
//
func NewPixbufFromResource(resourcePath string) (*Pixbuf, error) {
	var _arg1 *C.char      // out
	var _cret *C.GdkPixbuf // in
	var _cerr *C.GError    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_pixbuf_new_from_resource(_arg1, &_cerr)
	runtime.KeepAlive(resourcePath)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromResourceAtScale creates a new pixbuf by loading an image from an
// resource.
//
// The file format is detected automatically. If NULL is returned, then error
// will be set.
//
// The image will be scaled to fit in the requested size, optionally preserving
// the image's aspect ratio. When preserving the aspect ratio, a width of -1
// will cause the image to be scaled to the exact given height, and a height of
// -1 will cause the image to be scaled to the exact given width. When not
// preserving aspect ratio, a width or height of -1 means to not scale the image
// at all in that dimension.
//
// The stream is not closed.
//
// The function takes the following parameters:
//
//    - resourcePath: path of the resource file.
//    - width the image should have or -1 to not constrain the width.
//    - height the image should have or -1 to not constrain the height.
//    - preserveAspectRatio: TRUE to preserve the image's aspect ratio.
//
func NewPixbufFromResourceAtScale(resourcePath string, width, height int, preserveAspectRatio bool) (*Pixbuf, error) {
	var _arg1 *C.char      // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.gboolean   // out
	var _cret *C.GdkPixbuf // in
	var _cerr *C.GError    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(width)
	_arg3 = C.int(height)
	if preserveAspectRatio {
		_arg4 = C.TRUE
	}

	_cret = C.gdk_pixbuf_new_from_resource_at_scale(_arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(resourcePath)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(preserveAspectRatio)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromStream creates a new pixbuf by loading an image from an input
// stream.
//
// The file format is detected automatically.
//
// If NULL is returned, then error will be set.
//
// The cancellable can be used to abort the operation from another thread. If
// the operation was cancelled, the error G_IO_ERROR_CANCELLED will be returned.
// Other possible errors are in the GDK_PIXBUF_ERROR and G_IO_ERROR domains.
//
// The stream is not closed.
//
// The function takes the following parameters:
//
//    - ctx: optional GCancellable object, NULL to ignore.
//    - stream: GInputStream to load the pixbuf from.
//
func NewPixbufFromStream(ctx context.Context, stream gio.InputStreamer) (*Pixbuf, error) {
	var _arg2 *C.GCancellable // out
	var _arg1 *C.GInputStream // out
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))

	_cret = C.gdk_pixbuf_new_from_stream(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromStreamAtScale creates a new pixbuf by loading an image from an
// input stream.
//
// The file format is detected automatically. If NULL is returned, then error
// will be set. The cancellable can be used to abort the operation from another
// thread. If the operation was cancelled, the error G_IO_ERROR_CANCELLED will
// be returned. Other possible errors are in the GDK_PIXBUF_ERROR and G_IO_ERROR
// domains.
//
// The image will be scaled to fit in the requested size, optionally preserving
// the image's aspect ratio.
//
// When preserving the aspect ratio, a width of -1 will cause the image to be
// scaled to the exact given height, and a height of -1 will cause the image to
// be scaled to the exact given width. If both width and height are given, this
// function will behave as if the smaller of the two values is passed as -1.
//
// When not preserving aspect ratio, a width or height of -1 means to not scale
// the image at all in that dimension.
//
// The stream is not closed.
//
// The function takes the following parameters:
//
//    - ctx: optional GCancellable object, NULL to ignore.
//    - stream: GInputStream to load the pixbuf from.
//    - width the image should have or -1 to not constrain the width.
//    - height the image should have or -1 to not constrain the height.
//    - preserveAspectRatio: TRUE to preserve the image's aspect ratio.
//
func NewPixbufFromStreamAtScale(ctx context.Context, stream gio.InputStreamer, width, height int, preserveAspectRatio bool) (*Pixbuf, error) {
	var _arg5 *C.GCancellable // out
	var _arg1 *C.GInputStream // out
	var _arg2 C.gint          // out
	var _arg3 C.gint          // out
	var _arg4 C.gboolean      // out
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = C.gint(width)
	_arg3 = C.gint(height)
	if preserveAspectRatio {
		_arg4 = C.TRUE
	}

	_cret = C.gdk_pixbuf_new_from_stream_at_scale(_arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(preserveAspectRatio)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromStreamFinish finishes an asynchronous pixbuf creation operation
// started with gdk_pixbuf_new_from_stream_async().
//
// The function takes the following parameters:
//
//    - asyncResult: GAsyncResult.
//
func NewPixbufFromStreamFinish(asyncResult gio.AsyncResulter) (*Pixbuf, error) {
	var _arg1 *C.GAsyncResult // out
	var _cret *C.GdkPixbuf    // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GAsyncResult)(unsafe.Pointer(asyncResult.Native()))

	_cret = C.gdk_pixbuf_new_from_stream_finish(_arg1, &_cerr)
	runtime.KeepAlive(asyncResult)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// NewPixbufFromXPMData creates a new pixbuf by parsing XPM data in memory.
//
// This data is commonly the result of including an XPM file into a program's C
// source.
//
// The function takes the following parameters:
//
//    - data: pointer to inline XPM data.
//
func NewPixbufFromXPMData(data []string) *Pixbuf {
	var _arg1 **C.char     // out
	var _cret *C.GdkPixbuf // in

	{
		_arg1 = (**C.char)(C.malloc(C.size_t(uint((len(data) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(data)+1)
			var zero *C.char
			out[len(data)] = zero
			for i := range data {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(data[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gdk_pixbuf_new_from_xpm_data(_arg1)
	runtime.KeepAlive(data)

	var _pixbuf *Pixbuf // out

	_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pixbuf
}

// AddAlpha takes an existing pixbuf and adds an alpha channel to it.
//
// If the existing pixbuf already had an alpha channel, the channel values are
// copied from the original; otherwise, the alpha channel is initialized to 255
// (full opacity).
//
// If substitute_color is TRUE, then the color specified by the (r, g, b)
// arguments will be assigned zero opacity. That is, if you pass (255, 255, 255)
// for the substitute color, all white pixels will become fully transparent.
//
// If substitute_color is FALSE, then the (r, g, b) arguments will be ignored.
//
// The function takes the following parameters:
//
//    - substituteColor: whether to set a color to zero opacity.
//    - r: red value to substitute.
//    - g: green value to substitute.
//    - b: blue value to substitute.
//
func (pixbuf *Pixbuf) AddAlpha(substituteColor bool, r, g, b byte) *Pixbuf {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.gboolean   // out
	var _arg2 C.guchar     // out
	var _arg3 C.guchar     // out
	var _arg4 C.guchar     // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	if substituteColor {
		_arg1 = C.TRUE
	}
	_arg2 = C.guchar(r)
	_arg3 = C.guchar(g)
	_arg4 = C.guchar(b)

	_cret = C.gdk_pixbuf_add_alpha(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(substituteColor)
	runtime.KeepAlive(r)
	runtime.KeepAlive(g)
	runtime.KeepAlive(b)

	var _ret *Pixbuf // out

	_ret = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _ret
}

// ApplyEmbeddedOrientation takes an existing pixbuf and checks for the presence
// of an associated "orientation" option.
//
// The orientation option may be provided by the JPEG loader (which reads the
// exif orientation tag) or the TIFF loader (which reads the TIFF orientation
// tag, and compensates it for the partial transforms performed by libtiff).
//
// If an orientation option/tag is present, the appropriate transform will be
// performed so that the pixbuf is oriented correctly.
func (src *Pixbuf) ApplyEmbeddedOrientation() *Pixbuf {
	var _arg0 *C.GdkPixbuf // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))

	_cret = C.gdk_pixbuf_apply_embedded_orientation(_arg0)
	runtime.KeepAlive(src)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// Composite creates a transformation of the source image src by scaling by
// scale_x and scale_y then translating by offset_x and offset_y.
//
// This gives an image in the coordinates of the destination pixbuf. The
// rectangle (dest_x, dest_y, dest_width, dest_height) is then alpha blended
// onto the corresponding rectangle of the original destination image.
//
// When the destination rectangle contains parts not in the source image, the
// data at the edges of the source image is replicated to infinity.
//
// ! (composite.png).
//
// The function takes the following parameters:
//
//    - dest into which to render the results.
//    - destX: left coordinate for region to render.
//    - destY: top coordinate for region to render.
//    - destWidth: width of the region to render.
//    - destHeight: height of the region to render.
//    - offsetX: offset in the X direction (currently rounded to an integer).
//    - offsetY: offset in the Y direction (currently rounded to an integer).
//    - scaleX: scale factor in the X direction.
//    - scaleY: scale factor in the Y direction.
//    - interpType: interpolation type for the transformation.
//    - overallAlpha: overall alpha for source image (0..255).
//
func (src *Pixbuf) Composite(dest *Pixbuf, destX, destY, destWidth, destHeight int, offsetX, offsetY, scaleX, scaleY float64, interpType InterpType, overallAlpha int) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out
	var _arg11 C.int           // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = C.GdkInterpType(interpType)
	_arg11 = C.int(overallAlpha)

	C.gdk_pixbuf_composite(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destX)
	runtime.KeepAlive(destY)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(offsetX)
	runtime.KeepAlive(offsetY)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
	runtime.KeepAlive(interpType)
	runtime.KeepAlive(overallAlpha)
}

// CompositeColor creates a transformation of the source image src by scaling by
// scale_x and scale_y then translating by offset_x and offset_y, then alpha
// blends the rectangle (dest_x ,dest_y, dest_width, dest_height) of the
// resulting image with a checkboard of the colors color1 and color2 and renders
// it onto the destination image.
//
// If the source image has no alpha channel, and overall_alpha is 255, a fast
// path is used which omits the alpha blending and just performs the scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
//
// The function takes the following parameters:
//
//    - dest into which to render the results.
//    - destX: left coordinate for region to render.
//    - destY: top coordinate for region to render.
//    - destWidth: width of the region to render.
//    - destHeight: height of the region to render.
//    - offsetX: offset in the X direction (currently rounded to an integer).
//    - offsetY: offset in the Y direction (currently rounded to an integer).
//    - scaleX: scale factor in the X direction.
//    - scaleY: scale factor in the Y direction.
//    - interpType: interpolation type for the transformation.
//    - overallAlpha: overall alpha for source image (0..255).
//    - checkX: x offset for the checkboard (origin of checkboard is at
//    -check_x, -check_y).
//    - checkY: y offset for the checkboard.
//    - checkSize: size of checks in the checkboard (must be a power of two).
//    - color1: color of check at upper left.
//    - color2: color of the other check.
//
func (src *Pixbuf) CompositeColor(dest *Pixbuf, destX, destY, destWidth, destHeight int, offsetX, offsetY, scaleX, scaleY float64, interpType InterpType, overallAlpha, checkX, checkY, checkSize int, color1, color2 uint32) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out
	var _arg11 C.int           // out
	var _arg12 C.int           // out
	var _arg13 C.int           // out
	var _arg14 C.int           // out
	var _arg15 C.guint32       // out
	var _arg16 C.guint32       // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = C.GdkInterpType(interpType)
	_arg11 = C.int(overallAlpha)
	_arg12 = C.int(checkX)
	_arg13 = C.int(checkY)
	_arg14 = C.int(checkSize)
	_arg15 = C.guint32(color1)
	_arg16 = C.guint32(color2)

	C.gdk_pixbuf_composite_color(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15, _arg16)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destX)
	runtime.KeepAlive(destY)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(offsetX)
	runtime.KeepAlive(offsetY)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
	runtime.KeepAlive(interpType)
	runtime.KeepAlive(overallAlpha)
	runtime.KeepAlive(checkX)
	runtime.KeepAlive(checkY)
	runtime.KeepAlive(checkSize)
	runtime.KeepAlive(color1)
	runtime.KeepAlive(color2)
}

// CompositeColorSimple creates a new pixbuf by scaling src to dest_width x
// dest_height and alpha blending the result with a checkboard of colors color1
// and color2.
//
// The function takes the following parameters:
//
//    - destWidth: width of destination image.
//    - destHeight: height of destination image.
//    - interpType: interpolation type for the transformation.
//    - overallAlpha: overall alpha for source image (0..255).
//    - checkSize: size of checks in the checkboard (must be a power of two).
//    - color1: color of check at upper left.
//    - color2: color of the other check.
//
func (src *Pixbuf) CompositeColorSimple(destWidth, destHeight int, interpType InterpType, overallAlpha, checkSize int, color1, color2 uint32) *Pixbuf {
	var _arg0 *C.GdkPixbuf    // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.GdkInterpType // out
	var _arg4 C.int           // out
	var _arg5 C.int           // out
	var _arg6 C.guint32       // out
	var _arg7 C.guint32       // out
	var _cret *C.GdkPixbuf    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))
	_arg1 = C.int(destWidth)
	_arg2 = C.int(destHeight)
	_arg3 = C.GdkInterpType(interpType)
	_arg4 = C.int(overallAlpha)
	_arg5 = C.int(checkSize)
	_arg6 = C.guint32(color1)
	_arg7 = C.guint32(color2)

	_cret = C.gdk_pixbuf_composite_color_simple(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(src)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(interpType)
	runtime.KeepAlive(overallAlpha)
	runtime.KeepAlive(checkSize)
	runtime.KeepAlive(color1)
	runtime.KeepAlive(color2)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// Copy creates a new GdkPixbuf with a copy of the information in the specified
// pixbuf.
//
// Note that this does not copy the options set on the original GdkPixbuf, use
// gdk_pixbuf_copy_options() for this.
func (pixbuf *Pixbuf) Copy() *Pixbuf {
	var _arg0 *C.GdkPixbuf // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_copy(_arg0)
	runtime.KeepAlive(pixbuf)

	var _ret *Pixbuf // out

	if _cret != nil {
		_ret = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _ret
}

// CopyArea copies a rectangular area from src_pixbuf to dest_pixbuf.
//
// Conversion of pixbuf formats is done automatically.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the copy operation. Therefore, you can
// not use this function to scroll a pixbuf.
//
// The function takes the following parameters:
//
//    - srcX: source X coordinate within src_pixbuf.
//    - srcY: source Y coordinate within src_pixbuf.
//    - width: width of the area to copy.
//    - height: height of the area to copy.
//    - destPixbuf: destination pixbuf.
//    - destX: x coordinate within dest_pixbuf.
//    - destY: y coordinate within dest_pixbuf.
//
func (srcPixbuf *Pixbuf) CopyArea(srcX, srcY, width, height int, destPixbuf *Pixbuf, destX, destY int) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.int        // out
	var _arg5 *C.GdkPixbuf // out
	var _arg6 C.int        // out
	var _arg7 C.int        // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(srcPixbuf.Native()))
	_arg1 = C.int(srcX)
	_arg2 = C.int(srcY)
	_arg3 = C.int(width)
	_arg4 = C.int(height)
	_arg5 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))
	_arg6 = C.int(destX)
	_arg7 = C.int(destY)

	C.gdk_pixbuf_copy_area(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(srcPixbuf)
	runtime.KeepAlive(srcX)
	runtime.KeepAlive(srcY)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(destPixbuf)
	runtime.KeepAlive(destX)
	runtime.KeepAlive(destY)
}

// CopyOptions copies the key/value pair options attached to a GdkPixbuf to
// another GdkPixbuf.
//
// This is useful to keep original metadata after having manipulated a file.
// However be careful to remove metadata which you've already applied, such as
// the "orientation" option after rotating the image.
//
// The function takes the following parameters:
//
//    - destPixbuf: destination pixbuf.
//
func (srcPixbuf *Pixbuf) CopyOptions(destPixbuf *Pixbuf) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.GdkPixbuf // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(srcPixbuf.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(destPixbuf.Native()))

	_cret = C.gdk_pixbuf_copy_options(_arg0, _arg1)
	runtime.KeepAlive(srcPixbuf)
	runtime.KeepAlive(destPixbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Fill clears a pixbuf to the given RGBA value, converting the RGBA value into
// the pixbuf's pixel format.
//
// The alpha component will be ignored if the pixbuf doesn't have an alpha
// channel.
//
// The function takes the following parameters:
//
//    - pixel: RGBA pixel to used to clear (0xffffffff is opaque white,
//    0x00000000 transparent black).
//
func (pixbuf *Pixbuf) Fill(pixel uint32) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg1 = C.guint32(pixel)

	C.gdk_pixbuf_fill(_arg0, _arg1)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(pixel)
}

// Flip flips a pixbuf horizontally or vertically and returns the result in a
// new pixbuf.
//
// The function takes the following parameters:
//
//    - horizontal: TRUE to flip horizontally, FALSE to flip vertically.
//
func (src *Pixbuf) Flip(horizontal bool) *Pixbuf {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.gboolean   // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))
	if horizontal {
		_arg1 = C.TRUE
	}

	_cret = C.gdk_pixbuf_flip(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(horizontal)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// BitsPerSample queries the number of bits per color sample in a pixbuf.
func (pixbuf *Pixbuf) BitsPerSample() int {
	var _arg0 *C.GdkPixbuf // out
	var _cret C.int        // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_bits_per_sample(_arg0)
	runtime.KeepAlive(pixbuf)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ByteLength returns the length of the pixel data, in bytes.
func (pixbuf *Pixbuf) ByteLength() uint {
	var _arg0 *C.GdkPixbuf // out
	var _cret C.gsize      // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_byte_length(_arg0)
	runtime.KeepAlive(pixbuf)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Colorspace queries the color space of a pixbuf.
func (pixbuf *Pixbuf) Colorspace() Colorspace {
	var _arg0 *C.GdkPixbuf    // out
	var _cret C.GdkColorspace // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_colorspace(_arg0)
	runtime.KeepAlive(pixbuf)

	var _colorspace Colorspace // out

	_colorspace = Colorspace(_cret)

	return _colorspace
}

// HasAlpha queries whether a pixbuf has an alpha channel (opacity information).
func (pixbuf *Pixbuf) HasAlpha() bool {
	var _arg0 *C.GdkPixbuf // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_has_alpha(_arg0)
	runtime.KeepAlive(pixbuf)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Height queries the height of a pixbuf.
func (pixbuf *Pixbuf) Height() int {
	var _arg0 *C.GdkPixbuf // out
	var _cret C.int        // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_height(_arg0)
	runtime.KeepAlive(pixbuf)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NChannels queries the number of channels of a pixbuf.
func (pixbuf *Pixbuf) NChannels() int {
	var _arg0 *C.GdkPixbuf // out
	var _cret C.int        // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_n_channels(_arg0)
	runtime.KeepAlive(pixbuf)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Option looks up key in the list of options that may have been attached to the
// pixbuf when it was loaded, or that may have been attached by another function
// using gdk_pixbuf_set_option().
//
// For instance, the ANI loader provides "Title" and "Artist" options. The ICO,
// XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot options for cursor
// definitions. The PNG loader provides the tEXt ancillary chunk key/value pairs
// as options. Since 2.12, the TIFF and JPEG loaders return an "orientation"
// option string that corresponds to the embedded TIFF/Exif orientation tag (if
// present). Since 2.32, the TIFF loader sets the "multipage" option string to
// "yes" when a multi-page TIFF is loaded. Since 2.32 the JPEG and PNG loaders
// set "x-dpi" and "y-dpi" if the file contains image density information in
// dots per inch. Since 2.36.6, the JPEG loader sets the "comment" option with
// the comment EXIF tag.
//
// The function takes the following parameters:
//
//    - key: nul-terminated string.
//
func (pixbuf *Pixbuf) Option(key string) string {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out
	var _cret *C.gchar     // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_pixbuf_get_option(_arg0, _arg1)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Options returns a GHashTable with a list of all the options that may have
// been attached to the pixbuf when it was loaded, or that may have been
// attached by another function using gdkpixbuf.Pixbuf.SetOption().
func (pixbuf *Pixbuf) Options() map[string]string {
	var _arg0 *C.GdkPixbuf  // out
	var _cret *C.GHashTable // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_options(_arg0)
	runtime.KeepAlive(pixbuf)

	var _hashTable map[string]string // out

	_hashTable = make(map[string]string, gextras.HashTableSize(unsafe.Pointer(_cret)))
	gextras.MoveHashTable(unsafe.Pointer(_cret), true, func(k, v unsafe.Pointer) {
		ksrc := *(**C.gchar)(k)
		vsrc := *(**C.gchar)(v)
		var kdst string // out
		var vdst string // out
		kdst = C.GoString((*C.gchar)(unsafe.Pointer(ksrc)))
		vdst = C.GoString((*C.gchar)(unsafe.Pointer(vsrc)))
		_hashTable[kdst] = vdst
	})

	return _hashTable
}

// Pixels queries a pointer to the pixel data of a pixbuf.
//
// This function will cause an implicit copy of the pixbuf data if the pixbuf
// was created from read-only data.
//
// Please see the section on image data (#image-data) for information about how
// the pixel data is stored in memory.
func (pixbuf *Pixbuf) Pixels() []byte {
	var _arg0 *C.GdkPixbuf // out
	var _cret *C.guchar    // in
	var _arg1 C.guint      // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_pixels_with_length(_arg0, &_arg1)
	runtime.KeepAlive(pixbuf)

	var _guint8s []byte // out

	_guint8s = make([]byte, _arg1)
	copy(_guint8s, unsafe.Slice((*byte)(unsafe.Pointer(_cret)), _arg1))

	return _guint8s
}

// Rowstride queries the rowstride of a pixbuf, which is the number of bytes
// between the start of a row and the start of the next row.
func (pixbuf *Pixbuf) Rowstride() int {
	var _arg0 *C.GdkPixbuf // out
	var _cret C.int        // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_rowstride(_arg0)
	runtime.KeepAlive(pixbuf)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Width queries the width of a pixbuf.
func (pixbuf *Pixbuf) Width() int {
	var _arg0 *C.GdkPixbuf // out
	var _cret C.int        // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_get_width(_arg0)
	runtime.KeepAlive(pixbuf)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NewSubpixbuf creates a new pixbuf which represents a sub-region of
// src_pixbuf.
//
// The new pixbuf shares its pixels with the original pixbuf, so writing to one
// affects both. The new pixbuf holds a reference to src_pixbuf, so src_pixbuf
// will not be finalized until the new pixbuf is finalized.
//
// Note that if src_pixbuf is read-only, this function will force it to be
// mutable.
//
// The function takes the following parameters:
//
//    - srcX: x coord in src_pixbuf.
//    - srcY: y coord in src_pixbuf.
//    - width of region in src_pixbuf.
//    - height of region in src_pixbuf.
//
func (srcPixbuf *Pixbuf) NewSubpixbuf(srcX, srcY, width, height int) *Pixbuf {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.int        // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(srcPixbuf.Native()))
	_arg1 = C.int(srcX)
	_arg2 = C.int(srcY)
	_arg3 = C.int(width)
	_arg4 = C.int(height)

	_cret = C.gdk_pixbuf_new_subpixbuf(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(srcPixbuf)
	runtime.KeepAlive(srcX)
	runtime.KeepAlive(srcY)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _pixbuf *Pixbuf // out

	_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pixbuf
}

// ReadPixelBytes provides a #GBytes buffer containing the raw pixel data; the
// data must not be modified.
//
// This function allows skipping the implicit copy that must be made if
// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (pixbuf *Pixbuf) ReadPixelBytes() *glib.Bytes {
	var _arg0 *C.GdkPixbuf // out
	var _cret *C.GBytes    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_read_pixel_bytes(_arg0)
	runtime.KeepAlive(pixbuf)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// ReadPixels provides a read-only pointer to the raw pixel data.
//
// This function allows skipping the implicit copy that must be made if
// gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
func (pixbuf *Pixbuf) ReadPixels() *byte {
	var _arg0 *C.GdkPixbuf // out
	var _cret *C.guint8    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

	_cret = C.gdk_pixbuf_read_pixels(_arg0)
	runtime.KeepAlive(pixbuf)

	var _guint8 *byte // out

	_guint8 = (*byte)(unsafe.Pointer(_cret))

	return _guint8
}

// RemoveOption removes the key/value pair option attached to a GdkPixbuf.
//
// The function takes the following parameters:
//
//    - key: nul-terminated string representing the key to remove.
//
func (pixbuf *Pixbuf) RemoveOption(key string) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gdk_pixbuf_remove_option(_arg0, _arg1)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns the
// result in a new pixbuf.
//
// If angle is 0, this function will return a copy of src.
//
// The function takes the following parameters:
//
//    - angle to rotate by.
//
func (src *Pixbuf) RotateSimple(angle PixbufRotation) *Pixbuf {
	var _arg0 *C.GdkPixbuf        // out
	var _arg1 C.GdkPixbufRotation // out
	var _cret *C.GdkPixbuf        // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))
	_arg1 = C.GdkPixbufRotation(angle)

	_cret = C.gdk_pixbuf_rotate_simple(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(angle)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// SaturateAndPixelate modifies saturation and optionally pixelates src, placing
// the result in dest.
//
// The src and dest pixbufs must have the same image format, size, and
// rowstride.
//
// The src and dest arguments may be the same pixbuf with no ill effects.
//
// If saturation is 1.0 then saturation is not changed. If it's less than 1.0,
// saturation is reduced (the image turns toward grayscale); if greater than
// 1.0, saturation is increased (the image gets more vivid colors).
//
// If pixelate is TRUE, then pixels are faded in a checkerboard pattern to
// create a pixelated image.
//
// The function takes the following parameters:
//
//    - dest: place to write modified version of src.
//    - saturation factor.
//    - pixelate: whether to pixelate.
//
func (src *Pixbuf) SaturateAndPixelate(dest *Pixbuf, saturation float32, pixelate bool) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.GdkPixbuf // out
	var _arg2 C.gfloat     // out
	var _arg3 C.gboolean   // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.gfloat(saturation)
	if pixelate {
		_arg3 = C.TRUE
	}

	C.gdk_pixbuf_saturate_and_pixelate(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(saturation)
	runtime.KeepAlive(pixelate)
}

// SaveToBufferv: vector version of gdk_pixbuf_save_to_buffer().
//
// Saves pixbuf to a new buffer in format type, which is currently "jpeg",
// "tiff", "png", "ico" or "bmp".
//
// See gdkpixbuf.Pixbuf.SaveToBuffer() for more details.
//
// The function takes the following parameters:
//
//    - typ: name of file format.
//    - optionKeys: name of options to set.
//    - optionValues values for named options.
//
func (pixbuf *Pixbuf) SaveToBufferv(typ string, optionKeys, optionValues []string) ([]byte, error) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // in
	var _arg2 C.gsize      // in
	var _arg3 *C.char      // out
	var _arg4 **C.char     // out
	var _arg5 **C.char     // out
	var _cerr *C.GError    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		_arg4 = (**C.char)(C.malloc(C.size_t(uint((len(optionKeys) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(optionKeys)+1)
			var zero *C.char
			out[len(optionKeys)] = zero
			for i := range optionKeys {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionKeys[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg5 = (**C.char)(C.malloc(C.size_t(uint((len(optionValues) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg5))
		{
			out := unsafe.Slice(_arg5, len(optionValues)+1)
			var zero *C.char
			out[len(optionValues)] = zero
			for i := range optionValues {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionValues[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gdk_pixbuf_save_to_bufferv(_arg0, &_arg1, &_arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(optionKeys)
	runtime.KeepAlive(optionValues)

	var _buffer []byte // out
	var _goerr error   // out

	defer C.free(unsafe.Pointer(_arg1))
	_buffer = make([]byte, _arg2)
	copy(_buffer, unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _buffer, _goerr
}

// SaveToCallbackv: vector version of gdk_pixbuf_save_to_callback().
//
// Saves pixbuf to a callback in format type, which is currently "jpeg", "png",
// "tiff", "ico" or "bmp".
//
// If error is set, FALSE will be returned.
//
// See gdkpixbuf.Pixbuf.SaveToCallback() for more details.
//
// The function takes the following parameters:
//
//    - saveFunc: function that is called to save each block of data that the
//    save routine generates.
//    - typ: name of file format.
//    - optionKeys: name of options to set.
//    - optionValues values for named options.
//
func (pixbuf *Pixbuf) SaveToCallbackv(saveFunc PixbufSaveFunc, typ string, optionKeys, optionValues []string) error {
	var _arg0 *C.GdkPixbuf        // out
	var _arg1 C.GdkPixbufSaveFunc // out
	var _arg2 C.gpointer
	var _arg3 *C.char   // out
	var _arg4 **C.char  // out
	var _arg5 **C.char  // out
	var _cerr *C.GError // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg1 = (*[0]byte)(C._gotk4_gdkpixbuf2_PixbufSaveFunc)
	_arg2 = C.gpointer(gbox.Assign(saveFunc))
	defer gbox.Delete(uintptr(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		_arg4 = (**C.char)(C.malloc(C.size_t(uint((len(optionKeys) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(optionKeys)+1)
			var zero *C.char
			out[len(optionKeys)] = zero
			for i := range optionKeys {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionKeys[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg5 = (**C.char)(C.malloc(C.size_t(uint((len(optionValues) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg5))
		{
			out := unsafe.Slice(_arg5, len(optionValues)+1)
			var zero *C.char
			out[len(optionValues)] = zero
			for i := range optionValues {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionValues[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gdk_pixbuf_save_to_callbackv(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(saveFunc)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(optionKeys)
	runtime.KeepAlive(optionValues)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SaveToStreamv saves pixbuf to an output stream.
//
// Supported file formats are currently "jpeg", "tiff", "png", "ico" or "bmp".
//
// See gdkpixbuf.Pixbuf.SaveToStream() for more details.
//
// The function takes the following parameters:
//
//    - ctx: optional GCancellable object, NULL to ignore.
//    - stream: GOutputStream to save the pixbuf to.
//    - typ: name of file format.
//    - optionKeys: name of options to set.
//    - optionValues values for named options.
//
func (pixbuf *Pixbuf) SaveToStreamv(ctx context.Context, stream gio.OutputStreamer, typ string, optionKeys, optionValues []string) error {
	var _arg0 *C.GdkPixbuf     // out
	var _arg5 *C.GCancellable  // out
	var _arg1 *C.GOutputStream // out
	var _arg2 *C.char          // out
	var _arg3 **C.char         // out
	var _arg4 **C.char         // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		_arg3 = (**C.char)(C.malloc(C.size_t(uint((len(optionKeys) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(optionKeys)+1)
			var zero *C.char
			out[len(optionKeys)] = zero
			for i := range optionKeys {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionKeys[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg4 = (**C.char)(C.malloc(C.size_t(uint((len(optionValues) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(optionValues)+1)
			var zero *C.char
			out[len(optionValues)] = zero
			for i := range optionValues {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionValues[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gdk_pixbuf_save_to_streamv(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(optionKeys)
	runtime.KeepAlive(optionValues)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SaveToStreamvAsync saves pixbuf to an output stream asynchronously.
//
// For more details see gdk_pixbuf_save_to_streamv(), which is the synchronous
// version of this function.
//
// When the operation is finished, callback will be called in the main thread.
//
// You can then call gdk_pixbuf_save_to_stream_finish() to get the result of the
// operation.
//
// The function takes the following parameters:
//
//    - ctx: optional GCancellable object, NULL to ignore.
//    - stream: GOutputStream to which to save the pixbuf.
//    - typ: name of file format.
//    - optionKeys: name of options to set.
//    - optionValues values for named options.
//    - callback: GAsyncReadyCallback to call when the pixbuf is saved.
//
func (pixbuf *Pixbuf) SaveToStreamvAsync(ctx context.Context, stream gio.OutputStreamer, typ string, optionKeys, optionValues []string, callback gio.AsyncReadyCallback) {
	var _arg0 *C.GdkPixbuf          // out
	var _arg5 *C.GCancellable       // out
	var _arg1 *C.GOutputStream      // out
	var _arg2 *C.gchar              // out
	var _arg3 **C.gchar             // out
	var _arg4 **C.gchar             // out
	var _arg6 C.GAsyncReadyCallback // out
	var _arg7 C.gpointer

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GOutputStream)(unsafe.Pointer(stream.Native()))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		_arg3 = (**C.gchar)(C.malloc(C.size_t(uint((len(optionKeys) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(optionKeys)+1)
			var zero *C.gchar
			out[len(optionKeys)] = zero
			for i := range optionKeys {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(optionKeys[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg4 = (**C.gchar)(C.malloc(C.size_t(uint((len(optionValues) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(optionValues)+1)
			var zero *C.gchar
			out[len(optionValues)] = zero
			for i := range optionValues {
				out[i] = (*C.gchar)(unsafe.Pointer(C.CString(optionValues[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if callback != nil {
		_arg6 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg7 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gdk_pixbuf_save_to_streamv_async(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(stream)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(optionKeys)
	runtime.KeepAlive(optionValues)
	runtime.KeepAlive(callback)
}

// Savev: vector version of gdk_pixbuf_save().
//
// Saves pixbuf to a file in type, which is currently "jpeg", "png", "tiff",
// "ico" or "bmp".
//
// If error is set, FALSE will be returned.
//
// See gdkpixbuf.Pixbuf.Save() for more details.
//
// The function takes the following parameters:
//
//    - filename: name of file to save.
//    - typ: name of file format.
//    - optionKeys: name of options to set.
//    - optionValues values for named options.
//
func (pixbuf *Pixbuf) Savev(filename, typ string, optionKeys, optionValues []string) error {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out
	var _arg3 **C.char     // out
	var _arg4 **C.char     // out
	var _cerr *C.GError    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		_arg3 = (**C.char)(C.malloc(C.size_t(uint((len(optionKeys) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(optionKeys)+1)
			var zero *C.char
			out[len(optionKeys)] = zero
			for i := range optionKeys {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionKeys[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg4 = (**C.char)(C.malloc(C.size_t(uint((len(optionValues) + 1)) * uint(unsafe.Sizeof(uint(0))))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(optionValues)+1)
			var zero *C.char
			out[len(optionValues)] = zero
			for i := range optionValues {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionValues[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gdk_pixbuf_savev(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(optionKeys)
	runtime.KeepAlive(optionValues)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Scale creates a transformation of the source image src by scaling by scale_x
// and scale_y then translating by offset_x and offset_y, then renders the
// rectangle (dest_x, dest_y, dest_width, dest_height) of the resulting image
// onto the destination image replacing the previous contents.
//
// Try to use gdk_pixbuf_scale_simple() first; this function is the
// industrial-strength power tool you can fall back to, if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the scaling which results in rendering
// artifacts.
//
// The function takes the following parameters:
//
//    - dest into which to render the results.
//    - destX: left coordinate for region to render.
//    - destY: top coordinate for region to render.
//    - destWidth: width of the region to render.
//    - destHeight: height of the region to render.
//    - offsetX: offset in the X direction (currently rounded to an integer).
//    - offsetY: offset in the Y direction (currently rounded to an integer).
//    - scaleX: scale factor in the X direction.
//    - scaleY: scale factor in the Y direction.
//    - interpType: interpolation type for the transformation.
//
func (src *Pixbuf) Scale(dest *Pixbuf, destX, destY, destWidth, destHeight int, offsetX, offsetY, scaleX, scaleY float64, interpType InterpType) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(dest.Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = C.GdkInterpType(interpType)

	C.gdk_pixbuf_scale(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destX)
	runtime.KeepAlive(destY)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(offsetX)
	runtime.KeepAlive(offsetY)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
	runtime.KeepAlive(interpType)
}

// ScaleSimple: create a new pixbuf containing a copy of src scaled to
// dest_width x dest_height.
//
// This function leaves src unaffected.
//
// The interp_type should be GDK_INTERP_NEAREST if you want maximum speed (but
// when scaling down GDK_INTERP_NEAREST is usually unusably ugly). The default
// interp_type should be GDK_INTERP_BILINEAR which offers reasonable quality and
// speed.
//
// You can scale a sub-portion of src by creating a sub-pixbuf pointing into
// src; see gdkpixbuf.Pixbuf.NewSubpixbuf().
//
// If dest_width and dest_height are equal to the width and height of src, this
// function will return an unscaled copy of src.
//
// For more complicated scaling/alpha blending see gdkpixbuf.Pixbuf.Scale() and
// gdkpixbuf.Pixbuf.Composite().
//
// The function takes the following parameters:
//
//    - destWidth: width of destination image.
//    - destHeight: height of destination image.
//    - interpType: interpolation type for the transformation.
//
func (src *Pixbuf) ScaleSimple(destWidth, destHeight int, interpType InterpType) *Pixbuf {
	var _arg0 *C.GdkPixbuf    // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.GdkInterpType // out
	var _cret *C.GdkPixbuf    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(src.Native()))
	_arg1 = C.int(destWidth)
	_arg2 = C.int(destHeight)
	_arg3 = C.GdkInterpType(interpType)

	_cret = C.gdk_pixbuf_scale_simple(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(interpType)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// SetOption attaches a key/value pair as an option to a GdkPixbuf.
//
// If key already exists in the list of options attached to the pixbuf, the new
// value is ignored and FALSE is returned.
//
// The function takes the following parameters:
//
//    - key: nul-terminated string.
//    - value: nul-terminated string.
//
func (pixbuf *Pixbuf) SetOption(key, value string) bool {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // out
	var _arg2 *C.gchar     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.gchar)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gdk_pixbuf_set_option(_arg0, _arg1, _arg2)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
// extern gboolean _gotk4_gdkpixbuf2_PixbufSaveFunc(gchar*, gsize, GError**, gpointer);
import "C"

// PixbufSaveFunc: save functions used by gdkpixbuf.Pixbuf.SaveToCallback().
//
// This function is called once for each block of bytes that is "written" by
// gdk_pixbuf_save_to_callback().
//
// If successful it should return TRUE; if an error occurs it should set error
// and return FALSE, in which case gdk_pixbuf_save_to_callback() will fail with
// the same error.
type PixbufSaveFunc func(buf []byte) (err error, ok bool)

// NewPixbufFromFileAtSize creates a new pixbuf by loading an image from a file.
//
// The file format is detected automatically.
//
// If NULL is returned, then error will be set. Possible errors are:
//
//    - the file could not be opened
//    - there is no loader for the file's format
//    - there is not enough memory to allocate the image buffer
//    - the image buffer contains invalid data
//
// The error domains are GDK_PIXBUF_ERROR and G_FILE_ERROR.
//
// The image will be scaled to fit in the requested size, preserving the image's
// aspect ratio. Note that the returned pixbuf may be smaller than width x
// height, if the aspect ratio requires it. To load and image at the requested
// size, regardless of aspect ratio, use gdkpixbuf.Pixbuf.NewFromFileAtScale.
//
// The function takes the following parameters:
//
//    - filename: name of file to load, in the GLib file name encoding.
//    - width the image should have or -1 to not constrain the width.
//    - height the image should have or -1 to not constrain the height.
//
// The function returns the following values:
//
//    - pixbuf (optional): newly-created pixbuf.
//
func NewPixbufFromFileAtSize(filename string, width, height int) (*Pixbuf, error) {
	var _arg1 *C.char      // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _cret *C.GdkPixbuf // in
	var _cerr *C.GError    // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(width)
	_arg3 = C.int(height)

	_cret = C.gdk_pixbuf_new_from_file_at_size(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _pixbuf *Pixbuf // out
	var _goerr error    // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pixbuf, _goerr
}

// SaveToBufferv: vector version of gdk_pixbuf_save_to_buffer().
//
// Saves pixbuf to a new buffer in format type, which is currently "jpeg",
// "tiff", "png", "ico" or "bmp".
//
// See gdkpixbuf.Pixbuf.SaveToBuffer() for more details.
//
// The function takes the following parameters:
//
//    - typ: name of file format.
//    - optionKeys (optional): name of options to set.
//    - optionValues (optional) values for named options.
//
// The function returns the following values:
//
//    - buffer: location to receive a pointer to the new buffer.
//
func (pixbuf *Pixbuf) SaveToBufferv(typ string, optionKeys, optionValues []string) ([]byte, error) {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 *C.gchar     // in
	var _arg2 C.gsize      // in
	var _arg3 *C.char      // out
	var _arg4 **C.char     // out
	var _arg5 **C.char     // out
	var _cerr *C.GError    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		_arg4 = (**C.char)(C.calloc(C.size_t((len(optionKeys) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(optionKeys)+1)
			var zero *C.char
			out[len(optionKeys)] = zero
			for i := range optionKeys {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionKeys[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg5 = (**C.char)(C.calloc(C.size_t((len(optionValues) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg5))
		{
			out := unsafe.Slice(_arg5, len(optionValues)+1)
			var zero *C.char
			out[len(optionValues)] = zero
			for i := range optionValues {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionValues[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gdk_pixbuf_save_to_bufferv(_arg0, &_arg1, &_arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(optionKeys)
	runtime.KeepAlive(optionValues)

	var _buffer []byte // out
	var _goerr error   // out

	defer C.free(unsafe.Pointer(_arg1))
	_buffer = make([]byte, _arg2)
	copy(_buffer, unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _buffer, _goerr
}

// SaveToCallbackv: vector version of gdk_pixbuf_save_to_callback().
//
// Saves pixbuf to a callback in format type, which is currently "jpeg", "png",
// "tiff", "ico" or "bmp".
//
// If error is set, FALSE will be returned.
//
// See gdkpixbuf.Pixbuf.SaveToCallback() for more details.
//
// The function takes the following parameters:
//
//    - saveFunc: function that is called to save each block of data that the
//      save routine generates.
//    - typ: name of file format.
//    - optionKeys (optional): name of options to set.
//    - optionValues (optional) values for named options.
//
func (pixbuf *Pixbuf) SaveToCallbackv(saveFunc PixbufSaveFunc, typ string, optionKeys, optionValues []string) error {
	var _arg0 *C.GdkPixbuf        // out
	var _arg1 C.GdkPixbufSaveFunc // out
	var _arg2 C.gpointer
	var _arg3 *C.char   // out
	var _arg4 **C.char  // out
	var _arg5 **C.char  // out
	var _cerr *C.GError // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gdkpixbuf2_PixbufSaveFunc)
	_arg2 = C.gpointer(gbox.Assign(saveFunc))
	defer gbox.Delete(uintptr(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(typ)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		_arg4 = (**C.char)(C.calloc(C.size_t((len(optionKeys) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(optionKeys)+1)
			var zero *C.char
			out[len(optionKeys)] = zero
			for i := range optionKeys {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionKeys[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg5 = (**C.char)(C.calloc(C.size_t((len(optionValues) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg5))
		{
			out := unsafe.Slice(_arg5, len(optionValues)+1)
			var zero *C.char
			out[len(optionValues)] = zero
			for i := range optionValues {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionValues[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gdk_pixbuf_save_to_callbackv(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(pixbuf)
	runtime.KeepAlive(saveFunc)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(optionKeys)
	runtime.KeepAlive(optionValues)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Code generated by girgen. DO NOT EDIT.

package gdkpixbuf

import (
	"fmt"
	"runtime"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <gdk-pixbuf/gdk-pixbuf.h>
// #include <glib-object.h>
import "C"

// GTypeInterpType returns the GType for the type InterpType.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeInterpType() coreglib.Type {
	gtype := coreglib.Type(C.gdk_interp_type_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalInterpType)
	return gtype
}

// GTypePixbufRotation returns the GType for the type PixbufRotation.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypePixbufRotation() coreglib.Type {
	gtype := coreglib.Type(C.gdk_pixbuf_rotation_get_type())
	coreglib.RegisterGValueMarshaler(gtype, marshalPixbufRotation)
	return gtype
}

// InterpType: interpolation modes for scaling functions.
//
// The GDK_INTERP_NEAREST mode is the fastest scaling method, but has horrible
// quality when scaling down; GDK_INTERP_BILINEAR is the best choice if you
// aren't sure what to choose, it has a good speed/quality balance.
//
// **Note**: Cubic filtering is missing from the list; hyperbolic interpolation
// is just as fast and results in higher quality.
type InterpType C.gint

const (
	// InterpNearest: nearest neighbor sampling; this is the fastest and lowest
	// quality mode. Quality is normally unacceptable when scaling down, but may
	// be OK when scaling up.
	InterpNearest InterpType = iota
	// InterpTiles: this is an accurate simulation of the PostScript image
	// operator without any interpolation enabled. Each pixel is rendered as a
	// tiny parallelogram of solid color, the edges of which are implemented
	// with antialiasing. It resembles nearest neighbor for enlargement, and
	// bilinear for reduction.
	InterpTiles
	// InterpBilinear: best quality/speed balance; use this mode by default.
	// Bilinear interpolation. For enlargement, it is equivalent to
	// point-sampling the ideal bilinear-interpolated image. For reduction, it
	// is equivalent to laying down small tiles and integrating over the
	// coverage area.
	InterpBilinear
	// InterpHyper: this is the slowest and highest quality reconstruction
	// function. It is derived from the hyperbolic filters in Wolberg's "Digital
	// Image Warping", and is formally defined as the hyperbolic-filter sampling
	// the ideal hyperbolic-filter interpolated image (the filter is designed to
	// be idempotent for 1:1 pixel mapping). **Deprecated**: this interpolation
	// filter is deprecated, as in reality it has a lower quality than the
	// GDK_INTERP_BILINEAR filter (Since: 2.38).
	InterpHyper
)

func marshalInterpType(p uintptr) (interface{}, error) {
	return InterpType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for InterpType.
func (i InterpType) String() string {
	switch i {
	case InterpNearest:
		return "Nearest"
	case InterpTiles:
		return "Tiles"
	case InterpBilinear:
		return "Bilinear"
	case InterpHyper:
		return "Hyper"
	default:
		return fmt.Sprintf("InterpType(%d)", i)
	}
}

// PixbufRotation: possible rotations which can be passed to
// gdk_pixbuf_rotate_simple().
//
// To make them easier to use, their numerical values are the actual degrees.
type PixbufRotation C.gint

const (
	// PixbufRotateNone: no rotation.
	PixbufRotateNone PixbufRotation = 0
	// PixbufRotateCounterclockwise: rotate by 90 degrees.
	PixbufRotateCounterclockwise PixbufRotation = 90
	// PixbufRotateUpsidedown: rotate by 180 degrees.
	PixbufRotateUpsidedown PixbufRotation = 180
	// PixbufRotateClockwise: rotate by 270 degrees.
	PixbufRotateClockwise PixbufRotation = 270
)

func marshalPixbufRotation(p uintptr) (interface{}, error) {
	return PixbufRotation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PixbufRotation.
func (p PixbufRotation) String() string {
	switch p {
	case PixbufRotateNone:
		return "None"
	case PixbufRotateCounterclockwise:
		return "Counterclockwise"
	case PixbufRotateUpsidedown:
		return "Upsidedown"
	case PixbufRotateClockwise:
		return "Clockwise"
	default:
		return fmt.Sprintf("PixbufRotation(%d)", p)
	}
}

// Composite creates a transformation of the source image src by scaling by
// scale_x and scale_y then translating by offset_x and offset_y.
//
// This gives an image in the coordinates of the destination pixbuf. The
// rectangle (dest_x, dest_y, dest_width, dest_height) is then alpha blended
// onto the corresponding rectangle of the original destination image.
//
// When the destination rectangle contains parts not in the source image, the
// data at the edges of the source image is replicated to infinity.
//
// ! (composite.png).
//
// The function takes the following parameters:
//
//    - dest into which to render the results.
//    - destX: left coordinate for region to render.
//    - destY: top coordinate for region to render.
//    - destWidth: width of the region to render.
//    - destHeight: height of the region to render.
//    - offsetX: offset in the X direction (currently rounded to an integer).
//    - offsetY: offset in the Y direction (currently rounded to an integer).
//    - scaleX: scale factor in the X direction.
//    - scaleY: scale factor in the Y direction.
//    - interpType: interpolation type for the transformation.
//    - overallAlpha: overall alpha for source image (0..255).
//
func (src *Pixbuf) Composite(dest *Pixbuf, destX, destY, destWidth, destHeight int32, offsetX, offsetY, scaleX, scaleY float64, interpType InterpType, overallAlpha int32) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out
	var _arg11 C.int           // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = C.GdkInterpType(interpType)
	_arg11 = C.int(overallAlpha)

	C.gdk_pixbuf_composite(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destX)
	runtime.KeepAlive(destY)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(offsetX)
	runtime.KeepAlive(offsetY)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
	runtime.KeepAlive(interpType)
	runtime.KeepAlive(overallAlpha)
}

// CompositeColor creates a transformation of the source image src by scaling by
// scale_x and scale_y then translating by offset_x and offset_y, then alpha
// blends the rectangle (dest_x ,dest_y, dest_width, dest_height) of the
// resulting image with a checkboard of the colors color1 and color2 and renders
// it onto the destination image.
//
// If the source image has no alpha channel, and overall_alpha is 255, a fast
// path is used which omits the alpha blending and just performs the scaling.
//
// See gdk_pixbuf_composite_color_simple() for a simpler variant of this
// function suitable for many tasks.
//
// The function takes the following parameters:
//
//    - dest into which to render the results.
//    - destX: left coordinate for region to render.
//    - destY: top coordinate for region to render.
//    - destWidth: width of the region to render.
//    - destHeight: height of the region to render.
//    - offsetX: offset in the X direction (currently rounded to an integer).
//    - offsetY: offset in the Y direction (currently rounded to an integer).
//    - scaleX: scale factor in the X direction.
//    - scaleY: scale factor in the Y direction.
//    - interpType: interpolation type for the transformation.
//    - overallAlpha: overall alpha for source image (0..255).
//    - checkX: x offset for the checkboard (origin of checkboard is at -check_x,
//      -check_y).
//    - checkY: y offset for the checkboard.
//    - checkSize: size of checks in the checkboard (must be a power of two).
//    - color1: color of check at upper left.
//    - color2: color of the other check.
//
func (src *Pixbuf) CompositeColor(dest *Pixbuf, destX, destY, destWidth, destHeight int32, offsetX, offsetY, scaleX, scaleY float64, interpType InterpType, overallAlpha, checkX, checkY, checkSize int32, color1, color2 uint32) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out
	var _arg11 C.int           // out
	var _arg12 C.int           // out
	var _arg13 C.int           // out
	var _arg14 C.int           // out
	var _arg15 C.guint32       // out
	var _arg16 C.guint32       // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = C.GdkInterpType(interpType)
	_arg11 = C.int(overallAlpha)
	_arg12 = C.int(checkX)
	_arg13 = C.int(checkY)
	_arg14 = C.int(checkSize)
	_arg15 = C.guint32(color1)
	_arg16 = C.guint32(color2)

	C.gdk_pixbuf_composite_color(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15, _arg16)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destX)
	runtime.KeepAlive(destY)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(offsetX)
	runtime.KeepAlive(offsetY)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
	runtime.KeepAlive(interpType)
	runtime.KeepAlive(overallAlpha)
	runtime.KeepAlive(checkX)
	runtime.KeepAlive(checkY)
	runtime.KeepAlive(checkSize)
	runtime.KeepAlive(color1)
	runtime.KeepAlive(color2)
}

// CompositeColorSimple creates a new pixbuf by scaling src to dest_width x
// dest_height and alpha blending the result with a checkboard of colors color1
// and color2.
//
// The function takes the following parameters:
//
//    - destWidth: width of destination image.
//    - destHeight: height of destination image.
//    - interpType: interpolation type for the transformation.
//    - overallAlpha: overall alpha for source image (0..255).
//    - checkSize: size of checks in the checkboard (must be a power of two).
//    - color1: color of check at upper left.
//    - color2: color of the other check.
//
// The function returns the following values:
//
//    - pixbuf (optional): new pixbuf.
//
func (src *Pixbuf) CompositeColorSimple(destWidth, destHeight int32, interpType InterpType, overallAlpha, checkSize int32, color1, color2 uint32) *Pixbuf {
	var _arg0 *C.GdkPixbuf    // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.GdkInterpType // out
	var _arg4 C.int           // out
	var _arg5 C.int           // out
	var _arg6 C.guint32       // out
	var _arg7 C.guint32       // out
	var _cret *C.GdkPixbuf    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.int(destWidth)
	_arg2 = C.int(destHeight)
	_arg3 = C.GdkInterpType(interpType)
	_arg4 = C.int(overallAlpha)
	_arg5 = C.int(checkSize)
	_arg6 = C.guint32(color1)
	_arg7 = C.guint32(color2)

	_cret = C.gdk_pixbuf_composite_color_simple(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(src)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(interpType)
	runtime.KeepAlive(overallAlpha)
	runtime.KeepAlive(checkSize)
	runtime.KeepAlive(color1)
	runtime.KeepAlive(color2)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// Flip flips a pixbuf horizontally or vertically and returns the result in a
// new pixbuf.
//
// The function takes the following parameters:
//
//    - horizontal: TRUE to flip horizontally, FALSE to flip vertically.
//
// The function returns the following values:
//
//    - pixbuf (optional): new pixbuf.
//
func (src *Pixbuf) Flip(horizontal bool) *Pixbuf {
	var _arg0 *C.GdkPixbuf // out
	var _arg1 C.gboolean   // out
	var _cret *C.GdkPixbuf // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	if horizontal {
		_arg1 = C.TRUE
	}

	_cret = C.gdk_pixbuf_flip(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(horizontal)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// RotateSimple rotates a pixbuf by a multiple of 90 degrees, and returns the
// result in a new pixbuf.
//
// If angle is 0, this function will return a copy of src.
//
// The function takes the following parameters:
//
//    - angle to rotate by.
//
// The function returns the following values:
//
//    - pixbuf (optional): new pixbuf.
//
func (src *Pixbuf) RotateSimple(angle PixbufRotation) *Pixbuf {
	var _arg0 *C.GdkPixbuf        // out
	var _arg1 C.GdkPixbufRotation // out
	var _cret *C.GdkPixbuf        // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.GdkPixbufRotation(angle)

	_cret = C.gdk_pixbuf_rotate_simple(_arg0, _arg1)
	runtime.KeepAlive(src)
	runtime.KeepAlive(angle)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

// Scale creates a transformation of the source image src by scaling by scale_x
// and scale_y then translating by offset_x and offset_y, then renders the
// rectangle (dest_x, dest_y, dest_width, dest_height) of the resulting image
// onto the destination image replacing the previous contents.
//
// Try to use gdk_pixbuf_scale_simple() first; this function is the
// industrial-strength power tool you can fall back to, if
// gdk_pixbuf_scale_simple() isn't powerful enough.
//
// If the source rectangle overlaps the destination rectangle on the same
// pixbuf, it will be overwritten during the scaling which results in rendering
// artifacts.
//
// The function takes the following parameters:
//
//    - dest into which to render the results.
//    - destX: left coordinate for region to render.
//    - destY: top coordinate for region to render.
//    - destWidth: width of the region to render.
//    - destHeight: height of the region to render.
//    - offsetX: offset in the X direction (currently rounded to an integer).
//    - offsetY: offset in the Y direction (currently rounded to an integer).
//    - scaleX: scale factor in the X direction.
//    - scaleY: scale factor in the Y direction.
//    - interpType: interpolation type for the transformation.
//
func (src *Pixbuf) Scale(dest *Pixbuf, destX, destY, destWidth, destHeight int32, offsetX, offsetY, scaleX, scaleY float64, interpType InterpType) {
	var _arg0 *C.GdkPixbuf     // out
	var _arg1 *C.GdkPixbuf     // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out
	var _arg5 C.int            // out
	var _arg6 C.double         // out
	var _arg7 C.double         // out
	var _arg8 C.double         // out
	var _arg9 C.double         // out
	var _arg10 C.GdkInterpType // out

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(dest).Native()))
	_arg2 = C.int(destX)
	_arg3 = C.int(destY)
	_arg4 = C.int(destWidth)
	_arg5 = C.int(destHeight)
	_arg6 = C.double(offsetX)
	_arg7 = C.double(offsetY)
	_arg8 = C.double(scaleX)
	_arg9 = C.double(scaleY)
	_arg10 = C.GdkInterpType(interpType)

	C.gdk_pixbuf_scale(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10)
	runtime.KeepAlive(src)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(destX)
	runtime.KeepAlive(destY)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(offsetX)
	runtime.KeepAlive(offsetY)
	runtime.KeepAlive(scaleX)
	runtime.KeepAlive(scaleY)
	runtime.KeepAlive(interpType)
}

// ScaleSimple: create a new pixbuf containing a copy of src scaled to
// dest_width x dest_height.
//
// This function leaves src unaffected.
//
// The interp_type should be GDK_INTERP_NEAREST if you want maximum speed (but
// when scaling down GDK_INTERP_NEAREST is usually unusably ugly). The default
// interp_type should be GDK_INTERP_BILINEAR which offers reasonable quality and
// speed.
//
// You can scale a sub-portion of src by creating a sub-pixbuf pointing into
// src; see gdkpixbuf.Pixbuf.NewSubpixbuf().
//
// If dest_width and dest_height are equal to the width and height of src, this
// function will return an unscaled copy of src.
//
// For more complicated scaling/alpha blending see gdkpixbuf.Pixbuf.Scale() and
// gdkpixbuf.Pixbuf.Composite().
//
// The function takes the following parameters:
//
//    - destWidth: width of destination image.
//    - destHeight: height of destination image.
//    - interpType: interpolation type for the transformation.
//
// The function returns the following values:
//
//    - pixbuf (optional): new pixbuf.
//
func (src *Pixbuf) ScaleSimple(destWidth, destHeight int32, interpType InterpType) *Pixbuf {
	var _arg0 *C.GdkPixbuf    // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.GdkInterpType // out
	var _cret *C.GdkPixbuf    // in

	_arg0 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(src).Native()))
	_arg1 = C.int(destWidth)
	_arg2 = C.int(destHeight)
	_arg3 = C.GdkInterpType(interpType)

	_cret = C.gdk_pixbuf_scale_simple(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(src)
	runtime.KeepAlive(destWidth)
	runtime.KeepAlive(destHeight)
	runtime.KeepAlive(interpType)

	var _pixbuf *Pixbuf // out

	if _cret != nil {
		_pixbuf = wrapPixbuf(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _pixbuf
}

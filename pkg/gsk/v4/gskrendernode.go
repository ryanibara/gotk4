// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
// extern void _gotk4_gsk4_ParseErrorFunc(void*, void*, GError*, gpointer);
import "C"

// GTypeRenderNode returns the GType for the type RenderNode.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeRenderNode() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gsk", "RenderNode").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalRenderNode)
	return gtype
}

// ParseErrorFunc: type of callback that is called when an error occurs during
// node deserialization.
type ParseErrorFunc func(start, end *ParseLocation, err error)

//export _gotk4_gsk4_ParseErrorFunc
func _gotk4_gsk4_ParseErrorFunc(arg1 *C.void, arg2 *C.void, arg3 *C.GError, arg4 C.gpointer) {
	var fn ParseErrorFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ParseErrorFunc)
	}

	var _start *ParseLocation // out
	var _end *ParseLocation   // out
	var _err error            // out

	_start = (*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_err = gerror.Take(unsafe.Pointer(arg3))

	fn(_start, _end, _err)
}

// BottomChild retrieves the bottom GskRenderNode child of the node.
//
// The function returns the following values:
//
//    - renderNode: bottom child node.
//
func (node *BlendNode) BottomChild() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "BlendNode")
	_gret := _info.InvokeClassMethod("get_bottom_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// TopChild retrieves the top GskRenderNode child of the node.
//
// The function returns the following values:
//
//    - renderNode: top child node.
//
func (node *BlendNode) TopChild() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "BlendNode")
	_gret := _info.InvokeClassMethod("get_top_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NewBlurNode creates a render node that blurs the child.
//
// The function takes the following parameters:
//
//    - child node to blur.
//    - radius: blur radius.
//
// The function returns the following values:
//
//    - blurNode: new GskRenderNode.
//
func NewBlurNode(child RenderNoder, radius float32) *BlurNode {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(radius)

	_info := girepository.MustFind("Gsk", "BlurNode")
	_gret := _info.InvokeClassMethod("new_BlurNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(radius)

	var _blurNode *BlurNode // out

	_blurNode = wrapBlurNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _blurNode
}

// Child retrieves the child GskRenderNode of the blur node.
//
// The function returns the following values:
//
//    - renderNode: blurred child node.
//
func (node *BlurNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "BlurNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Radius retrieves the blur radius of the node.
//
// The function returns the following values:
//
//    - gfloat: blur radius.
//
func (node *BlurNode) Radius() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "BlurNode")
	_gret := _info.InvokeClassMethod("get_radius", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Colors retrieves the colors of the border.
//
// The function returns the following values:
//
//    - rgbA: array of 4 RGBA structs for the top, right, bottom and left color
//      of the border.
//
func (node *BorderNode) Colors() *gdk.RGBA {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "BorderNode")
	_gret := _info.InvokeClassMethod("get_colors", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _rgbA
}

// Outline retrieves the outline of the border.
//
// The function returns the following values:
//
//    - roundedRect: outline of the border.
//
func (node *BorderNode) Outline() *RoundedRect {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "BorderNode")
	_gret := _info.InvokeClassMethod("get_outline", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// Widths retrieves the stroke widths of the border.
//
// The function returns the following values:
//
//    - gfloats: array of 4 floats for the top, right, bottom and left stroke
//      width of the border, respectively.
//
func (node *BorderNode) Widths() [4]float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "BorderNode")
	_gret := _info.InvokeClassMethod("get_widths", _args[:], nil)
	_cret := *(**C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloats [4]float32 // out

	_gfloats = *(*[4]float32)(unsafe.Pointer(&*(**C.float)(unsafe.Pointer(&_cret))))

	return _gfloats
}

// NewCairoNode creates a GskRenderNode that will render a cairo surface into
// the area given by bounds.
//
// You can draw to the cairo surface using gsk.CairoNode.GetDrawContext().
//
// The function takes the following parameters:
//
//    - bounds: rectangle to render to.
//
// The function returns the following values:
//
//    - cairoNode: new GskRenderNode.
//
func NewCairoNode(bounds *graphene.Rect) *CairoNode {
	var _args [1]girepository.Argument

	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[0])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_info := girepository.MustFind("Gsk", "CairoNode")
	_gret := _info.InvokeClassMethod("new_CairoNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(bounds)

	var _cairoNode *CairoNode // out

	_cairoNode = wrapCairoNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _cairoNode
}

// DrawContext creates a Cairo context for drawing using the surface associated
// to the render node.
//
// If no surface exists yet, a surface will be created optimized for rendering
// to renderer.
//
// The function returns the following values:
//
//    - context: cairo context used for drawing; use cairo_destroy() when done
//      drawing.
//
func (node *CairoNode) DrawContext() *cairo.Context {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "CairoNode")
	_gret := _info.InvokeClassMethod("get_draw_context", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(uintptr(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.cairo_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _context
}

// Surface retrieves the Cairo surface used by the render node.
//
// The function returns the following values:
//
//    - surface: cairo surface.
//
func (node *CairoNode) Surface() *cairo.Surface {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "CairoNode")
	_gret := _info.InvokeClassMethod("get_surface", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	C.cairo_surface_reference(*(**C.void)(unsafe.Pointer(&_cret)))
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// NewClipNode creates a GskRenderNode that will clip the child to the area
// given by clip.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - clip to apply.
//
// The function returns the following values:
//
//    - clipNode: new GskRenderNode.
//
func NewClipNode(child RenderNoder, clip *graphene.Rect) *ClipNode {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(clip)))

	_info := girepository.MustFind("Gsk", "ClipNode")
	_gret := _info.InvokeClassMethod("new_ClipNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _clipNode *ClipNode // out

	_clipNode = wrapClipNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _clipNode
}

// Child gets the child node that is getting clipped by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting clipped.
//
func (node *ClipNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ClipNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the clip rectangle for node.
//
// The function returns the following values:
//
//    - rect: clip rectangle.
//
func (node *ClipNode) Clip() *graphene.Rect {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ClipNode")
	_gret := _info.InvokeClassMethod("get_clip", _args[:], nil)
	_cret := *(**C.graphene_rect_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_rect_t)(unsafe.Pointer(&_cret)))))

	return _rect
}

// NewColorMatrixNode creates a GskRenderNode that will drawn the child with
// color_matrix.
//
// In particular, the node will transform the operation
//
//    pixel = color_matrix * pixel + color_offset
//
// for every pixel.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - colorMatrix: matrix to apply.
//    - colorOffset values to add to the color.
//
// The function returns the following values:
//
//    - colorMatrixNode: new GskRenderNode.
//
func NewColorMatrixNode(child RenderNoder, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) *ColorMatrixNode {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.graphene_matrix_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_matrix_t)(gextras.StructNative(unsafe.Pointer(colorMatrix)))
	*(**C.graphene_vec4_t)(unsafe.Pointer(&_args[2])) = (*C.graphene_vec4_t)(gextras.StructNative(unsafe.Pointer(colorOffset)))

	_info := girepository.MustFind("Gsk", "ColorMatrixNode")
	_gret := _info.InvokeClassMethod("new_ColorMatrixNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(colorMatrix)
	runtime.KeepAlive(colorOffset)

	var _colorMatrixNode *ColorMatrixNode // out

	_colorMatrixNode = wrapColorMatrixNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _colorMatrixNode
}

// Child gets the child node that is getting its colors modified by the given
// node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting its colors modified.
//
func (node *ColorMatrixNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ColorMatrixNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ColorMatrix retrieves the color matrix used by the node.
//
// The function returns the following values:
//
//    - matrix: 4x4 color matrix.
//
func (node *ColorMatrixNode) ColorMatrix() *graphene.Matrix {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ColorMatrixNode")
	_gret := _info.InvokeClassMethod("get_color_matrix", _args[:], nil)
	_cret := *(**C.graphene_matrix_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _matrix *graphene.Matrix // out

	_matrix = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_matrix_t)(unsafe.Pointer(&_cret)))))

	return _matrix
}

// ColorOffset retrieves the color offset used by the node.
//
// The function returns the following values:
//
//    - vec4: color vector.
//
func (node *ColorMatrixNode) ColorOffset() *graphene.Vec4 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ColorMatrixNode")
	_gret := _info.InvokeClassMethod("get_color_offset", _args[:], nil)
	_cret := *(**C.graphene_vec4_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _vec4 *graphene.Vec4 // out

	_vec4 = (*graphene.Vec4)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_vec4_t)(unsafe.Pointer(&_cret)))))

	return _vec4
}

// NewColorNode creates a GskRenderNode that will render the color specified by
// rgba into the area given by bounds.
//
// The function takes the following parameters:
//
//    - rgba: GdkRGBA specifying a color.
//    - bounds: rectangle to render the color into.
//
// The function returns the following values:
//
//    - colorNode: new GskRenderNode.
//
func NewColorNode(rgba *gdk.RGBA, bounds *graphene.Rect) *ColorNode {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(rgba)))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_info := girepository.MustFind("Gsk", "ColorNode")
	_gret := _info.InvokeClassMethod("new_ColorNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(rgba)
	runtime.KeepAlive(bounds)

	var _colorNode *ColorNode // out

	_colorNode = wrapColorNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _colorNode
}

// Color retrieves the color of the given node.
//
// The function returns the following values:
//
//    - rgbA: color of the node.
//
func (node *ColorNode) Color() *gdk.RGBA {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ColorNode")
	_gret := _info.InvokeClassMethod("get_color", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _rgbA
}

// Angle retrieves the angle for the gradient in radians, normalized in [0, 2 *
// PI].
//
// The angle is starting at the top and going clockwise, as expressed in the css
// specification:
//
//    angle = 90 - gsk_conic_gradient_node_get_rotation().
//
// The function returns the following values:
//
//    - gfloat: angle for the gradient.
//
func (node *ConicGradientNode) Angle() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ConicGradientNode")
	_gret := _info.InvokeClassMethod("get_angle", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Center retrieves the center pointer for the gradient.
//
// The function returns the following values:
//
//    - point: center point for the gradient.
//
func (node *ConicGradientNode) Center() *graphene.Point {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ConicGradientNode")
	_gret := _info.InvokeClassMethod("get_center", _args[:], nil)
	_cret := *(**C.graphene_point_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_point_t)(unsafe.Pointer(&_cret)))))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *ConicGradientNode) NColorStops() uint {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ConicGradientNode")
	_gret := _info.InvokeClassMethod("get_n_color_stops", _args[:], nil)
	_cret := *(*C.gsize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(*(*C.gsize)(unsafe.Pointer(&_cret)))

	return _gsize
}

// Rotation retrieves the rotation for the gradient in degrees.
//
// The function returns the following values:
//
//    - gfloat: rotation for the gradient.
//
func (node *ConicGradientNode) Rotation() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ConicGradientNode")
	_gret := _info.InvokeClassMethod("get_rotation", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// NewContainerNode creates a new GskRenderNode instance for holding the given
// children.
//
// The new node will acquire a reference to each of the children.
//
// The function takes the following parameters:
//
//    - children of the node.
//
// The function returns the following values:
//
//    - containerNode: new GskRenderNode.
//
func NewContainerNode(children []RenderNoder) *ContainerNode {
	var _args [2]girepository.Argument

	*(*C.guint)(unsafe.Pointer(&_args[1])) = (C.guint)(len(children))
	*(***C.void)(unsafe.Pointer(&_args[0])) = (**C.void)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(*(***C.void)(unsafe.Pointer(&_args[0]))))
	{
		out := unsafe.Slice((**C.void)(*(***C.void)(unsafe.Pointer(&_args[0]))), len(children))
		for i := range children {
			*(**C.void)(unsafe.Pointer(&out[i])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(children[i]).Native()))
		}
	}

	_info := girepository.MustFind("Gsk", "ContainerNode")
	_gret := _info.InvokeClassMethod("new_ContainerNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(children)

	var _containerNode *ContainerNode // out

	_containerNode = wrapContainerNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _containerNode
}

// Child gets one of the children of container.
//
// The function takes the following parameters:
//
//    - idx: position of the child to get.
//
// The function returns the following values:
//
//    - renderNode: idx'th child of container.
//
func (node *ContainerNode) Child(idx uint32) RenderNoder {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(idx)

	_info := girepository.MustFind("Gsk", "ContainerNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren retrieves the number of direct children of node.
//
// The function returns the following values:
//
//    - guint: number of children of the GskRenderNode.
//
func (node *ContainerNode) NChildren() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ContainerNode")
	_gret := _info.InvokeClassMethod("get_n_children", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// NewCrossFadeNode creates a GskRenderNode that will do a cross-fade between
// start and end.
//
// The function takes the following parameters:
//
//    - start node to be drawn.
//    - end: node to be cross_fadeed onto the start node.
//    - progress: how far the fade has progressed from start to end. The value
//      will be clamped to the range [0 ... 1].
//
// The function returns the following values:
//
//    - crossFadeNode: new GskRenderNode.
//
func NewCrossFadeNode(start, end RenderNoder, progress float32) *CrossFadeNode {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(start).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(end).Native()))
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(progress)

	_info := girepository.MustFind("Gsk", "CrossFadeNode")
	_gret := _info.InvokeClassMethod("new_CrossFadeNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(progress)

	var _crossFadeNode *CrossFadeNode // out

	_crossFadeNode = wrapCrossFadeNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _crossFadeNode
}

// EndChild retrieves the child GskRenderNode at the end of the cross-fade.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *CrossFadeNode) EndChild() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "CrossFadeNode")
	_gret := _info.InvokeClassMethod("get_end_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Progress retrieves the progress value of the cross fade.
//
// The function returns the following values:
//
//    - gfloat progress value, between 0 and 1.
//
func (node *CrossFadeNode) Progress() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "CrossFadeNode")
	_gret := _info.InvokeClassMethod("get_progress", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// StartChild retrieves the child GskRenderNode at the beginning of the
// cross-fade.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *CrossFadeNode) StartChild() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "CrossFadeNode")
	_gret := _info.InvokeClassMethod("get_start_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NewDebugNode creates a GskRenderNode that will add debug information about
// the given child.
//
// Adding this node has no visual effect.
//
// The function takes the following parameters:
//
//    - child to add debug info for.
//    - message: debug message.
//
// The function returns the following values:
//
//    - debugNode: new GskRenderNode.
//
func NewDebugNode(child RenderNoder, message string) *DebugNode {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(message)))

	_info := girepository.MustFind("Gsk", "DebugNode")
	_gret := _info.InvokeClassMethod("new_DebugNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(message)

	var _debugNode *DebugNode // out

	_debugNode = wrapDebugNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _debugNode
}

// Child gets the child node that is getting drawn by the given node.
//
// The function returns the following values:
//
//    - renderNode: child GskRenderNode.
//
func (node *DebugNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "DebugNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Message gets the debug message that was set on this node.
//
// The function returns the following values:
//
//    - utf8: debug message.
//
func (node *DebugNode) Message() string {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "DebugNode")
	_gret := _info.InvokeClassMethod("get_message", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))

	return _utf8
}

// NewGLShaderNode creates a GskRenderNode that will render the given shader
// into the area given by bounds.
//
// The args is a block of data to use for uniform input, as per types and
// offsets defined by the shader. Normally this is generated by
// gsk.GLShader.FormatArgs() or gsk.ShaderArgsBuilder.
//
// See gsk.GLShader for details about how the shader should be written.
//
// All the children will be rendered into textures (if they aren't already
// GskTextureNodes, which will be used directly). These textures will be sent as
// input to the shader.
//
// If the renderer doesn't support GL shaders, or if there is any problem when
// compiling the shader, then the node will draw pink. You should use
// gsk.GLShader.Compile() to ensure the shader will work for the renderer before
// using it.
//
// The function takes the following parameters:
//
//    - shader: GLShader.
//    - bounds: rectangle to render the shader into.
//    - args arguments for the uniforms.
//    - children: array of child nodes, these will be rendered to textures and
//      used as input.
//
// The function returns the following values:
//
//    - glShaderNode: new GskRenderNode.
//
func NewGLShaderNode(shader *GLShader, bounds *graphene.Rect, args *glib.Bytes, children []RenderNoder) *GLShaderNode {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	*(**C.GBytes)(unsafe.Pointer(&_args[2])) = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	*(*C.guint)(unsafe.Pointer(&_args[4])) = (C.guint)(len(children))
	*(***C.void)(unsafe.Pointer(&_args[3])) = (**C.void)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(*(***C.void)(unsafe.Pointer(&_args[3]))))
	{
		out := unsafe.Slice((**C.void)(*(***C.void)(unsafe.Pointer(&_args[3]))), len(children))
		for i := range children {
			*(**C.void)(unsafe.Pointer(&out[i])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(children[i]).Native()))
		}
	}

	_info := girepository.MustFind("Gsk", "GLShaderNode")
	_gret := _info.InvokeClassMethod("new_GLShaderNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(shader)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(args)
	runtime.KeepAlive(children)

	var _glShaderNode *GLShaderNode // out

	_glShaderNode = wrapGLShaderNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _glShaderNode
}

// Args gets args for the node.
//
// The function returns the following values:
//
//    - bytes with the uniform arguments.
//
func (node *GLShaderNode) Args() *glib.Bytes {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "GLShaderNode")
	_gret := _info.InvokeClassMethod("get_args", _args[:], nil)
	_cret := *(**C.GBytes)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(*(**C.GBytes)(unsafe.Pointer(&_cret)))))
	C.g_bytes_ref(*(**C.GBytes)(unsafe.Pointer(&_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bytes
}

// Child gets one of the children.
//
// The function takes the following parameters:
//
//    - idx: position of the child to get.
//
// The function returns the following values:
//
//    - renderNode: idx'th child of node.
//
func (node *GLShaderNode) Child(idx uint32) RenderNoder {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(*C.guint)(unsafe.Pointer(&_args[1])) = C.guint(idx)

	_info := girepository.MustFind("Gsk", "GLShaderNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren returns the number of children.
//
// The function returns the following values:
//
//    - guint: number of children.
//
func (node *GLShaderNode) NChildren() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "GLShaderNode")
	_gret := _info.InvokeClassMethod("get_n_children", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Shader gets shader code for the node.
//
// The function returns the following values:
//
//    - glShader: GLShader shader.
//
func (node *GLShaderNode) Shader() *GLShader {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "GLShaderNode")
	_gret := _info.InvokeClassMethod("get_shader", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _glShader *GLShader // out

	_glShader = wrapGLShader(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _glShader
}

// NewInsetShadowNode creates a GskRenderNode that will render an inset shadow
// into the box given by outline.
//
// The function takes the following parameters:
//
//    - outline of the region containing the shadow.
//    - color of the shadow.
//    - dx: horizontal offset of shadow.
//    - dy: vertical offset of shadow.
//    - spread: how far the shadow spreads towards the inside.
//    - blurRadius: how much blur to apply to the shadow.
//
// The function returns the following values:
//
//    - insetShadowNode: new GskRenderNode.
//
func NewInsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) *InsetShadowNode {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(outline)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(dx)
	*(*C.float)(unsafe.Pointer(&_args[3])) = C.float(dy)
	*(*C.float)(unsafe.Pointer(&_args[4])) = C.float(spread)
	*(*C.float)(unsafe.Pointer(&_args[5])) = C.float(blurRadius)

	_info := girepository.MustFind("Gsk", "InsetShadowNode")
	_gret := _info.InvokeClassMethod("new_InsetShadowNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _insetShadowNode *InsetShadowNode // out

	_insetShadowNode = wrapInsetShadowNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _insetShadowNode
}

// BlurRadius retrieves the blur radius to apply to the shadow.
//
// The function returns the following values:
//
//    - gfloat: blur radius, in pixels.
//
func (node *InsetShadowNode) BlurRadius() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "InsetShadowNode")
	_gret := _info.InvokeClassMethod("get_blur_radius", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Color retrieves the color of the inset shadow.
//
// The function returns the following values:
//
//    - rgbA: color of the shadow.
//
func (node *InsetShadowNode) Color() *gdk.RGBA {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "InsetShadowNode")
	_gret := _info.InvokeClassMethod("get_color", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _rgbA
}

// Dx retrieves the horizontal offset of the inset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *InsetShadowNode) Dx() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "InsetShadowNode")
	_gret := _info.InvokeClassMethod("get_dx", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Dy retrieves the vertical offset of the inset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *InsetShadowNode) Dy() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "InsetShadowNode")
	_gret := _info.InvokeClassMethod("get_dy", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Outline retrieves the outline rectangle of the inset shadow.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *InsetShadowNode) Outline() *RoundedRect {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "InsetShadowNode")
	_gret := _info.InvokeClassMethod("get_outline", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads inwards.
//
// The function returns the following values:
//
//    - gfloat: size of the shadow, in pixels.
//
func (node *InsetShadowNode) Spread() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "InsetShadowNode")
	_gret := _info.InvokeClassMethod("get_spread", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// End retrieves the final point of the linear gradient.
//
// The function returns the following values:
//
//    - point: final point.
//
func (node *LinearGradientNode) End() *graphene.Point {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "LinearGradientNode")
	_gret := _info.InvokeClassMethod("get_end", _args[:], nil)
	_cret := *(**C.graphene_point_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_point_t)(unsafe.Pointer(&_cret)))))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *LinearGradientNode) NColorStops() uint {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "LinearGradientNode")
	_gret := _info.InvokeClassMethod("get_n_color_stops", _args[:], nil)
	_cret := *(*C.gsize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(*(*C.gsize)(unsafe.Pointer(&_cret)))

	return _gsize
}

// Start retrieves the initial point of the linear gradient.
//
// The function returns the following values:
//
//    - point: initial point.
//
func (node *LinearGradientNode) Start() *graphene.Point {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "LinearGradientNode")
	_gret := _info.InvokeClassMethod("get_start", _args[:], nil)
	_cret := *(**C.graphene_point_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_point_t)(unsafe.Pointer(&_cret)))))

	return _point
}

// NewOpacityNode creates a GskRenderNode that will drawn the child with reduced
// opacity.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - opacity to apply.
//
// The function returns the following values:
//
//    - opacityNode: new GskRenderNode.
//
func NewOpacityNode(child RenderNoder, opacity float32) *OpacityNode {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(opacity)

	_info := girepository.MustFind("Gsk", "OpacityNode")
	_gret := _info.InvokeClassMethod("new_OpacityNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(opacity)

	var _opacityNode *OpacityNode // out

	_opacityNode = wrapOpacityNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _opacityNode
}

// Child gets the child node that is getting opacityed by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting opacityed.
//
func (node *OpacityNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "OpacityNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Opacity gets the transparency factor for an opacity node.
//
// The function returns the following values:
//
//    - gfloat: opacity factor.
//
func (node *OpacityNode) Opacity() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "OpacityNode")
	_gret := _info.InvokeClassMethod("get_opacity", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// NewOutsetShadowNode creates a GskRenderNode that will render an outset shadow
// around the box given by outline.
//
// The function takes the following parameters:
//
//    - outline of the region surrounded by shadow.
//    - color of the shadow.
//    - dx: horizontal offset of shadow.
//    - dy: vertical offset of shadow.
//    - spread: how far the shadow spreads towards the inside.
//    - blurRadius: how much blur to apply to the shadow.
//
// The function returns the following values:
//
//    - outsetShadowNode: new GskRenderNode.
//
func NewOutsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) *OutsetShadowNode {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(outline)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(dx)
	*(*C.float)(unsafe.Pointer(&_args[3])) = C.float(dy)
	*(*C.float)(unsafe.Pointer(&_args[4])) = C.float(spread)
	*(*C.float)(unsafe.Pointer(&_args[5])) = C.float(blurRadius)

	_info := girepository.MustFind("Gsk", "OutsetShadowNode")
	_gret := _info.InvokeClassMethod("new_OutsetShadowNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _outsetShadowNode *OutsetShadowNode // out

	_outsetShadowNode = wrapOutsetShadowNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _outsetShadowNode
}

// BlurRadius retrieves the blur radius of the shadow.
//
// The function returns the following values:
//
//    - gfloat: blur radius, in pixels.
//
func (node *OutsetShadowNode) BlurRadius() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "OutsetShadowNode")
	_gret := _info.InvokeClassMethod("get_blur_radius", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Color retrieves the color of the outset shadow.
//
// The function returns the following values:
//
//    - rgbA: color.
//
func (node *OutsetShadowNode) Color() *gdk.RGBA {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "OutsetShadowNode")
	_gret := _info.InvokeClassMethod("get_color", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _rgbA
}

// Dx retrieves the horizontal offset of the outset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *OutsetShadowNode) Dx() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "OutsetShadowNode")
	_gret := _info.InvokeClassMethod("get_dx", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Dy retrieves the vertical offset of the outset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *OutsetShadowNode) Dy() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "OutsetShadowNode")
	_gret := _info.InvokeClassMethod("get_dy", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Outline retrieves the outline rectangle of the outset shadow.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *OutsetShadowNode) Outline() *RoundedRect {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "OutsetShadowNode")
	_gret := _info.InvokeClassMethod("get_outline", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads outwards.
//
// The function returns the following values:
//
//    - gfloat: size of the shadow, in pixels.
//
func (node *OutsetShadowNode) Spread() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "OutsetShadowNode")
	_gret := _info.InvokeClassMethod("get_spread", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Center retrieves the center pointer for the gradient.
//
// The function returns the following values:
//
//    - point: center point for the gradient.
//
func (node *RadialGradientNode) Center() *graphene.Point {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RadialGradientNode")
	_gret := _info.InvokeClassMethod("get_center", _args[:], nil)
	_cret := *(**C.graphene_point_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_point_t)(unsafe.Pointer(&_cret)))))

	return _point
}

// End retrieves the end value for the gradient.
//
// The function returns the following values:
//
//    - gfloat: end value for the gradient.
//
func (node *RadialGradientNode) End() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RadialGradientNode")
	_gret := _info.InvokeClassMethod("get_end", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Hradius retrieves the horizonal radius for the gradient.
//
// The function returns the following values:
//
//    - gfloat: horizontal radius for the gradient.
//
func (node *RadialGradientNode) Hradius() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RadialGradientNode")
	_gret := _info.InvokeClassMethod("get_hradius", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *RadialGradientNode) NColorStops() uint {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RadialGradientNode")
	_gret := _info.InvokeClassMethod("get_n_color_stops", _args[:], nil)
	_cret := *(*C.gsize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(*(*C.gsize)(unsafe.Pointer(&_cret)))

	return _gsize
}

// Start retrieves the start value for the gradient.
//
// The function returns the following values:
//
//    - gfloat: start value for the gradient.
//
func (node *RadialGradientNode) Start() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RadialGradientNode")
	_gret := _info.InvokeClassMethod("get_start", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// Vradius retrieves the vertical radius for the gradient.
//
// The function returns the following values:
//
//    - gfloat: vertical radius for the gradient.
//
func (node *RadialGradientNode) Vradius() float32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RadialGradientNode")
	_gret := _info.InvokeClassMethod("get_vradius", _args[:], nil)
	_cret := *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(*(*C.float)(unsafe.Pointer(&_cret)))

	return _gfloat
}

// RenderNode: GskRenderNode is the basic block in a scene graph to be rendered
// using GskRenderer.
//
// Each node has a parent, except the top-level node; each node may have
// children nodes.
//
// Each node has an associated drawing surface, which has the size of the
// rectangle set when creating it.
//
// Render nodes are meant to be transient; once they have been associated to a
// gsk.Renderer it's safe to release any reference you have on them. All
// gsk.RenderNodes are immutable, you can only specify their properties during
// construction.
type RenderNode struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*RenderNode)(nil)
)

// RenderNoder describes types inherited from class RenderNode.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RenderNoder interface {
	coreglib.Objector
	baseRenderNode() *RenderNode
}

var _ RenderNoder = (*RenderNode)(nil)

func wrapRenderNode(obj *coreglib.Object) *RenderNode {
	return &RenderNode{
		Object: obj,
	}
}

func marshalRenderNode(p uintptr) (interface{}, error) {
	return wrapRenderNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (node *RenderNode) baseRenderNode() *RenderNode {
	return node
}

// BaseRenderNode returns the underlying base object.
func BaseRenderNode(obj RenderNoder) *RenderNode {
	return obj.baseRenderNode()
}

// Draw the contents of node to the given cairo context.
//
// Typically, you'll use this function to implement fallback rendering of
// GskRenderNodes on an intermediate Cairo context, instead of using the drawing
// context associated to a GdkSurface's rendering buffer.
//
// For advanced nodes that cannot be supported using Cairo, in particular for
// nodes doing 3D operations, this function may fail.
//
// The function takes the following parameters:
//
//    - cr: cairo context to draw to.
//
func (node *RenderNode) Draw(cr *cairo.Context) {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(cr.Native()))

	_info := girepository.MustFind("Gsk", "RenderNode")
	_info.InvokeClassMethod("draw", _args[:], nil)

	runtime.KeepAlive(node)
	runtime.KeepAlive(cr)
}

// Bounds retrieves the boundaries of the node.
//
// The node will not draw outside of its boundaries.
//
// The function returns the following values:
//
//    - bounds: return location for the boundaries.
//
func (node *RenderNode) Bounds() *graphene.Rect {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RenderNode")
	_info.InvokeClassMethod("get_bounds", _args[:], _outs[:])

	runtime.KeepAlive(node)

	var _bounds *graphene.Rect // out

	_bounds = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_rect_t)(unsafe.Pointer(&_outs[0])))))

	return _bounds
}

// Serialize serializes the node for later deserialization via
// gsk_render_node_deserialize(). No guarantees are made about the format used
// other than that the same version of GTK will be able to deserialize the
// result of a call to gsk_render_node_serialize() and
// gsk_render_node_deserialize() will correctly reject files it cannot open that
// were created with previous versions of GTK.
//
// The intended use of this functions is testing, benchmarking and debugging.
// The format is not meant as a permanent storage format.
//
// The function returns the following values:
//
//    - bytes representing the node.
//
func (node *RenderNode) Serialize() *glib.Bytes {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RenderNode")
	_gret := _info.InvokeClassMethod("serialize", _args[:], nil)
	_cret := *(**C.GBytes)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(*(**C.GBytes)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _bytes
}

// WriteToFile: this function is equivalent to calling
// gsk_render_node_serialize() followed by g_file_set_contents().
//
// See those two functions for details on the arguments.
//
// It is mostly intended for use inside a debugger to quickly dump a render node
// to a file for later inspection.
//
// The function takes the following parameters:
//
//    - filename: file to save it to.
//
func (node *RenderNode) WriteToFile(filename string) error {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**C.char)(unsafe.Pointer(&_args[1])) = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_args[1]))))

	_info := girepository.MustFind("Gsk", "RenderNode")
	_info.InvokeClassMethod("write_to_file", _args[:], nil)

	runtime.KeepAlive(node)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if *(**C.GError)(unsafe.Pointer(&_cerr)) != nil {
		_goerr = gerror.Take(unsafe.Pointer(*(**C.GError)(unsafe.Pointer(&_cerr))))
	}

	return _goerr
}

// RenderNodeDeserialize loads data previously created via
// gsk_render_node_serialize().
//
// For a discussion of the supported format, see that function.
//
// The function takes the following parameters:
//
//    - bytes containing the data.
//    - errorFunc (optional): callback on parsing errors or NULL.
//
// The function returns the following values:
//
//    - renderNode (optional): new GskRenderNode or NULL on error.
//
func RenderNodeDeserialize(bytes *glib.Bytes, errorFunc ParseErrorFunc) RenderNoder {
	var _args [3]girepository.Argument

	*(**C.GBytes)(unsafe.Pointer(&_args[0])) = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	if errorFunc != nil {
		*(*C.gpointer)(unsafe.Pointer(&_args[1])) = (*[0]byte)(C._gotk4_gsk4_ParseErrorFunc)
		_args[2] = C.gpointer(gbox.Assign(errorFunc))
		defer gbox.Delete(uintptr(_args[2]))
	}

	_info := girepository.MustFind("Gsk", "deserialize")
	_gret := _info.InvokeFunction(_args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(bytes)
	runtime.KeepAlive(errorFunc)

	var _renderNode RenderNoder // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		{
			objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(RenderNoder)
				return ok
			})
			rv, ok := casted.(RenderNoder)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
			}
			_renderNode = rv
		}
	}

	return _renderNode
}

// NewRepeatNode creates a GskRenderNode that will repeat the drawing of child
// across the given bounds.
//
// The function takes the following parameters:
//
//    - bounds of the area to be painted.
//    - child to repeat.
//    - childBounds (optional): area of the child to repeat or NULL to use the
//      child's bounds.
//
// The function returns the following values:
//
//    - repeatNode: new GskRenderNode.
//
func NewRepeatNode(bounds *graphene.Rect, child RenderNoder, childBounds *graphene.Rect) *RepeatNode {
	var _args [3]girepository.Argument

	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[0])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if childBounds != nil {
		*(**C.graphene_rect_t)(unsafe.Pointer(&_args[2])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(childBounds)))
	}

	_info := girepository.MustFind("Gsk", "RepeatNode")
	_gret := _info.InvokeClassMethod("new_RepeatNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(bounds)
	runtime.KeepAlive(child)
	runtime.KeepAlive(childBounds)

	var _repeatNode *RepeatNode // out

	_repeatNode = wrapRepeatNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _repeatNode
}

// Child retrieves the child of node.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *RepeatNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RepeatNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ChildBounds retrieves the bounding rectangle of the child of node.
//
// The function returns the following values:
//
//    - rect: bounding rectangle.
//
func (node *RepeatNode) ChildBounds() *graphene.Rect {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RepeatNode")
	_gret := _info.InvokeClassMethod("get_child_bounds", _args[:], nil)
	_cret := *(**C.graphene_rect_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_rect_t)(unsafe.Pointer(&_cret)))))

	return _rect
}

// NewRoundedClipNode creates a GskRenderNode that will clip the child to the
// area given by clip.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - clip to apply.
//
// The function returns the following values:
//
//    - roundedClipNode: new GskRenderNode.
//
func NewRoundedClipNode(child RenderNoder, clip *RoundedRect) *RoundedClipNode {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(clip)))

	_info := girepository.MustFind("Gsk", "RoundedClipNode")
	_gret := _info.InvokeClassMethod("new_RoundedClipNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _roundedClipNode *RoundedClipNode // out

	_roundedClipNode = wrapRoundedClipNode(coreglib.Take(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedClipNode
}

// Child gets the child node that is getting clipped by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting clipped.
//
func (node *RoundedClipNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RoundedClipNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the rounded rectangle used to clip the contents of the node.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *RoundedClipNode) Clip() *RoundedRect {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "RoundedClipNode")
	_gret := _info.InvokeClassMethod("get_clip", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// Child retrieves the child GskRenderNode of the shadow node.
//
// The function returns the following values:
//
//    - renderNode: child render node.
//
func (node *ShadowNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ShadowNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NShadows retrieves the number of shadows in the node.
//
// The function returns the following values:
//
//    - gsize: number of shadows.
//
func (node *ShadowNode) NShadows() uint {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "ShadowNode")
	_gret := _info.InvokeClassMethod("get_n_shadows", _args[:], nil)
	_cret := *(*C.gsize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(*(*C.gsize)(unsafe.Pointer(&_cret)))

	return _gsize
}

// Shadow retrieves the shadow data at the given index i.
//
// The function takes the following parameters:
//
//    - i: given index.
//
// The function returns the following values:
//
//    - shadow data.
//
func (node *ShadowNode) Shadow(i uint) *Shadow {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(*C.gsize)(unsafe.Pointer(&_args[1])) = C.gsize(i)

	_info := girepository.MustFind("Gsk", "ShadowNode")
	_gret := _info.InvokeClassMethod("get_shadow", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)
	runtime.KeepAlive(i)

	var _shadow *Shadow // out

	_shadow = (*Shadow)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _shadow
}

// NewTextNode creates a render node that renders the given glyphs.
//
// Note that color may not be used if the font contains color glyphs.
//
// The function takes the following parameters:
//
//    - font containing the glyphs.
//    - glyphs to render.
//    - color: foreground color to render with.
//    - offset of the baseline.
//
// The function returns the following values:
//
//    - textNode (optional): new GskRenderNode.
//
func NewTextNode(font pango.Fonter, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) *TextNode {
	var _args [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(glyphs)))
	*(**C.void)(unsafe.Pointer(&_args[2])) = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	*(**C.graphene_point_t)(unsafe.Pointer(&_args[3])) = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(offset)))

	_info := girepository.MustFind("Gsk", "TextNode")
	_gret := _info.InvokeClassMethod("new_TextNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(color)
	runtime.KeepAlive(offset)

	var _textNode *TextNode // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_textNode = wrapTextNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	}

	return _textNode
}

// Color retrieves the color used by the text node.
//
// The function returns the following values:
//
//    - rgbA: text color.
//
func (node *TextNode) Color() *gdk.RGBA {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "TextNode")
	_gret := _info.InvokeClassMethod("get_color", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _rgbA
}

// Font returns the font used by the text node.
//
// The function returns the following values:
//
//    - font: font.
//
func (node *TextNode) Font() pango.Fonter {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "TextNode")
	_gret := _info.InvokeClassMethod("get_font", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _font pango.Fonter // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(pango.Fonter)
			return ok
		})
		rv, ok := casted.(pango.Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_font = rv
	}

	return _font
}

// NumGlyphs retrieves the number of glyphs in the text node.
//
// The function returns the following values:
//
//    - guint: number of glyphs.
//
func (node *TextNode) NumGlyphs() uint32 {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "TextNode")
	_gret := _info.InvokeClassMethod("get_num_glyphs", _args[:], nil)
	_cret := *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _guint uint32 // out

	_guint = uint32(*(*C.guint)(unsafe.Pointer(&_cret)))

	return _guint
}

// Offset retrieves the offset applied to the text.
//
// The function returns the following values:
//
//    - point with the horizontal and vertical offsets.
//
func (node *TextNode) Offset() *graphene.Point {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "TextNode")
	_gret := _info.InvokeClassMethod("get_offset", _args[:], nil)
	_cret := *(**C.graphene_point_t)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_point_t)(unsafe.Pointer(&_cret)))))

	return _point
}

// HasColorGlyphs checks whether the text node has color glyphs.
//
// The function returns the following values:
//
//    - ok: TRUE if the text node has color glyphs.
//
func (node *TextNode) HasColorGlyphs() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "TextNode")
	_gret := _info.InvokeClassMethod("has_color_glyphs", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// NewTextureNode creates a GskRenderNode that will render the given texture
// into the area given by bounds.
//
// The function takes the following parameters:
//
//    - texture: GdkTexture.
//    - bounds: rectangle to render the texture into.
//
// The function returns the following values:
//
//    - textureNode: new GskRenderNode.
//
func NewTextureNode(texture gdk.Texturer, bounds *graphene.Rect) *TextureNode {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_info := girepository.MustFind("Gsk", "TextureNode")
	_gret := _info.InvokeClassMethod("new_TextureNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(texture)
	runtime.KeepAlive(bounds)

	var _textureNode *TextureNode // out

	_textureNode = wrapTextureNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _textureNode
}

// Texture retrieves the GdkTexture used when creating this GskRenderNode.
//
// The function returns the following values:
//
//    - texture: GdkTexture.
//
func (node *TextureNode) Texture() gdk.Texturer {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "TextureNode")
	_gret := _info.InvokeClassMethod("get_texture", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _texture gdk.Texturer // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gdk.Texturer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Texturer)
			return ok
		})
		rv, ok := casted.(gdk.Texturer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
		}
		_texture = rv
	}

	return _texture
}

// NewTransformNode creates a GskRenderNode that will transform the given child
// with the given transform.
//
// The function takes the following parameters:
//
//    - child: node to transform.
//    - transform to apply.
//
// The function returns the following values:
//
//    - transformNode: new GskRenderNode.
//
func NewTransformNode(child RenderNoder, transform *Transform) *TransformNode {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(transform)))

	_info := girepository.MustFind("Gsk", "TransformNode")
	_gret := _info.InvokeClassMethod("new_TransformNode", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(transform)

	var _transformNode *TransformNode // out

	_transformNode = wrapTransformNode(coreglib.AssumeOwnership(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _transformNode
}

// Child gets the child node that is getting transformed by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting transformed.
//
func (node *TransformNode) Child() RenderNoder {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "TransformNode")
	_gret := _info.InvokeClassMethod("get_child", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Transform retrieves the GskTransform used by the node.
//
// The function returns the following values:
//
//    - transform: GskTransform.
//
func (node *TransformNode) Transform() *Transform {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	_info := girepository.MustFind("Gsk", "TransformNode")
	_gret := _info.InvokeClassMethod("get_transform", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	C.gsk_transform_ref(*(**C.void)(unsafe.Pointer(&_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// ColorStop: color stop in a gradient node.
//
// An instance of this type is always passed by reference.
type ColorStop struct {
	*colorStop
}

// colorStop is the struct that's finalized.
type colorStop struct {
	native unsafe.Pointer
}

// ParseLocation: location in a parse buffer.
//
// An instance of this type is always passed by reference.
type ParseLocation struct {
	*parseLocation
}

// parseLocation is the struct that's finalized.
type parseLocation struct {
	native unsafe.Pointer
}

// Bytes: offset of the location in the parse buffer, as bytes.
func (p *ParseLocation) Bytes() uint {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("bytes")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	var v uint // out
	v = uint(*(*C.gsize)(unsafe.Pointer(&*valptr)))
	return v
}

// Chars: offset of the location in the parse buffer, as characters.
func (p *ParseLocation) Chars() uint {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("chars")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	var v uint // out
	v = uint(*(*C.gsize)(unsafe.Pointer(&*valptr)))
	return v
}

// Lines: line of the location in the parse buffer.
func (p *ParseLocation) Lines() uint {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("lines")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	var v uint // out
	v = uint(*(*C.gsize)(unsafe.Pointer(&*valptr)))
	return v
}

// LineBytes: position in the line, as bytes.
func (p *ParseLocation) LineBytes() uint {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("line_bytes")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	var v uint // out
	v = uint(*(*C.gsize)(unsafe.Pointer(&*valptr)))
	return v
}

// LineChars: position in the line, as characters.
func (p *ParseLocation) LineChars() uint {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("line_chars")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	var v uint // out
	v = uint(*(*C.gsize)(unsafe.Pointer(&*valptr)))
	return v
}

// Bytes: offset of the location in the parse buffer, as bytes.
func (p *ParseLocation) SetBytes(bytes uint) {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("bytes")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	*(*C.gsize)(unsafe.Pointer(&*valptr)) = C.gsize(bytes)
}

// Chars: offset of the location in the parse buffer, as characters.
func (p *ParseLocation) SetChars(chars uint) {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("chars")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	*(*C.gsize)(unsafe.Pointer(&*valptr)) = C.gsize(chars)
}

// Lines: line of the location in the parse buffer.
func (p *ParseLocation) SetLines(lines uint) {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("lines")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	*(*C.gsize)(unsafe.Pointer(&*valptr)) = C.gsize(lines)
}

// LineBytes: position in the line, as bytes.
func (p *ParseLocation) SetLineBytes(lineBytes uint) {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("line_bytes")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	*(*C.gsize)(unsafe.Pointer(&*valptr)) = C.gsize(lineBytes)
}

// LineChars: position in the line, as characters.
func (p *ParseLocation) SetLineChars(lineChars uint) {
	offset := girepository.MustFind("Gsk", "ParseLocation").StructFieldOffset("line_chars")
	valptr := (*uintptr)(unsafe.Add(p.native, offset))
	*(*C.gsize)(unsafe.Pointer(&*valptr)) = C.gsize(lineChars)
}

// Shadow: shadow parameters in a shadow node.
//
// An instance of this type is always passed by reference.
type Shadow struct {
	*shadow
}

// shadow is the struct that's finalized.
type shadow struct {
	native unsafe.Pointer
}

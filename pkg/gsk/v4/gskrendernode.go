// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gskrendernode.go.
var GTypeRenderNode = coreglib.Type(C.gsk_render_node_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeRenderNode, F: marshalRenderNode},
	})
}

// ParseErrorFunc: type of callback that is called when an error occurs during
// node deserialization.
type ParseErrorFunc func(start, end *ParseLocation, err error)

//export _gotk4_gsk4_ParseErrorFunc
func _gotk4_gsk4_ParseErrorFunc(arg1 *C.GskParseLocation, arg2 *C.GskParseLocation, arg3 *C.GError, arg4 C.gpointer) {
	var fn ParseErrorFunc
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ParseErrorFunc)
	}

	var _start *ParseLocation // out
	var _end *ParseLocation   // out
	var _err error            // out

	_start = (*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	_end = (*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(arg2)))
	_err = gerror.Take(unsafe.Pointer(arg3))

	fn(_start, _end, _err)
}

// BottomChild retrieves the bottom GskRenderNode child of the node.
//
// The function returns the following values:
//
//    - renderNode: bottom child node.
//
func (node *BlendNode) BottomChild() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**BlendNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "BlendNode").InvokeMethod("get_bottom_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// TopChild retrieves the top GskRenderNode child of the node.
//
// The function returns the following values:
//
//    - renderNode: top child node.
//
func (node *BlendNode) TopChild() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**BlendNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "BlendNode").InvokeMethod("get_top_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NewBlurNode creates a render node that blurs the child.
//
// The function takes the following parameters:
//
//    - child node to blur.
//    - radius: blur radius.
//
// The function returns the following values:
//
//    - blurNode: new GskRenderNode.
//
func NewBlurNode(child RenderNoder, radius float32) *BlurNode {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.float // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = C.float(radius)
	*(*RenderNoder)(unsafe.Pointer(&args[0])) = _arg0
	*(*float32)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "BlurNode").InvokeMethod("new_BlurNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(radius)

	var _blurNode *BlurNode // out

	_blurNode = wrapBlurNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blurNode
}

// Child retrieves the child GskRenderNode of the blur node.
//
// The function returns the following values:
//
//    - renderNode: blurred child node.
//
func (node *BlurNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**BlurNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "BlurNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Radius retrieves the blur radius of the node.
//
// The function returns the following values:
//
//    - gfloat: blur radius.
//
func (node *BlurNode) Radius() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**BlurNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "BlurNode").InvokeMethod("get_radius", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Colors retrieves the colors of the border.
//
// The function returns the following values:
//
//    - rgbA: array of 4 RGBA structs for the top, right, bottom and left color
//      of the border.
//
func (node *BorderNode) Colors() *gdk.RGBA {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**BorderNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "BorderNode").InvokeMethod("get_colors", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Outline retrieves the outline of the border.
//
// The function returns the following values:
//
//    - roundedRect: outline of the border.
//
func (node *BorderNode) Outline() *RoundedRect {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**BorderNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "BorderNode").InvokeMethod("get_outline", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Widths retrieves the stroke widths of the border.
//
// The function returns the following values:
//
//    - gfloats: array of 4 floats for the top, right, bottom and left stroke
//      width of the border, respectively.
//
func (node *BorderNode) Widths() [4]float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void  // out
	var _cret *C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**BorderNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "BorderNode").InvokeMethod("get_widths", args[:], nil)
	_cret = *(**C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloats [4]float32 // out

	_gfloats = *(*[4]float32)(unsafe.Pointer(&_cret))

	return _gfloats
}

// NewCairoNode creates a GskRenderNode that will render a cairo surface into
// the area given by bounds.
//
// You can draw to the cairo surface using gsk.CairoNode.GetDrawContext().
//
// The function takes the following parameters:
//
//    - bounds: rectangle to render to.
//
// The function returns the following values:
//
//    - cairoNode: new GskRenderNode.
//
func NewCairoNode(bounds *graphene.Rect) *CairoNode {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))
	*(**graphene.Rect)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "CairoNode").InvokeMethod("new_CairoNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(bounds)

	var _cairoNode *CairoNode // out

	_cairoNode = wrapCairoNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoNode
}

// DrawContext creates a Cairo context for drawing using the surface associated
// to the render node.
//
// If no surface exists yet, a surface will be created optimized for rendering
// to renderer.
//
// The function returns the following values:
//
//    - context: cairo context used for drawing; use cairo_destroy() when done
//      drawing.
//
func (node *CairoNode) DrawContext() *cairo.Context {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**CairoNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "CairoNode").InvokeMethod("get_draw_context", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.cairo_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _context
}

// Surface retrieves the Cairo surface used by the render node.
//
// The function returns the following values:
//
//    - surface: cairo surface.
//
func (node *CairoNode) Surface() *cairo.Surface {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**CairoNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "CairoNode").InvokeMethod("get_surface", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	C.cairo_surface_reference(_cret)
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.void)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// NewClipNode creates a GskRenderNode that will clip the child to the area
// given by clip.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - clip to apply.
//
// The function returns the following values:
//
//    - clipNode: new GskRenderNode.
//
func NewClipNode(child RenderNoder, clip *graphene.Rect) *ClipNode {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(clip)))
	*(*RenderNoder)(unsafe.Pointer(&args[0])) = _arg0
	*(**graphene.Rect)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "ClipNode").InvokeMethod("new_ClipNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _clipNode *ClipNode // out

	_clipNode = wrapClipNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _clipNode
}

// Child gets the child node that is getting clipped by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting clipped.
//
func (node *ClipNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ClipNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ClipNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the clip rectangle for node.
//
// The function returns the following values:
//
//    - rect: clip rectangle.
//
func (node *ClipNode) Clip() *graphene.Rect {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ClipNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ClipNode").InvokeMethod("get_clip", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rect
}

// NewColorMatrixNode creates a GskRenderNode that will drawn the child with
// color_matrix.
//
// In particular, the node will transform the operation
//
//    pixel = color_matrix * pixel + color_offset
//
// for every pixel.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - colorMatrix: matrix to apply.
//    - colorOffset values to add to the color.
//
// The function returns the following values:
//
//    - colorMatrixNode: new GskRenderNode.
//
func NewColorMatrixNode(child RenderNoder, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) *ColorMatrixNode {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(colorMatrix)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(colorOffset)))
	*(*RenderNoder)(unsafe.Pointer(&args[0])) = _arg0
	*(**graphene.Matrix)(unsafe.Pointer(&args[1])) = _arg1
	*(**graphene.Vec4)(unsafe.Pointer(&args[2])) = _arg2

	_gret := girepository.MustFind("Gsk", "ColorMatrixNode").InvokeMethod("new_ColorMatrixNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(colorMatrix)
	runtime.KeepAlive(colorOffset)

	var _colorMatrixNode *ColorMatrixNode // out

	_colorMatrixNode = wrapColorMatrixNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorMatrixNode
}

// Child gets the child node that is getting its colors modified by the given
// node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting its colors modified.
//
func (node *ColorMatrixNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ColorMatrixNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ColorMatrixNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ColorMatrix retrieves the color matrix used by the node.
//
// The function returns the following values:
//
//    - matrix: 4x4 color matrix.
//
func (node *ColorMatrixNode) ColorMatrix() *graphene.Matrix {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ColorMatrixNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ColorMatrixNode").InvokeMethod("get_color_matrix", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _matrix *graphene.Matrix // out

	_matrix = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _matrix
}

// ColorOffset retrieves the color offset used by the node.
//
// The function returns the following values:
//
//    - vec4: color vector.
//
func (node *ColorMatrixNode) ColorOffset() *graphene.Vec4 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ColorMatrixNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ColorMatrixNode").InvokeMethod("get_color_offset", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _vec4 *graphene.Vec4 // out

	_vec4 = (*graphene.Vec4)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _vec4
}

// NewColorNode creates a GskRenderNode that will render the color specified by
// rgba into the area given by bounds.
//
// The function takes the following parameters:
//
//    - rgba: GdkRGBA specifying a color.
//    - bounds: rectangle to render the color into.
//
// The function returns the following values:
//
//    - colorNode: new GskRenderNode.
//
func NewColorNode(rgba *gdk.RGBA, bounds *graphene.Rect) *ColorNode {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(rgba)))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))
	*(**gdk.RGBA)(unsafe.Pointer(&args[0])) = _arg0
	*(**graphene.Rect)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "ColorNode").InvokeMethod("new_ColorNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(rgba)
	runtime.KeepAlive(bounds)

	var _colorNode *ColorNode // out

	_colorNode = wrapColorNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorNode
}

// Color retrieves the color of the given node.
//
// The function returns the following values:
//
//    - rgbA: color of the node.
//
func (node *ColorNode) Color() *gdk.RGBA {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ColorNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ColorNode").InvokeMethod("get_color", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Angle retrieves the angle for the gradient in radians, normalized in [0, 2 *
// PI].
//
// The angle is starting at the top and going clockwise, as expressed in the css
// specification:
//
//    angle = 90 - gsk_conic_gradient_node_get_rotation().
//
// The function returns the following values:
//
//    - gfloat: angle for the gradient.
//
func (node *ConicGradientNode) Angle() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ConicGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ConicGradientNode").InvokeMethod("get_angle", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Center retrieves the center pointer for the gradient.
//
// The function returns the following values:
//
//    - point: center point for the gradient.
//
func (node *ConicGradientNode) Center() *graphene.Point {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ConicGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ConicGradientNode").InvokeMethod("get_center", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *ConicGradientNode) NColorStops() uint {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gsize // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ConicGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ConicGradientNode").InvokeMethod("get_n_color_stops", args[:], nil)
	_cret = *(*C.gsize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Rotation retrieves the rotation for the gradient in degrees.
//
// The function returns the following values:
//
//    - gfloat: rotation for the gradient.
//
func (node *ConicGradientNode) Rotation() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ConicGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ConicGradientNode").InvokeMethod("get_rotation", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NewContainerNode creates a new GskRenderNode instance for holding the given
// children.
//
// The new node will acquire a reference to each of the children.
//
// The function takes the following parameters:
//
//    - children of the node.
//
// The function returns the following values:
//
//    - containerNode: new GskRenderNode.
//
func NewContainerNode(children []RenderNoder) *ContainerNode {
	var args [2]girepository.Argument
	var _arg0 **C.void // out
	var _arg1 C.guint
	var _cret *C.void // in

	_arg1 = (C.guint)(len(children))
	_arg0 = (**C.void)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg0))
	{
		out := unsafe.Slice((**C.void)(_arg0), len(children))
		for i := range children {
			out[i] = (*C.void)(unsafe.Pointer(coreglib.InternObject(children[i]).Native()))
		}
	}
	*(*[]RenderNoder)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ContainerNode").InvokeMethod("new_ContainerNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(children)

	var _containerNode *ContainerNode // out
	_out1 = *(**ContainerNode)(unsafe.Pointer(&outs[1]))

	_containerNode = wrapContainerNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _containerNode
}

// Child gets one of the children of container.
//
// The function takes the following parameters:
//
//    - idx: position of the child to get.
//
// The function returns the following values:
//
//    - renderNode: idx'th child of container.
//
func (node *ContainerNode) Child(idx uint32) RenderNoder {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.guint // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = C.guint(idx)
	*(**ContainerNode)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "ContainerNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren retrieves the number of direct children of node.
//
// The function returns the following values:
//
//    - guint: number of children of the GskRenderNode.
//
func (node *ContainerNode) NChildren() uint32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.guint // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ContainerNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ContainerNode").InvokeMethod("get_n_children", args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _guint uint32 // out

	_guint = uint32(_cret)

	return _guint
}

// NewCrossFadeNode creates a GskRenderNode that will do a cross-fade between
// start and end.
//
// The function takes the following parameters:
//
//    - start node to be drawn.
//    - end: node to be cross_fadeed onto the start node.
//    - progress: how far the fade has progressed from start to end. The value
//      will be clamped to the range [0 ... 1].
//
// The function returns the following values:
//
//    - crossFadeNode: new GskRenderNode.
//
func NewCrossFadeNode(start, end RenderNoder, progress float32) *CrossFadeNode {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.float // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(start).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(end).Native()))
	_arg2 = C.float(progress)
	*(*RenderNoder)(unsafe.Pointer(&args[0])) = _arg0
	*(*RenderNoder)(unsafe.Pointer(&args[1])) = _arg1
	*(*float32)(unsafe.Pointer(&args[2])) = _arg2

	_gret := girepository.MustFind("Gsk", "CrossFadeNode").InvokeMethod("new_CrossFadeNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(progress)

	var _crossFadeNode *CrossFadeNode // out

	_crossFadeNode = wrapCrossFadeNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _crossFadeNode
}

// EndChild retrieves the child GskRenderNode at the end of the cross-fade.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *CrossFadeNode) EndChild() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**CrossFadeNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "CrossFadeNode").InvokeMethod("get_end_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Progress retrieves the progress value of the cross fade.
//
// The function returns the following values:
//
//    - gfloat progress value, between 0 and 1.
//
func (node *CrossFadeNode) Progress() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**CrossFadeNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "CrossFadeNode").InvokeMethod("get_progress", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// StartChild retrieves the child GskRenderNode at the beginning of the
// cross-fade.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *CrossFadeNode) StartChild() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**CrossFadeNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "CrossFadeNode").InvokeMethod("get_start_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NewDebugNode creates a GskRenderNode that will add debug information about
// the given child.
//
// Adding this node has no visual effect.
//
// The function takes the following parameters:
//
//    - child to add debug info for.
//    - message: debug message.
//
// The function returns the following values:
//
//    - debugNode: new GskRenderNode.
//
func NewDebugNode(child RenderNoder, message string) *DebugNode {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(message)))
	*(*RenderNoder)(unsafe.Pointer(&args[0])) = _arg0
	*(*string)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "DebugNode").InvokeMethod("new_DebugNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(message)

	var _debugNode *DebugNode // out

	_debugNode = wrapDebugNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _debugNode
}

// Child gets the child node that is getting drawn by the given node.
//
// The function returns the following values:
//
//    - renderNode: child GskRenderNode.
//
func (node *DebugNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**DebugNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "DebugNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Message gets the debug message that was set on this node.
//
// The function returns the following values:
//
//    - utf8: debug message.
//
func (node *DebugNode) Message() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**DebugNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "DebugNode").InvokeMethod("get_message", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NewGLShaderNode creates a GskRenderNode that will render the given shader
// into the area given by bounds.
//
// The args is a block of data to use for uniform input, as per types and
// offsets defined by the shader. Normally this is generated by
// gsk.GLShader.FormatArgs() or gsk.ShaderArgsBuilder.
//
// See gsk.GLShader for details about how the shader should be written.
//
// All the children will be rendered into textures (if they aren't already
// GskTextureNodes, which will be used directly). These textures will be sent as
// input to the shader.
//
// If the renderer doesn't support GL shaders, or if there is any problem when
// compiling the shader, then the node will draw pink. You should use
// gsk.GLShader.Compile() to ensure the shader will work for the renderer before
// using it.
//
// The function takes the following parameters:
//
//    - shader: GLShader.
//    - bounds: rectangle to render the shader into.
//    - args arguments for the uniforms.
//    - children: array of child nodes, these will be rendered to textures and
//      used as input.
//
// The function returns the following values:
//
//    - glShaderNode: new GskRenderNode.
//
func NewGLShaderNode(shader *GLShader, bounds *graphene.Rect, args *glib.Bytes, children []RenderNoder) *GLShaderNode {
	var args [5]girepository.Argument
	var _arg0 *C.void  // out
	var _arg1 *C.void  // out
	var _arg2 *C.void  // out
	var _arg3 **C.void // out
	var _arg4 C.guint
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(args)))
	_arg4 = (C.guint)(len(children))
	_arg3 = (**C.void)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((**C.void)(_arg3), len(children))
		for i := range children {
			out[i] = (*C.void)(unsafe.Pointer(coreglib.InternObject(children[i]).Native()))
		}
	}
	*(**GLShader)(unsafe.Pointer(&args[0])) = _arg0
	*(**graphene.Rect)(unsafe.Pointer(&args[1])) = _arg1
	*(**glib.Bytes)(unsafe.Pointer(&args[2])) = _arg2
	*(*[]RenderNoder)(unsafe.Pointer(&args[3])) = _arg3

	_gret := girepository.MustFind("Gsk", "GLShaderNode").InvokeMethod("new_GLShaderNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(shader)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(args)
	runtime.KeepAlive(children)

	var _glShaderNode *GLShaderNode // out
	_out4 = *(**GLShaderNode)(unsafe.Pointer(&outs[4]))

	_glShaderNode = wrapGLShaderNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glShaderNode
}

// Args gets args for the node.
//
// The function returns the following values:
//
//    - bytes with the uniform arguments.
//
func (node *GLShaderNode) Args() *glib.Bytes {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**GLShaderNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "GLShaderNode").InvokeMethod("get_args", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_bytes_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Child gets one of the children.
//
// The function takes the following parameters:
//
//    - idx: position of the child to get.
//
// The function returns the following values:
//
//    - renderNode: idx'th child of node.
//
func (node *GLShaderNode) Child(idx uint32) RenderNoder {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.guint // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = C.guint(idx)
	*(**GLShaderNode)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "GLShaderNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren returns the number of children.
//
// The function returns the following values:
//
//    - guint: number of children.
//
func (node *GLShaderNode) NChildren() uint32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.guint // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**GLShaderNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "GLShaderNode").InvokeMethod("get_n_children", args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _guint uint32 // out

	_guint = uint32(_cret)

	return _guint
}

// Shader gets shader code for the node.
//
// The function returns the following values:
//
//    - glShader: GLShader shader.
//
func (node *GLShaderNode) Shader() *GLShader {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**GLShaderNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "GLShaderNode").InvokeMethod("get_shader", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _glShader *GLShader // out

	_glShader = wrapGLShader(coreglib.Take(unsafe.Pointer(_cret)))

	return _glShader
}

// NewInsetShadowNode creates a GskRenderNode that will render an inset shadow
// into the box given by outline.
//
// The function takes the following parameters:
//
//    - outline of the region containing the shadow.
//    - color of the shadow.
//    - dx: horizontal offset of shadow.
//    - dy: vertical offset of shadow.
//    - spread: how far the shadow spreads towards the inside.
//    - blurRadius: how much blur to apply to the shadow.
//
// The function returns the following values:
//
//    - insetShadowNode: new GskRenderNode.
//
func NewInsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) *InsetShadowNode {
	var args [6]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.float // out
	var _arg3 C.float // out
	var _arg4 C.float // out
	var _arg5 C.float // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	_arg2 = C.float(dx)
	_arg3 = C.float(dy)
	_arg4 = C.float(spread)
	_arg5 = C.float(blurRadius)
	*(**RoundedRect)(unsafe.Pointer(&args[0])) = _arg0
	*(**gdk.RGBA)(unsafe.Pointer(&args[1])) = _arg1
	*(*float32)(unsafe.Pointer(&args[2])) = _arg2
	*(*float32)(unsafe.Pointer(&args[3])) = _arg3
	*(*float32)(unsafe.Pointer(&args[4])) = _arg4
	*(*float32)(unsafe.Pointer(&args[5])) = _arg5

	_gret := girepository.MustFind("Gsk", "InsetShadowNode").InvokeMethod("new_InsetShadowNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _insetShadowNode *InsetShadowNode // out

	_insetShadowNode = wrapInsetShadowNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _insetShadowNode
}

// BlurRadius retrieves the blur radius to apply to the shadow.
//
// The function returns the following values:
//
//    - gfloat: blur radius, in pixels.
//
func (node *InsetShadowNode) BlurRadius() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**InsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "InsetShadowNode").InvokeMethod("get_blur_radius", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the inset shadow.
//
// The function returns the following values:
//
//    - rgbA: color of the shadow.
//
func (node *InsetShadowNode) Color() *gdk.RGBA {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**InsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "InsetShadowNode").InvokeMethod("get_color", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Dx retrieves the horizontal offset of the inset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *InsetShadowNode) Dx() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**InsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "InsetShadowNode").InvokeMethod("get_dx", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the inset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *InsetShadowNode) Dy() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**InsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "InsetShadowNode").InvokeMethod("get_dy", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the inset shadow.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *InsetShadowNode) Outline() *RoundedRect {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**InsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "InsetShadowNode").InvokeMethod("get_outline", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads inwards.
//
// The function returns the following values:
//
//    - gfloat: size of the shadow, in pixels.
//
func (node *InsetShadowNode) Spread() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**InsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "InsetShadowNode").InvokeMethod("get_spread", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// End retrieves the final point of the linear gradient.
//
// The function returns the following values:
//
//    - point: final point.
//
func (node *LinearGradientNode) End() *graphene.Point {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**LinearGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "LinearGradientNode").InvokeMethod("get_end", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *LinearGradientNode) NColorStops() uint {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gsize // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**LinearGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "LinearGradientNode").InvokeMethod("get_n_color_stops", args[:], nil)
	_cret = *(*C.gsize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the initial point of the linear gradient.
//
// The function returns the following values:
//
//    - point: initial point.
//
func (node *LinearGradientNode) Start() *graphene.Point {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**LinearGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "LinearGradientNode").InvokeMethod("get_start", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// NewOpacityNode creates a GskRenderNode that will drawn the child with reduced
// opacity.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - opacity to apply.
//
// The function returns the following values:
//
//    - opacityNode: new GskRenderNode.
//
func NewOpacityNode(child RenderNoder, opacity float32) *OpacityNode {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.float // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = C.float(opacity)
	*(*RenderNoder)(unsafe.Pointer(&args[0])) = _arg0
	*(*float32)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "OpacityNode").InvokeMethod("new_OpacityNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(opacity)

	var _opacityNode *OpacityNode // out

	_opacityNode = wrapOpacityNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _opacityNode
}

// Child gets the child node that is getting opacityed by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting opacityed.
//
func (node *OpacityNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**OpacityNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "OpacityNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Opacity gets the transparency factor for an opacity node.
//
// The function returns the following values:
//
//    - gfloat: opacity factor.
//
func (node *OpacityNode) Opacity() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**OpacityNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "OpacityNode").InvokeMethod("get_opacity", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NewOutsetShadowNode creates a GskRenderNode that will render an outset shadow
// around the box given by outline.
//
// The function takes the following parameters:
//
//    - outline of the region surrounded by shadow.
//    - color of the shadow.
//    - dx: horizontal offset of shadow.
//    - dy: vertical offset of shadow.
//    - spread: how far the shadow spreads towards the inside.
//    - blurRadius: how much blur to apply to the shadow.
//
// The function returns the following values:
//
//    - outsetShadowNode: new GskRenderNode.
//
func NewOutsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) *OutsetShadowNode {
	var args [6]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 C.float // out
	var _arg3 C.float // out
	var _arg4 C.float // out
	var _arg5 C.float // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	_arg2 = C.float(dx)
	_arg3 = C.float(dy)
	_arg4 = C.float(spread)
	_arg5 = C.float(blurRadius)
	*(**RoundedRect)(unsafe.Pointer(&args[0])) = _arg0
	*(**gdk.RGBA)(unsafe.Pointer(&args[1])) = _arg1
	*(*float32)(unsafe.Pointer(&args[2])) = _arg2
	*(*float32)(unsafe.Pointer(&args[3])) = _arg3
	*(*float32)(unsafe.Pointer(&args[4])) = _arg4
	*(*float32)(unsafe.Pointer(&args[5])) = _arg5

	_gret := girepository.MustFind("Gsk", "OutsetShadowNode").InvokeMethod("new_OutsetShadowNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _outsetShadowNode *OutsetShadowNode // out

	_outsetShadowNode = wrapOutsetShadowNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _outsetShadowNode
}

// BlurRadius retrieves the blur radius of the shadow.
//
// The function returns the following values:
//
//    - gfloat: blur radius, in pixels.
//
func (node *OutsetShadowNode) BlurRadius() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**OutsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "OutsetShadowNode").InvokeMethod("get_blur_radius", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the outset shadow.
//
// The function returns the following values:
//
//    - rgbA: color.
//
func (node *OutsetShadowNode) Color() *gdk.RGBA {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**OutsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "OutsetShadowNode").InvokeMethod("get_color", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Dx retrieves the horizontal offset of the outset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *OutsetShadowNode) Dx() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**OutsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "OutsetShadowNode").InvokeMethod("get_dx", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the outset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *OutsetShadowNode) Dy() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**OutsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "OutsetShadowNode").InvokeMethod("get_dy", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the outset shadow.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *OutsetShadowNode) Outline() *RoundedRect {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**OutsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "OutsetShadowNode").InvokeMethod("get_outline", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads outwards.
//
// The function returns the following values:
//
//    - gfloat: size of the shadow, in pixels.
//
func (node *OutsetShadowNode) Spread() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**OutsetShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "OutsetShadowNode").InvokeMethod("get_spread", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Center retrieves the center pointer for the gradient.
//
// The function returns the following values:
//
//    - point: center point for the gradient.
//
func (node *RadialGradientNode) Center() *graphene.Point {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RadialGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RadialGradientNode").InvokeMethod("get_center", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// End retrieves the end value for the gradient.
//
// The function returns the following values:
//
//    - gfloat: end value for the gradient.
//
func (node *RadialGradientNode) End() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RadialGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RadialGradientNode").InvokeMethod("get_end", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Hradius retrieves the horizonal radius for the gradient.
//
// The function returns the following values:
//
//    - gfloat: horizontal radius for the gradient.
//
func (node *RadialGradientNode) Hradius() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RadialGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RadialGradientNode").InvokeMethod("get_hradius", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *RadialGradientNode) NColorStops() uint {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gsize // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RadialGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RadialGradientNode").InvokeMethod("get_n_color_stops", args[:], nil)
	_cret = *(*C.gsize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the start value for the gradient.
//
// The function returns the following values:
//
//    - gfloat: start value for the gradient.
//
func (node *RadialGradientNode) Start() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RadialGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RadialGradientNode").InvokeMethod("get_start", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Vradius retrieves the vertical radius for the gradient.
//
// The function returns the following values:
//
//    - gfloat: vertical radius for the gradient.
//
func (node *RadialGradientNode) Vradius() float32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.float // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RadialGradientNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RadialGradientNode").InvokeMethod("get_vradius", args[:], nil)
	_cret = *(*C.float)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RenderNode: GskRenderNode is the basic block in a scene graph to be rendered
// using GskRenderer.
//
// Each node has a parent, except the top-level node; each node may have
// children nodes.
//
// Each node has an associated drawing surface, which has the size of the
// rectangle set when creating it.
//
// Render nodes are meant to be transient; once they have been associated to a
// gsk.Renderer it's safe to release any reference you have on them. All
// gsk.RenderNodes are immutable, you can only specify their properties during
// construction.
type RenderNode struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*RenderNode)(nil)
)

// RenderNoder describes types inherited from class RenderNode.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RenderNoder interface {
	coreglib.Objector
	baseRenderNode() *RenderNode
}

var _ RenderNoder = (*RenderNode)(nil)

func wrapRenderNode(obj *coreglib.Object) *RenderNode {
	return &RenderNode{
		Object: obj,
	}
}

func marshalRenderNode(p uintptr) (interface{}, error) {
	return wrapRenderNode(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (node *RenderNode) baseRenderNode() *RenderNode {
	return node
}

// BaseRenderNode returns the underlying base object.
func BaseRenderNode(obj RenderNoder) *RenderNode {
	return obj.baseRenderNode()
}

// Draw the contents of node to the given cairo context.
//
// Typically, you'll use this function to implement fallback rendering of
// GskRenderNodes on an intermediate Cairo context, instead of using the drawing
// context associated to a GdkSurface's rendering buffer.
//
// For advanced nodes that cannot be supported using Cairo, in particular for
// nodes doing 3D operations, this function may fail.
//
// The function takes the following parameters:
//
//    - cr: cairo context to draw to.
//
func (node *RenderNode) Draw(cr *cairo.Context) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(cr.Native()))
	*(**RenderNode)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gsk", "RenderNode").InvokeMethod("draw", args[:], nil)

	runtime.KeepAlive(node)
	runtime.KeepAlive(cr)
}

// Serialize serializes the node for later deserialization via
// gsk_render_node_deserialize(). No guarantees are made about the format used
// other than that the same version of GTK will be able to deserialize the
// result of a call to gsk_render_node_serialize() and
// gsk_render_node_deserialize() will correctly reject files it cannot open that
// were created with previous versions of GTK.
//
// The intended use of this functions is testing, benchmarking and debugging.
// The format is not meant as a permanent storage format.
//
// The function returns the following values:
//
//    - bytes representing the node.
//
func (node *RenderNode) Serialize() *glib.Bytes {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RenderNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RenderNode").InvokeMethod("serialize", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// WriteToFile: this function is equivalent to calling
// gsk_render_node_serialize() followed by g_file_set_contents().
//
// See those two functions for details on the arguments.
//
// It is mostly intended for use inside a debugger to quickly dump a render node
// to a file for later inspection.
//
// The function takes the following parameters:
//
//    - filename: file to save it to.
//
func (node *RenderNode) WriteToFile(filename string) error {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cerr *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**RenderNode)(unsafe.Pointer(&args[1])) = _arg1

	girepository.MustFind("Gsk", "RenderNode").InvokeMethod("write_to_file", args[:], nil)

	runtime.KeepAlive(node)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// NewRepeatNode creates a GskRenderNode that will repeat the drawing of child
// across the given bounds.
//
// The function takes the following parameters:
//
//    - bounds of the area to be painted.
//    - child to repeat.
//    - childBounds (optional): area of the child to repeat or NULL to use the
//      child's bounds.
//
// The function returns the following values:
//
//    - repeatNode: new GskRenderNode.
//
func NewRepeatNode(bounds *graphene.Rect, child RenderNoder, childBounds *graphene.Rect) *RepeatNode {
	var args [3]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg1 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if childBounds != nil {
		_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(childBounds)))
	}
	*(**graphene.Rect)(unsafe.Pointer(&args[0])) = _arg0
	*(*RenderNoder)(unsafe.Pointer(&args[1])) = _arg1
	*(**graphene.Rect)(unsafe.Pointer(&args[2])) = _arg2

	_gret := girepository.MustFind("Gsk", "RepeatNode").InvokeMethod("new_RepeatNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(bounds)
	runtime.KeepAlive(child)
	runtime.KeepAlive(childBounds)

	var _repeatNode *RepeatNode // out

	_repeatNode = wrapRepeatNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatNode
}

// Child retrieves the child of node.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *RepeatNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RepeatNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RepeatNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ChildBounds retrieves the bounding rectangle of the child of node.
//
// The function returns the following values:
//
//    - rect: bounding rectangle.
//
func (node *RepeatNode) ChildBounds() *graphene.Rect {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RepeatNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RepeatNode").InvokeMethod("get_child_bounds", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rect
}

// NewRoundedClipNode creates a GskRenderNode that will clip the child to the
// area given by clip.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - clip to apply.
//
// The function returns the following values:
//
//    - roundedClipNode: new GskRenderNode.
//
func NewRoundedClipNode(child RenderNoder, clip *RoundedRect) *RoundedClipNode {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(clip)))
	*(*RenderNoder)(unsafe.Pointer(&args[0])) = _arg0
	*(**RoundedRect)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "RoundedClipNode").InvokeMethod("new_RoundedClipNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _roundedClipNode *RoundedClipNode // out

	_roundedClipNode = wrapRoundedClipNode(coreglib.Take(unsafe.Pointer(_cret)))

	return _roundedClipNode
}

// Child gets the child node that is getting clipped by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting clipped.
//
func (node *RoundedClipNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RoundedClipNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RoundedClipNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the rounded rectangle used to clip the contents of the node.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *RoundedClipNode) Clip() *RoundedRect {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**RoundedClipNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "RoundedClipNode").InvokeMethod("get_clip", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Child retrieves the child GskRenderNode of the shadow node.
//
// The function returns the following values:
//
//    - renderNode: child render node.
//
func (node *ShadowNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ShadowNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NShadows retrieves the number of shadows in the node.
//
// The function returns the following values:
//
//    - gsize: number of shadows.
//
func (node *ShadowNode) NShadows() uint {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.gsize // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**ShadowNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "ShadowNode").InvokeMethod("get_n_shadows", args[:], nil)
	_cret = *(*C.gsize)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Shadow retrieves the shadow data at the given index i.
//
// The function takes the following parameters:
//
//    - i: given index.
//
// The function returns the following values:
//
//    - shadow data.
//
func (node *ShadowNode) Shadow(i uint) *Shadow {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 C.gsize // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	_arg1 = C.gsize(i)
	*(**ShadowNode)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "ShadowNode").InvokeMethod("get_shadow", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)
	runtime.KeepAlive(i)

	var _shadow *Shadow // out

	_shadow = (*Shadow)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _shadow
}

// NewTextNode creates a render node that renders the given glyphs.
//
// Note that color may not be used if the font contains color glyphs.
//
// The function takes the following parameters:
//
//    - font containing the glyphs.
//    - glyphs to render.
//    - color: foreground color to render with.
//    - offset of the baseline.
//
// The function returns the following values:
//
//    - textNode (optional): new GskRenderNode.
//
func NewTextNode(font pango.Fonter, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) *TextNode {
	var args [4]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _arg2 *C.void // out
	var _arg3 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(font).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg2 = (*C.void)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = (*C.void)(gextras.StructNative(unsafe.Pointer(offset)))
	*(*pango.Fonter)(unsafe.Pointer(&args[0])) = _arg0
	*(**pango.GlyphString)(unsafe.Pointer(&args[1])) = _arg1
	*(**gdk.RGBA)(unsafe.Pointer(&args[2])) = _arg2
	*(**graphene.Point)(unsafe.Pointer(&args[3])) = _arg3

	_gret := girepository.MustFind("Gsk", "TextNode").InvokeMethod("new_TextNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(font)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(color)
	runtime.KeepAlive(offset)

	var _textNode *TextNode // out

	if _cret != nil {
		_textNode = wrapTextNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _textNode
}

// Color retrieves the color used by the text node.
//
// The function returns the following values:
//
//    - rgbA: text color.
//
func (node *TextNode) Color() *gdk.RGBA {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**TextNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "TextNode").InvokeMethod("get_color", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Font returns the font used by the text node.
//
// The function returns the following values:
//
//    - font: font.
//
func (node *TextNode) Font() pango.Fonter {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**TextNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "TextNode").InvokeMethod("get_font", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _font pango.Fonter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(pango.Fonter)
			return ok
		})
		rv, ok := casted.(pango.Fonter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.Fonter")
		}
		_font = rv
	}

	return _font
}

// NumGlyphs retrieves the number of glyphs in the text node.
//
// The function returns the following values:
//
//    - guint: number of glyphs.
//
func (node *TextNode) NumGlyphs() uint32 {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret C.guint // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**TextNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "TextNode").InvokeMethod("get_num_glyphs", args[:], nil)
	_cret = *(*C.guint)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _guint uint32 // out

	_guint = uint32(_cret)

	return _guint
}

// Offset retrieves the offset applied to the text.
//
// The function returns the following values:
//
//    - point with the horizontal and vertical offsets.
//
func (node *TextNode) Offset() *graphene.Point {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**TextNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "TextNode").InvokeMethod("get_offset", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// HasColorGlyphs checks whether the text node has color glyphs.
//
// The function returns the following values:
//
//    - ok: TRUE if the text node has color glyphs.
//
func (node *TextNode) HasColorGlyphs() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**TextNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "TextNode").InvokeMethod("has_color_glyphs", args[:], nil)
	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewTextureNode creates a GskRenderNode that will render the given texture
// into the area given by bounds.
//
// The function takes the following parameters:
//
//    - texture: GdkTexture.
//    - bounds: rectangle to render the texture into.
//
// The function returns the following values:
//
//    - textureNode: new GskRenderNode.
//
func NewTextureNode(texture gdk.Texturer, bounds *graphene.Rect) *TextureNode {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(bounds)))
	*(*gdk.Texturer)(unsafe.Pointer(&args[0])) = _arg0
	*(**graphene.Rect)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "TextureNode").InvokeMethod("new_TextureNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(texture)
	runtime.KeepAlive(bounds)

	var _textureNode *TextureNode // out

	_textureNode = wrapTextureNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textureNode
}

// Texture retrieves the GdkTexture used when creating this GskRenderNode.
//
// The function returns the following values:
//
//    - texture: GdkTexture.
//
func (node *TextureNode) Texture() gdk.Texturer {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**TextureNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "TextureNode").InvokeMethod("get_texture", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _texture gdk.Texturer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Texturer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Texturer)
			return ok
		})
		rv, ok := casted.(gdk.Texturer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Texturer")
		}
		_texture = rv
	}

	return _texture
}

// NewTransformNode creates a GskRenderNode that will transform the given child
// with the given transform.
//
// The function takes the following parameters:
//
//    - child: node to transform.
//    - transform to apply.
//
// The function returns the following values:
//
//    - transformNode: new GskRenderNode.
//
func NewTransformNode(child RenderNoder, transform *Transform) *TransformNode {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(transform)))
	*(*RenderNoder)(unsafe.Pointer(&args[0])) = _arg0
	*(**Transform)(unsafe.Pointer(&args[1])) = _arg1

	_gret := girepository.MustFind("Gsk", "TransformNode").InvokeMethod("new_TransformNode", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(child)
	runtime.KeepAlive(transform)

	var _transformNode *TransformNode // out

	_transformNode = wrapTransformNode(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _transformNode
}

// Child gets the child node that is getting transformed by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting transformed.
//
func (node *TransformNode) Child() RenderNoder {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**TransformNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "TransformNode").InvokeMethod("get_child", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(RenderNoder)
			return ok
		})
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Transform retrieves the GskTransform used by the node.
//
// The function returns the following values:
//
//    - transform: GskTransform.
//
func (node *TransformNode) Transform() *Transform {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(node).Native()))
	*(**TransformNode)(unsafe.Pointer(&args[0])) = _arg0

	_gret := girepository.MustFind("Gsk", "TransformNode").InvokeMethod("get_transform", args[:], nil)
	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(node)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// ColorStop: color stop in a gradient node.
//
// An instance of this type is always passed by reference.
type ColorStop struct {
	*colorStop
}

// colorStop is the struct that's finalized.
type colorStop struct {
	native *C.GskColorStop
}

// ParseLocation: location in a parse buffer.
//
// An instance of this type is always passed by reference.
type ParseLocation struct {
	*parseLocation
}

// parseLocation is the struct that's finalized.
type parseLocation struct {
	native *C.GskParseLocation
}

// NewParseLocation creates a new ParseLocation instance from the given
// fields.
func NewParseLocation(bytes, chars, lines, lineBytes, lineChars uint) ParseLocation {
	var f0 C.gsize // out
	f0 = C.gsize(bytes)
	var f1 C.gsize // out
	f1 = C.gsize(chars)
	var f2 C.gsize // out
	f2 = C.gsize(lines)
	var f3 C.gsize // out
	f3 = C.gsize(lineBytes)
	var f4 C.gsize // out
	f4 = C.gsize(lineChars)

	v := C.GskParseLocation{
		bytes:      f0,
		chars:      f1,
		lines:      f2,
		line_bytes: f3,
		line_chars: f4,
	}

	return *(*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Bytes: offset of the location in the parse buffer, as bytes.
func (p *ParseLocation) Bytes() uint {
	var v uint // out
	v = uint(p.native.bytes)
	return v
}

// Chars: offset of the location in the parse buffer, as characters.
func (p *ParseLocation) Chars() uint {
	var v uint // out
	v = uint(p.native.chars)
	return v
}

// Lines: line of the location in the parse buffer.
func (p *ParseLocation) Lines() uint {
	var v uint // out
	v = uint(p.native.lines)
	return v
}

// LineBytes: position in the line, as bytes.
func (p *ParseLocation) LineBytes() uint {
	var v uint // out
	v = uint(p.native.line_bytes)
	return v
}

// LineChars: position in the line, as characters.
func (p *ParseLocation) LineChars() uint {
	var v uint // out
	v = uint(p.native.line_chars)
	return v
}

// Shadow: shadow parameters in a shadow node.
//
// An instance of this type is always passed by reference.
type Shadow struct {
	*shadow
}

// shadow is the struct that's finalized.
type shadow struct {
	native *C.GskShadow
}

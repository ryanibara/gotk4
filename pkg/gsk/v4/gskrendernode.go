// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"reflect"
	"runtime"
	"sync"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gsk/gsk.h>
// void _gotk4_gsk4_ParseErrorFunc(GskParseLocation*, GskParseLocation*, GError*, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_render_node_get_type()), F: marshalRenderNoder},
	})
}

// ParseErrorFunc: type of callback that is called when an error occurs during
// node deserialization.
type ParseErrorFunc func(start, end *ParseLocation, err error)

//export _gotk4_gsk4_ParseErrorFunc
func _gotk4_gsk4_ParseErrorFunc(arg0 *C.GskParseLocation, arg1 *C.GskParseLocation, arg2 *C.GError, arg3 C.gpointer) {
	v := gbox.Get(uintptr(arg3))
	if v == nil {
		panic(`callback not found`)
	}

	var start *ParseLocation // out
	var end *ParseLocation   // out
	var err error            // out

	start = (*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(arg0)))
	end = (*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	err = gerror.Take(unsafe.Pointer(arg2))

	fn := v.(ParseErrorFunc)
	fn(start, end, err)
}

// NewBlendNode creates a GskRenderNode that will use blend_mode to blend the
// top node onto the bottom node.
//
// The function takes the following parameters:
//
//    - bottom node to be drawn.
//    - top: node to be blended onto the bottom node.
//    - blendMode: blend mode to use.
//
// The function returns the following values:
//
//    - blendNode: new GskRenderNode.
//
func NewBlendNode(bottom, top RenderNoder, blendMode BlendMode) *BlendNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.GskBlendMode   // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(bottom.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(top.Native()))
	_arg3 = C.GskBlendMode(blendMode)

	_cret = C.gsk_blend_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bottom)
	runtime.KeepAlive(top)
	runtime.KeepAlive(blendMode)

	var _blendNode *BlendNode // out

	_blendNode = wrapBlendNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blendNode
}

// BlendMode retrieves the blend mode used by node.
//
// The function returns the following values:
//
//    - blendMode: blend mode.
//
func (node *BlendNode) BlendMode() BlendMode {
	var _arg0 *C.GskRenderNode // out
	var _cret C.GskBlendMode   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blend_node_get_blend_mode(_arg0)
	runtime.KeepAlive(node)

	var _blendMode BlendMode // out

	_blendMode = BlendMode(_cret)

	return _blendMode
}

// BottomChild retrieves the bottom GskRenderNode child of the node.
//
// The function returns the following values:
//
//    - renderNode: bottom child node.
//
func (node *BlendNode) BottomChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blend_node_get_bottom_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// TopChild retrieves the top GskRenderNode child of the node.
//
// The function returns the following values:
//
//    - renderNode: top child node.
//
func (node *BlendNode) TopChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blend_node_get_top_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NewBlurNode creates a render node that blurs the child.
//
// The function takes the following parameters:
//
//    - child node to blur.
//    - radius: blur radius.
//
// The function returns the following values:
//
//    - blurNode: new GskRenderNode.
//
func NewBlurNode(child RenderNoder, radius float32) *BlurNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = C.float(radius)

	_cret = C.gsk_blur_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(radius)

	var _blurNode *BlurNode // out

	_blurNode = wrapBlurNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blurNode
}

// Child retrieves the child GskRenderNode of the blur node.
//
// The function returns the following values:
//
//    - renderNode: blurred child node.
//
func (node *BlurNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blur_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Radius retrieves the blur radius of the node.
//
// The function returns the following values:
//
//    - gfloat: blur radius.
//
func (node *BlurNode) Radius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blur_node_get_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NewBorderNode creates a GskRenderNode that will stroke a border rectangle
// inside the given outline.
//
// The 4 sides of the border can have different widths and colors.
//
// The function takes the following parameters:
//
//    - outline describing the outline of the border.
//    - borderWidth: stroke width of the border on the top, right, bottom and
//      left side respectively.
//    - borderColor: color used on the top, right, bottom and left side.
//
// The function returns the following values:
//
//    - borderNode: new GskRenderNode.
//
func NewBorderNode(outline *RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) *BorderNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.float          // out
	var _arg3 *C.GdkRGBA        // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	{
		var out [4]C.GdkRGBA
		_arg3 = &out[0]
		for i := 0; i < 4; i++ {
			out[i] = *(*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer((&borderColor[i]))))
		}
	}

	_cret = C.gsk_border_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(borderWidth)
	runtime.KeepAlive(borderColor)

	var _borderNode *BorderNode // out

	_borderNode = wrapBorderNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _borderNode
}

// Colors retrieves the colors of the border.
//
// The function returns the following values:
//
//    - rgbA: array of 4 RGBA structs for the top, right, bottom and left color
//      of the border.
//
func (node *BorderNode) Colors() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_border_node_get_colors(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Outline retrieves the outline of the border.
//
// The function returns the following values:
//
//    - roundedRect: outline of the border.
//
func (node *BorderNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_border_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Widths retrieves the stroke widths of the border.
//
// The function returns the following values:
//
//    - gfloats: array of 4 floats for the top, right, bottom and left stroke
//      width of the border, respectively.
//
func (node *BorderNode) Widths() [4]float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.float         // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_border_node_get_widths(_arg0)
	runtime.KeepAlive(node)

	var _gfloats [4]float32 // out

	_gfloats = *(*[4]float32)(unsafe.Pointer(&_cret))

	return _gfloats
}

// NewCairoNode creates a GskRenderNode that will render a cairo surface into
// the area given by bounds.
//
// You can draw to the cairo surface using gsk.CairoNode.GetDrawContext().
//
// The function takes the following parameters:
//
//    - bounds: rectangle to render to.
//
// The function returns the following values:
//
//    - cairoNode: new GskRenderNode.
//
func NewCairoNode(bounds *graphene.Rect) *CairoNode {
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_cairo_node_new(_arg1)
	runtime.KeepAlive(bounds)

	var _cairoNode *CairoNode // out

	_cairoNode = wrapCairoNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoNode
}

// DrawContext creates a Cairo context for drawing using the surface associated
// to the render node.
//
// If no surface exists yet, a surface will be created optimized for rendering
// to renderer.
//
// The function returns the following values:
//
//    - context: cairo context used for drawing; use cairo_destroy() when done
//      drawing.
//
func (node *CairoNode) DrawContext() *cairo.Context {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.cairo_t       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cairo_node_get_draw_context(_arg0)
	runtime.KeepAlive(node)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	return _context
}

// Surface retrieves the Cairo surface used by the render node.
//
// The function returns the following values:
//
//    - surface: cairo surface.
//
func (node *CairoNode) Surface() *cairo.Surface {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cairo_node_get_surface(_arg0)
	runtime.KeepAlive(node)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	C.cairo_surface_reference(_cret)
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// NewClipNode creates a GskRenderNode that will clip the child to the area
// given by clip.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - clip to apply.
//
// The function returns the following values:
//
//    - clipNode: new GskRenderNode.
//
func NewClipNode(child RenderNoder, clip *graphene.Rect) *ClipNode {
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(clip)))

	_cret = C.gsk_clip_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _clipNode *ClipNode // out

	_clipNode = wrapClipNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _clipNode
}

// Child gets the child node that is getting clipped by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting clipped.
//
func (node *ClipNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_clip_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the clip rectangle for node.
//
// The function returns the following values:
//
//    - rect: clip rectangle.
//
func (node *ClipNode) Clip() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_clip_node_get_clip(_arg0)
	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rect
}

// NewColorMatrixNode creates a GskRenderNode that will drawn the child with
// color_matrix.
//
// In particular, the node will transform the operation
//
//    pixel = color_matrix * pixel + color_offset
//
// for every pixel.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - colorMatrix: matrix to apply.
//    - colorOffset values to add to the color.
//
// The function returns the following values:
//
//    - colorMatrixNode: new GskRenderNode.
//
func NewColorMatrixNode(child RenderNoder, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) *ColorMatrixNode {
	var _arg1 *C.GskRenderNode     // out
	var _arg2 *C.graphene_matrix_t // out
	var _arg3 *C.graphene_vec4_t   // out
	var _cret *C.GskRenderNode     // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_matrix_t)(gextras.StructNative(unsafe.Pointer(colorMatrix)))
	_arg3 = (*C.graphene_vec4_t)(gextras.StructNative(unsafe.Pointer(colorOffset)))

	_cret = C.gsk_color_matrix_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(child)
	runtime.KeepAlive(colorMatrix)
	runtime.KeepAlive(colorOffset)

	var _colorMatrixNode *ColorMatrixNode // out

	_colorMatrixNode = wrapColorMatrixNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorMatrixNode
}

// Child gets the child node that is getting its colors modified by the given
// node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting its colors modified.
//
func (node *ColorMatrixNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_color_matrix_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ColorMatrix retrieves the color matrix used by the node.
//
// The function returns the following values:
//
//    - matrix: 4x4 color matrix.
//
func (node *ColorMatrixNode) ColorMatrix() *graphene.Matrix {
	var _arg0 *C.GskRenderNode     // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_color_matrix_node_get_color_matrix(_arg0)
	runtime.KeepAlive(node)

	var _matrix *graphene.Matrix // out

	_matrix = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _matrix
}

// ColorOffset retrieves the color offset used by the node.
//
// The function returns the following values:
//
//    - vec4: color vector.
//
func (node *ColorMatrixNode) ColorOffset() *graphene.Vec4 {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_color_matrix_node_get_color_offset(_arg0)
	runtime.KeepAlive(node)

	var _vec4 *graphene.Vec4 // out

	_vec4 = (*graphene.Vec4)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _vec4
}

// NewColorNode creates a GskRenderNode that will render the color specified by
// rgba into the area given by bounds.
//
// The function takes the following parameters:
//
//    - rgba: GdkRGBA specifying a color.
//    - bounds: rectangle to render the color into.
//
// The function returns the following values:
//
//    - colorNode: new GskRenderNode.
//
func NewColorNode(rgba *gdk.RGBA, bounds *graphene.Rect) *ColorNode {
	var _arg1 *C.GdkRGBA         // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_color_node_new(_arg1, _arg2)
	runtime.KeepAlive(rgba)
	runtime.KeepAlive(bounds)

	var _colorNode *ColorNode // out

	_colorNode = wrapColorNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorNode
}

// Color retrieves the color of the given node.
//
// The function returns the following values:
//
//    - rgbA: color of the node.
//
func (node *ColorNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_color_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// NewConicGradientNode creates a GskRenderNode that draws a conic gradient.
//
// The conic gradient starts around center in the direction of rotation. A
// rotation of 0 means that the gradient points up. Color stops are then added
// clockwise.
//
// The function takes the following parameters:
//
//    - bounds of the node.
//    - center of the gradient.
//    - rotation of the gradient in degrees.
//    - colorStops: pointer to an array of GskColorStop defining the gradient.
//      The offsets of all color stops must be increasing. The first stop's
//      offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//    - conicGradientNode: new GskRenderNode.
//
func NewConicGradientNode(bounds *graphene.Rect, center *graphene.Point, rotation float32, colorStops []ColorStop) *ConicGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(rotation)
	_arg5 = (C.gsize)(len(colorStops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_conic_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(rotation)
	runtime.KeepAlive(colorStops)

	var _conicGradientNode *ConicGradientNode // out

	_conicGradientNode = wrapConicGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _conicGradientNode
}

// Angle retrieves the angle for the gradient in radians, normalized in [0, 2 *
// PI].
//
// The angle is starting at the top and going clockwise, as expressed in the css
// specification:
//
//    angle = 90 - gsk_conic_gradient_node_get_rotation().
//
// The function returns the following values:
//
//    - gfloat: angle for the gradient.
//
func (node *ConicGradientNode) Angle() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_angle(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Center retrieves the center pointer for the gradient.
//
// The function returns the following values:
//
//    - point: center point for the gradient.
//
func (node *ConicGradientNode) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_center(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// ColorStops retrieves the color stops in the gradient.
//
// The function returns the following values:
//
//    - colorStops: color stops in the gradient.
//
func (node *ConicGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	{
		src := unsafe.Slice(_cret, _arg1)
		_colorStops = make([]ColorStop, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_colorStops[i] = *(*ColorStop)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _colorStops
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *ConicGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Rotation retrieves the rotation for the gradient in degrees.
//
// The function returns the following values:
//
//    - gfloat: rotation for the gradient.
//
func (node *ConicGradientNode) Rotation() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_rotation(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NewContainerNode creates a new GskRenderNode instance for holding the given
// children.
//
// The new node will acquire a reference to each of the children.
//
// The function takes the following parameters:
//
//    - children of the node.
//
// The function returns the following values:
//
//    - containerNode: new GskRenderNode.
//
func NewContainerNode(children []RenderNoder) *ContainerNode {
	var _arg1 **C.GskRenderNode // out
	var _arg2 C.guint
	var _cret *C.GskRenderNode // in

	_arg2 = (C.guint)(len(children))
	_arg1 = (**C.GskRenderNode)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GskRenderNode)(_arg1), len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(children[i].Native()))
		}
	}

	_cret = C.gsk_container_node_new(_arg1, _arg2)
	runtime.KeepAlive(children)

	var _containerNode *ContainerNode // out

	_containerNode = wrapContainerNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _containerNode
}

// Child gets one of the children of container.
//
// The function takes the following parameters:
//
//    - idx: position of the child to get.
//
// The function returns the following values:
//
//    - renderNode: idx'th child of container.
//
func (node *ContainerNode) Child(idx uint) RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_container_node_get_child(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren retrieves the number of direct children of node.
//
// The function returns the following values:
//
//    - guint: number of children of the GskRenderNode.
//
func (node *ContainerNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_container_node_get_n_children(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// NewCrossFadeNode creates a GskRenderNode that will do a cross-fade between
// start and end.
//
// The function takes the following parameters:
//
//    - start node to be drawn.
//    - end: node to be cross_fadeed onto the start node.
//    - progress: how far the fade has progressed from start to end. The value
//      will be clamped to the range [0 ... 1].
//
// The function returns the following values:
//
//    - crossFadeNode: new GskRenderNode.
//
func NewCrossFadeNode(start, end RenderNoder, progress float32) *CrossFadeNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(end.Native()))
	_arg3 = C.float(progress)

	_cret = C.gsk_cross_fade_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(progress)

	var _crossFadeNode *CrossFadeNode // out

	_crossFadeNode = wrapCrossFadeNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _crossFadeNode
}

// EndChild retrieves the child GskRenderNode at the end of the cross-fade.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *CrossFadeNode) EndChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cross_fade_node_get_end_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Progress retrieves the progress value of the cross fade.
//
// The function returns the following values:
//
//    - gfloat progress value, between 0 and 1.
//
func (node *CrossFadeNode) Progress() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cross_fade_node_get_progress(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// StartChild retrieves the child GskRenderNode at the beginning of the
// cross-fade.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *CrossFadeNode) StartChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cross_fade_node_get_start_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NewDebugNode creates a GskRenderNode that will add debug information about
// the given child.
//
// Adding this node has no visual effect.
//
// The function takes the following parameters:
//
//    - child to add debug info for.
//    - message: debug message.
//
// The function returns the following values:
//
//    - debugNode: new GskRenderNode.
//
func NewDebugNode(child RenderNoder, message string) *DebugNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.char          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(message)))

	_cret = C.gsk_debug_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(message)

	var _debugNode *DebugNode // out

	_debugNode = wrapDebugNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _debugNode
}

// Child gets the child node that is getting drawn by the given node.
//
// The function returns the following values:
//
//    - renderNode: child GskRenderNode.
//
func (node *DebugNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_debug_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Message gets the debug message that was set on this node.
//
// The function returns the following values:
//
//    - utf8: debug message.
//
func (node *DebugNode) Message() string {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.char          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_debug_node_get_message(_arg0)
	runtime.KeepAlive(node)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NewGLShaderNode creates a GskRenderNode that will render the given shader
// into the area given by bounds.
//
// The args is a block of data to use for uniform input, as per types and
// offsets defined by the shader. Normally this is generated by
// gsk.GLShader.FormatArgs() or gsk.ShaderArgsBuilder.
//
// See gsk.GLShader for details about how the shader should be written.
//
// All the children will be rendered into textures (if they aren't already
// GskTextureNodes, which will be used directly). These textures will be sent as
// input to the shader.
//
// If the renderer doesn't support GL shaders, or if there is any problem when
// compiling the shader, then the node will draw pink. You should use
// gsk.GLShader.Compile() to ensure the shader will work for the renderer before
// using it.
//
// The function takes the following parameters:
//
//    - shader: GLShader.
//    - bounds: rectangle to render the shader into.
//    - args arguments for the uniforms.
//    - children: array of child nodes, these will be rendered to textures and
//      used as input.
//
// The function returns the following values:
//
//    - glShaderNode: new GskRenderNode.
//
func NewGLShaderNode(shader *GLShader, bounds *graphene.Rect, args *glib.Bytes, children []RenderNoder) *GLShaderNode {
	var _arg1 *C.GskGLShader     // out
	var _arg2 *C.graphene_rect_t // out
	var _arg3 *C.GBytes          // out
	var _arg4 **C.GskRenderNode  // out
	var _arg5 C.guint
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskGLShader)(unsafe.Pointer(shader.Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg3 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg5 = (C.guint)(len(children))
	_arg4 = (**C.GskRenderNode)(C.calloc(C.size_t(len(children)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((**C.GskRenderNode)(_arg4), len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(children[i].Native()))
		}
	}

	_cret = C.gsk_gl_shader_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(args)
	runtime.KeepAlive(children)

	var _glShaderNode *GLShaderNode // out

	_glShaderNode = wrapGLShaderNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glShaderNode
}

// Args gets args for the node.
//
// The function returns the following values:
//
//    - bytes with the uniform arguments.
//
func (node *GLShaderNode) Args() *glib.Bytes {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GBytes        // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_gl_shader_node_get_args(_arg0)
	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_bytes_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Child gets one of the children.
//
// The function takes the following parameters:
//
//    - idx: position of the child to get.
//
// The function returns the following values:
//
//    - renderNode: idx'th child of node.
//
func (node *GLShaderNode) Child(idx uint) RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_gl_shader_node_get_child(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren returns the number of children.
//
// The function returns the following values:
//
//    - guint: number of children.
//
func (node *GLShaderNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_gl_shader_node_get_n_children(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Shader gets shader code for the node.
//
// The function returns the following values:
//
//    - glShader: GLShader shader.
//
func (node *GLShaderNode) Shader() *GLShader {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskGLShader   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_gl_shader_node_get_shader(_arg0)
	runtime.KeepAlive(node)

	var _glShader *GLShader // out

	_glShader = wrapGLShader(externglib.Take(unsafe.Pointer(_cret)))

	return _glShader
}

// NewInsetShadowNode creates a GskRenderNode that will render an inset shadow
// into the box given by outline.
//
// The function takes the following parameters:
//
//    - outline of the region containing the shadow.
//    - color of the shadow.
//    - dx: horizontal offset of shadow.
//    - dy: vertical offset of shadow.
//    - spread: how far the shadow spreads towards the inside.
//    - blurRadius: how much blur to apply to the shadow.
//
// The function returns the following values:
//
//    - insetShadowNode: new GskRenderNode.
//
func NewInsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) *InsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_inset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _insetShadowNode *InsetShadowNode // out

	_insetShadowNode = wrapInsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _insetShadowNode
}

// BlurRadius retrieves the blur radius to apply to the shadow.
//
// The function returns the following values:
//
//    - gfloat: blur radius, in pixels.
//
func (node *InsetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_blur_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the inset shadow.
//
// The function returns the following values:
//
//    - rgbA: color of the shadow.
//
func (node *InsetShadowNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Dx retrieves the horizontal offset of the inset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *InsetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_dx(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the inset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *InsetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_dy(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the inset shadow.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *InsetShadowNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads inwards.
//
// The function returns the following values:
//
//    - gfloat: size of the shadow, in pixels.
//
func (node *InsetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_spread(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NewLinearGradientNode creates a GskRenderNode that will create a linear
// gradient from the given points and color stops, and render that into the area
// given by bounds.
//
// The function takes the following parameters:
//
//    - bounds: rectangle to render the linear gradient into.
//    - start: point at which the linear gradient will begin.
//    - end: point at which the linear gradient will finish.
//    - colorStops: pointer to an array of GskColorStop defining the gradient.
//      The offsets of all color stops must be increasing. The first stop's
//      offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//    - linearGradientNode: new GskRenderNode.
//
func NewLinearGradientNode(bounds *graphene.Rect, start, end *graphene.Point, colorStops []ColorStop) *LinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(end)))
	_arg5 = (C.gsize)(len(colorStops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _linearGradientNode *LinearGradientNode // out

	_linearGradientNode = wrapLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _linearGradientNode
}

// ColorStops retrieves the color stops in the gradient.
//
// The function returns the following values:
//
//    - colorStops: color stops in the gradient.
//
func (node *LinearGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_linear_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	{
		src := unsafe.Slice(_cret, _arg1)
		_colorStops = make([]ColorStop, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_colorStops[i] = *(*ColorStop)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _colorStops
}

// End retrieves the final point of the linear gradient.
//
// The function returns the following values:
//
//    - point: final point.
//
func (node *LinearGradientNode) End() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_linear_gradient_node_get_end(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *LinearGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_linear_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the initial point of the linear gradient.
//
// The function returns the following values:
//
//    - point: initial point.
//
func (node *LinearGradientNode) Start() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_linear_gradient_node_get_start(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// NewOpacityNode creates a GskRenderNode that will drawn the child with reduced
// opacity.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - opacity to apply.
//
// The function returns the following values:
//
//    - opacityNode: new GskRenderNode.
//
func NewOpacityNode(child RenderNoder, opacity float32) *OpacityNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = C.float(opacity)

	_cret = C.gsk_opacity_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(opacity)

	var _opacityNode *OpacityNode // out

	_opacityNode = wrapOpacityNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _opacityNode
}

// Child gets the child node that is getting opacityed by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting opacityed.
//
func (node *OpacityNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_opacity_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Opacity gets the transparency factor for an opacity node.
//
// The function returns the following values:
//
//    - gfloat: opacity factor.
//
func (node *OpacityNode) Opacity() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_opacity_node_get_opacity(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NewOutsetShadowNode creates a GskRenderNode that will render an outset shadow
// around the box given by outline.
//
// The function takes the following parameters:
//
//    - outline of the region surrounded by shadow.
//    - color of the shadow.
//    - dx: horizontal offset of shadow.
//    - dy: vertical offset of shadow.
//    - spread: how far the shadow spreads towards the inside.
//    - blurRadius: how much blur to apply to the shadow.
//
// The function returns the following values:
//
//    - outsetShadowNode: new GskRenderNode.
//
func NewOutsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) *OutsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_outset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _outsetShadowNode *OutsetShadowNode // out

	_outsetShadowNode = wrapOutsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _outsetShadowNode
}

// BlurRadius retrieves the blur radius of the shadow.
//
// The function returns the following values:
//
//    - gfloat: blur radius, in pixels.
//
func (node *OutsetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_blur_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the outset shadow.
//
// The function returns the following values:
//
//    - rgbA: color.
//
func (node *OutsetShadowNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Dx retrieves the horizontal offset of the outset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *OutsetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_dx(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the outset shadow.
//
// The function returns the following values:
//
//    - gfloat: offset, in pixels.
//
func (node *OutsetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_dy(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the outset shadow.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *OutsetShadowNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads outwards.
//
// The function returns the following values:
//
//    - gfloat: size of the shadow, in pixels.
//
func (node *OutsetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_spread(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NewRadialGradientNode creates a GskRenderNode that draws a radial gradient.
//
// The radial gradient starts around center. The size of the gradient is
// dictated by hradius in horizontal orientation and by vradius in vertial
// orientation.
//
// The function takes the following parameters:
//
//    - bounds of the node.
//    - center of the gradient.
//    - hradius: horizontal radius.
//    - vradius: vertical radius.
//    - start: percentage >= 0 that defines the start of the gradient around
//      center.
//    - end: percentage >= 0 that defines the end of the gradient around center.
//    - colorStops: pointer to an array of GskColorStop defining the gradient.
//      The offsets of all color stops must be increasing. The first stop's
//      offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//    - radialGradientNode: new GskRenderNode.
//
func NewRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius, vradius, start, end float32, colorStops []ColorStop) *RadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop     // out
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = (C.gsize)(len(colorStops))
	_arg7 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg7))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg7), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(hradius)
	runtime.KeepAlive(vradius)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _radialGradientNode *RadialGradientNode // out

	_radialGradientNode = wrapRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _radialGradientNode
}

// Center retrieves the center pointer for the gradient.
//
// The function returns the following values:
//
//    - point: center point for the gradient.
//
func (node *RadialGradientNode) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_center(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// ColorStops retrieves the color stops in the gradient.
//
// The function returns the following values:
//
//    - colorStops: color stops in the gradient.
//
func (node *RadialGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	{
		src := unsafe.Slice(_cret, _arg1)
		_colorStops = make([]ColorStop, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_colorStops[i] = *(*ColorStop)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _colorStops
}

// End retrieves the end value for the gradient.
//
// The function returns the following values:
//
//    - gfloat: end value for the gradient.
//
func (node *RadialGradientNode) End() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_end(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Hradius retrieves the horizonal radius for the gradient.
//
// The function returns the following values:
//
//    - gfloat: horizontal radius for the gradient.
//
func (node *RadialGradientNode) Hradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_hradius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NColorStops retrieves the number of color stops in the gradient.
//
// The function returns the following values:
//
//    - gsize: number of color stops.
//
func (node *RadialGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the start value for the gradient.
//
// The function returns the following values:
//
//    - gfloat: start value for the gradient.
//
func (node *RadialGradientNode) Start() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_start(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Vradius retrieves the vertical radius for the gradient.
//
// The function returns the following values:
//
//    - gfloat: vertical radius for the gradient.
//
func (node *RadialGradientNode) Vradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_vradius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RenderNode: GskRenderNode is the basic block in a scene graph to be rendered
// using GskRenderer.
//
// Each node has a parent, except the top-level node; each node may have
// children nodes.
//
// Each node has an associated drawing surface, which has the size of the
// rectangle set when creating it.
//
// Render nodes are meant to be transient; once they have been associated to a
// gsk.Renderer it's safe to release any reference you have on them. All
// gsk.RenderNodes are immutable, you can only specify their properties during
// construction.
type RenderNode struct {
	*externglib.Object

	_ [0]func()     // equal guard
	_ [0]sync.Mutex // copy guard
}

var (
	_ externglib.Objector = (*RenderNode)(nil)
)

// RenderNoder describes types inherited from class RenderNode.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type RenderNoder interface {
	externglib.Objector
	baseRenderNode() *RenderNode
}

var _ RenderNoder = (*RenderNode)(nil)

func wrapRenderNode(obj *externglib.Object) *RenderNode {
	return &RenderNode{
		Object: obj,
	}
}

func marshalRenderNoder(p uintptr) (interface{}, error) {
	return wrapRenderNode(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (node *RenderNode) baseRenderNode() *RenderNode {
	return node
}

// BaseRenderNode returns the underlying base object.
func BaseRenderNode(obj RenderNoder) *RenderNode {
	return obj.baseRenderNode()
}

// Draw the contents of node to the given cairo context.
//
// Typically, you'll use this function to implement fallback rendering of
// GskRenderNodes on an intermediate Cairo context, instead of using the drawing
// context associated to a GdkSurface's rendering buffer.
//
// For advanced nodes that cannot be supported using Cairo, in particular for
// nodes doing 3D operations, this function may fail.
//
// The function takes the following parameters:
//
//    - cr: cairo context to draw to.
//
func (node *RenderNode) Draw(cr *cairo.Context) {
	var _arg0 *C.GskRenderNode // out
	var _arg1 *C.cairo_t       // out

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))

	C.gsk_render_node_draw(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(cr)
}

// Bounds retrieves the boundaries of the node.
//
// The node will not draw outside of its boundaries.
//
// The function returns the following values:
//
//    - bounds: return location for the boundaries.
//
func (node *RenderNode) Bounds() *graphene.Rect {
	var _arg0 *C.GskRenderNode  // out
	var _arg1 C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	C.gsk_render_node_get_bounds(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _bounds *graphene.Rect // out

	_bounds = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _bounds
}

// NodeType returns the type of the node.
//
// The function returns the following values:
//
//    - renderNodeType: type of the GskRenderNode.
//
func (node *RenderNode) NodeType() RenderNodeType {
	var _arg0 *C.GskRenderNode    // out
	var _cret C.GskRenderNodeType // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_render_node_get_node_type(_arg0)
	runtime.KeepAlive(node)

	var _renderNodeType RenderNodeType // out

	_renderNodeType = RenderNodeType(_cret)

	return _renderNodeType
}

// Serialize serializes the node for later deserialization via
// gsk_render_node_deserialize(). No guarantees are made about the format used
// other than that the same version of GTK will be able to deserialize the
// result of a call to gsk_render_node_serialize() and
// gsk_render_node_deserialize() will correctly reject files it cannot open that
// were created with previous versions of GTK.
//
// The intended use of this functions is testing, benchmarking and debugging.
// The format is not meant as a permanent storage format.
//
// The function returns the following values:
//
//    - bytes representing the node.
//
func (node *RenderNode) Serialize() *glib.Bytes {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GBytes        // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_render_node_serialize(_arg0)
	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// WriteToFile: this function is equivalent to calling
// gsk_render_node_serialize() followed by g_file_set_contents().
//
// See those two functions for details on the arguments.
//
// It is mostly intended for use inside a debugger to quickly dump a render node
// to a file for later inspection.
//
// The function takes the following parameters:
//
//    - filename: file to save it to.
//
func (node *RenderNode) WriteToFile(filename string) error {
	var _arg0 *C.GskRenderNode // out
	var _arg1 *C.char          // out
	var _cerr *C.GError        // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gsk_render_node_write_to_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(node)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RenderNodeDeserialize loads data previously created via
// gsk_render_node_serialize().
//
// For a discussion of the supported format, see that function.
//
// The function takes the following parameters:
//
//    - bytes containing the data.
//    - errorFunc (optional): callback on parsing errors or NULL.
//
// The function returns the following values:
//
//    - renderNode (optional): new GskRenderNode or NULL on error.
//
func RenderNodeDeserialize(bytes *glib.Bytes, errorFunc ParseErrorFunc) RenderNoder {
	var _arg1 *C.GBytes           // out
	var _arg2 C.GskParseErrorFunc // out
	var _arg3 C.gpointer
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))
	if errorFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_gsk4_ParseErrorFunc)
		_arg3 = C.gpointer(gbox.Assign(errorFunc))
		defer gbox.Delete(uintptr(_arg3))
	}

	_cret = C.gsk_render_node_deserialize(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bytes)
	runtime.KeepAlive(errorFunc)

	var _renderNode RenderNoder // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.AssumeOwnership(objptr)
			casted := object.Cast()
			rv, ok := casted.(RenderNoder)
			if !ok {
				panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
			}
			_renderNode = rv
		}
	}

	return _renderNode
}

// NewRepeatNode creates a GskRenderNode that will repeat the drawing of child
// across the given bounds.
//
// The function takes the following parameters:
//
//    - bounds of the area to be painted.
//    - child to repeat.
//    - childBounds (optional): area of the child to repeat or NULL to use the
//      child's bounds.
//
// The function returns the following values:
//
//    - repeatNode: new GskRenderNode.
//
func NewRepeatNode(bounds *graphene.Rect, child RenderNoder, childBounds *graphene.Rect) *RepeatNode {
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.GskRenderNode   // out
	var _arg3 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	if childBounds != nil {
		_arg3 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(childBounds)))
	}

	_cret = C.gsk_repeat_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(child)
	runtime.KeepAlive(childBounds)

	var _repeatNode *RepeatNode // out

	_repeatNode = wrapRepeatNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatNode
}

// Child retrieves the child of node.
//
// The function returns the following values:
//
//    - renderNode: GskRenderNode.
//
func (node *RepeatNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_repeat_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ChildBounds retrieves the bounding rectangle of the child of node.
//
// The function returns the following values:
//
//    - rect: bounding rectangle.
//
func (node *RepeatNode) ChildBounds() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_repeat_node_get_child_bounds(_arg0)
	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rect
}

// NewRepeatingLinearGradientNode creates a GskRenderNode that will create a
// repeating linear gradient from the given points and color stops, and render
// that into the area given by bounds.
//
// The function takes the following parameters:
//
//    - bounds: rectangle to render the linear gradient into.
//    - start: point at which the linear gradient will begin.
//    - end: point at which the linear gradient will finish.
//    - colorStops: pointer to an array of GskColorStop defining the gradient.
//      The offsets of all color stops must be increasing. The first stop's
//      offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//    - repeatingLinearGradientNode: new GskRenderNode.
//
func NewRepeatingLinearGradientNode(bounds *graphene.Rect, start, end *graphene.Point, colorStops []ColorStop) *RepeatingLinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(end)))
	_arg5 = (C.gsize)(len(colorStops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_repeating_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _repeatingLinearGradientNode *RepeatingLinearGradientNode // out

	_repeatingLinearGradientNode = wrapRepeatingLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingLinearGradientNode
}

// NewRepeatingRadialGradientNode creates a GskRenderNode that draws a repeating
// radial gradient.
//
// The radial gradient starts around center. The size of the gradient is
// dictated by hradius in horizontal orientation and by vradius in vertial
// orientation.
//
// The function takes the following parameters:
//
//    - bounds of the node.
//    - center of the gradient.
//    - hradius: horizontal radius.
//    - vradius: vertical radius.
//    - start: percentage >= 0 that defines the start of the gradient around
//      center.
//    - end: percentage >= 0 that defines the end of the gradient around center.
//    - colorStops: pointer to an array of GskColorStop defining the gradient.
//      The offsets of all color stops must be increasing. The first stop's
//      offset must be >= 0 and the last stop's offset must be <= 1.
//
// The function returns the following values:
//
//    - repeatingRadialGradientNode: new GskRenderNode.
//
func NewRepeatingRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius, vradius, start, end float32, colorStops []ColorStop) *RepeatingRadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop     // out
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = (C.gsize)(len(colorStops))
	_arg7 = (*C.GskColorStop)(C.calloc(C.size_t(len(colorStops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg7))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg7), len(colorStops))
		for i := range colorStops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&colorStops[i]))))
		}
	}

	_cret = C.gsk_repeating_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(hradius)
	runtime.KeepAlive(vradius)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _repeatingRadialGradientNode *RepeatingRadialGradientNode // out

	_repeatingRadialGradientNode = wrapRepeatingRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingRadialGradientNode
}

// NewRoundedClipNode creates a GskRenderNode that will clip the child to the
// area given by clip.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - clip to apply.
//
// The function returns the following values:
//
//    - roundedClipNode: new GskRenderNode.
//
func NewRoundedClipNode(child RenderNoder, clip *RoundedRect) *RoundedClipNode {
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.GskRoundedRect // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(clip)))

	_cret = C.gsk_rounded_clip_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _roundedClipNode *RoundedClipNode // out

	_roundedClipNode = wrapRoundedClipNode(externglib.Take(unsafe.Pointer(_cret)))

	return _roundedClipNode
}

// Child gets the child node that is getting clipped by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting clipped.
//
func (node *RoundedClipNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_rounded_clip_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the rounded rectangle used to clip the contents of the node.
//
// The function returns the following values:
//
//    - roundedRect: rounded rectangle.
//
func (node *RoundedClipNode) Clip() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_rounded_clip_node_get_clip(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// NewShadowNode creates a GskRenderNode that will draw a child with the given
// shadows below it.
//
// The function takes the following parameters:
//
//    - child: node to draw.
//    - shadows to apply.
//
// The function returns the following values:
//
//    - shadowNode: new GskRenderNode.
//
func NewShadowNode(child RenderNoder, shadows []Shadow) *ShadowNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskShadow     // out
	var _arg3 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg3 = (C.gsize)(len(shadows))
	_arg2 = (*C.GskShadow)(C.calloc(C.size_t(len(shadows)), C.size_t(C.sizeof_GskShadow)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GskShadow)(_arg2), len(shadows))
		for i := range shadows {
			out[i] = *(*C.GskShadow)(gextras.StructNative(unsafe.Pointer((&shadows[i]))))
		}
	}

	_cret = C.gsk_shadow_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(child)
	runtime.KeepAlive(shadows)

	var _shadowNode *ShadowNode // out

	_shadowNode = wrapShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shadowNode
}

// Child retrieves the child GskRenderNode of the shadow node.
//
// The function returns the following values:
//
//    - renderNode: child render node.
//
func (node *ShadowNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_shadow_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NShadows retrieves the number of shadows in the node.
//
// The function returns the following values:
//
//    - gsize: number of shadows.
//
func (node *ShadowNode) NShadows() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_shadow_node_get_n_shadows(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Shadow retrieves the shadow data at the given index i.
//
// The function takes the following parameters:
//
//    - i: given index.
//
// The function returns the following values:
//
//    - shadow data.
//
func (node *ShadowNode) Shadow(i uint) *Shadow {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.gsize          // out
	var _cret *C.GskShadow     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))
	_arg1 = C.gsize(i)

	_cret = C.gsk_shadow_node_get_shadow(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(i)

	var _shadow *Shadow // out

	_shadow = (*Shadow)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _shadow
}

// NewTextNode creates a render node that renders the given glyphs.
//
// Note that color may not be used if the font contains color glyphs.
//
// The function takes the following parameters:
//
//    - font containing the glyphs.
//    - glyphs to render.
//    - color: foreground color to render with.
//    - offset of the baseline.
//
// The function returns the following values:
//
//    - textNode (optional): new GskRenderNode.
//
func NewTextNode(font pango.Fonter, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) *TextNode {
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 *C.GdkRGBA          // out
	var _arg4 *C.graphene_point_t // out
	var _cret *C.GskRenderNode    // in

	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))
	_arg2 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg3 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg4 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(offset)))

	_cret = C.gsk_text_node_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(color)
	runtime.KeepAlive(offset)

	var _textNode *TextNode // out

	if _cret != nil {
		_textNode = wrapTextNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _textNode
}

// Color retrieves the color used by the text node.
//
// The function returns the following values:
//
//    - rgbA: text color.
//
func (node *TextNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Font returns the font used by the text node.
//
// The function returns the following values:
//
//    - font: font.
//
func (node *TextNode) Font() pango.Fonter {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.PangoFont     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_font(_arg0)
	runtime.KeepAlive(node)

	var _font pango.Fonter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(pango.Fonter)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not pango.Fonter")
		}
		_font = rv
	}

	return _font
}

// Glyphs retrieves the glyph information in the node.
//
// The function returns the following values:
//
//    - glyphInfos: glyph information.
//
func (node *TextNode) Glyphs() []pango.GlyphInfo {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.PangoGlyphInfo // in
	var _arg1 C.guint           // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_glyphs(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _glyphInfos []pango.GlyphInfo // out

	{
		src := unsafe.Slice(_cret, _arg1)
		_glyphInfos = make([]pango.GlyphInfo, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_glyphInfos[i] = *(*pango.GlyphInfo)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _glyphInfos
}

// NumGlyphs retrieves the number of glyphs in the text node.
//
// The function returns the following values:
//
//    - guint: number of glyphs.
//
func (node *TextNode) NumGlyphs() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_num_glyphs(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Offset retrieves the offset applied to the text.
//
// The function returns the following values:
//
//    - point with the horizontal and vertical offsets.
//
func (node *TextNode) Offset() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_offset(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// HasColorGlyphs checks whether the text node has color glyphs.
//
// The function returns the following values:
//
//    - ok: TRUE if the text node has color glyphs.
//
func (node *TextNode) HasColorGlyphs() bool {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_has_color_glyphs(_arg0)
	runtime.KeepAlive(node)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NewTextureNode creates a GskRenderNode that will render the given texture
// into the area given by bounds.
//
// The function takes the following parameters:
//
//    - texture: GdkTexture.
//    - bounds: rectangle to render the texture into.
//
// The function returns the following values:
//
//    - textureNode: new GskRenderNode.
//
func NewTextureNode(texture gdk.Texturer, bounds *graphene.Rect) *TextureNode {
	var _arg1 *C.GdkTexture      // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_texture_node_new(_arg1, _arg2)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(bounds)

	var _textureNode *TextureNode // out

	_textureNode = wrapTextureNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textureNode
}

// Texture retrieves the GdkTexture used when creating this GskRenderNode.
//
// The function returns the following values:
//
//    - texture: GdkTexture.
//
func (node *TextureNode) Texture() gdk.Texturer {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkTexture    // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_texture_node_get_texture(_arg0)
	runtime.KeepAlive(node)

	var _texture gdk.Texturer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Texturer is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(gdk.Texturer)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gdk.Texturer")
		}
		_texture = rv
	}

	return _texture
}

// NewTransformNode creates a GskRenderNode that will transform the given child
// with the given transform.
//
// The function takes the following parameters:
//
//    - child: node to transform.
//    - transform to apply.
//
// The function returns the following values:
//
//    - transformNode: new GskRenderNode.
//
func NewTransformNode(child RenderNoder, transform *Transform) *TransformNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskTransform  // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(transform)))

	_cret = C.gsk_transform_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(transform)

	var _transformNode *TransformNode // out

	_transformNode = wrapTransformNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _transformNode
}

// Child gets the child node that is getting transformed by the given node.
//
// The function returns the following values:
//
//    - renderNode: child that is getting transformed.
//
func (node *TransformNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_transform_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.Cast()
		rv, ok := casted.(RenderNoder)
		if !ok {
			panic("object of type " + reflect.TypeOf(casted).String() + " (" + object.TypeFromInstance().String() + ") is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Transform retrieves the GskTransform used by the node.
//
// The function returns the following values:
//
//    - transform: GskTransform.
//
func (node *TransformNode) Transform() *Transform {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskTransform  // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_transform_node_get_transform(_arg0)
	runtime.KeepAlive(node)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// ColorStop: color stop in a gradient node.
//
// An instance of this type is always passed by reference.
type ColorStop struct {
	*colorStop
}

// colorStop is the struct that's finalized.
type colorStop struct {
	native *C.GskColorStop
}

// Offset: offset of the color stop.
func (c *ColorStop) Offset() float32 {
	var v float32 // out
	v = float32(c.native.offset)
	return v
}

// Color: color at the given offset.
func (c *ColorStop) Color() *gdk.RGBA {
	var v *gdk.RGBA // out
	v = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&c.native.color))))
	return v
}

// ParseLocation: location in a parse buffer.
//
// An instance of this type is always passed by reference.
type ParseLocation struct {
	*parseLocation
}

// parseLocation is the struct that's finalized.
type parseLocation struct {
	native *C.GskParseLocation
}

// NewParseLocation creates a new ParseLocation instance from the given
// fields.
func NewParseLocation(bytes, chars, lines, lineBytes, lineChars uint) ParseLocation {
	var f0 C.gsize // out
	f0 = C.gsize(bytes)
	var f1 C.gsize // out
	f1 = C.gsize(chars)
	var f2 C.gsize // out
	f2 = C.gsize(lines)
	var f3 C.gsize // out
	f3 = C.gsize(lineBytes)
	var f4 C.gsize // out
	f4 = C.gsize(lineChars)

	v := C.GskParseLocation{
		bytes:      f0,
		chars:      f1,
		lines:      f2,
		line_bytes: f3,
		line_chars: f4,
	}

	return *(*ParseLocation)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Bytes: offset of the location in the parse buffer, as bytes.
func (p *ParseLocation) Bytes() uint {
	var v uint // out
	v = uint(p.native.bytes)
	return v
}

// Chars: offset of the location in the parse buffer, as characters.
func (p *ParseLocation) Chars() uint {
	var v uint // out
	v = uint(p.native.chars)
	return v
}

// Lines: line of the location in the parse buffer.
func (p *ParseLocation) Lines() uint {
	var v uint // out
	v = uint(p.native.lines)
	return v
}

// LineBytes: position in the line, as bytes.
func (p *ParseLocation) LineBytes() uint {
	var v uint // out
	v = uint(p.native.line_bytes)
	return v
}

// LineChars: position in the line, as characters.
func (p *ParseLocation) LineChars() uint {
	var v uint // out
	v = uint(p.native.line_chars)
	return v
}

// Shadow: shadow parameters in a shadow node.
//
// An instance of this type is always passed by reference.
type Shadow struct {
	*shadow
}

// shadow is the struct that's finalized.
type shadow struct {
	native *C.GskShadow
}

// Color: color of the shadow.
func (s *Shadow) Color() *gdk.RGBA {
	var v *gdk.RGBA // out
	v = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&s.native.color))))
	return v
}

// Dx: horizontal offset of the shadow.
func (s *Shadow) Dx() float32 {
	var v float32 // out
	v = float32(s.native.dx)
	return v
}

// Dy: vertical offset of the shadow.
func (s *Shadow) Dy() float32 {
	var v float32 // out
	v = float32(s.native.dy)
	return v
}

// Radius radius of the shadow.
func (s *Shadow) Radius() float32 {
	var v float32 // out
	v = float32(s.native.radius)
	return v
}

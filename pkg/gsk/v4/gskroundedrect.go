// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	"github.com/diamondburned/gotk4/pkg/graphene"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// RoundedRect: rectangular region with rounded corners.
//
// Application code should normalize rectangles using
// gsk.RoundedRect.Normalize(); this function will ensure that the bounds of the
// rectangle are normalized and ensure that the corner values are positive and
// the corners do not overlap.
//
// All functions taking a GskRoundedRect as an argument will internally operate
// on a normalized copy; all functions returning a GskRoundedRect will always
// return a normalized one.
//
// The algorithm used for normalizing corner sizes is described in the CSS
// specification (https://drafts.csswg.org/css-backgrounds-3/#border-radius).
//
// An instance of this type is always passed by reference.
type RoundedRect struct {
	*roundedRect
}

// roundedRect is the struct that's finalized.
type roundedRect struct {
	native unsafe.Pointer
}

// Bounds bounds of the rectangle.
func (r *RoundedRect) Bounds() *graphene.Rect {
	offset := girepository.MustFind("Gsk", "RoundedRect").StructFieldOffset("bounds")
	valptr := (*uintptr)(unsafe.Add(r.native, offset))
	var v *graphene.Rect // out
	v = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer((&*(*C.graphene_rect_t)(unsafe.Pointer(&*valptr))))))
	return v
}

// Corner: size of the 4 rounded corners.
func (r *RoundedRect) Corner() [4]graphene.Size {
	offset := girepository.MustFind("Gsk", "RoundedRect").StructFieldOffset("corner")
	valptr := (*uintptr)(unsafe.Add(r.native, offset))
	var v [4]graphene.Size // out
	{
		src := &*(*C.graphene_size_t)(unsafe.Pointer(&*valptr))
		for i := 0; i < 4; i++ {
			v[i] = *(*graphene.Size)(gextras.NewStructNative(unsafe.Pointer((&*(*C.graphene_size_t)(unsafe.Pointer(&src[i]))))))
		}
	}
	return v
}

// ContainsPoint checks if the given point is inside the rounded rectangle.
//
// The function takes the following parameters:
//
//    - point to check.
//
// The function returns the following values:
//
//    - ok: TRUE if the point is inside the rounded rectangle.
//
func (self *RoundedRect) ContainsPoint(point *graphene.Point) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(**C.graphene_point_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("contains_point", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)
	runtime.KeepAlive(point)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// ContainsRect checks if the given rect is contained inside the rounded
// rectangle.
//
// The function takes the following parameters:
//
//    - rect: rectangle to check.
//
// The function returns the following values:
//
//    - ok: TRUE if the rect is fully contained inside the rounded rectangle.
//
func (self *RoundedRect) ContainsRect(rect *graphene.Rect) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(rect)))

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("contains_rect", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)
	runtime.KeepAlive(rect)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Init initializes the given GskRoundedRect with the given values.
//
// This function will implicitly normalize the GskRoundedRect before returning.
//
// The function takes the following parameters:
//
//    - bounds: graphene_rect_t describing the bounds.
//    - topLeft: rounding radius of the top left corner.
//    - topRight: rounding radius of the top right corner.
//    - bottomRight: rounding radius of the bottom right corner.
//    - bottomLeft: rounding radius of the bottom left corner.
//
// The function returns the following values:
//
//    - roundedRect: initialized rectangle.
//
func (self *RoundedRect) Init(bounds *graphene.Rect, topLeft *graphene.Size, topRight *graphene.Size, bottomRight *graphene.Size, bottomLeft *graphene.Size) *RoundedRect {
	var _args [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	*(**C.graphene_size_t)(unsafe.Pointer(&_args[2])) = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(topLeft)))
	*(**C.graphene_size_t)(unsafe.Pointer(&_args[3])) = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(topRight)))
	*(**C.graphene_size_t)(unsafe.Pointer(&_args[4])) = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(bottomRight)))
	*(**C.graphene_size_t)(unsafe.Pointer(&_args[5])) = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(bottomLeft)))

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("init", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(topLeft)
	runtime.KeepAlive(topRight)
	runtime.KeepAlive(bottomRight)
	runtime.KeepAlive(bottomLeft)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// InitCopy initializes self using the given src rectangle.
//
// This function will not normalize the GskRoundedRect, so make sure the source
// is normalized.
//
// The function takes the following parameters:
//
//    - src: GskRoundedRect.
//
// The function returns the following values:
//
//    - roundedRect: initialized rectangle.
//
func (self *RoundedRect) InitCopy(src *RoundedRect) *RoundedRect {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(src)))

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("init_copy", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)
	runtime.KeepAlive(src)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// InitFromRect initializes self to the given bounds and sets the radius of all
// four corners to radius.
//
// The function takes the following parameters:
//
//    - bounds: graphene_rect_t.
//    - radius: border radius.
//
// The function returns the following values:
//
//    - roundedRect: initialized rectangle.
//
func (self *RoundedRect) InitFromRect(bounds *graphene.Rect, radius float32) *RoundedRect {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(radius)

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("init_from_rect", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(radius)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// IntersectsRect checks if part of the given rect is contained inside the
// rounded rectangle.
//
// The function takes the following parameters:
//
//    - rect: rectangle to check.
//
// The function returns the following values:
//
//    - ok: TRUE if the rect intersects with the rounded rectangle.
//
func (self *RoundedRect) IntersectsRect(rect *graphene.Rect) bool {
	var _args [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(rect)))

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("intersects_rect", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)
	runtime.KeepAlive(rect)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// IsRectilinear checks if all corners of self are right angles and the
// rectangle covers all of its bounds.
//
// This information can be used to decide if gsk.ClipNode.New or
// gsk.RoundedClipNode.New should be called.
//
// The function returns the following values:
//
//    - ok: TRUE if the rectangle is rectilinear.
//
func (self *RoundedRect) IsRectilinear() bool {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("is_rectilinear", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Normalize normalizes the passed rectangle.
//
// This function will ensure that the bounds of the rectangle are normalized and
// ensure that the corner values are positive and the corners do not overlap.
//
// The function returns the following values:
//
//    - roundedRect: normalized rectangle.
//
func (self *RoundedRect) Normalize() *RoundedRect {
	var _args [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("normalize", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// Offset offsets the bound's origin by dx and dy.
//
// The size and corners of the rectangle are unchanged.
//
// The function takes the following parameters:
//
//    - dx: horizontal offset.
//    - dy: vertical offset.
//
// The function returns the following values:
//
//    - roundedRect: offset rectangle.
//
func (self *RoundedRect) Offset(dx float32, dy float32) *RoundedRect {
	var _args [3]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(dx)
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(dy)

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("offset", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

// Shrink shrinks (or grows) the given rectangle by moving the 4 sides according
// to the offsets given.
//
// The corner radii will be changed in a way that tries to keep the center of
// the corner circle intact. This emulates CSS behavior.
//
// This function also works for growing rectangles if you pass negative values
// for the top, right, bottom or left.
//
// The function takes the following parameters:
//
//    - top: how far to move the top side downwards.
//    - right: how far to move the right side to the left.
//    - bottom: how far to move the bottom side upwards.
//    - left: how far to move the left side to the right.
//
// The function returns the following values:
//
//    - roundedRect: resized GskRoundedRect.
//
func (self *RoundedRect) Shrink(top float32, right float32, bottom float32, left float32) *RoundedRect {
	var _args [5]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(top)
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(right)
	*(*C.float)(unsafe.Pointer(&_args[3])) = C.float(bottom)
	*(*C.float)(unsafe.Pointer(&_args[4])) = C.float(left)

	_info := girepository.MustFind("Gsk", "RoundedRect")
	_gret := _info.InvokeRecordMethod("shrink", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)
	runtime.KeepAlive(top)
	runtime.KeepAlive(right)
	runtime.KeepAlive(bottom)
	runtime.KeepAlive(left)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))

	return _roundedRect
}

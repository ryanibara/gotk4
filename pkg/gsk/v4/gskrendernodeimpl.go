// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gsk/gsk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gsk_blend_node_get_type()), F: marshalBlendNoder},
		{T: externglib.Type(C.gsk_blur_node_get_type()), F: marshalBlurNoder},
		{T: externglib.Type(C.gsk_border_node_get_type()), F: marshalBorderNoder},
		{T: externglib.Type(C.gsk_cairo_node_get_type()), F: marshalCairoNoder},
		{T: externglib.Type(C.gsk_clip_node_get_type()), F: marshalClipNoder},
		{T: externglib.Type(C.gsk_color_matrix_node_get_type()), F: marshalColorMatrixNoder},
		{T: externglib.Type(C.gsk_color_node_get_type()), F: marshalColorNoder},
		{T: externglib.Type(C.gsk_conic_gradient_node_get_type()), F: marshalConicGradientNoder},
		{T: externglib.Type(C.gsk_container_node_get_type()), F: marshalContainerNoder},
		{T: externglib.Type(C.gsk_cross_fade_node_get_type()), F: marshalCrossFadeNoder},
		{T: externglib.Type(C.gsk_debug_node_get_type()), F: marshalDebugNoder},
		{T: externglib.Type(C.gsk_gl_shader_node_get_type()), F: marshalGLShaderNoder},
		{T: externglib.Type(C.gsk_inset_shadow_node_get_type()), F: marshalInsetShadowNoder},
		{T: externglib.Type(C.gsk_linear_gradient_node_get_type()), F: marshalLinearGradientNoder},
		{T: externglib.Type(C.gsk_opacity_node_get_type()), F: marshalOpacityNoder},
		{T: externglib.Type(C.gsk_outset_shadow_node_get_type()), F: marshalOutsetShadowNoder},
		{T: externglib.Type(C.gsk_radial_gradient_node_get_type()), F: marshalRadialGradientNoder},
		{T: externglib.Type(C.gsk_repeat_node_get_type()), F: marshalRepeatNoder},
		{T: externglib.Type(C.gsk_repeating_linear_gradient_node_get_type()), F: marshalRepeatingLinearGradientNoder},
		{T: externglib.Type(C.gsk_repeating_radial_gradient_node_get_type()), F: marshalRepeatingRadialGradientNoder},
		{T: externglib.Type(C.gsk_rounded_clip_node_get_type()), F: marshalRoundedClipNoder},
		{T: externglib.Type(C.gsk_shadow_node_get_type()), F: marshalShadowNoder},
		{T: externglib.Type(C.gsk_text_node_get_type()), F: marshalTextNoder},
		{T: externglib.Type(C.gsk_texture_node_get_type()), F: marshalTextureNoder},
		{T: externglib.Type(C.gsk_transform_node_get_type()), F: marshalTransformNoder},
	})
}

// BlendNode: render node applying a blending function between its two child
// nodes.
type BlendNode struct {
	RenderNode
}

func wrapBlendNode(obj *externglib.Object) *BlendNode {
	return &BlendNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalBlendNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapBlendNode(obj), nil
}

// NewBlendNode creates a GskRenderNode that will use blend_mode to blend the
// top node onto the bottom node.
func NewBlendNode(bottom RenderNoder, top RenderNoder, blendMode BlendMode) *BlendNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.GskBlendMode   // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(bottom.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(top.Native()))
	_arg3 = C.GskBlendMode(blendMode)

	_cret = C.gsk_blend_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bottom)
	runtime.KeepAlive(top)
	runtime.KeepAlive(blendMode)

	var _blendNode *BlendNode // out

	_blendNode = wrapBlendNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blendNode
}

// BlendMode retrieves the blend mode used by node.
func (node *BlendNode) BlendMode() BlendMode {
	var _arg0 *C.GskRenderNode // out
	var _cret C.GskBlendMode   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blend_node_get_blend_mode(_arg0)
	runtime.KeepAlive(node)

	var _blendMode BlendMode // out

	_blendMode = BlendMode(_cret)

	return _blendMode
}

// BottomChild retrieves the bottom GskRenderNode child of the node.
func (node *BlendNode) BottomChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blend_node_get_bottom_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// TopChild retrieves the top GskRenderNode child of the node.
func (node *BlendNode) TopChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blend_node_get_top_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// BlurNode: render node applying a blur effect to its single child.
type BlurNode struct {
	RenderNode
}

func wrapBlurNode(obj *externglib.Object) *BlurNode {
	return &BlurNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalBlurNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapBlurNode(obj), nil
}

// NewBlurNode creates a render node that blurs the child.
func NewBlurNode(child RenderNoder, radius float32) *BlurNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = C.float(radius)

	_cret = C.gsk_blur_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(radius)

	var _blurNode *BlurNode // out

	_blurNode = wrapBlurNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _blurNode
}

// Child retrieves the child GskRenderNode of the blur node.
func (node *BlurNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blur_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Radius retrieves the blur radius of the node.
func (node *BlurNode) Radius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_blur_node_get_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// BorderNode: render node for a border.
type BorderNode struct {
	RenderNode
}

func wrapBorderNode(obj *externglib.Object) *BorderNode {
	return &BorderNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalBorderNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapBorderNode(obj), nil
}

// NewBorderNode creates a GskRenderNode that will stroke a border rectangle
// inside the given outline.
//
// The 4 sides of the border can have different widths and colors.
func NewBorderNode(outline *RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) *BorderNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.float          // out
	var _arg3 *C.GdkRGBA        // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	_arg3 = (*C.GdkRGBA)(unsafe.Pointer(&borderColor))

	_cret = C.gsk_border_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(borderWidth)
	runtime.KeepAlive(borderColor)

	var _borderNode *BorderNode // out

	_borderNode = wrapBorderNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _borderNode
}

// Colors retrieves the colors of the border.
func (node *BorderNode) Colors() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_border_node_get_colors(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Outline retrieves the outline of the border.
func (node *BorderNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_border_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Widths retrieves the stroke widths of the border.
func (node *BorderNode) Widths() [4]float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.float         // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_border_node_get_widths(_arg0)
	runtime.KeepAlive(node)

	var _gfloats [4]float32 // out

	_gfloats = *(*[4]float32)(unsafe.Pointer(&_cret))

	return _gfloats
}

// CairoNode: render node for a Cairo surface.
type CairoNode struct {
	RenderNode
}

func wrapCairoNode(obj *externglib.Object) *CairoNode {
	return &CairoNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalCairoNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapCairoNode(obj), nil
}

// NewCairoNode creates a GskRenderNode that will render a cairo surface into
// the area given by bounds.
//
// You can draw to the cairo surface using gsk.CairoNode.GetDrawContext().
func NewCairoNode(bounds *graphene.Rect) *CairoNode {
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_cairo_node_new(_arg1)
	runtime.KeepAlive(bounds)

	var _cairoNode *CairoNode // out

	_cairoNode = wrapCairoNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cairoNode
}

// DrawContext creates a Cairo context for drawing using the surface associated
// to the render node.
//
// If no surface exists yet, a surface will be created optimized for rendering
// to renderer.
func (node *CairoNode) DrawContext() *cairo.Context {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.cairo_t       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cairo_node_get_draw_context(_arg0)
	runtime.KeepAlive(node)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	return _context
}

// Surface retrieves the Cairo surface used by the render node.
func (node *CairoNode) Surface() *cairo.Surface {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.cairo_surface_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cairo_node_get_surface(_arg0)
	runtime.KeepAlive(node)

	var _surface *cairo.Surface // out

	_surface = cairo.WrapSurface(uintptr(unsafe.Pointer(_cret)))
	C.cairo_surface_reference(_cret)
	runtime.SetFinalizer(_surface, func(v *cairo.Surface) {
		C.cairo_surface_destroy((*C.cairo_surface_t)(unsafe.Pointer(v.Native())))
	})

	return _surface
}

// ClipNode: render node applying a rectangular clip to its single child node.
type ClipNode struct {
	RenderNode
}

func wrapClipNode(obj *externglib.Object) *ClipNode {
	return &ClipNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalClipNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapClipNode(obj), nil
}

// NewClipNode creates a GskRenderNode that will clip the child to the area
// given by clip.
func NewClipNode(child RenderNoder, clip *graphene.Rect) *ClipNode {
	var _arg1 *C.GskRenderNode   // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(clip)))

	_cret = C.gsk_clip_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _clipNode *ClipNode // out

	_clipNode = wrapClipNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _clipNode
}

// Child gets the child node that is getting clipped by the given node.
func (node *ClipNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_clip_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the clip rectangle for node.
func (node *ClipNode) Clip() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_clip_node_get_clip(_arg0)
	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rect
}

// ColorMatrixNode: render node controlling the color matrix of its single child
// node.
type ColorMatrixNode struct {
	RenderNode
}

func wrapColorMatrixNode(obj *externglib.Object) *ColorMatrixNode {
	return &ColorMatrixNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalColorMatrixNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapColorMatrixNode(obj), nil
}

// NewColorMatrixNode creates a GskRenderNode that will drawn the child with
// color_matrix.
//
// In particular, the node will transform the operation
//
//    pixel = color_matrix * pixel + color_offset
//
// for every pixel.
func NewColorMatrixNode(child RenderNoder, colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) *ColorMatrixNode {
	var _arg1 *C.GskRenderNode     // out
	var _arg2 *C.graphene_matrix_t // out
	var _arg3 *C.graphene_vec4_t   // out
	var _cret *C.GskRenderNode     // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.graphene_matrix_t)(gextras.StructNative(unsafe.Pointer(colorMatrix)))
	_arg3 = (*C.graphene_vec4_t)(gextras.StructNative(unsafe.Pointer(colorOffset)))

	_cret = C.gsk_color_matrix_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(child)
	runtime.KeepAlive(colorMatrix)
	runtime.KeepAlive(colorOffset)

	var _colorMatrixNode *ColorMatrixNode // out

	_colorMatrixNode = wrapColorMatrixNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorMatrixNode
}

// Child gets the child node that is getting its colors modified by the given
// node.
func (node *ColorMatrixNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_color_matrix_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ColorMatrix retrieves the color matrix used by the node.
func (node *ColorMatrixNode) ColorMatrix() *graphene.Matrix {
	var _arg0 *C.GskRenderNode     // out
	var _cret *C.graphene_matrix_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_color_matrix_node_get_color_matrix(_arg0)
	runtime.KeepAlive(node)

	var _matrix *graphene.Matrix // out

	_matrix = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _matrix
}

// ColorOffset retrieves the color offset used by the node.
func (node *ColorMatrixNode) ColorOffset() *graphene.Vec4 {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_vec4_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_color_matrix_node_get_color_offset(_arg0)
	runtime.KeepAlive(node)

	var _vec4 *graphene.Vec4 // out

	_vec4 = (*graphene.Vec4)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _vec4
}

// ColorNode: render node for a solid color.
type ColorNode struct {
	RenderNode
}

func wrapColorNode(obj *externglib.Object) *ColorNode {
	return &ColorNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalColorNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapColorNode(obj), nil
}

// NewColorNode creates a GskRenderNode that will render the color specified by
// rgba into the area given by bounds.
func NewColorNode(rgba *gdk.RGBA, bounds *graphene.Rect) *ColorNode {
	var _arg1 *C.GdkRGBA         // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_color_node_new(_arg1, _arg2)
	runtime.KeepAlive(rgba)
	runtime.KeepAlive(bounds)

	var _colorNode *ColorNode // out

	_colorNode = wrapColorNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _colorNode
}

// Color retrieves the color of the given node.
func (node *ColorNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_color_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// ConicGradientNode: render node for a conic gradient.
type ConicGradientNode struct {
	RenderNode
}

func wrapConicGradientNode(obj *externglib.Object) *ConicGradientNode {
	return &ConicGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalConicGradientNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapConicGradientNode(obj), nil
}

// NewConicGradientNode creates a GskRenderNode that draws a conic gradient.
//
// The conic gradient starts around center in the direction of rotation. A
// rotation of 0 means that the gradient points up. Color stops are then added
// clockwise.
func NewConicGradientNode(bounds *graphene.Rect, center *graphene.Point, rotation float32, colorStops []ColorStop) *ConicGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(rotation)
	_arg5 = (C.gsize)(len(colorStops))
	if len(colorStops) > 0 {
		_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))
	}

	_cret = C.gsk_conic_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(rotation)
	runtime.KeepAlive(colorStops)

	var _conicGradientNode *ConicGradientNode // out

	_conicGradientNode = wrapConicGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _conicGradientNode
}

// Angle retrieves the angle for the gradient in radians, normalized in [0, 2 *
// PI].
//
// The angle is starting at the top and going clockwise, as expressed in the css
// specification:
//
//    angle = 90 - gsk_conic_gradient_node_get_rotation().
func (node *ConicGradientNode) Angle() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_angle(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Center retrieves the center pointer for the gradient.
func (node *ConicGradientNode) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_center(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// ColorStops retrieves the color stops in the gradient.
func (node *ConicGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	_colorStops = make([]ColorStop, _arg1)
	copy(_colorStops, unsafe.Slice((*ColorStop)(unsafe.Pointer(_cret)), _arg1))

	return _colorStops
}

// NColorStops retrieves the number of color stops in the gradient.
func (node *ConicGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Rotation retrieves the rotation for the gradient in degrees.
func (node *ConicGradientNode) Rotation() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_conic_gradient_node_get_rotation(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// ContainerNode: render node that can contain other render nodes.
type ContainerNode struct {
	RenderNode
}

func wrapContainerNode(obj *externglib.Object) *ContainerNode {
	return &ContainerNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalContainerNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapContainerNode(obj), nil
}

// NewContainerNode creates a new GskRenderNode instance for holding the given
// children.
//
// The new node will acquire a reference to each of the children.
func NewContainerNode(children []RenderNoder) *ContainerNode {
	var _arg1 **C.GskRenderNode // out
	var _arg2 C.guint
	var _cret *C.GskRenderNode // in

	_arg2 = (C.guint)(len(children))
	_arg1 = (**C.GskRenderNode)(C.malloc(C.ulong(len(children)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.GskRenderNode)(_arg1), len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(children[i].Native()))
		}
	}

	_cret = C.gsk_container_node_new(_arg1, _arg2)
	runtime.KeepAlive(children)

	var _containerNode *ContainerNode // out

	_containerNode = wrapContainerNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _containerNode
}

// Child gets one of the children of container.
func (node *ContainerNode) Child(idx uint) RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_container_node_get_child(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren retrieves the number of direct children of node.
func (node *ContainerNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_container_node_get_n_children(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CrossFadeNode: render node cross fading between two child nodes.
type CrossFadeNode struct {
	RenderNode
}

func wrapCrossFadeNode(obj *externglib.Object) *CrossFadeNode {
	return &CrossFadeNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalCrossFadeNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapCrossFadeNode(obj), nil
}

// NewCrossFadeNode creates a GskRenderNode that will do a cross-fade between
// start and end.
func NewCrossFadeNode(start RenderNoder, end RenderNoder, progress float32) *CrossFadeNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskRenderNode // out
	var _arg3 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(start.Native()))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(end.Native()))
	_arg3 = C.float(progress)

	_cret = C.gsk_cross_fade_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(progress)

	var _crossFadeNode *CrossFadeNode // out

	_crossFadeNode = wrapCrossFadeNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _crossFadeNode
}

// EndChild retrieves the child GskRenderNode at the end of the cross-fade.
func (node *CrossFadeNode) EndChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cross_fade_node_get_end_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Progress retrieves the progress value of the cross fade.
func (node *CrossFadeNode) Progress() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cross_fade_node_get_progress(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// StartChild retrieves the child GskRenderNode at the beginning of the
// cross-fade.
func (node *CrossFadeNode) StartChild() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_cross_fade_node_get_start_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// DebugNode: render node that emits a debugging message when drawing its child
// node.
type DebugNode struct {
	RenderNode
}

func wrapDebugNode(obj *externglib.Object) *DebugNode {
	return &DebugNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalDebugNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapDebugNode(obj), nil
}

// NewDebugNode creates a GskRenderNode that will add debug information about
// the given child.
//
// Adding this node has no visual effect.
func NewDebugNode(child RenderNoder, message string) *DebugNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.char          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(message)))

	_cret = C.gsk_debug_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(message)

	var _debugNode *DebugNode // out

	_debugNode = wrapDebugNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _debugNode
}

// Child gets the child node that is getting drawn by the given node.
func (node *DebugNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_debug_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Message gets the debug message that was set on this node.
func (node *DebugNode) Message() string {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.char          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_debug_node_get_message(_arg0)
	runtime.KeepAlive(node)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GLShaderNode: render node using a GL shader when drawing its children nodes.
type GLShaderNode struct {
	RenderNode
}

func wrapGLShaderNode(obj *externglib.Object) *GLShaderNode {
	return &GLShaderNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalGLShaderNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapGLShaderNode(obj), nil
}

// NewGLShaderNode creates a GskRenderNode that will render the given shader
// into the area given by bounds.
//
// The args is a block of data to use for uniform input, as per types and
// offsets defined by the shader. Normally this is generated by
// gsk.GLShader.FormatArgs() or gsk.ShaderArgsBuilder.
//
// See gsk.GLShader for details about how the shader should be written.
//
// All the children will be rendered into textures (if they aren't already
// GskTextureNodes, which will be used directly). These textures will be sent as
// input to the shader.
//
// If the renderer doesn't support GL shaders, or if there is any problem when
// compiling the shader, then the node will draw pink. You should use
// gsk.GLShader.Compile() to ensure the shader will work for the renderer before
// using it.
func NewGLShaderNode(shader *GLShader, bounds *graphene.Rect, args *glib.Bytes, children []RenderNoder) *GLShaderNode {
	var _arg1 *C.GskGLShader     // out
	var _arg2 *C.graphene_rect_t // out
	var _arg3 *C.GBytes          // out
	var _arg4 **C.GskRenderNode  // out
	var _arg5 C.guint
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskGLShader)(unsafe.Pointer(shader.Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg3 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(args)))
	_arg5 = (C.guint)(len(children))
	_arg4 = (**C.GskRenderNode)(C.malloc(C.ulong(len(children)) * C.ulong(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((**C.GskRenderNode)(_arg4), len(children))
		for i := range children {
			out[i] = (*C.GskRenderNode)(unsafe.Pointer(children[i].Native()))
		}
	}

	_cret = C.gsk_gl_shader_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(args)
	runtime.KeepAlive(children)

	var _glShaderNode *GLShaderNode // out

	_glShaderNode = wrapGLShaderNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _glShaderNode
}

// Args gets args for the node.
func (node *GLShaderNode) Args() *glib.Bytes {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GBytes        // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_gl_shader_node_get_args(_arg0)
	runtime.KeepAlive(node)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_bytes_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Child gets one of the children.
func (node *GLShaderNode) Child(idx uint) RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.guint          // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))
	_arg1 = C.guint(idx)

	_cret = C.gsk_gl_shader_node_get_child(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(idx)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NChildren returns the number of children.
func (node *GLShaderNode) NChildren() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_gl_shader_node_get_n_children(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Shader gets shader code for the node.
func (node *GLShaderNode) Shader() *GLShader {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskGLShader   // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_gl_shader_node_get_shader(_arg0)
	runtime.KeepAlive(node)

	var _glShader *GLShader // out

	_glShader = wrapGLShader(externglib.Take(unsafe.Pointer(_cret)))

	return _glShader
}

// InsetShadowNode: render node for an inset shadow.
type InsetShadowNode struct {
	RenderNode
}

func wrapInsetShadowNode(obj *externglib.Object) *InsetShadowNode {
	return &InsetShadowNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalInsetShadowNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapInsetShadowNode(obj), nil
}

// NewInsetShadowNode creates a GskRenderNode that will render an inset shadow
// into the box given by outline.
func NewInsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) *InsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_inset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _insetShadowNode *InsetShadowNode // out

	_insetShadowNode = wrapInsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _insetShadowNode
}

// BlurRadius retrieves the blur radius to apply to the shadow.
func (node *InsetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_blur_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the inset shadow.
func (node *InsetShadowNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Dx retrieves the horizontal offset of the inset shadow.
func (node *InsetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_dx(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the inset shadow.
func (node *InsetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_dy(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the inset shadow.
func (node *InsetShadowNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads inwards.
func (node *InsetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_inset_shadow_node_get_spread(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// LinearGradientNode: render node for a linear gradient.
type LinearGradientNode struct {
	RenderNode
}

func wrapLinearGradientNode(obj *externglib.Object) *LinearGradientNode {
	return &LinearGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalLinearGradientNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapLinearGradientNode(obj), nil
}

// NewLinearGradientNode creates a GskRenderNode that will create a linear
// gradient from the given points and color stops, and render that into the area
// given by bounds.
func NewLinearGradientNode(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) *LinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(end)))
	_arg5 = (C.gsize)(len(colorStops))
	if len(colorStops) > 0 {
		_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))
	}

	_cret = C.gsk_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _linearGradientNode *LinearGradientNode // out

	_linearGradientNode = wrapLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _linearGradientNode
}

// ColorStops retrieves the color stops in the gradient.
func (node *LinearGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_linear_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	_colorStops = make([]ColorStop, _arg1)
	copy(_colorStops, unsafe.Slice((*ColorStop)(unsafe.Pointer(_cret)), _arg1))

	return _colorStops
}

// End retrieves the final point of the linear gradient.
func (node *LinearGradientNode) End() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_linear_gradient_node_get_end(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// NColorStops retrieves the number of color stops in the gradient.
func (node *LinearGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_linear_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the initial point of the linear gradient.
func (node *LinearGradientNode) Start() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_linear_gradient_node_get_start(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// OpacityNode: render node controlling the opacity of its single child node.
type OpacityNode struct {
	RenderNode
}

func wrapOpacityNode(obj *externglib.Object) *OpacityNode {
	return &OpacityNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalOpacityNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapOpacityNode(obj), nil
}

// NewOpacityNode creates a GskRenderNode that will drawn the child with reduced
// opacity.
func NewOpacityNode(child RenderNoder, opacity float32) *OpacityNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 C.float          // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = C.float(opacity)

	_cret = C.gsk_opacity_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(opacity)

	var _opacityNode *OpacityNode // out

	_opacityNode = wrapOpacityNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _opacityNode
}

// Child gets the child node that is getting opacityed by the given node.
func (node *OpacityNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_opacity_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Opacity gets the transparency factor for an opacity node.
func (node *OpacityNode) Opacity() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_opacity_node_get_opacity(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// OutsetShadowNode: render node for an outset shadow.
type OutsetShadowNode struct {
	RenderNode
}

func wrapOutsetShadowNode(obj *externglib.Object) *OutsetShadowNode {
	return &OutsetShadowNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalOutsetShadowNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapOutsetShadowNode(obj), nil
}

// NewOutsetShadowNode creates a GskRenderNode that will render an outset shadow
// around the box given by outline.
func NewOutsetShadowNode(outline *RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32) *OutsetShadowNode {
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	_cret = C.gsk_outset_shadow_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)

	var _outsetShadowNode *OutsetShadowNode // out

	_outsetShadowNode = wrapOutsetShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _outsetShadowNode
}

// BlurRadius retrieves the blur radius of the shadow.
func (node *OutsetShadowNode) BlurRadius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_blur_radius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Color retrieves the color of the outset shadow.
func (node *OutsetShadowNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Dx retrieves the horizontal offset of the outset shadow.
func (node *OutsetShadowNode) Dx() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_dx(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Dy retrieves the vertical offset of the outset shadow.
func (node *OutsetShadowNode) Dy() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_dy(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Outline retrieves the outline rectangle of the outset shadow.
func (node *OutsetShadowNode) Outline() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_outline(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// Spread retrieves how much the shadow spreads outwards.
func (node *OutsetShadowNode) Spread() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_outset_shadow_node_get_spread(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RadialGradientNode: render node for a radial gradient.
type RadialGradientNode struct {
	RenderNode
}

func wrapRadialGradientNode(obj *externglib.Object) *RadialGradientNode {
	return &RadialGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRadialGradientNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRadialGradientNode(obj), nil
}

// NewRadialGradientNode creates a GskRenderNode that draws a radial gradient.
//
// The radial gradient starts around center. The size of the gradient is
// dictated by hradius in horizontal orientation and by vradius in vertial
// orientation.
func NewRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) *RadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop     // out
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = (C.gsize)(len(colorStops))
	if len(colorStops) > 0 {
		_arg7 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))
	}

	_cret = C.gsk_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(hradius)
	runtime.KeepAlive(vradius)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _radialGradientNode *RadialGradientNode // out

	_radialGradientNode = wrapRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _radialGradientNode
}

// Center retrieves the center pointer for the gradient.
func (node *RadialGradientNode) Center() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_center(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// ColorStops retrieves the color stops in the gradient.
func (node *RadialGradientNode) ColorStops() []ColorStop {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskColorStop  // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_color_stops(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _colorStops []ColorStop // out

	_colorStops = make([]ColorStop, _arg1)
	copy(_colorStops, unsafe.Slice((*ColorStop)(unsafe.Pointer(_cret)), _arg1))

	return _colorStops
}

// End retrieves the end value for the gradient.
func (node *RadialGradientNode) End() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_end(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Hradius retrieves the horizonal radius for the gradient.
func (node *RadialGradientNode) Hradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_hradius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// NColorStops retrieves the number of color stops in the gradient.
func (node *RadialGradientNode) NColorStops() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_n_color_stops(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Start retrieves the start value for the gradient.
func (node *RadialGradientNode) Start() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_start(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Vradius retrieves the vertical radius for the gradient.
func (node *RadialGradientNode) Vradius() float32 {
	var _arg0 *C.GskRenderNode // out
	var _cret C.float          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_radial_gradient_node_get_vradius(_arg0)
	runtime.KeepAlive(node)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// RepeatNode: render node repeating its single child node.
type RepeatNode struct {
	RenderNode
}

func wrapRepeatNode(obj *externglib.Object) *RepeatNode {
	return &RepeatNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRepeatNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRepeatNode(obj), nil
}

// NewRepeatNode creates a GskRenderNode that will repeat the drawing of child
// across the given bounds.
func NewRepeatNode(bounds *graphene.Rect, child RenderNoder, childBounds *graphene.Rect) *RepeatNode {
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.GskRenderNode   // out
	var _arg3 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	if childBounds != nil {
		_arg3 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(childBounds)))
	}

	_cret = C.gsk_repeat_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(child)
	runtime.KeepAlive(childBounds)

	var _repeatNode *RepeatNode // out

	_repeatNode = wrapRepeatNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatNode
}

// Child retrieves the child of node.
func (node *RepeatNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_repeat_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ChildBounds retrieves the bounding rectangle of the child of node.
func (node *RepeatNode) ChildBounds() *graphene.Rect {
	var _arg0 *C.GskRenderNode   // out
	var _cret *C.graphene_rect_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_repeat_node_get_child_bounds(_arg0)
	runtime.KeepAlive(node)

	var _rect *graphene.Rect // out

	_rect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rect
}

// RepeatingLinearGradientNode: render node for a repeating linear gradient.
type RepeatingLinearGradientNode struct {
	RenderNode
}

func wrapRepeatingLinearGradientNode(obj *externglib.Object) *RepeatingLinearGradientNode {
	return &RepeatingLinearGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRepeatingLinearGradientNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRepeatingLinearGradientNode(obj), nil
}

// NewRepeatingLinearGradientNode creates a GskRenderNode that will create a
// repeating linear gradient from the given points and color stops, and render
// that into the area given by bounds.
func NewRepeatingLinearGradientNode(bounds *graphene.Rect, start *graphene.Point, end *graphene.Point, colorStops []ColorStop) *RepeatingLinearGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(end)))
	_arg5 = (C.gsize)(len(colorStops))
	if len(colorStops) > 0 {
		_arg4 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))
	}

	_cret = C.gsk_repeating_linear_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _repeatingLinearGradientNode *RepeatingLinearGradientNode // out

	_repeatingLinearGradientNode = wrapRepeatingLinearGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingLinearGradientNode
}

func (*RepeatingLinearGradientNode) privateRepeatingLinearGradientNode() {}

// RepeatingRadialGradientNode: render node for a repeating radial gradient.
type RepeatingRadialGradientNode struct {
	RenderNode
}

func wrapRepeatingRadialGradientNode(obj *externglib.Object) *RepeatingRadialGradientNode {
	return &RepeatingRadialGradientNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRepeatingRadialGradientNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRepeatingRadialGradientNode(obj), nil
}

// NewRepeatingRadialGradientNode creates a GskRenderNode that draws a repeating
// radial gradient.
//
// The radial gradient starts around center. The size of the gradient is
// dictated by hradius in horizontal orientation and by vradius in vertial
// orientation.
func NewRepeatingRadialGradientNode(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, colorStops []ColorStop) *RepeatingRadialGradientNode {
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop     // out
	var _arg8 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = (C.gsize)(len(colorStops))
	if len(colorStops) > 0 {
		_arg7 = (*C.GskColorStop)(unsafe.Pointer(&colorStops[0]))
	}

	_cret = C.gsk_repeating_radial_gradient_node_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(hradius)
	runtime.KeepAlive(vradius)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(colorStops)

	var _repeatingRadialGradientNode *RepeatingRadialGradientNode // out

	_repeatingRadialGradientNode = wrapRepeatingRadialGradientNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _repeatingRadialGradientNode
}

func (*RepeatingRadialGradientNode) privateRepeatingRadialGradientNode() {}

// RoundedClipNode: render node applying a rounded rectangle clip to its single
// child.
type RoundedClipNode struct {
	RenderNode
}

func wrapRoundedClipNode(obj *externglib.Object) *RoundedClipNode {
	return &RoundedClipNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalRoundedClipNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapRoundedClipNode(obj), nil
}

// NewRoundedClipNode creates a GskRenderNode that will clip the child to the
// area given by clip.
func NewRoundedClipNode(child RenderNoder, clip *RoundedRect) *RoundedClipNode {
	var _arg1 *C.GskRenderNode  // out
	var _arg2 *C.GskRoundedRect // out
	var _cret *C.GskRenderNode  // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(clip)))

	_cret = C.gsk_rounded_clip_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(clip)

	var _roundedClipNode *RoundedClipNode // out

	_roundedClipNode = wrapRoundedClipNode(externglib.Take(unsafe.Pointer(_cret)))

	return _roundedClipNode
}

// Child gets the child node that is getting clipped by the given node.
func (node *RoundedClipNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_rounded_clip_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Clip retrieves the rounded rectangle used to clip the contents of the node.
func (node *RoundedClipNode) Clip() *RoundedRect {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.GskRoundedRect // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_rounded_clip_node_get_clip(_arg0)
	runtime.KeepAlive(node)

	var _roundedRect *RoundedRect // out

	_roundedRect = (*RoundedRect)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _roundedRect
}

// ShadowNode: render node drawing one or more shadows behind its single child
// node.
type ShadowNode struct {
	RenderNode
}

func wrapShadowNode(obj *externglib.Object) *ShadowNode {
	return &ShadowNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalShadowNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapShadowNode(obj), nil
}

// NewShadowNode creates a GskRenderNode that will draw a child with the given
// shadows below it.
func NewShadowNode(child RenderNoder, shadows []Shadow) *ShadowNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskShadow     // out
	var _arg3 C.gsize
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg3 = (C.gsize)(len(shadows))
	if len(shadows) > 0 {
		_arg2 = (*C.GskShadow)(unsafe.Pointer(&shadows[0]))
	}

	_cret = C.gsk_shadow_node_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(child)
	runtime.KeepAlive(shadows)

	var _shadowNode *ShadowNode // out

	_shadowNode = wrapShadowNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shadowNode
}

// Child retrieves the child GskRenderNode of the shadow node.
func (node *ShadowNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_shadow_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// NShadows retrieves the number of shadows in the node.
func (node *ShadowNode) NShadows() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gsize          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_shadow_node_get_n_shadows(_arg0)
	runtime.KeepAlive(node)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Shadow retrieves the shadow data at the given index i.
func (node *ShadowNode) Shadow(i uint) *Shadow {
	var _arg0 *C.GskRenderNode // out
	var _arg1 C.gsize          // out
	var _cret *C.GskShadow     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))
	_arg1 = C.gsize(i)

	_cret = C.gsk_shadow_node_get_shadow(_arg0, _arg1)
	runtime.KeepAlive(node)
	runtime.KeepAlive(i)

	var _shadow *Shadow // out

	_shadow = (*Shadow)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _shadow
}

// TextNode: render node drawing a set of glyphs.
type TextNode struct {
	RenderNode
}

func wrapTextNode(obj *externglib.Object) *TextNode {
	return &TextNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalTextNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTextNode(obj), nil
}

// NewTextNode creates a render node that renders the given glyphs.
//
// Note that color may not be used if the font contains color glyphs.
func NewTextNode(font pango.Fonter, glyphs *pango.GlyphString, color *gdk.RGBA, offset *graphene.Point) *TextNode {
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 *C.GdkRGBA          // out
	var _arg4 *C.graphene_point_t // out
	var _cret *C.GskRenderNode    // in

	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))
	_arg2 = (*C.PangoGlyphString)(gextras.StructNative(unsafe.Pointer(glyphs)))
	_arg3 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg4 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(offset)))

	_cret = C.gsk_text_node_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(font)
	runtime.KeepAlive(glyphs)
	runtime.KeepAlive(color)
	runtime.KeepAlive(offset)

	var _textNode *TextNode // out

	if _cret != nil {
		_textNode = wrapTextNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _textNode
}

// Color retrieves the color used by the text node.
func (node *TextNode) Color() *gdk.RGBA {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkRGBA       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_color(_arg0)
	runtime.KeepAlive(node)

	var _rgbA *gdk.RGBA // out

	_rgbA = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _rgbA
}

// Font returns the font used by the text node.
func (node *TextNode) Font() pango.Fonter {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.PangoFont     // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_font(_arg0)
	runtime.KeepAlive(node)

	var _font pango.Fonter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.Fonter is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(pango.Fonter)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not pango.Fonter")
		}
		_font = rv
	}

	return _font
}

// Glyphs retrieves the glyph information in the node.
func (node *TextNode) Glyphs() []pango.GlyphInfo {
	var _arg0 *C.GskRenderNode  // out
	var _cret *C.PangoGlyphInfo // in
	var _arg1 C.guint           // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_glyphs(_arg0, &_arg1)
	runtime.KeepAlive(node)

	var _glyphInfos []pango.GlyphInfo // out

	{
		src := unsafe.Slice(_cret, _arg1)
		_glyphInfos = make([]pango.GlyphInfo, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_glyphInfos[i] = *(*pango.GlyphInfo)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
		}
	}

	return _glyphInfos
}

// NumGlyphs retrieves the number of glyphs in the text node.
func (node *TextNode) NumGlyphs() uint {
	var _arg0 *C.GskRenderNode // out
	var _cret C.guint          // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_num_glyphs(_arg0)
	runtime.KeepAlive(node)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Offset retrieves the offset applied to the text.
func (node *TextNode) Offset() *graphene.Point {
	var _arg0 *C.GskRenderNode    // out
	var _cret *C.graphene_point_t // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_get_offset(_arg0)
	runtime.KeepAlive(node)

	var _point *graphene.Point // out

	_point = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _point
}

// HasColorGlyphs checks whether the text node has color glyphs.
func (node *TextNode) HasColorGlyphs() bool {
	var _arg0 *C.GskRenderNode // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_text_node_has_color_glyphs(_arg0)
	runtime.KeepAlive(node)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextureNode: render node for a Texture.
type TextureNode struct {
	RenderNode
}

func wrapTextureNode(obj *externglib.Object) *TextureNode {
	return &TextureNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalTextureNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTextureNode(obj), nil
}

// NewTextureNode creates a GskRenderNode that will render the given texture
// into the area given by bounds.
func NewTextureNode(texture gdk.Texturer, bounds *graphene.Rect) *TextureNode {
	var _arg1 *C.GdkTexture      // out
	var _arg2 *C.graphene_rect_t // out
	var _cret *C.GskRenderNode   // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gsk_texture_node_new(_arg1, _arg2)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(bounds)

	var _textureNode *TextureNode // out

	_textureNode = wrapTextureNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textureNode
}

// Texture retrieves the GdkTexture used when creating this GskRenderNode.
func (node *TextureNode) Texture() gdk.Texturer {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GdkTexture    // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_texture_node_get_texture(_arg0)
	runtime.KeepAlive(node)

	var _texture gdk.Texturer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Texturer is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(gdk.Texturer)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gdk.Texturer")
		}
		_texture = rv
	}

	return _texture
}

// TransformNode: render node applying a GskTransform to its single child node.
type TransformNode struct {
	RenderNode
}

func wrapTransformNode(obj *externglib.Object) *TransformNode {
	return &TransformNode{
		RenderNode: RenderNode{
			Object: obj,
		},
	}
}

func marshalTransformNoder(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTransformNode(obj), nil
}

// NewTransformNode creates a GskRenderNode that will transform the given child
// with the given transform.
func NewTransformNode(child RenderNoder, transform *Transform) *TransformNode {
	var _arg1 *C.GskRenderNode // out
	var _arg2 *C.GskTransform  // out
	var _cret *C.GskRenderNode // in

	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(child.Native()))
	_arg2 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(transform)))

	_cret = C.gsk_transform_node_new(_arg1, _arg2)
	runtime.KeepAlive(child)
	runtime.KeepAlive(transform)

	var _transformNode *TransformNode // out

	_transformNode = wrapTransformNode(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _transformNode
}

// Child gets the child node that is getting transformed by the given node.
func (node *TransformNode) Child() RenderNoder {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_transform_node_get_child(_arg0)
	runtime.KeepAlive(node)

	var _renderNode RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := externglib.Take(objptr)
		rv, ok := (externglib.CastObject(object)).(RenderNoder)
		if !ok {
			panic("object of type " + object.TypeFromInstance().String() + " is not gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// Transform retrieves the GskTransform used by the node.
func (node *TransformNode) Transform() *Transform {
	var _arg0 *C.GskRenderNode // out
	var _cret *C.GskTransform  // in

	_arg0 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

	_cret = C.gsk_transform_node_get_transform(_arg0)
	runtime.KeepAlive(node)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gsk_transform_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/graphene"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// #include <glib-object.h>
import "C"

// GTypeTransform returns the GType for the type Transform.
//
// This function has the side effect of registering a GValue marshaler
// globally. Use this if you need that for any reason. The function is
// concurrently safe to use.
func GTypeTransform() coreglib.Type {
	gtype := coreglib.Type(girepository.MustFind("Gsk", "Transform").RegisteredGType())
	coreglib.RegisterGValueMarshaler(gtype, marshalTransform)
	return gtype
}

// Transform: GskTransform is an object to describe transform matrices.
//
// Unlike graphene_matrix_t, GskTransform retains the steps in how a transform
// was constructed, and allows inspecting them. It is modeled after the way CSS
// describes transforms.
//
// GskTransform objects are immutable and cannot be changed after creation. This
// means code can safely expose them as properties of objects without having to
// worry about others changing them.
//
// An instance of this type is always passed by reference.
type Transform struct {
	*transform
}

// transform is the struct that's finalized.
type transform struct {
	native unsafe.Pointer
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Transform{&transform{(unsafe.Pointer)(b)}}, nil
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {
	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("new", nil, nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// Equal checks two transforms for equality.
//
// The function takes the following parameters:
//
//    - second (optional) transform.
//
// The function returns the following values:
//
//    - ok: TRUE if the two transforms perform the same operation.
//
func (first *Transform) Equal(second *Transform) bool {
	var _args [2]girepository.Argument

	if first != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(first)))
	}
	if second != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(second)))
	}

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("equal", _args[:], nil)
	_cret := *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _ok bool // out

	if *(*C.gboolean)(unsafe.Pointer(&_cret)) != 0 {
		_ok = true
	}

	return _ok
}

// Invert inverts the given transform.
//
// If self is not invertible, NULL is returned. Note that inverting NULL also
// returns NULL, which is the correct inverse of NULL. If you need to
// differentiate between those cases, you should check self is not NULL before
// calling this function.
//
// The function returns the following values:
//
//    - transform (optional): inverted transform or NULL if the transform cannot
//      be inverted.
//
func (self *Transform) Invert() *Transform {
	var _args [1]girepository.Argument

	if self != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	}

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("invert", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _transform *Transform // out

	if *(**C.void)(unsafe.Pointer(&_cret)) != nil {
		_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_transform)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _transform
}

// Matrix multiplies next with the given matrix.
//
// The function takes the following parameters:
//
//    - matrix to multiply next with.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var _args [2]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	*(**C.graphene_matrix_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_matrix_t)(gextras.StructNative(unsafe.Pointer(matrix)))

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("matrix", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(matrix)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// Perspective applies a perspective projection transform.
//
// This transform scales points in X and Y based on their Z value, scaling
// points with positive Z values away from the origin, and those with negative Z
// values towards the origin. Points on the z=0 plane are unchanged.
//
// The function takes the following parameters:
//
//    - depth: distance of the z=0 plane. Lower values give a more flattened
//      pyramid and therefore a more pronounced perspective effect.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Perspective(depth float32) *Transform {
	var _args [2]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(depth)

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("perspective", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(depth)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// Rotate rotates next angle degrees in 2D - or in 3D-speak, around the z axis.
//
// The function takes the following parameters:
//
//    - angle: rotation angle, in degrees (clockwise).
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Rotate(angle float32) *Transform {
	var _args [2]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(angle)

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("rotate", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(angle)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// Rotate3D rotates next angle degrees around axis.
//
// For a rotation in 2D space, use gsk.Transform.Rotate().
//
// The function takes the following parameters:
//
//    - angle: rotation angle, in degrees (clockwise).
//    - axis: rotation axis.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Rotate3D(angle float32, axis *graphene.Vec3) *Transform {
	var _args [3]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(angle)
	*(**C.graphene_vec3_t)(unsafe.Pointer(&_args[2])) = (*C.graphene_vec3_t)(gextras.StructNative(unsafe.Pointer(axis)))

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("rotate_3d", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(angle)
	runtime.KeepAlive(axis)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// Scale scales next in 2-dimensional space by the given factors.
//
// Use gsk.Transform.Scale3D() to scale in all 3 dimensions.
//
// The function takes the following parameters:
//
//    - factorX: scaling factor on the X axis.
//    - factorY: scaling factor on the Y axis.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Scale(factorX float32, factorY float32) *Transform {
	var _args [3]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(factorX)
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(factorY)

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("scale", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(factorX)
	runtime.KeepAlive(factorY)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// Scale3D scales next by the given factors.
//
// The function takes the following parameters:
//
//    - factorX: scaling factor on the X axis.
//    - factorY: scaling factor on the Y axis.
//    - factorZ: scaling factor on the Z axis.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Scale3D(factorX float32, factorY float32, factorZ float32) *Transform {
	var _args [4]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	*(*C.float)(unsafe.Pointer(&_args[1])) = C.float(factorX)
	*(*C.float)(unsafe.Pointer(&_args[2])) = C.float(factorY)
	*(*C.float)(unsafe.Pointer(&_args[3])) = C.float(factorZ)

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("scale_3d", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(factorX)
	runtime.KeepAlive(factorY)
	runtime.KeepAlive(factorZ)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// To2D converts a GskTransform to a 2D transformation matrix.
//
// self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D to check.
//
// The returned values have the following layout:
//
//      | xx yx |   |  a  b  0 |
//      | xy yy | = |  c  d  0 |
//      | dx dy |   | tx ty  1 |
//
//
// This function can be used to convert between a GskTransform and a matrix type
// from other 2D drawing libraries, in particular Cairo.
//
// The function returns the following values:
//
//    - outXx: return location for the xx member.
//    - outYx: return location for the yx member.
//    - outXy: return location for the xy member.
//    - outYy: return location for the yy member.
//    - outDx: return location for the x0 member.
//    - outDy: return location for the y0 member.
//
func (self *Transform) To2D() (outXx float32, outYx float32, outXy float32, outYy float32, outDx float32, outDy float32) {
	var _args [1]girepository.Argument
	var _outs [6]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))

	_info := girepository.MustFind("Gsk", "Transform")
	_info.InvokeRecordMethod("to_2d", _args[:], _outs[:])

	runtime.KeepAlive(self)

	var _outXx float32 // out
	var _outYx float32 // out
	var _outXy float32 // out
	var _outYy float32 // out
	var _outDx float32 // out
	var _outDy float32 // out

	_outXx = float32(*(*C.float)(unsafe.Pointer(&_outs[0])))
	_outYx = float32(*(*C.float)(unsafe.Pointer(&_outs[1])))
	_outXy = float32(*(*C.float)(unsafe.Pointer(&_outs[2])))
	_outYy = float32(*(*C.float)(unsafe.Pointer(&_outs[3])))
	_outDx = float32(*(*C.float)(unsafe.Pointer(&_outs[4])))
	_outDy = float32(*(*C.float)(unsafe.Pointer(&_outs[5])))

	return _outXx, _outYx, _outXy, _outYy, _outDx, _outDy
}

// ToAffine converts a GskTransform to 2D affine transformation factors.
//
// self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_AFFINE to check.
//
// The function returns the following values:
//
//    - outScaleX: return location for the scale factor in the x direction.
//    - outScaleY: return location for the scale factor in the y direction.
//    - outDx: return location for the translation in the x direction.
//    - outDy: return location for the translation in the y direction.
//
func (self *Transform) ToAffine() (outScaleX float32, outScaleY float32, outDx float32, outDy float32) {
	var _args [1]girepository.Argument
	var _outs [4]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))

	_info := girepository.MustFind("Gsk", "Transform")
	_info.InvokeRecordMethod("to_affine", _args[:], _outs[:])

	runtime.KeepAlive(self)

	var _outScaleX float32 // out
	var _outScaleY float32 // out
	var _outDx float32     // out
	var _outDy float32     // out

	_outScaleX = float32(*(*C.float)(unsafe.Pointer(&_outs[0])))
	_outScaleY = float32(*(*C.float)(unsafe.Pointer(&_outs[1])))
	_outDx = float32(*(*C.float)(unsafe.Pointer(&_outs[2])))
	_outDy = float32(*(*C.float)(unsafe.Pointer(&_outs[3])))

	return _outScaleX, _outScaleY, _outDx, _outDy
}

// ToMatrix computes the actual value of self and stores it in out_matrix.
//
// The previous value of out_matrix will be ignored.
//
// The function returns the following values:
//
//    - outMatrix: matrix to set.
//
func (self *Transform) ToMatrix() *graphene.Matrix {
	var _args [1]girepository.Argument
	var _outs [1]girepository.Argument

	if self != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	}

	_info := girepository.MustFind("Gsk", "Transform")
	_info.InvokeRecordMethod("to_matrix", _args[:], _outs[:])

	runtime.KeepAlive(self)

	var _outMatrix *graphene.Matrix // out

	_outMatrix = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_matrix_t)(unsafe.Pointer(&_outs[0])))))

	return _outMatrix
}

// String converts a matrix into a string that is suitable for printing.
//
// The resulting string can be parsed with gsk.Transform().Parse.
//
// This is a wrapper around gsk.Transform.Print().
//
// The function returns the following values:
//
//    - utf8: new string for self.
//
func (self *Transform) String() string {
	var _args [1]girepository.Argument

	if self != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	}

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("to_string", _args[:], nil)
	_cret := *(**C.char)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret)))))
	defer C.free(unsafe.Pointer(*(**C.char)(unsafe.Pointer(&_cret))))

	return _utf8
}

// ToTranslate converts a GskTransform to a translation operation.
//
// self must be a 2D transformation. If you are not sure, use
// gsk_transform_get_category() >= GSK_TRANSFORM_CATEGORY_2D_TRANSLATE to check.
//
// The function returns the following values:
//
//    - outDx: return location for the translation in the x direction.
//    - outDy: return location for the translation in the y direction.
//
func (self *Transform) ToTranslate() (outDx float32, outDy float32) {
	var _args [1]girepository.Argument
	var _outs [2]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))

	_info := girepository.MustFind("Gsk", "Transform")
	_info.InvokeRecordMethod("to_translate", _args[:], _outs[:])

	runtime.KeepAlive(self)

	var _outDx float32 // out
	var _outDy float32 // out

	_outDx = float32(*(*C.float)(unsafe.Pointer(&_outs[0])))
	_outDy = float32(*(*C.float)(unsafe.Pointer(&_outs[1])))

	return _outDx, _outDy
}

// Transform applies all the operations from other to next.
//
// The function takes the following parameters:
//
//    - other (optional): transform to apply.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Transform(other *Transform) *Transform {
	var _args [2]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	if other != nil {
		*(**C.void)(unsafe.Pointer(&_args[1])) = (*C.void)(gextras.StructNative(unsafe.Pointer(other)))
	}

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("transform", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(other)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// TransformBounds transforms a graphene_rect_t using the given transform self.
//
// The result is the bounding box containing the coplanar quad.
//
// The function takes the following parameters:
//
//    - rect: graphene_rect_t.
//
// The function returns the following values:
//
//    - outRect: return location for the bounds of the transformed rectangle.
//
func (self *Transform) TransformBounds(rect *graphene.Rect) *graphene.Rect {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(**C.graphene_rect_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(rect)))

	_info := girepository.MustFind("Gsk", "Transform")
	_info.InvokeRecordMethod("transform_bounds", _args[:], _outs[:])

	runtime.KeepAlive(self)
	runtime.KeepAlive(rect)

	var _outRect *graphene.Rect // out

	_outRect = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_rect_t)(unsafe.Pointer(&_outs[0])))))

	return _outRect
}

// TransformPoint transforms a graphene_point_t using the given transform self.
//
// The function takes the following parameters:
//
//    - point: graphene_point_t.
//
// The function returns the following values:
//
//    - outPoint: return location for the transformed point.
//
func (self *Transform) TransformPoint(point *graphene.Point) *graphene.Point {
	var _args [2]girepository.Argument
	var _outs [1]girepository.Argument

	*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	*(**C.graphene_point_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	_info := girepository.MustFind("Gsk", "Transform")
	_info.InvokeRecordMethod("transform_point", _args[:], _outs[:])

	runtime.KeepAlive(self)
	runtime.KeepAlive(point)

	var _outPoint *graphene.Point // out

	_outPoint = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer(*(**C.graphene_point_t)(unsafe.Pointer(&_outs[0])))))

	return _outPoint
}

// Translate translates next in 2-dimensional space by point.
//
// The function takes the following parameters:
//
//    - point to translate the transform by.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Translate(point *graphene.Point) *Transform {
	var _args [2]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	*(**C.graphene_point_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("translate", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(point)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

// Translate3D translates next by point.
//
// The function takes the following parameters:
//
//    - point to translate the transform by.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var _args [2]girepository.Argument

	if next != nil {
		*(**C.void)(unsafe.Pointer(&_args[0])) = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	*(**C.graphene_point3d_t)(unsafe.Pointer(&_args[1])) = (*C.graphene_point3d_t)(gextras.StructNative(unsafe.Pointer(point)))

	_info := girepository.MustFind("Gsk", "Transform")
	_gret := _info.InvokeRecordMethod("translate_3d", _args[:], nil)
	_cret := *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(point)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(*(**C.void)(unsafe.Pointer(&_cret)))))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _transform
}

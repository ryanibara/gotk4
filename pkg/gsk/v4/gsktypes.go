// Code generated by girgen. DO NOT EDIT.

package gsk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/graphene"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
import "C"

// glib.Type values for gsktypes.go.
var GTypeTransform = coreglib.Type(C.gsk_transform_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeTransform, F: marshalTransform},
	})
}

// Transform: GskTransform is an object to describe transform matrices.
//
// Unlike graphene_matrix_t, GskTransform retains the steps in how a transform
// was constructed, and allows inspecting them. It is modeled after the way CSS
// describes transforms.
//
// GskTransform objects are immutable and cannot be changed after creation. This
// means code can safely expose them as properties of objects without having to
// worry about others changing them.
//
// An instance of this type is always passed by reference.
type Transform struct {
	*transform
}

// transform is the struct that's finalized.
type transform struct {
	native *C.GskTransform
}

func marshalTransform(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Transform{&transform{(*C.GskTransform)(b)}}, nil
}

// NewTransform constructs a struct Transform.
func NewTransform() *Transform {
	var _cret *C.void // in

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Equal checks two transforms for equality.
//
// The function takes the following parameters:
//
//    - second (optional) transform.
//
// The function returns the following values:
//
//    - ok: TRUE if the two transforms perform the same operation.
//
func (first *Transform) Equal(second *Transform) bool {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 *C.void    // out
	var _cret C.gboolean // in

	if first != nil {
		_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(first)))
	}
	if second != nil {
		_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(second)))
	}
	*(**Transform)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Invert inverts the given transform.
//
// If self is not invertible, NULL is returned. Note that inverting NULL also
// returns NULL, which is the correct inverse of NULL. If you need to
// differentiate between those cases, you should check self is not NULL before
// calling this function.
//
// The function returns the following values:
//
//    - transform (optional): inverted transform or NULL if the transform cannot
//      be inverted.
//
func (self *Transform) Invert() *Transform {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	if self != nil {
		_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	}
	*(**Transform)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _transform *Transform // out

	if _cret != nil {
		_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_transform)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gsk_transform_unref((*C.GskTransform)(intern.C))
			},
		)
	}

	return _transform
}

// Matrix multiplies next with the given matrix.
//
// The function takes the following parameters:
//
//    - matrix to multiply next with.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Matrix(matrix *graphene.Matrix) *Transform {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	if next != nil {
		_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(matrix)))
	*(**Transform)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(matrix)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// String converts a matrix into a string that is suitable for printing.
//
// The resulting string can be parsed with gsk.Transform().Parse.
//
// This is a wrapper around gsk.Transform.Print().
//
// The function returns the following values:
//
//    - utf8: new string for self.
//
func (self *Transform) String() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	if self != nil {
		_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(self)))
	}
	*(**Transform)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Transform applies all the operations from other to next.
//
// The function takes the following parameters:
//
//    - other (optional): transform to apply.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Transform(other *Transform) *Transform {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	if next != nil {
		_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	if other != nil {
		_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(other)))
	}
	*(**Transform)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(other)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Translate translates next in 2-dimensional space by point.
//
// The function takes the following parameters:
//
//    - point to translate the transform by.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Translate(point *graphene.Point) *Transform {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	if next != nil {
		_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(point)))
	*(**Transform)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(point)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}

// Translate3D translates next by point.
//
// The function takes the following parameters:
//
//    - point to translate the transform by.
//
// The function returns the following values:
//
//    - transform: new transform.
//
func (next *Transform) Translate3D(point *graphene.Point3D) *Transform {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out
	var _cret *C.void // in

	if next != nil {
		_arg0 = (*C.void)(gextras.StructNative(unsafe.Pointer(next)))
	}
	_arg1 = (*C.void)(gextras.StructNative(unsafe.Pointer(point)))
	*(**Transform)(unsafe.Pointer(&args[1])) = _arg1

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(next)
	runtime.KeepAlive(point)

	var _transform *Transform // out

	_transform = (*Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_transform)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gsk_transform_unref((*C.GskTransform)(intern.C))
		},
	)

	return _transform
}
